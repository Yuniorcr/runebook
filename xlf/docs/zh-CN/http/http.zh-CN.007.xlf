<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="d62340e78d8072dcadbb02101963582d73906639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">该 &lt;code&gt;CONNECT&lt;/code&gt; 方法开始与所请求的资源双向通信。它可以用来打开隧道。</target>
        </trans-unit>
        <trans-unit id="d8e201387bc9b6658a40f0cd1fa9bd028389520f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df08e573a851328603ffe071d7221d02feef0bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header holds &lt;em&gt;directives&lt;/em&gt; (instructions) for &lt;a href=&quot;../caching&quot;&gt;caching&lt;/a&gt; in both requests and responses. A given directive in a request does not mean the same directive should be in the response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb3aeaa30daf04257b5de4b9c07c7b9084e9851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; general-header field is used to specify directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.</source>
          <target state="translated">所述 &lt;code&gt;Cache-Control&lt;/code&gt; 通用头字段被用于为请求和响应缓存机制指定指令。高速缓存伪指令是单向的，这意味着请求中的给定伪指令并不意味着在响应中将给出相同的伪指令。</target>
        </trans-unit>
        <trans-unit id="06a62b505dd9b8d1a88549c8be79a0204c13ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c781f98a9ab9c12f19392e18737aa478f857a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-control&lt;/code&gt; header</source>
          <target state="translated">所述 &lt;code&gt;Cache-control&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="c446d7df905a8656f6c8ae1eb3467db307c496ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header accepts one or more directives. If all types of data should be cleared, the wildcard directive (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) can be used.</source>
          <target state="translated">的 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 报头接受一个或多个指令。如果应清除所有类型的数据，则可以使用通配符指令（ &lt;code&gt;&quot;*&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aaa643bf0a85cb5496af99271031c5e3d158467e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header clears browsing data (cookies, storage, cache) associated with the requesting website. It allows web developers to have more control over the data stored locally by a browser for their origins.</source>
          <target state="translated">在 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 头清除浏览与请求网站相关的数据（饼干，存储，高速缓存）。它使Web开发人员可以更好地控制浏览器在本地存储的数据来源。</target>
        </trans-unit>
        <trans-unit id="f577eabd139f31271f00d10bbba8aad8ea919cc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is &lt;code&gt;keep-alive&lt;/code&gt;, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.</source>
          <target state="translated">该 &lt;code&gt;Connection&lt;/code&gt; 一般报头控制是否该网络连接保持在当前事务结束后打开。如果发送的值是 &lt;code&gt;keep-alive&lt;/code&gt; ，则连接是持久的并且不会关闭，从而允许对同一服务器的后续请求得以完成。</target>
        </trans-unit>
        <trans-unit id="d537fcd6c95a2057cfd4527c292424b94b1ea111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; header is set to &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; to indicate that an upgrade is requested.</source>
          <target state="translated">该 &lt;code&gt;Connection&lt;/code&gt; 头被设置为 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; ，以表明升级请求。</target>
        </trans-unit>
        <trans-unit id="2861dc12e30d4470a55eeb695e751b55e5e6a33a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Disposition&lt;/code&gt; header is defined in the larger context of MIME messages for e-mail, but only a subset of the possible parameters apply to HTTP forms and &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. Only the value &lt;code&gt;form-data&lt;/code&gt;, as well as the optional directive &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, can be used in the HTTP context.</source>
          <target state="translated">的 &lt;code&gt;Content-Disposition&lt;/code&gt; 报头在MIME消息的电子邮件的更大的范围内定义的，但仅可能的参数的子集应用于HTTP形式和&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求。HTTP上下文中只能使用值 &lt;code&gt;form-data&lt;/code&gt; 以及可选的伪指令 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="488c45ed82b63009ef20ba093e068984681301a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Encoding&lt;/code&gt; entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">所述 &lt;code&gt;Content-Encoding&lt;/code&gt; 实体报头被用于压缩媒体类型。如果存在，则其值指示将哪些编码应用于实体。它让客户端知道如何解码以获得由 &lt;code&gt;Content-Type&lt;/code&gt; 标头引用的媒体类型。</target>
        </trans-unit>
        <trans-unit id="43905a4350aba1098e2a710d64c8e9ee9088db8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt; header is used to specify the &lt;strong&gt; intended audience of the page&lt;/strong&gt;, and can indicate that this is more than one language.</source>
          <target state="translated">在 &lt;code&gt;Content-Language&lt;/code&gt; 头用于指定&lt;strong&gt;页面的目标受众&lt;/strong&gt;，并能表明这是一种以上的语言。</target>
        </trans-unit>
        <trans-unit id="76fdb5d41ede9d4b6ff14e156b9fc840583f22aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to &lt;strong&gt;describe the language(s) intended for the audience&lt;/strong&gt;, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7cdf9f8259b0b027b83c7eabaf300c7bb40cfcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">的 &lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;实体头&lt;/a&gt;用于描述语言（一个或多个），用于对于观众来说，使得其允许用户根据用户自己的优选语言区分。</target>
        </trans-unit>
        <trans-unit id="9ceb94b4b8102114799b44b32b66d5292b6f1285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Length&lt;/code&gt; entity header indicates the size of the entity-body, in bytes, sent to the recipient.</source>
          <target state="translated">在 &lt;code&gt;Content-Length&lt;/code&gt; 的实体报头指示实体主体的大小，以字节为单位，发送到接收方。</target>
        </trans-unit>
        <trans-unit id="5d90bdb5582a8fea93b884b09c9eb8e68632eacc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Location&lt;/code&gt; header indicates an alternate location for the returned data. The principal use is to indicate the URL of a resource transmitted as the result of &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Content-Location&lt;/code&gt; 报头指示为返回的数据的备用位置。主要用途是指示作为&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;结果传输的资源的URL 。</target>
        </trans-unit>
        <trans-unit id="23071b7ae3831b0ab8df674533efac8686372e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Range&lt;/code&gt; response HTTP header indicates where in a full body message a partial message belongs.</source>
          <target state="translated">的 &lt;code&gt;Content-Range&lt;/code&gt; 响应HTTP报头指示其中一个完整的身体信息的部分消息所属。</target>
        </trans-unit>
        <trans-unit id="7a62e0c2806ef55661c99afdb86b1f8e171c816e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;strong&gt;&lt;dfn&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/dfn&gt;&lt;/strong&gt; HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda7fd480680111156c0cfd188e09b05c5966f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Type&lt;/code&gt; entity header is used to indicate the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;media type&lt;/a&gt; of the resource.</source>
          <target state="translated">的 &lt;code&gt;Content-Type&lt;/code&gt; 实体报头用于指示所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;媒体类型&lt;/a&gt;的资源的。</target>
        </trans-unit>
        <trans-unit id="426d10d47e9cd0040a6dc32d3445f661ae1dd5ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; HTTP request header contains stored &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">所述 &lt;code&gt;Cookie&lt;/code&gt; 的HTTP请求报头包含存储&lt;a href=&quot;../cookies&quot;&gt;的HTTP cookies&lt;/a&gt;先前通过与所述服务器发送&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;报头。</target>
        </trans-unit>
        <trans-unit id="55cd10bb3eab56fcb3aaa9ed9e419b3b3cdd6947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; header is optional and may be omitted if, for example, the browser's privacy settings block cookies.</source>
          <target state="translated">所述 &lt;code&gt;Cookie&lt;/code&gt; 头是可选的，并且如果例如，在浏览器的隐私设置阻止Cookie可以被省略。</target>
        </trans-unit>
        <trans-unit id="906194f2cbb1fc47870cf91c47d3fd010f4ebd31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; deletes the specified resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82dc9f4d351ce501d0f5c9cfab64763375d85ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; method deletes the specified resource.</source>
          <target state="translated">该 &lt;code&gt;DELETE&lt;/code&gt; 方法删除指定的资源。</target>
        </trans-unit>
        <trans-unit id="52d55ecc480b283f141b3b6f98cde8cb0145d572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DNT&lt;/code&gt; (&lt;strong&gt;D&lt;/strong&gt;o &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;T&lt;/strong&gt;rack) request header indicates the user's tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.</source>
          <target state="translated">该 &lt;code&gt;DNT&lt;/code&gt; （&lt;strong&gt;d&lt;/strong&gt; &amp;oslash; &lt;strong&gt;&amp;Ntilde;&lt;/strong&gt; OT &lt;strong&gt;Ť&lt;/strong&gt;机架）请求报头指示该用户的跟踪的偏好。它可以让用户指出他们是否更喜欢隐私而不是个性化内容。</target>
        </trans-unit>
        <trans-unit id="71ac6b7e2c0b37cbc89c1ece6a483f1521bccee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; general HTTP header contains the date and time at which the message was originated.</source>
          <target state="translated">的 &lt;code&gt;Date&lt;/code&gt; 一般HTTP报头包含在该消息起源的日期和时间。</target>
        </trans-unit>
        <trans-unit id="fca5c6f26004ba8e513493500c35759b7d8670d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; attributes define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b1269bf21dd422aa77c2c9c23ee0803a5f37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; directives define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">该 &lt;code&gt;Domain&lt;/code&gt; 和 &lt;code&gt;Path&lt;/code&gt; 指示定义&lt;em&gt;范围&lt;/em&gt;的cookie：什么网址，饼干应送。</target>
        </trans-unit>
        <trans-unit id="bae089f0efeafa75b1ab5dc8946d17d6e70ec21e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; attribute specifies which hosts are allowed to receive the cookie. If unspecified, it defaults to the same &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt; that set the cookie, &lt;em&gt;excluding subdomains&lt;/em&gt;. If &lt;code&gt;Domain&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; specified, then subdomains are always included. Therefore, specifying &lt;code&gt;Domain&lt;/code&gt; is less restrictive than omitting it. However, it can be helpful when subdomains need to share information about a user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c5ea9e0e528b35e54f97738194b2df17917c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (&quot;mid-air collisions&quot;).</source>
          <target state="translated">的 &lt;code&gt;ETag&lt;/code&gt; 的 HTTP响应报头为资源的特定版本的标识符。它可以使缓存更高效，并节省带宽，因为如果内容未更改，Web服务器不需要发送完整的响应。另一方面，如果内容已更改，则etag有助于防止资源的同时更新相互覆盖（&amp;ldquo;空中冲突&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="08646657870bfe9fc25378ffe7f57b55887a674a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content has not changed. Additionally, etags help prevent simultaneous updates of a resource from overwriting each other (&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;&quot;mid-air collisions&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b330412716d107192b6533fb30bf1581cd40ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Early-Data&lt;/code&gt; header is &lt;strong&gt;not&lt;/strong&gt; set by the originator of the request (i.e., a browser).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26733480324535c0741d6a6528e1941641f5ce19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">在 &lt;code&gt;Expect-CT&lt;/code&gt; 头部允许以报告和/或证书透明度的要求执行，这将阻止使用misissued证书进行的忽视该网站站点选择。</target>
        </trans-unit>
        <trans-unit id="d45aa61794fa19b9937294984a26564b7a2b70b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">在 &lt;code&gt;Expect-CT&lt;/code&gt; 头部允许以报告和/或证书透明度的要求执行，这将阻止使用misissued证书进行的忽视该网站站点选择。当站点启用 &lt;code&gt;Expect-CT&lt;/code&gt; 标头时，他们正在请求浏览器检查该站点的任何证书是否出现在公共CT日志中。</target>
        </trans-unit>
        <trans-unit id="5a38756d00a5a11b921674c4de083e3755d47807" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header lets sites opt in to reporting and/or enforcement of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; requirements, to prevent the use of misissued certificates for that site from going unnoticed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5d41eb6b835eb5ad3b6e94b607f55e721d9fdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; will likely become obsolete in June 2021. Since May 2018 new certificates are expected to support SCTs by default. Certificates before March 2018 were allowed to have a lifetime of 39 months, those will all be expired in June 2021.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f567c805d3b14ec3ccf5444b3918351ca629ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect&lt;/code&gt; HTTP request header indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">该 &lt;code&gt;Expect&lt;/code&gt; HTTP请求头表示期望，需要通过服务器才能满足妥善处理该请求。</target>
        </trans-unit>
        <trans-unit id="ea971246a330c3fd5b0ad3d128ebdbac36f3fb88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Feature-Policy&lt;/code&gt; header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9092e5df3d3c5b1e6e4085ebcd0973332a4819a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the &lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;reverse proxy servers&lt;/a&gt; that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43b4a38f617b0e601765fc7fa48f903467c8a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">的 &lt;code&gt;Forwarded&lt;/code&gt; 报头包含来自被改变或丢失时代理参与请求的路径代理服务器的面向客户端的信息。</target>
        </trans-unit>
        <trans-unit id="e7acf99131e3b502a504dfc606eb81c2fa8a3438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; method requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">该 &lt;code&gt;GET&lt;/code&gt; 方法请求指定资源的表示。使用 &lt;code&gt;GET&lt;/code&gt; 的请求应仅检索数据。</target>
        </trans-unit>
        <trans-unit id="f4a622f1f455f51e4324f29b7983e11b4aa63399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">该 &lt;code&gt;GET&lt;/code&gt; 请求指定资源的表示。使用 &lt;code&gt;GET&lt;/code&gt; 的请求应仅检索数据。</target>
        </trans-unit>
        <trans-unit id="fe2a61ce5f6f874b6cccf46f639263ba9a7751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; method asks for a response identical to that of a &lt;code&gt;GET&lt;/code&gt; request, but without the response body.</source>
          <target state="translated">的 &lt;code&gt;HEAD&lt;/code&gt; 方法请求等同于一个的响应 &lt;code&gt;GET&lt;/code&gt; 请求，但是没有响应体。</target>
        </trans-unit>
        <trans-unit id="8ab0b6ae10182c291f380700fbca30952dcca777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the &lt;a href=&quot;../headers&quot;&gt;headers&lt;/a&gt; that would be returned if the &lt;code&gt;HEAD&lt;/code&gt; request's URL was instead requested with the HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. For example, if a URL might produce a large download, a &lt;code&gt;HEAD&lt;/code&gt; request could read its &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header to check the filesize without actually downloading the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcdb3000e143a76a0cbe83303746d3c1a0deba82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the headers that are returned if the specified resource would be requested with an HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</source>
          <target state="translated">该 &lt;code&gt;HEAD&lt;/code&gt; 请求如果指定的资源将通过一个HTTP请求所返回的头&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法。例如，可以在决定下载大量资源以节省带宽之前完成此请求。</target>
        </trans-unit>
        <trans-unit id="25050b6d25bf48e5e860b9e13a504c685ed5f20b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HttpOnly&lt;/code&gt; cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript.</source>
          <target state="translated">在 &lt;code&gt;HttpOnly&lt;/code&gt; cookie的属性可以帮助缓解防止通过JavaScript访问cookie值这种攻击。</target>
        </trans-unit>
        <trans-unit id="4db136fae95161e355b0319d6e24b7eb8dde4690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource only if it matches one of the listed &lt;code&gt;ETags&lt;/code&gt;. For &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and other non-safe methods, it will only upload the resource in this case.</source>
          <target state="translated">的 &lt;code&gt;If-Match&lt;/code&gt; 的HTTP请求报头使得所述请求为条件。对于&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法，服务器仅在与列出的 &lt;code&gt;ETags&lt;/code&gt; 之一匹配时才发送回所请求的资源。对于&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;和其他非安全方法，在这种情况下，它将仅上载资源。</target>
        </trans-unit>
        <trans-unit id="89b34bc5ae9734af9081d0e5ea57512f4460ba59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Modified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; without any body; the &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header of a previous request will contain the date of last modification. Unlike &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Modified-Since&lt;/code&gt; can only be used with a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;If-Modified-Since&lt;/code&gt; 请求HTTP标头发出请求的条件：服务器会发送回所请求的资源，具有&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; 种&lt;/a&gt;状态，只有当它已经给定的日期之后被最后修改。如果此后未修改请求，则响应为&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; ,&lt;/a&gt;没有任何正文；&lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;一个请求的Last-Modified响应标头将包含上次修改的日期。与&lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 不同&lt;/a&gt;， &lt;code&gt;If-Modified-Since&lt;/code&gt; 只能与&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; 一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5986b8f11ba0994d8a72e97fe21f90cc137ceae5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-None-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it doesn't have an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; matching the given ones. For other methods, the request will be processed only if the eventually existing resource's &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; doesn't match any of the values listed.</source>
          <target state="translated">所述 &lt;code&gt;If-None-Match&lt;/code&gt; 的HTTP请求报头使得所述请求为条件。对于&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法，仅当服务器没有与给定资源匹配的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; 时&lt;/a&gt;，服务器才会以&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;状态发送回请求的资源。对于其他方法，仅当最终现有资源的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;与列出的任何值都不匹配时，才会处理请求。</target>
        </trans-unit>
        <trans-unit id="2724d0a408c5f3bcd5c0014c571f5f10868e51ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Range&lt;/code&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">在 &lt;code&gt;If-Range&lt;/code&gt; HTTP请求头生产一系列要求条件：如果条件满足，范围请求将被发出，服务器发回&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 用适当的身体答案。如果不满足该条件，则以&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 状态发送完整资源。</target>
        </trans-unit>
        <trans-unit id="22163b61a8a59a375d09bff2ee1f49eb81aa2552" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">在 &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 请求的HTTP标头，使有条件的请求：服务器会发送回所请求的资源，或者接受它的情况下&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;或其他非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;方法，只有当它尚未最后给出修改后日期。如果在给定日期之后修改了请求，则响应将是&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（失败的前提条件）错误。</target>
        </trans-unit>
        <trans-unit id="33d2652dcdd336882d1ff7dcd4aab424143119d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the resource has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">在 &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 请求的HTTP标头，使有条件的请求：服务器会发送回所请求的资源，或者接受它的情况下&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;或其他非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;方法，只有当它尚未最后给出修改后日期。如果资源已在指定日期之后被修改，响应将是&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（预处理失败）错误。</target>
        </trans-unit>
        <trans-unit id="c6e9dbc2bd4ee3beeb7dae2fbab0d0ed4f0f0c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Large-Allocation&lt;/code&gt; header throws warnings or error messages when used incorrectly. You'll encounter them in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;web console&lt;/a&gt;.</source>
          <target state="translated">如果使用不正确， &lt;code&gt;Large-Allocation&lt;/code&gt; 标头将引发警告或错误消息。您将在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;网络控制台中&lt;/a&gt;遇到它们。</target>
        </trans-unit>
        <trans-unit id="1f7bbba0c2fe1da5cfd40ee4dbb5a457286f63d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last-Modified&lt;/code&gt; response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header, it is a fallback mechanism. Conditional requests containing &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers make use of this field.</source>
          <target state="translated">在 &lt;code&gt;Last-Modified&lt;/code&gt; 响应HTTP报头包含在其原始服务器认为该资源的最后修改的日期和时间。它用作验证器来确定接收或存储的资源是否相同。不如&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;标头准确，它是一种后备机制。包含&lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;标头的条件请求将使用此字段。</target>
        </trans-unit>
        <trans-unit id="408faa70ae199f0916e25f0545a45cf1159c3a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Location&lt;/code&gt; response header indicates the URL to redirect a page to. It only provides a meaning when served with a &lt;code&gt;3xx&lt;/code&gt; (redirection) or &lt;code&gt;201&lt;/code&gt; (created) status response.</source>
          <target state="translated">该 &lt;code&gt;Location&lt;/code&gt; 响应头表示URL的页面重定向到。它仅在提供 &lt;code&gt;3xx&lt;/code&gt; （重定向）或 &lt;code&gt;201&lt;/code&gt; （已创建）状态响应时提供含义。</target>
        </trans-unit>
        <trans-unit id="7d4bbe1245321cac039158aa76ac84b747faeeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</source>
          <target state="translated">该 &lt;code&gt;OPTIONS&lt;/code&gt; 是用来描述目标资源的通讯选择。客户端可以为OPTIONS方法指定URL，也可以为星号（*）指定整个服务器。</target>
        </trans-unit>
        <trans-unit id="87018d773f4ad1701e531629a9f995260745c1b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; method is used to describe the communication options for the target resource.</source>
          <target state="translated">的 &lt;code&gt;OPTIONS&lt;/code&gt; 方法被用来描述用于目标资源的通信选项。</target>
        </trans-unit>
        <trans-unit id="a6e38b6b645f385912507ae1ea58453222ae125b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; requests permitted communication options for a given URL or server. A client can specify a URL with this method, or an asterisk (&lt;code&gt;*&lt;/code&gt;) to refer to the entire server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a07a0f8f183e5dac76997068b2e3c2b7238732b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Origin&lt;/code&gt; request header indicates where a fetch originates from. It doesn't include any path information, but only the server name. It is sent with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests, as well as with &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. It is similar to the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, but, unlike this header, it doesn't disclose the whole path.</source>
          <target state="translated">的 &lt;code&gt;Origin&lt;/code&gt; 请求报头指示其中一个取从起源。它不包含任何路径信息，而仅包含服务器名称。它与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求以及&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求一起发送。它与&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;标头类似，但是与标头不同，它没有公开整个路径。</target>
        </trans-unit>
        <trans-unit id="fbfda01971457a54151941075f2b100b82e48523" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; applies partial modifications to a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9159e5596093f157b377894f822a924c1cb222b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; method is used to apply partial modifications to a resource.</source>
          <target state="translated">该 &lt;code&gt;PATCH&lt;/code&gt; 方法用于局部修改应用到的资源。</target>
        </trans-unit>
        <trans-unit id="1f5331c568d957daee441f1fc46cb653dfa3c711" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.</source>
          <target state="translated">该 &lt;code&gt;POST&lt;/code&gt; 方法用于提交一个实体到指定的资源，往往造成在服务器上的状态或副作用的变化。</target>
        </trans-unit>
        <trans-unit id="3be3fad872235976dca00e40191bbd8a2412e11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; sends data to the server. The type of the body of the request is indicated by the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">该 &lt;code&gt;POST&lt;/code&gt; 将数据发送到服务器。请求主体的&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;由Content-Type标头指示。</target>
        </trans-unit>
        <trans-unit id="fa5fa4af532ebd69d21f151a379cfa743406c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05eb025eb7c8b4be7ac86b298f646c06fa3ba3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; method replaces all current representations of the target resource with the request payload.</source>
          <target state="translated">该 &lt;code&gt;PUT&lt;/code&gt; 方法替换请求负载目标资源的所有当前表示。</target>
        </trans-unit>
        <trans-unit id="6881c728a58c81e16c491c3900a0cb662b6f7797" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; attribute indicates a URL path that must exist in the requested URL in order to send the &lt;code&gt;Cookie&lt;/code&gt; header. The &lt;code&gt;%x2F&lt;/code&gt; (&quot;/&quot;) character is considered a directory separator, and subdirectories match as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c89f21cbe09b59b1b9abe85e9acdd8ee45935d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pragma&lt;/code&gt; header</source>
          <target state="translated">该 &lt;code&gt;Pragma&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="d99324cd748dcc4ddf7bf1ab613ab29af0de9abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Proxy-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Proxy-Authenticate&lt;/code&gt; 报头与一个发送沿&lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38b88eeb5a1167fff3d87ac75a5f9789ffbc4ed1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b15d048b735cd58d12cb36f1c04b433a92d0de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">的 &lt;code&gt;Range&lt;/code&gt; 的HTTP请求报头指示一个文件，该服务器应返回的一部分。可以一次请求一个 &lt;code&gt;Range&lt;/code&gt; 标头来请求多个部分，服务器可以将这些范围发送回多部分文档中。如果服务器发回范围，则它将&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 用于响应。如果范围无效，则服务器返回&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Range Not Satisfiable&lt;/code&gt; 错误。服务器还可以忽略 &lt;code&gt;Range&lt;/code&gt; 标头，并以&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;状态代码返回整个文档。</target>
        </trans-unit>
        <trans-unit id="5d730336d5f314e4ffb348e65cc342c819634ceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header governs which referrer information, sent in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, should be included with requests made.</source>
          <target state="translated">所述 &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP头共治其中引荐信息，在所发送&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;报头，应包含的请求。</target>
        </trans-unit>
        <trans-unit id="76239ca8ee1c72f207bd371031df7511a9737ea4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTP header&lt;/a&gt; controls how much &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;referrer information&lt;/a&gt; (sent via the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header) should be included with requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471a084b48fd4c8723f09a90baa8df53c1cd93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Retry-After&lt;/code&gt; response HTTP header indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:</source>
          <target state="translated">的 &lt;code&gt;Retry-After&lt;/code&gt; 响应HTTP报头指示所述用户代理应该多长时间使一个后续请求之前等待。使用此标头的主要情况有三种：</target>
        </trans-unit>
        <trans-unit id="12bf22b5dbc2a8c45c1d6d8c1615396a45809438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute lets servers require that a cookie shouldn't be sent with cross-origin requests (where &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;Site&lt;/a&gt; is defined by the registrable domain), which provides some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6374aa4b75562bedbe4aa399825eadf45d2253c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header specifies one or more WebSocket protocols that you wish to use, in order of preference. The first one that is supported by the server will be selected and returned by the server in a &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header included in the response. You can use this more than once in the header, as well; the result is the same as if you used a comma-delineated list of subprotocol identifiers in a single header.</source>
          <target state="translated">该 &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 头指定的一个或多个的WebSocket协议，您要使用，按优先顺序。服务器支持的第一个服务器将在响应中包含的 &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 标头中选择并返回。您也可以在标题中多次使用它；结果与在单个标头中使用逗号分隔的子协议标识符列表相同。</target>
        </trans-unit>
        <trans-unit id="bcaa9b003cfb51a580c36805f7e5708f883883c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header communicates one or more metrics and descriptions for a given request-response cycle. It is used to surface any backend server timing metrics (e.g. database read/write, CPU time, file system access, etc.) in the developer tools in the user's browser or in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">所述 &lt;code&gt;Server-Timing&lt;/code&gt; 头连通的一个或多个度量和说明对于给定的请求响应周期。它用于在用户浏览器或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt;界面中的开发人员工具中显示任何后端服务器计时指标（例如，数据库读/写，CPU时间，文件系统访问等）。</target>
        </trans-unit>
        <trans-unit id="58ba7a6637e80a2b7ed529a9998dc728401d3c92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header may expose potentially sensitive application and infrastructure information. Consider to control which metrics are returned when and to whom on the server side. For example, you could only show metrics to authenticated users and nothing to the public.</source>
          <target state="translated">该 &lt;code&gt;Server-Timing&lt;/code&gt; 头可能会暴露潜在的敏感应用和基础设施的信息。考虑控制哪些度量标准在服务器端何时以及向谁返回。例如，您只能向经过身份验证的用户显示指标，而不会向公众显示任何指标。</target>
        </trans-unit>
        <trans-unit id="55f111f3d740121c0376e9d447632d82acbbd389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send a cookie from the server to the user agent, so the user agent can send it back to the server later. To send multiple cookies, multiple &lt;code&gt;Set-Cookie&lt;/code&gt; headers should be sent in the same response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e616d6c13d2c598274b6aa0d7cf7d1cc7921936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send cookies from the server to the user agent.</source>
          <target state="translated">所述 &lt;code&gt;Set-Cookie&lt;/code&gt; 的HTTP响应报头用于从服务器向用户代理发送cookie。</target>
        </trans-unit>
        <trans-unit id="d633495cdc7990d58394c50c8d640450b06b2d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; and &lt;code&gt;Cookie&lt;/code&gt; headers</source>
          <target state="translated">该 &lt;code&gt;Set-Cookie&lt;/code&gt; 和 &lt;code&gt;Cookie&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="4ee3227d824b48a69ef6dfb672317e9a7fe813f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceMap&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.</source>
          <target state="translated">所述 &lt;code&gt;SourceMap&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;生成的代码的响应报头链接&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;源图&lt;/a&gt;，从而使得浏览器来重构原始源并在调试器呈现重构原始。</target>
        </trans-unit>
        <trans-unit id="cc48476ae000e635700cbc6cc0b3e1b52a2ba404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Strict-Transport-Security&lt;/code&gt; response header (often abbreviated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP.</source>
          <target state="translated">在 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; 响应报头（通常缩写为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;）让网站告诉浏览器中使用HTTPS，而不是使用HTTP，它应该只被访问。</target>
        </trans-unit>
        <trans-unit id="a54300d397ddd96a89ed7e4299d868f45d6d3b45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; method performs a message loop-back test along the path to the target resource.</source>
          <target state="translated">的 &lt;code&gt;TRACE&lt;/code&gt; 方法进行沿着路径到目标资源的消息环回测试。</target>
        </trans-unit>
        <trans-unit id="f4e482563cca8b6b536cb03f419ca214a60b04b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</source>
          <target state="translated">的 &lt;code&gt;TRACE&lt;/code&gt; 进行沿着路径到目标资源的消息环回测试，提供了一个有用的调试机制。</target>
        </trans-unit>
        <trans-unit id="24a6cebd134cf5267f57018cea1581d2a79160d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tk&lt;/code&gt; response header indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">的 &lt;code&gt;Tk&lt;/code&gt; 的响应报头指示施加到相应的请求的跟踪状态。</target>
        </trans-unit>
        <trans-unit id="661d8abe462ff964e30520abb6a9490ee2f57e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity&lt;/a&gt; to the user.</source>
          <target state="translated">的 &lt;code&gt;Transfer-Encoding&lt;/code&gt; 标头指定编码时使用的安全传送的形式&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;的实体&lt;/a&gt;提供给用户。</target>
        </trans-unit>
        <trans-unit id="e80b8cf0899b9de1fbc8c3b7fc1f7628157f4015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;payload body&lt;/a&gt; to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fd812100e724a16068b0d9d88fea979cbef78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header specifies one or more comma-separated protocol names, in order of preference.</source>
          <target state="translated">所述 &lt;code&gt;Upgrade&lt;/code&gt; 头指定的一个或多个以逗号分隔的协议名称，首选项的顺序。</target>
        </trans-unit>
        <trans-unit id="ba632e686f1f5e8841818ed95374f3d49208c686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User-Agent&lt;/code&gt; header</source>
          <target state="translated">的 &lt;code&gt;User-Agent&lt;/code&gt; 报头</target>
        </trans-unit>
        <trans-unit id="d7a5f551ef4f873a95fa7564b99b777f320ff383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; algorithm.</source>
          <target state="translated">该 &lt;code&gt;Vary&lt;/code&gt; HTTP响应头决定如何满足未来的请求头，以决定一个缓存的响应是否可以使用，而不是请求从源服务器一个新的一个。服务器使用它来指示在&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;算法中选择资源表示形式时使用了哪些标头。</target>
        </trans-unit>
        <trans-unit id="b41f5b9f20c1124889bea2cf3b58e60fc1e6c962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header can also be useful for serving different content to desktop and mobile users, or to allow search engines to discover the mobile version of a page (and perhaps also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended). This is usually achieved with the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, and works because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different for mobile and desktop clients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194b4e9dbe38f2da963d88dc0f228c708df4f3f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header should be set on a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response exactly like it would have been set on an equivalent &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response.</source>
          <target state="translated">所述 &lt;code&gt;Vary&lt;/code&gt; 头应在设置&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 响应酷似它会一直集上的等效&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 响应。</target>
        </trans-unit>
        <trans-unit id="320c93529dc0245d276d67069f44ba338d5af1d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it.</source>
          <target state="translated">所述 &lt;code&gt;Vary&lt;/code&gt; 头在HTTP的1.1版本，并将是必要的，以便允许高速缓存以适当地工作。为了与服务器驱动的内容协商一起使用，缓存需要知道服务器使用了哪些标准来选择传输的内容。这样，缓存可以重播算法，并且能够直接提供可接受的内容，而无需向服务器发出更多请求。显然，通配符' &lt;code&gt;*&lt;/code&gt; '阻止了缓存的发生，因为缓存无法知道其背后的元素。</target>
        </trans-unit>
        <trans-unit id="76641ba7095f2c68f90780c9306f63f6bf04e9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it. For more information &lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTP caching &amp;gt; Varying responses&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4bde9aa68e310507cb43566d5d20223a7c4d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; response header</source>
          <target state="translated">所述 &lt;code&gt;Vary&lt;/code&gt; 响应头</target>
        </trans-unit>
        <trans-unit id="405a63b6723f58e2ec7f579da6d22e1185e2ba24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WWW-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">的 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 报头与一个一起发送&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 响应。</target>
        </trans-unit>
        <trans-unit id="4c2052dca6314ec4744d6670a2fcfde4364c3176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Warning&lt;/code&gt; general HTTP header contains information about possible problems with the status of the message. More than one &lt;code&gt;Warning&lt;/code&gt; header may appear in a response.</source>
          <target state="translated">该 &lt;code&gt;Warning&lt;/code&gt; 一般HTTP标头包含有关该消息的状态可能出现的问题的信息。响应中可能会出现多个&amp;ldquo; &lt;code&gt;Warning&lt;/code&gt; 标题。</target>
        </trans-unit>
        <trans-unit id="efe0fdb5e1f6f144e9e814a9d19ed38077ab4d3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Width&lt;/code&gt; request header field is a number that indicates the desired resource width in physical pixels (i.e. intrinsic size of an image). The provided pixel value is a number rounded to the smallest following integer (i.e. ceiling value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e5b0e1f18626b41321a488aa80a25f985f1deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">的 &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP响应报头控制DNS预取，通过该浏览器主动地在两个链路上执行域名解析，用户可以选择遵循以及用于由文档引用的项目，包括图像，CSS URL的特征，JavaScript等。</target>
        </trans-unit>
        <trans-unit id="ff3dc3f28097222bbf317e1c8c99177c20310367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. When traffic is intercepted between clients and servers, server access logs contain the IP address of the proxy or load balancer only. To see the original IP address of the client, the &lt;code&gt;X-Forwarded-For&lt;/code&gt; request header is used.</source>
          <target state="translated">该 &lt;code&gt;X-Forwarded-For&lt;/code&gt; （XFF）报头是用于通过HTTP代理或负载平衡器识别连接到web服务器的客户端的原始IP地址的事实上的标准报头。当客户端和服务器之间的流量被拦截时，服务器访问日志仅包含代理或负载平衡器的IP地址。要查看客户端的原始IP地址，请使用 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 请求标头。</target>
        </trans-unit>
        <trans-unit id="482fcec20c0b4ec16aa7ff0f4a40cd4a8e96efd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) header is a de-facto standard header for identifying the original host requested by the client in the &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; HTTP request header.</source>
          <target state="translated">该 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; （XFH）报头是用于识别由客户机在所要求的原始主机一个事实上的标准报头&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; HTTP请求报头。</target>
        </trans-unit>
        <trans-unit id="ac80a173a5330f7e0e915503af16d57814a7f24e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) header is a de-facto standard header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. Your server access logs contain the protocol used between the server and the load balancer, but not the protocol used between the client and the load balancer. To determine the protocol used between the client and the load balancer, the &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; request header can be used.</source>
          <target state="translated">该 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; （XFP）报头是用于识别协议（HTTP或HTTPS），其中使用的客户端连接到代理或负载平衡器一个事实上的标准报头。您的服务器访问日志包含服务器和负载平衡器之间使用的协议，但不包含客户端和负载平衡器之间使用的协议。要确定客户端与负载均衡器之间使用的协议，可以使用 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; 请求标头。</target>
        </trans-unit>
        <trans-unit id="7641932b013d9ddf2ffa745ed9e59704ae3a5eaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">该 &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;响应报头可以被用来指示一个浏览器是否应该被允许在一个以呈现页面&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。网站可以通过确保其内容未嵌入其他网站来避免&lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;点击劫持&lt;/a&gt;攻击。</target>
        </trans-unit>
        <trans-unit id="f8fc0e13a5bd95f55b983508d376db1ef57d9475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c716845b63ad60de10c5d0721c333cc0a7789d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;. Sites can use this to avoid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;click-jacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691c4a3bae3f1a7c0be3c3aed1c8e618e4fcd9e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delta-seconds&lt;/code&gt; parameter indicates the number of seconds the results can be cached.</source>
          <target state="translated">该 &lt;code&gt;delta-seconds&lt;/code&gt; 参数表示的秒的结果可以被高速缓存的数量。</target>
        </trans-unit>
        <trans-unit id="b2e68877049d392fb0d9efdba7e61a35e4736a2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;), but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8325de55392dc75d103db2ad034803012b8edc93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;, but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">该 &lt;code&gt;frame-ancestors&lt;/code&gt; 指令的语法类似于其它指令的源列表（例如&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;，但不允许 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 例如，它也不会回落到 &lt;code&gt;default-src&lt;/code&gt; 设置，仅允许以下来源：</target>
        </trans-unit>
        <trans-unit id="e84f1d948281d5568220728b9d276abf0bdd4199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;https://foo.example&lt;/code&gt; origin is permitted to request the &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; URL via the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d731b7e80edba53bed02fe84939621f3420c12d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; makes it case-insensitive, and &lt;code&gt;mobi&lt;/code&gt; matches all mobile browsers.</source>
          <target state="translated">在 &lt;code&gt;i&lt;/code&gt; 使其不区分大小写，并且 &lt;code&gt;mobi&lt;/code&gt; 所有移动浏览器相匹配。</target>
        </trans-unit>
        <trans-unit id="6ff2a01caeced20b51683f18c74fcf809d0a629a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infile&lt;/code&gt; parameter is the name of the file you wish to encode into base64 format, and &lt;code&gt;remotename&lt;/code&gt; is the remote name for the file, which isn't actually used in &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">该 &lt;code&gt;infile&lt;/code&gt; 参数是要编码的文件转换成Base64格式的名称， &lt;code&gt;remotename&lt;/code&gt; 是文件，这是不实际使用的远程名称 &lt;code&gt;data&lt;/code&gt; 的URL。</target>
        </trans-unit>
        <trans-unit id="604f09cfd89d091aa486d6636b750613f4f96b4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a &lt;a href=&quot;mime_types&quot;&gt;MIME type&lt;/a&gt; string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e539bd2196b041a5032c2ef5a8994c7b7bde4dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a MIME type string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;mediatype&lt;/code&gt; 是一个MIME类型的字符串，如 &lt;code&gt;'image/jpeg'&lt;/code&gt; 为JPEG图像文件。如果省略，则默认为 &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da52d7b321f788536d3829326d49c595d809fbf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME type is used to send partial responses to the browser.</source>
          <target state="translated">的 &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME类型被用来发送部分响应给浏览器。</target>
        </trans-unit>
        <trans-unit id="13ff0ccca95ad2dd6f5550002a8ef74789370c1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt; type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4a04b22f0b8d9d9056086ed2761a4ce7474e18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt;type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">的 &lt;code&gt;multipart/form-data&lt;/code&gt; 类型可以发送一个完成的值时，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML表格&lt;/a&gt;从浏览器到服务器。</target>
        </trans-unit>
        <trans-unit id="5ed16b201bb930d269ec462a17331c9fe9b5c948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-store&lt;/code&gt; directive will prevent a new resource being cached, but it will not prevent the cache from responding with a non-stale resource that was cached as the result of an earlier request. Setting &lt;code&gt;max-age=0&lt;/code&gt; as well forces the cache to revalidate (clears the cache).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d35dc77974d9a90114bab977a8eb5559894a4d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;payment&lt;/code&gt; feature's default allowlist value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa620fbdcb9cf9072c11203ebc2680fadd85c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any allow-list or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; are ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82adb286ff040efc04b5588e84c42dc13b4b83e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">在 &lt;code&gt;strict-dynamic&lt;/code&gt; 源表达式指定的信任明确给出与存在于标记的脚本，通过用随机数或散列伴随它，应当被传播到所有由根脚本加载的脚本。同时，所有白名单或源表达式（例如 &lt;code&gt;'self'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 都将被忽略。有关示例，请参见&lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3dc0a625918a10bc3cf47e685dbed66f751c4502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive is evaluated before &lt;a href=&quot;block-all-mixed-content&quot;&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;&lt;/a&gt; and if it is set, the latter is effectively a no-op. It is recommended to set either directive, but not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">该 &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 之前指令评估&lt;a href=&quot;block-all-mixed-content&quot;&gt; &lt;code&gt;block-all-mixed-content&lt;/code&gt; &lt;/a&gt;，如果它被设置，后者实际上是一个无操作。建议设置其中一个指令，但不要同时设置两个指令，除非您希望在较旧的浏览器上强制使用HTTPS，而在重定向到HTTP之后不强制使用该浏览器。</target>
        </trans-unit>
        <trans-unit id="67a6354b055d21e0ec5e6eda7647d60f1e916b1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive will not ensure that users visiting your site via links on third-party sites will be upgraded to HTTPS for the top-level navigation and thus does not replace the &lt;a href=&quot;../strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) header, which should still be set with an appropriate &lt;code&gt;max-age&lt;/code&gt; to ensure that users are not subject to SSL stripping attacks.</source>
          <target state="translated">该 &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 指令将不能保证用户通过第三方网站的链接访问您的网站将升级为HTTPS为顶级导航，因此不更换&lt;a href=&quot;../strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;）头，其仍应设置适当的 &lt;code&gt;max-age&lt;/code&gt; 以确保用户不受SSL剥离攻击。</target>
        </trans-unit>
        <trans-unit id="6a8d44d29e56bc0c55ce499b78519e2f545a58b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;HTTP version&lt;/em&gt;, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.</source>
          <target state="translated">的&lt;em&gt;HTTP版本&lt;/em&gt;，它定义了剩余的消息的结构，充当的预期版本的指示符以用于响应。</target>
        </trans-unit>
        <trans-unit id="534c7de6c70ce30d5cc7ac84f7a1d413ddee5f41" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;asterisk form&lt;/em&gt;, a simple asterisk (&lt;code&gt;'*'&lt;/code&gt;) is used with &lt;code&gt;OPTIONS&lt;/code&gt;, representing the server as a whole.</source>
          <target state="translated">的&lt;em&gt;星号形式&lt;/em&gt;，一个简单的星号（ &lt;code&gt;'*'&lt;/code&gt; ）用于 &lt;code&gt;OPTIONS&lt;/code&gt; ，代表服务器作为一个整体。</target>
        </trans-unit>
        <trans-unit id="e9fb04fb929e15b710da1fe284b86de9e6922e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol version&lt;/em&gt;, usually &lt;code&gt;HTTP/1.1&lt;/code&gt;.</source>
          <target state="translated">的&lt;em&gt;协议版本&lt;/em&gt;，通常是 &lt;code&gt;HTTP/1.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57141383ea92e8d11fc4aae1bb6ea799c9f809f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request target&lt;/em&gt;, usually a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be</source>
          <target state="translated">所述&lt;em&gt;请求对象&lt;/em&gt;，通常是一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;，或协议，端口和域的绝对路径通常特征在于请求上下文。此请求目标的格式在不同的HTTP方法之间有所不同。有可能</target>
        </trans-unit>
        <trans-unit id="f9cc4edb4b5b40b8f3c061c79a6b4c632e4c730a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; a few exceptions being programs used by engineers, and Web developers to debug their applications.</source>
          <target state="translated">所述&lt;em&gt;用户代理&lt;/em&gt;是作用于用户的代表任何工具。该角色主要由Web浏览器执行。工程师和Web开发人员用来调试其应用程序的程序是少数例外。</target>
        </trans-unit>
        <trans-unit id="094e3c74b2c1d28d2f1a69f2c5868e7adb3602cc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; other possibilities are programs used by engineers and Web developers to debug their applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ff728fce867d59850505a9f213412ce8cd201b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;var&gt;type&lt;/var&gt;&lt;/strong&gt; represents the general category into which the data type falls, such as &lt;code&gt;video&lt;/code&gt; or &lt;code&gt;text&lt;/code&gt;. The &lt;strong&gt;&lt;var&gt;subtype&lt;/var&gt;&lt;/strong&gt; identifies the exact kind of data of the specified type the MIME type represents. For example, for the MIME type &lt;code&gt;text&lt;/code&gt;, the subtype might be &lt;code&gt;plain&lt;/code&gt; (plain text), &lt;code&gt;html&lt;/code&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; source code), or &lt;code&gt;calendar&lt;/code&gt; (for iCalendar/&lt;code&gt;.ics&lt;/code&gt;) files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b83df44d3d37a4c410b129685134339244574f5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alt-Svc&lt;/strong&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">在&lt;strong&gt;按住Alt键SVC&lt;/strong&gt;头用于列表替代方式达到这个网站。</target>
        </trans-unit>
        <trans-unit id="8c3c79f7301c1c8d0fa9e587ad3fa734394dfbe4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP DELETE request method&lt;/strong&gt; deletes the specified resource.</source>
          <target state="translated">的&lt;strong&gt;HTTP DELETE请求方法&lt;/strong&gt;删除指定的资源。</target>
        </trans-unit>
        <trans-unit id="8f98d07b9e286fdee4af0bfd151e3fef8b4e1fdf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PATCH request method&lt;/strong&gt; applies partial modifications to a resource.</source>
          <target state="translated">的&lt;strong&gt;HTTP请求PATCH方法&lt;/strong&gt;应用于局部修改的资源。</target>
        </trans-unit>
        <trans-unit id="2f72c255d4cd8cf0faaa3dfd5ef732d3c26ae02b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PUT request method&lt;/strong&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">的&lt;strong&gt;HTTP PUT请求方法&lt;/strong&gt;创建新的资源或替换请求负载目标资源的表示。</target>
        </trans-unit>
        <trans-unit id="617a279a7f85aa11b7e9119c0549c65940ed8bdb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Sec-WebSocket-Accept&lt;/strong&gt; header is used in the websocket opening handshake. It would appear in the response headers. That is, this is header is sent from server to client to inform that server is willing to initiate a websocket connection.</source>
          <target state="translated">所述&lt;strong&gt;仲丁基的WebSocket -接受&lt;/strong&gt;报头在网页套接字开口握手使用。它会出现在响应标题中。也就是说，此标头是从服务器发送到客户端的，以通知服务器愿意启动Websocket连接。</target>
        </trans-unit>
        <trans-unit id="fec1b2ea30a4b23ec6ed613fb4a58917ff6f2e5d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Trailer&lt;/strong&gt; response header allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.</source>
          <target state="translated">所述&lt;strong&gt;拖车&lt;/strong&gt;响应头允许发送方包括为了供给元数据可能同时消息体被发送，诸如消息完整性检查，数字签名，或后处理状态动态地生成在分块消息的末尾附加字段。</target>
        </trans-unit>
        <trans-unit id="72b737b3f7ebb245858f1a5344bbb6bcfd1d296b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt; request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.</source>
          <target state="translated">的&lt;strong&gt;用户代理&lt;/strong&gt;请求头包含一个特征串，其允许网络协议对等体，以确定应用程序的类型，操作系统，软件供应商或请求软件的用户代理的软件版本。</target>
        </trans-unit>
        <trans-unit id="2288013069b97e56ffbc4768d5888642c23e6913" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;request header&lt;/a&gt; is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808b80dac820b6a1614956c81b08b2381235cc1b" translate="yes" xml:space="preserve">
          <source>The Accept header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7fb45a1dfda8bd680e10b36530ac6598af98b2" translate="yes" xml:space="preserve">
          <source>The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.

       Accept         = &quot;Accept&quot; &quot;:&quot;
                        #( media-range [ accept-params ] )

       media-range    = ( &quot;*/*&quot;
                        | ( type &quot;/&quot; &quot;*&quot; )
                        | ( type &quot;/&quot; subtype )
                        ) *( &quot;;&quot; parameter )
       accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
       accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.

   Each media-range MAY be followed by one or more accept-params,
   beginning with the &quot;q&quot; parameter for indicating a relative quality
   factor. The first &quot;q&quot; parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;). The
   default value is q=1.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named &quot;q&quot;. 

   The example

       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as &quot;I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality.&quot;

   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server SHOULD
   send a 406 (not acceptable) response.

   A more elaborate example is

       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity.&quot;

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,

       Accept: text/*, text/html, text/html;level=1, */*

   have the following precedence:

       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,

       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7

      Note: A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.</source>
          <target state="translated">接受请求标头字段可用于指定响应可接受的某些媒体类型。接受标头可用于指示该请求特别限于一小部分所需类型，例如在请求嵌入式图像的情况下。接受=&amp;ldquo;接受&amp;rdquo;&amp;ldquo;：&amp;rdquo;＃（media-range [accept-params]）media-range =（&amp;ldquo; * / *&amp;rdquo; |（type&amp;ldquo; /&amp;rdquo;&amp;ldquo; *&amp;rdquo;）|（type&amp;ldquo; /&amp;rdquo;子类型）））*（ &amp;ldquo;;&amp;rdquo;参数）accept-params =&amp;ldquo;;&amp;rdquo; &amp;ldquo; q&amp;rdquo;&amp;ldquo; =&amp;rdquo; qvalue *（accept-extension）accept-extension =&amp;ldquo;;&amp;rdquo; token [&amp;ldquo; =&amp;rdquo;（token | quoted-string）]星号&amp;ldquo; *&amp;rdquo;字符用于将媒体类型分组到范围内，其中&amp;ldquo; * / *&amp;rdquo;表示所有媒体类型，&amp;ldquo; type / *&amp;rdquo;表示该类型的所有子类型。媒体范围可以包括适用于该范围的媒体类型参数。每个媒体范围都可以跟随一个或多个接受参数，以&amp;ldquo; q&amp;rdquo;参数开头，以指示相对质量因数。第一个&amp;ldquo; q&amp;rdquo;参数（如果有）将媒体范围参数与accept-params分开。品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（媒体范围可以包括适用于该范围的媒体类型参数。每个媒体范围都可以跟随一个或多个接受参数，以&amp;ldquo; q&amp;rdquo;参数开头，以指示相对质量因数。第一个&amp;ldquo; q&amp;rdquo;参数（如果有）将媒体范围参数与accept-params分开。品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（媒体范围可以包括适用于该范围的媒体类型参数。每个媒体范围都可以跟随一个或多个接受参数，以&amp;ldquo; q&amp;rdquo;参数开头，以指示相对质量因数。第一个&amp;ldquo; q&amp;rdquo;参数（如果有）将媒体范围参数与accept-params分开。品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（&lt;a href=&quot;#section-3.9&quot;&gt;第3.9节&lt;/a&gt;）。默认值为q = 1。注意：由于历史上的惯例，使用&amp;ldquo; q&amp;rdquo;参数名称将媒体类型参数与&amp;ldquo;接受&amp;rdquo;扩展参数分开。尽管这可以阻止任何名为&amp;ldquo; q&amp;rdquo;的媒体类型参数与媒体范围一起使用，但考虑到IANA媒体类型注册表中缺少任何&amp;ldquo; q&amp;rdquo;参数并且很少使用任何媒体类型的情况，因此认为这种事件不太可能发生接受中的参数。不鼓励将来的媒体类型注册任何名为&amp;ldquo; q&amp;rdquo;的参数。该示例接受：audio / *; q = 0.2，音频/基本应该解释为&amp;ldquo;我更喜欢音频/基本，但是如果质量降低80％之后，如果音频类型是最好的，请向我发送任何音频类型。&amp;rdquo;如果不存在&amp;ldquo;接受&amp;rdquo;标头字段，则假定客户端接受所有媒体类型。如果存在一个Accept头字段，并且如果服务器不能根据组合的Accept字段值发送可接受的响应，则服务器应该发送406（不可接受）响应。一个更详细的示例是Accept：text / plain; q = 0.5，text / html，text / x-dvi; q = 0.8，text / xc从字面上看，这将被解释为&amp;ldquo; text / html和text / xc是首选的媒体类型，但是如果它们不存在，则发送text / x-dvi实体，如果不存在存在，请发送文本/纯文本实体。&amp;rdquo;媒体范围可以被更特定的媒体范围或特定的媒体类型覆盖。如果给定类型适用多个介质范围，则最具体的参考优先。例如，接受：text / *，text / html，text / html; level = 1，* / *具有以下优先级：1）text / html; level = 1 2）text / html 3）text / * 4）* / *媒体与给定类型关联的类型质量因子是通过找到与该类型匹配的具有最高优先级的媒体范围来确定的。例如，接受：text / *; q = 0.3，text / html; q = 0.7，text / html; level = 1，text / html; level = 2; q = 0.4，* / *; q = 0.5要关联的以下值：text / html; level = 1 = 1 text / html = 0.7 text / plain = 0.3 image / jpeg = 0.5 text / html; level = 2 = 0.4 text / html; level = 3 = 0.7注意：可能为用户代理提供了某些媒体范围的默认质量值集。但是，除非用户代理是无法与其他呈现代理进行交互的封闭系统，否则此默认设置应可由用户配置。</target>
        </trans-unit>
        <trans-unit id="e7b4f26fbb0e2bce3365129a80d0fb7728e75c9b" translate="yes" xml:space="preserve">
          <source>The Accept-CH header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63aae7229caefbd97fe24c548f9020512978ccc" translate="yes" xml:space="preserve">
          <source>The Accept-CH-Lifetime header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4769fb0951abad4aa7016b3134653949993c77de" translate="yes" xml:space="preserve">
          <source>The Accept-Charset header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234dfa2f1729dd01886001e7daa88ee0bafe27f6" translate="yes" xml:space="preserve">
          <source>The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-
   purpose character sets to signal that capability to a server which is
   capable of representing documents in those character sets.

      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
              1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )


   Character set values are described in &lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;. Each charset MAY
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is

      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no &quot;*&quot; is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.

   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server SHOULD send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.</source>
          <target state="translated">Accept-Charset请求标头字段可用于指示响应可接受的字符集。该字段允许客户机能够理解更全面或专用的字符集，以将这种能力发送给能够在那些字符集中表示文档的服务器。 Accept-Charset =&amp;ldquo; Accept-Charset&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃（（charset |&amp;ldquo; *&amp;rdquo;）[&amp;ldquo;;&amp;rdquo;&amp;ldquo; q&amp;rdquo;&amp;ldquo; =&amp;rdquo; qvalue]）字符集的值在&lt;a href=&quot;#section-3.4&quot;&gt;3.4节&lt;/a&gt;中介绍。可以给每个字符集一个相关联的质量值，该质量值表示用户对该字符集的偏好。默认值为q = 1。一个示例是Accept-Charset：iso-8859-5，unicode-1-1; q = 0.8特殊值&amp;ldquo; *&amp;rdquo;（如果出现在Accept-Charset字段中）则匹配每个字符集（包括ISO-8859-1）在&amp;ldquo;接受字符集&amp;rdquo;字段的其他地方未提及。如果Accept-Charset字段中不存在&amp;ldquo; *&amp;rdquo;，则所有未明确提及的字符集的质量值均为0，ISO-8859-1除外，如果未明确提及，则其质量值为1。如果不存在Accept-Charset标头，则默认值为任何字符集都是可接受的。如果存在Accept-Charset标头，并且如果服务器不能根据Accept-Charset头发送可接受的响应，则服务器应该发送带有406（不可接受）状态码的错误响应，尽管也允许发送不可接受的响应。</target>
        </trans-unit>
        <trans-unit id="4cd92c762aa78d137a23b8b73482ba75b9995048" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e57729d1ed38c6ddc068a85cca9d470a3c1d181" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;) that are acceptable in
   the response.

       Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot; 

                          1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       codings          = ( content-coding | &quot;*&quot; )

   Examples of its use are:

       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:

      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;)

      2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.

      3. If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.

      4. The &quot;identity&quot; content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does
         not explicitly include the &quot;identity&quot; content-coding. If the
         Accept-Encoding field-value is empty, then only the &quot;identity&quot;
         encoding is acceptable.

   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server SHOULD send an error response
   with the 406 (Not Acceptable) status code.

   If no Accept-Encoding field is present in a request, the server MAY
   assume that the client will accept any content coding. In this case,
   if &quot;identity&quot; is one of the available content-codings, then the
   server SHOULD use the &quot;identity&quot; content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.

      Note: If the request does not include an Accept-Encoding field,
      and if the &quot;identity&quot; content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e., 

      &quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Accept-Encoding请求标头字段与Accept相似，但是限制了内容编码（&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）在响应中可以接受。 Accept-Encoding =&amp;ldquo; Accept-Encoding&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃（编码[&amp;ldquo;;&amp;rdquo;&amp;ldquo; q&amp;rdquo;&amp;ldquo; =&amp;rdquo; qvalue]）编码=（content-coding |&amp;ldquo; *&amp;rdquo;）其用法示例如下：Accept-Encoding：压缩，gzip接受编码：接受编码：*接受编码：压缩; q = 0.5，gzip; q = 1.0接受编码：gzip; q = 1.0，身份; q = 0.5，*; q = 0服务器使用以下规则根据&amp;ldquo;接受编码&amp;rdquo;字段测试内容编码是否可接受：1.如果内容编码是&amp;ldquo;接受&amp;rdquo;中列出的内容编码之一-Encoding字段，那么它是可以接受的，除非它带有qvalue0。（如&lt;a href=&quot;#section-3.9&quot;&gt;3.9节中&lt;/a&gt;所定义），q值为0表示&amp;ldquo;不可接受&amp;rdquo;。）2. Accept-Encoding字段中的特殊&amp;ldquo; *&amp;rdquo;符号与标头字段中未明确列出的任何可用内容编码匹配。 3.如果可接受多个内容编码，则首选具有最高非零q值的可接受内容编码。 4.&amp;ldquo;身份&amp;rdquo;内容编码始终是可以接受的，除非由于Accept-Encoding字段包含&amp;ldquo; identity; q = 0&amp;rdquo;或由于该字段包含&amp;ldquo; *; q = 0&amp;rdquo;且未明确包含&amp;ldquo;身份&amp;rdquo;内容编码。如果Accept-Encoding字段值为空，则仅&amp;ldquo;身份&amp;rdquo;编码是可接受的。如果请求中存在一个Accept-Encoding字段，并且如果服务器无法根据Accept-Encoding标头发送可接受的响应，则服务器应该发送一个错误响应，并带有406（不可接受）状态码。如果请求中不存在Accept-Encoding字段，则服务器可以假定客户端将接受任何内容编码。在这种情况下，如果&amp;ldquo;身份&amp;rdquo;是可用的内容编码之一，则服务器应该使用&amp;ldquo;身份&amp;rdquo;内容编码，除非它具有其他信息，即不同的内容编码对客户端有意义。注意：如果请求中不包含&amp;ldquo;接受编码&amp;rdquo;字段，并且&amp;ldquo;身份&amp;rdquo;内容编码不可用，则HTTP / 1.0客户端通常会理解的内容编码（即，&amp;ldquo; gzip&amp;rdquo;和&amp;ldquo; compress&amp;rdquo;）是首选；一些较旧的客户端不正确地显示与其他内容编码一起发送的消息。服务器可能还会基于有关特定用户代理或客户端的信息来做出此决定。注意：大多数HTTP / 1.0应用程序都不识别或遵循与内容编码关联的q值。这意味着qvalue不能使用，并且x-gzip或x-compress不允许使用。这意味着qvalues将不起作用，并且x-gzip或x-compress不允许使用。这意味着qvalue不能使用，并且x-gzip或x-compress不允许使用。</target>
        </trans-unit>
        <trans-unit id="007df01155d25e755642903868beaa64cb7fcbdf" translate="yes" xml:space="preserve">
          <source>The Accept-Language header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba115d77d254ca318ebb9337409d39d8d2c75fa" translate="yes" xml:space="preserve">
          <source>The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;.

       Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                         1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )

   Each language-range MAY be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to &quot;q=1&quot;. For
   example,

       Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English.&quot; A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is &quot;-&quot;.
   The special range &quot;*&quot;, if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.

      Note: This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.

   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-
   range in the field that matches the language-tag. If no language-
   range in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server 

   SHOULD assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   &lt;a href=&quot;#section-15.1.4&quot;&gt;section 15.1.4&lt;/a&gt;.

   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field MUST NOT be given in
   the request.

      Note: When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting &quot;en-gb&quot;, they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add &quot;en&quot; to get the
      best matching behavior.</source>
          <target state="translated">Accept-Language请求标头字段类似于Accept，但是限制了首选自然语言集作为对请求的响应。语言标签在&lt;a href=&quot;#section-3.10&quot;&gt;3.10节&lt;/a&gt;中定义。 Accept-Language =&amp;ldquo; Accept-Language&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃（语言范围[&amp;ldquo;;&amp;rdquo;&amp;ldquo; q&amp;rdquo;&amp;ldquo; =&amp;rdquo; qvalue]）语言范围=（（1 * 8ALPHA *（&amp;ldquo;-&amp;rdquo; 1 * 8ALPHA）） |&amp;ldquo; *&amp;rdquo;）可以给每个语言范围一个相关的质量值，该质量值表示用户对该范围指定的语言的偏爱估计。质量值默认为&amp;ldquo; q = 1&amp;rdquo;。例如，Accept-Language：da，en-gb; q = 0.8，en; q = 0.7表示：&amp;ldquo;我更喜欢丹麦语，但会接受英式英语和其他类型的英语。&amp;rdquo;如果语言范围与语言标签完全相同，或者与语言标签完全相同，或者与标签的前缀完全相同，则前缀后面的第一个标签字符为&amp;ldquo;-&amp;rdquo;。特殊范围&amp;ldquo; *&amp;rdquo;（如果出现在&amp;ldquo;接受语言&amp;rdquo;字段中）将与&amp;ldquo;接受语言&amp;rdquo;字段中存在的任何其他范围未匹配的每个标签进行匹配。注意：前缀匹配规则的使用并不意味着将语言标签分配给语言，以确保用户理解带有特定标签的语言始终是正确的，那么该用户也将理解带有标签的所有语言。为此标签作为前缀。如果是这种情况，则前缀规则仅允许使用前缀标签。通过&amp;ldquo;接受语言&amp;rdquo;字段分配给语言标签的语言质量因子是该字段中与语言标签匹配的最长语言范围的质量值。如果字段中没有语言范围与标签匹配，则分配的语言质量因子为0。如果请求中不存在Accept-Language标头，则服务器应假定所有语言均可接受。如果存在Accept-Language标头，则所有被分配了大于0的质量因子的语言都是可以接受的。在每个请求中发送带有用户完整语言偏好的Accept-Language标头可能与用户的隐私期望背道而驰。有关此问题的讨论，请参见在每个请求中发送带有用户完整语言偏好的Accept-Language标头可能与用户的隐私期望背道而驰。有关此问题的讨论，请参见在每个请求中发送带有用户完整语言偏好的Accept-Language标头可能与用户的隐私期望背道而驰。有关此问题的讨论，请参见 &lt;a href=&quot;#section-15.1.4&quot;&gt;第15.1.4节&lt;/a&gt;。由于可懂度高度依赖于单个用户，因此建议客户端应用程序使用户可以选择语言偏好。如果选择不可用，则在请求中不得给出Accept-Language标头字段。注意：在向用户提供语言偏好选择时，我们提醒实施者以下事实：用户不熟悉上述语言匹配的详细信息，并应提供适当的指导。例如，用户可能会假设选择&amp;ldquo; en-gb&amp;rdquo;时，如果没有英式英语，则将向他们提供任何种类的英语文档。在这种情况下，用户代理可能建议添加&amp;ldquo; en&amp;rdquo;以获得最佳匹配行为。</target>
        </trans-unit>
        <trans-unit id="dceeccc14ca79697274f5080fd10fd4f709e2583" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:

          Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
          acceptable-ranges = 1#range-unit | &quot;none&quot;

      Origin servers that accept byte-range requests MAY send

          Accept-Ranges: bytes

      but are not required to do so. Clients MAY generate byte-range
      requests without having received this header for the resource
      involved. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

      Servers that do not accept any kind of range request for a
      resource MAY send

          Accept-Ranges: none

      to advise the client not to attempt a range request.</source>
          <target state="translated">Accept-Ranges响应标头字段允许服务器指示其接受资源的范围请求：Accept-Ranges =&amp;ldquo; Accept-Ranges&amp;rdquo;&amp;ldquo;：&amp;rdquo; accept-ranges accept-ranges = 1＃range-unit |接受字节范围请求的&amp;ldquo;无&amp;rdquo;原始服务器可以发送Accept-Ranges：字节，但不是必须的。客户端可以生成字节范围的请求，而没有收到所涉及资源的此头。范围单位在&lt;a href=&quot;#section-3.12&quot;&gt;第3.12节&lt;/a&gt;中定义。不接受任何类型的资源范围请求的服务器可以发送Accept-Ranges：无，建议客户端不要尝试范围请求。</target>
        </trans-unit>
        <trans-unit id="20fe0a78765b42653f8af73cd9564f1524ef0e69" translate="yes" xml:space="preserve">
          <source>The Age header field is used to convey an estimated age of the
   response message when obtained from a cache.  The Age field value is
   the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server.  In essence, the Age 

   value is the sum of the time that the response has been resident in
   each of the caches along the path from the origin server, plus the
   amount of time it has been in transit along network paths.

   The following data is used for the age calculation:

   age_value

      The term &quot;age_value&quot; denotes the value of the Age header field
      (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), in a form appropriate for arithmetic operation; or
      0, if not available.

   date_value

      The term &quot;date_value&quot; denotes the value of the Date header field,
      in a form appropriate for arithmetic operations.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 of [RFC7231]&lt;/a&gt; for the definition of the Date header field,
      and for requirements regarding responses without it.

   now

      The term &quot;now&quot; means &quot;the current value of the clock at the host
      performing the calculation&quot;.  A host ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;])
      or some similar protocol to synchronize its clocks to Coordinated
      Universal Time.

   request_time

      The current value of the clock at the host at the time the request
      resulting in the stored response was made.

   response_time

      The current value of the clock at the host at the time the
      response was received.

   A response's age can be calculated in two entirely independent ways:

   1.  the &quot;apparent_age&quot;: response_time minus date_value, if the local
       clock is reasonably well synchronized to the origin server's
       clock.  If the result is negative, the result is replaced by
       zero.

   2.  the &quot;corrected_age_value&quot;, if all of the caches along the
       response path implement HTTP/1.1.  A cache MUST interpret this
       value relative to the time the request was initiated, not the
       time that the response was received. 

     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;

   These are combined as

     corrected_initial_age = max(apparent_age, corrected_age_value);

   unless the cache is confident in the value of the Age header field
   (e.g., because there are no HTTP/1.0 hops in the Via header field),
   in which case the corrected_age_value MAY be used as the
   corrected_initial_age.

   The current_age of a stored response can then be calculated by adding
   the amount of time (in seconds) since the stored response was last
   validated by the origin server to the corrected_initial_age.

     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;</source>
          <target state="translated">当从高速缓存中获得时，&amp;ldquo;年龄&amp;rdquo;标头字段用于传达响应消息的估计年龄。 &amp;ldquo;年龄&amp;rdquo;字段的值是自原始服务器生成或验证响应以来，缓存对秒数的估计。本质上，Age值是响应从源服务器沿路径驻留在每个缓存中的时间加上沿网络路径传输的时间之和。以下数据用于年龄计算：age_value术语&amp;ldquo; age_value&amp;rdquo;表示&amp;ldquo;年龄&amp;rdquo;标头字段的值（&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节）&lt;/a&gt;），采用适合算术运算的形式；或0（如果不可用）。 date_value术语&amp;ldquo; date_value&amp;rdquo;以适合算术运算的形式表示Date标头字段的值。请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;[RFC7231]的7.1.1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;节&lt;/a&gt;，了解Date标头字段的定义，以及有关没有此标头的响应的要求。 now术语&amp;ldquo; now&amp;rdquo;表示&amp;ldquo;执行计算的主机上时钟的当前值&amp;rdquo;。主机应使用NTP（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;]）或一些类似的协议，以将其时钟同步到协调世界时。 request_time发出导致存储的响应的请求时主机上时钟的当前值。 response_time接收响应时主机上时钟的当前值。可以使用两种完全独立的方法来计算响应的时间：1.&amp;ldquo; apparent_age&amp;rdquo;：response_time减去date_value（如果本地时钟与原始服务器的时钟合理地同步）。如果结果为负，则结果将替换为零。 2.如果响应路径上的所有缓存均实现HTTP / 1.1，则为&amp;ldquo; corrected_age_value&amp;rdquo;。缓存必须相对于发起请求的时间而不是接收响应的时间来解释该值。 parent_age = max（0，response_time-date_value）; response_delay = response_time-request_time; corrected_age_value = age_value + response_delay;这些被合并为corrected_initial_age = max（表观年龄，corrected_age_value）;除非高速缓存对Age标头字段的值有信心（例如，因为Via标头字段中没有HTTP / 1.0跳），在这种情况下，corrected_age_value可以用作corrected_initial_age。然后，可以通过将自存储服务器上次验证存储的响应以来的时间量（以秒为单位）添加到corrected_initial_age中，来计算存储的响应的current_age。resident_time = now-response_time; current_age =校正后的初始年龄+ resident_time;</target>
        </trans-unit>
        <trans-unit id="fdef55523947f477881a984ce9c7d78915e916d7" translate="yes" xml:space="preserve">
          <source>The Age response-header field conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &quot;fresh&quot; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;.

           Age = &quot;Age&quot; &quot;:&quot; age-value
           age-value = delta-seconds

      Age values are non-negative decimal integers, representing time in
      seconds.

      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it MUST transmit an Age header with a value of
      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST
      include an Age header field in every response generated from its
      own cache. Caches SHOULD use an arithmetic type of at least 31
      bits of range.</source>
          <target state="translated">年龄响应标头字段传达了发件人对自从在原始服务器上生成响应（或其重新验证）以来的时间量的估计。如果缓存的响应时间不超过其新鲜度生命周期，则它是&amp;ldquo;新鲜的&amp;rdquo;。年龄值是按照&lt;a href=&quot;#section-13.2.3&quot;&gt;第13.2.3节中的&lt;/a&gt;规定计算的。 Age =&amp;ldquo; Age&amp;rdquo;&amp;ldquo; ::&amp;rdquo; age-value age-value = delta-seconds年龄值是非负十进制整数，以秒为单位表示时间。如果缓存收到的值大于它可以表示的最大正整数，或者如果任何年龄计算溢出，则它必须发送一个2147483648（2 ^ 31）值的Age标头。包含缓存的HTTP / 1.1服务器必须在其自身的缓存生成的每个响应中都包含Age标头字段。缓存应该使用至少31位范围的算术类型。</target>
        </trans-unit>
        <trans-unit id="d37b3ed1a7bd53de7b0c73a5ae6518e139d2ed9d" translate="yes" xml:space="preserve">
          <source>The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.

          Allow   = &quot;Allow&quot; &quot;:&quot; #Method

      Example of use:

          Allow: GET, HEAD, PUT

      This field cannot prevent a client from trying other methods.
      However, the indications given by the Allow header field value
      SHOULD be followed. The actual set of allowed methods is defined
      by the origin server at the time of each request.

      The Allow header field MAY be provided with a PUT request to
      recommend the methods to be supported by the new or modified
      resource. The server is not required to support these methods and
      SHOULD include an Allow header in the response giving the actual
      supported methods. 

      A proxy MUST NOT modify the Allow header field even if it does not
      understand all the methods specified, since the user agent might
      have other means of communicating with the origin server.</source>
          <target state="translated">Allow实体头字段列出了由Request-URI标识的资源所支持的方法集。这个字段的目的是严格地通知接收者与资源相关的有效方法。允许头字段必须存在于405(方法不允许)响应中。Allow=&quot;Allow&quot; &quot;:&quot; #方法 使用示例。使用示例:Allow.GET,HEAD,PUT GET,HEAD,PUT 这个字段不能阻止客户端尝试其他方法。但是,应该遵循Allow头字段值给出的指示。实际的允许方法集是由源服务器在每个请求时定义的。允许头字段可以和PUT请求一起提供,以推荐新的或修改后的资源所支持的方法。服务器不需要支持这些方法,应该在响应中包含一个Allow头,给出实际支持的方法。即使代理不理解所有指定的方法,也不能修改Allow头字段,因为用户代理可能有其他方法与源服务器通信。</target>
        </trans-unit>
        <trans-unit id="13a4fef575d5af4e237a81912fe641b20dff803a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol imposes few restrictions on the actions of servers.
   Unless a constraint is specified here, servers can be expected to
   vary in behavior, in particular around the manipulation of Atom
   Entries sent by clients.  For example, although this specification
   only defines the expected behavior of Collections with respect to GET
   and POST, this does not imply that PUT, DELETE, PROPPATCH, and others
   are forbidden on Collection Resources -- only that this specification
   does not define what the server's response would be to those methods.
   Similarly, while some HTTP status codes are mentioned explicitly,
   clients ought to be prepared to handle any status code from a server.
   Servers can choose to accept, reject, delay, moderate, censor,
   reformat, translate, relocate, or re-categorize the content submitted
   to them.  Only some of these choices are immediately relayed back to
   the client in responses to client requests; other choices may only
   become apparent later, in the feed or published entries.  The same
   series of requests to two different publishing sites can result in a
   different series of HTTP responses, different resulting feeds, or
   different entry contents.

   As a result, client software has to be written flexibly to accept
   what the server decides are the results of its submissions.  Any
   server response or server content modification not explicitly
   forbidden by this specification or HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] is therefore
   allowed.</source>
          <target state="translated">Atom协议对服务器的行为几乎没有限制。除非在此未指定约束，否则服务器的行为可能会有所不同，尤其是围绕客户端发送的Atom条目的操作。例如，尽管此规范仅定义了关于GET和POST的Collections的预期行为，但这并不意味着Collection资源上禁止PUT，DELETE，PROPPATCH和其他功能-只是此规范未定义服务器的资源应对将是那些方法。同样，尽管明确提到了一些HTTP状态代码，但客户端应准备好处理服务器中的任何状态代码。服务器可以选择接受，拒绝，延迟，适度，检查器，重新格式化，翻译，重新定位，或重新分类提交给他们的内容。这些选择中只有一部分会立即响应客户请求而中继回客户。其他选择可能仅稍后在提要或已发布的条目中变得明显。对两个不同发布站点的相同系列请求可能导致不同系列的HTTP响应，不同结果的提要或不同条目内容。结果，必须灵活地编写客户端软件，以接受服务器决定其提交结果的内容。本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[在Feed或已发布的条目中。对两个不同发布站点的相同系列请求可能导致不同系列的HTTP响应，不同结果的提要或不同条目内容。结果，必须灵活地编写客户端软件，以接受服务器决定其提交结果的内容。本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[在Feed或已发布的条目中。对两个不同发布站点的相同系列请求可能导致不同系列的HTTP响应，不同结果的提要或不同条目内容。结果，必须灵活地编写客户端软件，以接受服务器决定其提交结果的内容。本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;因此，允许使用RFC2616 ]。</target>
        </trans-unit>
        <trans-unit id="3007c47f9b138e0499c5f1a7d9a65013178447c8" translate="yes" xml:space="preserve">
          <source>The Atom Protocol specifies operations for publishing and editing
   Resources using HTTP.  It uses Atom-formatted representations to
   describe the state and metadata of those Resources.  It defines how
   Collections of Resources can be organized, and it specifies formats
   to support their discovery, grouping and categorization.</source>
          <target state="translated">Atom协议规定了使用HTTP发布和编辑资源的操作,它使用Atom格式化的表示来描述这些资源的状态和元数据。它使用Atom格式化的表示来描述这些资源的状态和元数据。它定义了如何组织资源集合,并指定了支持其发现、分组和分类的格式。</target>
        </trans-unit>
        <trans-unit id="3a69850b360c5d4d12134d47ffb0f4087be9cb1a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol uses the response status codes defined in HTTP to
   indicate the success or failure of an operation.  Consult the HTTP
   specification [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] for detailed definitions of each status code.

   Implementers are asked to note that according to the HTTP
   specification, HTTP 4xx and 5xx response entities SHOULD include a
   human-readable explanation of the error.</source>
          <target state="translated">Atom协议使用HTTP中定义的响应状态代码来指示操作的成功或失败。有关每个状态代码的详细定义，请参考HTTP规范[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]。要求实现者注意，根据HTTP规范，HTTP 4xx和5xx响应实体应该包括该错误的易于理解的解释。</target>
        </trans-unit>
        <trans-unit id="169d7cc9960872ff8dd439fd04a8242bd3b29ed5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol</source>
          <target state="translated">Atom出版协议</target>
        </trans-unit>
        <trans-unit id="aa8edeb1773be5498439f67a0412dde5980a08ac" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is an application-level protocol for
   publishing and editing Web Resources using HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  The protocol supports the creation of Web Resources and
   provides facilities for:

   o  Collections: Sets of Resources, which can be retrieved in whole or
      in part.

   o  Services: Discovery and description of Collections.

   o  Editing: Creating, editing, and deleting Resources.

   The Atom Publishing Protocol is different from many contemporary
   protocols in that the server is given wide latitude in processing
   requests from clients.  See &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; for more details.</source>
          <target state="translated">Atom发布协议是用于使用HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]和XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] 发布和编辑Web资源的应用程序级协议。该协议支持Web资源的创建，并提供以下功能：o集合：资源集，可以全部或部分检索。服务：发现和描述集合。 o编辑：创建，编辑和删除资源。 Atom发布协议与许多现代协议的不同之处在于，服务器在处理来自客户端的请求方面具有很大的自由度。有关更多详细信息，请参见&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="091cad87f70ba141ab92f1e05e1c2c4c7b6a0753" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP and thus subject to the
   security considerations found in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;Section&amp;nbsp;15 of [RFC2616]&lt;/a&gt;.

   The threats listed in this section apply to many protocols that run
   under HTTP.  The Atompub Working Group decided that the protection
   afforded by running authenticated HTTP under TLS (as described in
   &lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) was sufficient to mitigate many of the problems presented
   by the attacks listed in this section.</source>
          <target state="translated">Atom发布协议基于HTTP，因此需要遵守&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;[RFC2616]第15节中&lt;/a&gt;的安全性考虑。本节中列出的威胁适用于在HTTP下运行的许多协议。 Atompub工作组认为，通过在TLS下运行经过身份验证的HTTP（如&lt;a href=&quot;#section-14&quot;&gt;第14节&lt;/a&gt;所述）所提供的保护 足以缓解本节中列出的攻击所带来的许多问题。</target>
        </trans-unit>
        <trans-unit id="5d125ad81e218339dcf924271a55cccc89e9d5f5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP.  Authentication
   requirements for HTTP are covered in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;Section&amp;nbsp;11 of [RFC2616]&lt;/a&gt;.

   The use of authentication mechanisms to prevent POSTing or editing by
   unknown or unauthorized clients is RECOMMENDED but not required.
   When authentication is not used, clients and servers are vulnerable
   to trivial spoofing, denial-of-service, and defacement attacks.
   However, in some contexts, this is an acceptable risk.

   The type of authentication deployed is a local decision made by the
   server operator.  Clients are likely to face authentication schemes
   that vary across server deployments.  At a minimum, client and server
   implementations MUST be capable of being configured to use HTTP Basic
   Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] in conjunction with a connection made with
   TLS 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;] or a subsequent standards-track version of TLS
   (such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;]), supporting the conventions for using HTTP over
   TLS described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. 

   The choice of authentication mechanism will impact interoperability.
   The minimum level of security referenced above (Basic Authentication
   with TLS) is considered good practice for Internet applications at
   the time of publication of this specification and sufficient for
   establishing a baseline for interoperability.  Implementers are
   encouraged to investigate and use alternative mechanisms regarded as
   equivalently good or better at the time of deployment.  It is
   RECOMMENDED that clients be implemented in such a way that new
   authentication schemes can be deployed.

   Because this protocol uses HTTP response status codes as the primary
   means of reporting the result of a request, servers are advised to
   respond to unauthorized or unauthenticated requests using an
   appropriate 4xx HTTP response code (e.g., 401 &quot;Unauthorized&quot; or 403
   &quot;Forbidden&quot;) in accordance with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].</source>
          <target state="translated">Atom发布协议基于HTTP。 HTTP的身份验证要求在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;[RFC2616]的第11节&lt;/a&gt;中介绍。建议但不要求使用身份验证机制来防止未知或未经授权的客户端进行POST或编辑。不使用身份验证时，客户端和服务器容易受到小规模的欺骗，拒绝服务和破坏攻击。但是，在某些情况下，这是可以接受的风险。部署的身份验证类型是服务器操作员的本地决定。客户端可能会遇到随服务器部署而异的身份验证方案。至少，客户端和服务器实现必须能够配置为使用HTTP基本认证[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;]与TLS 1.0 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt; ]或后续标准跟踪版本的TLS（例如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt; ]）建立的连接结合在一起，支持[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818]中&lt;/a&gt;所述的在TLS上使用HTTP的约定]。认证机制的选择将影响互操作性。在本规范发布之时，以上提到的最低安全级别（使用TLS的基本身份验证）被认为是Internet应用程序的良好做法，足以为互操作性建立基线。鼓励实施人员在部署时研究并使用被认为等效或较好的替代机制。建议以可以部署新身份验证方案的方式实施客户端。由于此协议使用HTTP响应状态代码作为报告请求结果的主要方式，因此建议服务器使用适当的4xx HTTP响应代码（例如，401&amp;ldquo;未经授权&amp;rdquo;或403&amp;ldquo;禁止&amp;rdquo;）&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="b27e5a48d6a66251fa9d4883723e1c6d86c30969" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol uses HTTP methods to author Member
   Resources as follows:

   o  GET is used to retrieve a representation of a known Resource.

   o  POST is used to create a new, dynamically named, Resource.  When
      the client submits non-Atom-Entry representations to a Collection
      for creation, two Resources are always created -- a Media Entry
      for the requested Resource, and a Media Link Entry for metadata
      about the Resource that will appear in the Collection.

   o  PUT is used to edit a known Resource.  It is not used for Resource
      creation.

   o  DELETE is used to remove a known Resource.

   The Atom Protocol only covers the creating, editing, and deleting of
   Entry and Media Resources.  Other Resources could be created, edited,
   and deleted as the result of manipulating a Collection, but the
   number of those Resources, their media types, and effects of Atom
   Protocol operations on them are outside the scope of this
   specification. 

   Since all aspects of client-server interaction are defined in terms
   of HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] should be consulted for any areas not covered in
   this specification.</source>
          <target state="translated">Atom发布协议使用HTTP方法来创作成员资源，如下所示：o GET用于检索已知资源的表示形式。 o POST用于创建新的动态命名资源。当客户端将非原子条目表示形式提交给集合以进行创建时，将始终创建两个资源-所请求资源的媒体条目，以及将出现在集合中的有关资源元数据的媒体链接条目。 o PUT用于编辑已知资源。它不用于资源创建。 o DELETE用于删除已知资源。 Atom协议仅涵盖条目，媒体资源的创建，编辑和删除。通过操纵集合，可以创建，编辑和删除其他资源，但是这些资源的数量，它们的媒体类型以及Atom协议操作对其的影响不在本规范的范围之内。由于客户端-服务器交互的所有方面都是根据HTTP定义的，因此[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;对于本规范未涵盖的任何领域，请查阅RFC2616。</target>
        </trans-unit>
        <trans-unit id="42d277116045b96cf12bbfe45ba81c76ae3ef5f2" translate="yes" xml:space="preserve">
          <source>The Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] defines the &quot;application/
   atom+xml&quot; media type to identify both Atom Feed and Atom Entry
   Documents.  Implementation experience has demonstrated that Atom Feed
   and Entry Documents can have different processing models and that
   there are situations where they need to be differentiated.  This
   specification defines a &quot;type&quot; parameter used to differentiate the
   two types of Atom documents.</source>
          <target state="translated">Atom联合格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]定义了&amp;ldquo; application / atom + xml&amp;rdquo;媒体类型，以同时标识Atom Feed和Atom Entry文档。实施经验表明，Atom Feed和Entry Documents可以具有不同的处理模型，并且在某些情况下需要对其进行区分。该规范定义了一个&amp;ldquo;类型&amp;rdquo;参数，用于区分两种类型的Atom文档。</target>
        </trans-unit>
        <trans-unit id="6a14656993634aa0a74177de15aa55441d492abb" translate="yes" xml:space="preserve">
          <source>The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all 

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of &quot;example.com:25&quot; would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.</source>
          <target state="translated">CONNECT方法请求接收者建立到由请求目标标识的目的地原始服务器的隧道，如果成功，则此后将其行为限制为双向盲目转发数据包，直到关闭隧道为止。隧道通常用于通过一个或多个代理创建端到端虚拟连接，然后可以使用TLS（传输层安全性[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]）。 CONNECT仅用于对代理的请求中。接收到自己的CONNECT请求的源服务器可以使用2xx（成功）状态码进行响应，以指示已建立连接。但是，大多数原始服务器不实现CONNECT。发送CONNECT请求的客户端必须发送请求目标的授权形式（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230] 5.3节）&lt;/a&gt;）;也就是说，请求目标仅包含隧道目标的主机名和端口号，并用冒号分隔。例如，CONNECT server.example.com:80 HTTP / 1.1主机：server.example.com：80收件人代理可以通过直接连接到请求目标，或者（如果配置为使用另一个代理）通过转发来建立隧道。 CONNECT请求到下一个入站代理。任何2xx（成功）响应都表示发件人（和所有入站代理）将在结束成功响应的标头部分的空白行之后立即切换到隧道模式；空行之后收到的数据来自请求目标所标识的服务器。除成功响应外，任何其他响应都表明尚未建立隧道，并且该连接仍受HTTP控制。当隧道中间人检测到任一方已关闭其连接时，该隧道即被关闭：中间人务必尝试将来自封闭方的任何未完成的数据发送到另一方，同时关闭两个连接，然后丢弃所有未交付的剩余数据。代理身份验证可用于建立创建隧道的权限。例如，CONNECT server.example.com:80 HTTP / 1.1主机：server.example.com：80代理授权：基本aGVsbG86d29ybGQ =建立通往任意服务器的隧道存在很大的风险，特别是当目标是不用于Web流量的众所周知的或保留的TCP端口时。例如，连接到&amp;ldquo; example.com:25&amp;rdquo;的请求目标将建议代理连接到用于SMTP流量的保留端口。如果允许，这可能会诱使代理中继垃圾邮件。支持CONNECT的代理应该将它的使用限制为一组有限的已知端口或安全请求目标的可配置白名单。服务器不得在2xx（成功）响应中向CONNECT发送任何Transfer-Encoding或Content-Length头字段。客户端必须忽略在成功响应CONNECT时收到的任何Content-Length或Transfer-Encoding头字段。 CONNECT请求消息中的有效负载没有定义的语义。在CONNECT请求上发送有效内容主体可能会导致某些现有实现拒绝该请求。对CONNECT方法的响应不可缓存。</target>
        </trans-unit>
        <trans-unit id="5cc173ef45538302331fa209f0189866cab3850f" translate="yes" xml:space="preserve">
          <source>The COPY method creates a duplicate of the source resource identified
   by the Request-URI, in the destination resource identified by the URI
   in the Destination header.  The Destination header MUST be present.
   The exact behavior of the COPY method depends on the type of the
   source resource.

   All WebDAV-compliant resources MUST support the COPY method.
   However, support for the COPY method does not guarantee the ability
   to copy a resource.  For example, separate programs may control
   resources on the same server.  As a result, it may not be possible to
   copy a resource to a location that appears to be on the same server.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">COPY方法在Destination标头中的URI标识的目标资源中，创建由Request-URI标识的源资源的副本。目标报头必须存在。 COPY方法的确切行为取决于源资源的类型。所有符合WebDAV的资源都必须支持COPY方法。但是，对COPY方法的支持不能保证复制资源的能力。例如，单独的程序可以控制同一服务器上的资源。结果，可能无法将资源复制到似乎在同一服务器上的位置。此方法是幂等的，但并不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="14111f3c8a7b4d6556d104b92402303159cbab91" translate="yes" xml:space="preserve">
          <source>The COPY method on a collection without a Depth header MUST act as if
   a Depth header with value &quot;infinity&quot; was included.  A client may
   submit a Depth header on a COPY on a collection with a value of &quot;0&quot;
   or &quot;infinity&quot;.  Servers MUST support the &quot;0&quot; and &quot;infinity&quot; Depth
   header behaviors on WebDAV-compliant resources.

   An infinite-depth COPY instructs that the collection resource
   identified by the Request-URI is to be copied to the location
   identified by the URI in the Destination header, and all its internal
   member resources are to be copied to a location relative to it,
   recursively through all levels of the collection hierarchy.  Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.

   A COPY of &quot;Depth: 0&quot; only instructs that the collection and its
   properties, but not resources identified by its internal member URLs,
   are to be copied.

   Any headers included with a COPY MUST be applied in processing every
   resource to be copied with the exception of the Destination header.

   The Destination header only specifies the destination URI for the
   Request-URI.  When applied to members of the collection identified by
   the Request-URI, the value of Destination is to be modified to
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://example.com/ and the 

   Destination is http://example.com/b/, then when
   http://example.com/a/c/d is processed, it must use a Destination of
   http://example.com/b/c/d.

   When the COPY method has completed processing, it MUST have created a
   consistent URL namespace at the destination (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the
   definition of namespace consistency).  However, if an error occurs
   while copying an internal collection, the server MUST NOT copy any
   resources identified by members of this collection (i.e., the server
   must skip this subtree), as this would create an inconsistent
   namespace.  After detecting an error, the COPY operation SHOULD try
   to finish as much of the original copy operation as possible (i.e.,
   the server should still attempt to copy other subtrees and their
   members that are not descendants of an error-causing collection).

   So, for example, if an infinite-depth copy operation is performed on
   collection /a/, which contains collections /a/b/ and /a/c/, and an
   error occurs copying /a/b/, an attempt should still be made to copy
   /a/c/.  Similarly, after encountering an error copying a non-
   collection resource as part of an infinite-depth copy, the server
   SHOULD try to finish as much of the original copy operation as
   possible.

   If an error in executing the COPY method occurs with a resource other
   than the resource identified in the Request-URI, then the response
   MUST be a 207 (Multi-Status), and the URL of the resource causing the
   failure MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a COPY method.  These responses can
   be safely omitted because the client will know that the progeny of a
   resource could not be copied when the client receives an error for
   the parent.  Additionally, 201 (Created)/204 (No Content) status
   codes SHOULD NOT be returned as values in 207 (Multi-Status)
   responses from COPY methods.  They, too, can be safely omitted
   because they are the default success codes.</source>
          <target state="translated">没有深度标头的集合上的COPY方法必须像包含值&amp;ldquo;无穷大&amp;rdquo;的深度标头一样工作。客户可以在值为&amp;ldquo; 0&amp;rdquo;或&amp;ldquo; infinity&amp;rdquo;的集合的COPY上提交Depth标头。服务器必须在符合WebDAV的资源上支持&amp;ldquo; 0&amp;rdquo;和&amp;ldquo;无限&amp;rdquo;深度标头行为。无限深度COPY指示将Request-URI标识的收集资源复制到Destination标头中URI标识的位置，并将其所有内部成员资源递归复制到相对于其的位置收集层次结构的所有级别。请注意，如果处理不正确，则/ A /到/ A / B /的无限深度COPY可能导致无限递归。 &amp;ldquo;深度：0&amp;rdquo;仅指示要复制集合及其属性，而不复制其内部成员URL所标识的资源。COPY附带的任何标头都必须用于处理要复制的每个资源，但目的地标头除外。 Destination标头仅指定Request-URI的目标URI，当应用于Request-URI标识的集合的成员时，将修改Destination的值以反映层次结构中的当前位置。 -URI为/ a /，主机标头值为http://example.com/，目标为http://example.com/b/，然后在处理http://example.com/a/c/d时，它必须使用http://example.com/b/c/d的目标。COPY方法完成处理后，它必须在目标位置创建了一致的URL名称空间（请参见&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节&lt;/a&gt;（用于命名空间一致性的定义）。但是，如果在复制内部集合时发生错误，则服务器不得复制该集合成员标识的任何资源（即服务器必须跳过此子树），因为这将导致名称空间不一致。在检测到错误之后，COPY操作应尝试完成尽可能多的原始复制操作（即，服务器仍应尝试复制不是引起错误的集合的后代的其他子树及其成员）。因此，例如，如果对包含集合/ a / b /和/ a / c /的集合/ a /执行无限深度复制操作，并且在复制/ a / b /时发生错误，则仍应尝试复制/ a / c /。同样，在将非收集资源作为无限深度副本的一部分复制时遇到错误后，服务器应尝试完成尽可能多的原始副本操作。如果在请求URI中标识的资源以外的资源发生执行COPY方法的错误，则响应必须为207（多状态），并且导致失败的资源的URL必须与特定内容一起出现错误。 COPY方法不应在207（多状态）响应中返回424（依赖关系失败）状态码。可以安全地省略这些响应，因为当客户端收到父级的错误时，客户端将知道无法复制资源的后代。另外，COPY方法的207（多状态）响应中的值不应返回201（已创建）/ 204（无内容）状态码。由于它们是默认的成功代码，因此也可以安全地省略它们。</target>
        </trans-unit>
        <trans-unit id="4ccb4eecacf9e00ad51b2aefeb841f59a202bd7d" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Modern browsers use CORS in APIs such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to mitigate the risks of cross-origin HTTP requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbf23077eb5623c9faba43d84ac7826f9fbf870" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to help mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORS机制支持安全的跨域请求和浏览器与Web服务器之间的数据传输。现代浏览器在 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch之&lt;/a&gt;类的API容器中使用CORS，以帮助减轻跨源HTTP请求的风险。</target>
        </trans-unit>
        <trans-unit id="96ee35d668c5e43e29f1dd8cb8ffc05ffe8f756d" translate="yes" xml:space="preserve">
          <source>The CORS protocol originally required that behavior but &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;was subsequently changed to no longer require it&lt;/a&gt;. However, not all browsers have implemented the change, and so still exhibit the behavior that was originally required.</source>
          <target state="translated">CORS协议最初要求该行为，但&lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;后来更改为不再需要它&lt;/a&gt;。但是，并非所有的浏览器都实现了此更改，因此仍然表现出最初所需的行为。</target>
        </trans-unit>
        <trans-unit id="90251c7853324d5188765c4d4396bb48f7d83e13" translate="yes" xml:space="preserve">
          <source>The CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive should be used with this header, otherwise this header will be an expensive no-op machine.</source>
          <target state="translated">CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;指令应与此头一起使用，否则此头将是昂贵的无操作机器。</target>
        </trans-unit>
        <trans-unit id="bb80a0a4cc2668fea5fc69f81138adf60314c6bd" translate="yes" xml:space="preserve">
          <source>The CSP mechanism allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1440f01ca2c2191b9c319acb6ec56e362606ce" translate="yes" xml:space="preserve">
          <source>The Cache-Control general-header field is used to specify directives
   that MUST be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.

      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see &lt;a href=&quot;#section-14.32&quot;&gt;section 14.32&lt;/a&gt;).

   Cache directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-
   directive for a specific cache.

    Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           &quot;no-cache&quot;                          ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                          ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;, 14.9.4
         | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;no-transform&quot;                      ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;only-if-cached&quot;                    ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | cache-extension                     ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

     cache-response-directive =
           &quot;public&quot;                               ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;private&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ] ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-cache&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                             ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;no-transform&quot;                         ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;must-revalidate&quot;                      ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;proxy-revalidate&quot;                     ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | cache-extension                        ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

    cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ] 

   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of the HTTP protocol might apply these directives to
   header fields not defined in HTTP/1.1.

   The cache-control directives can be broken down into these general
   categories:

      - Restrictions on what are cacheable; these may only be imposed by
        the origin server.

      - Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.

      - Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.

      - Controls over cache revalidation and reload; these may only be
        imposed by a user agent.

      - Control over transformation of entities.

      - Extensions to the caching system.</source>
          <target state="translated">Cache-Control general-header字段用于指定指令，请求/响应链中的所有缓存机制都必须遵守这些指令。指令指定了旨在防止缓存不利地影响请求或响应的行为。这些指令通常会覆盖默认的缓存算法。高速缓存伪指令是单向的，因为在请求中存在伪指令并不意味着在响应中将给出相同的伪指令。请注意，HTTP / 1.0缓存可能未实现Cache-Control，而可能仅实现了Pragma：no-cache（请参阅&lt;a href=&quot;#section-14.32&quot;&gt;第14.32节）&lt;/a&gt;）。缓存指令必须由代理或网关应用程序传递，无论它们对该应用程序的意义如何，因为这些指令可能适用于请求/响应链上的所有接收者。无法为特定的高速缓存指定高速缓存指令。 Cache-Control =&amp;ldquo; Cache-Control&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃cache-directive缓存指令=缓存请求指令|缓存响应指令缓存请求指令=&amp;ldquo; no-cache&amp;rdquo;; &lt;a href=&quot;#section-14.9.1&quot;&gt;第14.9.1节&lt;/a&gt; | &amp;ldquo;无商店&amp;rdquo;；&lt;a href=&quot;#section-14.9.2&quot;&gt;第14.9.2节&lt;/a&gt; | &amp;ldquo; max-age&amp;rdquo;&amp;ldquo; =&amp;rdquo;增量秒；&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt;，14.9.4 节 | &amp;ldquo;最大陈旧&amp;rdquo;[&amp;ldquo; =&amp;rdquo; delta-seconds]; &lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt; | &amp;ldquo; min-fresh&amp;rdquo;&amp;ldquo; =&amp;rdquo;增量秒；&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt; | &amp;ldquo;不变换&amp;rdquo;；&lt;a href=&quot;#section-14.9.5&quot;&gt;第14.9.5节&lt;/a&gt; | &amp;ldquo;仅当缓存&amp;rdquo;；&lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节&lt;/a&gt; |缓存扩展&lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6节&lt;/a&gt; cache-response-directive =&amp;ldquo; public&amp;rdquo;; &lt;a href=&quot;#section-14.9.1&quot;&gt;第14.9.1节&lt;/a&gt; | &amp;ldquo; private&amp;rdquo; [&amp;ldquo; =&amp;rdquo; &amp;lt;&amp;ldquo;&amp;gt; 1＃field-name &amp;lt;&amp;rdquo;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;第14.9.1节&lt;/a&gt; | &amp;ldquo; no-cache&amp;rdquo; [&amp;ldquo; =&amp;rdquo; &amp;lt;&amp;ldquo;&amp;gt; 1＃field-name &amp;lt;&amp;rdquo;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;第14.9.1节&lt;/a&gt; | &amp;ldquo;无商店&amp;rdquo;；&lt;a href=&quot;#section-14.9.2&quot;&gt;第14.9.2节&lt;/a&gt; | &amp;ldquo;不变换&amp;rdquo;；&lt;a href=&quot;#section-14.9.5&quot;&gt;第14.9.5节&lt;/a&gt; | &amp;ldquo;必须重新验证&amp;rdquo;；&lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节&lt;/a&gt; | &amp;ldquo;代理重新验证&amp;rdquo;；&lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节&lt;/a&gt; | &amp;ldquo; max-age&amp;rdquo;&amp;ldquo; =&amp;rdquo;增量秒；&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt; | &amp;ldquo; s-maxage&amp;rdquo;&amp;ldquo; =&amp;rdquo;增量秒；&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt; |缓存扩展&lt;a href=&quot;#section-14.9.6&quot;&gt;第14.9.6节&lt;/a&gt; cache-extension =令牌[&amp;ldquo; =&amp;rdquo;（令牌| quoted-string）]出现没有任何1＃field-name参数的指令时，该指令适用于整个请求或响应。当这样的指令与1＃field-name参数一起出现时，它仅适用于一个或多个命名字段，而不适用于请求或响应的其余部分。该机制支持可扩展性。 HTTP协议的未来版本的实现可能会将这些指令应用于HTTP / 1.1中未定义的标头字段。缓存控制指令可以分为以下几类：-对可缓存内容的限制；这些只能由原始服务器强加。 -对缓存可能存储的内容的限制；这些可以由原始服务器或用户代理强加。-修改基本到期机制；这些可以由原始服务器或用户代理强加。 -控制缓存重新验证和重新加载；这些只能由用户代理强加。 -控制实体的转换。 -扩展缓存系统。</target>
        </trans-unit>
        <trans-unit id="9324bfa18c0087b8561a3281ae4b9944c65be9ca" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) MAY be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.

   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.

   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

       Cache-Control: private, community=&quot;UCI&quot;

   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior. 

   Unrecognized cache-directives MUST be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).</source>
          <target state="translated">Cache-Control头域可以通过使用一个或多个cache-extension标记来扩展,每个标记都有一个可选的赋值。信息性扩展(那些不需要改变缓存行为的扩展)可以在不改变其他指令语义的情况下被添加。行为性扩展是作为现有缓存指令基础的修改器而设计的。新指令和标准指令都被提供了,这样,不理解新指令的应用程序将默认为标准指令所指定的行为,而理解新指令的应用程序将承认它修改了与标准指令相关的要求。通过这种方式,可以在不需要修改基础协议的情况下对缓存控制指令进行扩展。这种扩展机制依赖于HTTP缓存服从所有为其原生HTTP-版本定义的缓存控制指令,服从某些扩展,并忽略所有它不理解的指令。例如,考虑一个名为community的假设性新响应指令,它作为私有指令的修饰符。我们将这个新指令定义为,除了任何非共享的缓存外,任何仅由其值中命名的community成员共享的缓存都可以缓存响应。一个希望允许UCI社区在他们的共享缓存中使用原本私有的响应的起源服务器可以通过包含Cache-Control:private,community=&quot;UCI&quot; 看到这个头字段的缓存将正确地行动,即使缓存不理解社区缓存扩展,因为它也会看到并理解私有指令,从而默认为安全行为。未识别的缓存指令必须被忽略;我们假设任何可能未被HTTP/1.1缓存识别的缓存指令将与标准指令(或响应的默认缓存性)相结合,这样即使缓存不理解扩展,缓存行为也会保持最低限度的正确性。</target>
        </trans-unit>
        <trans-unit id="f33f8e03ed1edc160f54d39609d6b7e8bfc2a2f7" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional value.  A cache
   MUST ignore unrecognized cache directives.

   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other
   directives.

   Behavioral extensions are designed to work by acting as modifiers to
   the existing base of cache directives.  Both the new directive and
   the old directive are supplied, such that applications that do not
   understand the new directive will default to the behavior specified
   by the old directive, and those that understand the new directive
   will recognize it as modifying the requirements associated with the
   old directive.  In this way, extensions to the existing cache-control
   directives can be made without breaking deployed caches.

   For example, consider a hypothetical new response directive called
   &quot;community&quot; that acts as a modifier to the private directive: in
   addition to private caches, any cache that is shared only by members
   of the named community is allowed to cache the response.  An origin
   server wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

     Cache-Control: private, community=&quot;UCI&quot;

   A cache that recognizes such a community cache-extension could
   broaden its behavior in accordance with that extension.  A cache that
   does not recognize the community cache-extension would ignore it and
   adhere to the private directive.</source>
          <target state="translated">Cache-Control头字段可以通过使用一个或多个cache-extension标记来扩展,每个标记都有一个可选的值。缓存必须忽略未识别的缓存指令。信息性扩展(那些不需要改变缓存行为的扩展)可以在不改变其他指令语义的情况下被添加。行为性扩展是通过作为现有缓存指令基础的修改器来工作的。同时提供新指令和旧指令,这样,不理解新指令的应用程序将默认为旧指令指定的行为,而理解新指令的应用程序将承认它修改了与旧指令相关的要求。通过这种方式,可以在不破坏部署的缓存的情况下对现有的缓存控制指令进行扩展。例如,考虑一个名为 &quot;community &quot;的假设性新响应指令,它作为私有指令的修改器:除了私有缓存外,任何仅由命名的community成员共享的缓存都允许缓存响应。希望允许UCI社区在他们的共享缓存中使用私有响应的起源服务器可以通过包含Cache-Control:private,community=&quot;UCI&quot; 识别这样一个社区缓存扩展的缓存可以根据该扩展扩展其行为。不承认社区缓存扩展的缓存将忽略它,并遵守私有指令。</target>
        </trans-unit>
        <trans-unit id="b85b1bbcc9141ccc627797dbf9d5406273b17461" translate="yes" xml:space="preserve">
          <source>The California Consumer Privacy Act</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50007c31e7e40ed5eaa0ff3024c3f4a7f1a8be9" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/Blink-based engines) user agent string is similar to Firefox&amp;rsquo;s. For compatibility, it adds strings like &lt;code&gt;KHTML, like Gecko&lt;/code&gt; and &lt;code&gt;Safari&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4526b0c406ce54b0f40282cbe0ea0db53127d37" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/blink-based engines) user agent string is similar to the Firefox format. For compatibility, it adds strings like &quot;KHTML, like Gecko&quot; and &quot;Safari&quot;.</source>
          <target state="translated">Chrome(或基于Chromium/blink的引擎)用户代理字符串与Firefox格式类似。为了兼容性,它增加了 &quot;KHTML,像Gecko &quot;和 &quot;Safari &quot;等字符串。</target>
        </trans-unit>
        <trans-unit id="4e445db7bcb2d5d8898885e114adb8cb0619ec53" translate="yes" xml:space="preserve">
          <source>The Connection general-header field allows the sender to specify
   options that are desired for that particular connection and MUST NOT
   be communicated by proxies over further connections.

   The Connection header has the following grammar:

       Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
       connection-token  = token

   HTTP/1.1 proxies MUST parse the Connection header field before a
   message is forwarded and, for each connection-token in this field,
   remove any header field(s) from the message with the same name as the
   connection-token. Connection options are signaled by the presence of
   a connection-token in the Connection header field, not by any
   corresponding additional header field(s), since the additional header
   field may not be sent if there are no parameters associated with that
   connection option.

   Message headers listed in the Connection header MUST NOT include
   end-to-end headers, such as Cache-Control.

   HTTP/1.1 defines the &quot;close&quot; connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,

       Connection: close

   in either the request or the response header fields indicates that
   the connection SHOULD NOT be considered `persistent' (&lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;)
   after the current request/response is complete.

   HTTP/1.1 applications that do not support persistent connections MUST
   include the &quot;close&quot; connection option in every message.

   A system receiving an HTTP/1.0 (or lower-version) message that
   includes a Connection header MUST, for each connection-token in this
   field, remove and ignore any header field(s) from the message with
   the same name as the connection-token. This protects against mistaken
   forwarding of such header fields by pre-HTTP/1.1 proxies. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;.</source>
          <target state="translated">连接通用头字段允许发送方指定该特定连接所需的选项，并且代理不得在其他连接上进行通信。 Connection标头具有以下语法：Connection =&amp;ldquo; Connection&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃（connection-token）connection-token =令牌HTTP / 1.1代理必须在转发消息之前对Connection标头字段进行解析，并针对每个连接令牌在此字段中，从消息中删除与连接令牌同名的所有标头字段。连接选项是通过Connection标头字段中存在连接令牌而不是任何相应的其他标头字段来表示的，因为如果没有与该连接选项关联的参数，则可能不会发送附加头字段。连接头中列出的消息头不得包含端对端头，例如Cache-Control。 HTTP / 1.1为发送方定义了&amp;ldquo;关闭&amp;rdquo;连接选项，以指示响应完成后将关闭连接。例如，在请求或响应标头字段中的Connection：close指示不应将连接视为&amp;ldquo;持久&amp;rdquo;（发送者的连接选项，用于指示响应完成后将关闭连接。例如，在请求或响应标头字段中的Connection：close指示不应将连接视为&amp;ldquo;持久&amp;rdquo;（发送者的连接选项，用于指示响应完成后将关闭连接。例如，在请求或响应标头字段中的Connection：close指示不应将连接视为&amp;ldquo;持久&amp;rdquo;（&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;）在当前请求/响应完成之后。不支持持久连接的HTTP / 1.1应用程序必须在每条消息中都包含&amp;ldquo;关闭&amp;rdquo;连接选项。接收包含连接标头的HTTP / 1.0（或更低版本）消息的系统，对于此字段中的每个连接令牌，必须从消息中删除并忽略与该标头同名的任何标头字段，令牌。这样可以防止HTTP / 1.1之前的代理错误转发此类标头字段。参见&lt;a href=&quot;#section-19.6.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2 &lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="400f4aed66b4ae488aed6a9f1d0ba0a1d48e0bf5" translate="yes" xml:space="preserve">
          <source>The Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) provides a &quot;close&quot;
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.

   A client that sends a &quot;close&quot; connection option MUST NOT send further
   requests on that connection (after the one containing &quot;close&quot;) and
   MUST close the connection after reading the final response message
   corresponding to this request.

   A server that receives a &quot;close&quot; connection option MUST initiate a
   close of the connection (see below) after it sends the final response
   to the request that contained &quot;close&quot;.  The server SHOULD send a
   &quot;close&quot; connection option in its final response on that connection.
   The server MUST NOT process any further requests received on that
   connection.

   A server that sends a &quot;close&quot; connection option MUST initiate a close
   of the connection (see below) after it sends the response containing
   &quot;close&quot;.  The server MUST NOT process any further requests received
   on that connection.

   A client that receives a &quot;close&quot; connection option MUST cease sending
   requests on that connection and close the connection after reading
   the response message containing the &quot;close&quot;; if additional pipelined
   requests had been sent on the connection, the client SHOULD NOT
   assume that they will be processed by the server. 

   If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.</source>
          <target state="translated">连接头字段（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）提供了&amp;ldquo;关闭&amp;rdquo;连接选项，当发送方希望在当前请求/响应对之后关闭连接时，发送方应该发送该连接选项。发送&amp;ldquo;关闭&amp;rdquo;连接选项的客户端不得在该连接上发送进一步的请求（在包含&amp;ldquo;关闭&amp;rdquo;的连接之后），并且必须在读取与该请求相对应的最终响应消息后关闭该连接。收到&amp;ldquo;关闭&amp;rdquo;连接选项的服务器在发送对包含&amp;ldquo;关闭&amp;rdquo;的请求的最终响应后，必须启动连接的关闭（请参见下文）。服务器应该在对该连接的最终响应中发送&amp;ldquo;关闭&amp;rdquo;连接选项。服务器不得处理在该连接上收到的任何其他请求。发送&amp;ldquo;&amp;ldquo;关闭&amp;rdquo;连接选项必须在发送包含&amp;ldquo;关闭&amp;rdquo;的响应后启动连接的关闭（请参见下文）。服务器不得处理该连接上收到的任何其他请求。收到&amp;ldquo;关闭&amp;rdquo;连接选项的客户端必须停止在读取包含&amp;ldquo;关闭&amp;rdquo;的响应消息后，在该连接上发送请求并关闭该连接；如果在该连接上发送了其他流水线请求，则客户端不应假定服务器将处理它们。立即关闭TCP连接，则存在很大的风险，即客户端将无法读取最后的HTTP响应。如果服务器在完全关闭的连接上从客户端接收到其他数据，例如，客户端在收到服务器响应之前发送的另一个请求，服务器的TCP堆栈将向客户端发送重置数据包；不幸的是，在客户端的HTTP解析器可以读取和解释它们之前，复位数据包可能会擦除客户端的未确认输入缓冲区。为了避免TCP重置问题，服务器通常分阶段关闭连接。首先，服务器通过仅关闭读/写连接的写侧来执行半关闭。然后，服务器继续从连接中读取数据，直到服务器接收到客户端的相应关闭，或者直到服务器合理地确定其自己的TCP堆栈已收到客户端对包含服务器最后响应的数据包的确认为止。最后，服务器完全关闭连接。重置问题是TCP独占的还是其他传输连接协议中也可能存在，这是未知的。</target>
        </trans-unit>
        <trans-unit id="e4269110c11e8492bcb4464320596b28df93a15f" translate="yes" xml:space="preserve">
          <source>The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;].

        content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                              disposition-type *( &quot;;&quot; disposition-parm )
        disposition-type = &quot;attachment&quot; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &quot;=&quot; ( token | quoted-string )

   An example is

        Content-Disposition: attachment; filename=&quot;fname.ext&quot;

   The receiving user agent SHOULD NOT respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename SHOULD be treated as a terminal component only.

   If this header is used in a response with the application/octet-
   stream content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.

   See &lt;a href=&quot;#section-15.5&quot;&gt;section 15.5&lt;/a&gt; for Content-Disposition security issues.</source>
          <target state="translated">已经提出了Content-Disposition响应标头字段，作为原始服务器在用户请求将内容保存到文件时建议默认文件名的一种方式。这种用法是从&lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [ &lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;]。 content-disposition =&amp;ldquo; Content-Disposition&amp;rdquo;&amp;ldquo;：&amp;rdquo;处置类型*（&amp;ldquo;;&amp;rdquo; disposition-parm）处置类型=&amp;ldquo; attachment&amp;rdquo; | disp-extension-token处置参数=文件名-参数| disp-extension-parm filename-parm =&amp;ldquo; filename&amp;rdquo;&amp;ldquo; =&amp;rdquo;带引号的字符串disp-extension-token =令牌disp-extension-parm =令牌&amp;ldquo; =&amp;rdquo;（token | quoted-string）一个示例是Content-Disposition：附件; filename =&amp;ldquo; fname.ext&amp;rdquo;接收方用户代理不应遵守filename-parm参数中存在的任何目录路径信息，该参数是目前被认为适用于HTTP实现的唯一参数。文件名应仅被视为终端组件。如果此标头用于应用程序/八位流内容类型的响应中，则暗示建议用户代理不应显示该响应，而应直接输入&amp;ldquo;将响应另存为...&amp;rdquo;对话框。看到&lt;a href=&quot;#section-15.5&quot;&gt;&lt;/a&gt;关于内容处置安全性问题的15.5节。</target>
        </trans-unit>
        <trans-unit id="22177303e5c541de4c1a2fb13e69fc833be5a044" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding

   Content codings are defined in &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;. An example of its use is

       Content-Encoding: gzip

   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy MAY modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   &quot;no-transform&quot; cache-control directive is present in the message.

   If the content-coding of an entity is not &quot;identity&quot;, then the
   response MUST include a Content-Encoding entity-header (&lt;a href=&quot;#section-14.11&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;) that lists the non-identity content-coding(s) used.

   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server SHOULD respond with a
   status code of 415 (Unsupported Media Type).

   If multiple encodings have been applied to an entity, the content
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.</source>
          <target state="translated">&amp;ldquo;内容编码实体标题&amp;rdquo;字段用作媒体类型的修饰符。当存在时，其值指示已将哪些其他内容编码应用于实体，因此必须应用哪种解码机制才能获得Content-Type标头字段引用的媒体类型。内容编码主要用于允许压缩文档而不会丢失其基础媒体类型的标识。Content-Encoding =&amp;ldquo; Content-Encoding&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃content-coding内容编码在&lt;a href=&quot;#section-3.5&quot;&gt;3.5节&lt;/a&gt;中定义。其用法的一个示例是Content-Encoding：gzip content-coding是由Request-URI标识的实体的特征。通常，实体-主体使用此编码存储，并且仅在渲染或类似用法之前进行解码。但是，如果已知新的编码是接收者可以接受的，则非透明代理可以修改内容编码，除非消息中存在&amp;ldquo; no-transform&amp;rdquo;缓存控制指令。如果实体的内容编码不是&amp;ldquo; identity&amp;rdquo;，则响应必须包含一个Content-Encoding实体头（&lt;a href=&quot;#section-14.11&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11 &lt;/a&gt;节）），其中列出了使用的非身份内容编码。如果请求消息中实体的内容编码对原始服务器不可接受，则服务器应以状态代码415（不支持的媒体类型）进行响应。如果对实体应用了多种编码，则内容编码必须按其应用顺序列出。关于编码参数的附加信息可以由本规范未定义的其他实体报头字段提供。</target>
        </trans-unit>
        <trans-unit id="78e0f66604a34d6350aaee50ec1aed948b641dff" translate="yes" xml:space="preserve">
          <source>The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.

       Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is

       Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the &quot;Treaty of
   Waitangi,&quot; presented simultaneously in the original Maori and English
   versions, would call for

       Content-Language: mi, en

   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as &quot;A First
   Lesson in Latin,&quot; which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Content-Language实体标题字段描述了封闭实体的预期受众的自然语言。请注意，这可能并不等同于实体主体中使用的所有语言。 Content-Language =&amp;ldquo; Content-Language&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃language-tag语言标签在&lt;a href=&quot;#section-3.10&quot;&gt;3.10节&lt;/a&gt;中定义。内容语言的主要目的是允许用户根据用户自己喜欢的语言来识别和区分实体。因此，如果正文内容仅适用于丹麦语读者，则适当的字段为Content-Language：da如果未指定Content-Language，则默认值为该内容适用于所有语言的读者。这可能意味着发件人不认为它是特定于任何自然语言的，或者发件人不知道它打算使用哪种语言。可能会列出针对多种受众的内容使用多种语言。例如，在原始毛利语和英语版本中同时呈现的&amp;ldquo;怀唐伊条约&amp;rdquo;的译本将要求使用Content-Language：mi，zh_cn但是，仅仅因为一个实体中存在多种语言，并不意味着它旨在用于多种语言的受众。一个例子是初学者的语言入门，例如&amp;ldquo;拉丁文的第一课&amp;rdquo;，显然是供有英语水平的听众使用的。在这种情况下，内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。</target>
        </trans-unit>
        <trans-unit id="a1abd3b0ff945fb9c54be7f36c23b898d0262eca" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the
   entity-body, in decimal number of OCTETs, sent to the recipient or,
   in the case of the HEAD method, the size of the entity-body that
   would have been sent had the request been a GET.

       Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT

   An example is

       Content-Length: 3495

   Applications SHOULD use this field to indicate the transfer-length of
   the message-body, unless this is prohibited by the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 

   Any Content-Length greater than or equal to zero is a valid value.
   &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; describes how to determine the length of a message-body
   if a Content-Length is not given.

   Note that the meaning of this field is significantly different from
   the corresponding definition in MIME, where it is an optional field
   used within the &quot;message/external-body&quot; content-type. In HTTP, it
   SHOULD be sent whenever the message's length can be determined prior
   to being transferred, unless this is prohibited by the rules in
   &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Content-Length实体标头字段指示发送给接收方的实体的大小（以OCTET的十进制数为单位），如果使用HEAD方法，则表示已发送的实体的大小。该请求是GET。 Content-Length =&amp;ldquo; Content-Length&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1 * DIGIT例如Content-Length：3495应用程序应使用此字段指示消息正文的传输长度，除非&lt;a href=&quot;#section-4.4&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4 &lt;/a&gt;节中的规则禁止。任何大于或等于零的Content-Length都是有效值。 &lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;描述了如果未指定Content-Length时如何确定消息正文的长度。请注意，此字段的含义与MIME中的相应定义明显不同，MIME是MIME中相应的定义，它是&amp;ldquo;消息/外部主体&amp;rdquo;内容类型中使用的可选字段。在HTTP中，只要在传输之前可以确定消息的长度，就应该发送该消息，除非&lt;a href=&quot;#section-4.4&quot;&gt;4.4节中&lt;/a&gt;的规则禁止这样做 。</target>
        </trans-unit>
        <trans-unit id="f5000316ac8e17d070fa4e93bb14ed2071d4d60f" translate="yes" xml:space="preserve">
          <source>The Content-Location entity-header field MAY be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server SHOULD provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server SHOULD provide a Content-Location
   for the particular variant which is returned.

       Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                         ( absoluteURI | relativeURI )

   The value of Content-Location also defines the base URI for the
   entity.

   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests MAY specify the Content-Location URI as the request-
   URI if the desire is to identify the source of that particular
   entity.

   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-
   Location can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &lt;a href=&quot;#section-13.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;.

   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.

   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.</source>
          <target state="translated">当可以从与请求资源的URI不同的位置访问该实体时，可以使用Content-Location实体头字段为消息中包含的实体提供资源位置。服务器应为对应于响应实体的变量提供Content-Location；特别是在一个资源有多个与之相关联的实体，并且这些实体实际上具有可以单独访问它们的单独位置的情况下，服务器应该为返回的特定变体提供一个Content-Location。 Content-Location =&amp;ldquo; Content-Location&amp;rdquo;&amp;ldquo;：&amp;rdquo;（absoluteURI | relativeURI）Content-Location的值还定义了实体的基本URI。Content-Location值不能替代原始请求的URI。它仅是请求时与该特定实体相对应的资源位置的声明。如果希望识别特定实体的来源，将来的请求可以将Content-Location URI指定为request-URI。缓存不能假定Content-Location不同于用于检索它的URI的实体可用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源检索到的多个实体，如它仅是请求时与该特定实体相对应的资源位置的声明。如果希望识别特定实体的来源，以后的请求可以将Content-Location URI指定为请求URI。缓存不能假定Content-Location与用于检索它的URI不同的实体可以用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源检索到的多个实体，如它仅是请求时与该特定实体相对应的资源位置的声明。如果希望识别特定实体的来源，以后的请求可以将Content-Location URI指定为请求URI。缓存不能假定Content-Location与用于检索它的URI不同的实体可以用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源检索到的多个实体，如缓存不能假定Content-Location与用于检索它的URI不同的实体可以用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源中检索到的多个实体，如缓存不能假定Content-Location与用于检索它的URI不同的实体可以用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源检索到的多个实体，如&lt;a href=&quot;#section-13.6&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6 &lt;/a&gt;节。如果Content-Location是相对URI，则相对URI是相对于请求URI解释的。PUT或POST请求中Content-Location标头的含义未定义；在这种情况下，服务器可以随意忽略它。</target>
        </trans-unit>
        <trans-unit id="6782e7664ef97f5aa5c3c489b023d738a78d068c" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [&lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt;], is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)

        Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
        md5-digest   = &amp;lt;base64 of 128 bit MD5 digest as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt;

   The Content-MD5 header field MAY be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients MAY generate the Content-MD5 header field;
   proxies and gateways MUST NOT generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-
   body, including gateways and proxies, MAY check that the digest value
   in this header field matches that of the entity-body as received.

   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding MUST be removed
   prior to checking the Content-MD5 value against the received entity.

   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.

   HTTP extends &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.

   There are several consequences of this. The entity-body for composite
   types MAY contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-
   Encoding or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.

   Conversion of all line breaks to CRLF MUST NOT be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted MUST be left unaltered when computing
   the digest. 

      Note: while the definition of Content-MD5 is exactly the same for
      HTTP as in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [ &lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt; ]中定义的Content-MD5实体报头字段是实体主体的MD5摘要，目的是提供实体主体的端到端消息完整性检查（MIC）。（注意：MIC可以很好地检测出运输过程中实体的意外修改，但不能证明没有遭到恶意攻击。）Content-MD5 =&amp;ldquo; Content-MD5&amp;rdquo;&amp;ldquo;：&amp;rdquo; md5-digest md5-digest = &amp;lt;base64 of根据&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864的&lt;/a&gt; 128位MD5摘要&amp;gt; Content-MD5标头字段可以由源服务器或客户端生成，以用作实体主体的完整性检查。只有原始服务器或客户端可以生成Content-MD5标头字段；代理和网关绝不能生成它，因为这会破坏其作为端到端完整性检查的价值。实体主体的任何接收者，包括网关和代理，都可以检查该头字段中的摘要值是否与接收到的实体主体的摘要值匹配。基于实体主体的内容（包括已应用的任何内容编码，但不包括应用于消息主体的任何传输编码）来计算MD5摘要。如果接收到的消息带有传输编码，则必须在根据接收到的实体检查Content-MD5值之前删除该编码。这样的结果是，摘要在实体主体的八位位组上的计算完全相同，并且如果不应用传输编码，则将按顺序发送。 HTTP扩展&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;允许针对MIME复合媒体类型（例如multipart / *和message / rfc822）计算摘要，但这不会更改上段中定义的摘要的计算方式。这有几个后果。复合类型的实体主体可以包含许多主体部分，每个主体部分都有自己的MIME和HTTP标头（包括Content-MD5，Content-Transfer-Encoding和Content-Encoding标头）。如果主体部分具有Content-Transfer-Encoding或Content-Encoding标头，则假定主体部分的内容已应用编码，并且主体部分按原样包含在Content-MD5摘要中-即申请后。身体部位不允许使用Transfer-Encoding标头字段。在计算或检查摘要之前，绝不能将所有换行符转换为CRLF：在实际中传输摘要时，在文本中实际使用的换行惯例必须保持不变。注意：虽然Content-MD5的HTTP定义与&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;&lt;/a&gt;针对MIME实体的RFC 1864，Content-MD5在HTTP实体上的应用与在MIME实体上的应用有几种不同的方式。一个是HTTP与MIME不同，它不使用Content-Transfer-Encoding，而是使用Transfer-Encoding和Content-Encoding。另一个是HTTP比MIME更频繁地使用二进制内容类型，因此值得注意的是，在这种情况下，用于计算摘要的字节顺序是为该类型定义的传输字节顺序。最后，HTTP允许使用几种换行约定中的任何一种来传输文本类型，而不仅仅是使用CRLF的规范形式。</target>
        </trans-unit>
        <trans-unit id="ff07970e216340fa2fb8373a79c1c42c82bcf1ba" translate="yes" xml:space="preserve">
          <source>The Content-Range entity-header is sent with a partial entity-body to
   specify where in the full entity-body the partial body should be
   applied. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

       Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec &quot;/&quot;
                                 ( instance-length | &quot;*&quot; )

       byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                      | &quot;*&quot;
       instance-length           = 1*DIGIT

   The header SHOULD indicate the total length of the full entity-body,
   unless this length is unknown or difficult to determine. The asterisk
   &quot;*&quot; character means that the instance-length is unknown at the time
   when the response was generated.

   Unlike byte-ranges-specifier values (see &lt;a href=&quot;#section-14.35.1&quot;&gt;section 14.35.1&lt;/a&gt;), a byte-
   range-resp-spec MUST only specify one range, and MUST contain
   absolute byte positions for both the first and last byte of the
   range.

   A byte-content-range-spec with a byte-range-resp-spec whose last-
   byte-pos value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-
   spec MUST ignore it and any content transferred along with it.

   A server sending a response with status code 416 (Requested range not
   satisfiable) SHOULD include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;. The instance-length specifies the current length of 

   the selected resource. A response with status code 206 (Partial
   Content) MUST NOT include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;.

   Examples of byte-content-range-spec values, assuming that the entity
   contains a total of 1234 bytes:

      . The first 500 bytes:
       bytes 0-499/1234

      . The second 500 bytes:
       bytes 500-999/1234

      . All except for the first 500 bytes:
       bytes 500-1233/1234

      . The last 500 bytes:
       bytes 734-1233/1234

   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a Content-Range header, and a Content-Length header
   showing the number of bytes actually transferred. For example,

       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif

   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is &quot;multipart/byteranges&quot; as defined
   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.

   A response to a request for a single range MUST NOT be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, MAY be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message MUST NOT ask for multiple
   byte-ranges in a single request.

   When a client requests multiple byte-ranges in one request, the
   server SHOULD return them in the order that they appeared in the
   request. 

   If the server ignores a byte-range-spec because it is syntactically
   invalid, the server SHOULD treat the request as if the invalid Range
   header field did not exist. (Normally, this means return a 200
   response containing the full entity).

   If the server receives a request (other than one including an If-
   Range request-header field) with an unsatisfiable Range request-
   header field (that is, all of whose byte-range-spec values have a
   first-byte-pos value greater than the current length of the selected
   resource), it SHOULD return a response code of 416 (Requested range
   not satisfiable) (&lt;a href=&quot;#section-10.4.17&quot;&gt;section 10.4.17&lt;/a&gt;).

      Note: clients cannot depend on servers to send a 416 (Requested
      range not satisfiable) response instead of a 200 (OK) response for
      an unsatisfiable Range request-header, since not all servers
      implement this request-header.</source>
          <target state="translated">Content-Range实体标头与部分实体主体一起发送，以指定应在整个实体主体中的何处应用部分主体。范围单位在&lt;a href=&quot;#section-3.12&quot;&gt;第3.12节&lt;/a&gt;中定义。 Content-Range =&amp;ldquo; Content-Range&amp;rdquo;&amp;ldquo;：&amp;rdquo;&amp;ldquo;内容范围规范content-range-spec =字节内容范围规范byte-content-range-spec =字节单位SP byte-range-resp-spec&amp;rdquo; /&amp;ldquo;（instance-length |&amp;rdquo; *&amp;ldquo;）byte-range-resp-spec =（第一个字节pos&amp;rdquo;-&amp;ldquo;最后一个字节pos）| &amp;ldquo; *&amp;rdquo; instance-length = 1 * DIGIT标头应指示整个实体的总长度，除非该长度未知或难以确定。星号&amp;ldquo; *&amp;rdquo;表示在生成响应时实例长度未知。与字节范围指定符值不同（请参见&lt;a href=&quot;#section-14.35.1&quot;&gt;第14.35.1节）&lt;/a&gt;），字节范围-resp-spec必须仅指定一个范围，并且必须包含该范围的第一个和最后一个字节的绝对字节位置。字节范围-resp-spec的字节内容范围规范，其最后一个字节pos值小于其第一个字节pos值，或者其实例长度值小于或等于其最后一个byte-pos值byte-pos值，无效。无效字节内容范围规范的接收者必须忽略它以及与之一起传输的任何内容。发送状态代码为416（请求范围不能满足）的响应的服务器应该包括一个Content-Range字段，其字节范围响应规范为&amp;ldquo; *&amp;rdquo;。 instance-length指定所选资源的当前长度。状态码为206（部分内容）的响应不得包含&amp;ldquo;字节数范围说明&amp;rdquo;为&amp;ldquo; *&amp;rdquo;的&amp;ldquo;内容范围&amp;rdquo;字段。假设实体总共包含1234个字节，则为byte-content-range-spec值的示例：前500个字节：字节0-499 / 1234。后500个字节：字节500-999 / 1234。除前500个字节外，全部：字节500-1233 / 1234。最后500个字节：字节734-1233 / 1234当HTTP消息包含单个范围的内容时（例如，对单个范围的请求的响应或对一组重叠但没有任何漏洞的请求的响应） ），则使用Content-Range标头和显示实际传输的字节数的Content-Length标头发送此内容。例如，HTTP / 1。1206部分内容日期：1995年11月15日星期三06:25:24 GMT上次修改时间：1995年11月15日星期三04:58:08 GMT内容范围：字节21010-47021 / 47022内容长度：26012内容类型：image / gif当HTTP消息包含多个范围的内容（例如，对多个非重叠范​​围的请求的响应）时，这些内容将作为多部分消息进行传输。如附录19.2所定义，用于此目的的multipart媒体类型是&amp;ldquo; multipart / byteranges&amp;rdquo;。有关兼容性问题，请参见附录19.6.3。不得使用multipart / byteranges媒体类型发送对单个范围的请求的响应。对多个范围（其结果是单个范围）的请求的响应，可以作为多部分/字节范围媒体类型（包含一部分）发送。不能解码multipart / byteranges消息的客户端不得在单个请求中要求多个字节范围。当客户端在一个请求中请求多个字节范围时，服务器应按它们在请求中出现的顺序返回它们。如果服务器由于语法无效而忽略了字节范围规范，则服务器应将请求视为无效的Range标头字段不存在。 （通常，这意味着返回包含完整实体的200响应）。如果服务器接收到一个请求（除了包含If-Range请求头域的请求），但请求的头域不满足要求（即所有字节范围指定值的first-byte-pos值都更大）比所选资源的当前长度），它应返回响应代码416（请求的范围无法满足）（&lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17节&lt;/a&gt;）。注意：对于不满意的Range请求标头，客户端不能依赖服务器发送416（请求范围无法满足）响应而不是200（OK）响应，因为并非所有服务器都实现此请求标头。</target>
        </trans-unit>
        <trans-unit id="e283ef83ad0c98c2f0776bde603c318284d66f81" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type

   Media types are defined in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;. An example of the field is

       Content-Type: text/html; charset=ISO-8859-4

   Further discussion of methods for identifying the media type of an
   entity is provided in &lt;a href=&quot;#section-7.2.1&quot;&gt;section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Content-Type实体标头字段指示发送给接收者的实体主体的媒体类型，或者在HEAD方法的情况下，指示如果请求是GET则应发送的媒体类型。 Content-Type =&amp;ldquo; Content-Type&amp;rdquo;&amp;ldquo;：&amp;rdquo;媒体类型媒体类型在&lt;a href=&quot;#section-3.7&quot;&gt;3.7节&lt;/a&gt;中定义。该字段的一个示例是Content-Type：text / html; charset = ISO-8859-4在&lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1节中&lt;/a&gt;提供了有关标识实体媒体类型的方法的进一步讨论。</target>
        </trans-unit>
        <trans-unit id="037f56850e2d9507141cb0bfad334028f9b60f2f" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with an HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &quot;credentials&quot; (including &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.</source>
          <target state="translated">跨域资源共享标准通过添加新的&lt;a href=&quot;headers&quot;&gt;HTTP标头来工作&lt;/a&gt;，这些标头允许服务器描述允许使用Web浏览器读取该信息的一组来源。此外，对于可能导致服务器数据产生副作用的HTTP请求方法（特别是对于&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;以外的HTTP方法或某些&lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME类型的&lt;/a&gt;&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;使用），该规范要求浏览器&amp;ldquo;预检&amp;rdquo;请求，并请求支持的方法从服务器使用HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;请求方法，然后在服务器&amp;ldquo;批准&amp;rdquo;后，使用实际的HTTP请求方法发送实际的请求。服务器还可以通知客户端&amp;ldquo;凭据&amp;rdquo;（包括&lt;a href=&quot;cookies&quot;&gt;Cookie&lt;/a&gt;和HTTP身份验证数据）应与请求一起发送。</target>
        </trans-unit>
        <trans-unit id="a3df3b7b4551cce965a08ca5b788db7477ac35eb" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with the HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request. Servers can also inform clients whether &quot;credentials&quot; (such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and &lt;a href=&quot;authentication&quot;&gt;HTTP Authentication&lt;/a&gt;) should be sent with requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858dfd56015c8a42c014f2e88a9adef69bbf8f6d" translate="yes" xml:space="preserve">
          <source>The DELETE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header with
   a DELETE on a collection with any value but infinity.

   DELETE instructs that the collection specified in the Request-URI and
   all resources identified by its internal member URLs are to be
   deleted.

   If any resource identified by a member URL cannot be deleted, then
   all of the member's ancestors MUST NOT be deleted, so as to maintain
   URL namespace consistency.

   Any headers included with DELETE MUST be applied in processing every
   resource to be deleted.

   When the DELETE method has completed processing, it MUST result in a
   consistent URL namespace.

   If an error occurs deleting a member resource (a resource other than
   the resource identified in the Request-URI), then the response can be
   a 207 (Multi-Status).  Multi-Status is used here to indicate which
   internal resources could NOT be deleted, including an error code,
   which should help the client understand which resources caused the
   failure.  For example, the Multi-Status body could include a response
   with status 423 (Locked) if an internal resource was locked.

   The server MAY return a 4xx status response, rather than a 207, if
   the request failed completely.

   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-
   Status) response for DELETE.  They can be safely left out because the
   client will know that the ancestors of a resource could not be
   deleted when the client receives an error for the ancestor's progeny.
   Additionally, 204 (No Content) errors SHOULD NOT be returned in the
   207 (Multi-Status).  The reason for this prohibition is that 204 (No
   Content) is the default success code.</source>
          <target state="translated">集合上的DELETE方法必须像使用了 &quot;Depth:infinity &quot;头一样。客户端决不能在一个集合上提交带有DELETE的Depth头,该集合的值只有infinity。DELETE指示将删除Request-URI中指定的集合以及由其内部成员URL标识的所有资源。如果不能删除成员URL所标识的任何资源,那么该成员的所有祖先必须不被删除,以保持URL命名空间的一致性。在处理每个要删除的资源时,必须应用DELETE包含的任何头信息。当DELETE方法完成处理后,它必须产生一个一致的URL命名空间。如果在删除一个成员资源(Request-URI中标识的资源以外的资源)时发生错误,那么响应可以是207(Multi-Status)。这里使用Multi-Status来指示哪些内部资源不能被删除,包括错误代码,这应该有助于客户机了解是哪些资源导致了失败。例如,如果一个内部资源被锁定,Multi-Status主体可以包含一个状态423(Locked)的响应。如果请求完全失败,服务器可以返回4xx状态响应,而不是207。424(Failed Dependency)状态码不应该出现在DELETE的207(Multi-Status)响应中。它们可以安全地被排除在外,因为当客户端收到祖先的后代的错误时,客户端将知道资源的祖先不能被删除。此外,204(无内容)错误不应该在207(多状态)中返回。之所以这样禁止,是因为204(无内容)是默认的成功代码。</target>
        </trans-unit>
        <trans-unit id="e71c2610a983fa8562e2bcbd279e311806bf6084" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server delete the resource
   identified by the Request-URI. This method MAY be overridden by human
   intervention (or other means) on the origin server. The client cannot
   be guaranteed that the operation has been carried out, even if the
   status code returned from the origin server indicates that the action
   has been completed successfully. However, the server SHOULD NOT
   indicate success unless, at the time the response is given, it
   intends to delete the resource or move it to an inaccessible
   location.

   A successful response SHOULD be 200 (OK) if the response includes an
   entity describing the status, 202 (Accepted) if the action has not
   yet been enacted, or 204 (No Content) if the action has been enacted
   but the response does not include an entity.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.</source>
          <target state="translated">DELETE方法要求源服务器删除由Request-URI标识的资源。这个方法可以被源服务器上的人为干预(或其他手段)所覆盖。即使源服务器返回的状态码表明操作已经成功完成,客户端也不能保证操作已经完成。但是,服务器不应表示成功,除非在给出响应时,它打算删除资源或将其移动到一个不可访问的位置。如果响应包括描述状态的实体,则成功的响应应该是200(OK);如果操作尚未执行,则应该是202(Accepted);如果操作已经执行但响应不包括实体,则应该是204(No Content)。如果请求通过缓存,并且 Request-URI 识别了一个或多个当前缓存的实体,则这些条目应被视为陈旧。此方法的响应是不可缓存的。</target>
        </trans-unit>
        <trans-unit id="c974be9fc532fcdd84db91fdeb0ba6b9b0cfa15b" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement 

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">DELETE方法请求原始服务器删除目标资源与其当前功能之间的关联。实际上，此方法类似于UNIX中的rm命令：它在源服务器的URI映射上表示删除操作，而不是期望删除先前关联的信息。如果目标资源具有一个或多个当前表示，则它们可能会或可能不会被原始服务器销毁，并且相关的存储可能会或可能不会被回收，这完全取决于资源的性质及其由原始服务器的实现（超出了本规范的范围）。同样，由于DELETE，可能需要停用或归档资源的其他实现方面，例如数据库或网关连接。通常，假定原始服务器仅对具有预定机制以完成删除的资源允许DELETE。相对而言，很少有资源允许使用DELETE方法-它的主要用途是用于远程创作环境，在该环境中，用户对其效果有所了解。例如，先前使用PUT请求创建的资源，或在对POST请求进行201（已创建）响应后通过位置标头字段标识的资源，可能允许相应的DELETE请求撤消那些操作。同样，实现创作功能的自定义用户代理实现（例如使用HTTP进行远程操作的版本控制客户端）可能会基于服务器的假设使用DELETEURI空间经过精心设计，以与版本库相对应。如果成功应用了DELETE方法，则源服务器应在操作可能成功但尚未执行之前发送202（接受）状态代码，如果操作已经执行且不再进行进一步操作，则发送204（无内容）状态代码。要提供信息，或者如果已执行操作且响应消息包括描述状态的表示，则提供200（确定）状态码。 DELETE请求消息中的有效负载没有定义的语义；在DELETE请求上发送有效内容正文可能会导致某些现有实现拒绝该请求。对DELETE方法的响应不可缓存。如果DELETE请求通过一个缓存，该缓存具有一个或多个存储的有效请求URI的响应，这些存储的响应将无效（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234]的4.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dd290a0d44bd1aedc43b87181e19c3e8fd871af9" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which
   the message was originated, having the same semantics as orig-date in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;. The field value is an HTTP-date, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;; it MUST be sent in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-date format.

       Date  = &quot;Date&quot; &quot;:&quot; HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   Origin servers MUST include a Date header field in all responses,
   except in these cases: 

      1. If the response status code is 100 (Continue) or 101 (Switching
         Protocols), the response MAY include a Date header field, at
         the server's option.

      2. If the response status code conveys a server error, e.g. 500
         (Internal Server Error) or 503 (Service Unavailable), and it is
         inconvenient or impossible to generate a valid Date.

      3. If the server does not have a clock that can provide a
         reasonable approximation of the current time, its responses
         MUST NOT include a Date header field. In this case, the rules
         in &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; MUST be followed.

   A received message that does not have a Date header field MUST be
   assigned one by the recipient if the message will be cached by that
   recipient or gatewayed via a protocol which requires a Date. An HTTP
   implementation without a clock MUST NOT cache responses without
   revalidating them on every use. An HTTP cache, especially a shared
   cache, SHOULD use a mechanism, such as NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], to synchronize its
   clock with a reliable external standard.

   Clients SHOULD only send a Date header field in messages that include
   an entity-body, as in the case of the PUT and POST requests, and even
   then it is optional. A client without a clock MUST NOT send a Date
   header field in a request.

   The HTTP-date sent in a Date header SHOULD NOT represent a date and
   time subsequent to the generation of the message. It SHOULD represent
   the best available approximation of the date and time of message
   generation, unless the implementation has no means of generating a
   reasonably accurate date and time. In theory, the date ought to
   represent the moment just before the entity is generated. In
   practice, the date can be generated at any time during the message
   origination without affecting its semantic value.</source>
          <target state="translated">&amp;ldquo;日期&amp;rdquo;一般标题字段表示消息发出的日期和时间，其语义与&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822中的&lt;/a&gt; orig-date相同 。字段值是HTTP日期，如&lt;a href=&quot;#section-3.3.1&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1 &lt;/a&gt;节所述；必须在&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8中&lt;/a&gt;发送]-日期格式。 Date =&amp;ldquo; Date&amp;rdquo;&amp;ldquo;：&amp;rdquo; HTTP-date例如：Date：Tue，15 Nov 1994 08:12:31 GMT原始服务器必须在所有响应中包括Date标头字段，以下情况除外：1.如果响应状态如果代码是100（继续）或101（交换协议），则响应可以包括Date头字段，由服务器选择。 2.如果响应状态代码传达服务器错误，例如500（内部服务器错误）或503（服务不可用），则不方便或无法生成有效的日期。 3.如果服务器没有可以提供当前时间的合理近似值的时钟，则其响应必须不包括Date标头字段。在这种情况下，&lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1节中的规则&lt;/a&gt;必须遵循。如果消息将由该收件人缓存或通过需要日期的协议进行网关传送，则接收方必须为接收到的没有日期标题字段的消息分配一个消息。没有时钟的HTTP实现绝不能缓存响应，而不必在每次使用时都重新验证它们。 HTTP缓存，尤其是共享缓存，应使用NTP等机制[ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;]，以使其时钟与可靠的外部标准同步。客户端应该只在包含实体主体的消息中发送Date头字段，例如在PUT和POST请求的情况下，即使这样它也是可选的。没有时钟的客户端不得在请求中发送Date标头字段。在Date标头中发送的HTTP-date不应代表消息生成后的日期和时间。它应该代表消息生成日期和时间的最佳可用近似值，除非实现没有办法生成合理准确的日期和时间。从理论上讲，日期应代表实体生成之前的时刻。实际上，可以在消息发起期间的任何时间生成日期，而不会影响其语义值。</target>
        </trans-unit>
        <trans-unit id="6903ec22652fb8e7c29947078193d2ba673e0d45" translate="yes" xml:space="preserve">
          <source>The Depth header may be used with the LOCK method.  Values other than
   0 or infinity MUST NOT be used with the Depth header on a LOCK
   method.  All resources that support the LOCK method MUST support the
   Depth header.

   A Depth header of value 0 means to just lock the resource specified
   by the Request-URI.

   If the Depth header is set to infinity, then the resource specified
   in the Request-URI along with all its members, all the way down the
   hierarchy, are to be locked.  A successful result MUST return a
   single lock token.  Similarly, if an UNLOCK is successfully executed
   on this token, all associated resources are unlocked.  Hence, partial
   success is not an option for LOCK or UNLOCK.  Either the entire
   hierarchy is locked or no resources are locked.

   If the lock cannot be granted to all resources, the server MUST
   return a Multi-Status response with a 'response' element for at least
   one resource that prevented the lock from being granted, along with a
   suitable status code for that failure (e.g., 403 (Forbidden) or 423
   (Locked)).  Additionally, if the resource causing the failure was not
   the resource requested, then the server SHOULD include a 'response'
   element for the Request-URI as well, with a 'status' element
   containing 424 Failed Dependency.

   If no Depth header is submitted on a LOCK request, then the request
   MUST act as if a &quot;Depth:infinity&quot; had been submitted.</source>
          <target state="translated">深度头可以和LOCK方法一起使用。LOCK 方法的深度标头不得使用 0 或无穷大以外的值。所有支持 LOCK 方法的资源都必须支持深度头。值为0的深度头意味着只锁定Request-URI指定的资源。如果深度头被设置为无穷大,那么Request-URI中指定的资源及其所有成员,一直到层次结构,都将被锁定。一个成功的结果必须返回一个单一的锁定令牌。同样,如果在这个标记上成功执行了UNLOCK,所有相关的资源都会被解锁。因此,部分成功不是LOCK或UNLOCK的选项。要么整个层次结构被锁定,要么没有资源被锁定。如果不能向所有资源授予锁,服务器必须返回一个多状态响应,其中包含至少一个阻止授予锁的资源的 &quot;响应 &quot;元素,以及该失败的适当状态代码(例如,403(禁止)或423(锁定))。此外,如果导致失败的资源不是被请求的资源,那么服务器也应该为Request-URI包含一个 &quot;响应 &quot;元素,并包含一个包含424 Failed Dependency的 &quot;状态 &quot;元素。如果在LOCK请求上没有提交Depth头,那么该请求必须像提交了 &quot;Depth:infinity &quot;一样。</target>
        </trans-unit>
        <trans-unit id="35342d84dcd43dba8096f5d5b39874e99cb4604b" translate="yes" xml:space="preserve">
          <source>The Destination request header specifies the URI that identifies a
   destination resource for methods such as COPY and MOVE, which take
   two URIs as parameters.

      Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref


   If the Destination value is an absolute-URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of
   [RFC3986]&lt;/a&gt;), it may name a different server (or different port or
   scheme).  If the source server cannot attempt a copy to the remote
   server, it MUST fail the request.  Note that copying and moving
   resources to remote servers is not fully defined in this
   specification (e.g., specific error conditions). 

   If the Destination value is too long or otherwise unacceptable, the
   server SHOULD return 400 (Bad Request), ideally with helpful
   information in an error body.</source>
          <target state="translated">Destination请求标头指定URI，该URI标识诸如COPY和MOVE之类的方法的目标资源，这些方法将两个URI作为参数。 Destination =&amp;ldquo; Destination&amp;rdquo;&amp;ldquo; ::&amp;rdquo;简单引用如果Destination值为绝对URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]的4.3节&lt;/a&gt;），则它可以命名其他服务器（或其他端口或方案）。如果源服务器无法尝试复制到远程服务器，则它必须使请求失败。请注意，在本规范中并未完全定义将资源复制和移动到远程服务器（例如，特定的错误条件）。如果目标值太长或不可接受，则服务器应返回400（错误请求），最好在错误正文中包含有用的信息。</target>
        </trans-unit>
        <trans-unit id="5ec562967c3ab4eb672c7b7fd0765b0c9a09d6b8" translate="yes" xml:space="preserve">
          <source>The ETag response-header field provides the current value of the
   entity tag for the requested variant. The headers used with entity
   tags are described in sections &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;. The entity tag
   MAY be used for comparison with other entities from the same resource
   (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

      ETag = &quot;ETag&quot; &quot;:&quot; entity-tag

   Examples:

      ETag: &quot;xyzzy&quot;
      ETag: W/&quot;xyzzy&quot;
      ETag: &quot;&quot;</source>
          <target state="translated">ETag响应标头字段提供所请求变体的实体标签的当前值。与实体标签使用的头中各节中描述&lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;，&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;和&lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;。实体标签可以用于与同一资源中的其他实体进行比较（参见&lt;a href=&quot;#section-13.3.3&quot;&gt;第13.3.3节&lt;/a&gt;）。 ETag =&amp;ldquo; ETag&amp;rdquo;&amp;ldquo;：&amp;rdquo;实体标签示例：ETag：&amp;ldquo; xyzzy&amp;rdquo; ETag：W /&amp;ldquo; xyzzy&amp;rdquo; ETag：&amp;ldquo;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="4712a2d0dd6a27be4029656072d6f063c6808073" translate="yes" xml:space="preserve">
          <source>The ETag response-header field value, an entity tag, provides for an
   &quot;opaque&quot; cache validator. This might allow more reliable validation
   in situations where it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.

   Entity Tags are described in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The headers used with
   entity tags are described in sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;, &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;.</source>
          <target state="translated">ETag响应标头字段值（一个实体标签）提供了一个&amp;ldquo;不透明&amp;rdquo;的缓存验证器。在不方便存储修改日期，HTTP日期值的一秒分辨率不足或原始服务器希望避免使用修改日期而引起的某些悖论的情况下，这可能允许更可靠的验证。 。实体标签在&lt;a href=&quot;#section-3.11&quot;&gt;3.11节&lt;/a&gt;中描述。与实体标签使用的头中各节中描述&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;，&lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;，&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;和&lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e574d1947b2d7656ccf38b993e2056ebdd1b0a0" translate="yes" xml:space="preserve">
          <source>The Expect request-header field is used to indicate that particular
   server behaviors are required by the client.

      Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

      expectation  =  &quot;100-continue&quot; | expectation-extension
      expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                               *expect-params ]
      expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]


   A server that does not understand or is unable to comply with any of
   the expectation values in the Expect field of a request MUST respond
   with appropriate error status. The server MUST respond with a 417
   (Expectation Failed) status if any of the expectations cannot be met
   or, if there are other problems with the request, some other 4xx
   status.

   This header field is defined with extensible syntax to allow for
   future extensions. If a server receives a request containing an
   Expect field that includes an expectation-extension that it does not
   support, it MUST respond with a 417 (Expectation Failed) status.

   Comparison of expectation values is case-insensitive for unquoted
   tokens (including the 100-continue token), and is case-sensitive for
   quoted-string expectation-extensions. 

   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST
   return a 417 (Expectation Failed) status if it receives a request
   with an expectation that it cannot meet. However, the Expect
   request-header itself is end-to-end; it MUST be forwarded if the
   request is forwarded.

   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the
   Expect header.

   See &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for the use of the 100 (continue) status.</source>
          <target state="translated">Expect请求标头字段用于指示客户端要求特定的服务器行为。期望=&amp;ldquo;期望&amp;rdquo;&amp;ldquo;：&amp;rdquo;&amp;ldquo; 1＃期望期望=&amp;rdquo; 100-继续&amp;ldquo; |期望扩展期望扩展=标记[&amp;ldquo; =&amp;rdquo;（标记|带引号的字符串）*期望参数]期望参数=&amp;ldquo;;&amp;rdquo; token [&amp;ldquo; =&amp;rdquo;（token | quoted-string）]不理解或无法遵守请求的Expect字段中的任何期望值的服务器必须以适当的错误状态进行响应。如果不能满足任何期望，或者如果请求有其他问题，则服务器必须以417（期望失败）状态做出响应，或者其他4xx状态。此标头字段使用可扩展语法定义，以允许将来扩展。如果服务器收到一个包含Expect字段的请求，该请求包含一个不支持的Expectation-Extension，则它必须以417（Expectation Failed）状态响应。期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到期望无法满足的请求，则它必须返回417（期望失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到看到看到看到看到看到看到如果服务器收到一个包含Expect字段的请求，该请求包含一个不支持的Expectation-Extension，则它必须以417（Expectation Failed）状态响应。期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到预期无法满足的请求，则它必须返回417（预期失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到如果服务器收到一个包含Expect字段的请求，该请求包含一个不支持的Expectation-Extension，则它必须以417（Expectation Failed）状态响应。期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到期望无法满足的请求，则它必须返回417（期望失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到看到看到期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到预期无法满足的请求，则它必须返回417（预期失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到期望无法满足的请求，则它必须返回417（期望失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到如果1个代理收到预期无法满足的请求，则必须返回417（预期失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到如果1个代理收到预期无法满足的请求，则必须返回417（预期失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到&lt;a href=&quot;#section-8.2.3&quot;&gt;第8.2.3节&lt;/a&gt;使用100（继续）状态。</target>
        </trans-unit>
        <trans-unit id="99ea10caeb88c8a848354c782365979235f3abbc" translate="yes" xml:space="preserve">
          <source>The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See &lt;a href=&quot;#section-13.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; for further discussion of the expiration model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The format is an absolute date and time as defined by HTTP-date in
   &lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;; it MUST be in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; date format:

      Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date

   An example of its use is

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

      Note: if a response includes a Cache-Control field with the max-
      age directive (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;), that directive overrides the
      Expires field.

   HTTP/1.1 clients and caches MUST treat other invalid date formats,
   especially including the value &quot;0&quot;, as in the past (i.e., &quot;already
   expired&quot;).

   To mark a response as &quot;already expired,&quot; an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;.) 

   To mark a response as &quot;never expires,&quot; an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one
   year in the future.

   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">Expires实体标题字段提供了将日期/时间视为过期的日期/时间。缓存（代理缓存或用户代理缓存）通常不会返回陈旧的缓存条目，除非首先使用源服务器（或使用具有实体的新副本的中间缓存）对其进行验证。有关到期模型的进一步讨论，请参见&lt;a href=&quot;#section-13.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2 &lt;/a&gt;节。Expires字段的存在并不意味着原始资源将在该时间之前，之后或之后改变或不再存在。格式是绝对日期和时间，如&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节中的&lt;/a&gt; HTTP-date所定义 ；它必须在&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123中&lt;/a&gt;日期格式：Expires =&amp;ldquo; Expires&amp;rdquo;&amp;ldquo;：&amp;rdquo; HTTP-date它的使用示例是Expires：Thu，01 Dec 1994 16:00:00 GMT注意：如果响应包含带有maxage指令的Cache-Control字段（请参见&lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3节&lt;/a&gt;），该指令将覆盖Expires字段。 HTTP / 1.1客户端和缓存必须像过去一样对待其他无效的日期格式，尤其是包括值&amp;ldquo; 0&amp;rdquo;（即&amp;ldquo;已经过期&amp;rdquo;）。要将响应标记为&amp;ldquo;已过期&amp;rdquo;，原始服务器将发送一个等于Date标头值的Expires日期。 （请参阅&lt;a href=&quot;#section-13.2.4&quot;&gt;第13.2.4节中的&lt;/a&gt;到期时间计算规则。）要将响应标记为&amp;ldquo;永不过期&amp;rdquo;，则源服务器会从发送响应之日起大约一年后发送一个Expires日期。 HTTP / 1.1服务器不应发送超过一年的过期日期。响应上存在将来某个日期的日期值的Expires标头字段，否则默认情况下将是不可缓存的，这表明该响应是可缓存的，除非由Cache-Control标头字段另行指示（&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt;） 。</target>
        </trans-unit>
        <trans-unit id="074a25a70f6f59d4456b693beabbab06efa52e09" translate="yes" xml:space="preserve">
          <source>The Feature Policy directive to apply the &lt;code&gt;allowlist&lt;/code&gt; to. See &lt;a href=&quot;#Directives&quot;&gt;Directives&lt;/a&gt; below for a list of the permitted directive names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802828c9e44a9d19272a3ae660a11b2bb9d689e1" translate="yes" xml:space="preserve">
          <source>The Feature-Policy HTTP header</source>
          <target state="translated">特征-政策HTTP头</target>
        </trans-unit>
        <trans-unit id="8b610252bef915d12d88c567e1882bdb3b137742" translate="yes" xml:space="preserve">
          <source>The From request-header field, if given, SHOULD contain an Internet
   e-mail address for the human user who controls the requesting user
   agent. The address SHOULD be machine-usable, as defined by &quot;mailbox&quot;
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]:

       From   = &quot;From&quot; &quot;:&quot; mailbox

   An example is:

       From: webmaster@w3.org

   This header field MAY be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requests. It SHOULD NOT
   be used as an insecure form of access protection. The interpretation
   of this field is that the request is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   particular, robot agents SHOULD include this header so that the
   person responsible for running the robot can be contacted if problems
   occur on the receiving end.

   The Internet e-mail address in this field MAY be separate from the
   Internet host which issued the request. For example, when a request
   is passed through a proxy the original issuer's address SHOULD be
   used.

   The client SHOULD NOT send the From header field without the user's
   approval, as it might conflict with the user's privacy interests or
   their site's security policy. It is strongly recommended that the
   user be able to disable, enable, and modify the value of this field
   at any time prior to a request.</source>
          <target state="translated">发件人请求头字段（如果提供）应该包含控制请求用户代理的人类用户的Internet电子邮件地址。地址应为机器可用，如通过&amp;ldquo;邮箱&amp;rdquo;中定义&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]如通过更新&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]：发件人=&amp;ldquo;发件人&amp;rdquo;&amp;ldquo;：&amp;rdquo;邮箱例如：发件人：webmaster@w3.org此标头字段可用于记录目的，并用作标识无效或不需要的请求的来源。不应将其用作访问保护的不安全形式。该字段的解释是，请求是代表给定的人执行的，该人对执行的方法承担责任。特别是，机器人代理应包含此标头，以便在接收端发生问题时可以联系负责运行机器人的人员。此字段中的Internet电子邮件地址可以与发出请求的Internet主机分开。例如，当请求通过代理传递时，原始发行者的的地址应使用。在未经用户批准的情况下，客户端不应该发送From头字段，因为它可能与用户的隐私权或他们站点的安全策略冲突。强烈建议用户在请求之前的任何时候都可以禁用，启用和修改此字段的值。</target>
        </trans-unit>
        <trans-unit id="8a3df35a0d664c78b3c3b6d7181ee8d7a2e5448f" translate="yes" xml:space="preserve">
          <source>The GET method means retrieve whatever information (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing process, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
   process, unless that text happens to be the output of the process.

   The semantics of the GET method change to a &quot;conditional GET&quot; if the
   request message includes an If-Modified-Since, If-Unmodified-Since,
   If-Match, If-None-Match, or If-Range header field. A conditional GET
   method requests that the entity be transferred only under the
   circumstances described by the conditional header field(s). The
   conditional GET method is intended to reduce unnecessary network
   usage by allowing cached entities to be refreshed without requiring
   multiple requests or transferring data already held by the client.

   The semantics of the GET method change to a &quot;partial GET&quot; if the
   request message includes a Range header field. A partial GET requests
   that only part of the entity be transferred, as described in &lt;a href=&quot;#section-14.35&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;. The partial GET method is intended to reduce unnecessary
   network usage by allowing partially-retrieved entities to be
   completed without transferring data already held by the client.

   The response to a GET request is cacheable if and only if it meets
   the requirements for HTTP caching described in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations when used for forms.</source>
          <target state="translated">GET方法意味着检索由Request-URI标识的任何信息（以实体的形式）。如果Request-URI涉及数据产生过程，则应将产生的数据作为响应中的实体返回，而不是过程的源文本，除非该文本恰好是过程的输出。如果请求消息包含If-Modified-Since，If-Unmodified-Since，If-Match，If-None-Match或If-Range标头字段，则GET方法的语义将变为&amp;ldquo;条件GET&amp;rdquo;。条件GET方法仅在条件标头字段描述的情况下才请求转移实体。有条件的GET方法旨在通过允许刷新缓存的实体而无需多个请求或传输客户端已经拥有的数据来减少不必要的网络使用。如果请求消息包含Range标头字段，则GET方法的语义将更改为&amp;ldquo;部分GET&amp;rdquo;。部分GET请求仅转移实体的一部分，如&lt;a href=&quot;#section-14.35&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35条&lt;/a&gt;。部分GET方法旨在通过允许部分取回的实体完成而无需传输客户端已经拥有的数据来减少不必要的网络使用。对GET请求的响应只有在满足&lt;a href=&quot;#section-13&quot;&gt;第13节中&lt;/a&gt;描述的HTTP缓存要求时才可以缓存。有关用于表单的安全性注意事项，请参见&lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fe6f3c8c21eb606abd80993ecfb90185941dd2b" translate="yes" xml:space="preserve">
          <source>The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource 

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a &quot;range request&quot;,
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">GET方法请求传输目标资源的当前选定表示形式。 GET是信息检索的主要机制，也是几乎所有性能优化的重点。因此，当人们谈论通过HTTP检索某些可识别的信息时，他们通常指的是发出GET请求。极有可能将资源标识符视为远程文件系统路径名，并将表示形式视为此类文件内容的副本。实际上，这就是实施了多少资源（请参阅 &lt;a href=&quot;#section-9.1&quot;&gt;第9.1节）&lt;/a&gt;出于相关的安全考虑）。但是，实际上没有这种限制。资源的HTTP接口很可能实现为内容对象树，各种数据库记录上的编程视图或其他信息系统的网关。即使将URI映射机制绑定到文件系统，也可以将原始服务器配置为以请求作为输入执行文件，并以表示形式发送输出，而不是直接传输文件。无论如何，仅原始服务器需要知道其每个资源标识符如何对应于一个实现，以及每个实现如何设法选择并发送对GET的响应的目标资源的当前表示。客户可以将GET的语义更改为&amp;ldquo;范围请求&amp;rdquo;，通过在请求中发送范围标头字段来请求仅传输所选表示形式的某些部分（[&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]）。GET请求消息中的有效负载没有定义的语义。在GET请求上发送有效内容正文可能会导致某些现有实现拒绝该请求。对GET请求的响应是可缓存的；缓存可以使用它来满足后续的GET和HEAD请求，除非Cache-Control头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节）&lt;/a&gt;另有说明。</target>
        </trans-unit>
        <trans-unit id="5094fc44298eab7b1db803d184d5d22fe3243b4b" translate="yes" xml:space="preserve">
          <source>The General Data Privacy Regulation (GDPR) in the European Union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df79dab20c7e00cfdc0198d8b7108bafe0b904f" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response. The metainformation contained
   in the HTTP headers in response to a HEAD request SHOULD be identical
   to the information sent in response to a GET request. This method can
   be used for obtaining metainformation about the entity implied by the
   request without transferring the entity-body itself. This method is
   often used for testing hypertext links for validity, accessibility,
   and recent modification.

   The response to a HEAD request MAY be cacheable in the sense that the
   information contained in the response MAY be used to update a
   previously cached entity from that resource. If the new field values
   indicate that the cached entity differs from the current entity (as
   would be indicated by a change in Content-Length, Content-MD5, ETag
   or Last-Modified), then the cache MUST treat the cache entry as
   stale.</source>
          <target state="translated">HEAD方法与GET方法相同,除了服务器必须不在响应中返回一个消息体。响应HEAD请求的HTTP头中包含的元信息应该与响应GET请求时发送的信息相同。这种方法可以用来获取请求中所隐含的实体的元信息,而不需要传输实体体本身。这种方法通常用于测试超文本链接的有效性、可访问性和最近的修改。对HEAD请求的响应可以是可缓存的,因为响应中包含的信息可以用来更新该资源中先前缓存的实体。如果新的字段值表明缓存的实体与当前实体不同(如Content-Length、Content-MD5、ETag或Last-Modified的变化),那么缓存必须将缓存条目视为陈旧。</target>
        </trans-unit>
        <trans-unit id="af87f0a9948cd0c865e17fe40c999f5f6559a626" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;Section&amp;nbsp;4.3.5 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">HEAD方法与GET相同，不同之处在于服务器在响应中不得发送消息正文（即，响应在标头部分的结尾处终止）。服务器应发送与HEAD请求相同的头字段，以响应HEAD请求，但有效载荷头字段除外（&lt;a href=&quot;#section-3.3&quot;&gt;第3.3节）&lt;/a&gt;）可以省略。此方法可用于获取有关所选表示形式的元数据而无需传输表示形式数据，并且通常用于测试超文本链接的有效性，可访问性和最新修改。 HEAD请求消息中的有效载荷没有定义的语义。在HEAD请求上发送有效内容主体可能会导致某些现有实现拒绝该请求。对HEAD请求的响应是可缓存的；高速缓存可以使用它来满足后续的HEAD请求，除非Cache-Control头字段另有指示（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节&lt;/a&gt;）。 HEAD响应也可能会影响先前缓存的GET响应；参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;[RFC7234]的4.3.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fa0cc40bb9e4667e351329947478703648e5a09" translate="yes" xml:space="preserve">
          <source>The HTML of &lt;code&gt;signup.html&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;signup.html&lt;/code&gt; 的HTML 如下所示：</target>
        </trans-unit>
        <trans-unit id="9e4ed100d87a6355dfbd6e285bdb4feb98fdc0d9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets over HTTP when the page uses HTTPS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ee255be05b605cffc50bf531b8bbc6cd52f1c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">当使用HTTPS加载页面时，HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 指令可防止使用HTTP加载任何资产。</target>
        </trans-unit>
        <trans-unit id="9387c952373df9470c27016caf452ee055a0a173" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4307301fcd6bb5ccdab9143ff3528885084251b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 伪指令限制可以使用脚本接口加载的URL。受限制的API是：</target>
        </trans-unit>
        <trans-unit id="182931c21e0e507ac442ba7fad6c85f7022aa1b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令用作其他CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch指令&lt;/a&gt;的后备。对于以下每个缺少的指令，用户代理将查找 &lt;code&gt;default-src&lt;/code&gt; 指令并将其使用此值：</target>
        </trans-unit>
        <trans-unit id="df6b0aa2488b0f60a06ea64f5f84252e16a5ba40" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;加载的字体指定有效来源。</target>
        </trans-unit>
        <trans-unit id="b26fdbf4c8f95b8df3d8b6830742e1c693873add" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; - &lt;code&gt;-action&lt;/code&gt; 指令限制了URL，这些URL可以用作给定上下文中表单提交的目标。</target>
        </trans-unit>
        <trans-unit id="e3702b120d46e550d906d2d9a8d47f7b89a394a2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; 指令指定了有效的父代，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;嵌入页面。</target>
        </trans-unit>
        <trans-unit id="e7a99a281dc2a7e2980a9a7cde577543fea1d6f5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; 指令使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素为嵌套浏览上下文加载指定有效的源。</target>
        </trans-unit>
        <trans-unit id="f35361ac952ed5107a00ab5b6446fbed51185da5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e405945a5f6f3e5caa215c10fb1ba16c926f41" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定用于加载媒体的有效源。</target>
        </trans-unit>
        <trans-unit id="8d107e0a38faf65b9362f0868294c5f1f868d7aa" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; 指令通过限制可以加载的资源类型来限制可以嵌入到文档中的插件集。</target>
        </trans-unit>
        <trans-unit id="6ad6e328ff3b4fb09016b0d4cd3b23b2ef304500" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">在HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; 指令用于指定信息&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; 的&lt;/a&gt;头部（单 &lt;code&gt;r&lt;/code&gt; 中的链接，因为这是在原有规范中的一个错字）从页面了。该API已弃用，并已从浏览器中删除。</target>
        </trans-unit>
        <trans-unit id="8f8670f822879a6c1f70bb6696d4385c9e028089" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; 指令可为请求的资源启用沙箱，类似于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性。它将限制应用于页面的操作，包括阻止弹出窗口，阻止插件和脚本的执行以及执行同源策略。</target>
        </trans-unit>
        <trans-unit id="63d32345b8cf84239a5bf4892731d98708512218" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; 指令指定了JavaScript的有效来源。这不仅包括直接加载到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的URL ，还包括内联脚本事件处理程序（ &lt;code&gt;onclick&lt;/code&gt; ）和可以触发脚本执行的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT样式表之&lt;/a&gt;类的东西。</target>
        </trans-unit>
        <trans-unit id="e2a780dcd99b14cfc49a43bc74102f1ed0b2e3e6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定样式表的有效源。</target>
        </trans-unit>
        <trans-unit id="591de896ab33256052ca0797fb955116eff15e90" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理将站点的所有不安全URL（通过HTTP服务的URL）视为已被安全URL（通过HTTPS服务的URL）代替。该指令适用于具有大量不安全的旧版URL且需要重写的网站。</target>
        </trans-unit>
        <trans-unit id="32ff6a8bc2363d0ff4f3086755b7248183c5b34b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;脚本指定有效的源。</target>
        </trans-unit>
        <trans-unit id="3acbb37620b5c60ffd911d6cef85fd1eada27d24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5b4e1965627b7bb6308888f53e91d8ff996658" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;default-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent looks for the &lt;code&gt;default-src&lt;/code&gt; directive and uses this value for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa9970523d0f2da18a413ddfa67a54c01337b6d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;style-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275423427a5662144b985c69ef01612f4d51c0a4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8c324b7db31bcba8cef085e4b98f52d8cd17a3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定可以将哪些&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;清单&lt;/a&gt;应用于资源。</target>
        </trans-unit>
        <trans-unit id="8d10806c81e23539dc0cc263131762383ee75c31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b239689551cd0c9430aba9321c015f59f5b7ee6a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定图像和图标的有效来源。</target>
        </trans-unit>
        <trans-unit id="f43d22faa65da48c48f2987c23a1ac5f2d7480b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db12171daec1cecdac720828f51ca0a57d2ce24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定有效的源。</target>
        </trans-unit>
        <trans-unit id="a75713e06f850d30f3c1d3897dfbb65c817d0a9c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 指令指示客户端要求对页面上的脚本或样式使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a32f782eaaf1368e46240e1ae4c440922d0f70d0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; 指令限制可以在文档的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中使用的URL 。如果不存在此值，则允许任何URI。如果不存在此伪指令，则用户代理将使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的值。</target>
        </trans-unit>
        <trans-unit id="358c131c1d5a8c89c254e16cfb1b9e90fee71186" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c9ca551ef322fcef92f79b3a236ae1ba63f558" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头的 &lt;code&gt;autoplay&lt;/code&gt; 指令控制是否允许当前文档自动播放通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;接口请求的媒体。启用此策略并且没有用户手势时，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;DOMException&lt;/code&gt; 。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上的 &lt;code&gt;autoplay&lt;/code&gt; 属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="7087babf47c5844e7ac3510edec835b831437673" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt;&lt;code&gt;NotAllowedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ab43068a1ce03c2c700695396807b764653f4c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;camera&lt;/code&gt; 指令控制是否允许当前文档使用视频输入设备。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0509b709eb9c12fa1d36b479d880843a32939bb2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;document-domain&lt;/code&gt; 指令控制是否允许当前文档设置&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;。启用此策略后，尝试设置&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;将会失败并导致引发 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db2a12cedfc96871f58d6b87b88cf7641d46244e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c66dd6d4d4a75699b185decdfad8e45e19e0002d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;encrypted-media&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）。启用此策略后，由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;DOMException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e8d5d79df5028bcf829983040e4f5d620f67f63" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;fullscreen&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt;。启用此策略后，返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; 会&lt;/a&gt;拒绝并带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb70b85868a9918e7c850de1c73663ec03ac5340" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;geolocation&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt;接口。启用此策略后，对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; 的&lt;/a&gt;调用将使这些函数的回调以 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt;代码进行调用。</target>
        </trans-unit>
        <trans-unit id="d88583ce1eab6212205a0ce4ec5269a6f045f6b3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;microphone&lt;/code&gt; 指令控制是否允许当前文档使用音频输入设备。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f61a9280d76cca41de0c10b1bb571562297d206c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;midi&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将以 &lt;code&gt;DOMException&lt;/code&gt; 拒绝。</target>
        </trans-unit>
        <trans-unit id="ad49b71ef86ec5410e8de76cba85903aa7fec02d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;payment&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;构造函数将抛出 &lt;code&gt;SecurityError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="596ebd10a4b879fc3f494e6c070eefbc8b1b78da" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf81d231c67dd1b00b85de64c8fcc4e2241cad31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;vr&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将以 &lt;code&gt;DOMException&lt;/code&gt; 拒绝。</target>
        </trans-unit>
        <trans-unit id="a4136ce714258747e9ae7bb826711d2f7370051e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header field's &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is disabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bd59abf141ac2acd0d6eb93603dfbb20ca13bb" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">当使用HTTPS加载页面时，HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 指令可防止使用HTTP加载任何资产。</target>
        </trans-unit>
        <trans-unit id="2c130ba07e36557d606dab5e0daeea1174e0f829" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 伪指令限制可以使用脚本接口加载的URL。受限制的API是：</target>
        </trans-unit>
        <trans-unit id="f9e44e9310d4af0da6d15e0f9e8b89d123612c88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令用作其他CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch指令&lt;/a&gt;的后备。对于以下每个缺少的指令，用户代理将查找 &lt;code&gt;default-src&lt;/code&gt; 指令并将其使用此值：</target>
        </trans-unit>
        <trans-unit id="872a0ce0f866c4f403e5c4fdabdba2ac75e64283" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;加载的字体指定有效来源。</target>
        </trans-unit>
        <trans-unit id="89db1b08f92d8384d90536ecc2f476ece38912e3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; - &lt;code&gt;-action&lt;/code&gt; 指令限制了URL，这些URL可以用作给定上下文中表单提交的目标。</target>
        </trans-unit>
        <trans-unit id="53e746d6be4fd9b5eb3832de56d4365f491df6d6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; 指令指定了有效的父代，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;嵌入页面。</target>
        </trans-unit>
        <trans-unit id="60434b7f567fe8e897910e8b6a67bd2318a07eda" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; 指令使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素为嵌套浏览上下文加载指定有效的源。</target>
        </trans-unit>
        <trans-unit id="af2c302ddc10d3d222e0a67e09b8d5d05e052366" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定用于加载媒体的有效源。</target>
        </trans-unit>
        <trans-unit id="3d40cffb60b43134b32f0810a5ed2a290fe665f6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; 指令通过限制可以加载的资源类型来限制可以嵌入到文档中的插件集。</target>
        </trans-unit>
        <trans-unit id="bdd0798eaf4df1ffabbf8a0c8d7aa4c0dbd9e69b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; 指令，用于指定&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;标头中的信息（在原始规范中使用单个 &lt;code&gt;r&lt;/code&gt; 表示错字），以指定远离页面的链接。该API已弃用，并已从浏览器中删除。</target>
        </trans-unit>
        <trans-unit id="befd663ba9deb24fd4ec2918a5d6109d2636a2d4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; 指令可为请求的资源启用沙箱，类似于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性。它对页面的操作施加了限制，包括防止弹出窗口，阻止插件和脚本的执行以及执行同源策略。</target>
        </trans-unit>
        <trans-unit id="5b8d334a3bce170c8993d25e4d184932264ac72f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; 指令指定了JavaScript的有效来源。这不仅包括直接加载到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的URL ，还包括内联脚本事件处理程序（ &lt;code&gt;onclick&lt;/code&gt; ）和可以触发脚本执行的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT样式表之&lt;/a&gt;类的东西。</target>
        </trans-unit>
        <trans-unit id="8cef37884cea47d641cdd47c4c37fa6b8ac6254c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为样式表的来源指定有效来源。</target>
        </trans-unit>
        <trans-unit id="27cf15a50bbcd9352999ad2ec374352073190e0d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7e1c437a2a4b57d25b681153a76fdfe0cd58a0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理将站点的所有不安全URL（通过HTTP服务的URL）视为已被安全URL（通过HTTPS服务的URL）代替。该指令适用于具有大量不安全的旧版URL且需要重写的网站。</target>
        </trans-unit>
        <trans-unit id="c6470e7d04b8abe1f65b75c4d51906723a206d5d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;脚本指定有效的源。</target>
        </trans-unit>
        <trans-unit id="65fa53659e196a5f364ee4db69fef14fde746c4b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定可以将哪些&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;清单&lt;/a&gt;应用于资源。</target>
        </trans-unit>
        <trans-unit id="e5534bb581250f2eb94ed31caf65205d9ee368e1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定图像和图标的有效来源。</target>
        </trans-unit>
        <trans-unit id="dc76ac8291a24a25cb87200add3759c6483c6ea1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定有效的源。</target>
        </trans-unit>
        <trans-unit id="1d78f21670ba26d46502f42156fd74dce6127ca2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 指令指示客户端要求对页面上的脚本或样式使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c04dd8d66fd1dfd03e0cb89fd2b86f5466e7e9c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; 指令限制可以在文档的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中使用的URL 。如果不存在此值，则允许任何URI。如果不存在此伪指令，则用户代理将使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的值。</target>
        </trans-unit>
        <trans-unit id="434bd95977151980be645e25d889ee96d08c9496" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f42da0f7bda5731910d6ec6cb2dc9b13ff87de9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b38e64dd4aafe5fbe1b9af5c13faa83b6a43ced" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52529e863205e105281cb3b1e67c42491db93580" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c026bd77cc15606268a474526426c47ed406dd3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;fullscreen&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt;。启用此策略后，返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; 会&lt;/a&gt;拒绝并带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="279945c05ed4e9f8612677a6cb5333c055c3347c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;geolocation&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt;接口。启用此策略后，对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; 的&lt;/a&gt;调用将使这些函数的回调以 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt;代码进行调用。</target>
        </trans-unit>
        <trans-unit id="b86b8ff6f832650a49ab241aa391e1a80cf0e208" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;microphone&lt;/code&gt; 指令控制是否允许当前文档使用音频输入设备。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ee0bf2b06d49cf8e3886496858e4c50b79dbf27" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e1c9da52aa492cca410e5baad4c4d7dda1aa4f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9aec9b3d7ed8d0d68045c2927ccdfecf55159b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a01790dc40b1842141c794cdff77d6c8665d41c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method only allows complete replacement of a document. Unlike &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; is not idempotent, meaning successive identical patch requests &lt;em&gt;may &lt;/em&gt;have different effects. However, it is possible to issue &lt;code&gt;PATCH&lt;/code&gt; requests in such a way as to be idempotent.</source>
          <target state="translated">HTTP &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;方法仅允许完全替换文档。与 &lt;code&gt;PUT&lt;/code&gt; 不同， &lt;code&gt;PATCH&lt;/code&gt; 不是幂等的，这意味着连续的相同补丁请求&lt;em&gt;可能会&lt;/em&gt;产生不同的影响。但是，可以以等幂的方式发出 &lt;code&gt;PATCH&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="7f334e7627368fd785cf9c286367893a77c43e45" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;100 Continue&lt;/code&gt; informational status response code indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">HTTP &lt;code&gt;100 Continue&lt;/code&gt; 信息状态响应代码表示到目前为止一切正常，客户端应继续请求，或者如果请求已完成，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="278c46bdc85af7c390f125d693bcbfb316c79076" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;200 OK&lt;/code&gt; success status response code indicates that the request has succeeded. A 200 response is cacheable by default.</source>
          <target state="translated">HTTP &lt;code&gt;200 OK&lt;/code&gt; 成功状态响应代码指示请求已成功。默认情况下，200响应是可缓存的。</target>
        </trans-unit>
        <trans-unit id="c0eb27679053d5143a43ddd8d3a3431a539fa9ad" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;201 Created&lt;/code&gt; success status response code indicates that the request has succeeded and has led to the creation of a resource. The new resource is effectively created before this response is sent back and the new resource is returned in the body of the message, its location being either the URL of the request, or the content of the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;201 Created&lt;/code&gt; 成功状态响应代码指示请求已成功并导致资源的创建。在发送此响应并将新资源返回到邮件正文之前，将有效地创建新资源，该新资源的位置可以是请求的URL或&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头的内容。</target>
        </trans-unit>
        <trans-unit id="f20649a3f0fe7c56e61071fa1174a4b08047b9bd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt; from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d3953aeb6b99914993168434167c7b602ed71d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 响应状态指示请求已成功，但是已封装的有效负载已由转换&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;代理&lt;/a&gt;从源服务器&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; 的&lt;/a&gt;响应（ &lt;code&gt;OK&lt;/code&gt; ）进行了修改。</target>
        </trans-unit>
        <trans-unit id="c8b0b238f5e41f13b1e7f817deb60c88d7d3bc20" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;204 No Content&lt;/code&gt; success status response code indicates that the request has succeeded, but that the client doesn't need to go away from its current page. A 204 response is cacheable by default. An &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header is included in such a response.</source>
          <target state="translated">HTTP &lt;code&gt;204 No Content&lt;/code&gt; 成功状态响应代码指示请求已成功，但是客户端不需要离开其当前页面。默认情况下，204响应是可缓存的。一个&lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; 的&lt;/a&gt;报头被包括在这样的响应。</target>
        </trans-unit>
        <trans-unit id="80288ab170aee829f4cf209605eb49eadc086eef" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; response status tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI.</source>
          <target state="translated">HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; 响应状态告诉客户端重置文档视图，例如清除表单内容，重置画布状态或刷新UI。</target>
        </trans-unit>
        <trans-unit id="0c81546d9f0eee981bd016b4cb4e7eaa4833eb13" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header of the request.</source>
          <target state="translated">HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; 成功状态响应代码表示请求已成功完成，并且主体包含请求的数据范围，如请求的&lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;标头中所述。</target>
        </trans-unit>
        <trans-unit id="3b3b5e099cd9381b1fd70b5113573795b1907f7d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; 客户端错误状态响应代码表示该请求尚未应用，因为它缺少针对目标资源的有效身份验证凭据。</target>
        </trans-unit>
        <trans-unit id="979b22f333764accadf3c7a12f9ce50117ebb170" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status response code indicates that the server understood the request but refuses to authorize it.</source>
          <target state="translated">HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; 客户端错误状态响应代码指示服务器理解了该请求但拒绝对其进行授权。</target>
        </trans-unit>
        <trans-unit id="17d3fa05f1dcd2e00101e33637b74e845046dbb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt; that is between the browser and the server that can access the requested resource.</source>
          <target state="translated">HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; 客户端错误状态响应代码表示该请求尚未应用，因为它缺少&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;代理服务器的&lt;/a&gt;有效身份验证凭据，该代理服务器位于浏览器和可以访问所请求资源的服务器之间。</target>
        </trans-unit>
        <trans-unit id="bbb5886db0baaa39aa591bfbfac7d405f377c2ab" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; client error response code indicates that the expectation given in the request's &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header could not be met.</source>
          <target state="translated">HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; 客户端错误响应代码指示无法满足请求的&lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt;标头中给出的期望。</target>
        </trans-unit>
        <trans-unit id="0fd8eba95386e5a941324f20f703ccd45af95a3a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference of Hyper Text Coffee Pot Control Protocol which was an April Fools' joke in 1998.</source>
          <target state="translated">HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; 客户端错误响应代码，指示服务器拒绝冲泡咖啡，因为它是茶壶。此错误是超文本咖啡壶控制协议的参考，该协议是1998年愚人节的笑话。</target>
        </trans-unit>
        <trans-unit id="654a84748c864e6e1a07b612586a854316f7aeb8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot. A combined coffee/tea pot that is temporarily out of coffee should instead return 503. This error is a reference to Hyper Text Coffee Pot Control Protocol defined in April Fools' jokes in 1998 and 2014.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11a396d84c2b4361354f28621db5450bb7872a5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73eb36719efddb2bf307089114ca5c1ff83bc1f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 响应代码指示服务器根据客户端的请求切换到该协议，客户端发送了包含&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;请求标头的消息。</target>
        </trans-unit>
        <trans-unit id="d7eb48272f72778b0b684676d2f608817e02eb9f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码表示该请求具有多个可能的响应。用户代理或用户应选择其中之一。由于没有选择任何一种响应的标准化方法，因此很少使用此响应代码。</target>
        </trans-unit>
        <trans-unit id="de334adf5ffab7d89b3c6e50513373cd0cee8cfc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, like a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request, or when the request is conditional and uses a &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; 客户端重定向响应代码指示不需要重新传输请求的资源。这是对缓存资源的隐式重定向。当请求方法是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;（例如&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;请求），或者请求是有条件的并且使用&lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;标头时，就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="709d37d1b0cf9c49b3de2408fbf6ef4e0002c27a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links that lead to a 404 page are often called broken or dead links and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341bb159a2216d99ce107781a967531062a1c137" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links which lead to a 404 page are often called broken or dead links, and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码表示服务器找不到请求的资源。指向404页的链接通常称为断开或无效链接，并且可能会受到&lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;rot的影响&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="963eb81b613d14e6431a53b19e1087de4815c917" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the server.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示请求与服务器的当前状态发生冲突。</target>
        </trans-unit>
        <trans-unit id="4a775e572f006026758ef524b8a9cc133b9ccc99" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the target resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e620c227a6a0b266557df35d3c5635f4241af7c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request entity is larger than limits defined by server; the server might close the connection or return a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示请求实体大于服务器定义的限制；服务器可能会关闭连接或返回&lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt;标头字段。</target>
        </trans-unit>
        <trans-unit id="84e2079297e778196c8c9ae50616e31cf6eb1ce4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; response status code indicates that the URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示客户端请求的URI比服务器愿意解释的更长。</target>
        </trans-unit>
        <trans-unit id="fd260910ed4759c1378089671fbb6c0fbbb60660" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request because the payload format is in an unsupported format.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示服务器拒绝接受请求，因为有效负载格式为不受支持的格式。</target>
        </trans-unit>
        <trans-unit id="fa970ac1d28b371bc4205e842d1c6d26ad5a73c4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示服务器拒绝使用当前协议执行请求，但是在客户端升级到其他协议后可能愿意这样做。</target>
        </trans-unit>
        <trans-unit id="75aa3c74acfab1e106209fd4dd08b06e3054f27c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server requires the request to be &lt;a href=&quot;../conditional_requests&quot;&gt;conditional&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示服务器要求请求是&lt;a href=&quot;../conditional_requests&quot;&gt;有条件的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="caa3bb3b92f0cfe33012b47986779e7f954a74b6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; response status code indicates the user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示用户在给定的时间内发送了太多请求（&amp;ldquo;速率限制&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="04093cec2709dfaadbfa7527dc5c2ce1cd0b0646" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器不愿意处理该请求，因为其标头字段太大。在减小请求头字段的大小之后，可以重新提交请求。</target>
        </trans-unit>
        <trans-unit id="aa944fee90f822e5d898a487cb81942f7a56be65" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server refuses to process the request because the request&amp;rsquo;s &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; are too long. The request &lt;em&gt;may&lt;/em&gt; be resubmitted after reducing the size of the request headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ddb3645327183c13becf845f54f56cdc4fdb5b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; 响应状态码指示客户端需要进行身份验证才能获得网络访问权限。</target>
        </trans-unit>
        <trans-unit id="61ba4c1907f9a2e1f56de138ea9bcbb425c864e8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header sends reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 响应标头将违反固定的 &lt;code&gt;report-uri&lt;/code&gt; 发送到标头中指定的report-uri，但与&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;不同，如果违反了固定，仍然允许浏览器连接到服务器。</target>
        </trans-unit>
        <trans-unit id="1d86ddf68a31dc8a760b8d60344a39004ec85b2f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header was used to send reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated. The header is silently ignored in modern browsers as support for HPKP has been removed. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and the &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1aca0b8602a1b4269702669b5705705488252e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header associates a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates. If one or several keys are pinned and none of them are used by the server, the browser will not accept the response as legitimate, and will not display it.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 响应标头将特定的加密公共&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;密钥&lt;/a&gt;与某个Web服务器相关联，以降低使用伪造证书进行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt;攻击的风险。如果固定了一个或多个键，并且服务器均未使用任何键，则浏览器将不会接受该响应为合法响应，也不会显示该响应。</target>
        </trans-unit>
        <trans-unit id="5426b643c79f95f69aab37cfedbccbbaa4236ca6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header used to associate a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates, however, it has been removed from modern browsers and is no longer supported. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc17523ceced42a997fa4ec405b48542dc6da961" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; 请求标头包含用于向服务器认证用户代理的凭据，通常在服务器以&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 状态和&lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;标头响应之后。</target>
        </trans-unit>
        <trans-unit id="91c7c3a40bace5e7298eaff1c25e12df9e924d3d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually, but not necessarily, after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eefae1a810c845c3fa68fd46660a1ab4ceaacda0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; response header allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 响应标头允许Web开发人员通过监视（但不强制执行）效果来试验策略。这些违规报告包含通过HTTP &lt;code&gt;POST&lt;/code&gt; 请求发送到指定URI 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1cedc9503c55c7df39812e0c200c391cb9852c4a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; 响应标头允许网站管理员控制允许用户代理为给定页面加载的资源。除少数例外，策略主要涉及指定服务器来源和脚本端点。这有助于防止跨站点脚本攻击（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1606c56903114379a30109e67a8a9703c7538a88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in content within any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; elements in the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f93db0c2b1cae96ab8007915ebdc3aee6ae9b29" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; 标头提供了一种机制，该机制允许和拒绝在其自己的框架以及嵌入的iframe中使用浏览器功能。</target>
        </trans-unit>
        <trans-unit id="1ee6fbdaf32a73c5d2da4ea87e0ad9941527d763" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource behind a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt;. It authenticates the request to the proxy server, allowing it to transmit the request further.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; 响应标头定义了身份验证方法，应使用该身份验证方法来访问&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;代理服务器&lt;/a&gt;后面的资源。它将请求认证到代理服务器，从而允许它进一步发送请求。</target>
        </trans-unit>
        <trans-unit id="d342efd1df2902182c9b47d04c0940ea25837a75" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt; status and the &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; 请求标头包含用于对代理服务器认证用户代理的凭据，通常是在服务器以&lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 状态和&lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;标头响应之后。</target>
        </trans-unit>
        <trans-unit id="06706a733035595c3ca09ed579f53668680fa83e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; request header sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP&lt;/a&gt; directive.</source>
          <target state="translated">HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; 请求标头将信号发送到服务器，以表示客户端对加密和认证响应的偏好，并且可以成功处理&lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt; CSP&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="5f27fddd57d61b2e03f1c5514e09709028f9f0a9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; 响应标头定义了应用于获得对资源访问权限的身份验证方法。</target>
        </trans-unit>
        <trans-unit id="aeb81534f8cc6e53ddfa06e7cb5d6c8eaf9dba55" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; that disables the use of inline JavaScript (&lt;code&gt;'unsafe-inline'&lt;/code&gt;), they can still provide protections for users of older web browsers that don't yet support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; 响应标头是Internet Explorer，Chrome和Safari的一项功能，当页面检测到反射的跨站点脚本（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）攻击时，该页面将阻止加载页面。尽管当站点实施强大的&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;禁止使用内联JavaScript（ &lt;code&gt;'unsafe-inline'&lt;/code&gt; ）时，在现代浏览器中这些保护在很大程度上是不必要的，但它们仍可以为尚未使用旧版Web浏览器的用户提供保护支持&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a09546225cff6400570e0443b16e0c6e86472fe" translate="yes" xml:space="preserve">
          <source>The HTTP Strict Transport Security header informs the browser that it should never load a site using HTTP and should automatically convert all attempts to access the site using HTTP to HTTPS requests instead.</source>
          <target state="translated">HTTP严格传输安全头告知浏览器,它不应该使用HTTP加载网站,而应该自动将所有使用HTTP访问网站的尝试转换为HTTPS请求。</target>
        </trans-unit>
        <trans-unit id="be8b00e9c8d5d272b2e1f90c102d59e067b32a0b" translate="yes" xml:space="preserve">
          <source>The HTTP URL namespace is a hierarchical namespace where the
   hierarchy is delimited with the &quot;/&quot; character.

   An HTTP URL namespace is said to be consistent if it meets the
   following conditions: for every URL in the HTTP hierarchy there
   exists a collection that contains that URL as an internal member URL.
   The root, or top-level collection of the namespace under
   consideration, is exempt from the previous rule.  The top-level
   collection of the namespace under consideration is not necessarily
   the collection identified by the absolute path '/' -- it may be
   identified by one or more path segments (e.g., /servlets/webdav/...)

   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL
   namespace be consistent -- a WebDAV-compatible resource may not have
   a parent collection.  However, certain WebDAV methods are prohibited
   from producing results that cause namespace inconsistencies.

   As is implicit in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], any resource, including
   collection resources, MAY be identified by more than one URI.  For
   example, a resource could be identified by multiple HTTP URLs.</source>
          <target state="translated">HTTP URL名称空间是层次结构名称空间，其中层次结构用&amp;ldquo; /&amp;rdquo;字符分隔。如果HTTP URL名称空间满足以下条件，则称该名称空间是一致的：对于HTTP层次结构中的每个URL，都存在一个包含该URL作为内部成员URL的集合。所考虑的名称空间的根或顶级集合免于先前的规则。所考虑的名称空间的顶级集合不一定是由绝对路径&amp;ldquo; /&amp;rdquo;标识的集合，它可以由一个或多个路径段（例如，/ servlets / webdav / ...）标识，而HTTP / 1.1或WebDAV都不要求整个HTTP URL名称空间保持一致-兼容WebDAV的资源可能没有父集合。然而，某些WebDAV方法被禁止产生导致名称空间不一致的结果。如[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;和[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]，包括集合资源在内的任何资源都可以由多个URI标识。例如，资源可以由多个HTTP URL标识。</target>
        </trans-unit>
        <trans-unit id="4fce77c17c83cf3b9166ab68262d46c09171eb1b" translate="yes" xml:space="preserve">
          <source>The HTTP authentication framework does not define a single mechanism
   for maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior
   to transmission.  While this provides flexibility for the development
   of future authentication schemes, it is inadequate for the protection
   of existing schemes that provide no confidentiality on their own, or
   that do not sufficiently protect against replay attacks.
   Furthermore, if the server expects credentials that are specific to
   each individual user, the exchange of those credentials will have the
   effect of identifying that user even if the content within
   credentials remains confidential.

   HTTP depends on the security properties of the underlying transport-
   or session-level connection to provide confidential transmission of
   header fields.  In other words, if a server limits access to
   authenticated users using this framework, the server needs to ensure
   that the connection is properly secured in accordance with the nature
   of the authentication scheme used.  For example, services that depend
   on individual user authentication often require a connection to be
   secured with TLS (&quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) prior to
   exchanging any credentials.</source>
          <target state="translated">HTTP身份验证框架没有定义用于维护凭据机密性的单一机制；相反，每个身份验证方案都定义了凭据在传输之前如何进行编码。尽管这为将来的身份验证方案的开发提供了灵活性，但不足以保护现有的方案，这些方案本身不提供任何机密性，或者不足以防止重放攻击。此外，如果服务器期望特定于每个单独用户的凭据，则即使凭据内的内容保持机密，这些凭据的交换也具有标识该用户的效果。HTTP依赖于基础传输或会话级连接的安全属性来提供头字段的机密传输。换句话说，如果服务器使用此框架将访问权限限制在经过身份验证的用户，则服务器需要确保根据所使用的身份验证方案的性质来正确保护连接。例如，依赖于个人用户身份验证的服务通常要求使用TLS（&amp;ldquo;传输层安全性&amp;rdquo;，&amp;ldquo; [依赖个人用户身份验证的服务通常需要使用TLS（&amp;ldquo;传输层安全性&amp;rdquo;，&amp;ldquo; [依赖个人用户身份验证的服务通常需要使用TLS（&amp;ldquo;传输层安全性&amp;rdquo;，&amp;ldquo; [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]）之前交换任何凭据。</target>
        </trans-unit>
        <trans-unit id="d8d09b5015d287016b84da909b78b11d8d4463c3" translate="yes" xml:space="preserve">
          <source>The HTTP conditional request header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by 

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC7232]&lt;/a&gt;.

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7232]&lt;/a&gt; |
   | If-None-Match       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7232]&lt;/a&gt; |
   | If-Modified-Since   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt; |
   | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of [RFC7232]&lt;/a&gt; |
   | If-Range            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">HTTP条件请求标头字段[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]允许客户端在目标资源的状态上放置前提条件，以便如果前提条件评估为false，则将不应用与方法语义相对应的操作。本规范定义的每个前提条件包括从目标资源的先前表示获得的一组验证器与所选表示形式的验证器当前状态之间的比较（&lt;a href=&quot;#section-7.2&quot;&gt;第7.2节&lt;/a&gt;）。因此，这些前提条件评估自客户端已知给定状态以来目标资源的状态是否已更改。这种评估的效果取决于方法的语义和条件的选择，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;[RFC7232]的第5节&lt;/a&gt;。 + --------------------- + -------------------------- + |标头字段名称|定义于... | + --------------------- + -------------------------- + |如果匹配| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;[RFC7232]的第3.1节&lt;/a&gt; | |如果不匹配| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232]的3.2节&lt;/a&gt; | | If-Modified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232]的3.3节&lt;/a&gt; | | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;[RFC7232]的3.4节&lt;/a&gt; | |如果范围| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]的3.2节&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="db5702e7098e5089b43ae75747b9b4a1f88a17e6" translate="yes" xml:space="preserve">
          <source>The HTTP method being used by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is not included in the list of methods specified by the response's &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header. This header specifies a comma-delineated list of the HTTP methods which may be used when using CORS to access the URL specified in the request; if the request is using any other method, this error occurs.</source>
          <target state="translated">由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求使用的HTTP方法未包含在响应的&lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;标头指定的方法列表中。此标头指定HTTP方法的逗号分隔列表，当使用CORS访问请求中指定的URL时可以使用该HTTP方法。如果请求使用任何其他方法，则会发生此错误。</target>
        </trans-unit>
        <trans-unit id="9a5f8b591cdf4b19c28a4fbbf2ef71bf29cedf58" translate="yes" xml:space="preserve">
          <source>The HTTP protocol is a request/response protocol. A client sends a
   request to the server in the form of a request method, URI, and
   protocol version, followed by a MIME-like message containing request
   modifiers, client information, and possible body content over a
   connection with a server. The server responds with a status line,
   including the message's protocol version and a success or error code,
   followed by a MIME-like message containing server information, entity
   metainformation, and possible entity-body content. The relationship
   between HTTP and MIME is described in appendix 19.4.

   Most HTTP communication is initiated by a user agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this may be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          request chain ------------------------&amp;gt;
       UA -------------------v------------------- O
          &amp;lt;----------------------- response chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/response chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, receiving requests for a URI in its absolute form,
   rewriting all or part of the message, and forwarding the reformatted
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some other server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relay point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass through an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messages.

          request chain --------------------------------------&amp;gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &amp;lt;------------------------------------- response chain

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   This distinction is important because some HTTP communication options 

   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultaneous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication which is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the request/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
   request. The following illustrates the resulting chain if B has a
   cached copy of an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ----------&amp;gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &amp;lt;--------- response chain

   Not all responses are usefully cacheable, and some requests may
   contain modifiers which place special requirements on cache behavior.
   HTTP requirements for cache behavior and cacheable responses are
   defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   In fact, there are a wide variety of architectures and configurations
   of caches and proxies currently being experimented with or deployed
   across the World Wide Web. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via CD-ROM, and so on. HTTP systems are used
   in corporate intranets over high-bandwidth links, and for access via
   PDAs with low-power radio links and intermittent connectivity. The
   goal of HTTP/1.1 is to support the wide diversity of configurations
   already deployed while introducing protocol constructs that meet the
   needs of those who build web applications that require high
   reliability and, failing that, at least reliable indications of
   failure.

   HTTP communication usually takes place over TCP/IP connections. The
   default port is TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;], but other ports can be used. This does
   not preclude HTTP from being implemented on top of any other protocol
   on the Internet, or on other networks. HTTP only presumes a reliable
   transport; any protocol that provides such guarantees can be used;
   the mapping of the HTTP/1.1 request and response structures onto the
   transport data units of the protocol in question is outside the scope
   of this specification. 

   In HTTP/1.0, most implementations used a new connection for each
   request/response exchange. In HTTP/1.1, a connection may be used for
   one or more request/response exchanges, although connections may be
   closed for a variety of reasons (see &lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;).</source>
          <target state="translated">HTTP协议是请求/响应协议。客户端以请求方法，URI和协议版本的形式向服务器发送请求，然后通过与服务器的连接发送类似MIME的消息，其中包含请求修饰符，客户端信息以及可能的主体内容。服务器以状态行作为响应，包括消息的协议版本和成功或错误代码，后跟类似MIME的消息，其中包含服务器信息，实体元信息以及可能的实体主体内容。 HTTP和MIME之间的关系在附录19.4中描述。大多数HTTP通信都是由用户代理发起的，由要应用于某个原始服务器上的资源的请求组成。在最简单的情况下，这可以通过用户代理（UA）与原始服务器（O）之间的单个连接（v）来完成。请求链------------------------&amp;gt; UA ------------------- v-- ----------------- O &amp;lt;-----------------------响应链当请求/响应链中存在一个或多个中介。有三种常见的中介形式：代理，网关和隧道。代理是转发代理，它以绝对形式接收对URI的请求，重写消息的全部或部分，然后将重新格式化的请求转发给URI标识的服务器。网关是接收代理，充当其他一些服务器之上的一层，并在必要时将请求转换为基础服务器的协议。隧道充当两个连接之间的中继点，而不会更改消息。当通信需要通过中间设备（例如防火墙）时，即使中间设备无法理解消息的内容，也可以使用隧道。请求链--------------------------------------&amp;gt; UA ----- v-- --- A ----- v ----- B ----- v ----- C ----- v ----- O &amp;lt;--------- ----------------------------响应链上图显示了用户代理和源之间的三个中介（A，B和C）服务器。遍及整个链的请求或响应消息将通过四个单独的连接。这种区别很重要，因为某些HTTP通信选项可能仅适用于与最近的非隧道邻居的连接，仅到链的端点，或链的所有连接。尽管该图是线性的，但是每个参与者都可以参与多个同时的通信。例如，B在处理A的请求的同时，可能正在从A以外的许多客户端接收请求，和/或将请求转发到C以外的服务器。不充当隧道的通信的任何一方都可以使用内部缓存来处理请求。缓存的效果是，如果链中的参与者之一具有适用于该请求的缓存响应，则请求/响应链会缩短。下图说明了如果B拥有来自O（通过C）对O的较早响应的缓存副本的结果链，而该响应尚未由UA或A缓存。请求链----------&amp;gt; UA ----- v ----- A ----- v ----- B------C----- -O &amp;lt;---------响应链并非所有响应都可以有效地缓存，并且某些请求可能包含对缓存行为有特殊要求的修饰符。缓存行为和可缓存响应的HTTP要求在&lt;a href=&quot;#section-13&quot;&gt;第13条&lt;/a&gt;。实际上，目前有各种各样的缓存和代理的体系结构和配置正在试验或部署在万维网上。这些系统包括用于节省跨洋带宽的代理缓存的国家层次结构，广播或多播缓存条目的系统，通过CD-ROM分发缓存数据的子集的组织等等。 HTTP系统用于企业内联网中的高带宽链接，并通过具有低功率无线电链接和间歇性连接的PDA进行访问。 HTTP / 1.1的目标是支持已经部署的多种配置，同时引入协议构造，以满足那些构建Web应用程序的需求，这些应用程序需要高可靠性，如果失败，至少要提供可靠的故障指示。HTTP通信通常通过TCP / IP连接进行。默认端口为TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]，但可以使用其他端口。这并不排除HTTP可以在Internet或其他网络上的任何其他协议之上实现。 HTTP仅假定可靠的传输。可以使用提供此类保证的任何协议； HTTP / 1.1请求和响应结构到所讨论协议的传输数据单元上的映射超出了本规范的范围。在HTTP / 1.0中，大多数实现都为每个请求/响应交换使用新的连接。在HTTP / 1.1中，尽管出于各种原因连接可能会关闭，但连接可用于一个或多个请求/响应交换（请参阅&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="711fba1dbcca7b38687dec5dcf6d2cbe1d22690a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol specifies a request method called &lt;a href=&quot;methods/connect&quot;&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;/a&gt;. It starts two-way communications with the requested resource and can be used to open a tunnel. This is how a client behind an HTTP proxy can access websites using SSL (i.e. HTTPS, port 443). Note, however, that not all proxy servers support the &lt;code&gt;CONNECT&lt;/code&gt; method or limit it to port 443 only.</source>
          <target state="translated">HTTP协议指定了一种称为&lt;a href=&quot;methods/connect&quot;&gt; &lt;code&gt;CONNECT&lt;/code&gt; &lt;/a&gt;的请求方法。它开始与请求的资源进行双向通信，并可用于打开隧道。这就是HTTP代理后面的客户端可以使用SSL（即HTTPS，端口443）访问网站的方式。但是请注意，并非所有代理服务器都支持 &lt;code&gt;CONNECT&lt;/code&gt; 方法或将其限制为仅端口443。</target>
        </trans-unit>
        <trans-unit id="a45670933a882d376a78839281d063695249e118" translate="yes" xml:space="preserve">
          <source>The HTTP protocol used in those early phases was very simple, later dubbed HTTP/0.9, and sometimes as the one-line protocol.</source>
          <target state="translated">早期阶段使用的HTTP协议非常简单,后来被称为HTTP/0.9,有时也被称为单行协议。</target>
        </trans-unit>
        <trans-unit id="8b8c615279d732a85c03cf31a496dadc0ee7a1e0" translate="yes" xml:space="preserve">
          <source>The HTTP request headers</source>
          <target state="translated">HTTP请求头</target>
        </trans-unit>
        <trans-unit id="dc91001bcd5977c42287ce1ec14f986765b8a528" translate="yes" xml:space="preserve">
          <source>The HTTP response headers</source>
          <target state="translated">HTTP响应头</target>
        </trans-unit>
        <trans-unit id="eb8587eac722cc07a0cd8556b058eb4e29c05d63" translate="yes" xml:space="preserve">
          <source>The HTTP status code of the resource on which the global object was instantiated.</source>
          <target state="translated">实例化全局对象的资源的HTTP状态码。</target>
        </trans-unit>
        <trans-unit id="7642977e6ce54243574090f3f5103dcd8214c71f" translate="yes" xml:space="preserve">
          <source>The HTTP version used in the request is not supported by the server.</source>
          <target state="translated">请求中使用的HTTP版本不被服务器支持。</target>
        </trans-unit>
        <trans-unit id="0cf1515c8e62f4e6628b5f0c81397855080991ba" translate="yes" xml:space="preserve">
          <source>The HTTP/1.1 standard defines list of the standard headers that start server-driven negotiation (&lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;). Though strictly speaking &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; is not in this list, it is sometimes also used to send a specific representation of the requested resource, though this is not considered as a good practice. The server uses the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header to indicate which headers it actually used for content negotiation (or more precisely the associated response headers), so that &lt;a href=&quot;caching&quot;&gt;caches&lt;/a&gt; can work optimally.</source>
          <target state="translated">HTTP / 1.1标准定义了启动服务器驱动的协商的标准标头的列表（&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;）。尽管严格说来，&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;不在此列表中，但有时也用于发送所请求资源的特定表示形式，尽管这不是一种好的做法。服务器使用&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;标头来指示其实际用于内容协商的标头（或更确切地说是相关联的响应标头），以便&lt;a href=&quot;caching&quot;&gt;缓存&lt;/a&gt;可以最佳地工作。</target>
        </trans-unit>
        <trans-unit id="ed9884f0209355d73677c39f7ea1c603c1d343ae" translate="yes" xml:space="preserve">
          <source>The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.</source>
          <target state="translated">HTTP/2二进制框架机制被设计成不需要改变任何应用的API或配置文件:它对用户广泛透明。</target>
        </trans-unit>
        <trans-unit id="dc2a35fa99cfd317dd5558de4b34fa07535768f1" translate="yes" xml:space="preserve">
          <source>The HTTP/2 protocol has several prime differences from the HTTP/1.1 version:</source>
          <target state="translated">HTTP/2协议与HTTP/1.1版本有几个首要区别。</target>
        </trans-unit>
        <trans-unit id="99fbf8dd0978f7db7e2a91bcbd770cc0ec6b4bcd" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">主机请求标头字段指定从用户给定的原始URI或引用资源（通常为HTTP URL，如&lt;a href=&quot;#section-3.2.2&quot;&gt;第3.2.2节中&lt;/a&gt;所述）获得的所请求资源的Internet主机和端口号。主机字段值必须表示原始URL所指定的原始服务器或网关的命名权限。这允许源服务器或网关在内部模棱两可的URL之间进行区分，例如单个IP地址上多个主机名的服务器的根&amp;ldquo; /&amp;rdquo; URL。 Host =&amp;ldquo;主机&amp;rdquo;&amp;ldquo;：&amp;rdquo;主机[&amp;ldquo;：&amp;rdquo;端口]; &lt;a href=&quot;#section-3.2.2&quot;&gt;第3.2.2节&lt;/a&gt; 没有任何尾随端口信息的&amp;ldquo;主机&amp;rdquo;表示所请求服务的默认端口（例如，HTTP URL为&amp;ldquo; 80&amp;rdquo;）。例如，原始服务器上的&amp;lt; &lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt;将正确包含：GET /pub/WWW/HTTP/1.1主机：www.w3.org客户端必须在所有HTTP / 1.1请求消息中包含主机标头字段。如果所请求的URI不包含所请求服务的Internet主机名，则&amp;ldquo;主机头&amp;rdquo;字段必须给出一个空值。 HTTP / 1.1代理必须确保其转发的任何请求消息均包含适当的Host标头字段，该字段标识代理所请求的服务。所有基于Internet的HTTP / 1.1服务器必须对任何缺少主机头字段的HTTP / 1.1请求消息以400（错误请求）状态码进行响应。有关主机的其他要求，请参见&lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;和&lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="3b1aa4a92939a94846182a9752d0647f06200784" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</source>
          <target state="translated">超文本咖啡壶控制协议的茶叶流出设备(HTCPCP-TEA)。</target>
        </trans-unit>
        <trans-unit id="2fbdae656d9bef10ff135384ea52e37645e6d50f" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA): Response Codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1867896c3b2397819388475788a0bf4abcbf5ed6" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been accepted for processing, but the processing has not been completed; in fact, processing may not have started yet. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa10aaa19ccd9183c515b022dab356e9181ff7f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示已接收到请求但尚未执行该请求。这是非承诺性的，这意味着HTTP无法稍后发送指示响应请求结果的异步响应。它用于其他进程或服务器处理请求的情况，或用于批处理。</target>
        </trans-unit>
        <trans-unit id="8da2e56e0326733411c384ee9df3d066f1be28c3" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; 的超文本传输​​协议（HTTP）&lt;strong&gt;301&lt;/strong&gt;重定向状态响应代码指示所请求的资源已确定地移动到&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;头给出的URL 。浏览器重定向到此页面，搜索引擎更新其到资源的链接（在&amp;ldquo; SEO说&amp;rdquo;中，据说&amp;ldquo; link-juice&amp;rdquo;被发送到新的URL）。</target>
        </trans-unit>
        <trans-unit id="bca235dd87a759f1a9dd3bfa9203b6546d063663" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been temporarily moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header. A browser redirects to this page but search engines don't update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is not sent to the new URL).</source>
          <target state="translated">找到的超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码指示所请求的资源已被临时移动到&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头提供的URL 。浏览器重定向到此页面，但是搜索引擎不会更新其到资源的链接（在&amp;ldquo; SEO说&amp;rdquo;中，据说&amp;ldquo; link-juice&amp;rdquo;没有发送到新的URL）。</target>
        </trans-unit>
        <trans-unit id="a0dc42b9614cba52b23ba38ea15b1e9d7488ecb2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources but to another page, like a confirmation page or an upload progress page. This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码，指示重定向不链接到新上传的资源，而是链接到另一个页面，如确认页面或上传进度页面。此响应代码通常作为&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;的结果发送回去。用于显示此重定向页面的方法始终是&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d5990b78312268a2a1237e68fb338dd4e8d416f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources, but to another page (such as a confirmation page or an upload progress page). This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3108347112af1e3d29e6704655c39459a5034ad0" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码指示所请求的资源已确定地移动到&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头提供的URL 。浏览器重定向到此页面，搜索引擎更新其到资源的链接（在&amp;ldquo; SEO说&amp;rdquo;中，据说&amp;ldquo; link-juice&amp;rdquo;被发送到新的URL）。</target>
        </trans-unit>
        <trans-unit id="cbd8493e7cce398f69ed55cb6bb5f24186092644" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2055230dbe836c1aaf7bd92cbe0fa85f1440c7fc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server could not understand the request due to invalid syntax.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器由于语法无效而无法理解该请求。</target>
        </trans-unit>
        <trans-unit id="15ac14cd04fa900b118bba5f014d31ab3bbfe121" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request method is known by the server but is not supported by the target resource.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示请求方法是服务器已知的，但目标资源不支持该方法。</target>
        </trans-unit>
        <trans-unit id="60871008192002b75675780fc635a2b570a2bf8c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server cannot produce a response matching the list of acceptable values defined in the request's proactive &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, and that the server is unwilling to supply a default representation.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码表示服务器无法生成与请求的主动&lt;a href=&quot;../content_negotiation&quot;&gt;内容协&lt;/a&gt;商标头中定义的可接受值列表相匹配的响应，并且服务器不愿提供默认表示。</target>
        </trans-unit>
        <trans-unit id="6d70feb7e34e129ebc5526b0c592e1fdbf1c816e" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; response status code means that the server would like to shut down this unused connection. It is sent on an idle connection by some servers, &lt;em&gt;even without any previous request by the client&lt;/em&gt;.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器希望关闭此未使用的连接。&lt;em&gt;即使没有客户端的任何先前请求，&lt;/em&gt;某些服务器&lt;em&gt;也会&lt;/em&gt;通过空闲连接发送它。</target>
        </trans-unit>
        <trans-unit id="a66fb4f3fae8e6c063276dcb5237ee845eeca4ed" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示在源服务器上不再可以访问目标资源，并且这种情况很可能是永久的。</target>
        </trans-unit>
        <trans-unit id="4b9a35e682079b0a683f989a76db71ce57aae81d" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request without a defined &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示服务器拒绝接受没有定义的&lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;标头的请求。</target>
        </trans-unit>
        <trans-unit id="731510b854954129731e069eb6b3d2e9019b2fdc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; when the condition defined by the &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码表示对目标资源的访问已被拒绝。&lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;不满足&lt;a href=&quot;../headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;或If-None-Match标头定义的条件，则对&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;以外的方法的条件请求会发生这种情况。在这种情况下，通常无法进行请求（通常是资源的上载或修改），并将此错误响应发送回去。</target>
        </trans-unit>
        <trans-unit id="95dad23f3e8d87cfe4b0b1791422ccff7fdb0ec9" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; error response code indicates that a server cannot serve the requested ranges. The most likely reason is that the document doesn't contain such ranges, or that the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header value, though syntactically correct, doesn't make sense.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; 无法&lt;strong&gt;满足&lt;/strong&gt;错误响应代码指示服务器无法满足请求的范围。最可能的原因是文档不包含此类范围，或者&lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;头值（尽管从语法上来说是正确的）没有意义。</target>
        </trans-unit>
        <trans-unit id="99f1059b5dc6332a65c7949a31d1b45cbce33ed7" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示服务器理解请求实体的内容类型，并且请求实体的语法正确，但是无法处理所包含的指令。</target>
        </trans-unit>
        <trans-unit id="630618c062b0adb0b4e53d21c6ec93a1ffc8709b" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to risk processing a request that might be replayed, which creates the potential for a replay attack.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器不愿意冒可能处理可能被重播的请求的风险，这可能会导致重播攻击。</target>
        </trans-unit>
        <trans-unit id="2ba79c25bd016d25902460c531a9af1832ad5084" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the user requested a resource that is not available due to legal reasons, such as a web page for which a legal action has been issued.</source>
          <target state="translated">由于法律原因而无法使用的超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示用户请求了由于法律原因而无法使用的资源，例如已对其采取法律行动的网页。</target>
        </trans-unit>
        <trans-unit id="b137e360e4b5274b152a6bc5424bdda215ece645" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码表明服务器遇到意外状况，阻止其满足请求。</target>
        </trans-unit>
        <trans-unit id="9c744578cdc0d9bb57ba2e4e4ab0fa07c99379e2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码表示该请求方法不受服务器支持，无法处理。要求服务器支持的唯一方法（因此不能返回此代码）是&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1db14053efdc5b849d20c165c505ccbdce0af60c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code means that &lt;strong&gt;the server does not support the functionality required to fulfill the request&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56e521d7943d1bf8ac9d8be1e1d2c5a9c11ad29" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, received an invalid response from the upstream server.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码指示该服务器在充当网关或代理的同时，从上游服务器接收到无效响应。</target>
        </trans-unit>
        <trans-unit id="d97095b9bce2f7dabb2319cf5e31ce5cd055c7fe" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server is not ready to handle the request.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码指示服务器尚未准备好处理请求。</target>
        </trans-unit>
        <trans-unit id="ed70120131ebb0a274691c4d30386f6dc8fc669c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, cannot get a response in time.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码指示服务器充当网关或代理时，无法及时获得响应。</target>
        </trans-unit>
        <trans-unit id="a75a514de375190ba5cb2f8574ec6665fc8a648c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5206e7fbe439a4fe0558730cbd561b9d56ad71ad" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; response status code indicates that the HTTP version used in the request is not supported by the server.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; 的HTTP版本响应状态代码表示服务器不支持请求中使用的HTTP版本。</target>
        </trans-unit>
        <trans-unit id="2e3eb482b38eeaa5e40d4ddbab8b13b92a13f7fd" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems.  This document is the
   first in a series of documents that collectively form the HTTP/1.1
   specification:

   1.  &quot;Message Syntax and Routing&quot; (this document)

   2.  &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]

   3.  &quot;Conditional Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]

   4.  &quot;Range Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   5.  &quot;Caching&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]

   6.  &quot;Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;]

   This HTTP/1.1 specification obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; (on HTTP
   versioning).  This specification also updates the use of CONNECT to
   establish a tunnel, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, and defines the
   &quot;https&quot; URI scheme that was described informally in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;.

   HTTP is a generic interface protocol for information systems.  It is
   designed to hide the details of how a service is implemented by
   presenting a uniform interface to clients that is independent of the
   types of resources provided.  Likewise, servers do not need to be
   aware of each client's purpose: an HTTP request can be considered in
   isolation rather than being associated with a specific type of client
   or a predetermined sequence of application steps.  The result is a
   protocol that can be used effectively in many different contexts and
   for which implementations can evolve independently over time.

   HTTP is also designed for use as an intermediation protocol for
   translating communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative
   information services by translating their diverse protocols into a
   hypertext format that can be viewed and manipulated by clients in the
   same way as HTTP services.

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface.  Instead, we
   are limited to defining the syntax of communication, the intent of
   received communication, and the expected behavior of recipients.  If
   the communication is considered in isolation, then successful actions 

   ought to be reflected in corresponding changes to the observable
   interface provided by servers.  However, since multiple clients might
   act in parallel and perhaps at cross-purposes, we cannot require that
   such changes be observable beyond the scope of a single response.

   This document describes the architectural elements that are used or
   referred to in HTTP, defines the &quot;http&quot; and &quot;https&quot; URI schemes,
   describes overall network operation and connection management, and
   defines HTTP message framing and forwarding requirements.  Our goal
   is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining
   the complete set of requirements for message parsers and message-
   forwarding intermediaries.</source>
          <target state="translated">超文本传输​​协议（HTTP）是一种无状态的应用程序级请求/响应协议，它使用可扩展的语义和自描述消息有效负载来与基于网络的超文本信息系统进行灵活的交互。本文档是共同构成HTTP / 1.1规范的一系列文档中的第一篇：1.&amp;ldquo;消息语法和路由&amp;rdquo;（本文档）2.&amp;ldquo;语义和内容&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 3.&amp;ldquo;条件请求&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] 4.&amp;ldquo;范围请求&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] 5.&amp;ldquo;缓存&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ] 6.&amp;ldquo;身份验证&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]此HTTP / 1。1规范淘汰了&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;（基于HTTP版本控制）。该规范还更新了CONNECT的使用，以建立先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817中&lt;/a&gt;定义的隧道，并定义了在&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;中非正式描述的&amp;ldquo; https&amp;rdquo; URI方案。。 HTTP是信息系统的通用接口协议。它旨在通过向客户端呈现与提供的资源类型无关的统一接口来隐藏服务实现方式的详细信息。同样，服务器不需要知道每个客户端的目的：可以将HTTP请求视为孤立的请求，而不是与特定类型的客户端或应用程序的预定顺序相关联。结果是可以在许多不同的上下文中有效使用的协议，其实现可以随时间独立发展。 HTTP还被设计为用作中介协议，用于与非HTTP信息系统之间来回通信。HTTP代理和网关可以通过将其各种协议转换为超文本格式来提供对替代信息服务的访问权限，这些超文本格式可以由客户端以与HTTP服务相同的方式进行查看和操作。这种灵活性的结果是，无法根据接口后面发生的事情来定义协议。相反，我们仅限于定义通信的语法，接收到的通信的意图以及接收者的预期行为。如果孤立地考虑通信，那么成功的动作应该反映在对服务器提供的可观察接口的相应更改中。但是，由于多个客户可能会并行运行，甚至可能互为目的，我们不能要求这种变化超出单个响应的范围即可观察到。本文档描述了HTTP中使用或引用的体系结构元素，定义了&amp;ldquo; http&amp;rdquo;和&amp;ldquo; https&amp;rdquo; URI方案，描述了整个网络操作和连接管理，并定义了HTTP消息成帧和转发要求。我们的目标是定义与消息语义无关的HTTP消息处理所必需的所有机制，从而定义消息解析器和消息转发中介的完整要求集。描述整体网络操作和连接管理，并定义HTTP消息成帧和转发要求。我们的目标是定义与消息语义无关的HTTP消息处理所必需的所有机制，从而定义消息解析器和消息转发中介的完整要求集。描述整体网络操作和连接管理，并定义HTTP消息成帧和转发要求。我们的目标是定义与消息语义无关的HTTP消息处理所必需的所有机制，从而定义消息解析器和消息转发中介的完整要求集。</target>
        </trans-unit>
        <trans-unit id="bfba6f949d10bf9871b3c465a4b0c721c894d894" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World-Wide Web global
   information initiative since 1990. The first version of HTTP,
   referred to as HTTP/0.9, was a simple protocol for raw data transfer
   across the Internet. HTTP/1.0, as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], improved
   the protocol by allowing messages to be in the format of MIME-like
   messages, containing metainformation about the data transferred and
   modifiers on the request/response semantics. However, HTTP/1.0 does
   not sufficiently take into consideration the effects of hierarchical
   proxies, caching, the need for persistent connections, or virtual
   hosts. In addition, the proliferation of incompletely-implemented
   applications calling themselves &quot;HTTP/1.0&quot; has necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.

   This specification defines the protocol referred to as &quot;HTTP/1.1&quot;.
   This protocol includes more stringent requirements than HTTP/1.0 in
   order to ensure reliable implementation of its features.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end update, and annotation. HTTP
   allows an open-ended set of methods and headers that indicate the
   purpose of a request [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. It builds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], as a location
   (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] or name (URN) [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;], for indicating the resource to which a 

   method is to be applied. Messages are passed in a format similar to
   that used by Internet mail [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as defined by the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;].

   HTTP is also used as a generic protocol for communication between
   user agents and proxies/gateways to other Internet systems, including
   those supported by the SMTP [&lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt;], NNTP [&lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt;], FTP [&lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt;], Gopher [&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;],
   and WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt;] protocols. In this way, HTTP allows basic hypermedia
   access to resources available from diverse applications.</source>
          <target state="translated">超文本传输​​协议（HTTP）是分布式，协作式超媒体信息系统的应用程序级协议。自1990年以来，HTTP已由万维网全球信息倡议使用。HTTP的第一个版本称为HTTP / 0.9，是用于通过Internet传输原始数据的简单协议。 HTTP / 1.0，由&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [ &lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;]通过允许消息采用类似于MIME的消息格式来改进协议，其中包含有关所传输数据的元信息以及请求/响应语义上的修饰符。但是，HTTP / 1.0没有充分考虑分层代理，缓存，对持久连接的需求或虚拟主机的影响。另外，自称&amp;ldquo; HTTP / 1.0&amp;rdquo;的不完整应用程序的泛滥使协议版本必须更改，以便两个通信的应用程序确定彼此的真实功能。该规范定义了称为&amp;ldquo; HTTP / 1.1&amp;rdquo;的协议。该协议比HTTP / 1.0包含更严格的要求，以确保可靠地实现其功能。实用的信息系统需要比简单检索更多的功能，包括搜索，前端更新和注释。 HTTP允许一组开放式的方法和标头，用于指示请求的目的[&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]。它建立在统一资源标识符（URI）[ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ]作为位置（URL）[ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]或名称（URN）[ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ] 提供的参考原则的基础上，用于指示要对其应用方法的资源。邮件以与多用途Internet邮件扩展（MIME）[ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ] 定义的Internet邮件[ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] 相似的格式传递。 HTTP还用作用户代理与代理/网关到其他Internet系统之间通信的通用协议，包括SMTP [ &lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt; ]，NNTP [ &lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt; ]，FTP [ &lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt; ]，Gopher [ &lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt; ]和WAIS [WAS] 支持的那些代理&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt; ]协议。这样，HTTP允许对各种应用程序可用资源的基本超媒体访问。</target>
        </trans-unit>
        <trans-unit id="1a129c42494254f3f39028a252991104523d52ce" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</source>
          <target state="translated">超文本传输协议状态码308(永久重定向)</target>
        </trans-unit>
        <trans-unit id="2f67a1bb61a74c01a68383ec9ae389f39adb9d3d" translate="yes" xml:space="preserve">
          <source>The If header has two distinct purposes:

   o  The first purpose is to make a request conditional by supplying a
      series of state lists with conditions that match tokens and ETags
      to a specific resource.  If this header is evaluated and all state
      lists fail, then the request MUST fail with a 412 (Precondition
      Failed) status.  On the other hand, the request can succeed only
      if one of the described state lists succeeds.  The success
      criteria for state lists and matching functions are defined in
      Sections &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; and &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;.

   o  Additionally, the mere fact that a state token appears in an If
      header means that it has been &quot;submitted&quot; with the request.  In
      general, this is used to indicate that the client has knowledge of
      that state token.  The semantics for submitting a state token
      depend on its type (for lock tokens, please refer to &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).

   Note that these two purposes need to be treated distinctly: a state
   token counts as being submitted independently of whether the server
   actually has evaluated the state list it appears in, and also
   independently of whether or not the condition it expressed was found
   to be true.</source>
          <target state="translated">If头有两个不同的目的：o第一个目的是通过提供一系列条件列表来使请求成为条件，条件列表的条件将令牌和ETag匹配到特定资源。如果评估了这个头，并且所有状态列表都失败了，那么请求必须以412（失败的前提条件）状态失败。另一方面，仅当所描述的状态列表之一成功时，请求才能成功。状态列表和匹配功能的成功标准在&lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;和&lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;节中定义。 o此外，仅在状态标头中出现状态令牌的事实意味着它已与请求&amp;ldquo;一起提交&amp;rdquo;。通常，这用于指示客户端具有该状态令牌的知识。提交状态令牌的语义取决于其类型（关于锁定令牌，请参阅&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）。请注意，这两个目的需要加以区别对待：状态令牌被视为独立于服务器是否实际评估了其出现在其中的状态列表而提交，并且还独立于是否确定其所表示的条件为真。</target>
        </trans-unit>
        <trans-unit id="ef772a237bb19f58e37ac6262a206108449c06a7" translate="yes" xml:space="preserve">
          <source>The If request header is intended to have similar functionality to
   the If-Match header defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;Section&amp;nbsp;14.24 of [RFC2616]&lt;/a&gt;.  However,
   the If header handles any state token as well as ETags.  A typical
   example of a state token is a lock token, and lock tokens are the
   only state tokens defined in this specification.</source>
          <target state="translated">If请求标头旨在具有与&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;[RFC2616]的14.24节中&lt;/a&gt;定义的If-Match标头相似的功能。但是，If标头可处理任何状态令牌以及ETag。状态令牌的典型示例是锁定令牌，并且锁定令牌是本规范中定义的唯一状态令牌。</target>
        </trans-unit>
        <trans-unit id="f13702c8c2a26258beb9827d9b24d567b0373ca0" translate="yes" xml:space="preserve">
          <source>The If-Match request-header field is used with a method to make it
   conditional. A client that has one or more entities previously
   obtained from the resource can verify that one of those entities is
   current by including a list of their associated entity tags in the
   If-Match header field. Entity tags are defined in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The
   purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead. It is also
   used, on updating requests, to prevent inadvertent modification of
   the wrong version of a resource. As a special case, the value &quot;*&quot;
   matches any current entity of the resource.

       If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if &quot;*&quot; is given 

   and any current entity exists for that resource, then the server MAY
   perform the requested method as if the If-Match header field did not
   exist.

   A server MUST use the strong comparison function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;)
   to compare the entity tags in If-Match.

   If none of the entity tags match, or if &quot;*&quot; is given and no current
   entity exists, the server MUST NOT perform the requested method, and
   MUST return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.

   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status, then the If-Match header
   MUST be ignored.

   The meaning of &quot;If-Match: *&quot; is that the method SHOULD be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;) exists, and
   MUST NOT be performed if the representation does not exist.

   A request intended to update a resource (e.g., a PUT) MAY include an
   If-Match header field to signal that the request method MUST NOT be
   applied if the entity corresponding to the If-Match value (a single
   entity tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:

       If-Match: &quot;xyzzy&quot;
       If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-Match: *

   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Match请求标头字段与使它成为条件的方法一起使用。具有先前从资源获得的一个或多个实体的客户端可以通过在If-Match标头字段中包括其关联的实体标签的列表来验证这些实体之一是当前的。实体标签在&lt;a href=&quot;#section-3.11&quot;&gt;3.11节&lt;/a&gt;中定义。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。在更新请求时，也可以使用它来防止对错误版本的资源进行无意的修改。在特殊情况下，值&amp;ldquo; *&amp;rdquo;与资源的任何当前实体匹配。 If-Match =&amp;ldquo; If-Match&amp;rdquo;&amp;ldquo;：&amp;rdquo;（&amp;ldquo; *&amp;rdquo; | 1＃entity-tag）如果任何实体标签与在响应类似GET请求的响应中已返回的实体的实体标签相匹配（在该资源上没有If-Match标头），或者如果给定了&amp;ldquo; *&amp;rdquo;并且该资源存在任何当前实体，则服务器可以执行请求的方法，就像If-Match标头字段不存在一样。服务器必须使用强比较功能（请参阅&lt;a href=&quot;#section-13.3.3&quot;&gt;第13.3.3节&lt;/a&gt;）以比较If-Match中的实体标签。如果没有任何实体标签匹配，或者给出了&amp;ldquo; *&amp;rdquo;，并且当前实体不存在，则服务器不得执行请求的方法，并且必须返回412（失败的前提条件）响应。当客户端希望阻止诸如PUT之类的更新方法修改自客户端上次检索该资源以来已更改的资源时，此行为最有用。如果该请求在没有If-Match头域的情况下导致2xx或412状态以外的其他任何情况，则必须忽略If-Match头。 &amp;ldquo; If-Match：*&amp;rdquo;的含义是，如果源服务器（或缓存，可能使用Vary机制）选择了表示形式，则应执行该方法，请参见&lt;a href=&quot;#section-14.44&quot;&gt;14.44节&lt;/a&gt;）存在，并且如果该表示不存在，则不得执行。旨在更新资源的请求（例如，PUT）可能包括If-Match头域，以信号通知如果与If-Match值相对应的实体（单个实体标签）不再存在，则必须不应用该请求方法该资源的表示。如果资源在他们不知情的情况下被更改，这允许用户指示他们不希望请求成功。示例：If-Match：&amp;ldquo; xyzzy&amp;rdquo; If-Match：&amp;ldquo; xyzzy&amp;rdquo;，&amp;ldquo; r2d2xxxx&amp;rdquo;，&amp;ldquo; c3piozzzz&amp;rdquo; If-Match：*请求的结果同时具有If-Match头字段和If-None-Match或If-Modified-Since标头字段未由该规范定义。</target>
        </trans-unit>
        <trans-unit id="9436a493b897cd39a84206566701a405b2d51016" translate="yes" xml:space="preserve">
          <source>The If-Modified-Since request-header field is used with a method to
   make it conditional: if the requested variant has not been modified
   since the time specified in this field, an entity will not be
   returned from the server; instead, a 304 (not modified) response will
   be returned without any message-body.

       If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date 

   An example of the field is:

       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A GET method with an If-Modified-Since header and no Range header
   requests that the identified entity be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:

      a) If the request would normally result in anything other than a
         200 (OK) status, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.

      b) If the variant has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.

      c) If the variant has not been modified since a valid If-
         Modified-Since date, the server SHOULD return a 304 (Not
         Modified) response.

   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.

      Note: The Range request-header field modifies the meaning of If-
      Modified-Since; see &lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt; for full details.

      Note: If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.

      Note: When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-
      Modified-Since header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-
      Modified header field whenever possible.

      Note: If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the 

      possibility of clock-skew-related problems if the If-Modified-
      Since date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.

   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Modified-Since请求标头字段与有条件的方法一起使用：如果自此字段中指定的时间以来所请求的变体没有被修改，则不会从服务器返回实体；相反，将返回304（未修改）响应，而没有任何消息正文。 If-Modified-Since =&amp;ldquo; If-Modified-Since&amp;rdquo;&amp;ldquo;：&amp;rdquo; HTTP日期字段的示例为：If-Modified-Since：Sat，1994年10月29日19:43:31 GMT带有If-的GET方法Modified-Since标头和没有Range标头的请求仅当从If-Modified-Since标头给出的日期以来对已标识的实体进行了修改的情况下，才转移所标识的实体。确定这种情况的算法包括以下几种情况：a）如果该请求通常会导致200（OK）状态以外的任何结果，或者所传递的If-Modified-Since日期无效，则响应与正常GET完全相同。迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到或者，如果传递的If-Modified-Since日期无效，则响应与正常GET完全相同。迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到或如果传递的If-Modified-Since日期无效，则响应与正常GET完全相同。迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到&lt;a href=&quot;#section-14.35&quot;&gt;第14.35条&lt;/a&gt;有关详细信息。注意：If-Modified-Since时间由服务器解释，其时钟可能未与客户端同步。注意：在处理If-Modified-Since标头字段时，某些服务器将使用精确的日期比较功能（而不是小于功能）来决定是否发送304（未修改）响应。为了在发送If-Modified-Since标头字段进行缓存验证时获得最佳结果，建议客户端尽可能使用在上一个Last-Modified标头字段中收到的确切日期字符串。注意：如果客户在If-Modified-Since标头中使用任意日期，而不是从同一请求的Last-Modified标头中获取日期，客户应意识到服务器在对时间的理解中会解释该日期。由于客户端和服务器之间的时间编码不同，客户端应考虑不同步的时钟和舍入问题。这包括：如果文档在第一次请求的时间与后续请求的If-Modified-Since日期之间发生更改，则可能出现竞争状况；如果If-Modified-Since日期，则可能存在时钟偏斜相关的问题。从客户端的时钟派生而无需校正服务器的时钟。由于网络延迟的缘故，对于客户端和服务器之间不同时基的修正最多是近似的。同时具有If-Modified-Since头字段和If-Match或If-Unmodified-Since头字段的请求结果在本规范中未定义。</target>
        </trans-unit>
        <trans-unit id="39e92741a96fab5452a65a932345457528d34e55" translate="yes" xml:space="preserve">
          <source>The If-None-Match request-header field is used with a method to make
   it conditional. A client that has one or more entities previously
   obtained from the resource can verify that none of those entities is
   current by including a list of their associated entity tags in the
   If-None-Match header field. The purpose of this feature is to allow
   efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g. PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.

   As a special case, the value &quot;*&quot; matches any current entity of the
   resource.

       If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if &quot;*&quot; is
   given and any current entity exists for that resource, then the
   server MUST NOT perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server SHOULD
   respond with a 304 (Not Modified) response, including the cache-
   related header fields (particularly ETag) of one of the entities that
   matched. For all other request methods, the server MUST respond with
   a status of 412 (Precondition Failed).

   See &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt; for rules on how to determine if two entities tags
   match. The weak comparison function can only be used with GET or HEAD
   requests. 

   If none of the entity tags match, then the server MAY perform the
   requested method as if the If-None-Match header field did not exist,
   but MUST also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity tags match, then the server MUST NOT
   return a 304 (Not Modified) response.

   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status, then the If-None-Match
   header MUST be ignored. (See &lt;a href=&quot;#section-13.3.4&quot;&gt;section 13.3.4&lt;/a&gt; for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)

   The meaning of &quot;If-None-Match: *&quot; is that the method MUST NOT be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;)
   exists, and SHOULD be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.

   Examples:

       If-None-Match: &quot;xyzzy&quot;
       If-None-Match: W/&quot;xyzzy&quot;
       If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
       If-None-Match: *

   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-None-Match请求标头字段与使它成为条件的方法一起使用。具有先前从资源获得的一个或多个实体的客户端可以通过在If-None-Match标头字段中包括其关联的实体标签的列表来验证这些实体中没有一个是当前的。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。当客户端认为该资源不存在时，它还可用于防止方法（例如PUT）无意中修改现有资源。在特殊情况下，值&amp;ldquo; *&amp;rdquo;与资源的任何当前实体匹配。 If-None-Match =&amp;ldquo; If-None-Match&amp;rdquo;&amp;ldquo;：&amp;rdquo;（&amp;ldquo; *&amp;rdquo;| 1＃entity-tag）是否有任何实体标签与该资源上对类似GET请求（没有If-None-Match标头）的响应中已返回的实体的实体标签匹配，或者&amp;ldquo; *给出&amp;ldquo;&amp;rdquo;，并且该资源存在任何当前实体，则服务器不得执行所请求的方法，除非需要这样做，因为资源的修改日期与请求中If-Modified-Since标头字段中提供的日期不匹配。相反，如果请求方法是GET或HEAD，则服务器应以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的标头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到看到看到看到看到那么服务器必须禁止执行请求的方法，除非需要这样做，因为资源的修改日期与请求中If-Modified-Since标头字段中提供的日期不匹配。相反，如果请求方法是GET或HEAD，则服务器应以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的标头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到那么服务器必须禁止执行请求的方法，除非需要这样做，因为资源的修改日期与请求中If-Modified-Since标头字段中提供的日期不匹配。相反，如果请求方法是GET或HEAD，则服务器应以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的标头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到服务器应该以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到服务器应该以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到&lt;a href=&quot;#section-13.3.3&quot;&gt;&lt;/a&gt;有关如何确定两个实体标签是否匹配的规则，请参见第13.3.3节。弱比较功能只能与GET或HEAD请求一起使用。如果没有一个实体标签匹配，则服务器可以执行请求的方法，就像If-None-Match头字段不存在一样，但是必须也忽略请求中的任何If-Modified-Since头字段。也就是说，如果没有任何实体标签匹配，则服务器务必不得返回304（未修改）响应。如果该请求在没有If-None-Match头字段的情况下导致2xx或304状态以外的任何其他情况，则必须忽略If-None-Match头。 （请参阅&lt;a href=&quot;#section-13.3.4&quot;&gt;第13.3.4节&lt;/a&gt;用于讨论在同一请求中同时出现If-Modified-Since和If-None-Match时的服务器行为。）&amp;ldquo; If-None-Match：*&amp;rdquo;的含义是，如果选择了表示形式，则不得执行该方法由原始服务器（或通过缓存，可能使用Vary机制），请参阅&lt;a href=&quot;#section-14.44&quot;&gt;第14.44节&lt;/a&gt;）存在，如果该表示不存在，则应该执行。此功能旨在防止PUT操作之间的冲突。示例：If-None-Match：&amp;ldquo; xyzzy&amp;rdquo; If-None-Match：W /&amp;ldquo; xyzzy&amp;rdquo; If-None-Match：&amp;ldquo; xyzzy&amp;rdquo;，&amp;ldquo; r2d2xxxx&amp;rdquo;，&amp;ldquo; c3piozzzz&amp;rdquo; If-None-Match：W /&amp;ldquo; xyzzy&amp;rdquo; ，W /&amp;ldquo; r2d2xxxx&amp;rdquo;，W /&amp;ldquo; c3piozzzz&amp;rdquo; If-None-Match：*具有If-None-Match头字段和If-Match或If-Unmodified-Since头字段的请求的结果是本规范未定义。</target>
        </trans-unit>
        <trans-unit id="a77607d9e035711baba5b97bc67fee22711422dd" translate="yes" xml:space="preserve">
          <source>The If-Unmodified-Since request-header field is used with a method to
   make it conditional. If the requested resource has not been modified
   since the time specified in this field, the server SHOULD perform the
   requested operation as if the If-Unmodified-Since header were not
   present.

   If the requested variant has been modified since the specified time,
   the server MUST NOT perform the requested operation, and MUST return
   a 412 (Precondition Failed).

      If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date

   An example of the field is:

       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status, the
   If-Unmodified-Since header SHOULD be ignored.

   If the specified date is invalid, the header is ignored.

   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.</source>
          <target state="translated">If-Unmodified-Since request-header字段与一个方法一起使用,使其成为条件。如果被请求的资源自该字段指定的时间以来没有被修改过,则服务器SHOULD执行请求的操作,就像If-Unmodified-Since头不存在一样。如果请求的变体在指定的时间后被修改,服务器必须不执行请求的操作,并且必须返回一个412(预设条件失败)。If-Unmodified-Since=&quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date 该字段的一个例子是:If-Unmodified-Since:Sat,29 Oct 1994 19:43:31 GMT 如果正常情况下(即没有If-Unmodified-Since头)请求的结果不是2xx或412状态,If-Unmodified-Since头应该被忽略。如果指定的日期是无效的,那么该头将被忽略。如果一个请求同时有If-Unmodified-Since头字段和If-None-Match或If-Modified-Since头字段,其结果在本规范中没有定义。</target>
        </trans-unit>
        <trans-unit id="fdfb0dc451f3880ef0d4f67dac2ee95582caadcf" translate="yes" xml:space="preserve">
          <source>The JavaScript function returns a single string</source>
          <target state="translated">该JavaScript函数返回一个字符串</target>
        </trans-unit>
        <trans-unit id="703e778a54d67833e0037322f76c267a64284bbc" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself and not be embedded in HTML.</source>
          <target state="translated">JavaScript函数应该总是被单独保存到一个文件中,而不是嵌入到HTML中。</target>
        </trans-unit>
        <trans-unit id="b34c71697b1823e77b9a782ccdbeeb5fdf757c55" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself but not be embedded in a HTML file or any other file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3233de7c368a8e5f19a8ef2604664291230823" translate="yes" xml:space="preserve">
          <source>The JavaScript snippets included in these sections (and running instances of the server-code that correctly handles these cross-site requests) can be found &quot;in action&quot; at &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt;, and will work in browsers that support cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/上&lt;/a&gt;找到&amp;ldquo;实际使用&amp;rdquo;中的这些部分（以及正确处理这些跨站点请求的服务器代码的运行实例）中包含的JavaScript代码段，并且在支持跨站点 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 的浏览器中工作。</target>
        </trans-unit>
        <trans-unit id="925661df194abc683169e90bef883c4c078be359" translate="yes" xml:space="preserve">
          <source>The Keep-Alive Header (Experimental specification)</source>
          <target state="translated">Keep-Alive Header (实验性规格)</target>
        </trans-unit>
        <trans-unit id="db2749cedc967fd4ef7ed7614b130c614deab08c" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field indicates the date and time at
   which the origin server believes the variant was last modified.

       Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date 

   An example of its use is

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it may be just the file system last-modified time. For
   entities with dynamically included parts, it may be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it may be the last-update time stamp of the record. For
   virtual objects, it may be the last time the internal state changed.

   An origin server MUST NOT send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server MUST replace that date with the message
   origination date.

   An origin server SHOULD obtain the Last-Modified value of the entity
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the entity's modification time, especially if the entity changes
   near the time that the response is generated.

   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</source>
          <target state="translated">Last-Modified实体头字段表示起源服务器认为变体最后被修改的日期和时间。Last-Modified=&quot;Last-Modified&quot; &quot;:&quot; HTTP-date 它的一个使用例子是 Last-Modified:Tue,15 Nov 1994 12:45:26 GMT 这个头域的确切含义取决于源服务器的实现和原始资源的性质。对于文件,它可能只是文件系统的最后修改时间。对于具有动态包含部分的实体,它可能是其组件部分的最近一次修改时间集。对于数据库网关,它可能是记录的最后更新时间戳。对于虚拟对象,它可能是内部状态最后一次改变的时间。源服务器必须不发送比服务器的消息发起时间晚的Last-Modified日期。在这种情况下,如果资源的最后一次修改表明是在未来的某个时间,服务器必须用消息发起日期来替换这个日期。发起服务器should获取实体的Last-Modified值,尽可能地接近它生成响应的Date值的时间。这可以让接收者准确评估实体的修改时间,特别是当实体在生成响应的时间附近发生变化时。HTTP/1.1服务器只要可行,就应该发送Last-Modified。</target>
        </trans-unit>
        <trans-unit id="528a83f631c94edde30298fe82ad4b470dc52fd6" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the entity has not been modified since the Last-Modified value.</source>
          <target state="translated">Last-Modified实体头字段值通常被用作缓存验证器。简单来说,如果一个实体在最后修改值之后没有被修改过,那么这个缓存条目就被认为是有效的。</target>
        </trans-unit>
        <trans-unit id="017625ae11b1cf3babbe1d1e9f72538a1d0bcdba" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">位置响应标头字段用于将收件人重定向到Request-URI以外的其他位置，以完成请求或标识新资源。对于201（已创建）响应，位置是请求创建的新资源的位置。对于3xx响应，位置应该指示服务器的首选URI，用于自动重定向到资源。字段值由单个绝对URI组成。 Location =&amp;ldquo; Location&amp;rdquo;&amp;ldquo;：&amp;rdquo; absoluteURI例如：Location：&lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/pub/WWW/People.html 注意：Content-Location标头字段（&lt;a href=&quot;#section-14.14&quot;&gt;第14.14节）&lt;/a&gt;）与位置的不同之处在于，内容位置标识了请求中包含的实体的原始位置。因此，响应可能包含Location和Content-Location的标头字段。另请参见&lt;a href=&quot;#section-13.10&quot;&gt;13.10节&lt;/a&gt;，了解某些方法的缓存要求。</target>
        </trans-unit>
        <trans-unit id="5bc7ceee0f881c0002d5d80140938c1e7f80c8e7" translate="yes" xml:space="preserve">
          <source>The MIME type of audiovisual files mostly indicate the container formats. The most common ones on the Web are:</source>
          <target state="translated">视听文件的MIME类型多表示容器格式。网络上最常见的有:</target>
        </trans-unit>
        <trans-unit id="7e997fc9b96d9d0ec4b11746c0834f2c40378a91" translate="yes" xml:space="preserve">
          <source>The MOVE operation on a non-collection resource is the logical
   equivalent of a copy (COPY), followed by consistency maintenance
   processing, followed by a delete of the source, where all three
   actions are performed in a single operation.  The consistency
   maintenance step allows the server to perform updates caused by the
   move, such as updating all URLs, other than the Request-URI that
   identifies the source resource, to point to the new destination
   resource. 

   The Destination header MUST be present on all MOVE methods and MUST
   follow all COPY requirements for the COPY part of the MOVE method.
   All WebDAV-compliant resources MUST support the MOVE method.

   Support for the MOVE method does not guarantee the ability to move a
   resource to a particular destination.  For example, separate programs
   may actually control different sets of resources on the same server.
   Therefore, it may not be possible to move a resource within a
   namespace that appears to belong to the same server.

   If a resource exists at the destination, the destination resource
   will be deleted as a side-effect of the MOVE operation, subject to
   the restrictions of the Overwrite header.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">在非集合资源上执行MOVE操作在逻辑上等效于副本（COPY），然后执行一致性维护处理，然后删除源，在此操作中，所有三个操作均在单个操作中执行。一致性维护步骤允许服务器执行由移动引起的更新，例如更新所有URL，而不是标识源资源的Request-URI，以指向新的目标资源。 Destination标头必须出现在所有MOVE方法上，并且必须遵循MOVE方法的COPY部分的所有COPY要求。所有符合WebDAV的资源都必须支持MOVE方法。对MOVE方法的支持不能保证将资源移动到特定目标的能力。例如，单独的程序实际上可以控制同一服务器上的不同资源集。因此，可能无法在似乎属于同一服务器的名称空间内移动资源。如果目标上存在资源，则该目标资源将作为MOVE操作的副作用而删除，但要遵守Overwrite标头的限制。此方法是幂等的，但不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="cb1023831cad3159839df21a4251dd372a13a0bc" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the
   TRACE (&lt;a href=&quot;#section-9.8&quot;&gt;section 9.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-9.2&quot;&gt;section 9.2&lt;/a&gt;) methods to limit the
   number of proxies or gateways that can forward the request to the
   next inbound server. This can be useful when the client is attempting
   to trace a request chain which appears to be failing or looping in
   mid-chain.

       Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message may be forwarded.

   Each proxy or gateway recipient of a TRACE or OPTIONS request
   containing a Max-Forwards header field MUST check and update its
   value prior to forwarding the request. If the received value is zero
   (0), the recipient MUST NOT forward the request; instead, it MUST
   respond as the final recipient. If the received Max-Forwards value is
   greater than zero, then the forwarded message MUST contain an updated
   Max-Forwards field with a value decremented by one (1).

   The Max-Forwards header field MAY be ignored for all other methods
   defined by this specification and for any extension methods for which
   it is not explicitly referred to as part of that method definition.</source>
          <target state="translated">Max-Forwards请求标头字段提供了一种具有TRACE（&lt;a href=&quot;#section-9.8&quot;&gt;第9.8节&lt;/a&gt;）和OPTIONS（&lt;a href=&quot;#section-9.2&quot;&gt;第9.2 &lt;/a&gt;节）的机制。）方法，以限制可以将请求转发到下一个入站服务器的代理或网关的数量。当客户端尝试跟踪似乎在中间链中失败或循环的请求链时，此功能很有用。 Max-Forwards =&amp;ldquo; Max-Forwards&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1 * DIGIT Max-Forwards值是一个十进制整数，指示可以转发此请求消息的剩余次数。包含Max-Forwards标头字段的TRACE或OPTIONS请求的每个代理或网关接收者必须在转发请求之前检查并更新其值。如果接收到的值为零（0），则接收者不得转发该请求；相反，它必须作为最终收件人进行响应。如果收到的Max-Forwards值大于零，那么转发的消息必须包含一个更新的Max-Forward字段，其值减一（1）。对于本规范定义的所有其他方法以及未明确将其定义为该方法定义一部分的所有扩展方法，可以忽略Max-Forwards标头字段。</target>
        </trans-unit>
        <trans-unit id="b9679bb7ec73b85f439581526aa5e2f804e20f5f" translate="yes" xml:space="preserve">
          <source>The Member URI allows clients to retrieve, edit, and delete a Member
   Resource using HTTP's GET, PUT, and DELETE methods.  Entry Resources
   are represented as Atom Entry documents.

   Member URIs appear in two places.  They are returned in a Location
   header after successful Resource creation using POST, as described in
   &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt; below.  They can also appear in a Collection Feed's
   Entries, as atom:link elements with a link relation of &quot;edit&quot;.

   A Member Entry SHOULD contain such an atom:link element with a link
   relation of &quot;edit&quot;, which indicates the Member URI.</source>
          <target state="translated">成员URI允许客户端使用HTTP的GET，PUT和DELETE方法检索，编辑和删除成员资源。条目资源表示为Atom条目文档。成员URI出现在两个位置。使用POST成功创建资源后，它们将在Location标头中返回，如 以下&lt;a href=&quot;#section-9.2&quot;&gt;9.2节&lt;/a&gt;所述。它们也可以作为具有&amp;ldquo;编辑&amp;rdquo;链接关系的atom：link元素出现在集合提要的条目中。成员条目应包含这样的atom：link元素，其链接关系为&amp;ldquo; edit&amp;rdquo;，指示成员URI。</target>
        </trans-unit>
        <trans-unit id="8bc27eaceea013a32bec84be620f4a677881aac7" translate="yes" xml:space="preserve">
          <source>The Method  token indicates the method to be performed on the
   resource identified by the Request-URI. The method is case-sensitive.

       Method         = &quot;OPTIONS&quot;                ; &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;
                      | &quot;GET&quot;                    ; &lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;
                      | &quot;HEAD&quot;                   ; &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;
                      | &quot;POST&quot;                   ; &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;
                      | &quot;PUT&quot;                    ; &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;
                      | &quot;DELETE&quot;                 ; &lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;
                      | &quot;TRACE&quot;                  ; &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;
                      | &quot;CONNECT&quot;                ; &lt;a href=&quot;#section-9.9&quot;&gt;Section 9.9&lt;/a&gt;
                      | extension-method
       extension-method = token

   The list of methods allowed by a resource can be specified in an
   Allow header field (&lt;a href=&quot;#section-14.7&quot;&gt;section 14.7&lt;/a&gt;). The return code of the response
   always notifies the client whether a method is currently allowed on a
   resource, since the set of allowed methods can change dynamically. An
   origin server SHOULD return the status code 405 (Method Not Allowed)
   if the method is known by the origin server but not allowed for the
   requested resource, and 501 (Not Implemented) if the method is
   unrecognized or not implemented by the origin server. The methods GET
   and HEAD MUST be supported by all general-purpose servers. All other
   methods are OPTIONAL; however, if the above methods are implemented,
   they MUST be implemented with the same semantics as those specified
   in &lt;a href=&quot;#section-9&quot;&gt;section 9&lt;/a&gt;.</source>
          <target state="translated">方法令牌指示要对由请求URI标识的资源执行的方法。该方法区分大小写。方法=&amp;ldquo;选项&amp;rdquo;；&lt;a href=&quot;#section-9.2&quot;&gt;第9.2节&lt;/a&gt; | &amp;ldquo; GET&amp;rdquo;；&lt;a href=&quot;#section-9.3&quot;&gt;第9.3节&lt;/a&gt; | &amp;ldquo;头&amp;rdquo;；&lt;a href=&quot;#section-9.4&quot;&gt;第9.4节&lt;/a&gt; | &amp;ldquo; POST&amp;rdquo;；&lt;a href=&quot;#section-9.5&quot;&gt;第9.5节&lt;/a&gt; | &amp;ldquo;放置&amp;rdquo;；&lt;a href=&quot;#section-9.6&quot;&gt;第9.6节&lt;/a&gt; | &amp;ldquo;删除&amp;rdquo;；&lt;a href=&quot;#section-9.7&quot;&gt;第9.7节&lt;/a&gt; | &amp;ldquo; TRACE&amp;rdquo;；&lt;a href=&quot;#section-9.8&quot;&gt;第9.8节&lt;/a&gt; | &amp;ldquo;连接&amp;rdquo;; &lt;a href=&quot;#section-9.9&quot;&gt;9.9节&lt;/a&gt; | extension-method extension-method =令牌可以在Allow标头字段中指定资源允许的方法列表（&lt;a href=&quot;#section-14.7&quot;&gt;第14.7节）&lt;/a&gt;）。响应的返回代码总是通知客户端资源上当前是否允许某个方法，因为允许的方法集可以动态更改。如果源服务器知道该方法但不允许所请求的资源，则源服务器应返回状态码405（不允许方法），如果源服务器无法识别或未实现该方法，则返回501（未实现）。所有通用服务器都必须支持GET和HEAD方法。所有其他方法都是可选的。但是，如果实现了上述方法，则必须以与&lt;a href=&quot;#section-9&quot;&gt;第9节中&lt;/a&gt;指定的语义相同的语义来实现。</target>
        </trans-unit>
        <trans-unit id="b472ea77a890edf2b85c6971105718fc4fd6fc42" translate="yes" xml:space="preserve">
          <source>The OPTIONS method represents a request for information about the
   communication options available on the request/response chain
   identified by the Request-URI. This method allows the client to
   determine the options and/or requirements associated with a resource,
   or the capabilities of a server, without implying a resource action
   or initiating a resource retrieval.

   Responses to this method are not cacheable.

   If the OPTIONS request includes an entity-body (as indicated by the
   presence of Content-Length or Transfer-Encoding), then the media type
   MUST be indicated by a Content-Type field. Although this
   specification does not define any use for such a body, future
   extensions to HTTP might use the OPTIONS body to make more detailed
   queries on the server. A server that does not support such an
   extension MAY discard the request body.

   If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
   intended to apply to the server in general rather than to a specific
   resource. Since a server's communication options typically depend on
   the resource, the &quot;*&quot; request is only useful as a &quot;ping&quot; or &quot;no-op&quot;
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 compliance (or lack thereof).

   If the Request-URI is not an asterisk, the OPTIONS request applies
   only to the options that are available when communicating with that
   resource.

   A 200 response SHOULD include any header fields that indicate
   optional features implemented by the server and applicable to that
   resource (e.g., Allow), possibly including extensions not defined by
   this specification. The response body, if any, SHOULD also include
   information about the communication options. The format for such a 

   body is not defined by this specification, but might be defined by
   future extensions to HTTP. Content negotiation MAY be used to select
   the appropriate response format. If no response body is included, the
   response MUST include a Content-Length field with a field-value of
   &quot;0&quot;.

   The Max-Forwards request-header field MAY be used to target a
   specific proxy in the request chain. When a proxy receives an OPTIONS
   request on an absoluteURI for which request forwarding is permitted,
   the proxy MUST check for a Max-Forwards field. If the Max-Forwards
   field-value is zero (&quot;0&quot;), the proxy MUST NOT forward the message;
   instead, the proxy SHOULD respond with its own communication options.
   If the Max-Forwards field-value is an integer greater than zero, the
   proxy MUST decrement the field-value when it forwards the request. If
   no Max-Forwards field is present in the request, then the forwarded
   request MUST NOT include a Max-Forwards field.</source>
          <target state="translated">OPTIONS方法表示请求提供关于由Request-URI确定的请求/响应链上可用的通信选项的信息。该方法允许客户端确定与资源相关联的选项和/或要求,或服务器的能力,而不暗示资源操作或启动资源检索。对该方法的响应是不可缓存的。如果OPTIONS请求包括实体主体(如Content-Length或Transfer-Encoding所示),那么媒体类型必须由Content-Type字段表示。虽然本规范没有定义这种实体体的任何用途,但未来HTTP的扩展可能会使用OPTIONS实体体来对服务器进行更详细的查询。不支持这种扩展的服务器可以丢弃请求体。如果Request-URI是星号(&quot;*&quot;),则OPTIONS请求的目的是适用于一般的服务器而不是特定的资源。由于服务器的通信选项通常取决于资源,所以 &quot;*&quot;请求仅作为 &quot;ping &quot;或 &quot;no-op &quot;类型的方法有用;它除了允许客户端测试服务器的能力外,没有其他作用。例如,这可以用来测试代理服务器是否符合HTTP/1.1的要求(或不符合)。如果Request-URI不是星号,OPTIONS请求只适用于与该资源通信时可用的选项。200响应应该包括任何表示由服务器实现并适用于该资源的可选功能的头字段(例如,Allow),可能包括本规范未定义的扩展。响应体(如果有的话)还应该包括有关通信选项的信息。本规范没有定义这种主体的格式,但可能由HTTP的未来扩展来定义。内容协商可以用来选择合适的响应格式。如果不包含响应体,响应必须包含一个字段值为 &quot;0 &quot;的Content-Length字段。Max-Forwards request-header字段可用于在请求链中锁定特定的代理。当代理收到一个允许请求转发的绝对URI上的OPTIONS请求时,代理必须检查Max-Forwards字段。如果Max-Forwards字段的值为0(&quot;0&quot;),代理必须不转发消息;相反,代理应该用自己的通信选项来响应。如果Max-Forwards字段值是一个大于0的整数,代理在转发请求时必须递减字段值。如果请求中没有Max-Forwards字段,那么转发的请求必须不包含Max-Forwards字段。</target>
        </trans-unit>
        <trans-unit id="49820b72a266a24d241c6570cc10be88c4ce50ca" translate="yes" xml:space="preserve">
          <source>The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action. 

   An OPTIONS request with an asterisk (&quot;*&quot;) as the request-target
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the &quot;*&quot; request is only useful as a
   &quot;ping&quot; or &quot;no-op&quot; type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of &quot;0&quot; if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.</source>
          <target state="translated">OPTIONS方法在源服务器或中间中介处请求有关可用于目标资源的通信选项的信息。此方法允许客户端确定与资源相关联的选项和/或要求或服务器的功能，而无需暗示资源操作。以星号（*）为请求目标的OPTIONS请求（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]的第5.3节）&lt;/a&gt;）通常适用于服务器，而不适用于特定资源。由于服务器的通信选项通常取决于资源，因此&amp;ldquo; *&amp;rdquo;请求仅用作&amp;ldquo; ping&amp;rdquo;或&amp;ldquo; no-op&amp;rdquo;类型的方法；除了允许客户端测试服务器功能之外，它没有任何作用。例如，这可以用于测试代理是否符合HTTP / 1.1规范（或缺少规范）。如果请求目标不是星号，则OPTIONS请求适用于与目标资源通信时可用的选项。产生对OPTIONS的成功响应的服务器应发送任何标头字段，这些标头字段可能指示该服务器实现并适用于目标资源的可选功能（例如，Allow），包括本规范未定义的潜在扩展。响应有效载荷（如果有）也可能以机器或人类可读的表示形式描述通信选项。此规范的标准格式不是由本规范定义的，但可能由将来对HTTP的扩展来定义。如果在响应中不发送有效载荷主体，则服务器必须生成一个值为&amp;ldquo; 0&amp;rdquo;的Content-Length字段。客户端可以在OPTIONS请求中发送Max-Forwards标头字段以定位请求链中的特定接收者（参见但可能由将来的HTTP扩展定义。如果在响应中不发送有效载荷主体，则服务器必须生成一个值为&amp;ldquo; 0&amp;rdquo;的Content-Length字段。客户端可以在OPTIONS请求中发送Max-Forwards标头字段以定位请求链中的特定接收者（参见但可能由将来的HTTP扩展定义。如果在响应中不发送有效载荷主体，则服务器必须生成一个值为&amp;ldquo; 0&amp;rdquo;的Content-Length字段。客户端可以在OPTIONS请求中发送Max-Forwards标头字段以定位请求链中的特定接收者（参见 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2节&lt;/a&gt;）。代理在转发请求时不得生成Max-Forwards标头字段，除非收到带有Max-Forwards字段的请求。生成包含有效内容主体的OPTIONS请求的客户端务必发送描述表示形式媒体类型的有效Content-Type头字段。尽管此规范未定义对此类有效负载的任何用法，但将来对HTTP的扩展可能会使用OPTIONS主体对目标资源进行更详细的查询。对OPTIONS方法的响应不可缓存。</target>
        </trans-unit>
        <trans-unit id="335a905cdd5cc098f1e6a149fd20a764baed11c1" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the Blink engine, which is why it almost looks the same, but adds &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0b5a78c1f599442b880ea6a8403854d20e3ef6" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the blink engine, which is why it almost looks the same, but adds &quot;OPR/&amp;lt;version&amp;gt;&quot;.</source>
          <target state="translated">Opera浏览器也基于眨眼引擎，这就是为什么它看上去几乎相同，但是添加了&amp;ldquo; OPR / &amp;lt;version&amp;gt;&amp;rdquo;的原因。</target>
        </trans-unit>
        <trans-unit id="1a9fb731478c28f4fa3740727c3862c0e8280261" translate="yes" xml:space="preserve">
          <source>The Operating System is given in most User Agent strings (although not web-focused platforms like Firefox OS), but the format varies a lot. It is a fixed string between two semi-colons, in the comment part of the User Agent. These strings are specific for each browser. They indicate the OS, but also often its version and information on the relying hardware (32 or 64 bits, or Intel/PPC for Mac).</source>
          <target state="translated">大多数用户代理字符串中都给出了操作系统(尽管不是像Firefox OS这样的网络平台),但格式变化很大。它是一个固定的字符串,在两个分号之间,在用户代理的注释部分。这些字符串对每个浏览器来说都是特定的。它们表明了操作系统,但通常也表明了它的版本和所依赖的硬件信息(32或64位,或Mac的Intel/PPC)。</target>
        </trans-unit>
        <trans-unit id="b865b396cc503b061720f4db16c1a8fdc2531248" translate="yes" xml:space="preserve">
          <source>The PAC file is named &lt;code&gt;proxy.pac&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9837bd9139ad48f4cd2dd0906bd1f2401fbe7f" translate="yes" xml:space="preserve">
          <source>The PAC file is named proxy.pac</source>
          <target state="translated">PAC文件命名为proxy.pac</target>
        </trans-unit>
        <trans-unit id="ad2834ac0702672d145d7ca3894c53d5a21fd051" translate="yes" xml:space="preserve">
          <source>The PHP snippets (and the JavaScript invocations to the server) in subsequent sections are taken from &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;the working code samples posted here.&lt;/a&gt; These will work in browsers that implement cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">后续部分中的PHP代码片段（以及服务器的JavaScript调用）摘自&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;此处发布的工作代码示例。&lt;/a&gt;这些将在实现跨站点&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 的&lt;/a&gt;浏览器中工作。</target>
        </trans-unit>
        <trans-unit id="d84539c58092eb061728beac8d3510599c78d9e2" translate="yes" xml:space="preserve">
          <source>The POST method is used to request that the origin server accept the
   entity enclosed in the request as a new subordinate of the resource
   identified by the Request-URI in the Request-Line. POST is designed
   to allow a uniform method to cover the following functions:

      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;

      - Extending a database through an append operation.

   The actual function performed by the POST method is determined by the
   server and is usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is subordinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a record is subordinate to a
   database.

   The action performed by the POST method might not result in a
   resource that can be identified by a URI. In this case, either 200
   (OK) or 204 (No Content) is the appropriate response status,
   depending on whether or not the response includes an entity that
   describes the result. 

   If a resource has been created on the origin server, the response
   SHOULD be 201 (Created) and contain an entity which describes the
   status of the request and refers to the new resource, and a Location
   header (see &lt;a href=&quot;#section-14.30&quot;&gt;section 14.30&lt;/a&gt;).

   Responses to this method are not cacheable, unless the response
   includes appropriate Cache-Control or Expires header fields. However,
   the 303 (See Other) response can be used to direct the user agent to
   retrieve a cacheable resource.

   POST requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">POST方法用于请求源服务器接受请求中包含的实体作为请求行中Request-URI标识的资源的新下属。 POST旨在允许一种统一的方法来覆盖以下功能：-现有资源的注释； -将消息发布到公告板，新闻组，邮件列表或类似的文章组； -向数据处理过程提供数据块，例如提交表单的结果； -通过附加操作扩展数据库。 POST方法执行的实际功能由服务器确定，通常取决于Request-URI。发布的实体从属于该URI，就像文件从属于包含它的目录一样，新闻文章从属于发布的新闻组，或者记录从属于数据库。 POST方法执行的操作可能不会导致可以由URI标识的资源。在这种情况下，适当的响应状态是200（确定）或204（无内容），这取决于响应是否包括描述结果的实体。如果在原始服务器上创建了资源，则响应应为201（已创建），并包含一个描述请求状态并引用新资源的实体以及一个Location标头（请参见在这种情况下，适当的响应状态是200（确定）或204（无内容），这取决于响应是否包括描述结果的实体。如果在原始服务器上创建了资源，则响应应为201（已创建），并包含一个描述请求状态并引用新资源的实体以及一个Location标头（请参见在这种情况下，适当的响应状态是200（确定）或204（无内容），这取决于响应是否包括描述结果的实体。如果在原始服务器上创建了资源，则响应应为201（已创建），并包含一个描述请求状态并引用新资源的实体以及一个Location标头（请参见&lt;a href=&quot;#section-14.30&quot;&gt;第14.30条&lt;/a&gt;）。除非响应包括适当的Cache-Control或Expires标头字段，否则对此方法的响应不可缓存。但是，303（请参阅其他）响应可用于指导用户代理检索可缓存资源。 POST请求必须遵守&lt;a href=&quot;#section-8.2&quot;&gt;8.2节中&lt;/a&gt;规定的消息传输要求。出于安全考虑，请参阅&lt;a href=&quot;#section-15.1.3&quot;&gt;第15.1.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7c4a0540415d773e2957d84d1e4f16f405d585a" translate="yes" xml:space="preserve">
          <source>The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process; 

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7234]&lt;/a&gt;).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.</source>
          <target state="translated">The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics. For example, POST is used for the following functions (among others): o Providing a block of data, such as the fields entered into an HTML form, to a data-handling process; o Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles; o Creating a new resource that has yet to be identified by the origin server; and o Appending data to a resource's existing representation(s). An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification might be received in a response to POST (the exceptions being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not Satisfiable)). If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing a Location header field that provides an identifier for the primary resource created (&lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2节&lt;/a&gt;）和描述请求状态的表述，同时引用新资源。对POST请求的响应仅在包含显式的新鲜度信息时才可缓存（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;[RFC7234]的4.2.1节&lt;/a&gt;）。但是，POST缓存并未广泛实施。对于原始服务器希望客户端能够以一种可以被以后的GET重用的方式缓存POST结果的情况，原始服务器可以发送一个200（OK）响应，其中包含结果和一个Content-Location。标头字段，其值与POST的有效请求URI相同（&lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt;). If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.</target>
        </trans-unit>
        <trans-unit id="babc13478772ae526be737f6ddcf858ed85d894b" translate="yes" xml:space="preserve">
          <source>The PROPFIND method retrieves properties defined on the resource
   identified by the Request-URI, if the resource does not have any
   internal members, or on the resource identified by the Request-URI
   and potentially its member resources, if the resource is a collection
   that has internal member URLs.  All DAV-compliant resources MUST
   support the PROPFIND method and the propfind XML element
   (&lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;) along with all XML elements defined for use with that
   element.

   A client MUST submit a Depth header with a value of &quot;0&quot;, &quot;1&quot;, or
   &quot;infinity&quot; with a PROPFIND request.  Servers MUST support &quot;0&quot; and &quot;1&quot;
   depth requests on WebDAV-compliant resources and SHOULD support
   &quot;infinity&quot; requests.  In practice, support for infinite-depth
   requests MAY be disabled, due to the performance and security
   concerns associated with this behavior.  Servers SHOULD treat a
   request without a Depth header as if a &quot;Depth: infinity&quot; header was
   included. 

   A client may submit a 'propfind' XML element in the body of the
   request method describing what information is being requested.  It is
   possible to:

   o  Request particular property values, by naming the properties
      desired within the 'prop' element (the ordering of properties in
      here MAY be ignored by the server),

   o  Request property values for those properties defined in this
      specification (at a minimum) plus dead properties, by using the
      'allprop' element (the 'include' element can be used with
      'allprop' to instruct the server to also include additional live
      properties that may not have been returned otherwise),

   o  Request a list of names of all the properties defined on the
      resource, by using the 'propname' element.

   A client may choose not to submit a request body.  An empty PROPFIND
   request body MUST be treated as if it were an 'allprop' request.

   Note that 'allprop' does not return values for all live properties.
   WebDAV servers increasingly have expensively-calculated or lengthy
   properties (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) and do not return all
   properties already.  Instead, WebDAV clients can use propname
   requests to discover what live properties exist, and request named
   properties when retrieving values.  For a live property defined
   elsewhere, that definition can specify whether or not that live
   property would be returned in 'allprop' requests.

   All servers MUST support returning a response of content type text/
   xml or application/xml that contains a multistatus XML element that
   describes the results of the attempts to retrieve the various
   properties.

   If there is an error retrieving a property, then a proper error
   result MUST be included in the response.  A request to retrieve the
   value of a property that does not exist is an error and MUST be noted
   with a 'response' XML element that contains a 404 (Not Found) status
   value.

   Consequently, the 'multistatus' XML element for a collection resource
   MUST include a 'response' XML element for each member URL of the
   collection, to whatever depth was requested.  It SHOULD NOT include
   any 'response' elements for resources that are not WebDAV-compliant.
   Each 'response' element MUST contain an 'href' element that contains
   the URL of the resource on which the properties in the prop XML
   element are defined.  Results for a PROPFIND on a collection resource
   are returned as a flat list whose order of entries is not 

   significant.  Note that a resource may have only one value for a
   property of a given name, so the property may only show up once in
   PROPFIND responses.

   Properties may be subject to access control.  In the case of
   'allprop' and 'propname' requests, if a principal does not have the
   right to know whether a particular property exists, then the property
   MAY be silently excluded from the response.

   Some PROPFIND results MAY be cached, with care, as there is no cache
   validation mechanism for most properties.  This method is both safe
   and idempotent (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of [RFC2616]&lt;/a&gt;).</source>
          <target state="translated">如果资源没有任何内部成员，则PROPFIND方法将检索在Request-URI所标识的资源上定义的属性；如果资源是具有以下内容的集合，则该资源将在Request-URI所标识的资源及其可能的成员资源上定义内部成员网址。所有符合DAV的资源都必须支持PROPFIND方法和Profind XML元素（&lt;a href=&quot;#section-14.20&quot;&gt;第14.20节&lt;/a&gt;）以及为该元素定义的所有XML元素。客户端必须通过PROPFIND请求提交深度标头，其值为&amp;ldquo; 0&amp;rdquo;，&amp;ldquo; 1&amp;rdquo;或&amp;ldquo; infinity&amp;rdquo;。服务器必须在符合WebDAV的资源上支持&amp;ldquo; 0&amp;rdquo;和&amp;ldquo; 1&amp;rdquo;深度请求，并且应该支持&amp;ldquo;无限&amp;rdquo;请求。实际上，由于与此行为相关的性能和安全问题，可能会禁用对无限深度请求的支持。服务器应将没有深度标头的请求视为已包含&amp;ldquo;深度：无限&amp;rdquo;标头。客户端可以在请求方法的主体中提交&amp;ldquo; propfind&amp;rdquo; XML元素，以描述正在请求的信息。可以：o请求特定的属性值，通过在'prop'元素内命名所需的属性（服务器可以忽略此处的属性顺序），o通过使用'请求该规范中定义的那些属性的属性值（至少）以及无效属性。 allprop&amp;rdquo;元素（&amp;ldquo; include&amp;rdquo;元素可以与&amp;ldquo; allprop&amp;rdquo;一起使用，以指示服务器还包括其他可能未返回的实时属性），o请求资源上定义的所有属性的名称列表，通过使用&amp;ldquo; propname&amp;rdquo;元素。客户可以选择不提交请求正文。空的PROPFIND请求正文必须被视为&amp;ldquo; allprop&amp;rdquo;请求。请注意，&amp;ldquo; allprop&amp;rdquo;不会返回所有活动属性的值。WebDAV服务器越来越具有昂贵的计算或冗长的属性（请参阅[&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]和[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]），并且不返回所有属性。相反，WebDAV客户端可以使用propname请求来发现存在的活动属性，并在检索值时请求命名属性。对于在其他位置定义的活动属性，该定义可以指定是否在&amp;ldquo; allprop&amp;rdquo;请求中返回该活动属性。所有服务器必须支持返回内容类型为text / xml或application / xml的响应，该响应包含多状态XML元素，该元素描述了尝试检索各种属性的结果。如果检索属性时发生错误，则必须在响应中包含正确的错误结果。检索不存在的属性值的请求是错误，必须以&amp;ldquo;响应&amp;rdquo;记录包含404（未找到）状态值的XML元素。因此，对于集合资源的&amp;ldquo;多状态&amp;rdquo; XML元素必须包括对集合的每个成员URL的&amp;ldquo;响应&amp;rdquo; XML元素，无论请求的深度如何。对于不符合WebDAV要求的资源，它不应包含任何&amp;ldquo;响应&amp;rdquo;元素。每个&amp;ldquo;响应&amp;rdquo;元素必须包含一个&amp;ldquo; href&amp;rdquo;元素，其中包含在其上定义prop XML元素属性的资源的URL。集合资源上PROPFIND的结果将作为平面列表返回，其条目顺序不重要。请注意，资源对于给定名称的属性可能只有一个值，因此该属性在PROPFIND响应中可能只显示一次。属性可能受访问控制。对于&amp;ldquo; allprop&amp;rdquo;和&amp;ldquo; propname&amp;rdquo;请求，如果委托人无权知道某个特定属性是否存在，则可以将该属性默默地排除在响应之外。某些PROPFIND结果可能要小心缓存，因为大多数属性没有缓存验证机制。此方法既安全又幂等（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="63b7604adf362cf9b58baac42bf0c778df2e71b7" translate="yes" xml:space="preserve">
          <source>The PROPPATCH method processes instructions specified in the request
   body to set and/or remove properties defined on the resource
   identified by the Request-URI.

   All DAV-compliant resources MUST support the PROPPATCH method and
   MUST process instructions that are specified using the
   propertyupdate, set, and remove XML elements.  Execution of the
   directives in this method is, of course, subject to access control
   constraints.  DAV-compliant resources SHOULD support the setting of
   arbitrary dead properties.

   The request message body of a PROPPATCH method MUST contain the
   propertyupdate XML element.

   Servers MUST process PROPPATCH instructions in document order (an
   exception to the normal rule that ordering is irrelevant).
   Instructions MUST either all be executed or none executed.  Thus, if
   any error occurs during processing, all executed instructions MUST be
   undone and a proper error result returned.  Instruction processing
   details can be found in the definition of the set and remove
   instructions in Sections &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; and &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;.

   If a server attempts to make any of the property changes in a
   PROPPATCH request (i.e., the request is not rejected for high-level
   errors before processing the body), the response MUST be a Multi-
   Status response as described in &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt;.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">PROPPATCH方法处理在请求正文中指定的指令，以设置和/或删除在Request-URI标识的资源上定义的属性。所有符合DAV的资源都必须支持PROPPATCH方法，并且必须处理使用propertyupdate，set和remove XML元素指定的指令。当然，此方法中指令的执行受访问控制约束。符合DAV的资源应支持任意无效属性的设置。 PROPPATCH方法的请求消息主体必须包含propertyupdate XML元素。服务器必须按文档顺序处理PROPPATCH指令（与顺序无关的普通规则是一个例外）。指令必须全部执行或不执行。从而，如果在处理过程中发生任何错误，则必须撤消所有已执行的指令，并返回正确的错误结果。可以在集合的定义中找到指令处理的详细信息，并在部分中删除指令。&lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;和&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;。如果服务器尝试在PROPPATCH请求中进行任何属性更改（即，在处理主体之前，该请求不会因高级错误而被拒绝），则响应必须是&lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1节中&lt;/a&gt;描述的多状态响应。。此方法是幂等的，但并不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="1975f22fa255d880d63431b9c6a1e839eaebbdbb" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the enclosed entity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosed entity SHOULD be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI does not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
   agent, the origin server can create the resource with that URI. If a
   new resource is created, the origin server MUST inform the user agent
   via the 201 (Created) response. If an existing resource is modified,
   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
   to indicate successful completion of the request. If the resource
   could not be created or modified with the Request-URI, an appropriate
   error response SHOULD be given that reflects the nature of the
   problem. The recipient of the entity MUST NOT ignore any Content-*
   (e.g. Content-Range) headers that it does not understand or implement
   and MUST return a 501 (Not Implemented) response in such cases.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.

   The fundamental difference between the POST and PUT requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resource that will handle the enclosed
   entity. That resource might be a data-accepting process, a gateway to
   some other protocol, or a separate entity that accepts annotations.
   In contrast, the URI in a PUT request identifies the entity enclosed
   with the request -- the user agent knows what URI is intended and the
   server MUST NOT attempt to apply the request to some other resource.
   If the server desires that the request be applied to a different URI, 

   it MUST send a 301 (Moved Permanently) response; the user agent MAY
   then make its own decision regarding whether or not to redirect the
   request.

   A single resource MAY be identified by many different URIs. For
   example, an article might have a URI for identifying &quot;the current
   version&quot; which is separate from the URI identifying each particular
   version. In this case, a PUT request on a general URI might result in
   several other URIs being defined by the origin server.

   HTTP/1.1 does not define how a PUT method affects the state of an
   origin server.

   PUT requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   Unless otherwise specified for a particular entity-header, the
   entity-headers in the PUT request SHOULD be applied to the resource
   created or modified by the PUT.</source>
          <target state="translated">PUT方法请求将封闭的实体存储在提供的Request-URI下。如果Request-URI引用了已经存在的资源，则应将封闭的实体视为驻留在原始服务器上的实体的修改版本。如果Request-URI没有指向现有资源，并且请求用户代理可以将该URI定义为新资源，则原始服务器可以使用该URI创建资源。如果创建了新资源，则原始服务器务必通过201（已创建）响应通知用户代理。如果修改了现有资源，则应发送200（确定）或204（无内容）响应代码以指示请求已成功完成。如果无法使用Request-URI创建或修改资源，应该给出反映问题性质的适当的错误响应。实体的接收者不得忽略其无法理解或实现的任何Content-*（例如Content-Range）头，并且在这种情况下必须返回501（未实现）响应。如果请求通过缓存，并且Request-URI标识一个或多个当前缓存的实体，则应将这些条目视为过期。此方法的响应不可缓存。 POST和PUT请求之间的根本区别体现在Request-URI的不同含义上。 POST请求中的URI标识将处理封闭实体的资源。该资源可能是数据接受过程，某些其他协议的网关，或者是接受注释的单独实体。相比之下，PUT请求中的URI标识请求中包含的实体-用户代理知道URI的意图，并且服务器绝不能尝试将请求应用于其他资源。如果服务器希望将该请求应用于其他URI，则它必须发送301（永久移动）响应；然后，用户代理可以自行决定是否重定向请求。单个资源可以由许多不同的URI标识。例如，文章可能具有用于标识&amp;ldquo;当前版本&amp;rdquo;的URI，该URI与标识每个特定版本的URI分开。在这种情况下，对通用URI的PUT请求可能会导致原始服务器定义了其他几个URI。 HTTP / 1。1没有定义PUT方法如何影响原始服务器的状态。 PUT请求必须遵守消息传输要求&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节&lt;/a&gt;。除非为特定的实体头另有规定，否则PUT请求中的实体头应该应用于由PUT创建或修改的资源。</target>
        </trans-unit>
        <trans-unit id="7beb3539a595c62f6de09ee642f7b3a560d38b59" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that 

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of &quot;text/html&quot; and the representation being PUT has a
   Content-Type of &quot;image/jpeg&quot;, the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to &quot;text/html&quot;,
       perhaps including a link to a different resource that would be a
       suitable target for the new representation. 

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is &quot;stored&quot;, nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying &quot;the current version&quot; (a resource) that is separate from
   the URIs identifying each particular version (different resources 

   that at one point shared the same state as the current version
   resource).  A successful PUT request on &quot;the current version&quot; URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt;]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">PUT方法请求创建目标资源的状态或将其替换为请求消息有效负载中包含的表示形式所定义的状态。给定表示的成功PUT将表明，在同一目标资源上进行的后续GET将导致在200（OK）响应中发送等效表示。但是，不能保证这样的状态更改是可观察到的，因为在接收到任何后续GET之前，目标资源可能由其他用户代理并行作用，或者可能由源服务器进行动态处理。成功的响应仅表示原始服务器在处理用户代理时已达到其意图。如果目标资源没有当前表示，并且PUT成功创建了一个表示，则原始服务器务必通过发送201（已创建）响应来通知用户代理。如果目标资源确实具有当前表示形式，并且该表示形式已根据封闭表示形式的状态成功进行了修改，则原始服务器务必发送200（确定）或204（无内容）响应，以指示成功完成了请求。源服务器应该忽略在PUT请求中接收到的无法识别的头字段（即，不要将它们保存为资源状态的一部分）。原始服务器应验证PUT表示是否与服务器对目标资源的任何约束一致，该约束不能由PUT更改，也不会由PUT更改。当源服务器使用与URI相关的内部配置信息以便为GET响应设置表示元数据的值时，这尤其重要。当PUT表示与目标资源不一致时，源服务器应通过转换表示或更改资源配置来使其一致，或者使用包含足够信息的适当错误消息进行响应，以解释为什么该表示不合适。建议使用409（冲突）或415（不受支持的媒体类型）状态码，后者专用于对Content-Type值的限制。例如，如果目标资源配置为始终具有&amp;ldquo; text / html&amp;rdquo;的Content-Type并且表示为PUT的Content-Type为&amp;ldquo; image / jpeg&amp;rdquo;，原始服务器应执行以下操作之一：重新配置目标资源以反映新的媒体类型； b。将PUT表示形式转换为与资源一致的格式，然后再将其保存为新的资源状态；或c。使用415（不支持的媒体类型）响应拒绝该请求，该响应指示目标资源仅限于&amp;ldquo; text / html&amp;rdquo;，可能包括指向其他​​资源的链接，该链接将是新表示形式的合适目标。 HTTP并未明确定义PUT方法如何影响原始服务器的状态，超出了用户代理请求的意图和原始服务器响应的语义所能表达的范围。无论从什么意义上讲，它都没有定义通过HTTP提供的接口之外的资源。它没有定义资源状态的&amp;ldquo;存储&amp;rdquo;方式，也没有定义由于资源状态变化而导致的存储方式如何变化，也没有定义原始服务器如何将资源状态转换为表示形式。通常，服务器故意隐藏资源接口后面的所有实现细节。源服务器不得发送验证者头字段（服务器有意隐藏了资源接口后面的所有实现细节。源服务器不得发送验证者头字段（服务器有意隐藏了资源接口后面的所有实现细节。源服务器不得发送验证者头字段（&lt;a href=&quot;#section-7.2&quot;&gt;第7.2节&lt;/a&gt;）（例如ETag或Last-Modified字段）在成功响应PUT之前，除非保存请求的表示形式数据而未对主体应用任何转换（即资源的新表示形式数据与在其中接收到的表示数据相同） PUT请求）和验证者字段的值反映了新的表示形式。此要求允许用户代理知道它在内存中的表示体何时由于PUT而保持最新状态，因此不需要再次从源服务器检索，并且响应中接收到新的验证器。可以用于将来的条件请求，以防止意外覆盖（&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;）。 POST和PUT方法之间的根本区别通过封闭表示的不同意图得以突出。 POST请求中的目标资源旨在根据资源自身的语义处理封闭的表示形式，而PUT请求中的封闭的表示形式则定义为替换目标资源的状态。因此，即使确切的效果仅由原始服务器知道，PUT的意图也是幂等的，并且对中介者可见。对PUT请求的正确解释假定用户代理知道需要哪个目标资源。在收到状态更改请求后，代表客户选择适当URI的服务应使用POST方法而非PUT实现。如果原始服务器不会将请求的PUT状态更改为目标资源，而是希望将其应用于其他资源（例如，当资源已移至其他URI时），则原始服务器务必发送适当的3xx （重定向）响应；然后，用户代理可以自行决定是否重定向请求。应用于目标资源的PUT请求可能会对其他资源产生副作用。例如，文章可能具有用于标识&amp;ldquo;当前版本&amp;rdquo;（一种资源）的URI，该URI与标识每个特定版本的URI（在某一点与当前版本资源共享相同状态的不同资源）分开。在&amp;ldquo;当前版本&amp;rdquo;上成功的PUT请求因此，除了更改目标资源的状态之外，URI可能还会创建新的版本资源，并且可能还会导致在相关资源之间添加链接。允许在给定目标资源上进行PUT的原始服务器必须向包含内容范围标头字段的PUT请求发送400（错误请求）响应（&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;[RFC7233]的第4.2节&lt;/a&gt;），因为有效负载可能是部分内容，但已误将其作为完整表示进行了PUT。通过以状态与较大资源的一部分重叠的状态单独标识资源为目标，或者通过使用专门为部分更新定义的其他方法（例如，在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt; ]中定义的PATCH方法），可以进行部分内容更新。对PUT方法的响应不可缓存。如果成功的PUT请求通过具有有效请求URI的一个或多个存储响应的缓存，则这些存储的响应将无效（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234]的4.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6e42dfbab6315a9d1786cb94b26bfc16b764a831" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-
   specific directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   MAY require that behavior be consistent with the directives.

       Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
       pragma-directive  = &quot;no-cache&quot; | extension-pragma
       extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]

   When the no-cache directive is present in a request message, an
   application SHOULD forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) and is defined here for backward compatibility with
   HTTP/1.0. Clients SHOULD include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant. 

   Pragma directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient SHOULD be ignored by that recipient.

   HTTP/1.1 caches SHOULD treat &quot;Pragma: no-cache&quot; as if the client had
   sent &quot;Cache-Control: no-cache&quot;. No new Pragma directives will be
   defined in HTTP.

      Note: because the meaning of &quot;Pragma: no-cache as a response
      header field is not actually specified, it does not provide a
      reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</source>
          <target state="translated">Pragma通用标头字段用于包含特定于实现的指令，这些指令可能适用于请求/响应链中的任何接收者。从协议的角度来看，所有编译指示都指定了可选的行为。但是，某些系统可能要求行为与指令保持一致。 Pragma =&amp;ldquo; Pragma&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃pragma指令pragma指令=&amp;ldquo; no-cache&amp;rdquo; | extension-pragma extension-pragma = token [&amp;ldquo; =&amp;rdquo;（token | quoted-string）]当请求消息中存在no-cache指令时，即使应用程序具有缓存副本，应用程序也应将请求转发至原始服务器请求的内容。 该pragma伪指令与no-cache cache-directive具有相同的语义（请参阅&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节）。&lt;/a&gt;），并在此处定义为与HTTP / 1.0向后兼容。当向服务器发送不缓存请求（不符合HTTP / 1.1规范）时，客户端应同时包含两个标头字段。代理程序或网关应用程序必须传递实用指令，而不考虑它们对该应用程序的重要性，因为该指令可能适用于请求/响应链中的所有接收者。无法为特定收件人指定实用程序；但是，任何与接收者无关的编译指示都应被该接收者忽略。 HTTP / 1.1缓存应将&amp;ldquo; Pragma：no-cache&amp;rdquo;视为客户端已发送&amp;ldquo; Cache-Control：no-cache&amp;rdquo;。 HTTP中不会定义新的Pragma指令。注意：因为&amp;ldquo; Pragma：由于没有实际指定响应头字段，因此没有提供no-cache，它不能在响应中可靠地替代&amp;ldquo; Cache-Control：no-cache&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="871bcdf53c1b79539586617d7fc176e073aa2706" translate="yes" xml:space="preserve">
          <source>The Proxy-Authenticate response-header field MUST be included as part
   of a 407 (Proxy Authentication Required) response. The field value
   consists of a challenge that indicates the authentication scheme and
   parameters applicable to the proxy for this Request-URI.

       Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Unlike
   WWW-Authenticate, the Proxy-Authenticate header field applies only to
   the current connection and SHOULD NOT be passed on to downstream
   clients. However, an intermediate proxy might need to obtain its own
   credentials by requesting them from the downstream client, which in
   some circumstances will appear as if the proxy is forwarding the
   Proxy-Authenticate header field.</source>
          <target state="translated">必须将Proxy-Authenticate响应标头字段作为407（需要代理认证）响应的一部分包括在内。该字段值包含一个质询，该质询指示适用于此Request-URI的代理的身份验证方案和参数。 Proxy-Authenticate =&amp;ldquo; Proxy-Authenticate&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃挑战&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo;中描述了HTTP访问身份验证过程[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]。与WWW-Authenticate不同，Proxy-Authenticate标头字段仅适用于当前连接，不应将其传递给下游客户端。但是，中间代理可能需要通过向下游客户端请求它们来获取其自身的凭据，在某些情况下，中间代理看起来像是在转发Proxy-Authenticate标头字段。</target>
        </trans-unit>
        <trans-unit id="ad6052a85e2e7f8497d8ed5920ca77e487770b52" translate="yes" xml:space="preserve">
          <source>The Proxy-Authorization request-header field allows the client to
   identify itself (or its user) to a proxy which requires
   authentication. The Proxy-Authorization field value consists of
   credentials containing the authentication information of the user
   agent for the proxy and/or realm of the resource being requested.

       Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;] . Unlike
   Authorization, the Proxy-Authorization header field applies only to
   the next outbound proxy that demanded authentication using the Proxy-
   Authenticate field. When multiple proxies are used in a chain, the 

   Proxy-Authorization header field is consumed by the first outbound
   proxy that was expecting to receive credentials. A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Proxy-Authorization请求标头字段允许客户端向需要身份验证的代理标识自己（或其用户）。 Proxy-Authorization字段值由凭据组成，这些凭据包含用于所请求资源的代理和/或领域的用户代理的身份验证信息。 Proxy-Authorization =&amp;ldquo; Proxy-Authorization&amp;rdquo;&amp;ldquo;：&amp;rdquo;凭证HTTP访问认证过程在&amp;ldquo; HTTP认证：基本和摘要访问认证&amp;rdquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]。与授权不同，&amp;ldquo;代理授权&amp;rdquo;标头字段仅适用于需要使用&amp;ldquo;代理身份验证&amp;rdquo;字段进行身份验证的下一个出站代理。当一条链中使用多个代理时，第一个要接收凭据的出站代理会使用Proxy-Authorization标头字段。代理可以将证书从客户请求中继到下一个代理，如果这是代理协同认证给定请求的机制。</target>
        </trans-unit>
        <trans-unit id="a2e20c61425846c0564c678e617e3a0e40ac8e14" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Referer [sic] request-header字段允许客户端为服务器的利益指定从中获取Request-URI的资源的地址（URI）（&amp;ldquo; referrer&amp;rdquo;，尽管标头字段拼写错误）。 Referer请求标头允许服务器生成指向资源的反向链接列表，以进行关注，日志记录，优化的缓存等。它还允许跟踪过时或类型错误的链接以进行维护。如果Request-URI是从没有自己的URI的源（例如来自用户键盘的输入）获得的，则不得发送Referer字段。 Referer =&amp;ldquo; Referer&amp;rdquo;&amp;ldquo;：&amp;rdquo;（absoluteURI | relativeURI）示例：引用者：&lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/hypertext/DataSources/Overview.html 如果该字段值是相对URI，则应相对于Request-URI进行解释。URI不得包含片段。出于安全考虑，请参阅 &lt;a href=&quot;#section-15.1.3&quot;&gt;第15.1.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ada285615064adfa5d8e8460b22e8d2e1a9f7a60" translate="yes" xml:space="preserve">
          <source>The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending with CRLF. The
   elements are separated by SP characters. No CR or LF is allowed
   except in the final CRLF sequence.

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</source>
          <target state="translated">请求行以方法标记开始,后面是请求URI和协议版本,最后是CRLF。这些元素由SP字符分隔。除最后的CRLF序列外,不允许有CR或LF。Request-Line=Method SP Request-URI SP HTTP-Version CRLF。</target>
        </trans-unit>
        <trans-unit id="8314c65661bfa76aafcdfccc2a0cabd4c8b07f40" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URI是统一资源标识符（&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;），并标识在其上应用请求的资源。 Request-URI =&amp;ldquo; *&amp;rdquo; | absoluteURI | abs_path |权限Request-URI的四个选项取决于请求的性质。星号&amp;ldquo; *&amp;rdquo;表示请求不适用于特定资源，而是适用于服务器本身，并且仅在所使用的方法不一定适用于资源时才允许。一个示例是OPTIONS * HTTP / 1.1向代理发出请求时，需要absoluteURI形式。请求代理转发请求或从有效缓存中为其提供服务，并返回响应。注意，代理可以将请求转发到另一个代理，或者直接转发到absoluteURI指定的服务器。为了避免请求循环，代理必须能够识别其所有服务器名称，包括任何别名，本地变体和数字IP地址。请求行示例为：GET&lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1为了在将来的HTTP版本中允许在所有请求中转换为absoluteURI，即使所有HTTP / 1.1服务器也必须在请求中接受absoluteURI形式，即使HTTP / 1.1客户端只会在对代理的请求中生成它们。授权表仅由CONNECT方法使用（&lt;a href=&quot;#section-9.9&quot;&gt;第9.9节&lt;/a&gt;）。 Request-URI的最常见形式是用于标识源服务器或网关上的资源的形式。在这种情况下，必须发送URI的绝对路径（参见&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1节）。&lt;/a&gt;（例如abs_path）作为请求URI，并且URI（授权）的网络位置必须在主机标头字段中传输。例如，希望直接从源服务器检索以上资源的客户端将创建到主机&amp;ldquo; www.w3.org&amp;rdquo;的端口80的TCP连接，并发送以下行：GET /pub/WWW/TheProject.html HTTP / 1.1主机：www.w3.org，后跟请求的其余部分。注意绝对路径不能为空；如果原始URI中没有任何内容，则必须将其指定为&amp;ldquo; /&amp;rdquo;（服务器根目录）。 Request-URI以&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1 &lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;节中&lt;/a&gt;指定的格式发送。如果请求URI是使用&amp;ldquo;％HEX HEX&amp;rdquo;编码[ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;]，原始服务器必须解码Request-URI，以正确解释请求。服务器应使用适当的状态码响应无效的Request-URI。当透明的代理转发到下一个入站服务器时，绝不能重写接收到的Request-URI的&amp;ldquo; abs_path&amp;rdquo;部分，除非如上所述，否则用&amp;ldquo; /&amp;rdquo;替换空的abs_path。注意：当原始服务器为保留的目的不正确地使用非保留的URI字符时，&amp;ldquo;不重写&amp;rdquo;规则可防止代理更改请求的含义。实现者应注意，已知一些HTTP / 1.1之前的代理可以重写Request-URI。</target>
        </trans-unit>
        <trans-unit id="27df10f6e52fad72f86af47082d4aed616c53e54" translate="yes" xml:space="preserve">
          <source>The Retry-After response-header field can be used with a 503 (Service
   Unavailable) response to indicate how long the service is expected to
   be unavailable to the requesting client. This field MAY also be used
   with any 3xx (Redirection) response to indicate the minimum time the
   user-agent is asked wait before issuing the redirected request. The
   value of this field can be either an HTTP-date or an integer number
   of seconds (in decimal) after the time of the response.

       Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )

   Two examples of its use are

       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">Retry-After 响应头字段可与 503(服务不可用)响应一起使用,以指示请求客户机预计将有多长时间的服务不可用。此字段也可与任何 3xx(重定向)响应一起使用,以指示用户代理在发出重定向请求之前被要求等待的最短时间。这个字段的值可以是HTTP-date,也可以是响应时间后的整数秒(十进制)。Retry-After=&quot;Retry-After&quot; &quot;:&quot;(HTTP-date | delta-seconds)其使用的两个例子是Retry-After。Fri,31 Dec 1999 23:59:59 GMT Retry-After:120 在后一个例子中,延迟是2分钟。</target>
        </trans-unit>
        <trans-unit id="f351e70802256078de6c82adb6c9f8135e4ad1a4" translate="yes" xml:space="preserve">
          <source>The Server response-header field contains information about the
   software used by the origin server to handle the request. The field
   can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;) and comments
   identifying the server and any significant subproducts. The product
   tokens are listed in order of their significance for identifying the
   application.

       Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If the response is being forwarded through a proxy, the proxy
   application MUST NOT modify the Server response-header. Instead, it
   SHOULD include a Via field (as described in &lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;).

      Note: Revealing the specific software version of the server might
      allow the server machine to become more vulnerable to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged to make this field a configurable
      option.</source>
          <target state="translated">服务器响应标头字段包含有关原始服务器用来处理请求的软件的信息。该字段可以包含多个产品令牌（&lt;a href=&quot;#section-3.8&quot;&gt;第3.8节&lt;/a&gt;）和标识服务器以及任何重要子产品的注释。产品令牌按其对识别应用程序的重要性顺序列出。服务器=&amp;ldquo;服务器&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1 *（产品|注释）示例：服务器：CERN / 3.0 libwww / 2.17如果响应是通过代理转发的，则代理应用程序一定不能修改服务器响应头。相反，它应该包含Via字段（如&lt;a href=&quot;#section-14.45&quot;&gt;第14.45节中&lt;/a&gt;所述））。注意：显示服务器的特定软件版本可能使服务器计算机更容易受到针对已知包含安全漏洞的软件的攻击。鼓励服务器实现者将此字段设置为可配置选项。</target>
        </trans-unit>
        <trans-unit id="87ed514ae2ccfa3b72514fa6a84c466f301be7c1" translate="yes" xml:space="preserve">
          <source>The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in &lt;a href=&quot;#section-10&quot;&gt;section 10&lt;/a&gt;. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase. 

   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

      - 1xx: Informational - Request received, continuing process

      - 2xx: Success - The action was successfully received,
        understood, and accepted

      - 3xx: Redirection - Further action must be taken in order to
        complete the request

      - 4xx: Client Error - The request contains bad syntax or cannot
        be fulfilled

      - 5xx: Server Error - The server failed to fulfill an apparently
        valid request

   The individual values of the numeric status codes defined for
   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only
   recommendations -- they MAY be replaced by local equivalents without
   affecting the protocol.

      Status-Code    =
            &quot;100&quot;  ; &lt;a href=&quot;#section-10.1.1&quot;&gt;Section 10.1.1&lt;/a&gt;: Continue
          | &quot;101&quot;  ; &lt;a href=&quot;#section-10.1.2&quot;&gt;Section 10.1.2&lt;/a&gt;: Switching Protocols
          | &quot;200&quot;  ; &lt;a href=&quot;#section-10.2.1&quot;&gt;Section 10.2.1&lt;/a&gt;: OK
          | &quot;201&quot;  ; &lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;: Created
          | &quot;202&quot;  ; &lt;a href=&quot;#section-10.2.3&quot;&gt;Section 10.2.3&lt;/a&gt;: Accepted
          | &quot;203&quot;  ; &lt;a href=&quot;#section-10.2.4&quot;&gt;Section 10.2.4&lt;/a&gt;: Non-Authoritative Information
          | &quot;204&quot;  ; &lt;a href=&quot;#section-10.2.5&quot;&gt;Section 10.2.5&lt;/a&gt;: No Content
          | &quot;205&quot;  ; &lt;a href=&quot;#section-10.2.6&quot;&gt;Section 10.2.6&lt;/a&gt;: Reset Content
          | &quot;206&quot;  ; &lt;a href=&quot;#section-10.2.7&quot;&gt;Section 10.2.7&lt;/a&gt;: Partial Content
          | &quot;300&quot;  ; &lt;a href=&quot;#section-10.3.1&quot;&gt;Section 10.3.1&lt;/a&gt;: Multiple Choices
          | &quot;301&quot;  ; &lt;a href=&quot;#section-10.3.2&quot;&gt;Section 10.3.2&lt;/a&gt;: Moved Permanently
          | &quot;302&quot;  ; &lt;a href=&quot;#section-10.3.3&quot;&gt;Section 10.3.3&lt;/a&gt;: Found
          | &quot;303&quot;  ; &lt;a href=&quot;#section-10.3.4&quot;&gt;Section 10.3.4&lt;/a&gt;: See Other
          | &quot;304&quot;  ; &lt;a href=&quot;#section-10.3.5&quot;&gt;Section 10.3.5&lt;/a&gt;: Not Modified
          | &quot;305&quot;  ; &lt;a href=&quot;#section-10.3.6&quot;&gt;Section 10.3.6&lt;/a&gt;: Use Proxy
          | &quot;307&quot;  ; &lt;a href=&quot;#section-10.3.8&quot;&gt;Section 10.3.8&lt;/a&gt;: Temporary Redirect
          | &quot;400&quot;  ; &lt;a href=&quot;#section-10.4.1&quot;&gt;Section 10.4.1&lt;/a&gt;: Bad Request
          | &quot;401&quot;  ; &lt;a href=&quot;#section-10.4.2&quot;&gt;Section 10.4.2&lt;/a&gt;: Unauthorized
          | &quot;402&quot;  ; &lt;a href=&quot;#section-10.4.3&quot;&gt;Section 10.4.3&lt;/a&gt;: Payment Required
          | &quot;403&quot;  ; &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;: Forbidden
          | &quot;404&quot;  ; &lt;a href=&quot;#section-10.4.5&quot;&gt;Section 10.4.5&lt;/a&gt;: Not Found
          | &quot;405&quot;  ; &lt;a href=&quot;#section-10.4.6&quot;&gt;Section 10.4.6&lt;/a&gt;: Method Not Allowed
          | &quot;406&quot;  ; &lt;a href=&quot;#section-10.4.7&quot;&gt;Section 10.4.7&lt;/a&gt;: Not Acceptable 

          | &quot;407&quot;  ; &lt;a href=&quot;#section-10.4.8&quot;&gt;Section 10.4.8&lt;/a&gt;: Proxy Authentication Required
          | &quot;408&quot;  ; &lt;a href=&quot;#section-10.4.9&quot;&gt;Section 10.4.9&lt;/a&gt;: Request Time-out
          | &quot;409&quot;  ; &lt;a href=&quot;#section-10.4.10&quot;&gt;Section 10.4.10&lt;/a&gt;: Conflict
          | &quot;410&quot;  ; &lt;a href=&quot;#section-10.4.11&quot;&gt;Section 10.4.11&lt;/a&gt;: Gone
          | &quot;411&quot;  ; &lt;a href=&quot;#section-10.4.12&quot;&gt;Section 10.4.12&lt;/a&gt;: Length Required
          | &quot;412&quot;  ; &lt;a href=&quot;#section-10.4.13&quot;&gt;Section 10.4.13&lt;/a&gt;: Precondition Failed
          | &quot;413&quot;  ; &lt;a href=&quot;#section-10.4.14&quot;&gt;Section 10.4.14&lt;/a&gt;: Request Entity Too Large
          | &quot;414&quot;  ; &lt;a href=&quot;#section-10.4.15&quot;&gt;Section 10.4.15&lt;/a&gt;: Request-URI Too Large
          | &quot;415&quot;  ; &lt;a href=&quot;#section-10.4.16&quot;&gt;Section 10.4.16&lt;/a&gt;: Unsupported Media Type
          | &quot;416&quot;  ; &lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;: Requested range not satisfiable
          | &quot;417&quot;  ; &lt;a href=&quot;#section-10.4.18&quot;&gt;Section 10.4.18&lt;/a&gt;: Expectation Failed
          | &quot;500&quot;  ; &lt;a href=&quot;#section-10.5.1&quot;&gt;Section 10.5.1&lt;/a&gt;: Internal Server Error
          | &quot;501&quot;  ; &lt;a href=&quot;#section-10.5.2&quot;&gt;Section 10.5.2&lt;/a&gt;: Not Implemented
          | &quot;502&quot;  ; &lt;a href=&quot;#section-10.5.3&quot;&gt;Section 10.5.3&lt;/a&gt;: Bad Gateway
          | &quot;503&quot;  ; &lt;a href=&quot;#section-10.5.4&quot;&gt;Section 10.5.4&lt;/a&gt;: Service Unavailable
          | &quot;504&quot;  ; &lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;: Gateway Time-out
          | &quot;505&quot;  ; &lt;a href=&quot;#section-10.5.6&quot;&gt;Section 10.5.6&lt;/a&gt;: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *&amp;lt;TEXT, excluding CR, LF&amp;gt;

   HTTP status codes are extensible. HTTP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.</source>
          <target state="translated">Status-Code元素是3位数的整数结果代码，用于尝试理解和满足请求。这些代码已在&lt;a href=&quot;#section-10&quot;&gt;第10节&lt;/a&gt;中完全定义。原因短语旨在简要说明状态代码。状态代码供自动机使用，原因短语供人类用户使用。不需要客户检查或显示原因短语。状态码的第一位数字定义响应的类别。后两位数字没有任何分类作用。第一位数字有5个值：-1xx：信息性-已接收到请求，继续处理-2xx：成功-已成功接收，理解并接受了该操作-3xx：重定向-必须采取进一步的操作才能完成请求-4xx：客户端错误-请求包含错误的语法或无法实现-5xx：服务器错误-服务器无法满足看似有效的请求。下面显示了为HTTP / 1.1定义的数字状态代码的各个值以及一组相应的原因短语示例。此处列出的原因短语仅是建议-在不影响协议的情况下，它们可以被本地等效项替换。状态码=&amp;ldquo; 100&amp;rdquo;；&lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1节&lt;/a&gt;：继续| &amp;ldquo; 101&amp;rdquo;；&lt;a href=&quot;#section-10.1.2&quot;&gt;第10.1.2节&lt;/a&gt;：交换协议| &amp;ldquo; 200&amp;rdquo;；&lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1节&lt;/a&gt;：确定| &amp;ldquo; 201&amp;rdquo;；&lt;a href=&quot;#section-10.2.2&quot;&gt;第10.2.2节&lt;/a&gt;：创建| &amp;ldquo; 202&amp;rdquo;；&lt;a href=&quot;#section-10.2.3&quot;&gt;第10.2.3节&lt;/a&gt;：已接受| &amp;ldquo; 203&amp;rdquo;；&lt;a href=&quot;#section-10.2.4&quot;&gt;第10.2.4节&lt;/a&gt;：非权威信息| &amp;ldquo; 204&amp;rdquo;; &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5节&lt;/a&gt;：无内容| &amp;ldquo; 205&amp;rdquo;；&lt;a href=&quot;#section-10.2.6&quot;&gt;第10.2.6节&lt;/a&gt;：重置内容| &amp;ldquo; 206&amp;rdquo;；&lt;a href=&quot;#section-10.2.7&quot;&gt;第10.2.7节&lt;/a&gt;：部分内容| &amp;ldquo; 300&amp;rdquo;；&lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1节&lt;/a&gt;：多项选择&amp;ldquo; 301&amp;rdquo;；&lt;a href=&quot;#section-10.3.2&quot;&gt;10.3节&lt;/a&gt;2 ：永久移动| &amp;ldquo; 302&amp;rdquo;；&lt;a href=&quot;#section-10.3.3&quot;&gt;第10.3.3节&lt;/a&gt;：找到| &amp;ldquo; 303&amp;rdquo;；&lt;a href=&quot;#section-10.3.4&quot;&gt;第10.3.4节&lt;/a&gt;：查看其他| &amp;ldquo; 304&amp;rdquo;; &lt;a href=&quot;#section-10.3.5&quot;&gt;第10.3.5节&lt;/a&gt;：未修改| &amp;ldquo; 305&amp;rdquo;；&lt;a href=&quot;#section-10.3.6&quot;&gt;第10.3.6节&lt;/a&gt;：使用代理| &amp;ldquo; 307&amp;rdquo;；&lt;a href=&quot;#section-10.3.8&quot;&gt;第10.3.8节&lt;/a&gt;：临时重定向| &amp;ldquo; 400&amp;rdquo;；&lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1节&lt;/a&gt;：错误的请求| &amp;ldquo; 401&amp;rdquo;；&lt;a href=&quot;#section-10.4.2&quot;&gt;第10.4.2节&lt;/a&gt;：未经授权| &amp;ldquo; 402&amp;rdquo;；&lt;a href=&quot;#section-10.4.3&quot;&gt;第10.4.3节&lt;/a&gt;：需要付款| &amp;ldquo; 403&amp;rdquo;；&lt;a href=&quot;#section-10.4.4&quot;&gt;第10.4.4节&lt;/a&gt;：禁止| &amp;ldquo; 404&amp;rdquo;；&lt;a href=&quot;#section-10.4.5&quot;&gt;第10.4.5节&lt;/a&gt;：找不到| &amp;ldquo; 405&amp;rdquo;；&lt;a href=&quot;#section-10.4.6&quot;&gt;第10.4.6节&lt;/a&gt;：不允许的方法&amp;ldquo; 406&amp;rdquo;； &lt;a href=&quot;#section-10.4.7&quot;&gt;第10.4.7节&lt;/a&gt;：不可接受| &amp;ldquo; 407&amp;rdquo;；&lt;a href=&quot;#section-10.4.8&quot;&gt;第10.4.8节&lt;/a&gt;：需要代理身份验证| &amp;ldquo; 408&amp;rdquo;；&lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9节&lt;/a&gt;：请求超时| &amp;ldquo; 409&amp;rdquo;；&lt;a href=&quot;#section-10.4.10&quot;&gt;第10.4.10节&lt;/a&gt;：冲突| &amp;ldquo; 410&amp;rdquo;；&lt;a href=&quot;#section-10.4.11&quot;&gt;第10.4.11节&lt;/a&gt;：消失| &amp;ldquo; 411&amp;rdquo;；&lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12节&lt;/a&gt;：所需长度| &amp;ldquo; 412&amp;rdquo;；&lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13节&lt;/a&gt;：前提条件失败| &amp;ldquo; 413&amp;rdquo;；&lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14节&lt;/a&gt;：请求实体太大| &amp;ldquo; 414&amp;rdquo;；&lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15节&lt;/a&gt;：请求URI太大| &amp;ldquo; 415&amp;rdquo;；&lt;a href=&quot;#section-10.4.16&quot;&gt;第10.4.16节&lt;/a&gt;：不支持的媒体类型| &amp;ldquo; 416&amp;rdquo;；&lt;a href=&quot;#section-10.4.17&quot;&gt;第10.4.17节&lt;/a&gt;：无法满足要求的范围| &amp;ldquo; 417&amp;rdquo;；&lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18节&lt;/a&gt;：期望失败| &amp;ldquo; 500&amp;rdquo;；&lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1节&lt;/a&gt;：内部服务器错误| &amp;ldquo; 501&amp;rdquo;；&lt;a href=&quot;#section-10.5.2&quot;&gt;第10.5.2节&lt;/a&gt;：未实施| &amp;ldquo; 502&amp;rdquo;；&lt;a href=&quot;#section-10.5.3&quot;&gt;第10.5.3节&lt;/a&gt;：错误的网关| &amp;ldquo; 503&amp;rdquo;；&lt;a href=&quot;#section-10.5.4&quot;&gt;第10.5.4节&lt;/a&gt;：服务不可用| &amp;ldquo; 504&amp;rdquo;；&lt;a href=&quot;#section-10.5.5&quot;&gt;第10.5.5节&lt;/a&gt;：网关超时| &amp;ldquo; 505&amp;rdquo;；&lt;a href=&quot;#section-10.5.6&quot;&gt;第10.5.6节&lt;/a&gt;：不支持HTTP版本| extension-code extension-code = 3DIGIT原因短语= * &amp;lt;TEXT，不包括CR，LF&amp;gt; HTTP状态代码是可扩展的。不需要HTTP应用程序理解所有已注册状态代码的含义，尽管显然希望这样。但是，应用程序务必如第一位数字所示理解任何状态码的类别，并将任何无法识别的响应视为等同于该类的x00状态码，但不可识别的响应必须被缓存。例如，如果客户端接收到无法识别的状态码431，则它可以安全地假定其请求有问题，并将响应视为已接收到400状态码。在这种情况下用户代理应该向用户呈现随响应一起返回的实体，因为该实体可能会包含人类可读的信息，这些信息将解释异常状态。</target>
        </trans-unit>
        <trans-unit id="a033c5a9ee721261b9ef910b0f68478ac7363993" translate="yes" xml:space="preserve">
          <source>The TCP handshake itself is time-consuming, but a TCP connection adapts to its load, becoming more efficient with more sustained (or warm) connections. Short-lived connections do not make use of this efficiency feature of TCP, and performance degrades from optimum by persisting to transmit over a new, cold connection.</source>
          <target state="translated">TCP握手本身是很耗时的,但TCP连接会适应它的负载,通过更多的持续(或热)连接变得更有效率。短暂的连接并没有利用TCP的这种效率特征,通过持续在新的冷连接上传输,性能会从最佳状态下降。</target>
        </trans-unit>
        <trans-unit id="a9a108e88ad08677b3a7b101ee6720f85b6d8f49" translate="yes" xml:space="preserve">
          <source>The TE request-header field indicates what extension transfer-codings
   it is willing to accept in the response and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding. Its
   value may consist of the keyword &quot;trailers&quot; and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

       TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
       t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.

   Examples of its use are:

       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5

   The TE header field only applies to the immediate connection.
   Therefore, the keyword MUST be supplied within a Connection header
   field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever TE is present in an HTTP/1.1 message.

   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:

      1. The &quot;chunked&quot; transfer-coding is always acceptable. If the
         keyword &quot;trailers&quot; is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.

         Note: HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.

      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;) 

      3. If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue
         of 1.

   If the TE field-value is empty or if no TE field is present, the only
   transfer-coding  is &quot;chunked&quot;. A message with no transfer-coding is
   always acceptable.</source>
          <target state="translated">TE request-header字段指示它愿意在响应中接受哪些扩展传输编码，以及是否愿意以分块传输编码的形式接受尾部字段。它的值可以包含关键字&amp;ldquo; trailers&amp;rdquo;和/或带有可选接受参数的扩展名传输编码名称的逗号分隔列表（如&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节中&lt;/a&gt;所述）。 TE =&amp;ldquo; TE&amp;rdquo;&amp;ldquo;：&amp;rdquo;＃（t-codings）t-codings =&amp;ldquo; trailers&amp;rdquo; | （transfer-extension [accept-params]）关键字&amp;ldquo; trailers&amp;rdquo;的存在指示客户端愿意接受分块传输编码中的尾部字段，如&lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1节中&lt;/a&gt;所定义。。即使此关键字本身并不表示传输编码，也保留将其与传输编码值一起使用。其用法示例如下：TE：deflate TE：TE：尾随，deflate; q = 0.5 TE头字段仅适用于直接连接。因此，必须在Connection标头字段中提供关键字（&lt;a href=&quot;#section-14.10&quot;&gt;第14.10节&lt;/a&gt;），只要HTTP / 1.1消息中包含TE。服务器使用以下规则根据TE字段测试传输编码是否可接受：1.&amp;ldquo;分块&amp;rdquo;传输编码始终是可接受的。如果列出了关键字&amp;ldquo; trailers&amp;rdquo;，则客户端表明它愿意代表自己和任何下游客户端在分块响应中接受尾部字段。暗示是，如果给出的话，客户端将说明所有下游客户端都愿意在转发的响应中接受尾部字段，或者它将尝试代表下游接收方缓冲响应。注意：HTTP / 1。图1中没有定义任何方法来限制分块响应的大小，从而可以确保客户端缓冲整个响应。 2.如果要测试的传输编码是TE字段中列出的传输编码之一，则可以接受，除非它带有q值0。&lt;a href=&quot;#section-3.9&quot;&gt;在第3.9节中&lt;/a&gt;，q值为0表示&amp;ldquo;不可接受&amp;rdquo;。）3.如果可以接受多个传输编码，则首选具有最高非零q值的可接受传输编码。 &amp;ldquo;块式&amp;rdquo;传输编码始终具有1的q值。如果TE字段值为空或不存在TE字段，则唯一的传输编码为&amp;ldquo;块式&amp;rdquo;。没有传输编码的消息总是可以接受的。</target>
        </trans-unit>
        <trans-unit id="028b36d5d9b3506526bee546184ec9c68b1e3650" translate="yes" xml:space="preserve">
          <source>The TRACE method is used to invoke a remote, application-layer loop-
   back of the request message. The final recipient of the request
   SHOULD reflect the message received back to the client as the
   entity-body of a 200 (OK) response. The final recipient is either the 

   origin server or the first proxy or gateway to receive a Max-Forwards
   value of zero (0) in the request (see &lt;a href=&quot;#section-14.31&quot;&gt;section 14.31&lt;/a&gt;). A TRACE request
   MUST NOT include an entity.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (&lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;) is of
   particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to limit the
   length of the request chain, which is useful for testing a chain of
   proxies forwarding messages in an infinite loop.

   If the request is valid, the response SHOULD contain the entire
   request message in the entity-body, with a Content-Type of
   &quot;message/http&quot;. Responses to this method MUST NOT be cached.</source>
          <target state="translated">TRACE方法用于调用请求消息的远程应用程序层回送。请求的最终接收者应该将收到的消息作为200（OK）响应的实体主体反映回客户端。最终的接收者是原始服务器或第一个代理或网关，以在请求中接收零（0）的最大转发值（请参阅&lt;a href=&quot;#section-14.31&quot;&gt;14.31节&lt;/a&gt;）。 TRACE请求不得包含实体。 TRACE允许客户端查看请求链另一端收到的内容，并将该数据用于测试或诊断信息。 Via标头字段的值（&lt;a href=&quot;#section-14.45&quot;&gt;第14.45节&lt;/a&gt;）特别有趣，因为它充当了请求链的痕迹。使用Max-Forwards标头字段允许客户端限制请求链的长度，这对于测试无限循环中转发消息的代理链很有用。如果请求有效，则响应应在实体正文中包含整个请求消息，其Content-Type为&amp;ldquo; message / http&amp;rdquo;。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="6e96e28d353c4ec4abe9e9bc4e5f7f7754ad5448" translate="yes" xml:space="preserve">
          <source>The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of &quot;message/http&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;Section&amp;nbsp;8.3.1 of [RFC7230]&lt;/a&gt;).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;). 

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] or cookies [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of
   [RFC7230]&lt;/a&gt;) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.</source>
          <target state="translated">TRACE方法请求对请求消息进行远程的应用程序级回送。请求的最终接收者应该将收到的消息（不包括下面描述的某些字段）反映回客户端，作为内容类型为&amp;ldquo; message / http&amp;rdquo;的200（OK）响应的消息主体（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;第8.3.1节） [RFC7230]&lt;/a&gt;）。最终的接收者是原始服务器，或者是第一个在请求中接收最大转发值为零（0）的服务器（&lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1.2节&lt;/a&gt;）。客户端不得在TRACE请求中生成标头字段，该标头字段包含响应可能会泄露的敏感数据。例如，用户代理发送存储的用户凭证[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]或cookie [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ] 是愚蠢的]在TRACE请求中。请求的最终接收者应排除该接收者生成响应正文时可能包含敏感数据的任何请求标头字段。 TRACE允许客户端查看请求链另一端收到的内容，并将该数据用于测试或诊断信息。 Via标头字段的值（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]的5.7.1节&lt;/a&gt;）特别受关注，因为它充当请求链的跟踪。使用Max-Forwards标头字段允许客户端限制请求链的长度，这对于测试无限循环中转发消息的代理链很有用。客户端不得在TRACE请求中发送消息正文。对TRACE方法的响应不可缓存。</target>
        </trans-unit>
        <trans-unit id="03897f64a14a74fe7d2358b82a3a5d08dc5e4c2f" translate="yes" xml:space="preserve">
          <source>The Trailer general field value indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.

       Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name

   An HTTP/1.1 message SHOULD include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.

   If no Trailer header field is present, the trailer SHOULD NOT include
   any header fields. See &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt; for restrictions on the use of
   trailer fields in a &quot;chunked&quot; transfer-coding.

   Message header fields listed in the Trailer header field MUST NOT
   include the following header fields:

      . Transfer-Encoding

      . Content-Length

      . Trailer</source>
          <target state="translated">Trailer常规字段值指示给定的报头字段集出现在以分块传输编码编码的消息的尾部中。 Trailer =&amp;ldquo; Trailer&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃field-name HTTP / 1.1消息应在消息中使用带非空尾部的分块传输编码，在消息中包含Trailer头字段。这样做可以使收件人知道预告片中应包含哪些标题字段。如果不存在Trailer标头字段，则预告片不应包含任何标头字段。有关在&amp;ldquo;块状&amp;rdquo;传输编码中使用尾部字段的限制，请参见&lt;a href=&quot;#section-3.6.1&quot;&gt;第3.6.1节&lt;/a&gt;。尾部标头字段中列出的消息标头字段不得包含以下标头字段：。传输编码。内容长度。预告片</target>
        </trans-unit>
        <trans-unit id="5a0c272967d0d482ca0381c6f18703875d017457" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding general-header field indicates what (if any)
   type of transformation has been applied to the message body in order
   to safely transfer it between the sender and the recipient. This
   differs from the content-coding in that the transfer-coding is a
   property of the message, not of the entity.

     Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding

   Transfer-codings are defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;. An example is:

     Transfer-Encoding: chunked 

   If multiple encodings have been applied to an entity, the transfer-
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.

   Many older HTTP/1.0 applications do not understand the Transfer-
   Encoding header.</source>
          <target state="translated">Transfer-Encoding的一般标头字段指示已将什么类型的转换（如果有）应用于邮件正文，以便在发送方和接收方之间安全地进行转换。这与内容编码不同，因为传输编码是消息的属性，而不是实体的属性。 Transfer-Encoding =&amp;ldquo; Transfer-Encoding&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃transfer-coding传输代码在&lt;a href=&quot;#section-3.6&quot;&gt;3.6节&lt;/a&gt;中定义。一个示例是：传输编码：分块如果对一个实体应用了多种编码，则必须按其应用顺序列出传输编码。关于编码参数的附加信息可以由本规范未定义的其他实体报头字段提供。许多较旧的HTTP / 1.0应用程序不了解Transfer-Encoding标头。</target>
        </trans-unit>
        <trans-unit id="2b9c17fcff0e77e15eb4e1a1d785371389cb348c" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been (or
   will be) applied to the payload body in order to form the message
   body.  Transfer codings are defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

     Transfer-Encoding = 1#transfer-coding

   Transfer-Encoding is analogous to the Content-Transfer-Encoding field
   of MIME, which was designed to enable safe transport of binary data
   over a 7-bit transport service (&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], Section&amp;nbsp;6&lt;/a&gt;).  However, safe
   transport has a different focus for an 8bit-clean transfer protocol.
   In HTTP's case, Transfer-Encoding is primarily intended to accurately
   delimit a dynamically generated payload and to distinguish payload
   encodings that are only applied for transport efficiency or security
   from those that are characteristics of the selected resource. 

   A recipient MUST be able to parse the chunked transfer coding
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.  A sender MUST
   NOT apply chunked more than once to a message body (i.e., chunking an
   already chunked message is not allowed).  If any transfer coding
   other than chunked is applied to a request payload body, the sender
   MUST apply chunked as the final transfer coding to ensure that the
   message is properly framed.  If any transfer coding other than
   chunked is applied to a response payload body, the sender MUST either
   apply chunked as the final transfer coding or terminate the message
   by closing the connection.

   For example,

     Transfer-Encoding: gzip, chunked

   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.

   Unlike Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;),
   Transfer-Encoding is a property of the message, not of the
   representation, and any recipient along the request/response chain
   MAY decode the received transfer coding(s) or apply additional
   transfer coding(s) to the message body, assuming that corresponding
   changes are made to the Transfer-Encoding field-value.  Additional
   information about the encoding parameters can be provided by other
   header fields not defined by this specification.

   Transfer-Encoding MAY be sent in a response to a HEAD request or in a
   304 (Not Modified) response (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt;) to a GET
   request, neither of which includes a message body, to indicate that
   the origin server would have applied a transfer coding to the message
   body if the request had been an unconditional GET.  This indication
   is not required, however, because any recipient on the response chain
   (including the origin server) can remove transfer codings when they
   are not needed.

   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed
   that implementations advertising only HTTP/1.0 support will not
   understand how to process a transfer-encoded payload.  A client MUST
   NOT send a request containing Transfer-Encoding unless it knows the 

   server will handle HTTP/1.1 (or later) requests; such knowledge might
   be in the form of specific user configuration or by remembering the
   version of a prior received response.  A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).

   A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).</source>
          <target state="translated">Transfer-Encoding标头字段列出了与已（或将要）应用于有效负载主体以形成消息主体的传输编码序列相对应的传输编码名称。传输编码在&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;中定义。 Transfer-Encoding = 1＃transfer-coding Transfer-Encoding与MIME的Content-Transfer-Encoding字段类似，该字段旨在支持通过7位传输服务安全地传输二进制数据（&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045]，第6节&lt;/a&gt;）。但是，安全传输对8bit-clean传输协议的关注点有所不同。在HTTP的情况下，Transfer-Encoding的主要目的是准确界定动态生成的有效负载，并将仅用于传输效率或安全性的有效负载编码与所选资源的特征区分开。接收者必须能够解析分块的传输编码（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;），因为它在事先不知道有效载荷主体大小的情况下在成帧消息中起着至关重要的作用。发送者不得对消息主体多次应用分块（即，不允许对已分块的消息进行分块）。如果将除块之外的任何传输编码应用于请求有效载荷主体，则发送方务必将块作为最终传输编码应用，以确保消息被正确地构架。如果将除分块之外的任何传输编码应用于响应有效载荷主体，则发送方务必将分块应用​​为最终传输编码，或者通过关闭连接来终止消息。例如，Transfer-Encoding：gzip，分块表示有效载荷主体已使用gzip编码进行了压缩，然后在形成消息主体时已使用分块编码进行了分块。与内容编码（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]的第3.1.2.1节&lt;/a&gt;，传输编码是消息的属性，而不是表示的属性，并且请求/响应链上的任何接收者都可以对接收到的传输编码进行解码或应用其他传输编码。 ），并假定对&amp;ldquo;传输编码&amp;rdquo;字段值进行了相应的更改。关于编码参数的其他信息可以由本规范未定义的其他标头字段提供。可以在对HEAD请求的响应中或在304（未修改）响应中发送Transfer-Encoding（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]第4.1节&lt;/a&gt;）发送给GET请求（该请求均不包含消息正文），以指示如果请求是无条件GET，则原始服务器将对消息正文应用传输编码。但是，此指示不是必需的，因为响应链上的任何收件人（包括原始服务器）都可以在不需要时删除传输编码。服务器不得在状态码为1xx（信息性）或204（无内容）的任何响应中发送传输编码标头字段。服务器不得在对CONNECT请求的任何2xx（成功）响应中发送传输编码标头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]的第4.3.6节）&lt;/a&gt;）。在HTTP / 1.1中添加了传输编码。通常假定仅宣传HTTP / 1.0支持的实现将不了解如何处理传输编码的有效负载。除非客户端知道服务器将处理HTTP / 1.1（或更高版本）请求，否则客户端不得发送包含传输编码的请求。这样的知识可以采用特定用户配置的形式，也可以通过记住先前收到的响应的版本来实现。除非相应的请求指示HTTP / 1.1（或更高版本），否则服务器不得发送包含传输编码的响应。接收到带有传输编码的请求消息的服务器，它不理解应该以501（未实现）响应。</target>
        </trans-unit>
        <trans-unit id="1c8b20b0d07b7680a3c0f95ac8ec3b25b3de332b" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.2</source>
          <target state="translated">传输层安全(TLS)协议1.2版。</target>
        </trans-unit>
        <trans-unit id="12fd383ebe402c54f473646772c58d3e6163c837" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.3</source>
          <target state="translated">传输层安全(TLS)协议1.3版。</target>
        </trans-unit>
        <trans-unit id="8a56da9b77b531c4fafce5d057fc066caa86cf4f" translate="yes" xml:space="preserve">
          <source>The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">火狐浏览器的UA字符串本身被分解成四个部分。</target>
        </trans-unit>
        <trans-unit id="f72374d140af175240e14a12a7f961729a13b2d2" translate="yes" xml:space="preserve">
          <source>The UNLOCK method removes the lock identified by the lock token in
   the Lock-Token request header.  The Request-URI MUST identify a
   resource within the scope of the lock.

   Note that use of the Lock-Token header to provide the lock token is
   not consistent with other state-changing methods, which all require
   an If header with the lock token.  Thus, the If header is not needed
   to provide the lock token.  Naturally, when the If header is present,
   it has its normal meaning as a conditional header.

   For a successful response to this method, the server MUST delete the
   lock entirely.

   If all resources that have been locked under the submitted lock token
   cannot be unlocked, then the UNLOCK request MUST fail.

   A successful response to an UNLOCK method does not mean that the
   resource is necessarily unlocked.  It means that the specific lock
   corresponding to the specified token no longer exists.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the UNLOCK method.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">UNLOCK方法删除由Lock-Token请求标头中的锁令牌标识的锁。请求URI必须标识锁范围内的资源。请注意，使用Lock-Token标头提供锁令牌与其他状态更改方法不一致，其他方法都需要带有锁令牌的If标头。因此，不需要If标头来提供锁定令牌。自然，当If标头存在时，它具有条件标头的正常含义。为了成功响应此方法，服务器必须完全删除该锁。如果所有在提交的锁定令牌下锁定的资源都无法解锁，则UNLOCK请求务必失败。对UNLOCK方法的成功响应并不意味着必须解锁资源。这意味着对应于指定令牌的特定锁不再存在。任何支持LOCK方法的兼容DAV的资源都必须支持UNLOCK方法。此方法是幂等的，但不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="7dc195e95f3f78e1ec1e89ef97a6a85b571c15d4" translate="yes" xml:space="preserve">
          <source>The URI of the document in which the violation occurred.</source>
          <target state="translated">发生违规行为的文件的URI。</target>
        </trans-unit>
        <trans-unit id="a00094afe4ee340f38859ca45715a9f8d4fda91e" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the &lt;code&gt;document-uri&lt;/code&gt;, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb66755626c081ee38ccbccf8e082e6464687a3" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the document-uri, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">被内容安全策略阻止加载的资源的URI。如果被阻止的URI与文档的URI来源不同,那么被阻止的URI将被截断,只包含方案、主机和端口。</target>
        </trans-unit>
        <trans-unit id="ab6860a88c4f5fa569a9d2df89c6b4183b5b6406" translate="yes" xml:space="preserve">
          <source>The URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">客户端请求的URI长于服务器愿意解释的长度。</target>
        </trans-unit>
        <trans-unit id="3c5fb5f7c661d221d889ac05db6f82fe9c0205e8" translate="yes" xml:space="preserve">
          <source>The URI where the user agent should report &lt;code&gt;Expect-CT&lt;/code&gt; failures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2631108f4b94ab9a2cb00980acaf8c1f780ff904" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;http://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;http://example.com/index.html&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/index.html&lt;/code&gt;)</source>
          <target state="translated">该URL &lt;code&gt;http://example.com/&lt;/code&gt; 将被重定向到 &lt;code&gt;http://www.example.com/&lt;/code&gt; ，如将其下的任何文件或目录（ &lt;code&gt;http://example.com/index.html&lt;/code&gt; 将被重定向到 &lt;code&gt;http://www.example.com/index.html&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5efef24fc6384dd41fb192a1bf80a33651bde15a" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;https://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;https://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;https://example.com/some-page&lt;/code&gt; will be redirected to &lt;code&gt;https://www.example.com/some-page&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab68e1cdf6b3b2fc5d165ae5d131fcb809d37323" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome (versions 52 to 73), you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in policy or by launching with the &lt;code&gt;--unsafe-pac-url&lt;/code&gt; command-line flag (in Chrome 74, only the flag works, and from 75 onward, there is no way to disable path-stripping; as of Chrome 81, path-stripping does not apply to HTTP URLs, but there is interest in changing this behavior to match HTTPS); in Firefox, the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328f9c5a6f56c9b38378bbbf4afce0ee4c1c87e1" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome, you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, in Firefox the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">被访问的URL。 &lt;code&gt;https://&lt;/code&gt; URL 的路径和查询组件已被剥离。在Chrome中，您可以通过将 &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 来禁用此功能，在Firefox中，首选项是 &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1aac5516d3c0193c8b37aa0f0d853eb420d0c8fa" translate="yes" xml:space="preserve">
          <source>The URL of the requested resource has been changed permanently. The new URL is given in the response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0186dd865b14f3a2fc2d2ec7512e14fe948697fc" translate="yes" xml:space="preserve">
          <source>The Upgrade general-header allows the client to specify what
   additional communication protocols it supports and would like to use
   if the server finds it appropriate to switch protocols. The server
   MUST use the Upgrade header field within a 101 (Switching Protocols)
   response to indicate which protocol(s) are being switched.

       Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product

   For example,

       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

   The Upgrade header field is intended to provide a simple mechanism
   for transition from HTTP/1.1 to some other, incompatible protocol. It
   does so by allowing the client to advertise its desire to use another
   protocol, such as a later version of HTTP with a higher major version
   number, even though the current request has been made using HTTP/1.1.
   This eases the difficult transition between incompatible protocols by
   allowing the client to initiate a request in the more commonly
   supported protocol while indicating to the server that it would like
   to use a &quot;better&quot; protocol if available (where &quot;better&quot; is determined
   by the server, possibly according to the nature of the method and/or
   resource being requested).

   The Upgrade header field only applies to switching application-layer
   protocols upon the existing transport-layer connection. Upgrade
   cannot be used to insist on a protocol change; its acceptance and use
   by the server is optional. The capabilities and nature of the
   application-layer communication after the protocol change is entirely
   dependent upon the new protocol chosen, although the first action
   after changing the protocol MUST be a response to the initial HTTP
   request containing the Upgrade header field.

   The Upgrade header field only applies to the immediate connection.
   Therefore, the upgrade keyword MUST be supplied within a Connection
   header field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever Upgrade is present in an
   HTTP/1.1 message. 

   The Upgrade header field cannot be used to indicate a switch to a
   protocol on a different connection. For that purpose, it is more
   appropriate to use a 301, 302, 303, or 305 redirection response.

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-3.1&quot;&gt;section 3.1&lt;/a&gt; and future updates to this
   specification. Any token can be used as a protocol name; however, it
   will only be useful if both the client and server associate the name
   with the same protocol.</source>
          <target state="translated">升级通用标头允许客户端指定其支持的其他通信协议，并在服务器认为适合切换协议时使用。服务器必须使用101（交换协议）响应中的Upgrade标头字段来指示正在交换的协议。 Upgrade =&amp;ldquo; Upgrade&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃product例如，Upgrade：HTTP / 2.0，SHTTP / 1.3，IRC / 6.9，RTA / x11 Upgrade标头字段旨在提供一种从HTTP / 1.1过渡到某些协议的简单机制其他不兼容的协议。通过这样做，即使当前请求是使用HTTP / 1.1发出的，也允许客户端宣告其使用其他协议的愿望，例如具有较高主版本号的HTTP的更高版本。通过允许客户端以更普遍支持的协议发起请求，同时向服务器指示它希望使用&amp;ldquo;更好&amp;rdquo;的协议（如果可用，&amp;ldquo;更好&amp;rdquo;由服务器确定），从而缓解了不兼容协议之间的困难过渡。 ，可能取决于所请求方法和/或资源的性质）。升级标头字段仅适用于在现有传输层连接上切换应用程序层协议。升级不能用于坚持更改协议。服务器接受和使用它是可选的。协议更改后，应用层通信的功能和性质完全取决于所选的新协议，尽管更改协议后的第一个动作必须是对包含&amp;ldquo;升级头&amp;rdquo;字段的初始HTTP请求的响应。升级标头字段仅适用于直接连接。因此，必须在Connection标头字段中提供升级关键字（&lt;a href=&quot;#section-14.10&quot;&gt;第14.10节&lt;/a&gt;），只要HTTP / 1.1消息中存在升级。升级标头字段不能用于指示在其他连接上切换到协议。为此，更适合使用301、302、303或305重定向响应。本规范仅定义协议名称&amp;ldquo; HTTP&amp;rdquo;，以供超文本传输​​协议系列使用，如&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;的HTTP版本规则和对该规范的将来更新所定义。任何令牌都可以用作协议名称；但是，只有在客户端和服务器都将名称与相同协议相关联的情况下，它才有用。</target>
        </trans-unit>
        <trans-unit id="956c514c873571fd13c43a02eba30c85c739c04b" translate="yes" xml:space="preserve">
          <source>The User-Agent (&lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;), Via (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of [RFC7230]&lt;/a&gt;), and
   Server (&lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;) header fields often reveal information about
   the respective sender's software systems.  In theory, this can make
   it easier for an attacker to exploit known security holes; in
   practice, attackers tend to try all potential holes regardless of the
   apparent software versions being used.

   Proxies that serve as a portal through a network firewall ought to
   take special precautions regarding the transfer of header information
   that might identify hosts behind the firewall.  The Via header field
   allows intermediaries to replace sensitive machine names with
   pseudonyms.</source>
          <target state="translated">用户代理（&lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节&lt;/a&gt;），&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;通行证&lt;/a&gt;（[RFC7230]的第5.7.1节）和服务器（&lt;a href=&quot;#section-7.4.2&quot;&gt;第7.4.2节&lt;/a&gt;）标头字段通常揭示有关各个发送者软件系统的信息。从理论上讲，这可以使攻击者更容易利用已知的安全漏洞。实际上，无论使用哪种明显的软件版本，攻击者都倾向于尝试所有潜在的漏洞。通过网络防火墙充当门户的代理应该特别注意头信息的传输，这些信息可能标识防火墙后面的主机。 Via标头字段使中介机构可以使用假名替换敏感的计算机名称。</target>
        </trans-unit>
        <trans-unit id="d9bc48b6946945b170102521a95dcc585d202997" translate="yes" xml:space="preserve">
          <source>The User-Agent header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ab671dc85571491b078190122b8c7014630aae" translate="yes" xml:space="preserve">
          <source>The User-Agent request-header field contains information about the
   user agent originating the request. This is for statistical purposes,
   the tracing of protocol violations, and automated recognition of user
   agents for the sake of tailoring responses to avoid particular user
   agent limitations. User agents SHOULD include this field with
   requests. The field can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;)
   and comments identifying the agent and any subproducts which form a
   significant part of the user agent. By convention, the product tokens
   are listed in order of their significance for identifying the
   application.

       User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )

   Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3</source>
          <target state="translated">User-Agent请求标头字段包含有关发起请求的用户代理的信息。这是出于统计目的，跟踪协议违规行为以及为了调整响应以避免特定用户代理限制而自动识别用户代理。用户代理应在请求中包含此字段。该字段可以包含多个产品令牌（&lt;a href=&quot;#section-3.8&quot;&gt;第3.8节&lt;/a&gt;）和标识代理以及构成用户代理重要组成部分的任何子产品的注释。按照惯例，产品令牌按其在识别应用程序中的重要性依次列出。 User-Agent =&amp;ldquo; User-Agent&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1 *（product | comment）示例：User-Agent：CERN-LineMode / 2.15 libwww / 2.17b3</target>
        </trans-unit>
        <trans-unit id="0145d328878d74d7d6f76ae8e632bd27f666b2da" translate="yes" xml:space="preserve">
          <source>The Vary field value indicates the set of request-header fields that
   fully determines, while the response is fresh, whether a cache is
   permitted to use the response to reply to a subsequent request
   without revalidation. For uncacheable or stale responses, the Vary
   field value advises the user agent about the criteria that were used
   to select the representation. A Vary field value of &quot;*&quot; implies that
   a cache cannot determine from the request headers of a subsequent
   request whether this response is the appropriate representation. See
   &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field by caches.

       Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )

   An HTTP/1.1 server SHOULD include a Vary header field with any
   cacheable response that is subject to server-driven negotiation.
   Doing so allows a cache to properly interpret future requests on that
   resource and informs the user agent about the presence of negotiation 

   on that resource. A server MAY include a Vary header field with a
   non-cacheable response that is subject to server-driven negotiation,
   since this might provide the user agent with useful information about
   the dimensions over which the response varies at the time of the
   response.

   A Vary field value consisting of a list of field-names signals that
   the representation selected for the response is based on a selection
   algorithm which considers ONLY the listed request-header field values
   in selecting the most appropriate representation. A cache MAY assume
   that the same selection will be made for future requests with the
   same values for the listed field names, for the duration of time for
   which the response is fresh.

   The field-names given are not limited to the set of standard
   request-header fields defined by this specification. Field names are
   case-insensitive.

   A Vary field value of &quot;*&quot; signals that unspecified parameters not
   limited to the request-headers (e.g., the network address of the
   client), play a role in the selection of the response representation.
   The &quot;*&quot; value MUST NOT be generated by a proxy server; it may only be
   generated by an origin server.</source>
          <target state="translated">Vary字段值指示一组请求标头字段，它们在响应是新鲜的同时完全确定是否允许缓存使用响应来响应后续请求而无需重新验证。对于不可缓存或过时的响应，Vary字段值会向用户代理建议用于选择表示形式的标准。 Vary字段值&amp;ldquo; *&amp;rdquo;表示高速缓存无法从后续请求的请求标头中确定此响应是否适当。见 &lt;a href=&quot;#section-13.6&quot;&gt;13.6节&lt;/a&gt;供缓存使用Vary标头字段。 Vary =&amp;ldquo; Vary&amp;rdquo;&amp;ldquo;：&amp;rdquo;（&amp;ldquo; *&amp;rdquo; | 1＃field-name）HTTP / 1.1服务器应该包含一个Vary标头字段，该标头字段具有任何可缓存的响应，并受服务器驱动的协商的约束。这样做可以使缓存适当地解释对该资源的将来请求，并通知用户代理有关该资源的协商的存在。服务器可以包括一个带有不可缓存响应的Vary标头字段，该字段必须经过服务器驱动的协商，因为这可能为用户代理提供有用的信息，这些信息涉及响应在响应时变化的维度。由字段名称列表组成的Vary字段值表示为响应选择的表示形式基于选择算法，该选择算法在选择最合适的表示形式时仅考虑列出的请求标头字段值。缓存可以假设在响应是新鲜的持续时间内，将为列出的字段名称具有相同值的将来请求进行相同的选择。给定的字段名称不限于此规范定义的一组标准请求标头字段。字段名称不区分大小写。 Vary字段值&amp;ldquo; *&amp;rdquo;表示不限于请求标头的未指定参数（例如，客户端的网络地址）在响应表示的选择中起作用。 &amp;ldquo;*&amp;ldquo;值一定不能由代理服务器生成；它只能由源服务器生成。</target>
        </trans-unit>
        <trans-unit id="c4eba333151816238416f3ddeba94021b6342f57" translate="yes" xml:space="preserve">
          <source>The Vary response header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46218eb322ca25f8d1c7432adb208448ace419bd" translate="yes" xml:space="preserve">
          <source>The Via general-header field MUST be used by gateways and proxies to
   indicate the intermediate protocols and recipients between the user
   agent and the server on requests, and between the origin server and
   the client on responses. It is analogous to the &quot;Received&quot; field of
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] and is intended to be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   all senders along the request/response chain.

      Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )
      received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
      protocol-name     = token
      protocol-version  = token
      received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym
      pseudonym         = token

   The received-protocol indicates the protocol version of the message
   received by the server or client along each segment of the
   request/response chain. The received-protocol version is appended to
   the Via field value when the message is forwarded so that information
   about the protocol capabilities of upstream applications remains
   visible to all recipients. 

   The protocol-name is optional if and only if it would be &quot;HTTP&quot;. The
   received-by field is normally the host and optional port number of a
   recipient server or client that subsequently forwarded the message.
   However, if the real host is considered to be sensitive information,
   it MAY be replaced by a pseudonym. If the port is not given, it MAY
   be assumed to be the default port of the received-protocol.

   Multiple Via field values represents each proxy or gateway that has
   forwarded the message. Each recipient MUST append its information
   such that the end result is ordered according to the sequence of
   forwarding applications.

   Comments MAY be used in the Via header field to identify the software
   of the recipient proxy or gateway, analogous to the User-Agent and
   Server header fields. However, all comments in the Via field are
   optional and MAY be removed by any recipient prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at nowhere.com, which completes
   the request by forwarding it to the origin server at www.ics.uci.edu.
   The request received by www.ics.uci.edu would then have the following
   Via header field:

       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

   Proxies and gateways used as a portal through a network firewall
   SHOULD NOT, by default, forward the names and ports of hosts within
   the firewall region. This information SHOULD only be propagated if
   explicitly enabled. If not enabled, the received-by host of any host
   behind the firewall SHOULD be replaced by an appropriate pseudonym
   for that host.

   For organizations that have strong privacy requirements for hiding
   internal structures, a proxy MAY combine an ordered subsequence of
   Via header field entries with identical received-protocol values into
   a single such entry. For example,

       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

        could be collapsed to

       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy 

   Applications SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. Applications MUST NOT combine entries which
   have different received-protocol values.</source>
          <target state="translated">网关和代理必须使用&amp;ldquo;通过通用标头&amp;rdquo;字段来指示请求时用户代理与服务器之间以及响应时源服务器与客户端之间的中间协议和接收者。它类似于&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;的&amp;ldquo; Received&amp;rdquo;字段。 ]，旨在用于跟踪消息转发，避免请求循环以及识别请求/响应链中所有发送者的协议功能。 Via =&amp;ldquo; Via&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃（接收协议[[注释]接收）接收协议= [协议名称&amp;ldquo; /&amp;rdquo;]协议版本协议名称=令牌协议版本=令牌接收= （host [&amp;ldquo;：&amp;rdquo; port]）| pseudonym pseudonym =令牌接收协议表示服务器或客户端沿着请求/响应链的每个段接收到的消息的协议版本。转发消息时，接收到的协议版本会附加到&amp;ldquo;通过&amp;rdquo;字段值中，以便有关上游应用程序的协议功能的信息对于所有接收者都保持可见。当且仅当它将是&amp;ldquo; HTTP&amp;rdquo;时，协议名称是可选的。收件人字段通常是随后转发邮件的收件人服务器或客户端的主机和可选端口号。但是，如果真实主机被认为是敏感信息，则可以用化名代替。如果未给出端口，则可以假定它是接收协议的默认端口。多个&amp;ldquo;通过&amp;rdquo;字段值表示已转发邮件的每个代理或网关。每个接收者必须附加其信息，以便根据转发应用程序的顺序对最终结果进行排序。可以在&amp;ldquo;通过&amp;rdquo;标头字段中使用注释来标识收件人代理或网关的软件，类似于&amp;ldquo; User-Agent&amp;rdquo;和&amp;ldquo; Server&amp;rdquo;标头字段。但是，&amp;ldquo;通过&amp;rdquo;字段中的所有注释都是可选的，在转发邮件之前，任何收件人都可以将其删除。例如，可以将请求消息从HTTP / 1.0用户代理发送到名为&amp;ldquo; fred&amp;rdquo;的内部代理，该代理使用HTTP / 1.1将请求转发到nowhere.com上的公共代理，该代理通过以下方式完成请求：将其转发到位于www.ics.uci.edu的原始服务器。 www.ics.uci.edu收到的请求将具有以下Via标头字段：Via：1.0 fred，1。1 nowhere.com（Apache / 1.1）通过网络防火墙用作门户的代理和网关，默认情况下，不应转发防火墙区域内主机的名称和端口。仅在明确启用的情况下，才应传播此信息。如果未启用，则防火墙后面的任何主机的接收主机都应以该主机的适当假名代替。对于对隐藏内部结构有强烈隐私要求的组织，代理可以将具有相同接收协议值的Via头字段条目的有序子序列组合到一个这样的条目中。例如，Via：1.0 ricky，1.1 ethel，1.1 fred，1.0 lucy可以折叠为Via：1.0 ricky，1.1 mertz，1。0 lucy应用程序不应该合并多个条目，除非它们都处于同一组织控制之下并且主机已被假名代替。应用程序不得组合具有不同接收协议值的条目。</target>
        </trans-unit>
        <trans-unit id="0176fdb6175026d4c263772f8859cf082f15cf8e" translate="yes" xml:space="preserve">
          <source>The WWW-Authenticate response-header field MUST be included in 401
   (Unauthorized) response messages. The field value consists of at
   least one challenge that indicates the authentication scheme(s) and
   parameters applicable to the Request-URI.

       WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. User
   agents are advised to take special care in parsing the WWW-
   Authenticate field value as it might contain more than one challenge,
   or if more than one WWW-Authenticate header field is provided, the
   contents of a challenge itself can contain a comma-separated list of
   authentication parameters.</source>
          <target state="translated">WWW-Authenticate响应头字段必须包含在401（未授权）响应消息中。该字段值包含至少一个挑战，该挑战指示适用于Request-URI的身份验证方案和参数。 WWW-Authenticate =&amp;ldquo; WWW-Authenticate&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃挑战&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]中描述了HTTP访问身份验证过程。建议用户代理在解析WWW-Authenticate字段值时要格外小心，因为它可能包含多个挑战，或者如果提供了多个WWW-Authenticate标头字段，则挑战本身的内容可以包含逗号分隔认证参数列表。</target>
        </trans-unit>
        <trans-unit id="7a35f374a20f06c6368a7744257833df18d21fb6" translate="yes" xml:space="preserve">
          <source>The Warning general-header field is used to carry additional
   information about the status or transformation of a message which
   might not be reflected in the message. This information is typically
   used to warn about a possible lack of semantic transparency from
   caching operations or transformations applied to the entity body of
   the message.

   Warning headers are sent with responses using:

       Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value

       warning-value = warn-code SP warn-agent SP warn-text
                                             [SP warn-date]

       warn-code  = 3DIGIT
       warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym
                       ; the name or pseudonym of the server adding
                       ; the Warning header, for use in debugging
       warn-text  = quoted-string
       warn-date  = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt;

   A response MAY carry more than one Warning header.

   The warn-text SHOULD be in a natural language and character set that
   is most likely to be intelligible to the human user receiving the
   response. This decision MAY be based on any available knowledge, such
   as the location of the cache or user, the Accept-Language field in a
   request, the Content-Language field in a response, etc. The default
   language is English and the default character set is ISO-8859-1.

   If a character set other than ISO-8859-1 is used, it MUST be encoded
   in the warn-text using the method described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

   Warning headers can in general be applied to any message, however
   some specific warn-codes are specific to caches and can only be
   applied to response messages. New Warning headers SHOULD be added
   after any existing Warning headers. A cache MUST NOT delete any
   Warning header that it received with a message. However, if a cache
   successfully validates a cache entry, it SHOULD remove any Warning
   headers previously attached to that entry except as specified for 

   specific Warning codes. It MUST then add any Warning headers received
   in the validating response. In other words, Warning headers are those
   that would be attached to the most recent relevant response.

   When multiple Warning headers are attached to a response, the user
   agent ought to inform the user of as many of them as possible, in the
   order that they appear in the response. If it is not possible to
   inform the user of all of the warnings, the user agent SHOULD follow
   these heuristics:

      - Warnings that appear early in the response take priority over
        those appearing later in the response.

      - Warnings in the user's preferred character set take priority
        over warnings in other character sets but with identical warn-
        codes and warn-agents.

   Systems that generate multiple Warning headers SHOULD order them with
   this user agent behavior in mind.

   Requirements for the behavior of caches with respect to Warnings are
   stated in &lt;a href=&quot;#section-13.1.2&quot;&gt;section 13.1.2&lt;/a&gt;.

   This is a list of the currently-defined warn-codes, each with a
   recommended warn-text in English, and a description of its meaning.

   110 Response is stale
     MUST be included whenever the returned response is stale.

   111 Revalidation failed
     MUST be included if a cache returns a stale response because an
     attempt to revalidate the response failed, due to an inability to
     reach the server.

   112 Disconnected operation
     SHOULD be included if the cache is intentionally disconnected from
     the rest of the network for a period of time.

   113 Heuristic expiration
     MUST be included if the cache heuristically chose a freshness
     lifetime greater than 24 hours and the response's age is greater
     than 24 hours.

   199 Miscellaneous warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action, besides presenting the warning to
     the user. 

   214 Transformation applied
     MUST be added by an intermediate cache or proxy if it applies any
     transformation changing the content-coding (as specified in the
     Content-Encoding header) or media-type (as specified in the
     Content-Type header) of the response, or the entity-body of the
     response, unless this Warning code already appears in the response.

   299 Miscellaneous persistent warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action.

   If an implementation sends a message with one or more Warning headers
   whose version is HTTP/1.0 or lower, then the sender MUST include in
   each warning-value a warn-date that matches the date in the response.

   If an implementation receives a message with a warning-value that
   includes a warn-date, and that warn-date is different from the Date
   value in the response, then that warning-value MUST be deleted from
   the message before storing, forwarding, or using it. (This prevents
   bad consequences of naive caching of Warning header fields.) If all
   of the warning-values are deleted for this reason, the Warning header
   MUST be deleted as well.</source>
          <target state="translated">警告通用标头字段用于携带有关消息状态或转换的其他信息，这些信息可能未反映在消息中。此信息通常用于警告由于应用于消息实体的缓存操作或转换而导致的语义透明性可能不足。使用以下方式发送警告标头和响应：警告=&amp;ldquo;警告&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃warning-value warning-value =警告代码SP警告代理SP警告文本[SP警告日期]警告代码= 3DIGIT警告代理=（host [&amp;ldquo;：&amp;rdquo; port]）|笔名;服务器添加的名称或别名;警告标头，用于调试中的警告消息warn-text = quoted-string warn-date = &amp;lt;&amp;gt; HTTP-date &amp;lt;&amp;ldquo;&amp;gt;响应可以携带多个警告标头。警告文本应采用自然语言和字符集，以使接收响应的人类用户最容易理解。该决定可以基于任何可用的知识，例如缓存或用户的位置，请求中的Accept-Language字段，响应中的Content-Language字段等。默认语言为英语，默认字符集是ISO-8859-1。如果使用了ISO-8859-1以外的字符集，则必须使用以下描述的方法在警告文本中进行编码：警告文本应采用自然语言和字符集，以使接收响应的人类用户最容易理解。该决定可以基于任何可用的知识，例如缓存或用户的位置，请求中的Accept-Language字段，响应中的Content-Language字段等。默认语言为英语，默认字符集是ISO-8859-1。如果使用了ISO-8859-1以外的字符集，则必须使用以下描述的方法在警告文本中进行编码：警告文本应采用自然语言和字符集，以使接收响应的人类用户最容易理解。该决定可以基于任何可用的知识，例如缓存或用户的位置，请求中的Accept-Language字段，响应中的Content-Language字段等。默认语言为英语，默认字符集是ISO-8859-1。如果使用了ISO-8859-1以外的字符集，则必须使用以下描述的方法在警告文本中进行编码：响应等中的&amp;ldquo;内容语言&amp;rdquo;字段。默认语言是英语，默认字符集是ISO-8859-1。如果使用了ISO-8859-1以外的字符集，则必须使用以下描述的方法在警告文本中进行编码：响应等中的&amp;ldquo;内容语言&amp;rdquo;字段。默认语言是英语，默认字符集是ISO-8859-1。如果使用了ISO-8859-1以外的字符集，则必须使用以下描述的方法在警告文本中进行编码：&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]。警告头通常可以应用于任何消息，但是某些特定的警告代码特定于缓存，并且只能应用于响应消息。应该在任何现有的警告标头之后添加新的警告标头。高速缓存绝不能删除随消息一起收到的任何警告标头。但是，如果一个缓存成功地验证了一个缓存条目，它应该删除先前附加到该条目的所有Warning标头，除非为特定的Warning代码指定。然后，它必须添加在验证响应中收到的所有警告标头。换句话说，警告标头是那些将附加到最新相关响应的标头。当多个警告标头附加到响应时，用户代理应将尽可能多的警告标头告知用户，按照它们在响应中出现的顺序。如果不可能将所有警告都通知用户，则用户代理应遵循以下启发式：-响应初期出现的警告优先于响应后期出现的警告。 -用户首选字符集中的警告优先于其他字符集中的警告，但具有相同的警告代码和警告代理。产生多个警告标头的系统应按照用户代理的行为对其进行排序。关于警告的高速缓存行为的要求在-在响应中较早出现的警告优先于在响应中较晚出现的警告。 -用户首选字符集中的警告优先于其他字符集中的警告，但具有相同的警告代码和警告代理。产生多个警告标头的系统应按照用户代理的行为对其进行排序。关于警告的高速缓存行为的要求在-在响应中较早出现的警告优先于在响应中较晚出现的警告。 -用户首选字符集中的警告优先于其他字符集中的警告，但具有相同的警告代码和警告代理。产生多个警告标头的系统应按照用户代理的行为对其进行排序。关于警告的高速缓存行为的要求在关于警告的高速缓存行为的要求在关于警告的高速缓存行为的要求在&lt;a href=&quot;#section-13.1.2&quot;&gt;第13.1.2节&lt;/a&gt;。这是当前定义的警告代码的列表，每个警告代码均带有建议的英文警告文本以及其含义的描述。 110无论何时返回的响应是陈旧的，都必须包括响应是陈旧的。 111如果由于由于无法访问服务器而导致重新验证响应的尝试失败而导致缓存返回陈旧的响应，则必须包括重新验证失败。 112如果断开了缓存一段时间与网络其余部分的连接，则应该包括断开连接的操作。如果试探性地选择新鲜度寿命大于24小时且响应的时间大于24小时，则必须包括113个试探性到期。199其他警告警告文本可以包含要呈现给人类用户或记录的任意信息。收到此警告的系统除了向用户显示警告外，不得采取任何自动措施。 214如果转换应用了更改响应的内容编码（如Content-Encoding标头中所指定）或媒体类型（如Content-Type标头中所指定），则必须由中间缓存或代理添加所应用的转换，或响应的实体-主体，除非此警告代码已出现在响应中。 299其他持续警告警告文本可以包含要呈现给人类用户或记录的任意信息。收到此警告的系统不得执行任何自动操作。如果实现发送的消息带有一个或多个HTTP / 1.0或更低版本的Warning标头，则发送方务必在每个警告值中包含与响应中的日期匹配的警告日期。如果实现收到一条警告值包含警告日期的消息，并且警告日期与响应中的日期值不同，则必须在存储，转发或删除消息之前从消息中删除该警告值。使用它。 （这防止了警告标头字段的幼稚缓存的不良后果。）如果由于这个原因删除了所有警告值，则还必须删除警告标头。那么发送者必须在每个警告值中包含一个与响应中的日期相匹配的警告日期。如果实现收到一条警告值包含警告日期的消息，并且警告日期与响应中的日期值不同，则必须在存储，转发或删除消息之前从消息中删除该警告值。使用它。 （这防止了警告标头字段的幼稚缓存的不良后果。）如果由于这个原因删除了所有警告值，则还必须删除警告标头。那么发送者必须在每个警告值中包含一个与响应中的日期相匹配的警告日期。如果实现收到一条警告值包含警告日期的消息，并且警告日期与响应中的日期值不同，则必须在存储，转发或删除消息之前从消息中删除该警告值。使用它。 （这防止了警告标头字段的幼稚缓存的不良后果。）如果由于这个原因删除了所有警告值，则还必须删除警告标头。（这防止了警告标头字段的幼稚缓存的不良后果。）如果由于这个原因删除了所有警告值，则还必须删除警告标头。（这防止了警告标头字段的幼稚缓存的不良后果。）如果由于这个原因删除了所有警告值，则还必须删除警告标头。</target>
        </trans-unit>
        <trans-unit id="650ee0647a2c1fdd4db296e88e9d7457a6d4e9da" translate="yes" xml:space="preserve">
          <source>The Web APIs have native methods to encode or decode to base64: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64 encoding and decoding&lt;/a&gt;.</source>
          <target state="translated">Web API具有编码或解码为base64的本机方法：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64编码和解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56faf444060ee49993107fee26b7ba0d66f5e281" translate="yes" xml:space="preserve">
          <source>The Web Origin Concept</source>
          <target state="translated">网络起源的概念</target>
        </trans-unit>
        <trans-unit id="215d6bd38f0870c1defdd62eb60f6f1375d1790f" translate="yes" xml:space="preserve">
          <source>The Web Runtime uses the same user agent string as desktop Firefox.</source>
          <target state="translated">Web Runtime使用与桌面Firefox相同的用户代理字符串。</target>
        </trans-unit>
        <trans-unit id="941232b2ff4433cb0bd6270438632894b53fb59c" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links.</source>
          <target state="translated">网页由于没有不可预见的原因,暂时无法使用。这样,搜索引擎就不会更新链接了。</target>
        </trans-unit>
        <trans-unit id="55fa8ca3dd54f0ec3aab1401af4719063aeb4a24" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links. Better than &lt;code&gt;302&lt;/code&gt; when non-GET links/operations are available on the site.</source>
          <target state="translated">由于尚未预见的原因，该网页暂时不可用。这样，搜索引擎不会更新其链接。当站点上没有非GET链接/操作可用时，比 &lt;code&gt;302&lt;/code&gt; 更好。</target>
        </trans-unit>
        <trans-unit id="d6e1f00a886091957899f1d426a1a907509a4636" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily unavailable for unforeseen reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83272b4a920a61a8fef1340e4de8c385bd7ee81" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily unavailable for unforeseen reasons. Better than &lt;code&gt;302&lt;/code&gt; when non-&lt;code&gt;GET&lt;/code&gt; operations are available on the site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5e46a03efafad9853b734ee0d593694b072117" translate="yes" xml:space="preserve">
          <source>The Web server</source>
          <target state="translated">网络服务器</target>
        </trans-unit>
        <trans-unit id="95924074d7e37faf6b144a7b43119f38c76fd2f0" translate="yes" xml:space="preserve">
          <source>The WebSocket Protocol</source>
          <target state="translated">WebSocket协议</target>
        </trans-unit>
        <trans-unit id="09ee06d1ee05107c094545645447a824d3d94f1b" translate="yes" xml:space="preserve">
          <source>The WebSocket protocol version the client wishes to use when communicating with the server. This number should be the most recent version possible listed in the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket Version Number Registry&lt;/a&gt;. The most recent final version of the WebSocket protocol is version 13.</source>
          <target state="translated">客户端与服务器通信时希望使用的WebSocket协议版本。该编号应该是&lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket版本号注册表中&lt;/a&gt;列出的最新版本。WebSocket协议的最新最终版本是版本13。</target>
        </trans-unit>
        <trans-unit id="e242f211ed018b0f56d726778881102bd4b4068c" translate="yes" xml:space="preserve">
          <source>The XML namespace extension ([&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]) is used in this
   specification in order to allow for new XML elements to be added
   without fear of colliding with other element names.  Although WebDAV
   request and response bodies can be extended by arbitrary XML
   elements, which can be ignored by the message recipient, an XML
   element in the &quot;DAV:&quot; namespace SHOULD NOT be used in the request or
   response body unless that XML element is explicitly defined in an
   IETF RFC reviewed by a WebDAV working group.

   For WebDAV to be both extensible and backwards-compatible, both
   clients and servers need to know how to behave when unexpected or
   unrecognized command extensions are received.  For XML processing,
   this means that clients and servers MUST process received XML
   documents as if unexpected elements and attributes (and all children
   of unrecognized elements) were not there.  An unexpected element or
   attribute includes one that may be used in another context but is not
   expected here.  Ignoring such items for purposes of processing can of
   course be consistent with logging all information or presenting for
   debugging.

   This restriction also applies to the processing, by clients, of DAV
   property values where unexpected XML elements SHOULD be ignored
   unless the property's schema declares otherwise.

   This restriction does not apply to setting dead DAV properties on the
   server where the server MUST record all XML elements. 

   Additionally, this restriction does not apply to the use of XML where
   XML happens to be the content type of the entity body, for example,
   when used as the body of a PUT.

   Processing instructions in XML SHOULD be ignored by recipients.
   Thus, specifications extending WebDAV SHOULD NOT use processing
   instructions to define normative behavior.

   XML DTD fragments are included for all the XML elements defined in
   this specification.  However, correct XML will not be valid according
   to any DTD due to namespace usage and extension rules.  In
   particular:

   o  Elements (from this specification) are in the &quot;DAV:&quot; namespace,

   o  Element ordering is irrelevant unless otherwise stated,

   o  Extension attributes MAY be added,

   o  For element type definitions of &quot;ANY&quot;, the normative text
      definition for that element defines what can be in it and what
      that means.

   o  For element type definitions of &quot;#PCDATA&quot;, extension elements MUST
      NOT be added.

   o  For other element type definitions, including &quot;EMPTY&quot;, extension
      elements MAY be added.

   Note that this means that elements containing elements cannot be
   extended to contain text, and vice versa.

   With DTD validation relaxed by the rules above, the constraints
   described by the DTD fragments are normative (see for example
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).  A recipient of a WebDAV message with an XML body MUST
   NOT validate the XML document according to any hard-coded or
   dynamically-declared DTD.

   Note that this section describes backwards-compatible extensibility
   rules.  There might also be times when an extension is designed not
   to be backwards-compatible, for example, defining an extension that
   reuses an XML element defined in this document but omitting one of
   the child elements required by the DTDs in this specification.</source>
          <target state="translated">XML名称空间扩展名（[ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;在此规范中使用]）是为了允许添加新的XML元素而不必担心与其他元素名称冲突。尽管WebDAV请求和响应主体可以由任意XML元素扩展，而消息接收者可以忽略它们，但是除非明确定义XML元素，否则&amp;ldquo; DAV：&amp;rdquo;命名空间中的XML元素不应在请求或响应主体中使用。由WebDAV工作组审查的IETF RFC中。为了使WebDAV既可扩展又可向后兼容，客户端和服务器都需要知道在收到意外或无法识别的命令扩展时的行为。对于XML处理，这意味着客户端和服务器必须处理接收到的XML文档，就像不存在意外的元素和属性（以及所有无法识别的元素的子元素）一样。意外的元素或属性包括可以在其他上下文中使用的元素或属性，但此处不期望使用。当然，出于处理目的而忽略此类项目可以与记录所有信息或提供调试信息相一致。此限制也适用于客户端对DAV属性值的处理，除非属性的模式另行声明，否则应忽略意外的XML元素。此限制不适用于在服务器必须记录所有XML元素的服务器上设置无效DAV属性。另外，如果XML恰好是实体主体的内容类型，例如当用作PUT主体时，此限制不适用于XML。接收者应忽略XML中的处理指令。因此，扩展WebDAV的规范不应使用处理指令来定义规范行为。本规范中定义的所有XML元素均包含XML DTD片段。但是，由于名称空间的使用和扩展规则，正确的XML根据任何DTD都是无效的。特别是：o元素（根据本规范）位于&amp;ldquo; DAV：&amp;rdquo;命名空间中，o除非另有说明，否则元素顺序无关紧要，o可以添加扩展属性，o对于&amp;ldquo; ANY&amp;rdquo;的元素类型定义，该元素的规范文本定义定义了其中的含义以及含义。 o对于&amp;ldquo; #PCDATA&amp;rdquo;的元素类型定义，不得添加扩展元素。 o对于其他元素类型定义，包括&amp;ldquo; EMPTY&amp;rdquo;，可以添加扩展元素。请注意，这意味着包含元素的元素不能扩展为包含文本，反之亦然。通过以上规则放宽了DTD验证，DTD片段描述的约束是规范性的（例如，请参见请注意，这意味着包含元素的元素不能扩展为包含文本，反之亦然。通过以上规则放宽了DTD验证，DTD片段描述的约束是规范性的（例如，请参见请注意，这意味着包含元素的元素不能扩展为包含文本，反之亦然。通过以上规则放宽了DTD验证，DTD片段描述的约束是规范性的（例如，请参见 &lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;）。带有XML主体的WebDAV消息的接收者不得根据任何硬编码或动态声明的DTD验证XML文档。请注意，本节描述了向后兼容的扩展性规则。有时也可能将扩展设计为不向后兼容，例如，定义扩展以重用本文档中定义的XML元素，而忽略本规范中DTD所需的子元素之一。</target>
        </trans-unit>
        <trans-unit id="5abb61434aba6cac3c3255f0777b6e4ab04de6f1" translate="yes" xml:space="preserve">
          <source>The abbreviation for each format links to a longer description of the format, its capabilities, and detailed browser compatibility information; including which versions introduced support and specific special features that may have been introduced later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b298dd5e10b677f7b1f3b1962b7f374d92022229" translate="yes" xml:space="preserve">
          <source>The ability to lock a resource provides a mechanism for serializing
   access to that resource.  Using a lock, an authoring client can
   provide a reasonable guarantee that another principal will not modify
   a resource while it is being edited.  In this way, a client can
   prevent the &quot;lost update&quot; problem.

   This specification allows locks to vary over two client-specified
   parameters, the number of principals involved (exclusive vs. shared)
   and the type of access to be granted.  This document defines locking
   for only one access type, write.  However, the syntax is extensible,
   and permits the eventual specification of locking for other access
   types.</source>
          <target state="translated">锁定资源的能力提供了对该资源进行序列化访问的机制。使用锁,编写客户端可以提供合理的保证,即当资源被编辑时,另一个委托人不会修改该资源。通过这种方式,客户端可以防止 &quot;丢失更新 &quot;的问题。本规范允许锁在两个客户端指定的参数上变化,即涉及的委托人数量(独占与共享)和授予的访问类型。本文档只定义了一种访问类型的锁,即写。然而,该语法是可扩展的,并允许最终对其他访问类型的锁定进行规范。</target>
        </trans-unit>
        <trans-unit id="3b06c2527b7380abe2e2e286d29197b000c1f987" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements</source>
          <target state="translated">上述内容安全政策将允许内联&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素</target>
        </trans-unit>
        <trans-unit id="38b5b1c5b09838d3f34e6ad848719f979f8adbe4" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline styles like the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and the &lt;code&gt;style&lt;/code&gt; attribute on any element:</source>
          <target state="translated">上面的内容安全策略将允许内联样式，例如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;元素，以及任何元素上的 &lt;code&gt;style&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="fccee75b555f59c4fe0c1b6040c213d2c31d26f2" translate="yes" xml:space="preserve">
          <source>The above checks to see if the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header sent by the browser (obtained through $_SERVER['HTTP_ORIGIN']) matches '&lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;'. If yes, it returns &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">上面的代码检查浏览器发送的&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;标头（通过$ _SERVER ['HTTP_ORIGIN']获得）是否与' &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt; ' 相匹配。如果是，则返回&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; : //arunranga.com。这个例子可以在&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;这里看到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ded9ed730bf997dd582fce073e6812fd63d3ebf3" translate="yes" xml:space="preserve">
          <source>The above code would have made several incorrect assumptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced1ab96d2e07e89bba3cc71ef4220a4d87bd67e" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts &lt;code&gt;www.mozilla.org&lt;/code&gt; and &lt;code&gt;merchant.mozilla.org&lt;/code&gt; will go through the proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde7701a5c7f870f1548d1541023a9c35cec39e4" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts www.mozilla.org and merchant.mozilla.org will go through the proxy.</source>
          <target state="translated">上面的例子中,除了mozilla.org域中的本地主机外,其他所有主机都将使用代理,但www.mozilla.org和merchant.mozilla.org主机将通过代理。</target>
        </trans-unit>
        <trans-unit id="7aeeb6c5396c82b22fb67dae5cbdfb5d930395d8" translate="yes" xml:space="preserve">
          <source>The above permissions may be cached for 86,400 seconds (1 day).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517f24a05885574e21ddf60556499b7755bb7037" translate="yes" xml:space="preserve">
          <source>The above requires consulting the DNS every time; it can be grouped intelligently with other rules so that DNS is consulted only if other rules do not yield a result:</source>
          <target state="translated">以上每次都需要咨询DNS,可以和其他规则智能分组,只有在其他规则没有结果的情况下才会咨询DNS。</target>
        </trans-unit>
        <trans-unit id="5a1d7213c66cb3708576c9dee4e5fbc7b85eeee8" translate="yes" xml:space="preserve">
          <source>The added security is only provided if the user accessing the document is using a browser supporting &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">仅当访问文档的用户使用支持 &lt;code&gt;X-Frame-Options&lt;/code&gt; 的浏览器时，才提供增强的安全性。</target>
        </trans-unit>
        <trans-unit id="442c6996e10d8c8b2aa1a7ff243ac87908709eb2" translate="yes" xml:space="preserve">
          <source>The added security is provided only if the user accessing the document is using a browser that supports &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4cf5be0bdff2d41464e3aec79f3206f5e9a290" translate="yes" xml:space="preserve">
          <source>The address of the previous web page from which a link to the currently requested page was followed.</source>
          <target state="translated">前一个网页的地址,从该网页链接到当前请求的网页。</target>
        </trans-unit>
        <trans-unit id="b7f363462ba0e835d6efe5f6a4a754557a175395" translate="yes" xml:space="preserve">
          <source>The allow list is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13999e890799ba528c66f4b10225cdce017aa2" translate="yes" xml:space="preserve">
          <source>The allowlist is a list of origins that takes one of the following values:</source>
          <target state="translated">allowlist是一个起源列表,它的值为以下之一。</target>
        </trans-unit>
        <trans-unit id="393e3579b1c31fc17a2e5e0bd2a662711c3a5e42" translate="yes" xml:space="preserve">
          <source>The alternative and de-facto standard versions of this header are the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;x-forwarded-host&quot;&gt;&lt;code&gt;X-Forwarded-Host&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;x-forwarded-proto&quot;&gt;&lt;code&gt;X-Forwarded-Proto&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">此标头的替代和事实上的标准版本是&lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;x-forwarded-host&quot;&gt; &lt;code&gt;X-Forwarded-Host&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;x-forwarded-proto&quot;&gt; &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="55a9a290f76d786d7b3d83d441f76e13bf0f3dcc" translate="yes" xml:space="preserve">
          <source>The app:categories element can contain a &quot;fixed&quot; attribute, with a
   value of either &quot;yes&quot; or &quot;no&quot;, indicating whether the list of
   categories is a fixed or an open set.  The absence of the &quot;fixed&quot;
   attribute is equivalent to the presence of a &quot;fixed&quot; attribute with a
   value of &quot;no&quot;.

   Alternatively, the app:categories element MAY contain an &quot;href&quot;
   attribute, whose value MUST be an IRI reference identifying a
   Category Document.  If the &quot;href&quot; attribute is provided, the app:
   categories element MUST be empty and MUST NOT have the &quot;fixed&quot; or
   &quot;scheme&quot; attributes.</source>
          <target state="translated">app:category元素可以包含一个 &quot;fixed &quot;属性,其值为 &quot;yes &quot;或 &quot;no&quot;,表示类别列表是一个固定的还是开放的集合。没有 &quot;fixed &quot;属性就相当于有一个值为 &quot;no &quot;的 &quot;fixed &quot;属性。另外,app:categories 元素可以包含一个 &quot;href &quot;属性,它的值必须是标识一个 Category Document 的 IRI 引用。如果提供了 &quot;href &quot;属性,app:categories 元素必须是空的,而且必须没有 &quot;fixed &quot;或 &quot;scheme &quot;属性。</target>
        </trans-unit>
        <trans-unit id="41b7617765ea8bb8c7b2ba0dc382b82fa950ce4a" translate="yes" xml:space="preserve">
          <source>The app:collection element MAY appear as a child of an atom:feed or
   atom:source element in an Atom Feed Document.  Its content identifies
   a Collection by which new Entries can be added to appear in the feed.
   When it appears in an atom:feed or atom:source element, the app:
   collection element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">app：collection元素可以作为Atom Feed文档中atom：feed或atom：source元素的子元素出现。它的内容标识一个集合，通过该集合可以添加新条目以出现在提要中。当app：集合元素出现在atom：feed或atom：source元素中时，被视为&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;第&lt;/a&gt;6 节中定义的外部标记。</target>
        </trans-unit>
        <trans-unit id="784a9192f7175993193ec2889d2de31d1902f984" translate="yes" xml:space="preserve">
          <source>The app:collection element MUST contain an &quot;href&quot; attribute, whose
   value gives the IRI of the Collection.</source>
          <target state="translated">app:collection元素必须包含一个 &quot;href &quot;属性,其值给出Collection的IRI。</target>
        </trans-unit>
        <trans-unit id="7a08eb3336f8f673ed58387417f07a2fa35ffa86" translate="yes" xml:space="preserve">
          <source>The app:workspace element MUST contain one &quot;atom:title&quot; element (as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), giving a human-readable title for the
   Workspace.</source>
          <target state="translated">app：workspace元素必须包含一个&amp;ldquo; atom：title&amp;rdquo;元素（在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]中定义），为工作区提供易于理解的标题。</target>
        </trans-unit>
        <trans-unit id="31dd4c2d31d8ecfa729e47a41ac595124e30799a" translate="yes" xml:space="preserve">
          <source>The application/http type can be used to enclose a pipeline of one or
   more HTTP request or response messages (not intermixed).

   Type name:  application

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed messages (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body. 

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  HTTP messages enclosed by this type are in
      &quot;binary&quot; format; use of an appropriate Content-Transfer-Encoding
      is required when transmitted via email.

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.2&quot;&gt;Section 8.3.2&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">application / http类型可用于封装一个或多个HTTP请求或响应消息（不混合）的管道。类型名称：application子类型名称：http必需参数：N / A可选参数：version，msgtype version：所包含消息的HTTP版本号（例如&amp;ldquo; 1.1&amp;rdquo;）。如果不存在，则可以从正文的第一行确定版本。 msgtype：消息类型-&amp;ldquo;请求&amp;rdquo;或&amp;ldquo;响应&amp;rdquo;。如果不存在，则可以从主体的第一行确定类型。编码注意事项：这种类型的HTTP消息采用&amp;ldquo;二进制&amp;rdquo;格式；通过电子邮件传输时，需要使用适当的Content-Transfer-Encoding。安全注意事项：见&lt;a href=&quot;#section-9&quot;&gt;第9节&lt;/a&gt; 互操作性注意事项：N / A发布的规范：此规范（请参见&lt;a href=&quot;#section-8.3.2&quot;&gt;第8.3.2节&lt;/a&gt;）。使用此媒体类型的应用程序：N / A片段标识符注意事项：N / A其他信息：此类型不建议使用的别名：N / A幻数：N / A文件扩展名：N / A Macintosh文件类型代码：N / A要获取更多信息，请联系个人和电子邮件地址：请参阅作者地址部分。预期用途：COMMON使用限制：不适用作者：请参阅作者地址。变更负责人：IESG</target>
        </trans-unit>
        <trans-unit id="79aee5e9b1bd229aa07d406e676deb28b27cc227" translate="yes" xml:space="preserve">
          <source>The article &lt;a href=&quot;cors&quot;&gt;covering the HTTP headers used by both clients and servers is here&lt;/a&gt;, and should be considered prerequisite reading.</source>
          <target state="translated">&lt;a href=&quot;cors&quot;&gt;涵盖客户端和服务器使用的HTTP标头&lt;/a&gt;的文章在此处，应视为先决条件。</target>
        </trans-unit>
        <trans-unit id="06b805071003db0b0483630bf1631444f9c65f63" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource.</source>
          <target state="translated">星号是代表任何资源的特殊值。</target>
        </trans-unit>
        <trans-unit id="74a66c2c405c525c313119a786fdc5a7536e3be4" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource. They are only useful when uploading a resource, usually with &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, to check if another resource with the identity has already been uploaded before.</source>
          <target state="translated">星号是代表任何资源的特殊值。仅当通常使用&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;上传资源时，它们才有用，以检查之前是否已上传具有标识的另一个资源。</target>
        </trans-unit>
        <trans-unit id="dc0975dcc835c772deb36f7878cb50959eba5345" translate="yes" xml:space="preserve">
          <source>The asterisk-form of request-target is only used for a server-wide
   OPTIONS request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;Section&amp;nbsp;4.3.7 of [RFC7231]&lt;/a&gt;).

     asterisk-form  = &quot;*&quot;

   When a client wishes to request OPTIONS for the server as a whole, as
   opposed to a specific named resource of that server, the client MUST
   send only &quot;*&quot; (%x2A) as the request-target.  For example,

     OPTIONS * HTTP/1.1

   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query
   component, then the last proxy on the request chain MUST send a
   request-target of &quot;*&quot; when it forwards the request to the indicated
   origin server.

   For example, the request

     OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP/1.1

   would be forwarded by the final proxy as

     OPTIONS * HTTP/1.1
     Host: www.example.org:8001

   after connecting to port 8001 of host &quot;www.example.org&quot;.</source>
          <target state="translated">request-target的星号形式仅用于服务器范围内的OPTIONS请求（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;[RFC7231]的4.3.7节&lt;/a&gt;）。 asterisk-form =&amp;ldquo; *&amp;rdquo;当客户端希望为整个服务器请求OPTIONS时，与该服务器的特定命名资源相反，客户端必须仅发送&amp;ldquo; *&amp;rdquo;（％x2A）作为请求目标。例如，OPTIONS * HTTP / 1.1如果代理接收到带有绝对目标形式的请求目标的OPTIONS请求，其中URI具有空路径且没有查询组件，则请求链上的最后一个代理必须发送请求-目标&amp;ldquo; *&amp;rdquo;将请求转发到指示的原始服务器时。例如，请求OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; 在连接到主机&amp;ldquo; www.example.org&amp;rdquo;的端口8001之后，HTTP / 1.1将由最终代理作为选项转发* HTTP / 1.1主机：www.example.org：8001。</target>
        </trans-unit>
        <trans-unit id="7c769400bb18a5cd534dd7b8c9bf26657988f6ef" translate="yes" xml:space="preserve">
          <source>The authority component of a URL, consisting of the domain name and optionally the port (prefixed by a &lt;code&gt;':'&lt;/code&gt;), is called the &lt;em&gt;authority form&lt;/em&gt;. It is only used with &lt;code&gt;CONNECT&lt;/code&gt; when setting up an HTTP tunnel.</source>
          <target state="translated">URL的权限组成部分由域名和可选的端口（以 &lt;code&gt;':'&lt;/code&gt; 开头）组成，称为&lt;em&gt;权限形式&lt;/em&gt;。仅在设置HTTP隧道时与 &lt;code&gt;CONNECT&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="7687b27068a2ba93c3867498f2559aee586b78c2" translate="yes" xml:space="preserve">
          <source>The authority-form of request-target is only used for CONNECT
   requests (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of [RFC7231]&lt;/a&gt;).

     authority-form = authority

   When making a CONNECT request to establish a tunnel through one or
   more proxies, a client MUST send only the target URI's authority
   component (excluding any userinfo and its &quot;@&quot; delimiter) as the
   request-target.  For example,

     CONNECT www.example.com:80 HTTP/1.1</source>
          <target state="translated">request-target的授权形式仅用于CONNECT请求（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]的4.3.6节&lt;/a&gt;）。权限形式=权限发出CONNECT请求以通过一个或多个代理建立隧道时，客户端必须仅发送目标URI的权限组件（不包括任何userinfo及其&amp;ldquo; @&amp;rdquo;定界符）作为请求目标。例如，CONNECT www.example.com:80 HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="eb218e220bee49a462071f93357caea4eef78a66" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a .pac filename extension:</source>
          <target state="translated">自动配置文件应保存在一个扩展名为.pac的文件中。</target>
        </trans-unit>
        <trans-unit id="b1a30935583f6c8ca798d1fb82e164294a1797dd" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a &lt;code&gt;.pac&lt;/code&gt; filename extension:</source>
          <target state="translated">自动配置文件应保存到文件扩展名为 &lt;code&gt;.pac&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="97bb2f02d88593e20d553e3a3a22148f46c0a1bc" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the &lt;code&gt;REMOTE_ADDR&lt;/code&gt; environment variable in CGI).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885be6e78dcfaa04b9ed4e903a1be4fd5a6bb5be" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the REMOTE_ADDR environment variable in CGI).</source>
          <target state="translated">自动配置文件可以通过CGI脚本输出。例如,当根据客户端IP地址(CGI中的REMOTE_ADDR环境变量)使自动配置文件以不同的方式运行时,这很有用。</target>
        </trans-unit>
        <trans-unit id="654dd208a7e3408c3ffc11bf5374d37d8901160c" translate="yes" xml:space="preserve">
          <source>The basic cache mechanisms in HTTP/1.1 (server-specified expiration
   times and validators) are implicit directives to caches. In some
   cases, a server or client might need to provide explicit directives
   to the HTTP caches. We use the Cache-Control header for this purpose.

   The Cache-Control header allows a client or server to transmit a
   variety of directives in either requests or responses. These
   directives typically override the default caching algorithms. As a
   general rule, if there is any apparent conflict between header
   values, the most restrictive interpretation is applied (that is, the
   one that is most likely to preserve semantic transparency). However, 

   in some cases, cache-control directives are explicitly specified as
   weakening the approximation of semantic transparency (for example,
   &quot;max-stale&quot; or &quot;public&quot;).

   The cache-control directives are described in detail in &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;.</source>
          <target state="translated">HTTP / 1.1中的基本缓存机制（服务器指定的到期时间和验证器）是对缓存的隐式指令。在某些情况下，服务器或客户端可能需要向HTTP缓存提供明确的指令。为此，我们使用Cache-Control标头。 Cache-Control标头允许客户端或服务器在请求或响应中传输各种指令。这些指令通常会覆盖默认的缓存算法。通常，如果标头值之间存在任何明显的冲突，则会应用限制性最强的解释（即，最有可能保留语义透明性的解释）。但是，在某些情况下，显式指定了高速缓存控制指令以削弱语义透明性的近似性（例如，&amp;ldquo; max-stale&amp;rdquo;或&amp;ldquo;公开&amp;rdquo;）。缓存控制指令在以下内容中有详细描述&lt;a href=&quot;#section-14.9&quot;&gt;第14.9条&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="205356eaedd8e0ecc02522f44b70d14ec801fc5f" translate="yes" xml:space="preserve">
          <source>The basic features of the client-server protocol: what it can do and its intended uses.</source>
          <target state="translated">客户机-服务器协议的基本特点:它能做什么和它的预期用途。</target>
        </trans-unit>
        <trans-unit id="0a4f8aeb61f05bae2255b7ec47533f259568b8c3" translate="yes" xml:space="preserve">
          <source>The below status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;. You can find an updated specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&gt;RFC 7231&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7083aadda2c31d227df92dd2fa84ac3833dcfbc" translate="yes" xml:space="preserve">
          <source>The browser is &lt;strong&gt;always&lt;/strong&gt; the entity initiating the request. It is never the server (though some mechanisms have been added over the years to simulate server-initiated messages).</source>
          <target state="translated">浏览器&lt;strong&gt;始终&lt;/strong&gt;是发起请求的实体。它从来都不是服务器（尽管多年来已经添加了一些机制来模拟服务器启动的消息）。</target>
        </trans-unit>
        <trans-unit id="2cbd8e5718ca567c96ddc915f16935aae94c67e0" translate="yes" xml:space="preserve">
          <source>The browser version is often, but not always, put in the value part of the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; token in the User Agent String. This is of course not the case for Internet Explorer (which puts the version number right after the MSIE token), and for Opera after version 10, which has added a Version/&lt;em&gt;VersionNumber&lt;/em&gt; token.</source>
          <target state="translated">浏览器版本通常（但不总是）放在用户代理字符串中&lt;em&gt;BrowserName / VersionNumber&lt;/em&gt;令牌的值部分中。对于Internet Explorer（将版本号放在MSIE令牌后），对于Opera（在版本10之后）（已添加Version / &lt;em&gt;VersionNumber&lt;/em&gt;令牌），当然不是这种情况。</target>
        </trans-unit>
        <trans-unit id="5bdbde6838426248696c94b45cfec9d0fc5ec1db" translate="yes" xml:space="preserve">
          <source>The browser will automatically retry a previously unresponsive proxy after 30 minutes. Additional attempts will continue beginning at one hour, always adding 30 minutes to the elapsed time between attempts.</source>
          <target state="translated">浏览器将在30分钟后自动重试之前没有反应的代理。额外的尝试将从一小时开始继续,尝试之间的时间总是增加30分钟。</target>
        </trans-unit>
        <trans-unit id="887b852d02845ba1a99a4a0744f4797dc2bf5823" translate="yes" xml:space="preserve">
          <source>The cache is disconnected from the rest of the network.</source>
          <target state="translated">缓存与网络的其他部分断开。</target>
        </trans-unit>
        <trans-unit id="2f21d9d6b26c4e6bea5e52cb792172b8c9de3d95" translate="yes" xml:space="preserve">
          <source>The cache must verify the status of the stale resources before using it and expired ones should not be used.</source>
          <target state="translated">缓存在使用前必须验证陈旧资源的状态,过期的资源不应使用。</target>
        </trans-unit>
        <trans-unit id="daeefaacace04c4b349d31a7092c605e7392d449" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response.</source>
          <target state="translated">缓存不应该存储任何关于客户端请求或服务器响应的信息。</target>
        </trans-unit>
        <trans-unit id="6c578830e2a2b4f9372dff694a83a347a725c406" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response. A request is sent to the server and a full response is downloaded each and every time.</source>
          <target state="translated">缓存不应该存储任何关于客户端请求或服务器响应的内容。向服务器发送请求,每次都会下载完整的响应。</target>
        </trans-unit>
        <trans-unit id="7ca27201de90dba7af54bed9d5fa78a31a2d3e2e" translate="yes" xml:space="preserve">
          <source>The challenge and response flow works like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f42630e59bac670b1a39303ea428afbe6e77a0e" translate="yes" xml:space="preserve">
          <source>The character encoding standard.</source>
          <target state="translated">字符编码标准。</target>
        </trans-unit>
        <trans-unit id="fd7f690c409848b22dbd45c29cbfb870b4b15ecf" translate="yes" xml:space="preserve">
          <source>The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the chunk-size, for the sake of
   supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body
   size.

     chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string

   The chunked encoding is specific to each connection and is likely to
   be removed or recoded by each recipient (including intermediaries)
   before any higher-level application would have a chance to inspect
   the extensions.  Hence, use of chunk extensions is generally limited 

   to specialized HTTP services such as &quot;long polling&quot; (where client and
   server can have shared expectations regarding the use of chunk
   extensions) or for padding within an end-to-end secured connection.

   A recipient MUST ignore unrecognized chunk extensions.  A server
   ought to limit the total length of chunk extensions received in a
   request to an amount reasonable for the services provided, in the
   same way that it applies length limitations and timeouts for other
   parts of a message, and generate an appropriate 4xx (Client Error)
   response if that amount is exceeded.</source>
          <target state="translated">chunked编码允许每个chunk包含零个或多个chunk扩展,紧跟在chunk-size之后,以便提供每个chunk元数据(如签名或哈希)、中间消息控制信息或消息体大小的随机化。chunk-ext=*(&quot;;&quot; chunk-ext-name[&quot;=&quot; chunk-ext-val])chunk-ext-name=token chunk-ext-val=token/quoted-string 分块编码是每个连接所特有的,并且很可能在任何更高级别的应用程序有机会检查扩展之前,被每个接收者(包括中间人)删除或重新编码。因此,分块扩展的使用一般仅限于专门的HTTP服务,如 &quot;长轮询&quot;(客户端和服务器可以对分块扩展的使用有共同的期望)或在端到端安全连接中进行填充。接收者必须忽略未识别的分块扩展。服务器应该将请求中接收到的分块扩展的总长度限制在所提供服务的合理范围内,就像它对消息的其他部分应用长度限制和超时一样,如果超过了这个数量,则生成一个适当的4xx(客户端错误)响应。</target>
        </trans-unit>
        <trans-unit id="48e4a91f8067d7ebfdee16e201dcdb0c016dab57" translate="yes" xml:space="preserve">
          <source>The chunked encoding modifies the body of a message in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing entity-header fields. This
   allows dynamically produced content to be transferred along with the
   information necessary for the recipient to verify that it has
   received the full message.

       Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF

       chunk          = chunk-size [ chunk-extension ] CRLF
                        chunk-data CRLF
       chunk-size     = 1*HEX
       last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF

       chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
       chunk-ext-name = token
       chunk-ext-val  = token | quoted-string
       chunk-data     = chunk-size(OCTET)
       trailer        = *(entity-header CRLF)

   The chunk-size field is a string of hex digits indicating the size of
   the chunk. The chunked encoding is ended by any chunk whose size is
   zero, followed by the trailer, which is terminated by an empty line.

   The trailer allows the sender to include additional HTTP header
   fields at the end of the message. The Trailer header field can be
   used to indicate which header fields are included in a trailer (see
   &lt;a href=&quot;#section-14.40&quot;&gt;section 14.40&lt;/a&gt;). 

   A server using chunked transfer-coding in a response MUST NOT use the
   trailer for any header fields unless at least one of the following is
   true:

   a)the request included a TE header field that indicates &quot;trailers&quot; is
     acceptable in the transfer-coding of the  response, as described in
     &lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;; or,

   b)the server is the origin server for the response, the trailer
     fields consist entirely of optional metadata, and the recipient
     could use the message (in a manner acceptable to the origin server)
     without receiving this metadata.  In other words, the origin server
     is willing to accept the possibility that the trailer fields might
     be silently discarded along the path to the client.

   This requirement prevents an interoperability failure when the
   message is being received by an HTTP/1.1 (or later) proxy and
   forwarded to an HTTP/1.0 recipient. It avoids a situation where
   compliance with the protocol would have necessitated a possibly
   infinite buffer on the proxy.

   An example process for decoding a Chunked-Body is presented in
   appendix 19.4.6.

   All HTTP/1.1 applications MUST be able to receive and decode the
   &quot;chunked&quot; transfer-coding, and MUST ignore chunk-extension extensions
   they do not understand.</source>
          <target state="translated">分块编码修改消息的主体，以便将其作为一系列块传输，每个块都有自己的大小指示符，后跟一个包含实体报头字段的可选尾部。这允许动态产生的内容与接收者验证其已收到完整消息所需的信息一起传输。块状主体= *块状最后一个块状拖车CRLF块状=块状大小[块状扩展] CRLF块状数据CRLF块状大小= 1 * HEX块状末尾= 1 *（&amp;ldquo; 0&amp;rdquo;）[块状扩展名] CRLF chunk-extension = *（&amp;ldquo;;&amp;rdquo; chunk-ext-name [&amp;ldquo; =&amp;rdquo;[chunk-ext-val]））chunk-ext-name =令牌chunk-ext-val =令牌| quoted-string块数据=块大小（OCTET）预告片= *（实体标题CRLF）块大小字段是一个十六进制数字字符串，指示块的大小。分块编码以大小为零的任何分块结尾，其后是尾部，尾部以空行结束。预告片允许发件人在消息末尾包含其他HTTP标头字段。 Trailer标头字段可用于指示预告片中包含哪些标头字段（请参见分块编码以大小为零的任何分块结尾，然后是尾部的结尾，该尾部以空行结束。预告片允许发件人在消息末尾包含其他HTTP标头字段。 Trailer标头字段可用于指示预告片中包含哪些标头字段（请参见分块编码以大小为零的任何分块结尾，然后是尾部的结尾，该尾部以空行结束。预告片允许发件人在消息末尾包含其他HTTP标头字段。 Trailer标头字段可用于指示预告片中包含哪些标头字段（请参见 &lt;a href=&quot;#section-14.40&quot;&gt;第14.40条&lt;/a&gt;）。在响应中使用分块传输编码的服务器不得将尾部用于任何报头字段，除非至少满足以下条件之一：a）请求包含一个TE报头字段，该字段指示&amp;ldquo;尾部&amp;rdquo;在传输编码中是可接受的如&lt;a href=&quot;#section-14.39&quot;&gt;第14.39节&lt;/a&gt;所述 ;或者b）服务器是响应的原始服务器，尾部字段完全由可选的元数据组成，并且收件人可以使用消息（以原始服务器可接受的方式）而无需接收此元数据。换句话说，源服务器愿意接受这样的可能性，即拖车字段可能会沿着到客户端的路径被静默丢弃。当消息被HTTP / 1.1（或更高版本）代理接收并转发给HTTP / 1.0接收者时，此要求可防止互操作性失败。它避免了遵守协议会导致代理服务器上可能存在无限缓冲区的情况。附录19.4.6给出了解码块状体的示例过程。所有HTTP / 1。1个应用程序必须能够接收和解码&amp;ldquo;分块&amp;rdquo;传输编码，并且必须忽略它们不理解的块扩展。</target>
        </trans-unit>
        <trans-unit id="a7d9ecd82450ec8dc1ad7713aebafcc7e0d70fa4" translate="yes" xml:space="preserve">
          <source>The chunked transfer coding wraps the payload body in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing header fields.  Chunked
   enables content streams of unknown size to be transferred as a
   sequence of length-delimited buffers, which enables the sender to
   retain connection persistence and the recipient to know when it has
   received the entire message.

     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets

   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets.  The chunked transfer coding is complete
   when a chunk with a chunk-size of zero is received, possibly followed
   by a trailer, and finally terminated by an empty line.

   A recipient MUST be able to parse and decode the chunked transfer
   coding.</source>
          <target state="translated">分块式传输编码将有效载荷体包装起来,以便将其作为一系列分块传输,每个分块都有自己的大小指示器,然后是一个包含头字段的optional预告片。Chunked使得未知大小的内容流可以作为一个长度限定的缓冲区序列进行传输,这使得发送方能够保留连接持久性,接收方也能够知道何时收到了整个消息。chunked-body=*chunk last-chunk trailer-part CRLF chunk=chunk-size[chunk-ext]CRLF chunk-data CRLF chunk-size=1*HEXDIG last-chunk=1*(&quot;0&quot;)[chunk-ext]CRLF chunk-data=1*OCTET;chunk-size八位数的序列 chunk-size字段是一串十六进制数字,以八位数为单位表示chunk-data的大小。当接收到一个chunk-size为0的chunk时,chunk传输编码就完成了,后面可能是一个拖车,最后以空行结束。接收者必须能够解析和解码分块传输编码。</target>
        </trans-unit>
        <trans-unit id="415a4bc5f36b8b74ac665b81439b0f17201eff1f" translate="yes" xml:space="preserve">
          <source>The client IP address</source>
          <target state="translated">客户端IP地址</target>
        </trans-unit>
        <trans-unit id="f4f8621b5597ea11953d56253188393201c5390d" translate="yes" xml:space="preserve">
          <source>The client SHOULD continue with its request. This interim response is
   used to inform the client that the initial part of the request has
   been received and has not yet been rejected by the server. The client
   SHOULD continue by sending the remainder of the request or, if the
   request has already been completed, ignore this response. The server
   MUST send a final response after the request has been completed. See
   &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for detailed discussion of the use and handling of this
   status code.</source>
          <target state="translated">客户应继续其请求。此临时响应用于通知客户端请求的初始部分已被接收并且尚未被服务器拒绝。客户端应该继续发送剩余的请求，或者，如果请求已经完成，则忽略该响应。请求完成后，服务器必须发送最终响应。有关此状态码的使用和处理的详细讨论，请参见 &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cdfa1347854a07ac313ca6b4125f4dd9a9af51d" translate="yes" xml:space="preserve">
          <source>The client did not produce a request within the time that the server
   was prepared to wait. The client MAY repeat the request without
   modifications at any later time.</source>
          <target state="translated">客户端没有在服务器准备等待的时间内产生请求。客户端可以在以后的任何时间不加修改地重复该请求。</target>
        </trans-unit>
        <trans-unit id="7266b1abf9d7b15153ddaf61096e777051f04c74" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.</source>
          <target state="translated">客户端没有访问内容的权利,即他们是未经授权的,所以服务器拒绝给予适当的响应。与401不同的是,服务器知道客户端的身份。</target>
        </trans-unit>
        <trans-unit id="20c408742f6f7b483f2e5d78c14bc1e7549de56d" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content; that is, it is unauthorized, so the server is refusing to give the requested resource. Unlike 401, the client's identity is known to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a06a1a055ac600eef86c86487e70e03abac976" translate="yes" xml:space="preserve">
          <source>The client establishes a TCP connection (or the appropriate connection if the transport layer is not TCP).</source>
          <target state="translated">客户端建立一个TCP连接(如果传输层不是TCP,则建立相应的连接)。</target>
        </trans-unit>
        <trans-unit id="bc64fec6ee0e97b2601f305debb944c7297d99f9" translate="yes" xml:space="preserve">
          <source>The client has indicated preconditions in its headers which the server does not meet.</source>
          <target state="translated">客户端在其头文件中指出了服务器不满足的前提条件。</target>
        </trans-unit>
        <trans-unit id="bfa31c734d07698a1162e761b391639dea1a2247" translate="yes" xml:space="preserve">
          <source>The client issues a request to the canonical domain: &lt;code&gt;http://example.org/whatddup&lt;/code&gt;</source>
          <target state="translated">客户端向规范域发出请求： &lt;code&gt;http://example.org/whatddup&lt;/code&gt; : //example.org/whatddup</target>
        </trans-unit>
        <trans-unit id="517d78c7c821635a0b4548cee1bab26d988c7745" translate="yes" xml:space="preserve">
          <source>The client sends its request, and waits for the answer.</source>
          <target state="translated">客户端发送请求,并等待回答。</target>
        </trans-unit>
        <trans-unit id="ee32a252064fce95d78b27deb30677a6f5f9861f" translate="yes" xml:space="preserve">
          <source>The client should not repeat this request without modification.</source>
          <target state="translated">客户端不应不加修改地重复此请求。</target>
        </trans-unit>
        <trans-unit id="6ecda58cff7b06f0ebd744bad8fc92cd64e7b568" translate="yes" xml:space="preserve">
          <source>The client that initiated the request and subsequent proxies in a chain of proxies.</source>
          <target state="translated">发起请求的客户端以及代理链中的后续代理。</target>
        </trans-unit>
        <trans-unit id="72cded756bfa543235b2ef68f253845e7563a14d" translate="yes" xml:space="preserve">
          <source>The codings defined below can be used to compress the payload of a
   message.</source>
          <target state="translated">下面定义的编码可以用来压缩信息的有效载荷。</target>
        </trans-unit>
        <trans-unit id="971adc7eb81ae93f06509fafd469f5eea13bda5b" translate="yes" xml:space="preserve">
          <source>The comma-separated list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9677ba4a41043c80dd7875428097d17f3b102726" translate="yes" xml:space="preserve">
          <source>The common use case is to return &lt;code&gt;204&lt;/code&gt; as a result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request, updating a resource, without changing the current content of the page displayed to the user. If the resource is created, &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; is returned instead. If the page should be changed to the newly updated page, the &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">常见用例是作为&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;请求的结果返回 &lt;code&gt;204&lt;/code&gt; ，更新资源，而不更改显示给用户的页面的当前内容。如果创建了资源，则返回&lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; 。如果应将页面更改为新更新的页面，则应使用&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e652d732604ca7329e0833f245786713768ed8e7" translate="yes" xml:space="preserve">
          <source>The common use case of this status code is as the result of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request.</source>
          <target state="translated">此状态代码的常见用例是&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求的结果。</target>
        </trans-unit>
        <trans-unit id="5dee61655e811dbf764699bfb5c6ab2c8de25fd2" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. If a listed &lt;code&gt;ETag&lt;/code&gt; has the &lt;code&gt;W/&lt;/code&gt; prefix indicating a weak entity tag, it will never match under this comparison algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04133abc831323a63813210792503c0061624d7" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. This is weakened when the &lt;code&gt;W/&lt;/code&gt; prefix is used in front of the &lt;code&gt;ETag&lt;/code&gt;.</source>
          <target state="translated">与存储的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;比较&lt;/em&gt;使用&lt;em&gt;强比较算法&lt;/em&gt;，这意味着两个文件仅被视为字节对字节。当在 &lt;code&gt;ETag&lt;/code&gt; 前面使用 &lt;code&gt;W/&lt;/code&gt; 前缀时，这会减弱。</target>
        </trans-unit>
        <trans-unit id="72daedd3e8f61f2659bcac2190d51fd4c98967f8" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical if the content is equivalent &amp;mdash; they don't have to be identical byte for byte. For example, two pages that differ by the date of generation in the footer would still be considered as identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2fbb792f71c73497799f887f4d3819b0abaf6" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical not only if they are identical byte to byte, but if the content is equivalent. For example, two pages that would differ only by the date of generation in the footer would be considered as identical.</source>
          <target state="translated">与存储的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;比较&lt;/em&gt;使用&lt;em&gt;弱比较算法&lt;/em&gt;，这意味着两个文件不仅字节对字节相同，而且内容相同也被视为相同。例如，只有页脚的生成日期不同的两个页面将被视为相同。</target>
        </trans-unit>
        <trans-unit id="a0905c4e80c334babf93aeba4446459e7079b76c" translate="yes" xml:space="preserve">
          <source>The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; and send us a pull request.</source>
          <target state="translated">此页面中的兼容性表是根据结构化数据生成的。如果您想贡献数据，请查看&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;并向我们​​发送请求请求。</target>
        </trans-unit>
        <trans-unit id="a05c38dc87a4c3ad5288313d314048589646b4f9" translate="yes" xml:space="preserve">
          <source>The concrete steps necessary to deliver the HPKP header depend on the web server you use.</source>
          <target state="translated">传递HPKP头的具体步骤取决于你使用的Web服务器。</target>
        </trans-unit>
        <trans-unit id="f5aee79466e47707e7aaaf37d00efa279a7d1756" translate="yes" xml:space="preserve">
          <source>The content and concepts within are a product of the Atom community
   and the Atompub Working Group.</source>
          <target state="translated">其中的内容和概念是Atom社区和Atompub工作组的产物。</target>
        </trans-unit>
        <trans-unit id="5e832a9cde14ca1e931972542042bbb8f1f01671" translate="yes" xml:space="preserve">
          <source>The content of an &quot;app:accept&quot; element value is a media range as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The media range specifies a type of
   representation that can be POSTed to a Collection.

   The app:accept element is similar to the HTTP Accept request-header
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  Media type parameters are allowed within app:accept, but
   app:accept has no notion of preference -- &quot;accept-params&quot; or &quot;q&quot;
   arguments, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;Section&amp;nbsp;14.1 of [RFC2616]&lt;/a&gt; are not
   significant.

   White space (as defined in [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]) around the app:accept element's
   media range is insignificant and MUST be ignored.

   A value of &quot;application/atom+xml;type=entry&quot; MAY appear in any app:
   accept list of media ranges and indicates that Atom Entry Documents
   can be POSTed to the Collection.  If no app:accept element is
   present, clients SHOULD treat this as equivalent to an app:accept
   element with the content &quot;application/atom+xml;type=entry&quot;.

   If one app:accept element exists and is empty, clients SHOULD assume
   that the Collection does not support the creation of new Entries.

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }</source>
          <target state="translated">&amp;ldquo; app：accept&amp;rdquo;元素值的内容是[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中定义的媒体范围。媒体范围指定了一种可以过帐到集合的表示形式。 app：accept元素类似于HTTP Accept request-header [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]。 app：accept允许使用媒体类型参数，但是app：accept没有优先级概念- &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;[RFC2616]第14.1节中&lt;/a&gt;指定的&amp;ldquo; accept-params&amp;rdquo;或&amp;ldquo; q&amp;rdquo;参数并不重要。空格（如[ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml中&lt;/a&gt;定义]）周围的app：accept元素的媒体范围微不足道，必须忽略。值&amp;ldquo; application / atom + xml; type = entry&amp;rdquo;可能会出现在任何应用程序中：接受媒体范围列表，并指示可以将Atom条目文档发布到集合中。如果不存在app：accept元素，则客户端应将此内容等同于内容为&amp;ldquo; application / atom + xml; type = entry&amp;rdquo;的app：accept元素。如果一个app：accept元素存在且为空，则客户端应假定Collection不支持新条目的创建。 appAccept =元素app：accept {appCommonAttributes，（text？）}</target>
        </trans-unit>
        <trans-unit id="539a35b3718ee8a5aee196d79e2ab252e1794cb2" translate="yes" xml:space="preserve">
          <source>The content security policy</source>
          <target state="translated">内容安全政策</target>
        </trans-unit>
        <trans-unit id="a99f7db56a8fc0d621fb9f438536232235171cde" translate="yes" xml:space="preserve">
          <source>The cookie created above is a &lt;em&gt;session cookie&lt;/em&gt;: it is deleted when the client shuts down, because it didn't specify an &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directive. However, web browsers may use &lt;strong&gt;session restoring&lt;/strong&gt;, which makes most session cookies permanent, as if the browser was never closed.</source>
          <target state="translated">上面创建的cookie是&lt;em&gt;会话cookie&lt;/em&gt;：由于客户端未指定 &lt;code&gt;Expires&lt;/code&gt; 或 &lt;code&gt;Max-Age&lt;/code&gt; 指令，因此在客户端关闭时将其删除。但是，Web浏览器可能会使用&lt;strong&gt;会话还原&lt;/strong&gt;，这会使大多数会话Cookie保持永久状态，就像从未关闭过浏览器一样。</target>
        </trans-unit>
        <trans-unit id="d3ea80f5dbbb07b298e7e569c7ef43ac598c80e1" translate="yes" xml:space="preserve">
          <source>The creator of a lock has special privileges to use the lock to
   modify the resource.  When a locked resource is modified, a server
   MUST check that the authenticated principal matches the lock creator
   (in addition to checking for valid lock token submission).

   The server MAY allow privileged users other than the lock creator to
   destroy a lock (for example, the resource owner or an administrator).
   The 'unlock' privilege in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] was defined to provide that
   permission.

   There is no requirement for servers to accept LOCK requests from all
   users or from anonymous users.

   Note that having a lock does not confer full privilege to modify the
   locked resource.  Write access and other privileges MUST be enforced
   through normal privilege or authentication mechanisms, not based on
   the possible obscurity of lock token values.</source>
          <target state="translated">锁的创建者具有特殊的特权，可以使用锁来修改资源。修改锁定的资源后，服务器必须检查经过身份验证的主体是否与锁定创建者匹配（除了检查有效的锁定令牌提交之外）。服务器可以允许除锁创建者以外的特权用户破坏锁（例如，资源所有者或管理员）。[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744中&lt;/a&gt;的&amp;ldquo;解锁&amp;rdquo;特权定义为提供该权限。不需要服务器接受来自所有用户或匿名用户的LOCK请求。请注意，拥有锁并不授予修改锁定资源的完整特权。写访问权限和其他特权必须通过普通特权或身份验证机制来实施，而不是基于锁令牌值的可能模糊性。</target>
        </trans-unit>
        <trans-unit id="ed6930808b04a49db2a6e882d398fb403c175d9d" translate="yes" xml:space="preserve">
          <source>The credentials are constructed like this:</source>
          <target state="translated">证件的构造是这样的。</target>
        </trans-unit>
        <trans-unit id="7b8947dfbd554435efd90ececbfae32fbeaafdf7" translate="yes" xml:space="preserve">
          <source>The current set of policy-controlled features fall into two broad categories:</source>
          <target state="translated">目前一套政策控制的功能分为两大类。</target>
        </trans-unit>
        <trans-unit id="a8e69d68f3b1fc3a7df5c137fb99fc1e2d0cfdfa" translate="yes" xml:space="preserve">
          <source>The data URL will use the encoded data after the initial header line.</source>
          <target state="translated">数据URL将使用初始头行后的编码数据。</target>
        </trans-unit>
        <trans-unit id="230d58d4d34777b830d4af9d56c4ae6916e8d111" translate="yes" xml:space="preserve">
          <source>The data portion of a data URL is opaque, so an attempt to use a query string (page-specific parameters, with the syntax &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt;) with a data URL will just include the query string in the data the URL represents.</source>
          <target state="translated">数据URL的数据部分是不透明的，因此，尝试将查询字符串（特定于页面的参数，语法为 &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt; ）与数据URL一起使用时，查询字符串将仅包含在URL数据中代表。</target>
        </trans-unit>
        <trans-unit id="a838733e8354e6c49d346e5cb2fb10c66ede3853" translate="yes" xml:space="preserve">
          <source>The data to be sent is already compressed and a second compression won't lead to smaller data to be transmitted. This may be the case with some image formats;</source>
          <target state="translated">要发送的数据已经被压缩,第二次压缩不会导致传输的数据变小。某些图像格式可能会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="7f9129a63093295fb84eccd3b4f61f829c9ef91c" translate="yes" xml:space="preserve">
          <source>The date/time after which the response is considered stale.</source>
          <target state="translated">答复被视为失效的日期/时间。</target>
        </trans-unit>
        <trans-unit id="0911607a468bc8e23c0901e6b8899136c11add6c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;a href=&quot;#allowlist&quot;&gt;allowlist&lt;/a&gt; value is &lt;code&gt;'src'&lt;/code&gt;, so this is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f69faebfa441f8068a5c2a1d971d7bb75686df" translate="yes" xml:space="preserve">
          <source>The default allowlist is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b5d6196048d6e0193482609dd5869326eae443" translate="yes" xml:space="preserve">
          <source>The default value in &lt;a href=&quot;https://www.chromestatus.com/feature/5100524789563392&quot;&gt;Google Chrome&lt;/a&gt; is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1d97e38222ff903f1be33758664532039e0043" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;'self'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce8a92d4fc085eba2fc0033588db51c48988c071" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bebd0e8a85754c8108d63895e7f002620ba7cd6c" translate="yes" xml:space="preserve">
          <source>The definition of collection state has been fixed so it doesn't vary
   anymore depending on the Request-URI (see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The DAV:source property introduced in &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;Section&amp;nbsp;4.6 of [RFC2518]&lt;/a&gt; was
   removed due to lack of implementation experience.

   The DAV header now allows non-IETF extensions through URIs in
   addition to compliance class tokens.  It also can now be used in
   requests, although this specification does not define any associated
   semantics for the compliance classes defined in here (see
   &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).

   In &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, the definition of the Depth header (&lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;)
   required that, by default, request headers would be applied to each
   resource in scope.  Based on implementation experience, the default
   has now been reversed (see &lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;).

   The definitions of HTTP status code 102 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518], Section&amp;nbsp;10.1&lt;/a&gt;) and
   the Status-URI response header (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;) have been removed due to
   lack of implementation.

   The TimeType format used in the Timeout request header and the
   &quot;timeout&quot; XML element used to be extensible.  Now, only the two
   formats defined by this specification are allowed (see &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;).

Author's Address

   Lisa Dusseault (editor)
   CommerceNet
   2064 Edgewood Dr.
   Palo Alto, CA  94303
   US

   EMail: ldusseault@commerce.net 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Dusseault                   Standards Track                   [Page 127]</source>
          <target state="translated">收集状态的定义已固定，因此不再取决于Request-URI（请参见&lt;a href=&quot;#section-5.2&quot;&gt;5.2节&lt;/a&gt;）。由于缺乏实施经验&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;，[RFC2518] 4.6节中&lt;/a&gt;引入的DAV：source属性已被删除。 DAV标头现在除了符合性类令牌外，还允许通过URI进行非IETF扩展。现在，它也可以在请求中使用，尽管该规范并未为此处定义的合规性类定义任何关联的语义（请参见 &lt;a href=&quot;#section-10.1&quot;&gt;10.1节&lt;/a&gt;）。在&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518中&lt;/a&gt;，深度标头的定义（&lt;a href=&quot;#section-9.2&quot;&gt;第9.2节&lt;/a&gt;）要求，默认情况下，请求标头将应用于范围内的每个资源。根据实施经验，默认设置现已撤销（请参见&lt;a href=&quot;#section-10.2&quot;&gt;10.2节&lt;/a&gt;）。由于缺乏实现，已删除了HTTP状态代码102（&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518]，第10.1节&lt;/a&gt;）和Status-URI响应标头（&lt;a href=&quot;#section-9.7&quot;&gt;第9.7节&lt;/a&gt;）的定义。超时请求标头中使用的TimeType格式和XML元素&amp;ldquo;超时&amp;rdquo;曾经是可扩展的。现在，仅允许使用本规范定义的两种格式（请参见&lt;a href=&quot;#section-10.7&quot;&gt;10.7节）&lt;/a&gt;）。作者的地址Lisa Dusseault（编辑）CommerceNet 2064 Edgewood帕洛阿尔托博士，CA 94303美国电子邮件：ldusseault@commerce.net完整的版权声明版权所有（C）IETF信托（2007）。本文档受&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78中&lt;/a&gt;包含的权利，许可和限制的约束，除非另有说明，否则作者保留所有权利。本文档及其中包含的信息均按&amp;ldquo;原样&amp;rdquo;提供，并且贡献者，他/她代表的组织或赞助者（如果有），互联网社会，IETF信托和互联网工程任务强制免责声明明示或暗示的担保，包括但不限于任何担保，即使用此处的信息不会侵犯任何权利或对特定用途的适销性或适用性的任何默示担保。知识产权IETF对于可能声称与实施或使用本文档中描述的技术有关的任何知识产权或其他权利的有效性或范围，或根据此类权利获得的任何许可可能或不具有的范围，不采取任何立场。可能不可用；它也不表示它已做出任何独立的努力来确定任何此类权利。可以在以下位置找到有关RFC文档中有关权利的程序的信息：&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;。可以获取向IETF秘书处披露的知识产权的副本，以及可以提供的许可的任何保证，或者本规范的实施者或用户尝试获得一般许可或使用此类所有权的许可的结果。从IETF在线IPR存储库中获得，&lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;网址&lt;/a&gt;为 http://www.ietf.org/ipr。 IETF邀请任何感兴趣的团体提请其注意可能涵盖实施本标准所需技术的任何版权，专利或专利申请或其他所有权。请通过ietf-ipr@ietf.org将信息发送给IETF。 RFC编辑器功能的确认资金目前由Internet Society提供。杜赛标准赛道[第127页]</target>
        </trans-unit>
        <trans-unit id="846eb07b1348486cd629ae2d294bdd353ad9d018" translate="yes" xml:space="preserve">
          <source>The definition of validator weakness has been expanded and clarified.
   (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;)

   Weak entity-tags are now allowed in all requests except range
   requests.  (Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;)

   The ETag header field ABNF has been changed to not use quoted-string,
   thus avoiding escaping issues.  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   ETag is defined to provide an entity tag for the selected
   representation, thereby clarifying what it applies to in various
   situations (such as a PUT response).  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   The precedence for evaluation of conditional requests has been
   defined.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)</source>
          <target state="translated">验证者弱点的定义已得到扩展和澄清。 （&lt;a href=&quot;#section-2.1&quot;&gt;第2.1节&lt;/a&gt;）现在，除范围请求外，所有请求中都允许使用弱实体标签。 （第&lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;和&lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;节）ETag标头字段ABNF已更改为不使用带引号的字符串，从而避免了转义问题。 （&lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt;）定义了ETag，以为所选表示形式提供实体标签，从而阐明其在各种情况下（例如PUT响应）的适用范围。 （&lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt;）已经定义了条件请求评估的优先级。 （&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e5328b76256fad750a1749c068a42a24ebf54b5b" translate="yes" xml:space="preserve">
          <source>The delta-seconds rule specifies a non-negative integer, representing
   time in seconds.

     delta-seconds  = 1*DIGIT

   A recipient parsing a delta-seconds value and converting it to binary
   form ought to use an arithmetic type of at least 31 bits of
   non-negative integer range.  If a cache receives a delta-seconds
   value greater than the greatest integer it can represent, or if any
   of its subsequent calculations overflows, the cache MUST consider the
   value to be either 2147483648 (2^31) or the greatest positive integer
   it can conveniently represent.

      Note: The value 2147483648 is here for historical reasons,
      effectively represents infinity (over 68 years), and does not need
      to be stored in binary form; an implementation could produce it as
      a canned string if any overflow occurs, even if the calculations
      are performed with an arithmetic type incapable of directly
      representing that number.  What matters here is that an overflow
      be detected and not treated as a negative value in later
      calculations.</source>
          <target state="translated">delta-seconds规则指定了一个非负整数,代表以秒为单位的时间。 delta-seconds=1*DIGIT 接收者在解析delta-seconds值并将其转换为二进制形式时,应该使用至少31位非负整数范围的算术类型。如果一个缓存接收到的delta-seconds值大于它能表示的最大整数,或者它的任何后续计算溢出,缓存必须认为这个值是2147483648 (2^31)或者它能方便表示的最大正整数。注意:这里的值2147483648是出于历史原因,有效地代表了无穷大(超过68年),并且不需要以二进制形式存储;如果发生任何溢出,一个实现可以把它作为一个罐头字符串产生,即使计算是用一个无法直接代表这个数字的算术类型进行的。这里重要的是要检测到溢出,并且在以后的计算中不作为负值处理。</target>
        </trans-unit>
        <trans-unit id="462deec90237c01c88236d382d44851e9cb76a0d" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">不推荐使用的HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理报告违反内容安全策略的尝试。这些违规报告包含通过HTTP POST请求发送到指定URI的JSON文档。</target>
        </trans-unit>
        <trans-unit id="d2fba7a8d872d32f2df3792a939bb1791a1db637" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">不推荐使用的HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; 指令定义了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Worker&lt;/a&gt;和使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素加载的嵌套浏览上下文的有效源。对于工作人员，用户代理将不符合要求的请求视为致命的网络错误。</target>
        </trans-unit>
        <trans-unit id="e51c9503c283d705f7c21009451fd7fc25c1eae1" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">不推荐使用的HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理报告违反内容安全策略的尝试。这些违规报告包含通过HTTP POST请求发送到指定URI的JSON文档。</target>
        </trans-unit>
        <trans-unit id="fb07dc5196edc576bb2b0f9aa70d416b3225ffb6" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">不推荐使用的HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; 指令定义了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Worker&lt;/a&gt;和使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素加载的嵌套浏览上下文的有效源。对于工作人员，用户代理将不符合要求的请求视为致命的网络错误。</target>
        </trans-unit>
        <trans-unit id="06d89b04e62b26b8ec32aee4540211a4cdd447d1" translate="yes" xml:space="preserve">
          <source>The design of the cookie mechanism is such that a server is unable to confirm that a cookie was set on a secure origin or even to tell &lt;em&gt;where&lt;/em&gt; a cookie was originally set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546d3635c32a2c56e35d6d2aa60b3503528021d5" translate="yes" xml:space="preserve">
          <source>The determination of the best suited representation is made through one of two mechanisms:</source>
          <target state="translated">通过两种机制之一确定最合适的代表。</target>
        </trans-unit>
        <trans-unit id="efd86e58a3f30de9823ac04636ac8858e24077e3" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;POST&lt;/code&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6be54e0040e3b26e0677bc1c6c4c457e76e04c" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="translated">之间的差 &lt;code&gt;PUT&lt;/code&gt; 和&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;PUT&lt;/code&gt; 是等幂：调用它一次或多次连续具有相同的效果（也就是没有&lt;em&gt;侧面&lt;/em&gt;的效果），在那里连续的相同 &lt;code&gt;POST&lt;/code&gt; 可具有额外的效果，如通过顺序数次。</target>
        </trans-unit>
        <trans-unit id="6709d83055ac598235616e01accc6af867f222e8" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), whereas successive identical &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests may have additional effects, akin to placing an order several times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97e83ad793fdb57539f72e47bc2da06f9dd1d1b" translate="yes" xml:space="preserve">
          <source>The different behaviors are defined by the method of the request used, and by the set of headers used for a precondition:</source>
          <target state="translated">不同的行为是由所使用的请求方法和用于前提条件的头文件集来定义的。</target>
        </trans-unit>
        <trans-unit id="80097a5c7491102e72da844144491c63c53e8bbd" translate="yes" xml:space="preserve">
          <source>The different operations that can be done with HTTP: &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, and also less common requests like &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/trace&quot;&gt;&lt;code&gt;TRACE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用HTTP可以执行的不同操作：&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;以及不太常见的请求，例如&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;methods/trace&quot;&gt; &lt;code&gt;TRACE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e04de4891d47a19965395d893dcab0798dc6bd5e" translate="yes" xml:space="preserve">
          <source>The directive has no effect in and of itself, but only gains meaning in combination with other directives.</source>
          <target state="translated">该指令本身没有任何效力,只有与其他指令结合在一起才有意义。</target>
        </trans-unit>
        <trans-unit id="ff5b92c5b8f032668f44bf6f84a3cf1d8c8d5495" translate="yes" xml:space="preserve">
          <source>The directive whose enforcement caused the violation.</source>
          <target state="translated">其执行造成违规的指令;</target>
        </trans-unit>
        <trans-unit id="1e1a37c4f62f3222f090827450cdf97da20610e6" translate="yes" xml:space="preserve">
          <source>The directive whose inforcement caused the violation.</source>
          <target state="translated">导致违规的指令的执行情况;</target>
        </trans-unit>
        <trans-unit id="9d6fbbcf7c6fc507f3bb84ba69ad161ef0423583" translate="yes" xml:space="preserve">
          <source>The directives are case-insensitive and have an optional argument, that can use both token and quoted-string syntax. Multiple directives are comma-separated.</source>
          <target state="translated">指令不区分大小写,有一个可选的参数,可以使用标记和引号字符串两种语法。多条指令以逗号分隔。</target>
        </trans-unit>
        <trans-unit id="a323859b4a71cd1636fe58a5af5f7f00fc33a635" translate="yes" xml:space="preserve">
          <source>The directives of the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header can also be applied to &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;标头的指令也可以应用于 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="279baf1d439803980239f8e98d3badd1808c8388" translate="yes" xml:space="preserve">
          <source>The discrete types currently registered with the IANA are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c774d8f9b5eed24a795ffcdff60addf8cc635d" translate="yes" xml:space="preserve">
          <source>The document &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="translated">文档 &lt;code&gt;https://example.com/page.html&lt;/code&gt; 将发送引荐来源网址 &lt;code&gt;https://example.com/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d8ec917bef56223b37a5c1500b0656c3dce3b2f" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation header&lt;/code&gt; has opened another window with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. This is for the same reason as above, namely that they can communicate and thus we cannot allow them to switch processes.</source>
          <target state="translated">具有 &lt;code&gt;Large-Allocation header&lt;/code&gt; 的文档已打开另一个窗口，该窗口具有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; 或其他类似方法，而未设置 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 功能。这是因为与上述相同的原因，即他们可以通信，因此我们不能允许他们切换进程。</target>
        </trans-unit>
        <trans-unit id="4a86ff11f18e76ef15af55380e0e783a222b5261" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in a window which was opened by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. These windows must remain in the same process as their opener, as they can communicate, meaning that we cannot allow them to switch processes.</source>
          <target state="translated">具有 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头的文档已加载到由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; 或其他类似方法打开的窗口中，而未设置 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 功能。这些窗口必须保持与打开程序相同的进程，因为它们可以通信，这意味着我们不能允许它们切换进程。</target>
        </trans-unit>
        <trans-unit id="99747b44d362c4206f7c42047a6a2ac0e7e63002" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. Firefox cannot move an iframe into a new process currently, so the document must load in the current process.</source>
          <target state="translated">具有 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头的文档已加载到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 中&lt;/a&gt;。Firefox当前无法将iframe移动到新进程中，因此文档必须在当前进程中加载​​。</target>
        </trans-unit>
        <trans-unit id="a6f2c4f6f26722715e92610972343c812a59e653" translate="yes" xml:space="preserve">
          <source>The domain name of the forwarded server.</source>
          <target state="translated">转发服务器的域名。</target>
        </trans-unit>
        <trans-unit id="063cfa7dcd340bc61f1b1e374717469ae3ca0edf" translate="yes" xml:space="preserve">
          <source>The domain name of the server (for virtual hosting) or the IP.</source>
          <target state="translated">服务器的域名(用于虚拟主机)或IP。</target>
        </trans-unit>
        <trans-unit id="950978a8462def38d2b11b8a3fe9cb368d430082" translate="yes" xml:space="preserve">
          <source>The ePrivacy Directive in the EU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fdd0cbf82278b018fbbaf65a8801167da2e6c8" translate="yes" xml:space="preserve">
          <source>The effect of certain methods performed on a resource at the origin
   server might cause one or more existing cache entries to become non-
   transparently invalid. That is, although they might continue to be
   &quot;fresh,&quot; they do not accurately reflect what the origin server would
   return for a new request on that resource. 

   There is no way for the HTTP protocol to guarantee that all such
   cache entries are marked invalid. For example, the request that
   caused the change at the origin server might not have gone through
   the proxy where a cache entry is stored. However, several rules help
   reduce the likelihood of erroneous behavior.

   In this section, the phrase &quot;invalidate an entity&quot; means that the
   cache will either remove all instances of that entity from its
   storage, or will mark these as &quot;invalid&quot; and in need of a mandatory
   revalidation before they can be returned in response to a subsequent
   request.

   Some HTTP methods MUST cause a cache to invalidate an entity. This is
   either the entity referred to by the Request-URI, or by the Location
   or Content-Location headers (if present). These methods are:

      - PUT

      - DELETE

      - POST

   In order to prevent denial of service attacks, an invalidation based
   on the URI in a Location or Content-Location header MUST only be
   performed if the host part is the same as in the Request-URI.

   A cache that passes through requests for methods it does not
   understand SHOULD invalidate any entities referred to by the
   Request-URI.</source>
          <target state="translated">在源服务器上对资源执行的某些方法的影响可能会导致一个或多个现有的缓存条目变得非透明无效。也就是说,虽然它们可能继续是 &quot;新鲜的&quot;,但它们并不能准确地反映出源服务器对该资源的新请求所返回的内容。HTTP协议没有办法保证所有这样的缓存条目都被标记为无效。例如,在源服务器上引起变化的请求可能没有经过存储缓存条目的代理。然而,有几条规则有助于降低错误行为的可能性。在本节中,短语 &quot;使一个实体无效 &quot;意味着缓存将从它的存储中删除该实体的所有实例,或者将这些实例标记为 &quot;无效&quot;,并且在响应后续请求之前需要强制重新验证。有些HTTP方法必须使缓存无效化一个实体。这要么是Request-URI,要么是Location或Content-Location头(如果存在的话)所指的实体。这些方法是-PUT-DELETE-POST 为了防止拒绝服务攻击,基于Location或Content-Location头中的URI的无效化必须在主机部分与Request-URI相同的情况下进行。缓存通过请求它不理解的方法时,应该使Request-URI所引用的任何实体无效。</target>
        </trans-unit>
        <trans-unit id="d5ae0833fdb7faa042296f4443d9009502223ddd" translate="yes" xml:space="preserve">
          <source>The encoding algorithm, usually a &lt;a href=&quot;compression&quot;&gt;compression algorithm&lt;/a&gt;, that can be used on the resource sent back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96733518a6ff2858b2648088ac99a8575b177584" translate="yes" xml:space="preserve">
          <source>The entity-body (if any) sent with an HTTP request or response is in
   a format and encoding defined by the entity-header fields.

       entity-body    = *OCTET

   An entity-body is only present in a message when a message-body is
   present, as described in &lt;a href=&quot;#section-4.3&quot;&gt;section 4.3&lt;/a&gt;. The entity-body is obtained
   from the message-body by decoding any Transfer-Encoding that might
   have been applied to ensure safe and proper transfer of the message.</source>
          <target state="translated">与HTTP请求或响应一起发送的实体（如果有的话）采用由实体头字段定义的格式和编码。实体-主体= * OCTET实体-主体仅在消息主体存在时出现在消息中，如&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;所述。通过解码可能已应用来确保安全和正确传输消息的任何Transfer-Encoding，可以从消息主体获取实体主体。</target>
        </trans-unit>
        <trans-unit id="446ffc851c64954297de6b7856c3aaf1d655d3fb" translate="yes" xml:space="preserve">
          <source>The entity-length of a message is the length of the message-body
   before any transfer-codings have been applied. &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; defines
   how the transfer-length of a message-body is determined.</source>
          <target state="translated">消息的实体长度是在应用任何传输编码之前消息主体的长度。&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;定义了如何确定消息正文的传输长度。</target>
        </trans-unit>
        <trans-unit id="430808f49439af4bf0997780d867503fb8ae80aa" translate="yes" xml:space="preserve">
          <source>The equivalent &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response would have included the headers &lt;a href=&quot;../headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/content-location&quot;&gt;&lt;code&gt;Content-Location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">等效的&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 响应将包括标头&lt;a href=&quot;../headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../headers/content-location&quot;&gt; &lt;code&gt;Content-Location&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69c5ab4621c4edd07f710f991794d1e78a2f9d36" translate="yes" xml:space="preserve">
          <source>The exact directive for setting headers depends on your web server. In Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6274c604e308e30d74c2f35a4f5fe3102aafe5" translate="yes" xml:space="preserve">
          <source>The exact resource identified by an Internet request is determined by
   examining both the Request-URI and the Host header field.

   An origin server that does not allow resources to differ by the
   requested host MAY ignore the Host header field value when
   determining the resource identified by an HTTP/1.1 request. (But see
   &lt;a href=&quot;#section-19.6.1.1&quot;&gt;section 19.6.1.1&lt;/a&gt; for other requirements on Host support in HTTP/1.1.)

   An origin server that does differentiate resources based on the host
   requested (sometimes referred to as virtual hosts or vanity host
   names) MUST use the following rules for determining the requested
   resource on an HTTP/1.1 request:

   1. If Request-URI is an absoluteURI, the host is part of the
     Request-URI. Any Host header field value in the request MUST be
     ignored.

   2. If the Request-URI is not an absoluteURI, and the request includes
     a Host header field, the host is determined by the Host header
     field value.

   3. If the host as determined by rule 1 or 2 is not a valid host on
     the server, the response MUST be a 400 (Bad Request) error message.

   Recipients of an HTTP/1.0 request that lacks a Host header field MAY
   attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to determine what
   exact resource is being requested.</source>
          <target state="translated">通过检查Request-URI和Host标头字段来确定Internet请求标识的确切资源。在确定由HTTP / 1.1请求标识的资源时，不允许资源因请求的主机而异的原始服务器可以忽略Host标头字段值。（但请参阅 &lt;a href=&quot;#section-19.6.1.1&quot;&gt;第19.6.1.1节&lt;/a&gt;有关HTTP / 1.1中对主机支持的其他要求。）根据原始主机（有时称为虚拟主机或虚名主机名）来区分资源的原始服务器必须使用以下规则来确定HTTP / 1.1上的请求资源1.1请求：1.如果Request-URI是absoluteURI，则主机是Request-URI的一部分。请求中的任何主机头字段值都必须忽略。 2.如果Request-URI不是absoluteURI，并且请求包含一个Host标头字段，则主机由Host标头字段值确定。 3.如果规则1或2所确定的主机不是服务器上的有效主机，则响应必须为400（错误请求）错误消息。缺少Host标头字段的HTTP / 1.0请求的接收者可以尝试使用启发式（例如，检查URI路径以查找特定主机所独有的内容），以便确定请求的确切资源。</target>
        </trans-unit>
        <trans-unit id="b7709fb173b9a7682e88163b1524346d08926812" translate="yes" xml:space="preserve">
          <source>The example above creates an XML body to send with the &lt;code&gt;POST&lt;/code&gt; request. Also, a non-standard HTTP &lt;code&gt;X-PINGOTHER&lt;/code&gt; request header is set. Such headers are not part of HTTP/1.1, but are generally useful to web applications. Since the request uses a &lt;code&gt;Content-Type&lt;/code&gt; of &lt;code&gt;application/xml&lt;/code&gt;, and since a custom header is set, this request is preflighted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d41666eafa2d743345a256aece9bd1b22af0421" translate="yes" xml:space="preserve">
          <source>The examples at the end of this document are complete. There is no additional syntax needed to save it into a file and use it. (Of course, the JavaScripts must be edited to reflect your site's domain name and/or subnets.)</source>
          <target state="translated">本文档末尾的例子是完整的。没有额外的语法需要将其保存到一个文件中并使用它。当然,必须对JavaScripts进行编辑,以反映您网站的域名和/或子网)。</target>
        </trans-unit>
        <trans-unit id="4044137ba9e4a5b42152e40cc16d223426864ffc" translate="yes" xml:space="preserve">
          <source>The exception to this is if the worker script's origin is a globally unique identifier (for example, if its URL has a scheme of data or blob). In this case, the worker does inherit the content security policy of the document or worker that created it.</source>
          <target state="translated">例外情况是,如果worker脚本的来源是一个全球唯一的标识符(例如,如果它的URL具有数据或blob的方案)。在这种情况下,工作者确实继承了创建它的文档或工作者的内容安全策略。</target>
        </trans-unit>
        <trans-unit id="25060abe4601e57cbdab7b0fcd2e4d780cee3888" translate="yes" xml:space="preserve">
          <source>The expectation given in an Expect request-header field (see &lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) could not be met by this server, or, if the server is a proxy,
   the server has unambiguous evidence that the request could not be met
   by the next-hop server.</source>
          <target state="translated">此服务器无法满足在Expect请求标头字段（请参见&lt;a href=&quot;#section-14.20&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20 &lt;/a&gt;节）中给出的期望，或者，如果该服务器是代理，则该服务器有明确的证据表明下一跳服务器无法满足该请求。 。</target>
        </trans-unit>
        <trans-unit id="e89474435ba5cceae8038928368d478ddd9d1651" translate="yes" xml:space="preserve">
          <source>The expected size of the allocation to be performed, in megabytes.</source>
          <target state="translated">要执行的分配的预期大小,以兆字节为单位。</target>
        </trans-unit>
        <trans-unit id="ed4c70c74d035f0ea716b0ccb4bd9c7c87a82ce4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;headers/accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7187b470d2aaa46b6160031b6302821aeaad40ea" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="translated">实验性&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt;列出了服务器可以使用的配置数据，以选择适当的响应。有效值为：</target>
        </trans-unit>
        <trans-unit id="4c1f313837ffc811f5a2970246c6c36e4cf61462" translate="yes" xml:space="preserve">
          <source>The expiration time is computed as follows:</source>
          <target state="translated">过期时间的计算方法如下:</target>
        </trans-unit>
        <trans-unit id="85e3770a3188fd2db74ea558b54fe9b64ff2f7c6" translate="yes" xml:space="preserve">
          <source>The expiration time of an entity MAY be specified by the origin
   server using the Expires header (see &lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;). Alternatively,
   it MAY be specified using the max-age directive in a response. When
   the max-age cache-control directive is present in a cached response,
   the response is stale if its current age is greater than the age
   value given (in seconds) at the time of a new request for that
   resource. The max-age directive on a response implies that the
   response is cacheable (i.e., &quot;public&quot;) unless some other, more
   restrictive cache directive is also present.

   If a response includes both an Expires header and a max-age
   directive, the max-age directive overrides the Expires header, even
   if the Expires header is more restrictive. This rule allows an origin
   server to provide, for a given response, a longer expiration time to
   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be
   useful if certain HTTP/1.0 caches improperly calculate ages or
   expiration times, perhaps due to desynchronized clocks.

   Many HTTP/1.0 cache implementations will treat an Expires value that
   is less than or equal to the response Date value as being equivalent
   to the Cache-Control response directive &quot;no-cache&quot;. If an HTTP/1.1
   cache receives such a response, and the response does not include a
   Cache-Control header field, it SHOULD consider the response to be
   non-cacheable in order to retain compatibility with HTTP/1.0 servers.

       Note: An origin server might wish to use a relatively new HTTP
       cache control feature, such as the &quot;private&quot; directive, on a
       network including older caches that do not understand that
       feature. The origin server will need to combine the new feature
       with an Expires field whose value is less than or equal to the
       Date value. This will prevent older caches from improperly
       caching the response. 

   s-maxage
       If a response includes an s-maxage directive, then for a shared
       cache (but not for a private cache), the maximum age specified by
       this directive overrides the maximum age specified by either the
       max-age directive or the Expires header. The s-maxage directive
       also implies the semantics of the proxy-revalidate directive (see
       &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt;), i.e., that the shared cache must not use the
       entry after it becomes stale to respond to a subsequent request
       without first revalidating it with the origin server. The s-
       maxage directive is always ignored by a private cache.

   Note that most older caches, not compliant with this specification,
   do not implement any cache-control directives. An origin server
   wishing to use a cache-control directive that restricts, but does not
   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the
   requirement that the max-age directive overrides the Expires header,
   and the fact that pre-HTTP/1.1-compliant caches do not observe the
   max-age directive.

   Other directives allow a user agent to modify the basic expiration
   mechanism. These directives MAY be specified on a request:

   max-age
      Indicates that the client is willing to accept a response whose
      age is no greater than the specified time in seconds. Unless max-
      stale directive is also included, the client is not willing to
      accept a stale response.

   min-fresh
      Indicates that the client is willing to accept a response whose
      freshness lifetime is no less than its current age plus the
      specified time in seconds. That is, the client wants a response
      that will still be fresh for at least the specified number of
      seconds.

   max-stale
      Indicates that the client is willing to accept a response that has
      exceeded its expiration time. If max-stale is assigned a value,
      then the client is willing to accept a response that has exceeded
      its expiration time by no more than the specified number of
      seconds. If no value is assigned to max-stale, then the client is
      willing to accept a stale response of any age.

   If a cache returns a stale response, either because of a max-stale
   directive on a request, or because the cache is configured to
   override the expiration time of a response, the cache MUST attach a
   Warning header to the stale response, using Warning 110 (Response is
   stale). 

   A cache MAY be configured to return stale responses without
   validation, but only if this does not conflict with any &quot;MUST&quot;-level
   requirements concerning cache validation (e.g., a &quot;must-revalidate&quot;
   cache-control directive).

   If both the new request and the cached entry include &quot;max-age&quot;
   directives, then the lesser of the two values is used for determining
   the freshness of the cached entry for that request.</source>
          <target state="translated">实体的到期时间可以由原始服务器使用Expires标头指定（参见&lt;a href=&quot;#section-14.21&quot;&gt;第14.21节）&lt;/a&gt;）。或者，可以在响应中使用max-age指令指定它。当缓存响应中存在max-age cache-control指令时，如果响应的当前年龄大于对该资源的新请求时给定的年龄值（以秒为单位），则该响应为过时的。响应上的max-age指令表示该响应是可缓存的（即&amp;ldquo;公共&amp;rdquo;），除非还存在其他一些限制性更强的缓存指令。如果响应中同时包含Expires标头和max-age指令，则即使Expires标头的限制性更强，max-age指令也会覆盖Expires标头。此规则允许源服务器针对给定的响应，为HTTP / 1.1（或更高版本）缓存提供比HTTP / 1.0缓存更长的到期时间。如果某些HTTP / 1.0缓存可能由于时钟不同步而无法正确计算使用期限或到期时间，则这可能很有用。许多HTTP / 1.0缓存实现会将小于或等于响应日期值的Expires值视为等同于Cache-Control响应指令&amp;ldquo; no-cache&amp;rdquo;。如果HTTP / 1.1缓存接收到这样的响应，并且该响应不包含Cache-Control头字段，则它应将响应视为不可缓存的，以保持与HTTP / 1.0服务器的兼容性。注意：源服务器可能希望在网络上使用相对较新的HTTP缓存控制功能，例如&amp;ldquo; private&amp;rdquo;指令，该网络包括不了解该功能的较早缓存。原始服务器将需要将新功能与值小于或等于日期值的Expires字段组合。这将防止较早的缓存不适当地缓存响应。 s-maxage如果响应中包含s-maxage指令，则对于共享缓存（但不针对私有缓存），此指令指定的最大期限将覆盖max-age指令或Expires标头指定的最大期限。 s-maxage指令还暗含了proxy-revalidate指令的语义（请参阅然后对于共享缓存（而不是专用缓存），此伪指令指定的最大期限将覆盖max-age伪指令或Expires标头指定的最大期限。 s-maxage指令还暗含了proxy-revalidate指令的语义（请参阅然后对于共享缓存（而不是专用缓存），此伪指令指定的最大期限将覆盖max-age伪指令或Expires标头指定的最大期限。 s-maxage指令还暗含了proxy-revalidate指令的语义（请参阅 &lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节&lt;/a&gt;），即，共享缓存在失效之前不能使用该条目来响应后续请求，而不必先通过原始服务器对其进行验证。专用高速缓存始终会忽略s-maxage指令。请注意，大多数不符合此规范的较早的缓存均未实现任何缓存控制指令。希望使用缓存控制指令限制但不阻止HTTP / 1.1兼容的缓存的原始服务器可以利用max-age指令覆盖Expires标头的要求以及HTTP之前的事实兼容/1.1的缓存不遵守max-age指令。其他指令允许用户代理修改基本到期机制。这些指令可以在请求中指定：max-age表示客户端愿意接受其年龄不超过指定时间（以秒为单位）的响应。除非还包括maxstale指令，否则客户端将不愿接受过时的响应。 min-fresh表示客户端愿意接受其新鲜度寿命不小于其当前时间加上指定时间（以秒为单位）的响应。也就是说，客户端希望响应至少在指定的秒数内仍保持新鲜。 max-stale表示客户端愿意接受超过其到期时间的响应。如果为max-stale分配了一个值，那么客户端愿意接受超过其到期时间不超过指定秒数的响应。如果没有为max-stale分配任何值，则客户端愿意接受任何年龄的过时响应。如果由于请求中的max-stale指令，或者由于将高速缓存配置为覆盖响应的过期时间而使高速缓存返回了过期响应，则高速缓存务必使用警告110将警告标头附加到过期响应中（响应已过期）。可以将缓存配置为不进行验证就返回过期响应，但前提是该缓存不与任何有关缓存验证的&amp;ldquo;必须&amp;rdquo;级要求（例如，&amp;ldquo;必须重新验证&amp;rdquo;缓存控制指令）相冲突。如果新请求和缓存条目均包含&amp;ldquo; max-age&amp;rdquo;指令，则使用两个值中的较小者来确定该请求的缓存条目的新鲜度。</target>
        </trans-unit>
        <trans-unit id="a65d812882b0aba90b93b31c9c8f523446f0f382" translate="yes" xml:space="preserve">
          <source>The features include (see &lt;a href=&quot;headers/feature-policy#Directives&quot;&gt;Features list&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3993f15811c93a67d3ec5d0d92f253093020cabe" translate="yes" xml:space="preserve">
          <source>The features include:</source>
          <target state="translated">其特点包括:</target>
        </trans-unit>
        <trans-unit id="c73ddc20bc1d282151f4ec68084bc6164972b4dc" translate="yes" xml:space="preserve">
          <source>The file consists of a function called &lt;code&gt;FindProxyForURL&lt;/code&gt;. The example below will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">该文件包含一个名为 &lt;code&gt;FindProxyForURL&lt;/code&gt; 的函数。以下示例将在设置内部DNS服务器的环境中工作，使其只能解析内部主机名，并且目标是仅对无法解析的主机使用代理：</target>
        </trans-unit>
        <trans-unit id="ce8df497bc37efd316beaa79c7a58e65942dbc0b" translate="yes" xml:space="preserve">
          <source>The file firefox.js passes preference names and values to the pref() function. For example:</source>
          <target state="translated">文件firefox.js将偏好名称和值传递给pref()函数。例如</target>
        </trans-unit>
        <trans-unit id="5b3cb207abfe237d7efa942f6a8fef274b6ca29a" translate="yes" xml:space="preserve">
          <source>The final block is a data block, which contains the optional data.</source>
          <target state="translated">最后一个块是数据块,其中包含了可选的数据。</target>
        </trans-unit>
        <trans-unit id="82d496b5f7760cf0c1c546e8d1a28c4fc534cf8d" translate="yes" xml:space="preserve">
          <source>The final block is an optional data block, which may contain further data mainly used by the POST method.</source>
          <target state="translated">最后一个数据块是一个可选的数据块,它可能包含主要由POST方法使用的进一步数据。</target>
        </trans-unit>
        <trans-unit id="45bd5c32307d77b9998e20d89babbacc1a08c8ee" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;OPTIONS&lt;/code&gt;, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477b8ca70c884ab091243f614c5d70eeeab51fd8" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, DELETE, or OPTIONS, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="translated">请求的最后一部分是它的主体。并非所有请求都具有一个请求：诸如 &lt;code&gt;GET&lt;/code&gt; ， &lt;code&gt;HEAD&lt;/code&gt; ，DELETE或OPTIONS之类的获取资源的请求通常不需要一个。一些请求将数据发送到服务器以对其进行更新：与 &lt;code&gt;POST&lt;/code&gt; 请求（包含HTML表单数据）一样。</target>
        </trans-unit>
        <trans-unit id="a7bd7db1836bd8959bc7e0d7e27321e685761ca2" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="translated">请求的最终接收者应该反映接收到消息，不包括一些字段下面描述的，返回给客户端为具有一个200（OK）响应的消息主体&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;message/http&lt;/code&gt; 。最终收件人是原始服务器或第一个在请求中接收&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt;值的服务器。</target>
        </trans-unit>
        <trans-unit id="fa5fe1af847469a3d3023206916eb30deabd5583" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec16b4ce596bd77bc971178dc4e6a8899896e2cb" translate="yes" xml:space="preserve">
          <source>The first 40 characters of the inline script, event handler, or style that caused the violation.</source>
          <target state="translated">导致违规的内联脚本、事件处理程序或样式的前40个字符。</target>
        </trans-unit>
        <trans-unit id="30b3cc93d61693c25216e29c69eecc3a87dde174" translate="yes" xml:space="preserve">
          <source>The first line contains a request method followed by its parameters:</source>
          <target state="translated">第一行包含一个请求方法,后面是其参数。</target>
        </trans-unit>
        <trans-unit id="0ce913e069990d2088bde8127d92db28b9c6593c" translate="yes" xml:space="preserve">
          <source>The first line of a Response message is the Status-Line, consisting
   of the protocol version followed by a numeric status code and its
   associated textual phrase, with each element separated by SP
   characters. No CR or LF is allowed except in the final CRLF sequence.

       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</source>
          <target state="translated">响应消息的第一行是状态行,由协议版本组成,后面是一个数字状态码及其相关的文字短语,每个元素用SP字符分隔。除最后的CRLF序列外,不允许有CR或LF。状态行=HTTP-Version SP状态码SP理由短语CRLF(CRLF)</target>
        </trans-unit>
        <trans-unit id="34ccf4b003a3910dffb0926766714dc4dd11b6eb" translate="yes" xml:space="preserve">
          <source>The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another
   space, a possibly empty textual phrase describing the status code,
   and ending with CRLF.

     status-line = HTTP-version SP status-code SP reason-phrase CRLF

   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request.  The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt; for information about the semantics of
   status codes, including the classes of status code (indicated by the
   first digit), the status codes defined by this specification,
   considerations for the definition of new status codes, and the IANA
   registry.

     status-code    = 3DIGIT

   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were
   more frequently used with interactive text clients.  A client SHOULD
   ignore the reason-phrase content.

     reason-phrase  = *( HTAB / SP / VCHAR / obs-text )</source>
          <target state="translated">响应消息的第一行是状态行，由协议版本，空格（SP），状态代码，另一个空格，描述状态代码的可能为空的文本短语组成，并以CRLF结尾。 status-line = HTTP版本SP状态代码SP原因短语CRLF状态代码元素是一个3位整数代码，描述服务器尝试理解并满足客户端相应请求的结果。响应消息的其余部分将根据为该状态代码定义的语义进行解释。参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]的第6节&lt;/a&gt;有关状态码语义的信息，包括状态码的类别（由第一位数字表示），由本规范定义的状态码，对新状态码的定义的注意事项以及IANA注册中心。 status-code = 3DIGIT原因短语元素的存在仅是为了提供与数字状态代码关联的文本描述，这主要是出于对较早用于交互式文本客户端的Internet应用程序协议的尊重。客户应忽略原因短语内容。原因短语= *（HTAB / SP / VCHAR / obs-text）</target>
        </trans-unit>
        <trans-unit id="83e62459a880f4c5afe20430a0ef17081dbab746" translate="yes" xml:space="preserve">
          <source>The first line, the &lt;em&gt;status line&lt;/em&gt;, consists of an acknowledgment of the HTTP version used, followed by a status request (and its brief meaning in human-readable text).</source>
          <target state="translated">第一行是&lt;em&gt;状态行&lt;/em&gt;，由对所使用的HTTP版本的确认以及随后的状态请求（及其在人类可读文本中的简短含义）组成。</target>
        </trans-unit>
        <trans-unit id="5ae099fefbfad76e3dc77d1838fdc9c03df6ff4f" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is always &lt;code&gt;form-data&lt;/code&gt;. Additional parameters are case-insensitive and have arguments that use quoted-string syntax after the &lt;code&gt;'='&lt;/code&gt; sign. Multiple parameters are separated by a semi-colon (&lt;code&gt;';'&lt;/code&gt;).</source>
          <target state="translated">HTTP上下文中的第一个参数始终是 &lt;code&gt;form-data&lt;/code&gt; 。其他参数不区分大小写，并且在 &lt;code&gt;'='&lt;/code&gt; 符号后使用引号字符串语法的参数。多个参数之间用分号（ &lt;code&gt;';'&lt;/code&gt; ）分隔。</target>
        </trans-unit>
        <trans-unit id="1fe827f01fdf9c514ffb2a7b42770124ec3e2359" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is either &lt;code&gt;inline&lt;/code&gt; (default value, indicating it can be displayed inside the Web page, or as the Web page) or &lt;code&gt;attachment&lt;/code&gt; (indicating it should be downloaded; most browsers presenting a 'Save as' dialog, prefilled with the value of the &lt;code&gt;filename&lt;/code&gt; parameters if present).</source>
          <target state="translated">HTTP上下文中的第一个参数是 &lt;code&gt;inline&lt;/code&gt; （默认值，表明可以在网页内显示，也可以作为网页显示）或 &lt;code&gt;attachment&lt;/code&gt; （指示应下载；大多数浏览器会先显示&amp;ldquo;另存为&amp;rdquo;对话框）加上 &lt;code&gt;filename&lt;/code&gt; 参数的值（如果存在）。</target>
        </trans-unit>
        <trans-unit id="ce28a16fac0b2bc02f8a3ca48fc7babba03c0403" translate="yes" xml:space="preserve">
          <source>The first time your site is accessed using HTTPS and it returns the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, the browser records this information, so that future attempts to load the site using HTTP will automatically use HTTPS instead.</source>
          <target state="translated">首次使用HTTPS访问您的站点并返回 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; 标头时，浏览器会记录此信息，以便将来使用HTTP加载站点的尝试将自动使用HTTPS。</target>
        </trans-unit>
        <trans-unit id="36a8e92e02612d193d4f4ea4835f02c068455028" translate="yes" xml:space="preserve">
          <source>The first upload of a resource is an edge case of the previous. Like any update of a resource, it is subject to a race condition if two clients try to perform at the similar times. To prevent this, conditional requests can be used: by adding &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; with the special value of &lt;code&gt;'*'&lt;/code&gt;, representing any etag. The request will succeed, only if the resource didn't exist before:</source>
          <target state="translated">资源的首次上传是前一个资源的优势。像任何资源更新一样，如果两个客户端尝试在相同的时间执行资源，则该资源也会受到争用条件的影响。为防止这种情况，可以使用条件请求：通过添加具有特殊值 &lt;code&gt;'*'&lt;/code&gt; 的&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;来表示任何etag。仅当资源之前不存在时，请求才会成功：</target>
        </trans-unit>
        <trans-unit id="cc100946d8979f9ce8df35a1f6c26e450e867343" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91a68110a72942d37f1a34f4d6ec060c7f1376a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;被阻止，无法加载：</target>
        </trans-unit>
        <trans-unit id="d9b73c421a277665ab08a8298b8930b892f83d26" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485ecd6f231e048f16edaf6c17d5ccf5b1cb2429" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;被阻止，无法加载：</target>
        </trans-unit>
        <trans-unit id="63f869c917c180bee24835b4bf30ef56f30bb133" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;被阻止，无法加载：</target>
        </trans-unit>
        <trans-unit id="2bd3ab38162171d160acbfdeffc4df3e7c14c331" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素被阻止并且不会加载：</target>
        </trans-unit>
        <trans-unit id="af33c524092efa46a9bc5e3da17591ca7a2dfed3" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;元素被阻止并且不会加载：</target>
        </trans-unit>
        <trans-unit id="613e74e65709c0a5a289fb76a70fe4d72cdf7122" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">以下 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc90632d3761290b941626aad0314e6c02769a1e" translate="yes" xml:space="preserve">
          <source>The following Java code sets CORS response headers. Notice how the code sets the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">以下Java代码设置了CORS响应标头。注意，代码如何将 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 值设置为与&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;请求标头相同的值。</target>
        </trans-unit>
        <trans-unit id="94255118119d25126914c95e1d87df4cff5fadb0" translate="yes" xml:space="preserve">
          <source>The following are all valid JavaScript MIME types according to the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt;.</source>
          <target state="translated">以下是根据&lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME嗅探标准的&lt;/a&gt;所有有效JavaScript MIME类型。</target>
        </trans-unit>
        <trans-unit id="81369c9bb8b849666e492d12305470dc3ab76aac" translate="yes" xml:space="preserve">
          <source>The following command will extract the Base64 encoded information for a website.</source>
          <target state="translated">以下命令将提取一个网站的Base64编码信息。</target>
        </trans-unit>
        <trans-unit id="386280384a9e1e846fc762abee1b45fa8528a42c" translate="yes" xml:space="preserve">
          <source>The following commands will help you extract the Base64 encoded information from a key file, a certificate signing request, or a certificate.</source>
          <target state="translated">以下命令将帮助你从密钥文件、证书签名请求或证书中提取Base64编码信息。</target>
        </trans-unit>
        <trans-unit id="509ad4a6b5b143b75559c314a8f0880abef072e8" translate="yes" xml:space="preserve">
          <source>The following connections are blocked and won't load:</source>
          <target state="translated">以下连接被阻止,无法加载。</target>
        </trans-unit>
        <trans-unit id="ce04653c2a877eee1709cad576d94e84ea8ac4bc" translate="yes" xml:space="preserve">
          <source>The following cookie will be rejected if set by a server hosted on &lt;code&gt;example.com&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f830b6e4479681c906a8958ca927a242872bc6bc" translate="yes" xml:space="preserve">
          <source>The following cookie will be rejected if set by a server hosted on &lt;code&gt;originalcompany.com&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41623b548495875f7a172266a4ccbfc78a26525c" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF
   (line feed), OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible US-ASCII character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     RWS           = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     comment       = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     partial-URI   = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt; 

     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），HTAB（水平标签），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符）。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：BWS = &amp;lt;BWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; RWS = &amp;lt;RWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]， 3.2.3节&lt;/a&gt; &amp;gt; URI引用= &amp;lt;URI引用，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt;&amp;gt; absolute-URI = &amp;lt;绝对URI，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt; &amp;gt; comment = &amp;lt;注释，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt; field-name = &amp;lt;注释，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]，第3.2节&lt;/a&gt; &amp;gt; 部分- URI = &amp;lt;部分URI，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;引用的字符串，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt; token = &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c0942541cf8ef1d402170eff33c293ebc3cc0b4" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   Note that all rules derived from token are to be compared
   case-insensitively, like range-unit and acceptable-ranges.

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS        = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     token      = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date  = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;
     entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符） ）。请注意，所有源自令牌的规则都应不区分大小写地进行比较，例如range-unit和acceptable-ranges。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt;令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;以下规则在其他部分中定义：HTTP -date = &amp;lt;HTTP日期，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]，第7.1.1.1节&lt;/a&gt; &amp;gt;实体标签= &amp;lt;实体标签，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]，第2.3节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb819c2dfc07123960d680297955265860aae754" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符） ）。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：BWS = &amp;lt;BWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="af8790fbb4ed65c1be1cf1a4b4f340c4491c4f9d" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     pseudonym     = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符） ）。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt;字段名= &amp;lt;字段名，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]，第3.2节&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string ，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;端口= &amp;lt;端口，看到&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]第2.7节&lt;/a&gt; &amp;gt;假名= &amp;lt;假名，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]第5.7.1节&lt;/a&gt; &amp;gt; uri-host = &amp;lt;uri-host，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]第2.7节&lt;/a&gt; &amp;gt;以下规则在其他部分中定义：HTTP- date = &amp;lt;HTTP日期，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]，第7.1.1.1节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="bde3f83ba4fdea6e1247cb746890cdb2c25a10cd" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     obs-text      = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符） ）。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：OWS = &amp;lt;OWS，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; obs-text = &amp;lt;obs-text，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;以下规则在其他部分：HTTP日期= &amp;lt;HTTP日期，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]，第7.1.1.1节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="8084bb34a7c23d1e9e812c435cfc66928e96c80b" translate="yes" xml:space="preserve">
          <source>The following example shows the same copy operation being performed,
   but with the Overwrite header set to &quot;F.&quot; A response of 412
   (Precondition Failed) is returned because the destination URL is
   already mapped to a resource.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html
     Overwrite: F 

   &amp;gt;&amp;gt;Response

     HTTP/1.1 412 Precondition Failed</source>
          <target state="translated">下面的示例显示了相同的复制操作，但是Overwrite标头设置为&amp;ldquo; F&amp;rdquo;。由于目标URL已映射到资源，因此返回412（前提条件失败）响应。&amp;gt;&amp;gt;请求COPY /~fielding/index.html HTTP / 1.1主机：www.example.com目的地：http://www.example.com/users/f/fielding/index.html覆盖：F &amp;gt;&amp;gt;响应HTTP / 1.1 412前提条件失败</target>
        </trans-unit>
        <trans-unit id="8d3395be0d0b51b8ffa7605b7ec7844c4e4a39c7" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to &lt;code&gt;foo.example&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acf3453f8031411e0b71e19213cb90990e8cb3a" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to foo.example.</source>
          <target state="translated">下面的例子指定了证书透明度的执行时间为24小时,并向foo.example报告违规行为。</target>
        </trans-unit>
        <trans-unit id="94b32d3de424f684aa74d5609ddab84fb75dd925" translate="yes" xml:space="preserve">
          <source>The following font resource loading is blocked and won't load:</source>
          <target state="translated">以下字体资源加载受阻,无法加载。</target>
        </trans-unit>
        <trans-unit id="354531c678665d3125c2ef3c1112692d5b4fe889" translate="yes" xml:space="preserve">
          <source>The following headers are involved in the WebSocket upgrade process. Other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, the rest are generally optional or handled for you by the browser and server when they're talking to each other.</source>
          <target state="translated">WebSocket升级过程涉及以下头。除了&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头外，其余的通常是可选的，或者由浏览器和服务器在彼此通信时为您处理。</target>
        </trans-unit>
        <trans-unit id="bb8db65f4711517dd753e17a8cd07fb37a9810cb" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted.</source>
          <target state="translated">下面是一个将被预亮的请求的例子。</target>
        </trans-unit>
        <trans-unit id="f2caa1f526d805ff5feea71e36486901a1b33c7b" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6166015c4ad889984ba227b210f2740bda4740b4" translate="yes" xml:space="preserve">
          <source>The following line with your relevant key information (pin-sha256=&quot;...&quot; fields) will enable HPKP on lighttpd.</source>
          <target state="translated">以下一行加上您的相关密钥信息(pin-sha256=&quot;...&quot;字段)将启用lighttpd上的HPKP。</target>
        </trans-unit>
        <trans-unit id="2ae960e358cb5178ea4e99046d9b426fbe630cc9" translate="yes" xml:space="preserve">
          <source>The following list summarizes HTTP headers by their usage category. For an alphabetical list, see the navigation on the left side.</source>
          <target state="translated">下面的列表按照使用类别总结了HTTP头文件。按字母顺序排列的列表,请参见左侧的导航。</target>
        </trans-unit>
        <trans-unit id="eb997113b54cfb7ed6ae28493a5cfaf71d6f764b" translate="yes" xml:space="preserve">
          <source>The following request body for a PROPFIND method is illegal.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
       &amp;lt;D:propname/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The definition of the propfind element only allows for the allprop or
   the propname element, not both.  Thus, the above is an error and must
   be responded to with a 400 (Bad Request).

   Imagine, however, that a server wanted to be &quot;kind&quot; and decided to
   pick the allprop element as the true element and respond to it.  A
   client running over a bandwidth limited line who intended to execute
   a propname would be in for a big surprise if the server treated the
   command as an allprop.

   Additionally, if a server were lenient and decided to reply to this
   request, the results would vary randomly from server to server, with
   some servers executing the allprop directive, and others executing
   the propname directive.  This reduces interoperability rather than
   increasing it.</source>
          <target state="translated">以下对PROPFIND方法的请求正文是非法的。 &amp;lt;？xml version =&amp;ldquo; 1.0&amp;rdquo; encoding =&amp;ldquo; utf-8&amp;rdquo;吗？&amp;gt; &amp;lt;D：propfind xmlns：D =&amp;ldquo; DAV：&amp;rdquo;&amp;gt; &amp;lt;D：allprop /&amp;gt; &amp;lt;D：propname /&amp;gt; &amp;lt;/ D：propfind&amp;gt;定义该propfind元素仅允许allprop或propname元素，而不能同时允许两者。因此，以上内容是错误，必须使用400（错误请求）进行响应。但是，想象一下，一个服务器想成为&amp;ldquo;同类&amp;rdquo;服务器，并决定选择allprop元素作为真正的元素并做出响应。如果服务器将命令视为allprop，则在带宽受限的行上运行并打算执行propname的客户端将大吃一惊。此外，如果服务器宽容并决定回复此请求，结果会随服务器的不同而随机变化，其中一些服务器执行allprop指令，而其他服务器执行propname指令。这会降低互操作性，而不是增加互操作性。</target>
        </trans-unit>
        <trans-unit id="afe5b5f9e1c6d81603d280407ff45a5bd4095d77" translate="yes" xml:space="preserve">
          <source>The following request header fields are sent by a user agent to
   engage in proactive negotiation of the response content, as defined
   in &lt;a href=&quot;#section-3.4.1&quot;&gt;Section 3.4.1&lt;/a&gt;.  The preferences sent in these fields apply to any
   content in the response, including representations of the target
   resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear
   within the protocol.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | Accept            | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt; |
   | Accept-Charset    | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt; |
   | Accept-Encoding   | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   | Accept-Language   | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">以下请求标头字段由用户代理发送，以参与对响应内容的主动协商，如&lt;a href=&quot;#section-3.4.1&quot;&gt;第3.4.1节中&lt;/a&gt;所定义。在这些字段中发送的首选项适用于响应中的任何内容，包括目标资源的表示，错误或处理状态的表示，甚至可能会出现在协议中的其他文本字符串。 + ------------------- + --------------- + |标头字段名称|定义于... | + ------------------- + --------------- + |接受| &lt;a href=&quot;#section-5.3.2&quot;&gt;第5.3.2节&lt;/a&gt; | |接受字符集| &lt;a href=&quot;#section-5.3.3&quot;&gt;第5.3.3节&lt;/a&gt; | |接受编码| &lt;a href=&quot;#section-5.3.4&quot;&gt;第5.3.4节&lt;/a&gt; | |接受语言| &lt;a href=&quot;#section-5.3.5&quot;&gt;第5.3.5节&lt;/a&gt;| + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="b87d45a3e8d029bf68f7eb8d73ed362bd6af38eb" translate="yes" xml:space="preserve">
          <source>The following request header fields provide additional information
   about the request context, including information about the user, user
   agent, and resource behind the request.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | From              | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | Referer           | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | User-Agent        | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">以下请求标头字段提供有关请求上下文的其他信息，包括有关用户，用户代理和请求背后资源的信息。+ ------------------- + --------------- + | 标头字段名称| 定义于... | + ------------------- + --------------- + | 来自| &lt;a href=&quot;#section-5.5.1&quot;&gt;第5.5.1节&lt;/a&gt; | | 推荐人| &lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt; | | 用户代理| &lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节&lt;/a&gt; | + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="0c838a2a126c25c04d28baea5afb318e21afbddd" translate="yes" xml:space="preserve">
          <source>The following rules are used throughout this specification to
   describe basic parsing constructs. The US-ASCII coded character set
   is defined by ANSI X3.4-1986 [&lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]. 

       OCTET          = &amp;lt;any 8-bit sequence of data&amp;gt;
       CHAR           = &amp;lt;any US-ASCII character (octets 0 - 127)&amp;gt;
       UPALPHA        = &amp;lt;any US-ASCII uppercase letter &quot;A&quot;..&quot;Z&quot;&amp;gt;
       LOALPHA        = &amp;lt;any US-ASCII lowercase letter &quot;a&quot;..&quot;z&quot;&amp;gt;
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = &amp;lt;any US-ASCII digit &quot;0&quot;..&quot;9&quot;&amp;gt;
       CTL            = &amp;lt;any US-ASCII control character
                        (octets 0 - 31) and DEL (127)&amp;gt;
       CR             = &amp;lt;US-ASCII CR, carriage return (13)&amp;gt;
       LF             = &amp;lt;US-ASCII LF, linefeed (10)&amp;gt;
       SP             = &amp;lt;US-ASCII SP, space (32)&amp;gt;
       HT             = &amp;lt;US-ASCII HT, horizontal-tab (9)&amp;gt;
       &amp;lt;&quot;&amp;gt;            = &amp;lt;US-ASCII double-quote mark (34)&amp;gt;

   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all
   protocol elements except the entity-body (see appendix 19.3 for
   tolerant applications). The end-of-line marker within an entity-body
   is defined by its associated media type, as described in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;.

       CRLF           = CR LF

   HTTP/1.1 header field values can be folded onto multiple lines if the
   continuation line begins with a space or horizontal tab. All linear
   white space, including folding, has the same semantics as SP. A
   recipient MAY replace any linear white space with a single SP before
   interpreting the field value or forwarding the message downstream.

       LWS            = [CRLF] 1*( SP | HT )

   The TEXT rule is only used for descriptive field contents and values
   that are not intended to be interpreted by the message parser. Words
   of *TEXT MAY contain characters from character sets other than ISO-
   8859-1 [&lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt;] only when encoded according to the rules of &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

       TEXT           = &amp;lt;any OCTET except CTLs,
                        but including LWS&amp;gt;

   A CRLF is allowed in the definition of TEXT only as part of a header
   field continuation. It is expected that the folding LWS will be
   replaced with a single SP before interpretation of the TEXT value.

   Hexadecimal numeric characters are used in several protocol elements.

       HEX            = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
                      | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | DIGIT 

   Many HTTP/1.1 header field values consist of words separated by LWS
   or special characters. These special characters MUST be in a quoted
   string to be used within a parameter value (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;).

       token          = 1*&amp;lt;any CHAR except CTLs or separators&amp;gt;
       separators     = &quot;(&quot; | &quot;)&quot; | &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;@&quot;
                      | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &amp;lt;&quot;&amp;gt;
                      | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                      | &quot;{&quot; | &quot;}&quot; | SP | HT

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.
   In all other fields, parentheses are considered part of the field
   value.

       comment        = &quot;(&quot; *( ctext | quoted-pair | comment ) &quot;)&quot;
       ctext          = &amp;lt;any TEXT excluding &quot;(&quot; and &quot;)&quot;&amp;gt;

   A string of text is parsed as a single word if it is quoted using
   double-quote marks.

       quoted-string  = ( &amp;lt;&quot;&amp;gt; *(qdtext | quoted-pair ) &amp;lt;&quot;&amp;gt; )
       qdtext         = &amp;lt;any TEXT except &amp;lt;&quot;&amp;gt;&amp;gt;

   The backslash character (&quot;\&quot;) MAY be used as a single-character
   quoting mechanism only within quoted-string and comment constructs.

       quoted-pair    = &quot;\&quot; CHAR</source>
          <target state="translated">在整个说明书中，使用以下规则来描述基本的解析结构。US-ASCII编码字符集由ANSI X3.4-1986 [&lt;a href=&quot;#ref-21&quot;&gt; 21&lt;/a&gt;]。 OCTET = &amp;lt;任何8位数据序列&amp;gt; CHAR = &amp;lt;任何US-ASCII字符（八位字节0-127）&amp;gt; UPALPHA = &amp;lt;任何US-ASCII大写字母&amp;ldquo; A&amp;rdquo; ..&amp;ldquo; Z&amp;rdquo;&amp;gt; LOALPHA = &amp;lt;任何US-ASCII ASCII小写字母&amp;ldquo; a&amp;rdquo; ..&amp;ldquo; z&amp;rdquo;&amp;gt; ALPHA = UPALPHA | LOALPHA DIGIT = &amp;lt;任何US-ASCII数字&amp;ldquo; 0&amp;rdquo; ..&amp;ldquo; 9&amp;rdquo;&amp;gt; CTL = &amp;lt;任何US-ASCII控制字符（八位字节0-31）和DEL（127）&amp;gt; CR = &amp;lt;US-ASCII CR，回车（ 13）&amp;gt; LF = &amp;lt;US-ASCII LF，换行（10）&amp;gt; SP = &amp;lt;US-ASCII SP，空格（32）&amp;gt; HT = &amp;lt;US-ASCII HT，水平制表符（9）&amp;gt; &amp;lt;&amp;ldquo;&amp;gt; = &amp;lt;US-ASCII双引号（34）&amp;gt; HTTP / 1.1将序列CR LF定义为除实体主体之外的所有协议元素的行尾标记（有关允许的应用，请参见附录19.3）。实体中的行尾标记由其关联的媒体类型定义，如&lt;a href=&quot;#section-3.7&quot;&gt;第3.7节&lt;/a&gt;。如果继续行以空格或水平制表符开头，则CRLF = CR LF HTTP / 1.1标头字段值可以折叠为多行。所有线性空白（包括折叠）都具有与SP相同的语义。接收者可以在解释字段值或向下游转发消息之前用单个SP替换任何线性空格。 LWS = [CRLF] 1 *（SP | HT）TEXT规则仅用于描述性字段内容和消息解析器不打算解释的值。 * TEXT单词仅当按照&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt; ]的规则编码时，可能包含ISO-8859-1 [ &lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt; ] 以外的字符集中的字符]。 TEXT = &amp;lt;除CTL之外但包括LWS的任何OCTET&amp;gt; TEXT的定义中仅允许CRLF作为标头字段继续的一部分。预期在解释TEXT值之前，将折叠LWS替换为单个SP。十六进制数字字符用于多个协议元素。十六进制=&amp;ldquo; A&amp;rdquo; | &amp;ldquo; B&amp;rdquo; | &amp;ldquo; C&amp;rdquo; | &amp;ldquo; D&amp;rdquo; | &amp;ldquo; E&amp;rdquo; | &amp;ldquo; F&amp;rdquo; | &amp;ldquo; a&amp;rdquo; | &amp;ldquo; b&amp;rdquo; | &amp;ldquo; c&amp;rdquo; | &amp;ldquo; d&amp;rdquo; | &amp;ldquo; e&amp;rdquo; | &amp;ldquo; f&amp;rdquo; | DIGIT许多HTTP / 1.1标头字段值由用LWS或特殊字符分隔的单词组成。这些特殊字符必须在带引号的字符串中，以便在参数值中使用（如本&lt;a href=&quot;#section-3.6&quot;&gt;节中所定义）&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;这些特殊字符必须在带引号的字符串中，以在参数值中使用（如3.6&lt;/a&gt;）。令牌= 1 * &amp;lt;除CTL或分隔符外的任何CHAR&amp;gt;分隔符=&amp;ldquo;（&amp;rdquo; |&amp;ldquo;）&amp;rdquo; | &amp;ldquo; &amp;lt;&amp;rdquo; | &amp;ldquo;&amp;gt;&amp;rdquo; | &amp;ldquo; @&amp;rdquo; | &amp;ldquo;，&amp;rdquo; | &amp;ldquo;;&amp;rdquo; | &amp;ldquo;：&amp;rdquo; | &amp;ldquo; \&amp;rdquo; | &amp;lt;&amp;ldquo;&amp;gt; |&amp;rdquo; /&amp;ldquo; |&amp;rdquo; [&amp;ldquo; |&amp;rdquo;]&amp;ldquo; |&amp;rdquo;？&amp;ldquo; |&amp;rdquo; =&amp;ldquo; |&amp;rdquo; {&amp;ldquo; |&amp;rdquo;}&amp;ldquo; | SP | HT通过将注释文本括在中间，可以将注释包含在某些HTTP标头字段中圆括号。仅在包含&amp;ldquo;注释&amp;rdquo;作为其字段值定义的一部分的字段中才允许使用注释。在所有其他字段中，圆括号被视为字段值的一部分。comment =&amp;ldquo;（&amp;rdquo; *（ctext | quoted-pair | comment）&amp;ldquo; ）&amp;rdquo;ctext = &amp;lt;不含&amp;ldquo;（&amp;rdquo;和&amp;ldquo;）&amp;rdquo;的任何文本&amp;ldquo;&amp;gt;如果使用双引号将文本字符串引用，则将其解析为单个单词。 quoted-string =（&amp;lt;&amp;ldquo;&amp;gt; *（qdtext | quoted-pair）&amp;lt;&amp;rdquo;&amp;gt;）qdtext = &amp;lt;除&amp;lt;&amp;ldquo; &amp;gt;&amp;gt;之外的任何文本反斜杠字符（&amp;rdquo; \&amp;ldquo;）只能在带引号的字符串和注释构造。quoted-pair =&amp;ldquo; \&amp;rdquo; CHAR）只能在带引号的字符串和注释构造中用作单字符引用机制。 quoted-pair =&amp;ldquo; \&amp;rdquo; CHAR）只能在带引号的字符串和注释构造中用作单字符引用机制。 quoted-pair =&amp;ldquo; \&amp;rdquo; CHAR</target>
        </trans-unit>
        <trans-unit id="94fbcc64e65bdd0aa51395bd7a796209855490ba" translate="yes" xml:space="preserve">
          <source>The following sections describe the LOCK method, which is used to
   take out a lock of any access type and to refresh an existing lock.
   These sections on the LOCK method describe only those semantics that
   are specific to the LOCK method and are independent of the access
   type of the lock being requested.

   Any resource that supports the LOCK method MUST, at minimum, support
   the XML request and response formats defined herein.

   This method is neither idempotent nor safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">以下各节介绍LOCK方法，该方法用于取出任何访问类型的锁并刷新现有的锁。LOCK方法的这些部分仅描述LOCK方法特有的语义，并且与所请求锁的访问类型无关。任何支持LOCK方法的资源都必须至少支持本文定义的XML请求和响应格式。此方法既不是幂等也不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="abeecd90959a6815a68add2040eb84d9caaab598" translate="yes" xml:space="preserve">
          <source>The following status codes are added to those defined in HTTP/1.1
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].</source>
          <target state="translated">将以下状态代码添加到HTTP / 1.1 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中定义的状态代码中。</target>
        </trans-unit>
        <trans-unit id="9b6537480c704b017f88ab825b88e92592b9fb1e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the way major browser vendors indicate that their browsers are running on a mobile device:</source>
          <target state="translated">下表总结了主要浏览器厂商表示其浏览器在移动设备上运行的方式。</target>
        </trans-unit>
        <trans-unit id="84d447214f0a07951f17fa8b161dc87650490e95" translate="yes" xml:space="preserve">
          <source>The format for &lt;code&gt;data&lt;/code&gt; URLs is very simple, but it's easy to forget to put a comma before the &quot;data&quot; segment, or to incorrectly encode the data into base64 format.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; URL 的格式非常简单，但是很容易忘记在&amp;ldquo;数据&amp;rdquo;段前加上逗号，或者将数据错误地编码为base64格式。</target>
        </trans-unit>
        <trans-unit id="d7ba8c7d265a4018beb38838d1f5b22bd2735b93" translate="yes" xml:space="preserve">
          <source>The format problem might be due to the request's indicated &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, or as a result of inspecting the data directly.</source>
          <target state="translated">格式问题可能是由于请求所指示的&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;，或者是直接检查数据的结果。</target>
        </trans-unit>
        <trans-unit id="f6417d40b5bbb94e0ab0361d59b5efbe6a9c03d8" translate="yes" xml:space="preserve">
          <source>The forward slash (&lt;code&gt;/&lt;/code&gt;) character is interpreted as a directory separator, and subdirectories will be matched as well: for &lt;code&gt;Path=/docs&lt;/code&gt;, &lt;code&gt;/docs&lt;/code&gt;, &lt;code&gt;/docs/Web/&lt;/code&gt;, and &lt;code&gt;/docs/Web/HTTP&lt;/code&gt; will all match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd102c31666a18bf73247dbe968b9437a20ca82e" translate="yes" xml:space="preserve">
          <source>The forwarded protocol (http or https).</source>
          <target state="translated">转发协议(http或https)。</target>
        </trans-unit>
        <trans-unit id="5ad0214c4fd4e5e15f5b8411cc3e3ac722291550" translate="yes" xml:space="preserve">
          <source>The framework for HTTP Authentication is now defined by this
   document, rather than &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.

   The &quot;realm&quot; parameter is no longer always required on challenges;
   consequently, the ABNF allows challenges without any auth parameters.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   The &quot;token68&quot; alternative to auth-param lists has been added for
   consistency with legacy authentication schemes such as &quot;Basic&quot;.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   This specification introduces the Authentication Scheme Registry,
   along with considerations for new authentication schemes.
   (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)</source>
          <target state="translated">现在，此文档而不是&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;定义了HTTP身份验证的框架。挑战不再总是需要&amp;ldquo; realm&amp;rdquo;参数；因此，ABNF允许没有任何身份验证参数的挑战。 （&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;）已添加auth-param列表的&amp;ldquo; token68&amp;rdquo;替代项，以与诸如&amp;ldquo; Basic&amp;rdquo;之类的传统身份验证方案保持一致。 （&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;）本规范介绍了身份验证方案注册表，以及对新身份验证方案的注意事项。 （&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4d91b5b813304e8a213249cb1c603b64a74abb68" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-Control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81a90a6f49982e97eba3c1cef4effa451cb6b9f" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime. Finally, if neither header is present, look for a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; header. If this header is present, then the cache's freshness lifetime is equal to the value of the &lt;code&gt;Date&lt;/code&gt; header minus the value of the &lt;code&gt;Last-modified&lt;/code&gt; header divided by 10.</source>
          <target state="translated">新鲜度寿命是基于多个标头计算的。如果指定了&amp;ldquo; &lt;code&gt;Cache-control: max-age=N&lt;/code&gt; &amp;rdquo;标头，则新鲜度生存期等于N。如果不存在此标头（通常是这种情况），则检查是否存在&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;标头。如果存在 &lt;code&gt;Expires&lt;/code&gt; 标头，则其值减去&lt;a href=&quot;headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;标头的值将确定保鲜期。最后，如果两个标题都不存在，请查找&amp;ldquo; &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &amp;rdquo;&lt;/a&gt;标题。如果存在此标头，则高速缓存的新鲜度生存期等于 &lt;code&gt;Date&lt;/code&gt; 标头的值减去 &lt;code&gt;Last-modified&lt;/code&gt; 标头的值除以10。</target>
        </trans-unit>
        <trans-unit id="512b0319b59cba71ca1e2c65af451cb82702e739" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework</source>
          <target state="translated">一般的HTTP认证框架</target>
        </trans-unit>
        <trans-unit id="2a68383800c3c6e98cc63558c863f3f6c90c1d56" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework is used by several authentication schemes. Schemes can differ in security strength and in their availability in client or server software.</source>
          <target state="translated">一般的HTTP认证框架被几种认证方案所使用。这些方案在安全强度和在客户端或服务器软件中的可用性方面可以有所不同。</target>
        </trans-unit>
        <trans-unit id="047e5f84cba0657a76fe5fac248fc74bc7cb3a90" translate="yes" xml:space="preserve">
          <source>The general principle is that there should be an intuitive or non-breaking way for web developers to detect or handle the case when the feature is disabled. Newly introduced features may have an explicit API to signal the state. Existing features that later integrate with Feature Policy will typically use existing mechanisms. Some approaches include:</source>
          <target state="translated">总的原则是,当功能被禁用时,应该有一种直观的或非破坏性的方式让Web开发人员检测或处理该功能的情况。新引入的功能可能会有一个明确的API来发出状态信号。现有的功能如果以后与功能策略集成,通常会使用现有的机制。一些方法包括:</target>
        </trans-unit>
        <trans-unit id="4082c3c3add497840e14f2e91b541fe68c6e3568" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; attribute is used on HTML elements to indicate the language of an entire &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; document or parts of it.</source>
          <target state="translated">全局 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; 属性用于HTML元素，以指示整个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt;文档或部分文档的语言。</target>
        </trans-unit>
        <trans-unit id="57f2be6c87684acab7e795f4366c55ff9f31e0e7" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between :// and the first : or / after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="translated">从URL中提取的主机名。这只是为了方便起见,它与://和后面的第一个:或/之间的字符串相同。端口号不包含在这个参数中。必要时可以从URL中提取。</target>
        </trans-unit>
        <trans-unit id="5f24db479cf2b72fa937bcb464d99834bc0f6796" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between &lt;code&gt;://&lt;/code&gt; and the first &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b2c30b24be1ada27dc38a1f58fce4304459396" translate="yes" xml:space="preserve">
          <source>The hostname from the URL (excluding port number).</source>
          <target state="translated">来自URL的主机名(不包括端口号)。</target>
        </trans-unit>
        <trans-unit id="e2ca20155497fac3b42eb54e6e58c4e5f8398358" translate="yes" xml:space="preserve">
          <source>The hostname from the URL.</source>
          <target state="translated">URL中的主机名。</target>
        </trans-unit>
        <trans-unit id="7bcc834a08945d7f53b90ecdf02df16cd4cbc61a" translate="yes" xml:space="preserve">
          <source>The identity and the location of resources on the Web are mostly given by a single URL (Uniform Resource Locator, a kind of URI). There are sometimes reasons identity and location are not given by the same URI: HTTP uses a specific HTTP header, &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; when the resource requested wants the client to access it at another location.</source>
          <target state="translated">Web上资源的标识和位置通常由单个URL（统一资源定位器，一种URI）给出。有时会有相同的URI不能给出身份和位置的原因：当请求的资源希望客户端在另一个位置访问HTTP时，HTTP使用特定的HTTP标头&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1e67e8b2786357d4a6663a2bc15f636eb756e8f" translate="yes" xml:space="preserve">
          <source>The iframe allow attribute</source>
          <target state="translated">iframe的允许属性</target>
        </trans-unit>
        <trans-unit id="651815c795a02ba38593f0882335db6d832e2b91" translate="yes" xml:space="preserve">
          <source>The implementation of this prefetching in some browsers allows domain name resolution to occur in parallel with (instead of in serial with) the fetching of actual page content. By doing this, the high-latency domain name resolution process doesn't cause any delay while fetching content.</source>
          <target state="translated">在一些浏览器中实现这种预取功能,可以使域名解析与实际页面内容的获取同步进行(而不是串行进行)。通过这样做,高延迟的域名解析过程不会在获取内容时造成任何延迟。</target>
        </trans-unit>
        <trans-unit id="37f7cdd7fd1331a83928f974ca15680ae3b0af4f" translate="yes" xml:space="preserve">
          <source>The inclusion of the &quot;app:draft&quot; element represents a request by the
   client to control the visibility of a Member Resource.  The app:draft
   element MAY be ignored by the server.

   The number of app:draft elements in app:control MUST be zero or one.
   The content of an app:draft element MUST be one of &quot;yes&quot; or &quot;no&quot;.  If
   the element contains &quot;no&quot;, this indicates a client request that the
   Member Resource be made publicly visible.  If the app:draft element
   is not present, then servers that support the extension MUST behave
   as though an app:draft element containing &quot;no&quot; was sent.</source>
          <target state="translated">包含 &quot;app:draft &quot;元素表示客户端请求控制成员资源的可见性。app:draft 元素可以被服务器忽略。app:control 中的 app:draft 元素的数量必须为 0 或 1。app:draft 元素的内容必须是 &quot;yes &quot;或 &quot;no &quot;中的一个。如果该元素包含 &quot;no&quot;,则表示客户端请求将成员资源公开可见。如果不存在 app:draft 元素,那么支持扩展的服务器必须像发送包含 &quot;no &quot;的 app:draft 元素一样行事。</target>
        </trans-unit>
        <trans-unit id="ff9cab94e579758912dbc34c45bff0d14c466bcf" translate="yes" xml:space="preserve">
          <source>The information below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">以下信息已从MDN的GitHub（&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;）中提取。</target>
        </trans-unit>
        <trans-unit id="89f19b58853606bc26aa103de926f33f0228de47" translate="yes" xml:space="preserve">
          <source>The information by the client is quite verbose (HTTP/2 header compression mitigates this problem) and a privacy risk (HTTP fingerprinting)</source>
          <target state="translated">客户端提供的信息相当啰嗦(HTTP/2头压缩缓解了这个问题),而且存在隐私风险(HTTP指纹)。</target>
        </trans-unit>
        <trans-unit id="88371e0de52c1ea4ce93bd3a2050533f57795785" translate="yes" xml:space="preserve">
          <source>The information shown below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">下面显示的信息已从MDN的GitHub（&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;）中提取。</target>
        </trans-unit>
        <trans-unit id="3cf93a0d825024937b080186cbf88ae3afde9002" translate="yes" xml:space="preserve">
          <source>The initial range unit registry contains the registrations below:

   +-------------+---------------------------------------+-------------+
   | Range Unit  | Description                           | Reference   |
   | Name        |                                       |             |
   +-------------+---------------------------------------+-------------+
   | bytes       | a range of octets                     | &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt; |
   | none        | reserved as keyword, indicating no    | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   |             | ranges are supported                  |             |
   +-------------+---------------------------------------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">初始范围单位注册表包含以下注册：+ ------------- + ------------------------- -------------- + ------------- + |范围单位|描述参考| |姓名| | | + ------------- + ----------------------------------- ---- + ------------- + |字节|八位字节的范围| &lt;a href=&quot;#section-2.1&quot;&gt;第2.1节&lt;/a&gt; | |无|保留为关键字，表示否| &lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt; | | |支持范围| | + ------------- + ----------------------------------- ---- + ------------- +更改控制者为：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ebd17564840526ee148efdaf203fca839e5379a4" translate="yes" xml:space="preserve">
          <source>The initial version of HTTP had no version number; it has been later called 0.9 to differentiate it from the later versions. HTTP/0.9 is extremely simple: requests consist of a single line and start with the only possible method &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; followed by the path to the resource (not the URL as both the protocol, server, and port are unnecessary once connected to the server).</source>
          <target state="translated">HTTP的初始版本没有版本号。它后来被称为0.9，以区别于更高版本。HTTP / 0.9非常简单：请求由一行组成，并以唯一可能的方法&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;开头，后跟资源的路径（而不是URL，因为一旦连接到服务器，就不需要协议，服务器和端口）。</target>
        </trans-unit>
        <trans-unit id="aa546185419767d20a05e2cb4df36ea1b19d66d3" translate="yes" xml:space="preserve">
          <source>The interface where the request came in to the proxy server.</source>
          <target state="translated">请求进入代理服务器的界面。</target>
        </trans-unit>
        <trans-unit id="7c3952a320aa0697f4c57ed16e077bfea2eed9ae" translate="yes" xml:space="preserve">
          <source>The introduction of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt;&lt;code&gt;Client-Hints&lt;/code&gt;&lt;/a&gt; allows the browser, or client, to proactively communicate information about its requirements, or hardware constraints, to the server.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt; &lt;code&gt;Client-Hints&lt;/code&gt; &lt;/a&gt;的引入使浏览器或客户端可以将有关其要求或硬件限制的信息主动传达给服务器。</target>
        </trans-unit>
        <trans-unit id="b38d9075a389a16460fcd684d2635f8653d50eed" translate="yes" xml:space="preserve">
          <source>The introduction of security-related prefixes in the &lt;a href=&quot;../headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header, now helps guarantee a secure cookie has not been altered.</source>
          <target state="translated">&lt;a href=&quot;../headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;标头中引入了与安全性相关的前缀，现在可以帮助确保安全的cookie未被更改。</target>
        </trans-unit>
        <trans-unit id="5e730b1eec3af5f9a050a8a9662df02e4c7599c2" translate="yes" xml:space="preserve">
          <source>The issued request looks like this:</source>
          <target state="translated">发出的请求是这样的。</target>
        </trans-unit>
        <trans-unit id="c84804fc4afa331bf0f09b76ea2770dfd6b62155" translate="yes" xml:space="preserve">
          <source>The key for this request to upgrade. The client adds this if it wishes to do so, and the server will include in the response a key of its own, which the client will validate before delivering the upgrade response to you.</source>
          <target state="translated">本次请求升级的密钥。客户端如果愿意的话会添加这个,服务器会在响应中包含一个自己的密钥,客户端会在向你发送升级响应之前验证这个密钥。</target>
        </trans-unit>
        <trans-unit id="9a15e6847a0ff9b62775caf043875cd4c43edfc3" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   An implementation is not compliant if it fails to satisfy one or more
   of the MUST or REQUIRED level requirements for the protocols it
   implements. An implementation that satisfies all the MUST or REQUIRED
   level and all the SHOULD level requirements for its protocols is said
   to be &quot;unconditionally compliant&quot;; one that satisfies all the MUST
   level requirements but not all the SHOULD level requirements for its
   protocols is said to be &quot;conditionally compliant.&quot;</source>
          <target state="translated">本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应不&amp;rdquo;，&amp;ldquo;建议&amp;rdquo;，&amp;ldquo;可&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;按照&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]中的描述进行解释。如果某个实现无法满足其实现的协议的一个或多个&amp;ldquo;必须&amp;rdquo;或&amp;ldquo;必需&amp;rdquo;级别要求，则它不符合要求。满足其协议的所有MUST或REQUIRED级别以及所有SHOULD级别要求的实现被称为&amp;ldquo;无条件兼容&amp;rdquo;。满足所有MUST级别要求但不满足其协议的所有SHOULD级别要求的协议被称为&amp;ldquo;有条件地兼容&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9a4a2293d2f84b8a5fd8f2e4def5c748288282ce" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].</source>
          <target state="translated">本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;不应&amp;rdquo;，&amp;ldquo;建议&amp;rdquo;，&amp;ldquo;可以&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;是按照[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]中所述进行解释。</target>
        </trans-unit>
        <trans-unit id="f9eac2de940bf2c082a5aa542b14155a2665a0ba" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.</source>
          <target state="translated">本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;不应&amp;rdquo;，&amp;ldquo;建议&amp;rdquo;，&amp;ldquo;可以&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;是按照[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]中所述进行解释。关于错误处理的符合性标准和注意事项在&lt;a href=&quot;#section-2.5&quot;&gt;2.5节&lt;/a&gt;中定义。</target>
        </trans-unit>
        <trans-unit id="6a63eeb5f4d9a57b187d7fb929309ed70bf0dbac" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;Section&amp;nbsp;2.5 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;不应&amp;rdquo;，&amp;ldquo;建议&amp;rdquo;，&amp;ldquo;可以&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;是按照[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]中所述进行解释。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;[RFC7230]的2.5节&lt;/a&gt;中定义了有关错误处理的符合性标准和注意事项。</target>
        </trans-unit>
        <trans-unit id="bb75c6ee1cca0ad36d986b0e355cb0e843e6e2f2" translate="yes" xml:space="preserve">
          <source>The kind of validation is independent of the validator used. Both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; allow both types of validation, though the complexity to implement it on the server side may vary. HTTP uses strong validation by default, and it specifies when weak validation can be used.</source>
          <target state="translated">验证的种类与所使用的验证器无关。双方&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; 标&lt;/a&gt;允许两种类型的验证，虽然复杂性来实现它在服务器端可能会有所不同。HTTP默认情况下使用强验证，它指定何时可以使用弱验证。</target>
        </trans-unit>
        <trans-unit id="d08a92729e395511c2581a4dfc33791c98b63230" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communication created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the companies, but SSL 2.0 and its successors SSL 3.0 and SSL 3.1 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with version 1.0, 1.1, and 1.2 appearing successfully to close vulnerabilities. TLS 1.3 is currently in the making.</source>
          <target state="translated">早在1994年底,HTTP就发生了最大的变化。网景通信公司没有在基本的TCP/IP协议栈上发送HTTP,而是在其上创建了一个额外的加密传输层。SSL SSL 1.0从未在公司外部发布,但SSL 2.0及其后续的SSL 3.0和SSL 3.1通过加密和保证服务器和客户端之间交换的消息的真实性,允许创建电子商务网站。SSL被纳入标准轨道,最终成为TLS,1.0、1.1、1.2版本的出现成功弥补了漏洞。目前TLS 1.3正在酝酿中。</target>
        </trans-unit>
        <trans-unit id="cedd0ab48b46862829d9707f126e162c35e1388c" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communications created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the company, but SSL 2.0 and its successor SSL 3.0 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with versions 1.0, 1.1, 1.2, and 1.3 appearing successfully to close vulnerabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afbff65f36ae363825e270b4816f35143b381cc" translate="yes" xml:space="preserve">
          <source>The last modification date of the resource, used to compare several versions of the same resource. It is less accurate than &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but easier to calculate in some environments. Conditional requests using &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9022ae767f477f1c7bcdb68243b1fa5a2efe966" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code that sufficiently answers the request without the need for corresponding payload (like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt;) usually don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01d212bb5fa98e344dced612706d97e4c48d614" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code, like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;, usually don't.</source>
          <target state="translated">回应的最后一部分是身体。并非所有响应都有一个：状态码（如&lt;a href=&quot;status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; )的&lt;/a&gt;响应通常没有。</target>
        </trans-unit>
        <trans-unit id="13fd2da68ff6f625ec41f864542e44b06721f081" translate="yes" xml:space="preserve">
          <source>The length in decimal number of octets.</source>
          <target state="translated">以十进制八位数为单位的长度。</target>
        </trans-unit>
        <trans-unit id="fc5fa9bc684bf265ecd239fcfb6b1be61af94a10" translate="yes" xml:space="preserve">
          <source>The length of a message body is determined by one of the following
   (in order of precedence):

   1.  Any response to a HEAD request and any response with a 1xx
       (Informational), 204 (No Content), or 304 (Not Modified) status
       code is always terminated by the first empty line after the
       header fields, regardless of the header fields present in the
       message, and thus cannot contain a message body.

   2.  Any 2xx (Successful) response to a CONNECT request implies that
       the connection will become a tunnel immediately after the empty
       line that concludes the header fields.  A client MUST ignore any
       Content-Length or Transfer-Encoding header fields received in
       such a message.

   3.  If a Transfer-Encoding header field is present and the chunked
       transfer coding (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) is the final encoding, the message
       body length is determined by reading and decoding the chunked
       data until the transfer coding indicates the data is complete.

       If a Transfer-Encoding header field is present in a response and
       the chunked transfer coding is not the final encoding, the
       message body length is determined by reading the connection until
       it is closed by the server.  If a Transfer-Encoding header field
       is present in a request and the chunked transfer coding is not
       the final encoding, the message body length cannot be determined
       reliably; the server MUST respond with the 400 (Bad Request)
       status code and then close the connection.

       If a message is received with both a Transfer-Encoding and a
       Content-Length header field, the Transfer-Encoding overrides the
       Content-Length.  Such a message might indicate an attempt to
       perform request smuggling (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;) or response splitting
       (&lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;) and ought to be handled as an error.  A sender MUST
       remove the received Content-Length field prior to forwarding such
       a message downstream.

   4.  If a message is received without Transfer-Encoding and with
       either multiple Content-Length header fields having differing
       field-values or a single Content-Length header field having an
       invalid value, then the message framing is invalid and the
       recipient MUST treat it as an unrecoverable error.  If this is a
       request message, the server MUST respond with a 400 (Bad Request)
       status code and then close the connection.  If this is a response
       message received by a proxy, the proxy MUST close the connection
       to the server, discard the received response, and send a 502 (Bad 

       Gateway) response to the client.  If this is a response message
       received by a user agent, the user agent MUST close the
       connection to the server and discard the received response.

   5.  If a valid Content-Length header field is present without
       Transfer-Encoding, its decimal value defines the expected message
       body length in octets.  If the sender closes the connection or
       the recipient times out before the indicated number of octets are
       received, the recipient MUST consider the message to be
       incomplete and close the connection.

   6.  If this is a request message and none of the above are true, then
       the message body length is zero (no message body is present).

   7.  Otherwise, this is a response message without a declared message
       body length, so the message body length is determined by the
       number of octets received prior to the server closing the
       connection.

   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.

   A server MAY reject a request that contains a message body but not a
   Content-Length by responding with 411 (Length Required).

   Unless a transfer coding other than chunked has been applied, a
   client that sends a request containing a message body SHOULD use a
   valid Content-Length header field if the message body length is known
   in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a 411 (Length Required)
   status code even though they understand the chunked transfer coding.
   This is typically because such services are implemented via a gateway
   that requires a content-length in advance of being called and the
   server is unable or unwilling to buffer the entire request before
   processing.

   A user agent that sends a request containing a message body MUST send
   a valid Content-Length header field if it does not know the server
   will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version
   of a prior received response.

   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user
   agent MAY discard the remaining data or attempt to determine if that 

   data belongs as part of the prior response body, which might be the
   case if the prior message's Content-Length value is incorrect.  A
   client MUST NOT process, cache, or forward such extra data as a
   separate response, since such behavior would be vulnerable to cache
   poisoning.</source>
          <target state="translated">消息正文的长度由以下一项（按优先级顺序）确定：1.对HEAD请求的任何响应以及任何带有1xx（信息性），204（无内容）或304（未修改）的响应状态消息始终由标头字段之后的第一个空行终止，而不管消息中存在的标头字段如何，因此状态代码不能包含消息正文。2.对CONNECT请求的任何2xx（成功）响应都意味着该连接将在结束标头字段的空行之后立即成为隧道。客户必须忽略在这样的消息中收到的任何Content-Length或Transfer-Encoding头字段。3.如果存在Transfer-Encoding标头字段，并且分块后的传输编码（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;）是最终编码，消息主体长度是通过读取和解码分块数据确定的，直到传输编码指示数据完成为止。如果响应中存在Transfer-Encoding头字段，并且分块的传输编码不是最终编码，则通过读取连接直到服务器将其关闭才确定消息主体的长度。如果请求中存在Transfer-Encoding头字段，并且分块的传输编码不是最终编码，则无法可靠地确定消息正文长度；服务器必须使用400（错误请求）状态码进行响应，然后关闭连接。如果同时收到带有传输编码和内容长度标头字段的消息，传输编码会覆盖内容长度。此类消息可能表示尝试执行请求走私（&lt;a href=&quot;#section-9.5&quot;&gt;9.5节&lt;/a&gt;）或响应拆分（&lt;a href=&quot;#section-9.4&quot;&gt; 9.4节）&lt;/a&gt;），应将其视为错误。发送者必须在向下游转发这样的消息之前删除接收到的Content-Length字段。 4.如果收到的消息没有传输编码，并且具有多个具有不同字段值的Content-Length头字段或具有无效值的单个Content-Length头字段，则该消息框架无效，并且接收者必须对其进行处理作为不可恢复的错误。如果这是一个请求消息，则服务器必须以400（错误请求）状态码响应，然后关闭连接。如果这是代理接收到的响应消息，则代理必须关闭与服务器的连接，丢弃接收到的响应，并向客户端发送502（错误网关）响应。如果这是用户代理收到的响应消息，则用户代理必须关闭与服务器的连接并丢弃收到的响应。 5.如果存在有效的Content-Length标头字段，但没有Transfer-Encoding，则其十进制值以八位字节定义期望的消息正文长度。如果发送方关闭了连接或接收方在接收到指定数量的八位字节之前超时，则接收方必须认为该消息不完整并关闭连接。 6.如果这是请求消息，并且以上都不是，则消息正文长度为零（不存在消息正文）。 7.否则，这是一条没有声明的消息正文长度的响应消息，因此，邮件正文长度由服务器关闭连接之前接收到的八位字节数确定。由于没有办法将成功完成的，用分隔符分隔的消息与由于网络故障而中断的部分接收的消息区分开，因此服务器应尽可能生成编码或用长度分隔的消息。存在封闭定界功能主要是为了与HTTP / 1.0向后兼容。服务器可以通过响应411（必需的长度）来拒绝包含消息正文但不包含内容长度的请求。除非已经应用了分块之外的传输编码，否则如果发送者预先知道消息主体的长度，则发送包含消息主体的请求的客户端应该使用有效的Content-Length标头字段，而不是分块传输编码，因为某些现有服务即使知道了分块传输编码，也会以411（所需长度）状态码响应分块。这通常是因为此类服务是通过网关实现的，该网关要求在被调用之前具有内容长度，并且服务器无法或不愿意在处理之前缓冲整个请求。发送包含消息正文的请求的用户代理，如果不知道服务器将处理HTTP / 1.1（或更高版本）请求，则必须发送有效的Content-Length标头字段；这些知识可以采用特定用户配置的形式，也可以通过记住先前收到的响应的版本来实现。如果已经完全接收到对连接上最后一个请求的最终响应，并且还有其他要读取的数据，则用户代理可以丢弃剩余的数据，或者尝试确定该数据是否属于先前响应主体的一部分，这可能是如果先前消息的Content-Length值不正确，则为这种情况。客户端绝不能处理，缓存或转发额外的数据作为单独的响应，因为这样的行为容易受到缓存中毒的影响。因为这样的行为很容易受到缓存中毒的影响。因为这样的行为很容易受到缓存中毒的影响。</target>
        </trans-unit>
        <trans-unit id="bc721cb7f57681a68e8ffe39db25deee64045b40" translate="yes" xml:space="preserve">
          <source>The lifetime of a cookie can be defined in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de35152ee3c77722bc9537cad929955d73dab593" translate="yes" xml:space="preserve">
          <source>The list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">允许的&lt;a href=&quot;../methods&quot;&gt;HTTP请求方法&lt;/a&gt;列表。</target>
        </trans-unit>
        <trans-unit id="2d4513b7f363144d73199955a36973cf7c46be3c" translate="yes" xml:space="preserve">
          <source>The maximum amount of time a resource is considered fresh. Unlike &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15263fb5ed512784dbb85f5e27d3d988105feb1f" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the detailed format. If not specified, the cookie will have the lifetime of a &lt;strong&gt;session cookie. &lt;/strong&gt;A session is finished when the client is shut down meaning that session cookies will get removed at that point. However, many web browsers have a feature called session restore that will save all your tabs and have them come back next time you use the browser. Cookies will also be present and it's like you had never actually closed the browser.</source>
          <target state="translated">Cookie的最长生存期，以HTTP日期为时间戳。有关详细格式，请参见&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;。如果未指定，则cookie将具有&lt;strong&gt;会话cookie&lt;/strong&gt;的生存期&lt;strong&gt;。&lt;/strong&gt;当客户端关闭时，会话结束，这意味着会话cookie将在此时被删除。但是，许多Web浏览器都具有称为会话还原的功能，该功能将保存您的所有标签页，并在您下次使用浏览器时再次显示。Cookies也会出现，就好像您从未真正关闭浏览器一样。</target>
        </trans-unit>
        <trans-unit id="d852a80087f1759845814ae78b7b6a4cc10fa2cf" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the required formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63c2c824f245057f299d57750e6b8789678a89a" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 32kB</source>
          <target state="translated">支持的最大尺寸为32kB</target>
        </trans-unit>
        <trans-unit id="c27432dd9f890b43b972ceef8be06ebeb078000d" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 4GB</source>
          <target state="translated">支持的最大容量为4GB</target>
        </trans-unit>
        <trans-unit id="6711070acb52353698f99e67ae8f7a23d80cf676" translate="yes" xml:space="preserve">
          <source>The meaning of a success depends on the HTTP request method:</source>
          <target state="translated">成功的意义取决于HTTP请求方法。</target>
        </trans-unit>
        <trans-unit id="ed1aebd9e25e31bb79bed64a7c6d90aa83890cf3" translate="yes" xml:space="preserve">
          <source>The media format of the requested data is not supported by the server, so the server is rejecting the request.</source>
          <target state="translated">服务器不支持请求数据的媒体格式,所以服务器拒绝该请求。</target>
        </trans-unit>
        <trans-unit id="6d8af46d85f95f2c6776a4511c1248db0db1fa9e" translate="yes" xml:space="preserve">
          <source>The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;.

     message-body = *OCTET

   The rules for when a message body is allowed in a message differ for
   requests and responses.

   The presence of a message body in a request is signaled by a
   Content-Length or Transfer-Encoding header field.  Request message
   framing is independent of method semantics, even if the method does
   not define any use for a message body.

   The presence of a message body in a response depends on both the
   request method to which it is responding and the response status code
   (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;).  Responses to the HEAD request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2
   of [RFC7231]&lt;/a&gt;) never include a message body because the associated
   response header fields (e.g., Transfer-Encoding, Content-Length,
   etc.), if present, indicate only what their values would have been if
   the request method had been GET (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;). 2xx
   (Successful) responses to a CONNECT request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;) switch to tunnel mode instead of having a message body.
   All 1xx (Informational), 204 (No Content), and 304 (Not Modified)
   responses do not include a message body.  All other responses do
   include a message body, although the body might be of zero length.</source>
          <target state="translated">HTTP消息的消息正文（如果有）用于承载该请求或响应的有效内容正文。消息主体与有效载荷主体相同，除非已应用传输编码（如&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节中&lt;/a&gt;所述）。 message-body = * OCTET对于请求和响应，何时在消息中允许消息正文的规则有所不同。通过Content-Length或Transfer-Encoding标头字段可以指示请求中消息正文的存在。请求消息框架独立于方法语义，即使该方法未定义消息主体的任何用法。响应中消息体的存在取决于它所响应的请求方法和响应状态代码（&lt;a href=&quot;#section-3.1.2&quot;&gt;第3.1.2节）&lt;/a&gt;）。对HEAD请求方法的响应（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;[RFC7231]的4.3.2节&lt;/a&gt;）从不包含消息正文，因为相关的响应标头字段（例如Transfer-Encoding，Content-Length等）（如果存在）仅指示其值如果请求方法是GET（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]的4.3.1节&lt;/a&gt;），则应该是这样。对CONNECT请求方法的2xx（成功）响应（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]的第4.3.6节）&lt;/a&gt;）切换到隧道模式，而不要显示消息正文。所有1xx（信息性），204（无内容）和304（未修改）响应均不包含消息正文。所有其他响应都包括消息正文，尽管该正文的长度可能为零。</target>
        </trans-unit>
        <trans-unit id="4e8aaa241374a41dac239673c7a83e9b31912343" translate="yes" xml:space="preserve">
          <source>The message header fields below should be added to the permanent
   registry (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;]).</source>
          <target state="translated">下面的消息头字段应添加到永久注册表中（请参阅[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; ]）。</target>
        </trans-unit>
        <trans-unit id="5e0a346350c18fe7ecba53dc40c76384937c220e" translate="yes" xml:space="preserve">
          <source>The message-body (if any) of an HTTP message is used to carry the
   entity-body associated with the request or response. The message-body
   differs from the entity-body only when a transfer-coding has been
   applied, as indicated by the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;).

       message-body = entity-body
                    | &amp;lt;entity-body encoded as per Transfer-Encoding&amp;gt;

   Transfer-Encoding MUST be used to indicate any transfer-codings
   applied by an application to ensure safe and proper transfer of the
   message. Transfer-Encoding is a property of the message, not of the 

   entity, and thus MAY be added or removed by any application along the
   request/response chain. (However, &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt; places restrictions on
   when certain transfer-codings may be used.)

   The rules for when a message-body is allowed in a message differ for
   requests and responses.

   The presence of a message-body in a request is signaled by the
   inclusion of a Content-Length or Transfer-Encoding header field in
   the request's message-headers. A message-body MUST NOT be included in
   a request if the specification of the request method (&lt;a href=&quot;#section-5.1.1&quot;&gt;section 5.1.1&lt;/a&gt;)
   does not allow sending an entity-body in requests. A server SHOULD
   read and forward a message-body on any request; if the request method
   does not include defined semantics for an entity-body, then the
   message-body SHOULD be ignored when handling the request.

   For response messages, whether or not a message-body is included with
   a message is dependent on both the request method and the response
   status code (&lt;a href=&quot;#section-6.1.1&quot;&gt;section 6.1.1&lt;/a&gt;). All responses to the HEAD request method
   MUST NOT include a message-body, even though the presence of entity-
   header fields might lead one to believe they do. All 1xx
   (informational), 204 (no content), and 304 (not modified) responses
   MUST NOT include a message-body. All other responses do include a
   message-body, although it MAY be of zero length.</source>
          <target state="translated">HTTP消息的消息主体（如果有）用于承载与请求或响应关联的实体主体。消息主体与实体主体只有在应用了传输编码时才有所不同，如Transfer-Encoding头字段所示（&lt;a href=&quot;#section-14.41&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41 &lt;/a&gt;节）。 message-body =实体-主体| &amp;lt;按Transfer-Encoding编码的实体-主体&amp;gt; Transfer-Encoding必须用于指示应用程序所应用的任何传输编码，以确保安全正确地传输消息。传输编码是消息的属性，而不是实体的属性，因此可以由请求/响应链中的任何应用程序添加或删除。 （但是，&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节&lt;/a&gt;对何时可以使用某些传输编码设置了限制。）何时在消息中允许消息正文的规则因请求和响应而异。通过在请求的消息头中包含Content-Length或Transfer-Encoding头字段，可以指示请求中消息主体的存在。如果请求方法的规范（&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节）&lt;/a&gt;，则消息正文不得包含在请求中）不允许在请求中发送实体。服务器应根据任何请求读取并转发消息正文；如果请求方法不包括为实体主体定义的语义，则在处理请求时应忽略消息主体。对于响应消息，消息中是否包含消息正文取决于请求方法和响应状态代码（&lt;a href=&quot;#section-6.1.1&quot;&gt;第6.1.1节&lt;/a&gt;）。对HEAD请求方法的所有响应都不得包含消息正文，即使实体标头字段的存在可能会使人相信它们确实也是如此。所有的1xx（信息性），204（无内容）和304（未修改）响应均不得包含消息正文。所有其他响应都包括一个消息正文，尽管它的长度可以为零。</target>
        </trans-unit>
        <trans-unit id="a40c2c2dfbf9c25f98c934df39c7f7ed182fe5cf" translate="yes" xml:space="preserve">
          <source>The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for
   all &quot;message&quot; types regarding line length and encodings.

   Type name:  message

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed message (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body.

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted 

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Magic number(s):  N/A

      Deprecated alias names for this type:  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">消息/ http类型可用于封装单个HTTP请求或响应消息，只要它遵守所有有关行长和编码的&amp;ldquo;消息&amp;rdquo;类型的MIME限制。类型名称：message子类型名称：http必需参数：N / A可选参数：version，msgtype version：所包含消息的HTTP版本号（例如&amp;ldquo; 1.1&amp;rdquo;）。如果不存在，则可以从正文的第一行确定版本。 msgtype：消息类型-&amp;ldquo;请求&amp;rdquo;或&amp;ldquo;响应&amp;rdquo;。如果不存在，则可以从主体的第一行确定类型。编码注意事项：仅允许使用&amp;ldquo; 7bit&amp;rdquo;，&amp;ldquo; 8bit&amp;rdquo;或&amp;ldquo; binary&amp;rdquo;安全性注意事项：见&lt;a href=&quot;#section-9&quot;&gt;第9节&lt;/a&gt; 互操作性注意事项：N / A发布的规范：此规范（请参阅&lt;a href=&quot;#section-8.3.1&quot;&gt;第8.3.1节&lt;/a&gt;）。使用此媒体类型的应用程序：N / A片段标识符注意事项：N / A其他信息：幻数：N / A此类型已弃用的别名：N / A文件扩展名：N / A Macintosh文件类型代码：N / A要获取更多信息，请联系个人和电子邮件地址：请参见作者地址部分。预期用途：公共使用限制：N / A作者：请参阅作者地址部分。变更负责人：IESG</target>
        </trans-unit>
        <trans-unit id="0249133f37d2157bb5d5d75cceeb4bf6c3634006" translate="yes" xml:space="preserve">
          <source>The method and the body of the original request are reused to perform the redirected request. In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give an answer to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resources, but a confirmation message (like &quot;You successfully uploaded XYZ&quot;).</source>
          <target state="translated">重用原始请求的方法和主体以执行重定向的请求。在您希望将方法更改为&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 的情况下&lt;/a&gt;，请使用&lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; &lt;/a&gt;。当您想提供一个不是上载资源而是一个确认消息（例如&amp;ldquo;您已成功上载XYZ&amp;rdquo;）的&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;方法的答案时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="9c74b76d94e666b868875958cf478928caee388b" translate="yes" xml:space="preserve">
          <source>The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb5ff63a9c845a973320d106a4e7a8f6258bc0a" translate="yes" xml:space="preserve">
          <source>The method specified in the Request-Line is not allowed for the
   resource identified by the Request-URI. The response MUST include an
   Allow header containing a list of valid methods for the requested
   resource.</source>
          <target state="translated">Request-Line中指定的方法对于Request-URI标识的资源是不允许的。响应必须包含一个Allow头,包含请求资源的有效方法列表。</target>
        </trans-unit>
        <trans-unit id="c61cd0e1f1485b50b5d1e9ad93568afa1f7867e5" translate="yes" xml:space="preserve">
          <source>The misunderstood X-XSS-Protection &amp;ndash; blog.innerht.ml</source>
          <target state="translated">误解的X-XSS-Protection &amp;ndash; blog.innerht.ml</target>
        </trans-unit>
        <trans-unit id="6aa0132e5f88b4993af9157a3eacfea873d280a5" translate="yes" xml:space="preserve">
          <source>The more we use cached resources, the better the responsiveness and the performance of a Web site will be. To optimize this, good practices recommend to set expiration times as far in the future as possible. This is possible on resources that are regularly updated, or often, but is problematic for resources that are rarely and infrequently updated. They are the resources that would benefit the most from caching resources, yet this makes them very difficult to update. This is typical of the technical resources included and linked from each Web pages: JavaScript and CSS files change infrequently, but when they change you want them to be updated quickly.</source>
          <target state="translated">我们使用缓存资源越多,网站的响应速度和性能就越好。为了优化这一点,良好的实践建议将过期时间设置在尽可能远的未来。这在定期更新或经常更新的资源上是可行的,但对于很少更新和不经常更新的资源来说就有问题了。它们是最能从缓存资源中获益的资源,然而这却使它们很难更新。这就是典型的技术资源,包括和每个网页链接的技术资源。JavaScript和CSS文件变化不频繁,但当它们变化时,你希望它们能快速更新。</target>
        </trans-unit>
        <trans-unit id="2b2d80c0ac04c3f4350cef824a1e1156d252f06e" translate="yes" xml:space="preserve">
          <source>The most &quot;original&quot; implementation of PAC and its JavaScript libraries is, therefore, &lt;code&gt;nsProxyAutoConfig.js&lt;/code&gt; found in early versions of Firefox. These utilities are found in many other open-source systems including &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/proxy_resolver/pac_js_library.h&quot;&gt;Chromium&lt;/a&gt;. Firefox later integrated the file into &lt;code&gt;&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/source/netwerk/base/ProxyAutoConfig.cpp&quot;&gt;ProxyAutoConfig.cpp&lt;/a&gt;&lt;/code&gt; as a C++ string literal. To extract it into its own file, it suffices to copy the chunk into JavaScript with a &lt;code&gt;console.log&lt;/code&gt; directive to print it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900a5182069f7643f5a96c3714605f7b28cd3d50" translate="yes" xml:space="preserve">
          <source>The most basic form of lock is an exclusive lock.  Exclusive locks
   avoid having to deal with content change conflicts, without requiring
   any coordination other than the methods described in this
   specification.

   However, there are times when the goal of a lock is not to exclude
   others from exercising an access right but rather to provide a
   mechanism for principals to indicate that they intend to exercise
   their access rights.  Shared locks are provided for this case.  A
   shared lock allows multiple principals to receive a lock.  Hence any
   principal that has both access privileges and a valid lock can use
   the locked resource.

   With shared locks, there are two trust sets that affect a resource.
   The first trust set is created by access permissions.  Principals who
   are trusted, for example, may have permission to write to the
   resource.  Among those who have access permission to write to the
   resource, the set of principals who have taken out a shared lock also
   must trust each other, creating a (typically) smaller trust set
   within the access permission write set.

   Starting with every possible principal on the Internet, in most
   situations the vast majority of these principals will not have write
   access to a given resource.  Of the small number who do have write
   access, some principals may decide to guarantee their edits are free
   from overwrite conflicts by using exclusive write locks.  Others may
   decide they trust their collaborators will not overwrite their work
   (the potential set of collaborators being the set of principals who
   have write permission) and use a shared lock, which informs their
   collaborators that a principal may be working on the resource.

   The WebDAV extensions to HTTP do not need to provide all of the
   communications paths necessary for principals to coordinate their
   activities.  When using shared locks, principals may use any out-of-
   band communication channel to coordinate their work (e.g., face-to-
   face interaction, written notes, post-it notes on the screen,
   telephone conversation, email, etc.)  The intent of a shared lock is
   to let collaborators know who else may be working on a resource.

   Shared locks are included because experience from Web-distributed
   authoring systems has indicated that exclusive locks are often too
   rigid.  An exclusive lock is used to enforce a particular editing
   process: take out an exclusive lock, read the resource, perform
   edits, write the resource, release the lock.  This editing process
   has the problem that locks are not always properly released, for
   example, when a program crashes or when a lock creator leaves without 

   unlocking a resource.  While both timeouts (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;) and
   administrative action can be used to remove an offending lock,
   neither mechanism may be available when needed; the timeout may be
   long or the administrator may not be available.

   A successful request for a new shared lock MUST result in the
   generation of a unique lock associated with the requesting principal.
   Thus, if five principals have taken out shared write locks on the
   same resource, there will be five locks and five lock tokens, one for
   each principal.</source>
          <target state="translated">锁的最基本形式是排他锁。排他锁避免处理内容更改冲突，而不需要本规范中描述的方法以外的任何协调。但是，有时锁定的目的不是要排除其他人行使访问权，而是要为主体提供一种机制，以表明主体打算行使其访问权。在这种情况下提供了共享锁。共享锁允许多个主体接收一个锁。因此，既具有访问权限又具有有效锁定的任何主体都可以使用锁定的资源。使用共享锁，有两个影响资源的信任集。第一个信任集是由访问权限创建的。受信任的校长，例如，可能具有写入资源的权限。在具有写资源访问权限的主体中，已采取共享锁的主体组也必须彼此信任，从而在访问许可写入集中创建一个（通常）较小的信任集。从Internet上的每个可能的主体开始，在大多数情况下，这些主体中的绝大多数将不具有对给定资源的写权限。在确实具有写访问权的少数用户中，某些负责人可能会决定通过使用排他写锁定来确保其编辑不存在覆盖冲突。其他人可能会决定他们相信合作者不会覆盖他们的工作（潜在的合作者集合是具有写许可权的主体集合）并使用共享锁，通知其合作者委托人可能正在使用该资源。 WebDAV对HTTP的扩展不需要提供委托人协调其活动所需的所有通信路径。使用共享锁时，校长可以使用任何带外通信渠道来协调其工作（例如，面对面的交互，书面说明，屏幕上的便笺，电话交谈，电子邮件等）。共享锁的目的是让协作者知道谁可能还在处理资源。之所以包含共享锁，是因为Web分布式创作系统的经验表明，排他锁通常过于僵化。排他锁用于强制执行特定的编辑过程：取出排他锁，读取资源，执行编辑，编写资源，释放锁。此编辑过程存在一个问题，例如，当程序崩溃或当锁创建者在没有解锁资源的情况下离开时，锁并不总是被正确释放。虽然两个超时（&lt;a href=&quot;#section-6.6&quot;&gt;&lt;/a&gt;可以使用第6.6节）和管理措施来删除有问题的锁，必要时两种机制都不可用；超时时间可能很长，或者管理员可能不可用。对新共享锁的成功请求必须导致生成与请求主体相关联的唯一锁。因此，如果五个委托人对同一资源采取了共享写锁，则将有五个锁和五个锁令牌，每个委托人一个。</target>
        </trans-unit>
        <trans-unit id="a156ff3c58c5769ef6c6729d1da6678b0896af60" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme which is introduced in more details below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="translated">最常见的身份验证方案是&amp;ldquo;基本&amp;rdquo;身份验证方案，下面将对其进行详细介绍。IANA维护&lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;身份验证方案&lt;/a&gt;的列表，但是主机服务（例如Amazon AWS）还提供其他方案。常见的身份验证方案包括：</target>
        </trans-unit>
        <trans-unit id="255966f9ca10cd047714babaf260d4a6e24ab848" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme, which is introduced in more detail below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c5a495d4e0bf178a13835396e7d4610c8dd302" translate="yes" xml:space="preserve">
          <source>The most common form of URI is the Uniform Resource Locator (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;), which is known as the &lt;em&gt;web address&lt;/em&gt;.</source>
          <target state="translated">URI的最常见形式是统一资源定位符（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;），即&lt;em&gt;网址&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="441408fdebb55a519d6ec56cfba9f8cfcf41c9d1" translate="yes" xml:space="preserve">
          <source>The most common form of request-target is the origin-form.

     origin-form    = absolute-path [ &quot;?&quot; query ]

   When making a request directly to an origin server, other than a
   CONNECT or server-wide OPTIONS request (as detailed below), a client
   MUST send only the absolute path and query components of the target
   URI as the request-target.  If the target URI's path component is
   empty, the client MUST send &quot;/&quot; as the path within the origin-form of
   request-target.  A Host header field is also sent, as defined in
   &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;.

   For example, a client wishing to retrieve a representation of the
   resource identified as

     http://www.example.org/where?q=now

   directly from the origin server would open (or reuse) a TCP
   connection to port 80 of the host &quot;www.example.org&quot; and send the
   lines:

     GET /where?q=now HTTP/1.1
     Host: www.example.org

   followed by the remainder of the request message.</source>
          <target state="translated">请求目标的最常见形式是起源形式。origin-form =绝对路径[&amp;ldquo;？&amp;rdquo; 当直接向原始服务器发出请求时，除了CONNECT或服务器范围内的OPTIONS请求（如下所述）外，客户端必须仅发送目标URI的绝对路径和查询组件作为请求目标。如果目标URI的路径部分为空，则客户端必须在请求目标的源形式内发送&amp;ldquo; /&amp;rdquo;作为路径。还发送了一个Host标头字段，如 &lt;a href=&quot;#section-5.4&quot;&gt;第5.4节所述&lt;/a&gt;。例如，希望直接从源服务器检索标识为http://www.example.org/where?q=now的资源的表示形式的客户端将打开（或重用）到主机端口80的TCP连接&amp;ldquo; www.example.org&amp;rdquo;并发送以下行：GET / where？q = now HTTP / 1.1主机：www.example.org，后跟请求消息的其余部分。</target>
        </trans-unit>
        <trans-unit id="46ee34a68e260d2ac9a208c1c10ecca4cdb7c99d" translate="yes" xml:space="preserve">
          <source>The most common reason to perform user agent sniffing is to determine which type of device the browser runs on. The goal is to serve different HTML to different device types.</source>
          <target state="translated">执行用户代理嗅探的最常见原因是确定浏览器运行在哪种类型的设备上。目标是向不同的设备类型提供不同的HTML。</target>
        </trans-unit>
        <trans-unit id="61e4993d071956d95f174a16357fd080a1122e7b" translate="yes" xml:space="preserve">
          <source>The most common use case for conditional requests is updating a cache. With an empty cache, or without a cache, the requested resource is sent back with a status of &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">条件请求最常见的用例是更新缓存。在具有空缓存或没有缓存的情况下，以&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 的状态发送回所请求的资源。</target>
        </trans-unit>
        <trans-unit id="63916efe76674061fe4628e66838f4f65d786f1d" translate="yes" xml:space="preserve">
          <source>The most common use case is to resume a download, to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">最常见的用例是恢复下载,以保证存储的资源在收到最后一个片段后没有被修改。</target>
        </trans-unit>
        <trans-unit id="a9d5d6bfeb55ebb232d3c55e050956f34dcf4435" translate="yes" xml:space="preserve">
          <source>The most common use case is to update a cached entity that has no associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最常见的用例是更新没有关联的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;的缓存实体。</target>
        </trans-unit>
        <trans-unit id="f8e294a410237a9ceaa795c432872e161168f9e7" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server. The modern &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;Fetch API&lt;/code&gt;&lt;/a&gt; provides the same features with a more powerful and flexible feature set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e5095bac19f7e957fc81b9fc8a8c4dfee3e4ef" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on top of HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server.</source>
          <target state="translated">基于HTTP的最常用的API是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API，可用于在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;和服务器之间交换数据。</target>
        </trans-unit>
        <trans-unit id="0a53cc937fbb9dc05f3c30062aeb2e10f7633a16" translate="yes" xml:space="preserve">
          <source>The most commonly used MIME types used for web content are listed below. This isn't a complete list of all the types that may be available, however. See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers&quot;&gt;media container formats&lt;/a&gt; guide for that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e318c21bd25e3fadc6435097a45df0a0fc7f22d3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &quot;&lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;&quot; which is the maximum amount of time a resource will be considered fresh. Contrary to &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, this directive is relative to the time of the request. For the files in the application that will not change, you can usually add aggressive caching. This includes static files such as images, CSS files and JavaScript files, for example.</source>
          <target state="translated">此处最重要的指令是&amp;ldquo; &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt; &amp;rdquo;，这是资源被视为新鲜的最长时间。与&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;相反，此指令是相对于请求时间的。对于应用程序中不会更改的文件，通常可以添加主动缓存。例如，这包括静态文件，例如图像，CSS文件和JavaScript文件。</target>
        </trans-unit>
        <trans-unit id="ec18430cf06631edb1cb32f0734bdaa2055f42e3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;, which is the maximum amount of time in which a resource will be considered fresh. This directive is relative to the time of the request, and overrides the &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header (if set). For the files in the application that will not change, you can normally use aggressive caching. This includes static files such as images, CSS files, and JavaScript files, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de54066611634f9bbfbe66c8f61f170f030f4d4" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;和CORS 公开的最有趣的功能是发出&amp;ldquo;凭据&amp;rdquo;请求的功能，这些请求知道&lt;a href=&quot;cookies&quot;&gt;HTTP cookie&lt;/a&gt;和HTTP身份验证信息。默认情况下，在跨站点 &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; 或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;调用中，浏览器将&lt;strong&gt;不&lt;/strong&gt;发送凭据。调用 &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; 对象或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;构造函数时，必须设置特定标志。</target>
        </trans-unit>
        <trans-unit id="1f1f72e7e757ea8a76c23e50644af8cf17ebd184" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1c1a63ba9f8dd30771846a530a5374e05d9e6e" translate="yes" xml:space="preserve">
          <source>The name of a supported request header. The header may list any number of headers, separated by commas.</source>
          <target state="translated">支持的请求头的名称。该头可以列出任何数量的头,用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="0efb14ebcb5f0fce2ff3b286a2ffd2165a867e1e" translate="yes" xml:space="preserve">
          <source>The name of the policy section that was violated.</source>
          <target state="translated">违反的政策部分的名称。</target>
        </trans-unit>
        <trans-unit id="844cb327de813003d80319f4e20e97ec08ef266e" translate="yes" xml:space="preserve">
          <source>The name of the software or (sub) product that handles the requests.</source>
          <target state="translated">处理请求的软件或(子)产品的名称。</target>
        </trans-unit>
        <trans-unit id="d061e432c2a538045e603ec2696ad4093da4b49d" translate="yes" xml:space="preserve">
          <source>The name of the software or product that handled the request. Usually in a format similar to &lt;a href=&quot;user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbecb7545401e92e7f01c19b30802601bc05d85b" translate="yes" xml:space="preserve">
          <source>The name or pseudonym of the server or software adding the &lt;code&gt;Warning&lt;/code&gt; header (might be &quot;-&quot; when the agent is unknown).</source>
          <target state="translated">添加 &lt;code&gt;Warning&lt;/code&gt; 标头的服务器或软件的名称或化名（如果代理未知，则可能为&amp;ldquo;-&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="0040305cef3180d6d7255c0c077b8782a6cc726f" translate="yes" xml:space="preserve">
          <source>The next major version of HTTP, HTTP/3, will use QUIC instead TCP/TLS for the transport layer portion.</source>
          <target state="translated">HTTP的下一个主要版本HTTP/3,将使用QUIC代替TCP/TLS来传输层部分。</target>
        </trans-unit>
        <trans-unit id="b8b5231ea957c239b67921ea4d3ca6986e579896" translate="yes" xml:space="preserve">
          <source>The non-Chromium Edge puts its engine version after the &lt;em&gt;Edge/&lt;/em&gt; token, not the application version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a49012952b5d13c3bc899a210b34a7392e5f266" translate="yes" xml:space="preserve">
          <source>The non-standard &lt;code&gt;Large-Allocation&lt;/code&gt; response header tells the browser that the page being loaded is going to want to perform a large allocation. It is currently only implemented in Firefox, but is harmless to send to every browser.</source>
          <target state="translated">非标准的 &lt;code&gt;Large-Allocation&lt;/code&gt; 响应标头告诉浏览器正在加载的页面要执行大分配。它目前仅在Firefox中实现，但发送到每个浏览器都无害。</target>
        </trans-unit>
        <trans-unit id="ba5026e86262d6245f07b3191a146bd8bb62bfc9" translate="yes" xml:space="preserve">
          <source>The notion of HTTP headers has been introduced, both for the requests and the responses, allowing metadata to be transmitted and making the protocol extremely flexible and extensible.</source>
          <target state="translated">无论是请求还是响应,都引入了HTTP头的概念,允许传输元数据,使协议变得极其灵活和可扩展。</target>
        </trans-unit>
        <trans-unit id="5a8511f9154b7d1710ad96380db408589218a6d1" translate="yes" xml:space="preserve">
          <source>The number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host of the received message as a known &lt;code&gt;Expect-CT&lt;/code&gt; host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c597b22723fbfd913584650ba834a8d38d96da2" translate="yes" xml:space="preserve">
          <source>The number of seconds for which the alternative service is considered fresh. If omitted, it defaults to 24 hours. Alternative service entries can be cached for up to &lt;em&gt;&amp;lt;max-age&amp;gt;&lt;/em&gt; seconds, minus the age of the response (from the &lt;a href=&quot;age&quot;&gt;&lt;code&gt;Age&lt;/code&gt;&lt;/a&gt; header). If the cached entry expires, the client can no longer use this alternative service for new connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebe7f3b1e1476fa1411cff9686fdc49ff3da815" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt;&lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;  directive.</source>
          <target state="translated">过时的&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt; &lt;code&gt;referrer&lt;/code&gt; &lt;/a&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="8ee97cde545a5282f8eb8711464102b13b2f6dec" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Cookie2&lt;/code&gt; HTTP request header used to advise the server that the user agent understands &quot;new-style&quot; cookies, but nowadays user agents will use the &lt;a href=&quot;cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header instead, not this one.</source>
          <target state="translated">&lt;code&gt;Cookie2&lt;/code&gt; HTTP请求标头已过时，用于通知服务器用户代理可以理解&amp;ldquo;新型&amp;rdquo; cookie，但是如今，用户代理将改用&lt;a href=&quot;cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;标头，而不是此标头。</target>
        </trans-unit>
        <trans-unit id="33c769b0c666a82869a02203951c2b8b5edec421" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP response header used to send cookies from the server to the user agent, but has been deprecated by the specification. Use &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">用于将cookie从服务器发送到用户代理的过时的 &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP响应标头，但已被规范弃用。请改用&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd9be51f044c110f50b29c3226b55ae882be5f1e" translate="yes" xml:space="preserve">
          <source>The only allowed methods are:</source>
          <target state="translated">唯一允许的方法是:</target>
        </trans-unit>
        <trans-unit id="cc061ae17eb93f938e35cb15516a270a95c70f3c" translate="yes" xml:space="preserve">
          <source>The only allowed values for the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header are:</source>
          <target state="translated">&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;标头的唯一允许值为：</target>
        </trans-unit>
        <trans-unit id="12f64d0b6bf68050154b5d92dd4e2be1345a3197" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;307&lt;/code&gt; and &lt;a href=&quot;302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;307&lt;/code&gt; guarantees that the method and the body will not be changed when the redirected request is made. With &lt;code&gt;302&lt;/code&gt;, some old clients were incorrectly changing the method to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;: the behavior with non-&lt;code&gt;GET&lt;/code&gt; methods and &lt;code&gt;302&lt;/code&gt; is then unpredictable on the Web, whereas the behavior with &lt;code&gt;307&lt;/code&gt; is predictable. For &lt;code&gt;GET&lt;/code&gt; requests, their behavior is identical.</source>
          <target state="translated">&lt;code&gt;307&lt;/code&gt; 和&lt;a href=&quot;302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt;之间的唯一区别是 &lt;code&gt;307&lt;/code&gt; 保证在发出重定向请求时，方法和主体不会更改。随着 &lt;code&gt;302&lt;/code&gt; ，一些老客户被错误地改变的方法&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;：与非的行为 &lt;code&gt;GET&lt;/code&gt; 方法和 &lt;code&gt;302&lt;/code&gt; 然后在网络上不可预测的，而与行为 &lt;code&gt;307&lt;/code&gt; 是可预测的。对于 &lt;code&gt;GET&lt;/code&gt; 请求，它们的行为是相同的。</target>
        </trans-unit>
        <trans-unit id="d4019eec51fe05092ad2db95b5b089e76d4b1742" translate="yes" xml:space="preserve">
          <source>The only expectation defined in the specification is &lt;code&gt;Expect: 100-continue&lt;/code&gt;, to which the server shall respond with:</source>
          <target state="translated">规范中定义的唯一期望是 &lt;code&gt;Expect: 100-continue&lt;/code&gt; ，服务器应使用以下响应：</target>
        </trans-unit>
        <trans-unit id="8582b84a04fd3c0703aeb779483786b9e1fec4ab" translate="yes" xml:space="preserve">
          <source>The only valid value for this header is &lt;code&gt;true&lt;/code&gt; (case-sensitive). If you don't need credentials, omit this header entirely (rather than setting its value to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">此标头的唯一有效值为 &lt;code&gt;true&lt;/code&gt; （区分大小写）。如果不需要凭据，请完全忽略此标头（而不是将其值设置为 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="57e0edd3cec8916417007e47f389d457d3b92156" translate="yes" xml:space="preserve">
          <source>The order in which header fields with differing field names are
   received is not significant.  However, it is good practice to send
   header fields that contain control data first, such as Host on
   requests and Date on responses, so that implementations can decide
   when not to handle a message as early as possible.  A server MUST NOT
   apply a request to the target resource until the entire request 

   header section is received, since later header fields might include
   conditionals, authentication credentials, or deliberately misleading
   duplicate header fields that would impact request processing.

   A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).

   A recipient MAY combine multiple header fields with the same field
   name into one &quot;field-name: field-value&quot; pair, without changing the
   semantics of the message, by appending each subsequent field value to
   the combined field value in order, separated by a comma.  The order
   in which header fields with the same field name are received is
   therefore significant to the interpretation of the combined field
   value; a proxy MUST NOT change the order of these field values when
   forwarding a message.

      Note: In practice, the &quot;Set-Cookie&quot; header field ([&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]) often
      appears multiple times in a response message and does not use the
      list syntax, violating the above requirements on multiple header
      fields with the same name.  Since it cannot be combined into a
      single field-value, recipients ought to handle &quot;Set-Cookie&quot; as a
      special case while processing header fields.  (See &lt;a href=&quot;#appendix-A.2.3&quot;&gt;Appendix A.2.3&lt;/a&gt;
      of [&lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;] for details.)</source>
          <target state="translated">具有不同字段名称的头字段的接收顺序并不重要。但是，优良作法是首先发送包含控制数据的标头字段，例如&amp;ldquo; Host on request&amp;rdquo;和&amp;ldquo; Date on response&amp;rdquo;，以便实现可以决定何时不尽早处理消息。在接收到整个请求标头部分之前，服务器不得将请求应用于目标资源，因为后面的标头字段可能包括条件，身份验证凭据或故意误导重复的标头字段，这会影响请求处理。发件人不得在消息中生成具有相同字段名称的多个标头字段，除非该标头字段的整个字段值都定义为以逗号分隔的列表[即，＃（values）]或标头字段是众所周知的异常（如下所述）。接收者可以通过将每个随后的字段值按顺序附加到合并的字段值上并用逗号分隔，将具有相同字段名的多个报头字段组合成一对&amp;ldquo;字段名：字段值&amp;rdquo;，而不会改变消息的语义。逗号。因此，接收具有相同字段名称的头字段的顺序对于组合字段值的解释很重要。代理转发消息时不得更改这些字段值的顺序。注意：实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[通过将每个后续字段值按顺序附加到组合的字段值（以逗号分隔），而无需更改消息的语义。因此，接收具有相同字段名称的头字段的顺序对于组合字段值的解释很重要。代理转发消息时不得更改这些字段值的顺序。注意：实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[通过将每个后续字段值按顺序附加到组合的字段值（以逗号分隔），而无需更改消息的语义。因此，接收具有相同字段名称的头字段的顺序对于组合字段值的解释很重要。代理转发消息时不得更改这些字段值的顺序。注意：实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]）通常在响应消息中出现多次，并且不使用列表语法，这违反了对具有相同名称的多个标头字段的上述要求。由于不能将其组合为单个字段值，因此收件人在处理标头字段时应作为特殊情况处理&amp;ldquo; Set-Cookie&amp;rdquo;。（有关详细信息，请参见 [ &lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt; ]的&lt;a href=&quot;#appendix-A.2.3&quot;&gt;附录A.2.3&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="18149c10ff86aae91ec06cd0aef8f5de4440363f" translate="yes" xml:space="preserve">
          <source>The origin is a URI indicating the server from which the request initiated. It does not include any path information, but only the server name.</source>
          <target state="translated">origin是一个URI,表示请求是从哪个服务器发起的,它不包括任何路径信息,只包括服务器名称。它不包括任何路径信息,只包括服务器名称。</target>
        </trans-unit>
        <trans-unit id="26e7668fe582d80ecc70504dac9a50d81f54d606" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="translated">源服务器要求请求是有条件的。目的是为了防止 &quot;丢失更新 &quot;的问题,即客户端GET一个资源的状态,修改它,然后把它送回服务器,而与此同时,第三方已经修改了服务器上的状态,从而导致冲突。</target>
        </trans-unit>
        <trans-unit id="73f93eb007ff12547887950cf639f167d2aeb94c" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. This response is intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28b7e0ef7daf83cb81a618727021028721dfa63" translate="yes" xml:space="preserve">
          <source>The original WebDAV model for locking unmapped URLs created &quot;lock-
   null resources&quot;.  This model was over-complicated and some
   interoperability and implementation problems were discovered.  The
   new WebDAV model for locking unmapped URLs (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;) creates
   &quot;locked empty resources&quot;.  Lock-null resources are deprecated.  This
   section discusses the original model briefly because clients MUST be
   able to handle either model.

   In the original &quot;lock-null resource&quot; model, which is no longer
   recommended for implementation:

   o  A lock-null resource sometimes appeared as &quot;Not Found&quot;.  The
      server responds with a 404 or 405 to any method except for PUT,
      MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK.

   o  A lock-null resource does however show up as a member of its
      parent collection.

   o  The server removes the lock-null resource entirely (its URI
      becomes unmapped) if its lock goes away before it is converted to
      a regular resource.  Recall that locks go away not only when they
      expire or are unlocked, but are also removed if a resource is
      renamed or moved, or if any parent collection is renamed or moved. 

   o  The server converts the lock-null resource into a regular resource
      if a PUT request to the URL is successful.

   o  The server converts the lock-null resource into a collection if a
      MKCOL request to the URL is successful (though interoperability
      experience showed that not all servers followed this requirement).

   o  Property values were defined for DAV:lockdiscovery and DAV:
      supportedlock properties but not necessarily for other properties
      like DAV:getcontenttype.

   Clients can easily interoperate both with servers that support the
   old model &quot;lock-null resources&quot; and the recommended model of &quot;locked
   empty resources&quot; by only attempting PUT after a LOCK to an unmapped
   URL, not MKCOL or GET.</source>
          <target state="translated">用于锁定未映射URL的原始WebDAV模型创建了&amp;ldquo;锁定空资源&amp;rdquo;。该模型过于复杂，并且发现了一些互操作性和实现问题。用于锁定未映射URL的新WebDAV模型（请参见&lt;a href=&quot;#section-7.3&quot;&gt;7.3节）&lt;/a&gt;）创建&amp;ldquo;锁定的空资源&amp;rdquo;。不推荐使用空锁资源。本节简要讨论原始模型，因为客户端必须能够处理任何一个模型。在原始的&amp;ldquo;锁空资源&amp;rdquo;模型中，不再建议实施该模型：o锁空资源有时显示为&amp;ldquo;未找到&amp;rdquo;。服务器以404或405响应除PUT，MKCOL，OPTIONS，PROPFIND，LOCK和UNLOCK之外的任何方法。 o锁空资源确实会显示为其父集合的成员。 o如果服务器的锁在转换为常规资源之前消失了，则服务器将完全删除该锁为空的资源（其URI变为未映射）。回想一下，锁不仅会在过期或解锁时消失，但如果重命名或移动资源，或者重命名或移动任何父集合，也会被删除。 o如果对URL的PUT请求成功，则服务器会将空锁资源转换为常规资源。 o如果对URL的MKCOL请求成功，则服务器会将锁空资源转换为集合（尽管互操作性经验表明并非所有服务器都遵循此要求）。 o为DAV：lockdiscovery和DAV：supportedlock属性定义了属性值，但未为DAV：getcontenttype等其他属性定义属性值。客户端可以轻松地与支持旧模型&amp;ldquo;锁定空资源&amp;rdquo;和建议模型&amp;ldquo;锁定空资源&amp;rdquo;的服务器进行互操作。通过仅在锁定到未映射的URL（而不是MKCOL或GET）之后尝试PUT。</target>
        </trans-unit>
        <trans-unit id="bd67e38aa52dda3f2ef7884d2b5f132dc5a16c44" translate="yes" xml:space="preserve">
          <source>The original header name &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; is a misspelling of the word &quot;referrer&quot;. The &lt;code&gt;Referrer-Policy&lt;/code&gt; header does not share this misspelling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351291dcc2c8f40b6fda3d0b9fb11a63f52c019f" translate="yes" xml:space="preserve">
          <source>The original model of HTTP, and the default one in HTTP/1.0, is &lt;em&gt;short-lived connections&lt;/em&gt;. Each HTTP request is completed on its own connection; this means a TCP handshake happens before each HTTP request, and these are serialized.</source>
          <target state="translated">HTTP的原始模型（即HTTP / 1.0中的默认模型）是&lt;em&gt;短期连接&lt;/em&gt;。每个HTTP请求都在其自己的连接上完成；这意味着TCP握手在每个HTTP请求之前发生，并且已被序列化。</target>
        </trans-unit>
        <trans-unit id="79e460eb743f85621e4024af0b7bff004e6c3d39" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP header.</source>
          <target state="translated">由 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP标头指定的原始策略。</target>
        </trans-unit>
        <trans-unit id="4893fed57017b899f622f28734ae6d2fe80b3b77" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP header.</source>
          <target state="translated">由 &lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP标头指定的原始策略。</target>
        </trans-unit>
        <trans-unit id="65440960b2a3f39f3e1fd7555605568089a8d96a" translate="yes" xml:space="preserve">
          <source>The original vision of Tim Berners-Lee for the Web wasn't a read-only medium. He envisioned a Web where people can add and move documents remotely, a kind of distributed file system. Around 1996, HTTP has been extended to allow authoring, and a standard called WebDAV was created. It has been further extended for specific applications like CardDAV to handle address book entries and CalDAV to deal with calendars. But all these *DAV extensions had a flaw: they had to be implemented by the servers to be used, which was quite complex. Their use on Web realms stayed confidential.</source>
          <target state="translated">蒂姆-伯纳斯-李最初对网络的设想并不是一个只读的媒介。他设想的Web是人们可以远程添加和移动文档,是一种分布式文件系统。大约在1996年,HTTP已经被扩展到允许编写,并创建了一个名为WebDAV的标准。它被进一步扩展到特定的应用中,比如CardDAV处理地址簿条目,CalDAV处理日历。但所有这些*DAV扩展都有一个缺陷:它们必须由服务器来实现才能使用,这相当复杂。它们在网络领域的使用是保密的。</target>
        </trans-unit>
        <trans-unit id="ec62cbdca93d2ad4ec39377f99d81883dfe1d146" translate="yes" xml:space="preserve">
          <source>The output will look something like this:</source>
          <target state="translated">输出将是这样的。</target>
        </trans-unit>
        <trans-unit id="aa47362e2b58ce7c1d4859c59d1d577c32eab05a" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the same origin as the page itself. The spec leaves it up to browser vendors to decide whether this option applies to the top level, the parent, or the whole chain, although it is argued that the option is not very useful unless all ancestors are also in the same origin (see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;bug 725490&lt;/a&gt;). Also see &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; for support details.</source>
          <target state="translated">该页面只能以与页面本身相同的原点显示在框架中。该规范由浏览器供应商决定该选项是适用于顶层，父级还是整个链，尽管有人认为该选项不是很有用，除非所有祖先的起源都相同（请参见&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;错误） 725490&lt;/a&gt;）。另请参阅&lt;a href=&quot;#Browser_compatibility&quot;&gt;浏览器兼容性&lt;/a&gt;以获取支持详细信息。</target>
        </trans-unit>
        <trans-unit id="87ed0031ffdd1f701402da552456ef09ffc21cb3" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the specified origin. Note that in Firefox this still suffers from the same problem as &lt;code&gt;sameorigin&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin.</source>
          <target state="translated">该页面只能显示在指定原点的框架中。请注意，在Firefox中，这仍然遇到与 &lt;code&gt;sameorigin&lt;/code&gt; 相同的问题-它不会检查框架祖先是否起源于同一来源。</target>
        </trans-unit>
        <trans-unit id="6fd708bba3250a928bde72e278816558269ceee3" translate="yes" xml:space="preserve">
          <source>The page cannot be displayed in a frame, regardless of the site attempting to do so.</source>
          <target state="translated">无论网站是否试图这样做,该页面都不能在框架中显示。</target>
        </trans-unit>
        <trans-unit id="7e65beef9355c724f3b8565f6ab1fad05b9ee018" translate="yes" xml:space="preserve">
          <source>The parameters &quot;filename&quot; and &quot;filename*&quot; differ only in that &quot;filename*&quot; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &quot;filename&quot; and &quot;filename*&quot; are present in a single header field value, &quot;filename*&quot; is preferred over &quot;filename&quot; when both are understood.</source>
          <target state="translated">参数&amp;ldquo; filename&amp;rdquo;和&amp;ldquo; filename *&amp;rdquo;的区别仅在于&amp;ldquo; filename *&amp;rdquo;使用&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987中&lt;/a&gt;定义的编码。如果在单个标头字段值中同时存在&amp;ldquo;文件名&amp;rdquo;和&amp;ldquo;文件名*&amp;rdquo;，则当两者都理解时，&amp;ldquo;文件名*&amp;rdquo;比&amp;ldquo;文件名&amp;rdquo;更可取。</target>
        </trans-unit>
        <trans-unit id="acecd71c2fad3b28645f1a60d768a752cf9279b0" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; differ only in that &lt;code&gt;filename*&lt;/code&gt; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; are present in a single header field value, &lt;code&gt;filename*&lt;/code&gt; is preferred over &lt;code&gt;filename&lt;/code&gt; when both are understood.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73b0f673ad4f6ff6cd78d437d63486d3077a18d" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">要获取的资源的路径；资源的URL从上下文中显而易见的元素中剥离出来，例如，没有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;协议&lt;/a&gt;（ &lt;code&gt;http://&lt;/code&gt; ），&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;域&lt;/a&gt;（此处为 &lt;code&gt;developer.mozilla.org&lt;/code&gt; ）或TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;端口&lt;/a&gt;（此处为 &lt;code&gt;80&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d2379dd36e7935200c9bebfe54ad165f2211a593" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here, &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here, &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d24dd0cdd0a56d270ae234ba2ae51b6e5cb97c" translate="yes" xml:space="preserve">
          <source>The performance of web sites and applications can be significantly improved by reusing previously fetched resources. Web caches reduce latency and network traffic and thus lessen the time needed to display a representation of a resource. By making use of HTTP caching, Web sites become more responsive.</source>
          <target state="translated">通过重复使用以前获取的资源,可以显著提高网站和应用程序的性能。网络缓存减少了延迟和网络流量,从而减少了显示资源表示所需的时间。通过利用HTTP缓存,Web网站的响应速度变得更快。</target>
        </trans-unit>
        <trans-unit id="4ef7dc4ef4177a90ccc5fba5f3743824b87bfd8e" translate="yes" xml:space="preserve">
          <source>The policy is a string containing the policy directives describing your Content Security Policy.</source>
          <target state="translated">策略是一个字符串,包含描述您的内容安全策略的策略指令。</target>
        </trans-unit>
        <trans-unit id="1cde3605fdc2afc6de4d0a52e9aa9896f47fafaf" translate="yes" xml:space="preserve">
          <source>The policy:</source>
          <target state="translated">该政策:</target>
        </trans-unit>
        <trans-unit id="776afe838427d09cf840d7fc30aa63d4eaa2c3d9" translate="yes" xml:space="preserve">
          <source>The precondition given in one or more of the request-header fields
   evaluated to false when it was tested on the server. This response
   code allows the client to place preconditions on the current resource
   metainformation (header field data) and thus prevent the requested
   method from being applied to a resource other than the one intended.</source>
          <target state="translated">在服务器上测试时,一个或多个请求头字段中给出的前提条件被评估为false。这个响应代码允许客户机对当前的资源元信息(头字段数据)设置先决条件,从而防止所请求的方法被应用于目标资源以外的资源。</target>
        </trans-unit>
        <trans-unit id="82d265543b246e66360f0830a564b27c84119c7f" translate="yes" xml:space="preserve">
          <source>The preferred way to target content to a device form factor is to use CSS Media Queries. However, if you use UA sniffing to target content to a device form factor, please look for &lt;strong&gt;Mobi&lt;/strong&gt; (to include Opera Mobile, which uses &quot;Mobi&quot;) for the phone form factor and do &lt;strong&gt;not&lt;/strong&gt; assume any correlation between &quot;Android&quot; and the device form factor. This way, your code will work if/when Firefox ships on other phone/tablet operating systems or Android is used for laptops. Also, please use touch detection to find touch devices rather than looking for &quot;Mobi&quot; or &quot;Tablet&quot;, since there may be touch devices which are not tablets.</source>
          <target state="translated">将内容定位到设备尺寸的首选方法是使用CSS Media Queries。但是，如果您使用UA嗅探目标内容到设备的外形尺寸，请认准&lt;strong&gt;摩比&lt;/strong&gt;（包括Opera移动，它采用&amp;ldquo;牧高笛&amp;rdquo;）手机的外形和你&lt;strong&gt;没有&lt;/strong&gt;承担的&amp;ldquo;Android&amp;rdquo;和器件之间的任何关联构成因素。这样，如果/当Firefox在其他电话/平板电脑操作系统上附带或Android用于笔记本电脑时，您的代码将起作用。另外，请使用触摸检测来查找触摸设备，而不要查找&amp;ldquo; Mobi&amp;rdquo;或&amp;ldquo;平板电脑&amp;rdquo;，因为可能存在不是平板电脑的触摸设备。</target>
        </trans-unit>
        <trans-unit id="3f39eef261f64576ec5b25a729b1ec139f8018df" translate="yes" xml:space="preserve">
          <source>The preflight request below tells the server that we want to send a CORS &lt;code&gt;GET&lt;/code&gt; request that has the headers listed in &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;x-requested-with&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="336e39ad55330caf3f7eb800fefcd2e0dc7dd455" translate="yes" xml:space="preserve">
          <source>The preflight request simply suffered any kind of networking error that might ordinarily occur.</source>
          <target state="translated">飞行前的请求只是遭受了任何一种通常可能发生的网络错误。</target>
        </trans-unit>
        <trans-unit id="debdc150f8d10727246ce79b174d0a3a9962d2c4" translate="yes" xml:space="preserve">
          <source>The previous example was illegal because it contained two elements
   that were explicitly banned from appearing together in the propfind
   element.  However, XML is an extensible language, so one can imagine
   new elements being defined for use with propfind.  Below is the
   request body of a PROPFIND and, like the previous example, must be
   rejected with a 400 (Bad Request) by a server that does not
   understand the expired-props element.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
      xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;E:expired-props/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   To understand why a 400 (Bad Request) is returned, let us look at the
   request body as the server unfamiliar with expired-props sees it.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   As the server does not understand the 'expired-props' element,
   according to the WebDAV-specific XML processing rules specified in
   &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;, it must process the request as if the element were not
   there.  Thus, the server sees an empty propfind, which by the
   definition of the propfind element is illegal.

   Please note that had the extension been additive, it would not
   necessarily have resulted in a 400 (Bad Request).  For example,
   imagine the following request body for a PROPFIND:


      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;D:propname/&amp;gt;
       &amp;lt;E:leave-out&amp;gt;*boss*&amp;lt;/E:leave-out&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The previous example contains the fictitious element leave-out.  Its
   purpose is to prevent the return of any property whose name matches
   the submitted pattern.  If the previous example were submitted to a
   server unfamiliar with 'leave-out', the only result would be that the
   'leave-out' element would be ignored and a propname would be
   executed.</source>
          <target state="translated">前面的示例是非法的，因为它包含两个元素，这些元素被明确禁止在propfind元素中一起出现。但是，XML是一种可扩展的语言，因此可以想象定义了供propfind使用的新元素。以下是PROPFIND的请求正文，并且与前面的示例一样，不了解expired-props元素的服务器必须使用400（错误请求）将其拒绝。 &amp;lt;？xml版本=&amp;ldquo; 1.0&amp;rdquo;编码=&amp;ldquo; utf-8&amp;rdquo;吗？&amp;gt; &amp;lt;D：属性xmlns：D =&amp;ldquo; DAV：&amp;rdquo; xmlns：E =&amp;ldquo; http://www.example.com/standards/props/&amp;rdquo;&amp;gt; &amp;lt;E：expired-props /&amp;gt; &amp;lt;/ D：propfind&amp;gt;要了解为什么返回400（错误请求）的原因，让我们看一下请求正文，因为不熟悉expire-props的服务器会看到它。 &amp;lt;？xml版本=&amp;ldquo; 1.0&amp;rdquo;编码=&amp;ldquo; utf-8&amp;rdquo;？&amp;gt; &amp;lt;D：属性xmlns：D =&amp;ldquo; DAV：&amp;rdquo; xmlns：E =&amp;ldquo; http://www.example.com/standards/props/&amp;rdquo;&amp;gt; &amp;lt; / D：propfind&amp;gt;由于服务器无法理解'expired-props'元素，因此请根据在WebDAV中指定的XML处理规则 &lt;a href=&quot;#section-17&quot;&gt;第17节&lt;/a&gt;，它必须像处理元素不存在一样处理请求。因此，服务器看到一个空的propfind，根据propfind元素的定义，这是非法的。请注意，如果扩展名是加性的，则不一定会导致400（错误请求）。例如，假设对PROPFIND的以下请求正文：&amp;lt;？xml version =&amp;ldquo; 1.0&amp;rdquo; encoding =&amp;ldquo; utf-8&amp;rdquo;？&amp;gt; &amp;lt;D：propfind xmlns：D =&amp;ldquo; DAV：&amp;rdquo; xmlns：E =&amp;ldquo; http：// www.example.com/standards/props /&amp;ldquo;&amp;gt; &amp;lt;D：propname /&amp;gt; &amp;lt;E：leave-out&amp;gt; * boss * &amp;lt;/ E：leave-out&amp;gt; &amp;lt;/ D：propfind&amp;gt;上一个示例包含假想元素出来其目的是防止返回名称与提交的模式匹配的任何属性。如果将先前的示例提交给不熟悉&amp;ldquo; leave-out&amp;rdquo;的服务器，则唯一的结果是将忽略&amp;ldquo; leave-out&amp;rdquo;元素并执行属性名。</target>
        </trans-unit>
        <trans-unit id="1ae30a0f00a7837d72ecd861dd4a6d9fd65f4447" translate="yes" xml:space="preserve">
          <source>The primary changes in this revision have been editorial in nature:
   extracting the messaging syntax and partitioning HTTP semantics into
   separate documents for the core features, conditional requests,
   partial requests, caching, and authentication.  The conformance
   language has been revised to clearly target requirements and the
   terminology has been improved to distinguish payload from
   representations and representations from resources.

   A new requirement has been added that semantics embedded in a URI be
   disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   An algorithm has been added for determining if a payload is
   associated with a specific identifier.  (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;)

   The default charset of ISO-8859-1 for text media types has been
   removed; the default is now whatever the media type definition says.
   Likewise, special treatment of ISO-8859-1 has been removed from the
   Accept-Charset header field.  (&lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; and &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;)

   The definition of Content-Location has been changed to no longer
   affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;)

   To be consistent with the method-neutral parsing algorithm of
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], the definition of GET has been relaxed so that requests
   can have a body, even though a body has no meaning for GET.
   (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;)

   Servers are no longer required to handle all Content-* header fields
   and use of Content-Range has been explicitly banned in PUT requests.
   (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;)

   Definition of the CONNECT method has been moved from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;] to
   this specification.  (&lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt;)

   The OPTIONS and TRACE request methods have been defined as being
   safe.  (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; and &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) 

   The Expect header field's extension mechanism has been removed due to
   widely-deployed broken implementations.  (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)

   The Max-Forwards header field has been restricted to the OPTIONS and
   TRACE methods; previously, extension methods could have used it as
   well.  (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;)

   The &quot;about:blank&quot; URI has been suggested as a value for the Referer
   header field when no referring URI is applicable, which distinguishes
   that case from others where the Referer field is not sent or has been
   removed.  (&lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;)

   The following status codes are now cacheable (that is, they can be
   stored and reused by a cache without explicit freshness information
   present): 204, 404, 405, 414, 501.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)

   The 201 (Created) status description has been changed to allow for
   the possibility that more than one resource has been created.
   (&lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;)

   The definition of 203 (Non-Authoritative Information) has been
   broadened to include cases of payload transformations as well.
   (&lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;)

   The set of request methods that are safe to automatically redirect is
   no longer closed; user agents are able to make that determination
   based upon the request method semantics.  The redirect status codes
   301, 302, and 307 no longer have normative requirements on response
   payloads and user interaction.  (&lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;)

   The status codes 301 and 302 have been changed to allow user agents
   to rewrite the method from POST to GET.  (Sections &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; and &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;)

   The description of the 303 (See Other) status code has been changed
   to allow it to be cached if explicit freshness information is given,
   and a specific definition has been added for a 303 response to GET.
   (&lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;)

   The 305 (Use Proxy) status code has been deprecated due to security
   concerns regarding in-band configuration of a proxy.  (&lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;)

   The 400 (Bad Request) status code has been relaxed so that it isn't
   limited to syntax errors.  (&lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;)

   The 426 (Upgrade Required) status code has been incorporated from
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;].  (&lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;) 

   The target of requirements on HTTP-date and the Date header field
   have been reduced to those systems generating the date, rather than
   all systems sending a date.  (&lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;)

   The syntax of the Location header field has been changed to allow all
   URI references, including relative references and fragments, along
   with some clarifications as to when use of fragments would not be
   appropriate.  (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;)

   Allow has been reclassified as a response header field, removing the
   option to specify it in a PUT request.  Requirements relating to the
   content of Allow have been relaxed; correspondingly, clients are not
   required to always trust its value.  (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;)

   A Method Registry has been defined.  (&lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;)

   The Status Code Registry has been redefined by this specification;
   previously, it was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.
   (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;)

   Registration of content codings has been changed to require IETF
   Review.  (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;)

   The Content-Disposition header field has been removed since it is now
   defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt;].

   The Content-MD5 header field has been removed because it was
   inconsistently implemented with respect to partial responses.</source>
          <target state="translated">此修订版的主要更改本质上是编辑性的：提取消息传递语法并将HTTP语义划分为用于核心功能，条件请求，部分请求，缓存和身份验证的单独文档。对符合性语言进行了修订，以明确地针对需求，并且对术语进行了改进，以区分有效载荷与表示形式以及资源与表示形式。添加了新要求，即当那些语义与请求方法不一致时，禁用嵌入在URI中的语义，因为这是互操作性失败的常见原因。 （&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;）添加了一种算法，用于确定有效载荷是否与特定标识符相关联。 （&lt;a href=&quot;#section-3.1.4.1&quot;&gt;第3.1.4.1节&lt;/a&gt;）已删除文本媒体类型的默认ISO-8859-1字符集；现在，默认值是媒体类型定义说的内容。同样，已从Accept-Charset标头字段中删除了对ISO-8859-1的特殊处理。 （&lt;a href=&quot;#section-3.1.1.3&quot;&gt;第3.1.1.3节&lt;/a&gt;和&lt;a href=&quot;#section-5.3.3&quot;&gt;第5.3.3节&lt;/a&gt;）由于实施支持不佳以及可能破坏内容中相对链接的不良影响，已更改Content-Location的定义，使其不再影响解析相对URI引用的基本URI。协商资源。 （&lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt;）与[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;的方法无关的解析算法一致]，则放宽了GET的定义，即使主体对GET没有意义，请求也可以具有主体。 （&lt;a href=&quot;#section-4.3.1&quot;&gt;第4.3.1节&lt;/a&gt;）不再要求服务器处理所有Content- *标头字段，并且PUT请求中已明确禁止使用Content-Range。 （&lt;a href=&quot;#section-4.3.4&quot;&gt;第4.3.4节&lt;/a&gt;）CONNECT方法的定义已从[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]移至本规范。 （&lt;a href=&quot;#section-4.3.6&quot;&gt;第4.3.6节&lt;/a&gt;）OPTIONS和TRACE请求方法已定义为安全的。 （&lt;a href=&quot;#section-4.3.7&quot;&gt;第4.3.7节&lt;/a&gt;和&lt;a href=&quot;#section-4.3.8&quot;&gt;第4.3.8节&lt;/a&gt;）由于广泛采用的破坏性实现，Expect标头字段的扩展机制已删除。 （&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt;）Max-Forwards标头字段仅限于OPTIONS和TRACE方法；以前，扩展方法也可以使用它。 （&lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1.2节&lt;/a&gt;）当没有引用URI适用时，建议将&amp;ldquo; about：blank&amp;rdquo; URI用作Referer头字段的值，这可以将这种情况与没有发送或已删除Referer字段的其他情况区分开。 （&lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt;）现在，以下状态代码是可缓存的（即，可以在不存在显式新鲜度信息的情况下由缓存存储和重用它们）：204、404、405、414、501。（&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）201（已更改状态描述，以允许创建多个资源的可能性。 （&lt;a href=&quot;#section-6.3.2&quot;&gt;第6.3.2节&lt;/a&gt;）203（非权威性信息）的定义已扩展到包括有效负载转换的情况。 （&lt;a href=&quot;#section-6.3.4&quot;&gt;第6.3.4节&lt;/a&gt;）安全关闭的自动重定向请求方法集不再关闭；用户代理能够基于请求方法的语义进行该确定。重定向状态代码301、302和307不再对响应有效负载和用户交互具有规范性要求。 （&lt;a href=&quot;#section-6.4&quot;&gt;第6.4节&lt;/a&gt;）状态代码301和302已更改，以允许用户代理将方法从POST重写为GET。 （第&lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt;和&lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;节）状态303（请参阅其他）状态代码的描述已更改，以便在给出明确的新鲜度信息时可以对其进行缓存，并且已为303对GET的响应添加了特定的定义。 （&lt;a href=&quot;#section-6.4.4&quot;&gt;第6.4.4节&lt;/a&gt;）由于与代理的带内配置有关的安全问题，不建议使用305（使用代理）状态代码。 （&lt;a href=&quot;#section-6.4.5&quot;&gt;第6.4.5节&lt;/a&gt;）放宽了400（错误请求）状态码，使其不仅限于语法错误。 （&lt;a href=&quot;#section-6.5.1&quot;&gt;第6.5.1节&lt;/a&gt;）426（需要升级）状态代码已从[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]中合并。 （&lt;a href=&quot;#section-6.5.15&quot;&gt;第6.5.15节&lt;/a&gt;）对HTTP-date和Date标头字段的要求目标已降低为生成日期的系统，而不是所有发送日期的系统。 （&lt;a href=&quot;#section-7.1.1&quot;&gt;第7.1.1节&lt;/a&gt;）Location标头字段的语法已更改，以允许所有URI引用，包括相对引用和片段，以及一些有关何时不适合使用片段的说明。 （&lt;a href=&quot;#section-7.1.2&quot;&gt;第7.1.2节&lt;/a&gt;）Allow被重新分类为响应头字段，删除了在PUT请求中指定它的选项。放宽了关于&amp;ldquo;允许&amp;rdquo;内容的要求；相应地，客户无需始终信任其价值。 （&lt;a href=&quot;#section-7.4.1&quot;&gt;第7.4.1节&lt;/a&gt;）已经定义了方法注册表。 （&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;）状态代码注册表已由本规范重新定义；先前，它是在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;[RFC2817]的7.1节&lt;/a&gt;中定义的。（&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节&lt;/a&gt;）内容编码的注册已更改为需要IETF审核。（&lt;a href=&quot;#section-8.4&quot;&gt;第8.4节&lt;/a&gt;）因为[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt; ] 现在定义了Content-Disposition标头字段，所以已将其删除。Content-MD5标头字段已删除，因为相对于部分响应不一致地实现了该字段。</target>
        </trans-unit>
        <trans-unit id="e12309a2843027455af9add0576f0892e2a69fde" translate="yes" xml:space="preserve">
          <source>The primary difference between the HTTP header and the &lt;code&gt;allow&lt;/code&gt; attribute is that the allow attribute only controls features within an iframe. The header controls features in the response and any embedded content within the page.</source>
          <target state="translated">HTTP标头和 &lt;code&gt;allow&lt;/code&gt; 属性之间的主要区别在于allow属性仅控制iframe中的功能。标头控制响应中的功能以及页面内的任何嵌入式内容。</target>
        </trans-unit>
        <trans-unit id="b50ebcbe3e89d6447760b75f1e616af6abba5bb8" translate="yes" xml:space="preserve">
          <source>The principle behind entity tags is that only the service author
   knows the semantics of a resource well enough to select an
   appropriate cache validation mechanism, and the specification of any
   validator comparison function more complex than byte-equality would
   open up a can of worms. Thus, comparisons of any other headers
   (except Last-Modified, for compatibility with HTTP/1.0) are never
   used for purposes of validating a cache entry.</source>
          <target state="translated">实体标签背后的原则是,只有服务作者才清楚资源的语义,才能选择合适的缓存验证机制,而任何验证器比较功能的规范都会比字节均衡更复杂,这将会打开一个麻烦的罐子。因此,任何其他头文件的比较(除了Last-Modified,为了与HTTP/1.0兼容)都不会被用于验证缓存条目。</target>
        </trans-unit>
        <trans-unit id="e894f8457ed794b88882865f6c9931e22354537d" translate="yes" xml:space="preserve">
          <source>The principle behind entity-tags is that only the service author
   knows the implementation of a resource well enough to select the most
   accurate and efficient validation mechanism for that resource, and
   that any such mechanism can be mapped to a simple sequence of octets
   for easy comparison.  Since the value is opaque, there is no need for
   the client to be aware of how each entity-tag is constructed.

   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.  Other
   implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.

   An origin server SHOULD send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity-tag's use in conditional requests and
   evaluating cache freshness ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]) can result in a substantial
   reduction of HTTP network traffic and can be a significant factor in
   improving service scalability and reliability.</source>
          <target state="translated">实体标签背后的原理是，只有服务作者才足够了解资源的实现，可以为该资源选择最准确，最有效的验证机制，并且任何此类机制都可以映射到简单的八位字节序列以进行比较。由于该值是不透明的，因此客户端无需知道如何构造每个实体标签。例如，对所有更改都应用了特定于实现的版本控制的资源可能会使用内部修订号（可能与用于内容协商的方差标识符结合使用）来准确区分表示形式。其他实现可能会使用表示内容的防碰撞哈希，各种文件属性的组合，或具有亚秒分辨率的修改时间戳。原始服务器应该为可以合理而一致地确定更改检测结果的任何选定表示形式发送一个ETag，因为实体标签在条件请求中使用并评估缓存的新鲜度（[&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]）可以大大减少HTTP网络流量，并且可以成为提高服务可伸缩性和可靠性的重要因素。</target>
        </trans-unit>
        <trans-unit id="c1875060cbf6a72a618b42c5d094d85aee6d41e8" translate="yes" xml:space="preserve">
          <source>The principle is simple, but there is one potential problem: if the downloaded resource has been modified between both downloads, the obtained ranges will correspond to two different versions of the resource, and the final document will be corrupted.</source>
          <target state="translated">原理很简单,但有一个潜在的问题:如果下载的资源在两次下载之间都被修改过,那么得到的范围就会对应两个不同版本的资源,最后的文档就会被破坏。</target>
        </trans-unit>
        <trans-unit id="2f036bd357e0e56c778c2d79ff8ac18d032812cb" translate="yes" xml:space="preserve">
          <source>The protocol that is used. Usually it is the HTTP protocol or its secured version, HTTPS.</source>
          <target state="translated">使用的协议。通常是HTTP协议或其安全版本HTTPS。</target>
        </trans-unit>
        <trans-unit id="2ec525dcadd68d3467f5291ea2396006096b487a" translate="yes" xml:space="preserve">
          <source>The purpose of an HTTP cache is to store information received in
   response to requests for use in responding to future requests. In
   many cases, a cache simply returns the appropriate parts of a
   response to the requester. However, if the cache holds a cache entry
   based on a previous response, it might have to combine parts of a new
   response with what is held in the cache entry.</source>
          <target state="translated">HTTP缓存的目的是存储响应请求时收到的信息,以便在响应未来的请求时使用。在许多情况下,缓存只是将响应的适当部分返回给请求者。然而,如果缓存持有基于之前响应的缓存条目,它可能必须将新响应的部分与缓存条目中的内容结合起来。</target>
        </trans-unit>
        <trans-unit id="6728c1b09c31f5d826dfb315c8231a9800e8a7de" translate="yes" xml:space="preserve">
          <source>The purpose of the 100 (Continue) status (see &lt;a href=&quot;#section-10.1.1&quot;&gt;section 10.1.1&lt;/a&gt;) is to
   allow a client that is sending a request message with a request body
   to determine if the origin server is willing to accept the request
   (based on the request headers) before the client sends the request
   body. In some cases, it might either be inappropriate or highly
   inefficient for the client to send the body if the server will reject
   the message without looking at the body.

   Requirements for HTTP/1.1 clients:

      - If a client will wait for a 100 (Continue) response before
        sending the request body, it MUST send an Expect request-header
        field (&lt;a href=&quot;#section-14.20&quot;&gt;section 14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation.

      - A client MUST NOT send an Expect request-header field (&lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation if it does not intend
        to send a request body.

   Because of the presence of older implementations, the protocol allows
   ambiguous situations in which a client may send &quot;Expect: 100-
   continue&quot; without receiving either a 417 (Expectation Failed) status
   or a 100 (Continue) status. Therefore, when a client sends this
   header field to an origin server (possibly via a proxy) from which it
   has never seen a 100 (Continue) status, the client SHOULD NOT wait
   for an indefinite period before sending the request body.

   Requirements for HTTP/1.1 origin servers:

      - Upon receiving a request which includes an Expect request-header
        field with the &quot;100-continue&quot; expectation, an origin server MUST
        either respond with 100 (Continue) status and continue to read
        from the input stream, or respond with a final status code. The
        origin server MUST NOT wait for the request body before sending
        the 100 (Continue) response. If it responds with a final status
        code, it MAY close the transport connection or it MAY continue 

        to read and discard the rest of the request.  It MUST NOT
        perform the requested method if it returns a final status code.

      - An origin server SHOULD NOT send a 100 (Continue) response if
        the request message does not include an Expect request-header
        field with the &quot;100-continue&quot; expectation, and MUST NOT send a
        100 (Continue) response if such a request comes from an HTTP/1.0
        (or earlier) client. There is an exception to this rule: for
        compatibility with &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, a server MAY send a 100 (Continue)
        status in response to an HTTP/1.1 PUT or POST request that does
        not include an Expect request-header field with the &quot;100-
        continue&quot; expectation. This exception, the purpose of which is
        to minimize any client processing delays associated with an
        undeclared wait for 100 (Continue) status, applies only to
        HTTP/1.1 requests, and not to requests with any other HTTP-
        version value.

      - An origin server MAY omit a 100 (Continue) response if it has
        already received some or all of the request body for the
        corresponding request.

      - An origin server that sends a 100 (Continue) response MUST
        ultimately send a final status code, once the request body is
        received and processed, unless it terminates the transport
        connection prematurely.

      - If an origin server receives a request that does not include an
        Expect request-header field with the &quot;100-continue&quot; expectation,
        the request includes a request body, and the server responds
        with a final status code before reading the entire request body
        from the transport connection, then the server SHOULD NOT close
        the transport connection until it has read the entire request,
        or until the client closes the connection. Otherwise, the client
        might not reliably receive the response message. However, this
        requirement is not be construed as preventing a server from
        defending itself against denial-of-service attacks, or from
        badly broken client implementations.

   Requirements for HTTP/1.1 proxies:

      - If a proxy receives a request that includes an Expect request-
        header field with the &quot;100-continue&quot; expectation, and the proxy
        either knows that the next-hop server complies with HTTP/1.1 or
        higher, or does not know the HTTP version of the next-hop
        server, it MUST forward the request, including the Expect header
        field. 

      - If the proxy knows that the version of the next-hop server is
        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST
        respond with a 417 (Expectation Failed) status.

      - Proxies SHOULD maintain a cache recording the HTTP version
        numbers received from recently-referenced next-hop servers.

      - A proxy MUST NOT forward a 100 (Continue) response if the
        request message was received from an HTTP/1.0 (or earlier)
        client and did not include an Expect request-header field with
        the &quot;100-continue&quot; expectation. This requirement overrides the
        general rule for forwarding of 1xx responses (see &lt;a href=&quot;#section-10.1&quot;&gt;section 10.1&lt;/a&gt;).</source>
          <target state="translated">100（继续）状态（请参阅&lt;a href=&quot;#section-10.1.1&quot;&gt;第10.1.1节&lt;/a&gt;）的目的是允许正在发送带有请求正文的请求消息的客户端确定源服务器是否愿意接受请求（基于请求标头）在客户端发送请求正文之前。在某些情况下，如果服务器在不查看正文的情况下拒绝邮件，则客户端发送正文可能是不合适的，或者效率很低。 HTTP / 1.1客户端的要求：-如果客户端在发送请求正文之前将等待100（继续）响应，则必须发送带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段（&lt;a href=&quot;#section-14.20&quot;&gt;第14.20节&lt;/a&gt;）。 -客户端不得发送Expect请求标头字段（&lt;a href=&quot;#section-14.20&quot;&gt;部分&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;），如果它不打算发送请求正文，则期望为&amp;ldquo; 100-continue&amp;rdquo;。由于存在较早的实现，因此该协议允许模棱两可的情况，即客户端可以发送&amp;ldquo;期望：100-继续&amp;rdquo;，而不会接收到417（期望失败）状态或100（继续）状态。因此，当客户端将此标头字段发送到从未从其看到100（继续）状态的源服务器（可能通过代理）时，客户端不应在发送请求正文之前等待不确定的时间。 HTTP / 1.1原始服务器的要求：-收到包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段的请求后，源服务器必须以100（继续）状态响应并继续从输入流中读取，或以最终状态代码响应。原始服务器在发送100（继续）响应之前，绝对不能等待请求正文。如果它以最终状态代码响应，则可以关闭传输连接，或者可以继续读取并丢弃其余请求。如果返回最终状态代码，则不得执行所请求的方法。 -如果请求消息中不包含带有&amp;ldquo; 100-continue&amp;rdquo;期望值的Expect请求报头字段，则源服务器不应发送100（&amp;ldquo;继续&amp;rdquo;响应），并且如果此类请求到来，则不得发送100（&amp;ldquo;继续&amp;rdquo;）响应来自HTTP / 1.0（或更早版本）的客户端。此规则有一个例外：为了与&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;，服务器可以发送100（继续）状态，以响应HTTP / 1.1 PUT或POST请求，该请求不包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段。此异常的目的是最大程度减少与未声明的等待100（继续）状态相关的任何客户端处理延迟，该异常仅适用于HTTP / 1.1请求，而不适用于具有任何其他HTTP版本值的请求。 -如果原始服务器已经接收到相应请求的部分或全部请求主体，则它可以忽略100（继续）响应。 -一旦收到并处理了请求正文，发送100（继续）响应的原始服务器必须最终发送最终状态代码，除非它过早地终止传输连接。 -如果原始服务器收到的请求中不包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段，则该请求包含一个请求正文，并且服务器会从读取的整个请求正文之前返回最终状态代码进行响应传输连接，则服务器在读取整个请求之前或客户端关闭连接之前，不应关闭传输连接。否则，客户端可能无法可靠地接收响应消息。但是，此要求不能解释为阻止服务器防御拒绝服务攻击或严重破坏客户端实施的防御。HTTP / 1.1代理的要求：-如果代理收到的请求包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段，并且该代理知道下一跳服务器符合HTTP / 1.1或更高版本，或不知道下一跳服务器的HTTP版本，它必须转发请求，包括Expect标头字段。 -如果代理知道下一跳服务器的版本为HTTP / 1.0或更低版本，则它不得转发请求，并且必须以417（预期失败）状态进行响应。 -代理应该维护一个缓存，该缓存记录从最近引用的下一跳服务器接收到的HTTP版本号。-如果从HTTP / 1.0（或更早版本）的客户端接收到请求消息，并且代理不包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求报头字段，则代理不得转发100（&amp;ldquo; Continue&amp;rdquo;）响应。此要求优先于转发1xx响应的一般规则（请参阅&lt;a href=&quot;#section-10.1&quot;&gt;10.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0b61f958141b9100243d1bc18970ced7c1dcafec" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded &lt;em&gt;Subject Public Key Information&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future. See below on how to extract this information out of a certificate or key file.</source>
          <target state="translated">引用的字符串是Base64编码的&lt;em&gt;主题公共密钥信息&lt;/em&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;）指纹。可以为不同的公共密钥指定多个引脚。某些浏览器将来可能会允许使用SHA-256以外的其他哈希算法。请参阅以下有关如何从证书或密钥文件中提取此信息的信息。</target>
        </trans-unit>
        <trans-unit id="caac15f88bc560faaa8d23301f149cd934db87b9" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded Subject Public Key Information (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future.</source>
          <target state="translated">引用的字符串是Base64编码的主题公用密钥信息（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;）指纹。可以为不同的公共密钥指定多个引脚。某些浏览器将来可能会允许使用SHA-256以外的其他哈希算法。</target>
        </trans-unit>
        <trans-unit id="1e7090e603b1c8468593db08ace13cc460b311c3" translate="yes" xml:space="preserve">
          <source>The quoted string specifying the alternative authority which consists of an optional host override, a colon, and a mandatory port number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048868ca8bba5de4473c03e4f113e14a03b3840f" translate="yes" xml:space="preserve">
          <source>The range specified by the &lt;code&gt;Range&lt;/code&gt; header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.</source>
          <target state="translated">无法满足请求中&amp;ldquo; &lt;code&gt;Range&lt;/code&gt; 标头字段指定的范围；范围可能超出目标URI数据的大小。</target>
        </trans-unit>
        <trans-unit id="1d2b5330a14328ad92bbc96c72d50b3c95138424" translate="yes" xml:space="preserve">
          <source>The recommendation is to compress data as much as possible and therefore to use this field, but some types of resources, such as jpeg images, are already compressed. Sometimes, using additional compression doesn't reduce payload size and can even make the payload longer.</source>
          <target state="translated">建议尽可能地压缩数据,因此使用这个字段,但有些类型的资源,如jpeg图像,已经被压缩了。有时,使用额外的压缩并不能减少有效载荷大小,甚至会使有效载荷变长。</target>
        </trans-unit>
        <trans-unit id="b4310de37bf5d5b890a2b93359f92ce5fd4a2747" translate="yes" xml:space="preserve">
          <source>The recommended way of sniffing for Gecko-based browsers (if you &lt;em&gt;have to&lt;/em&gt; sniff for the browser engine instead of using feature detection) is by the presence of the &quot;&lt;code&gt;Gecko&lt;/code&gt;&quot; and &quot;&lt;code&gt;rv:&lt;/code&gt;&quot; strings, since some other browsers include a &quot;&lt;code&gt;like Gecko&lt;/code&gt;&quot; token.</source>
          <target state="translated">对于基于Gecko的浏览器，嗅探的推荐方法（如果您&lt;em&gt;必须对&lt;/em&gt;浏览器引擎&lt;em&gt;进行&lt;/em&gt;嗅探而不是使用功能检测）是通过存在&amp;ldquo; &lt;code&gt;Gecko&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;rv:&lt;/code&gt; &amp;rdquo;字符串，因为其他一些浏览器都包含&amp;ldquo; &lt;code&gt;like Gecko&lt;/code&gt; 令牌。</target>
        </trans-unit>
        <trans-unit id="835a33da74dbfed0d3a5afc284d8d5f7eeac4750" translate="yes" xml:space="preserve">
          <source>The referrer of the document in which the violation occurred.</source>
          <target state="translated">发生侵权行为的文件的提交人;</target>
        </trans-unit>
        <trans-unit id="060f5108fa86aba94bed9d14146f77e7e9a8271d" translate="yes" xml:space="preserve">
          <source>The referring resource is a local &quot;file&quot; or &quot;data&quot; URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457d2e04c3cca60af5bcc1e43cb940e66612e208" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +-----------+----------------------------------+---------------+
   | Warn Code | Short Description                | Reference     |
   +-----------+----------------------------------+---------------+
   | 110       | Response is Stale                | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | 111       | Revalidation Failed              | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | 112       | Disconnected Operation           | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   | 113       | Heuristic Expiration             | &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt; |
   | 199       | Miscellaneous Warning            | &lt;a href=&quot;#section-5.5.5&quot;&gt;Section 5.5.5&lt;/a&gt; |
   | 214       | Transformation Applied           | &lt;a href=&quot;#section-5.5.6&quot;&gt;Section 5.5.6&lt;/a&gt; |
   | 299       | Miscellaneous Persistent Warning | &lt;a href=&quot;#section-5.5.7&quot;&gt;Section 5.5.7&lt;/a&gt; |
   +-----------+----------------------------------+---------------+</source>
          <target state="translated">该注册表已使用以下注册填充：+ ----------- + --------------------------- ------- + --------------- + |警告代码|简短说明|参考| + ----------- + ---------------------------------- +- ------------- + | 110 |回应是过时的| &lt;a href=&quot;#section-5.5.1&quot;&gt;第5.5.1节&lt;/a&gt; | | 111 |重新验证失败| &lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt; | | 112 |断开连接的操作| &lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节&lt;/a&gt; | | 113 |启发式到期| &lt;a href=&quot;#section-5.5.4&quot;&gt;第5.5.4节&lt;/a&gt; | | 199 |其他警告| &lt;a href=&quot;#section-5.5.5&quot;&gt;第5.5.5节&lt;/a&gt; | | 214 |转化应用| &lt;a href=&quot;#section-5.5.6&quot;&gt;第5.5.6节&lt;/a&gt;| | 299 |其他持续警告| &lt;a href=&quot;#section-5.5.7&quot;&gt;第5.5.7节&lt;/a&gt; | + ----------- + ---------------------------------- +- ------------- +</target>
        </trans-unit>
        <trans-unit id="6bfb04acf1092d994bf84da7df6bb36e8f3a785e" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +------------------------+----------------------------------+
   | Cache Directive        | Reference                        |
   +------------------------+----------------------------------+
   | max-age                | &lt;a href=&quot;#section-5.2.1.1&quot;&gt;Section 5.2.1.1&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt; |
   | max-stale              | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;Section 5.2.1.2&lt;/a&gt;                  |
   | min-fresh              | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;Section 5.2.1.3&lt;/a&gt;                  |
   | must-revalidate        | &lt;a href=&quot;#section-5.2.2.1&quot;&gt;Section 5.2.2.1&lt;/a&gt;                  |
   | no-cache               | &lt;a href=&quot;#section-5.2.1.4&quot;&gt;Section 5.2.1.4&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt; |
   | no-store               | &lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.3&quot;&gt;Section 5.2.2.3&lt;/a&gt; |
   | no-transform           | &lt;a href=&quot;#section-5.2.1.6&quot;&gt;Section 5.2.1.6&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.4&quot;&gt;Section 5.2.2.4&lt;/a&gt; |
   | only-if-cached         | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;Section 5.2.1.7&lt;/a&gt;                  |
   | private                | &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Section 5.2.2.6&lt;/a&gt;                  |
   | proxy-revalidate       | &lt;a href=&quot;#section-5.2.2.7&quot;&gt;Section 5.2.2.7&lt;/a&gt;                  |
   | public                 | &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Section 5.2.2.5&lt;/a&gt;                  |
   | s-maxage               | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;                  |
   | stale-if-error         | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861], Section&amp;nbsp;4&lt;/a&gt;             |
   | stale-while-revalidate | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861], Section&amp;nbsp;3&lt;/a&gt;             |
   +------------------------+----------------------------------+</source>
          <target state="translated">该注册表已使用以下注册填充：+ ------------------------ + -------------- -------------------- + |缓存指令|参考| + ------------------------ + ------------------------ ---------- + |最大年龄| &lt;a href=&quot;#section-5.2.1.1&quot;&gt;第5.2.1.1 &lt;/a&gt;&lt;a href=&quot;#section-5.2.2.8&quot;&gt;节&lt;/a&gt;，第5.2.2.8节 | |最大陈旧| &lt;a href=&quot;#section-5.2.1.2&quot;&gt;第5.2.1.2节&lt;/a&gt; | |最小新鲜&lt;a href=&quot;#section-5.2.1.3&quot;&gt;第5.2.1.3节&lt;/a&gt; | |必须重新验证| &lt;a href=&quot;#section-5.2.2.1&quot;&gt;第5.2.2.1节&lt;/a&gt; | |无缓存| &lt;a href=&quot;#section-5.2.1.4&quot;&gt;第5.2.1.4 &lt;/a&gt;&lt;a href=&quot;#section-5.2.2.2&quot;&gt;节&lt;/a&gt;，第5.2.2.2节 | |无店| &lt;a href=&quot;#section-5.2.1.5&quot;&gt;第5.2.1.5节&lt;/a&gt;，&lt;a href=&quot;#section-5.2.2.3&quot;&gt;第5.2.2.3节&lt;/a&gt; | | 无变换| &lt;a href=&quot;#section-5.2.1.6&quot;&gt;第5.2.1.6 &lt;/a&gt;&lt;a href=&quot;#section-5.2.2.4&quot;&gt;节&lt;/a&gt;，第5.2.2.4节 | | 仅当缓存时| &lt;a href=&quot;#section-5.2.1.7&quot;&gt;第5.2.1.7节&lt;/a&gt; | | 私人| &lt;a href=&quot;#section-5.2.2.6&quot;&gt;第5.2.2.6节&lt;/a&gt; | | 代理重新验证| &lt;a href=&quot;#section-5.2.2.7&quot;&gt;第5.2.2.7节&lt;/a&gt; | | 公共| &lt;a href=&quot;#section-5.2.2.5&quot;&gt;第5.2.2.5节&lt;/a&gt; | | s-maxage | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;第5.2.2.9节&lt;/a&gt; | | 错误过时| &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861]，第4节&lt;/a&gt; | | 重新验证时失效| &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861]，第3节&lt;/a&gt; | + ------------------------ + ------------------------ ---------- +</target>
        </trans-unit>
        <trans-unit id="6c3e9e6ad9f0e3368fa4d44e9aa2e2c33c90d7a5" translate="yes" xml:space="preserve">
          <source>The relevant RFC document for the &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Upgrade header field is RFC 7230, section 6.7&lt;/a&gt;. The standard establishes rules for upgrading or changing to a different protocol on the current client, server, transport protocol connection. For example, this header standard allows a client to change from HTTP 1.1 to HTTP 2.0, assuming the server decides to acknowledge and implement the Upgrade header field. Neither party is required to accept the terms specified in the Upgrade header field. It can be used in both client and server headers. If the Upgrade header field is specified, then the sender MUST also send the Connection header field with the upgrade option specified. For details on the Connection header field &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;please see section 6.1 of the aforementioned RFC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;升级标头字段&lt;/a&gt;的相关RFC文档是RFC 7230的6.7节。该标准建立了在当前客户端，服务器，传输协议连接上升级或更改为其他协议的规则。例如，假设服务器决定确认并实现&amp;ldquo;升级&amp;rdquo;标头字段，则此标头标准允许客户端从HTTP 1.1更改为HTTP 2.0。双方均不需要接受&amp;ldquo;升级标题&amp;rdquo;字段中指定的条款。可以在客户端和服务器标头中使用它。如果指定了升级头字段，那么发送者还必须发送带有指定升级选项的连接头字段。有关Connection标头字段的详细信息，&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;请参见上述RFC的6.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9681bfccce6746b808712df87789877aff1a0a08" translate="yes" xml:space="preserve">
          <source>The remaining response header fields provide more information about
   the target resource for potential use in later requests.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Accept-Ranges     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7233]&lt;/a&gt; |
   | Allow             | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;            |
   | Server            | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;            |
   +-------------------+--------------------------+</source>
          <target state="translated">其余的响应头字段提供有关目标资源的更多信息，以供以后的请求中潜在使用。 + ------------------- + -------------------------- + |标头字段名称|定义于... | + ------------------- + -------------------------- + |接受范围| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;[RFC7233]第2.3节&lt;/a&gt; | |允许| &lt;a href=&quot;#section-7.4.1&quot;&gt;第7.4.1节&lt;/a&gt; | |服务器| &lt;a href=&quot;#section-7.4.2&quot;&gt;第7.4.2节&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="4af6457a5675ed1ed5b26a3a3626f6948e42d207" translate="yes" xml:space="preserve">
          <source>The report JSON object contains the following data:</source>
          <target state="translated">报告JSON对象包含以下数据:</target>
        </trans-unit>
        <trans-unit id="5baf54425251a0af52438742ec528ea5d7cad288" translate="yes" xml:space="preserve">
          <source>The representation data associated with an HTTP message is either
   provided as the payload body of the message or referred to by the
   message semantics and the effective request URI.  The representation
   data is in a format and encoding defined by the representation
   metadata header fields.

   The data type of the representation data is determined via the header
   fields Content-Type and Content-Encoding.  These define a two-layer,
   ordered encoding model:

     representation-data := Content-Encoding( Content-Type( bits ) )</source>
          <target state="translated">与HTTP消息相关联的表示数据要么作为消息的有效载荷体提供,要么由消息语义和有效请求URI引用。表示数据的格式和编码由表示元数据头字段定义。表示数据的数据类型通过头字段Content-Type和Content-Encoding决定。这两个字段定义了一个两层有序的编码模型:representation-data :=Content-Encoding(Content-Type(bits ))</target>
        </trans-unit>
        <trans-unit id="57fb990a7173c920416af3c97b46113340011437" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
   state of the resource. This code is only allowed in situations where
   it is expected that the user might be able to resolve the conflict
   and resubmit the request. The response body SHOULD include enough 

   information for the user to recognize the source of the conflict.
   Ideally, the response entity would include enough information for the
   user or user agent to fix the problem; however, that might not be
   possible and is not required.

   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the entity being PUT
   included changes to a resource which conflict with those made by an
   earlier (third-party) request, the server might use the 409 response
   to indicate that it can't complete the request. In this case, the
   response entity would likely contain a list of the differences
   between the two versions in a format defined by the response
   Content-Type.</source>
          <target state="translated">由于与资源的当前状态冲突,请求无法完成。只有在用户可能解决冲突并重新提交请求的情况下,才允许使用该代码。响应体应该包括足够的信息,以便用户识别冲突的来源。理想情况下,响应实体将包括足够的信息,让用户或用户代理能够解决问题;然而,这可能是不可能的,也不是必须的。冲突最可能发生在响应PUT请求时。例如,如果正在使用版本管理,并且被 PUT 的实体包含了对资源的更改,而这些更改与早期(第三方)请求所做的更改相冲突,服务器可能会使用 409 响应来表明它不能完成请求。在这种情况下,响应实体可能会包含两个版本之间的差异列表,其格式由响应Content-Type定义。</target>
        </trans-unit>
        <trans-unit id="62943efc1c331624006dfa87f2880914c04923b3" translate="yes" xml:space="preserve">
          <source>The request could not be understood by the server due to malformed
   syntax. The client SHOULD NOT repeat the request without
   modifications.</source>
          <target state="translated">由于语法错误,服务器无法理解该请求。客户端不应该不加修改地重复该请求。</target>
        </trans-unit>
        <trans-unit id="a5f388607fcf883d14ee29792afda2dc8c83b32d" translate="yes" xml:space="preserve">
          <source>The request failed due to failure of a previous request.</source>
          <target state="translated">由于之前的请求失败,导致请求失败。</target>
        </trans-unit>
        <trans-unit id="80b2b18dab161f54208331e259eefdc84181c453" translate="yes" xml:space="preserve">
          <source>The request has been accepted for processing, but the processing has
   not been completed.  The request might or might not eventually be
   acted upon, as it might be disallowed when processing actually takes
   place. There is no facility for re-sending a status code from an
   asynchronous operation such as this.

   The 202 response is intentionally non-committal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The entity returned with this
   response SHOULD include an indication of the request's current status
   and either a pointer to a status monitor or some estimate of when the
   user can expect the request to be fulfilled.</source>
          <target state="translated">请求已被受理,但处理工作尚未完成。该请求最终可能会被执行,也可能不会被执行,因为在实际处理时可能会被拒绝。没有从这样的异步操作中重新发送状态码的功能。202响应是有意的非承诺性的。它的目的是允许服务器接受对其他进程的请求(也许是一个每天只运行一次的面向批次的进程),而不要求用户代理与服务器的连接持续到进程完成。与这个响应一起返回的实体应该包括请求的当前状态的指示,以及指向状态监视器的指针或用户可以期望请求被完成的时间的某种估计。</target>
        </trans-unit>
        <trans-unit id="3496a6a34429a71d096b5d661e42c1a9bb755e60" translate="yes" xml:space="preserve">
          <source>The request has been fulfilled and resulted in a new resource being
   created. The newly created resource can be referenced by the URI(s)
   returned in the entity of the response, with the most specific URI
   for the resource given by a Location header field. The response
   SHOULD include an entity containing a list of resource
   characteristics and location(s) from which the user or user agent can
   choose the one most appropriate. The entity format is specified by
   the media type given in the Content-Type header field. The origin
   server MUST create the resource before returning the 201 status code.
   If the action cannot be carried out immediately, the server SHOULD
   respond with 202 (Accepted) response instead.

   A 201 response MAY contain an ETag response header field indicating
   the current value of the entity tag for the requested variant just
   created, see &lt;a href=&quot;#section-14.19&quot;&gt;section 14.19&lt;/a&gt;.</source>
          <target state="translated">该请求已完成，并导致创建了新资源。可以通过响应实体中返回的URI引用新创建的资源，其中最具体的URI由Location头字段给出。响应应该包括一个实体，其中包含资源特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由Content-Type标头字段中提供的媒体类型指定。原始服务器必须在返回201状态码之前创建资源。如果不能立即执行该操作，则服务器应以202（已接受）响应代替。201响应可能包含ETag响应标头字段，该字段指示刚刚创建的所请求变体的实体标签的当前值，请参见&lt;a href=&quot;#section-14.19&quot;&gt;第14.19条&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7d84e18807de0c6356f2f62e25c75fb03b74e11" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">该请求已被接收,但尚未采取行动。它是非承诺性的,意味着在HTTP中没有办法在以后发送一个异步响应来表示处理请求的结果。它的目的是用于另一个进程或服务器处理请求的情况,或者用于批处理。</target>
        </trans-unit>
        <trans-unit id="585082aac4586ccf5aebfeb0d6987e1358cca064" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is noncommittal, since there is no way in HTTP to later send an asynchronous response indicating the outcome of the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b875d4acb8b65c4bd9ffe04a6f98e27644fbcab" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. (There is no standardized way of choosing one of the responses, but HTML links to the possibilities are recommended so the user can pick.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563c97ec35447bf615f29b9828050c09a712103e" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. There is no standardized way of choosing one of the responses.</source>
          <target state="translated">该请求有一个以上可能的响应。用户代理或用户应选择其中之一。没有标准化的方式来选择其中一个响应。</target>
        </trans-unit>
        <trans-unit id="5487d137616e521aa017175b35b13aa2e3f74d3d" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a POST request, or after some PUT requests.</source>
          <target state="translated">请求已经成功,并因此创建了一个新的资源。这通常是在POST请求后或一些PUT请求后发送的响应。</target>
        </trans-unit>
        <trans-unit id="135d9441de12a3afffc64aee3e0646575c72a5dc" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result. This is typically the response sent after &lt;code&gt;POST&lt;/code&gt; requests, or some &lt;code&gt;PUT&lt;/code&gt; requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ecc9cc6596038de67ec68a577d983da6a673ef" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The information returned with the response
   is dependent on the method used in the request, for example:

   GET    an entity corresponding to the requested resource is sent in
          the response;

   HEAD   the entity-header fields corresponding to the requested
          resource are sent in the response without any message-body;

   POST   an entity describing or containing the result of the action; 

   TRACE  an entity containing the request message as received by the
          end server.</source>
          <target state="translated">请求已经成功。响应返回的信息取决于请求中使用的方法,例如。GET在响应中发送与请求资源相对应的实体;HEAD在响应中发送与请求资源相对应的实体头字段,不含任何消息体;POST是描述或包含操作结果的实体;TRACE是包含终端服务器收到的请求消息的实体。</target>
        </trans-unit>
        <trans-unit id="f565b6003126123248442292df2bf9baaa5e391b" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of a success varies depending on the HTTP method:</source>
          <target state="translated">请求成功了。成功的含义根据HTTP方法的不同而不同。</target>
        </trans-unit>
        <trans-unit id="9bd73430623220d33656725bff084d01a5160eeb" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of the success depends on the HTTP method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ea2a026f2515cb348f3705c18e0640e28ad870" translate="yes" xml:space="preserve">
          <source>The request header of note is &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, which shows that the invocation is coming from &lt;code&gt;https://foo.example&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11383f57aada516934509a2d3957090ac4763bc" translate="yes" xml:space="preserve">
          <source>The request looks something like this (less interesting headers are omitted here):</source>
          <target state="translated">请求看起来像这样(这里省略了不太有趣的标题)。</target>
        </trans-unit>
        <trans-unit id="0c671ed51daf22d159e04d7c4fd432023c8f3806" translate="yes" xml:space="preserve">
          <source>The request method and the body will not be altered, whereas &lt;a href=&quot;301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; may incorrectly sometimes be changed to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">请求方法和主体不会更改，而&lt;a href=&quot;301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;有时可能会错误地更改为&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="e391f1f093da1eaf3c8079eb9f1cb969d2137823" translate="yes" xml:space="preserve">
          <source>The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;, must never be disabled and should not return this error code.</source>
          <target state="translated">服务器知道该请求方法，但已被禁用，无法使用。例如，API可能禁止删除资源。决不能禁用两个强制方法 &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;HEAD&lt;/code&gt; ，并且不应返回此错误代码。</target>
        </trans-unit>
        <trans-unit id="3868804eb59e6799895608f9d8fc1f4241a46d74" translate="yes" xml:space="preserve">
          <source>The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">服务器不支持请求方法，无法处理该请求方法。要求服务器支持的唯一方法（因此不能返回此代码）是 &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cacbb0963918be12f6522f203c0731acc095523b" translate="yes" xml:space="preserve">
          <source>The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.

   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;)
   if those additional semantics do not conflict with the method.  For
   example, a client can send conditional request header fields
   (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) to make the requested action conditional on the current
   state of the target resource ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]).

     method = token

   HTTP was originally designed to be usable as an interface to
   distributed object systems.  The request method was envisioned as
   applying semantics to a target resource in much the same way as
   invoking a defined method on an identified object would apply
   semantics.  The method token is case-sensitive because it might be
   used as a gateway to object-based systems with case-sensitive method
   names.

   Unlike distributed objects, the standardized request methods in HTTP
   are not resource-specific, since uniform interfaces provide for
   better visibility and reuse in network-based systems [&lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;].  Once
   defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.

   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.  By
   convention, standardized methods are defined in all-uppercase
   US-ASCII letters. 

   +---------+-------------------------------------------------+-------+
   | Method  | Description                                     | Sec.  |
   +---------+-------------------------------------------------+-------+
   | GET     | Transfer a current representation of the target | 4.3.1 |
   |         | resource.                                       |       |
   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |
   |         | and header section.                             |       |
   | POST    | Perform resource-specific processing on the     | 4.3.3 |
   |         | request payload.                                |       |
   | PUT     | Replace all current representations of the      | 4.3.4 |
   |         | target resource with the request payload.       |       |
   | DELETE  | Remove all current representations of the       | 4.3.5 |
   |         | target resource.                                |       |
   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |
   |         | the target resource.                            |       |
   | OPTIONS | Describe the communication options for the      | 4.3.7 |
   |         | target resource.                                |       |
   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |
   |         | to the target resource.                         |       |
   +---------+-------------------------------------------------+-------+

   All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.

   Additional methods, outside the scope of this specification, have
   been standardized for use in HTTP.  All such methods ought to be
   registered within the &quot;Hypertext Transfer Protocol (HTTP) Method
   Registry&quot; maintained by IANA, as defined in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   The set of methods allowed by a target resource can be listed in an
   Allow header field (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;).  However, the set of allowed
   methods can change dynamically.  When a request method is received
   that is unrecognized or not implemented by an origin server, the
   origin server SHOULD respond with the 501 (Not Implemented) status
   code.  When a request method is received that is known by an origin
   server but not allowed for the target resource, the origin server
   SHOULD respond with the 405 (Method Not Allowed) status code.</source>
          <target state="translated">请求方法令牌是请求语义的主要来源。它指示客户端发出此请求的目的以及客户端期望成功的结果。如果请求方法中存在一些附加字段，则这些方法的语义可能会被某些标头字段的语义进一步专门化（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。例如，客户端可以发送条件请求标头字段（&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;），以使请求的操作基于目标资源的当前状态（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232]&lt;/a&gt;]）。 method =令牌HTTP最初旨在用作分布式对象系统的接口。可以将请求方法设想为将语义应用于目标资源的方式与在已标识的对象上调用定义的方法将应用语义的方式几乎相同。方法令牌区分大小写，因为它可以用作区分大小写的方法名称的基于对象的系统的网关。与分布式对象不同，HTTP中的标准化请求方法不是特定于资源的，因为统一的接口可在基于网络的系统中提供更好的可见性和重用性[ &lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;]。一旦定义，标准化方法在应用于任何资源时应具有相同的语义，尽管每个资源都自行确定是实现还是允许这些语义。下表概述了此规范定义了HTTP中常用的许多标准化方法。按照惯例，标准化方法以全大写的US-ASCII字母定义。 + --------- + --------------------------------------- ---------- + ------- + |方法描述秒| + --------- + --------------------------------------- ---------- + ------- + | GET |转移目标的当前表示| 4.3.1 | | |资源。 | | |头|与GET相同，但仅转移状态行| 4.3.2 | | |和标题部分。 | | |发布|对|执行特定于资源的处理4.3.3 | | |请求有效负载。 | | |放置|替换|的所有当前表示形式。 4.3.4 | | |具有请求有效负载的目标资源。 | | |删除删除|的所有当前表示。 4.3.5 | | |目标资源。 | | |连接|建立到由|标识的服务器的隧道4.3.6 | | |目标资源。 | | |选项|描述|的通讯选项。 4.3.7 | | |目标资源。| | |追踪|沿路径执行消息环回测试4.3.8 | | |到目标资源。 | | + --------- + --------------------------------------- ---------- + ------- +所有通用服务器必须支持GET和HEAD方法。所有其他方法都是可选的。在本规范范围之外的其他方法已经标准化，可以在HTTP中使用。所有此类方法都应在IANA维护的&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;中进行注册，如| | + --------- + --------------------------------------- ---------- + ------- +所有通用服务器必须支持GET和HEAD方法。所有其他方法都是可选的。在本规范范围之外的其他方法已经标准化，可以在HTTP中使用。所有此类方法都应在IANA维护的&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;中进行注册，如| | + --------- + --------------------------------------- ---------- + ------- +所有通用服务器必须支持GET和HEAD方法。所有其他方法都是可选的。在本规范范围之外的其他方法已经标准化，可以在HTTP中使用。所有此类方法都应在IANA维护的&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;中进行注册，如&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;。目标资源允许的方法集可以在&amp;ldquo;允许&amp;rdquo;标头字段中列出（&lt;a href=&quot;#section-7.4.1&quot;&gt;第7.4.1节&lt;/a&gt;）。但是，允许的方法集可以动态更改。当接收到源服务器无法识别或未实现的请求方法时，源服务器应以501（未实现）状态码响应。当接收到一个请求方法，该请求方法是源服务器已知的，但不允许目标资源使用时，源服务器应以405（方法不允许）状态码响应。</target>
        </trans-unit>
        <trans-unit id="ea4723439e12f3374a0c44c124fcfaaf67f0d247" translate="yes" xml:space="preserve">
          <source>The request requires user authentication. The response MUST include a
   WWW-Authenticate header field (&lt;a href=&quot;#section-14.47&quot;&gt;section 14.47&lt;/a&gt;) containing a challenge
   applicable to the requested resource. The client MAY repeat the
   request with a suitable Authorization header field (&lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;). If
   the request already included Authorization credentials, then the 401
   response indicates that authorization has been refused for those
   credentials. If the 401 response contains the same challenge as the
   prior response, and the user agent has already attempted
   authentication at least once, then the user SHOULD be presented the
   entity that was given in the response, since that entity might
   include relevant diagnostic information. HTTP access authentication
   is explained in &quot;HTTP Authentication: Basic and Digest Access
   Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">该请求需要用户认证。响应必须包括一个WWW-Authenticate头域（&lt;a href=&quot;#section-14.47&quot;&gt;第14.47节&lt;/a&gt;），该域包含适用于所请求资源的质询。客户端可以使用适当的Authorization标头字段重复请求（&lt;a href=&quot;#section-14.8&quot;&gt;第14.8节）&lt;/a&gt;）。如果请求已包含授权凭证，则401响应指示已拒绝这些凭证的授权。如果401响应包含与先前响应相同的质询，并且用户代理已经尝试了至少一次身份验证，则应该向用户提供响应中给定的实体，因为该实体可能包括相关的诊断信息。 HTTP访问身份验证在&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]中进行了说明。</target>
        </trans-unit>
        <trans-unit id="536c30469835dbdbadd49c3051aea9ea66357e5b" translate="yes" xml:space="preserve">
          <source>The request to TLS can be made either optionally or mandatorily.</source>
          <target state="translated">对TLS的请求可以是选择性的,也可以是强制性的。</target>
        </trans-unit>
        <trans-unit id="ab19f93fa18ca65854665f21139e776133cce6e1" translate="yes" xml:space="preserve">
          <source>The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.</source>
          <target state="translated">该请求指向的服务器无法产生响应。这可能是由未配置为对请求URI中包含的方案和权限组合产生响应的服务器发出的。</target>
        </trans-unit>
        <trans-unit id="e88680dcf3022af1b9dae0ac257cac1136f1dced" translate="yes" xml:space="preserve">
          <source>The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight</source>
          <target state="translated">该请求被重定向到'https://example.com/foo',这对于需要预检的跨源请求是不允许的。</target>
        </trans-unit>
        <trans-unit id="f7233ccb2f021155bf357e2393734dc2cb1fd475" translate="yes" xml:space="preserve">
          <source>The request was well-formed but was unable to be followed due to semantic errors.</source>
          <target state="translated">该请求格式良好,但由于语义错误而无法执行。</target>
        </trans-unit>
        <trans-unit id="c92c57474b6ca0ed55b1d1a0fed53a9265911a89" translate="yes" xml:space="preserve">
          <source>The request-header fields allow the client to pass additional
   information about the request, and about the client itself, to the
   server. These fields act as request modifiers, with semantics
   equivalent to the parameters on a programming language method
   invocation.

       request-header = Accept                   ; &lt;a href=&quot;#section-14.1&quot;&gt;Section 14.1&lt;/a&gt;
                      | Accept-Charset           ; &lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;
                      | Accept-Encoding          ; &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;
                      | Accept-Language          ; &lt;a href=&quot;#section-14.4&quot;&gt;Section 14.4&lt;/a&gt;
                      | Authorization            ; &lt;a href=&quot;#section-14.8&quot;&gt;Section 14.8&lt;/a&gt;
                      | Expect                   ; &lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;
                      | From                     ; &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;
                      | Host                     ; &lt;a href=&quot;#section-14.23&quot;&gt;Section 14.23&lt;/a&gt;
                      | If-Match                 ; &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt; 

                      | If-Modified-Since        ; &lt;a href=&quot;#section-14.25&quot;&gt;Section 14.25&lt;/a&gt;
                      | If-None-Match            ; &lt;a href=&quot;#section-14.26&quot;&gt;Section 14.26&lt;/a&gt;
                      | If-Range                 ; &lt;a href=&quot;#section-14.27&quot;&gt;Section 14.27&lt;/a&gt;
                      | If-Unmodified-Since      ; &lt;a href=&quot;#section-14.28&quot;&gt;Section 14.28&lt;/a&gt;
                      | Max-Forwards             ; &lt;a href=&quot;#section-14.31&quot;&gt;Section 14.31&lt;/a&gt;
                      | Proxy-Authorization      ; &lt;a href=&quot;#section-14.34&quot;&gt;Section 14.34&lt;/a&gt;
                      | Range                    ; &lt;a href=&quot;#section-14.35&quot;&gt;Section 14.35&lt;/a&gt;
                      | Referer                  ; &lt;a href=&quot;#section-14.36&quot;&gt;Section 14.36&lt;/a&gt;
                      | TE                       ; &lt;a href=&quot;#section-14.39&quot;&gt;Section 14.39&lt;/a&gt;
                      | User-Agent               ; &lt;a href=&quot;#section-14.43&quot;&gt;Section 14.43&lt;/a&gt;

   Request-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of request-
   header fields if all parties in the communication recognize them to
   be request-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">请求标头字段允许客户端将有关请求以及有关客户端本身的其他信息传递给服务器。这些字段充当请求修饰符，其语义等效于编程语言方法调用中的参数。 request-header =接受; &lt;a href=&quot;#section-14.1&quot;&gt;第14.1节&lt;/a&gt; |接受字符集&lt;a href=&quot;#section-14.2&quot;&gt;第14.2节&lt;/a&gt; |接受编码&lt;a href=&quot;#section-14.3&quot;&gt;第14.3节&lt;/a&gt; |接受语言&lt;a href=&quot;#section-14.4&quot;&gt;第14.4节&lt;/a&gt; |授权; &lt;a href=&quot;#section-14.8&quot;&gt;第14.8节&lt;/a&gt; |期望; &lt;a href=&quot;#section-14.20&quot;&gt;第14.20节&lt;/a&gt; |来自; &lt;a href=&quot;#section-14.22&quot;&gt;第14.22节&lt;/a&gt; |主持人; &lt;a href=&quot;#section-14.23&quot;&gt;第14.23节&lt;/a&gt; |如果匹配&lt;a href=&quot;#section-14.24&quot;&gt;第14.24节&lt;/a&gt; | If-Modified-Since; &lt;a href=&quot;#section-14.25&quot;&gt;第14.25节&lt;/a&gt; |如果不匹配&lt;a href=&quot;#section-14.26&quot;&gt;第14.26节&lt;/a&gt; | If-Range; &lt;a href=&quot;#section-14.27&quot;&gt;第14.27节&lt;/a&gt; | If-Unmodified-Since; &lt;a href=&quot;#section-14.28&quot;&gt;第14.28节&lt;/a&gt; | Max-Forwards；&lt;a href=&quot;#section-14.31&quot;&gt;第14.31节&lt;/a&gt; |代理授权&lt;a href=&quot;#section-14.34&quot;&gt;第14.34节&lt;/a&gt; |范围 ; &lt;a href=&quot;#section-14.35&quot;&gt;第14.35节&lt;/a&gt; |推荐人; &lt;a href=&quot;#section-14.36&quot;&gt;第14.36节&lt;/a&gt; | TE; &lt;a href=&quot;#section-14.39&quot;&gt;第14.39节&lt;/a&gt; |用户代理 ; 只有结合协议版本的更改，才能可靠地扩展&lt;a href=&quot;#section-14.43&quot;&gt;14.43节的&lt;/a&gt;请求标头字段名称。但是，如果通信中的所有各方都将它们视为请求标头字段，则可以为新的或实验性标头字段赋予请求标头字段的语义。无法识别的标头字段被视为实体标头字段。</target>
        </trans-unit>
        <trans-unit id="00ee3240d5b62db652acaaec1c517dfc4187762e" translate="yes" xml:space="preserve">
          <source>The requested resource MUST be accessed through the proxy given by
   the Location field. The Location field gives the URI of the proxy.
   The recipient is expected to repeat this single request via the
   proxy. 305 responses MUST only be generated by origin servers.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; was not clear that 305 was intended to redirect a
      single request, and to be generated by origin servers only.  Not
      observing these limitations has significant security consequences.</source>
          <target state="translated">所请求的资源必须通过位置字段给出的代理访问。位置字段提供代理的URI。预计收件人将通过代理重复此单个请求。305个响应只能由原始服务器生成。注意：&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;不清楚305是否旨在重定向单个请求，并且仅由原始服务器生成。不遵守这些限制会产生重大的安全后果。</target>
        </trans-unit>
        <trans-unit id="d984d2d7ff09514806eb927c4043ee9bc91f6a1d" translate="yes" xml:space="preserve">
          <source>The requested resource corresponds to any one of a set of
   representations, each with its own specific location, and agent-
   driven negotiation information (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) is being provided so that
   the user (or user agent) can select a preferred representation and
   redirect its request to that location.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of resource characteristics and location(s) from
   which the user or user agent can choose the one most appropriate. The
   entity format is specified by the media type given in the Content-
   Type header field. Depending upon the format and the capabilities of 

   the user agent, selection of the most appropriate choice MAY be
   performed automatically. However, this specification does not define
   any standard for such automatic selection.

   If the server has a preferred choice of representation, it SHOULD
   include the specific URI for that representation in the Location
   field; user agents MAY use the Location field value for automatic
   redirection. This response is cacheable unless indicated otherwise.</source>
          <target state="translated">所请求的资源对应于一组表示中的任何一个，每个表示都有自己的特定位置，以及代理驱动的协商信息（&lt;a href=&quot;#section-12&quot;&gt;第12节）&lt;/a&gt;），以便用户（或用户代理）可以选择首选的表示形式并将其请求重定向到该位置。除非它是HEAD请求，否则响应应包含一个实体，其中包含资源特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由&amp;ldquo;内容类型&amp;rdquo;标头字段中提供的媒体类型指定。根据用户代理的格式和功能，可以自动执行最合适的选择。但是，该规范没有为这种自动选择定义任何标准。如果服务器具有首选的表示形式，则应在&amp;ldquo;位置&amp;rdquo;字段中包含该表示形式的特定URI；用户代理可以使用&amp;ldquo;位置&amp;rdquo;字段值进行自动重定向。除非另有说明，否则此响应是可缓存的。</target>
        </trans-unit>
        <trans-unit id="e7c77b9895c801f0e66c9d13d10555d8495d972e" translate="yes" xml:space="preserve">
          <source>The requested resource has been assigned a new permanent URI and any
   future references to this resource SHOULD use one of the returned
   URIs.  Clients with link editing capabilities ought to automatically
   re-link references to the Request-URI to one or more of the new
   references returned by the server, where possible. This response is
   cacheable unless indicated otherwise.

   The new permanent URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

   If the 301 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: When automatically redirecting a POST request after
      receiving a 301 status code, some existing HTTP/1.0 user agents
      will erroneously change it into a GET request.</source>
          <target state="translated">被请求的资源已经被分配了一个新的永久URI,今后对该资源的任何引用都应该使用返回的URI之一。具有链接编辑功能的客户机应该尽可能自动地将对Request-URI的引用重新链接到服务器返回的一个或多个新的引用。除非另有说明,否则这个响应是可以缓存的。新的永久URI应该由响应中的Location字段给出。除非请求方法是HEAD,否则响应的实体应该包含一个简短的超文本注释,其中有指向新URI的超链接。如果301状态码是在响应GET或HEAD以外的请求时收到的,用户代理不应该自动重定向请求,除非它能被用户确认,因为这可能会改变发出请求的条件。注意:当收到301状态码后自动重定向POST请求时,一些现有的HTTP/1.0用户代理会错误地将其改为GET请求。</target>
        </trans-unit>
        <trans-unit id="84c9980aa16b04f88efc81ddd498027c5e617c08" translate="yes" xml:space="preserve">
          <source>The requested resource is no longer available at the server and no
   forwarding address is known. This condition is expected to be
   considered permanent. Clients with link editing capabilities SHOULD
   delete references to the Request-URI after user approval. If the
   server does not know, or has no facility to determine, whether or not
   the condition is permanent, the status code 404 (Not Found) SHOULD be
   used instead. This response is cacheable unless indicated otherwise.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer working at the server's site. It is not
   necessary to mark all permanently unavailable resources as &quot;gone&quot; or
   to keep the mark for any length of time -- that is left to the
   discretion of the server owner.</source>
          <target state="translated">所请求的资源在服务器上已不可用,且不知道转发地址。这种情况会被认为是永久性的。具有链接编辑功能的客户端应该在用户批准后删除对Request-URI的引用。如果服务器不知道或没有设施确定该条件是否是永久性的,应使用状态代码404(Not Found)来代替。除非另有说明,否则该响应是可缓存的。410 响应的主要目的是通过通知接收者该资源是故意不可用的,以及服务器所有者希望删除指向该资源的远程链接来协助网络维护工作。这种事件常见于限时、促销服务和属于个人不再在服务器站点工作的资源。没有必要将所有永久不可用的资源标记为 &quot;消失&quot;,也没有必要在任何时间内保持这一标记 ----这由服务器所有者自行决定。</target>
        </trans-unit>
        <trans-unit id="3a016e600e3bce12c26484b50fa5be354243d903" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection MAY be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s) , since many pre-HTTP/1.1 user agents do not
   understand the 307 status. Therefore, the note SHOULD contain the
   information necessary for a user to repeat the original request on
   the new URI.

   If the 307 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.</source>
          <target state="translated">请求的资源暂时驻留在不同的URI下。由于重定向可能偶尔会被改变,所以客户端应该在未来的请求中继续使用Request-URI。这个响应只有在Cache-Control或Expires头字段显示的情况下才是可缓存的。临时URI应该由响应中的Location字段给出。除非请求方法是HEAD,否则响应的实体应该包含一个简短的超文本注释,并带有指向新URI的超链接,因为许多前HTTP/1.1的用户代理不理解307状态。因此,该注释应包含必要的信息,以便用户在新的URI上重复原始请求。如果307状态码是在响应GET或HEAD以外的请求时收到的,除非用户确认,否则用户代理不得自动重定向该请求,因为这可能会改变发出请求的条件。</target>
        </trans-unit>
        <trans-unit id="a9d909310ffffdfd39320376da2640abfbc56135" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection might be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s). 

   If the 302 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; specify that the client is not allowed
      to change the method on the redirected request.  However, most
      existing user agent implementations treat 302 as if it were a 303
      response, performing a GET on the Location field-value regardless
      of the original request method. The status codes 303 and 307 have
      been added for servers that wish to make unambiguously clear which
      kind of reaction is expected of the client.</source>
          <target state="translated">所请求的资源临时位于其他URI下。由于重定向有时可能会更改，因此客户端应继续将Request-URI用于将来的请求。仅当由Cache-Control或Expires标头字段指示时，此响应才可缓存。临时URI应该由响应中的Location字段给出。除非请求方法是HEAD，否则响应的实体应包含简短的超文本注释，并带有指向新URI的超链接。如果响应GET或HEAD以外的请求而接收到302状态码，则用户代理不得自动重定向该请求，除非用户可以确认，因为这可能会更改发出该请求的条件。注意：&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;指定不允许客户端更改重定向请求上的方法。但是，大多数现有的用户代理实现都将302视为303响应，而不管原始请求方法如何，都对Location字段值执行GET。已为希望明确弄清客户端期望哪种反应的服务器添加了状态代码303和307。</target>
        </trans-unit>
        <trans-unit id="24d06f0884418e17262e5806d51e7313670997da" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host header
   field (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), report an error if it is missing from an
   HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) are among
   the most important changes defined by HTTP/1.1. 

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed.  The Host header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional
   requirements were placed on all HTTP/1.1 requests in order to ensure
   complete adoption.  At the time of this writing, most HTTP-based
   services are dependent upon the Host header field for targeting
   requests.</source>
          <target state="translated">客户端和服务器支持主机标头字段（&lt;a href=&quot;#section-5.4&quot;&gt;第5.4节&lt;/a&gt;）的要求，如果HTTP / 1.1请求中缺少该错误，则报告错误，并接受绝对URI（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节）&lt;/a&gt;）是HTTP / 1.1定义的最重要的更改之一。较旧的HTTP / 1.0客户端假定IP地址和服务器是一对一的关系。除了将请求定向到的IP地址之外，没有其他成熟的机制可用于区分请求的目标服务器。 Host标头字段是在HTTP / 1.1的开发过程中引入的，尽管大多数HTTP / 1.0浏览器很快实现了Host标头字段，但对所有HTTP / 1.1请求都提出了附加要求，以确保完全采用。在撰写本文时，大多数基于HTTP的服务都依赖于Host Header字段来定向请求。</target>
        </trans-unit>
        <trans-unit id="554d1e6bd5194783475ebafadd7bbf4b3ceb10ad" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host request-
   header, report an error if the Host request-header (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) is
   missing from an HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.1.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;) are among the most important changes defined by this
   specification.

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The changes outlined above will
   allow the Internet, once older HTTP clients are no longer common, to
   support multiple Web sites from a single IP address, greatly
   simplifying large operational Web servers, where allocation of many
   IP addresses to a single host has created serious problems. The
   Internet will also be able to recover the IP addresses that have been
   allocated for the sole purpose of allowing special-purpose domain
   names to be used in root-level HTTP URLs. Given the rate of growth of
   the Web, and the number of servers already deployed, it is extremely 

   important that all implementations of HTTP (including updates to
   existing HTTP/1.0 applications) correctly implement these
   requirements:

      - Both clients and servers MUST support the Host request-header.

      - A client that sends an HTTP/1.1 request MUST send a Host header.

      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1
        request does not include a Host request-header.

      - Servers MUST accept absolute URIs.</source>
          <target state="translated">客户端和服务器支持主机请求标头的要求，如果HTTP / 1.1请求中缺少主机请求标头（&lt;a href=&quot;#section-14.23&quot;&gt;第14.23节&lt;/a&gt;），则报告错误，并接受绝对URI（&lt;a href=&quot;#section-5.1.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2 &lt;/a&gt;节））是本规范定义的最重要的更改之一。较旧的HTTP / 1.0客户端假定IP地址和服务器是一对一的关系。除了将请求定向到的IP地址之外，没有其他成熟的机制可用于区分请求的目标服务器。上面概述的更改将使Internet（不再使用较旧的HTTP客户端时）可以从单个IP地址支持多个网站，从而大大简化了大型可操作Web服务器，其中将多个IP地址分配给单个主机会造成严重问题。互联网也将能够恢复已分配的IP地址，其唯一目的是允许在根级HTTP URL中使用特殊用途的域名。鉴于网络的增长速度，以及已经部署的服务器数量，所有HTTP实现（包括对现有HTTP / 1.0应用程序的更新）正确实现以下要求非常重要：-客户端和服务器都必须支持主机请求头。 -发送HTTP / 1.1请求的客户端必须发送主机标头。 -如果HTTP / 1.1请求不包含主机请求标头，则服务器必须报告400（错误请求）错误。 -服务器必须接受绝对URI。1个请求务必发送一个Host标头。 -如果HTTP / 1.1请求不包含主机请求标头，则服务器必须报告400（错误请求）错误。 -服务器必须接受绝对URI。1个请求必须发送一个Host标头。 -如果HTTP / 1.1请求不包含主机请求标头，则服务器必须报告400（错误请求）错误。 -服务器必须接受绝对URI。</target>
        </trans-unit>
        <trans-unit id="b85098c9f819adbf87cde9578f01517d8065c6c2" translate="yes" xml:space="preserve">
          <source>The resource identified by the request is only capable of generating
   response entities which have content characteristics not acceptable
   according to the accept headers sent in the request.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of available entity characteristics and location(s)
   from which the user or user agent can choose the one most
   appropriate. The entity format is specified by the media type given
   in the Content-Type header field. Depending upon the format and the
   capabilities of the user agent, selection of the most appropriate
   choice MAY be performed automatically. However, this specification
   does not define any standard for such automatic selection.

      Note: HTTP/1.1 servers are allowed to return responses which are
      not acceptable according to the accept headers sent in the
      request. In some cases, this may even be preferable to sending a
      406 response. User agents are encouraged to inspect the headers of
      an incoming response to determine if it is acceptable.

   If the response could be unacceptable, a user agent SHOULD
   temporarily stop receipt of more data and query the user for a
   decision on further actions.</source>
          <target state="translated">请求所确定的资源只能生成响应实体,这些实体的内容特征根据请求中发送的接受头不能接受。除非是HEAD请求,否则响应应该包括一个实体,其中包含一个可用的实体特性和位置的列表,用户或用户代理可以从中选择一个最合适的实体。实体格式由Content-Type头域中给出的媒体类型指定。根据格式和用户代理的能力,可以自动选择最合适的选择。但是,本规范并没有为这种自动选择定义任何标准。注意:HTTP/1.1服务器允许返回根据请求中发送的accept头不能接受的响应。在某些情况下,这甚至可能比发送406响应更可取。我们鼓励用户代理检查传入响应的头信息,以确定它是否可以接受。如果响应可能是不可接受的,用户代理showould暂时停止接收更多的数据,并询问用户以决定进一步的行动。</target>
        </trans-unit>
        <trans-unit id="7d38c9e9eed37f8ebb054ffe20689cb741c8e1bf" translate="yes" xml:space="preserve">
          <source>The resource that is being accessed is locked.</source>
          <target state="translated">正在访问的资源被锁定。</target>
        </trans-unit>
        <trans-unit id="2e6d65ce6753d6adca24d41c2f2aab6cad178c87" translate="yes" xml:space="preserve">
          <source>The response from the server may include these.</source>
          <target state="translated">服务器的响应可能包括这些。</target>
        </trans-unit>
        <trans-unit id="0596f7bd46252bc01ceca1b37ff3abcdb40b4bc7" translate="yes" xml:space="preserve">
          <source>The response header fields allow the server to pass additional
   information about the response beyond what is placed in the
   status-line.  These header fields give information about the server,
   about further access to the target resource, or about related
   resources.

   Although each response header field has a defined meaning, in
   general, the precise semantics might be further refined by the
   semantics of the request method and/or response status code.</source>
          <target state="translated">响应头字段允许服务器在状态行中的内容之外传递关于响应的附加信息。这些头字段给出了关于服务器的信息,关于进一步访问目标资源的信息,或者关于相关资源的信息。虽然每个响应头字段都有确定的含义,但一般来说,精确的语义可能会由请求方法和/或响应状态码的语义进一步细化。</target>
        </trans-unit>
        <trans-unit id="ff7a362ee27a0f1762005f0ec6ebc5bb964259ee" translate="yes" xml:space="preserve">
          <source>The response is extremely simple too: it only consisted of the file itself.</source>
          <target state="translated">响应也极其简单:它只由文件本身组成。</target>
        </trans-unit>
        <trans-unit id="a187e434f07fa362732384aa76405b41edb39ff9" translate="yes" xml:space="preserve">
          <source>The response may &lt;strong&gt;not&lt;/strong&gt; be stored in &lt;em&gt;any&lt;/em&gt; cache. Note that this will not prevent a valid &lt;em&gt;pre-existing&lt;/em&gt; cached response being returned. Clients can set &lt;code&gt;max-age=0&lt;/code&gt; to also clear existing cache responses, as this forces the cache to revalidate with the server (no other directives have an effect when used with &lt;code&gt;no-store&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="175c4a1ccf44338f289e8f6a8f5b206b71c5531a" translate="yes" xml:space="preserve">
          <source>The response may be stored by &lt;em&gt;any&lt;/em&gt; cache, even if the response is normally non-cacheable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2982c4aaa9bc3f78fafab7d00a3ebb08a20bc3" translate="yes" xml:space="preserve">
          <source>The response may be stored by &lt;em&gt;any&lt;/em&gt; cache, even if the response is normally non-cacheable. However, the stored response MUST &lt;em&gt;always&lt;/em&gt; go through validation with the origin server first before using it, therefore, you cannot use &lt;code&gt;no-cache&lt;/code&gt; in-conjunction with &lt;code&gt;immutable&lt;/code&gt;. &lt;code&gt;no-store&lt;/code&gt;&lt;em&gt;This directive is not effective in preventing caches from storing your response.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa0d406c5950086dcf14084183c400a270e03bf" translate="yes" xml:space="preserve">
          <source>The response may be stored only by a &lt;em&gt;browser's&lt;/em&gt; cache, even if the response is normally non-cacheable. &lt;code&gt;no-store&lt;/code&gt;&lt;em&gt;This directive is not effective in preventing caches from storing your response.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18efe3bb77387fcf6dc94b18b57204fcd81a30a1" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header that holds the allowed methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513c2898705ac68cc3e3ee06f80d9c90116f1922" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header with the allowed methods:</source>
          <target state="translated">然后，响应包含带有允许方法的&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;标头：</target>
        </trans-unit>
        <trans-unit id="18088efa80d68a5ff78b12db71323e5708eee380" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is missing the required &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, which is used to determine whether or not the resource can be accessed by content operating within the current origin.</source>
          <target state="translated">对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求的响应缺少必需的&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;标头，该标头用于确定当前源内操作的内容是否可以访问资源。</target>
        </trans-unit>
        <trans-unit id="bacd2f05b83c3c39f0e7214a569bb88e96978d01" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid header name.</source>
          <target state="translated">服务器发送的对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求的响应包括一个&lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;头，该头包括至少一个无效的头名。</target>
        </trans-unit>
        <trans-unit id="15a529998feb2d569f6cffb35b10491d075a60be" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid method name.</source>
          <target state="translated">服务器发送的对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求的响应包括一个&lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;标头，该标头包含至少一个无效的方法名称。</target>
        </trans-unit>
        <trans-unit id="2ae0be16c13fe096b642ef89520ae9e65e43a5c6" translate="yes" xml:space="preserve">
          <source>The response to the request can be found under a different URI and
   SHOULD be retrieved using a GET method on that resource. This method
   exists primarily to allow the output of a POST-activated script to
   redirect the user agent to a selected resource. The new URI is not a
   substitute reference for the originally requested resource. The 303
   response MUST NOT be cached, but the response to the second
   (redirected) request might be cacheable.

   The different URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

      Note: Many pre-HTTP/1.1 user agents do not understand the 303
      status. When interoperability with such clients is a concern, the
      302 status code may be used instead, since most user agents react
      to a 302 response as described here for 303.</source>
          <target state="translated">对请求的响应可以在不同的URI下找到,并且应该使用该资源的GET方法来检索。这种方法的存在主要是为了允许POST激活脚本的输出将用户代理重定向到选定的资源。新的URI不能替代最初请求的资源的引用。303响应必须不被缓存,但第二个(重定向)请求的响应可能是可缓存的。不同的URI应该由响应中的Location字段给出。除非请求方法是HEAD,否则响应的实体应该包含一个简短的超文本注释,并带有指向新URI的超链接。注意:许多HTTP/1.1之前的用户代理不理解303状态。当与这些客户机的互操作性是一个问题时,可以使用302状态代码来代替,因为大多数用户代理对302响应的反应就像这里对303的描述。</target>
        </trans-unit>
        <trans-unit id="12506b704a003858abdf13381ee9b21f91a7f1af" translate="yes" xml:space="preserve">
          <source>The response-header fields allow the server to pass additional
   information about the response which cannot be placed in the Status-
   Line. These header fields give information about the server and about
   further access to the resource identified by the Request-URI.

       response-header = Accept-Ranges           ; &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;
                       | Age                     ; &lt;a href=&quot;#section-14.6&quot;&gt;Section 14.6&lt;/a&gt;
                       | ETag                    ; &lt;a href=&quot;#section-14.19&quot;&gt;Section 14.19&lt;/a&gt;
                       | Location                ; &lt;a href=&quot;#section-14.30&quot;&gt;Section 14.30&lt;/a&gt;
                       | Proxy-Authenticate      ; &lt;a href=&quot;#section-14.33&quot;&gt;Section 14.33&lt;/a&gt; 

                       | Retry-After             ; &lt;a href=&quot;#section-14.37&quot;&gt;Section 14.37&lt;/a&gt;
                       | Server                  ; &lt;a href=&quot;#section-14.38&quot;&gt;Section 14.38&lt;/a&gt;
                       | Vary                    ; &lt;a href=&quot;#section-14.44&quot;&gt;Section 14.44&lt;/a&gt;
                       | WWW-Authenticate        ; &lt;a href=&quot;#section-14.47&quot;&gt;Section 14.47&lt;/a&gt;

   Response-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of response-
   header fields if all parties in the communication recognize them to
   be response-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">响应头字段允许服务器传递关于响应的其他信息，这些信息不能放在状态行中。这些头字段提供有关服务器以及对由Request-URI标识的资源的进一步访问的信息。 response-header =接受范围；&lt;a href=&quot;#section-14.5&quot;&gt;第14.5节&lt;/a&gt; |年龄; &lt;a href=&quot;#section-14.6&quot;&gt;第14.6节&lt;/a&gt; | ETag; &lt;a href=&quot;#section-14.19&quot;&gt;第14.19节&lt;/a&gt; |位置 ; &lt;a href=&quot;#section-14.30&quot;&gt;第14.30节&lt;/a&gt; |代理验证&lt;a href=&quot;#section-14.33&quot;&gt;第14.33节&lt;/a&gt; |重试后&lt;a href=&quot;#section-14.37&quot;&gt;第14.37节&lt;/a&gt; | 服务器; &lt;a href=&quot;#section-14.38&quot;&gt;第14.38节&lt;/a&gt; | 变化; &lt;a href=&quot;#section-14.44&quot;&gt;第14.44节&lt;/a&gt; | WWW认证 只有结合协议版本的更改，才能可靠地扩展&lt;a href=&quot;#section-14.47&quot;&gt;14.47节的&lt;/a&gt;响应头字段名称。但是，如果通信中的所有各方都将它们识别为响应头字段，则可以为新的或实验性的头字段赋予响应头字段的语义。无法识别的标头字段被视为实体标头字段。</target>
        </trans-unit>
        <trans-unit id="e9dacdcee08be9c8b87ede18aa52688f460db02e" translate="yes" xml:space="preserve">
          <source>The resulting string is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded (&lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt;).</source>
          <target state="translated">结果字符串是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt;编码的（ &lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe3f7b6dc9ffc173061b38ba8ad0c8201cfdcbaa" translate="yes" xml:space="preserve">
          <source>The returned metainformation in the entity-header is not the
   definitive set as available from the origin server, but is gathered
   from a local or a third-party copy. The set presented MAY be a subset
   or superset of the original version. For example, including local
   annotation information about the resource might result in a superset
   of the metainformation known by the origin server. Use of this
   response code is not required and is only appropriate when the
   response would otherwise be 200 (OK).</source>
          <target state="translated">实体头中返回的元信息并不是来自原服务器的最终集合,而是从本地或第三方副本中收集的。显示的集合可能是原始版本的子集或超集。例如,包含资源的本地注释信息可能会导致源服务器已知的元信息的超集。不需要使用此响应代码,只有在响应为200(OK)时才适合使用。</target>
        </trans-unit>
        <trans-unit id="18a95000f2ca8553876b3106954ec5daa00d8eec" translate="yes" xml:space="preserve">
          <source>The revision version added to revved resources doesn't need to be a classical revision string like 1.1.3, or even a monotonously growing suite of number. It can be anything that prevent collisions, like a hash or a date.</source>
          <target state="translated">添加到已修订资源中的修订版本不需要是像 1.1.3 这样的经典修订字符串,甚至不需要是一个单调增长的数字套件。它可以是任何可以防止碰撞的东西,比如哈希值或日期。</target>
        </trans-unit>
        <trans-unit id="b125ccbfa7a0e3bda312abb6c814a3f729297ece" translate="yes" xml:space="preserve">
          <source>The root of a Category Document is the &quot;app:categories&quot; element.  An
   app:categories element can contain zero or more atom:category
   elements from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] namespace
   (&quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;).

   An atom:category child element that has no &quot;scheme&quot; attribute
   inherits the attribute from its app:categories parent.  An atom:
   category child element with an existing &quot;scheme&quot; attribute does not
   inherit the &quot;scheme&quot; value of its app:categories parent element. 

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       }

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories</source>
          <target state="translated">类别文档的根是&amp;ldquo; app：categories&amp;rdquo;元素。 app：categories元素可以包含零个或多个来自Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]名称空间（&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &amp;rdquo;的atom：category元素没有&amp;ldquo; scheme&amp;rdquo;属性的atom：category子元素会从其app：categories父级继承该属性。具有现有&amp;ldquo; scheme&amp;rdquo;属性的atom：category子元素不会继承其app的&amp;ldquo; scheme&amp;rdquo;值：Category父元素。 &amp;ldquo; no&amp;rdquo;} ?，属性方案{atomURI} ?,（atomCategory *，undefinedContent）} appOutOfLineCategories =元素app：类别{属性href {atomURI}，undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories</target>
        </trans-unit>
        <trans-unit id="dac1669f4b5c683593043fc93e45f9e39b9b3183" translate="yes" xml:space="preserve">
          <source>The root of a Service Document is the &quot;app:service&quot; element.

   The app:service element is the container for service information
   associated with one or more Workspaces.  An app:service element MUST
   contain one or more app:workspace elements.

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   start = appService

   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }</source>
          <target state="translated">服务文档的根是&amp;ldquo; app：service&amp;rdquo;元素。 app：service元素是与一个或多个工作区关联的服务信息的容器。一个app：service元素必须包含一个或多个app：workspace元素。名称空间app =&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;rdquo; start = appService appService =元素app：service {appCommonAttributes，（appWorkspace +＆extensionElement *）}}</target>
        </trans-unit>
        <trans-unit id="7cc82da0d72b8678f1e0f58ad59a34e42ed94203" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ded409a46c9e2ba7534a99504667ab5ee8ab0f" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. In this case, it is an intermediate proxy that requires authentication. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="translated">相同的质询和响应机制可用于&lt;em&gt;代理身份验证&lt;/em&gt;。在这种情况下，它是需要身份验证的中间代理。由于资源认证和代理认证可以共存，因此需要不同的头和状态码集。在代理的情况下，具有挑战性的状态码为&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt;（需要代理身份验证），&amp;ldquo; &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;响应标头包含至少一个适用于代理的质询，并且&amp;ldquo; &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;请求标头用于向代理提供凭据服务器。</target>
        </trans-unit>
        <trans-unit id="0fb319a198a96a066c14d3602f889f224011cec2" translate="yes" xml:space="preserve">
          <source>The same-site attribute can have one of two values:</source>
          <target state="translated">同站点属性可以有两个值中的一个。</target>
        </trans-unit>
        <trans-unit id="a4b6e8afc97244358680d329fe8d9b651eecefb1" translate="yes" xml:space="preserve">
          <source>The second way to use Feature Policy is for controlling content within an iframe. Use the &lt;code&gt;allow&lt;/code&gt; attribute to specify a policy list for embedded content.</source>
          <target state="translated">使用功能策略的第二种方法是控制iframe中的内容。使用 &lt;code&gt;allow&lt;/code&gt; 属性为嵌入式内容指定策略列表。</target>
        </trans-unit>
        <trans-unit id="fe3498e5bef07e6ed03f63dc1e56c45eca481341" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Access Control Requests&lt;/a&gt; shows a header exchange between client and server. A server resource responding to a preflight requests needs to be able to make the following determinations:</source>
          <target state="translated">在部分&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;预检访问控制请求&lt;/a&gt;示出客户机和服务器之间的报头交换。响应预检请求的服务器资源需要能够做出以下确定：</target>
        </trans-unit>
        <trans-unit id="90f4ec1e7f4c071f00d99bb58a633629eba8d99f" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Access Control Requests&lt;/a&gt; shows you the header exchanges between client and server. Here is a PHP code segment that handles a Simple Request:</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;cors#Simple_requests&quot;&gt;简单访问控制请求&lt;/a&gt; &amp;rdquo;部分向您显示了客户端和服务器之间的标头交换。这是一个处理简单请求的PHP代码段：</target>
        </trans-unit>
        <trans-unit id="fa4d350781530c820391fd6c19e201ae2a7686b3" translate="yes" xml:space="preserve">
          <source>The semantics of GET are unchanged when applied to a collection,
   since GET is defined as, &quot;retrieve whatever information (in the form
   of an entity) is identified by the Request-URI&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  GET, when
   applied to a collection, may return the contents of an &quot;index.html&quot;
   resource, a human-readable view of the contents of the collection, or
   something else altogether.  Hence, it is possible that the result of
   a GET on a collection will bear no correlation to the membership of
   the collection.

   Similarly, since the definition of HEAD is a GET without a response
   message body, the semantics of HEAD are unmodified when applied to
   collection resources.</source>
          <target state="translated">GET的语义在应用于集合时不会更改，因为GET被定义为&amp;ldquo;检索Request-URI标识的任何信息（以实体的形式）&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]。当将GET应用于集合时，它可以返回&amp;ldquo; index.html&amp;rdquo;资源的内容，该集合的内容的人类可读视图或其他所有内容。因此，集合上GET的结果可能与集合的成员资格不相关。同样，由于HEAD的定义是没有响应消息主体的GET，因此将HEAD的语义应用于集合资源时不会被修改。</target>
        </trans-unit>
        <trans-unit id="00fa260f74b6e3042ef94427143bf9ccc1a0c47d" translate="yes" xml:space="preserve">
          <source>The server MUST generate an &lt;code&gt;Allow&lt;/code&gt; header field in a 405 response containing a list of the target resource's currently supported methods.</source>
          <target state="translated">服务器必须在405响应中生成 &lt;code&gt;Allow&lt;/code&gt; 标头字段，其中包含目标资源当前支持的方法的列表。</target>
        </trans-unit>
        <trans-unit id="0562c768d353635c49184c6fe08601647efdac48" translate="yes" xml:space="preserve">
          <source>The server also sends &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; with a value of &quot;&lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt;&quot;, confirming that these are permitted headers to be used with the actual request. Like &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; is a comma separated list of acceptable headers.</source>
          <target state="translated">服务器还发送值为&amp;ldquo; &lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt; &amp;rdquo;的 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ，确认这些是允许与实际请求一起使用的标头。像 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 一样， &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 是逗号分隔的可接受标题列表。</target>
        </trans-unit>
        <trans-unit id="583376e0dba516f5c2825a92214abd5ad5c19f01" translate="yes" xml:space="preserve">
          <source>The server answers with a code &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; with the header &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt;.</source>
          <target state="translated">服务器用标头 &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt; 的代码&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;回答：http://example.org/whaddup。</target>
        </trans-unit>
        <trans-unit id="51013a828db296ccfd288d288af04cf909401777" translate="yes" xml:space="preserve">
          <source>The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.</source>
          <target state="translated">服务器找不到请求的资源。在浏览器中,这意味着URL未被识别。在API中,这也意味着端点有效,但资源本身不存在。服务器也可能会发送这个响应而不是403,以向未经授权的客户端隐藏资源的存在。这个响应代码可能是最著名的一个,因为它在网络上经常出现。</target>
        </trans-unit>
        <trans-unit id="5c4ccfae2be68876da45c9c1dc793bd8e937dfdb" translate="yes" xml:space="preserve">
          <source>The server can not find the requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurrence on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79671e2c7c02bbc1b0253a58c7f5460d4f719ccf" translate="yes" xml:space="preserve">
          <source>The server can now redirect to a secure version of the site. A &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header can be used so that the site isn't served by caches to clients that don&amp;rsquo;t support the upgrade mechanism.</source>
          <target state="translated">服务器现在可以重定向到站点的安全版本。一个&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;头部可以用来让网站不会被缓存投放到不支持升级机制的客户。</target>
        </trans-unit>
        <trans-unit id="c5445db0622182456257f92e9ecf6bebf5eeb4a0" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource and if both values match (that is, the resource has not changed), the server send back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Not Modified&lt;/code&gt; status, without any body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="translated">服务器将客户端的 &lt;code&gt;ETag&lt;/code&gt; （通过 &lt;code&gt;If-None-Match&lt;/code&gt; 发送）与 &lt;code&gt;ETag&lt;/code&gt; 进行比较，以获取其当前资源版本，如果两个值都匹配（即资源未更改），则服务器会发送&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Not Modified&lt;/code&gt; 状态，没有任何主体，它告诉客户端响应的缓存版本仍然可以很好地使用（&lt;em&gt;新鲜&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="605fba61796e65ffe01c32b3fab960c6c121a075" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource, and if both values match (that is, the resource has not changed), the server sends back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; status, without a body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c7564335ef677861a44bea5af3ab893bbca1c3" translate="yes" xml:space="preserve">
          <source>The server could also consider other &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, such as &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">服务器还可以考虑其他&lt;a href=&quot;../content_negotiation&quot;&gt;内容协&lt;/a&gt;商标头，例如&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de85219a30abbe89bbf789c793cb5b7464c7af45" translate="yes" xml:space="preserve">
          <source>The server could not understand the request due to invalid syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96160ecd7ee13608af383e3bb73b0b35b5d6fb42" translate="yes" xml:space="preserve">
          <source>The server detected an infinite loop while processing the request.</source>
          <target state="translated">服务器在处理该请求时检测到一个无限循环。</target>
        </trans-unit>
        <trans-unit id="d4d0d326b4b9b27451ac87954663d1d88395013c" translate="yes" xml:space="preserve">
          <source>The server did not respond to the actual request (even if it responded to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;Preflight request&lt;/a&gt;). One scenario might be an HTTP service being developed that panicked without returning any data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedec016c5b57cc11eff3c532c6a93596d64f0f6" translate="yes" xml:space="preserve">
          <source>The server does not support the functionality required to fulfill the
   request. This is the appropriate response when the server does not
   recognize the request method and is not capable of supporting it for
   any resource.</source>
          <target state="translated">服务器不支持完成请求所需的功能。当服务器不识别请求方法,并且不能支持任何资源时,这是适当的响应。</target>
        </trans-unit>
        <trans-unit id="b05cf7bf3fff0832cc499297170da1dced108414" translate="yes" xml:space="preserve">
          <source>The server does not support, or refuses to support, the HTTP protocol
   version that was used in the request message. The server is
   indicating that it is unable or unwilling to complete the request
   using the same major version as the client, as described in &lt;a href=&quot;#section-3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;, other than with this error message. The response SHOULD contain
   an entity describing why that version is not supported and what other
   protocols are supported by that server.</source>
          <target state="translated">服务器不支持或拒绝支持请求消息中使用的HTTP协议版本。服务器会指示它无法或不愿意使用与客户端相同的主要版本（如&lt;a href=&quot;#section-3.1&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1 &lt;/a&gt;节中所述）来完成请求，但带有此错误消息除外。响应应该包含一个实体，描述为什么不支持该版本以及该服务器支持哪些其他协议。</target>
        </trans-unit>
        <trans-unit id="c06e31cc29dd99d9a9450fd0a50b146873ff8448" translate="yes" xml:space="preserve">
          <source>The server doesn't have total knowledge of the browser. Even with the Client Hints extension, it has not a complete knowledge of the capabilities of the browser. Unlike reactive content negotiation where the client makes the choice, the server choice is always somewhat arbitrary.</source>
          <target state="translated">服务器并不完全了解浏览器的情况。即使有客户端提示扩展,它对浏览器的功能也没有完全的了解。与反应式内容协商由客户端做出选择不同,服务器的选择总是有些随意性。</target>
        </trans-unit>
        <trans-unit id="59d4cf28c9831ade812e9ba3919040baedea9266" translate="yes" xml:space="preserve">
          <source>The server encountered an unexpected condition which prevented it
   from fulfilling the request.</source>
          <target state="translated">服务器遇到了意外情况,无法完成请求。</target>
        </trans-unit>
        <trans-unit id="10710baff0a022ad3a742df8fef3c65957eb66a8" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.</source>
          <target state="translated">服务器内部配置错误:所选择的变体资源本身被配置为参与透明内容协商,因此不是协商过程中的适当端点。</target>
        </trans-unit>
        <trans-unit id="706ed34301bbcc058a72a5142e2a23a25bb1303a" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: transparent content negotiation for the request results in a circular reference.</source>
          <target state="translated">服务器内部配置错误:请求的透明内容协商导致循环引用。</target>
        </trans-unit>
        <trans-unit id="d758b127d939bbbe9c83eda748c2d96b939c4dc5" translate="yes" xml:space="preserve">
          <source>The server has encountered a situation it doesn't know how to handle.</source>
          <target state="translated">服务器遇到了不知道如何处理的情况。</target>
        </trans-unit>
        <trans-unit id="5cf27f01c140eea8ea3c01504b142779b0027690" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a &lt;code&gt;GET&lt;/code&gt; request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30dd73b04a13c811e1dbf9b2319193169edb03c" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="translated">服务器已经完成了对资源的GET请求,响应是应用于当前实例的一个或多个实例操作结果的表示。</target>
        </trans-unit>
        <trans-unit id="e118a9d32f4f8ee5d1a291b20a7b4b379a234f47" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the partial GET request for the resource.
   The request MUST have included a Range header field (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;)
   indicating the desired range, and MAY have included an If-Range
   header field (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) to make the request conditional.

   The response MUST include the following header fields:

      - Either a Content-Range header field (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;) indicating
        the range included with this response, or a multipart/byteranges
        Content-Type including Content-Range fields for each part. If a
        Content-Length header field is present in the response, its
        value MUST match the actual number of OCTETs transmitted in the
        message-body.

      - Date

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request 

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the 206 response is the result of an If-Range request that used a
   strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), the response SHOULD NOT
   include other entity-headers. If the response is the result of an
   If-Range request that used a weak validator, the response MUST NOT
   include other entity-headers; this prevents inconsistencies between
   cached entity-bodies and updated headers. Otherwise, the response
   MUST include all of the entity-headers that would have been returned
   with a 200 (OK) response to the same request.

   A cache MUST NOT combine a 206 response with other previously cached
   content if the ETag or Last-Modified headers do not match exactly,
   see 13.5.4.

   A cache that does not support the Range and Content-Range headers
   MUST NOT cache 206 (Partial) responses.</source>
          <target state="translated">服务器已完成对资源的部分GET请求。该请求必须包含指示所需范围的Range标头字段（&lt;a href=&quot;#section-14.35&quot;&gt;第14.35节&lt;/a&gt;），并且可能包含If-Range标头字段（&lt;a href=&quot;#section-14.27&quot;&gt;第14.27节&lt;/a&gt;）以使请求成为条件请求。响应必须包含以下标头字段：-一个Content-Range标头字段（&lt;a href=&quot;#section-14.16&quot;&gt;第14.16节）&lt;/a&gt;）表示此响应所包含的范围，或者是一个多部分/字节范围的Content-Type，其中包括每个部分的Content-Range字段。如果响应中存在Content-Length头字段，则其值必须与消息正文中发送的OCTET的实际数量匹配。 -日期-ETag和/或Content-Location（如果标头是在对同一请求的200响应中发送的）-Expires，Cache-Control和/或Vary（如果字段值可能与任何发送的字段值不同）相同变体的先前响应如果206响应是使用强缓存验证器的If-Range请求的结果（请参见&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3节）&lt;/a&gt;），则响应不应包含其他实体标题。如果该响应是使用弱验证器的If-Range请求的结果，则该响应务必不包括其他实体标头；这可以防止缓存的实体与更新的标头之间的不一致。否则，响应必须包括所有对同一请求返回200（确定）响应的实体头。如果ETag或Last-Modified头不完全匹配，则缓存不得将206响应与其他先前缓存的内容组合在一起，请参见13.5.4。不支持Range和Content-Range头的缓存必须不缓存206（部分）响应。</target>
        </trans-unit>
        <trans-unit id="9154c7f74bf47c2abcfe8e8637f31d473b4ccf8a" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request and the user agent SHOULD reset
   the document view which caused the request to be sent. This response
   is primarily intended to allow input for actions to take place via
   user input, followed by a clearing of the form in which the input is
   given so that the user can easily initiate another input action. The
   response MUST NOT include an entity.</source>
          <target state="translated">服务器已经满足了请求,用户代理应该重新设置导致请求发送的文档视图。这个响应主要是为了允许通过用户输入来进行操作,然后清除输入的表单,以便用户可以轻松地发起另一个输入操作。响应必须不包括实体。</target>
        </trans-unit>
        <trans-unit id="0ee5c3ee094642bb5d46e9cb3d051a90abd31149" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request but does not need to return an
   entity-body, and might want to return updated metainformation. The
   response MAY include new or updated metainformation in the form of
   entity-headers, which if present SHOULD be associated with the
   requested variant.

   If the client is a user agent, it SHOULD NOT change its document view
   from that which caused the request to be sent. This response is
   primarily intended to allow input for actions to take place without
   causing a change to the user agent's active document view, although
   any new or updated metainformation SHOULD be applied to the document
   currently in the user agent's active view.

   The 204 response MUST NOT include a message-body, and thus is always
   terminated by the first empty line after the header fields.</source>
          <target state="translated">服务器已经满足了请求,但不需要返回实体主体,可能希望返回更新的元信息。响应可能包括以实体头形式出现的新的或更新的元信息,如果存在的话,这些元信息应该与请求的变体相关联。如果客户机是用户代理,它不应该改变导致发送请求的文档视图。这个响应主要是为了允许输入动作,而不引起用户代理的活动文档视图的改变,尽管任何新的或更新的元信息都应该应用到当前用户代理活动视图中的文档。204响应必须不包括消息体,因此总是以头字段后的第一行空结束。</target>
        </trans-unit>
        <trans-unit id="8c2ef715f1697c767e016f66e48a9c5ad3088fc4" translate="yes" xml:space="preserve">
          <source>The server has not found anything matching the Request-URI. No
   indication is given of whether the condition is temporary or
   permanent. The 410 (Gone) status code SHOULD be used if the server
   knows, through some internally configurable mechanism, that an old
   resource is permanently unavailable and has no forwarding address.
   This status code is commonly used when the server does not wish to
   reveal exactly why the request has been refused, or when no other
   response is applicable.</source>
          <target state="translated">服务器没有找到任何与Request-URI匹配的内容。没有说明这种情况是暂时的还是永久的。如果服务器通过一些内部可配置的机制知道一个旧的资源是永久不可用的,并且没有转发地址,那么应该使用410(Gone)状态码。这种状态码通常用于服务器不希望确切地揭示请求被拒绝的原因,或者没有其他适用的响应时。</target>
        </trans-unit>
        <trans-unit id="1d3eb58f597e0c6c5fa76c0069741d7639896309" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d2c9e44a151f75cad87b75d25351ab5902d469" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">服务器在此响应中包括一个&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;响应标头，以指示它切换到的协议。&lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;协议升级机制&lt;/a&gt;一文中详细描述了该过程。</target>
        </trans-unit>
        <trans-unit id="be80728dab68882cff956fbc4def7165d17d07e6" translate="yes" xml:space="preserve">
          <source>The server is currently unable to handle the request due to a
   temporary overloading or maintenance of the server. The implication
   is that this is a temporary condition which will be alleviated after
   some delay. If known, the length of the delay MAY be indicated in a
   Retry-After header. If no Retry-After is given, the client SHOULD
   handle the response as it would for a 500 response.

      Note: The existence of the 503 status code does not imply that a
      server must use it when becoming overloaded. Some servers may wish
      to simply refuse the connection.</source>
          <target state="translated">由于服务器暂时超载或维护,服务器目前无法处理该请求。这意味着这是一种暂时性的状况,将在一定的延迟后得到缓解。如果知道,延迟的长度可以在Retry-After头中表示。如果没有Retry-After,客户端应该像处理500响应那样处理响应。注意:503状态码的存在并不意味着服务器必须在超载时使用它。有些服务器可能希望直接拒绝连接。</target>
        </trans-unit>
        <trans-unit id="baf2d9062e2499753136835fe0c821934d565f38" translate="yes" xml:space="preserve">
          <source>The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the &lt;code&gt;Retry-After:&lt;/code&gt; HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.</source>
          <target state="translated">服务器尚未准备好处理请求。常见原因是服务器因维护而停机或过载。请注意，与此响应一起，应发送一个说明问题的用户友好页面。此响应应用于临时条件，并且 &lt;code&gt;Retry-After:&lt;/code&gt; HTTP标头应尽可能包含恢复服务之前的估计时间。网站管理员还必须注意与该响应一起发送的与缓存相关的标头，因为通常不应缓存这些临时条件响应。</target>
        </trans-unit>
        <trans-unit id="30401629d5451d683706de07ce99fc1a19648e2c" translate="yes" xml:space="preserve">
          <source>The server is overloaded and cannot afford the computational overhead induced by the compression requirement. Typically, Microsoft recommends not to compress if a server uses more than 80% of its computational power.</source>
          <target state="translated">服务器负荷过重,无法承受压缩要求带来的计算开销。通常情况下,如果服务器使用的计算能力超过80%,微软建议不要进行压缩。</target>
        </trans-unit>
        <trans-unit id="91058d54183ce48b758a3923ca1dd0add318d618" translate="yes" xml:space="preserve">
          <source>The server is refusing to process a request because the request
   entity is larger than the server is willing or able to process. The
   server MAY close the connection to prevent the client from continuing
   the request.

   If the condition is temporary, the server SHOULD include a Retry-
   After header field to indicate that it is temporary and after what
   time the client MAY try again.</source>
          <target state="translated">服务器拒绝处理请求,因为请求实体大于服务器愿意或能够处理的范围。服务器可以关闭连接以防止客户端继续请求。如果这种情况是暂时的,服务器应该包含一个Retry-After头,以表明这是暂时的,在什么时间之后客户端可以再试。</target>
        </trans-unit>
        <trans-unit id="555c0a61bfb0c95cce342015880bc471fe52028d" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the Request-URI
   is longer than the server is willing to interpret. This rare
   condition is only likely to occur when a client has improperly
   converted a POST request to a GET request with long query
   information, when the client has descended into a URI &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself), or when the server is under attack by a client attempting to
   exploit security holes present in some servers using fixed-length
   buffers for reading or manipulating the Request-URI.</source>
          <target state="translated">服务器拒绝服务该请求,因为Request-URI比服务器愿意解释的长。这种罕见的情况只有在以下情况下才有可能发生:客户端将POST请求不适当地转换为带有长查询信息的GET请求,客户端陷入URI重定向的 &quot;黑洞&quot;(例如,重定向的URI前缀指向自身的后缀),或者服务器受到客户端的攻击,客户端试图利用某些服务器中存在的安全漏洞,使用固定长度的缓冲区来读取或操作Request-URI。</target>
        </trans-unit>
        <trans-unit id="b7583fbc3987a772449c07846db7b69d3aab25c3" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the entity of
   the request is in a format not supported by the requested resource
   for the requested method.</source>
          <target state="translated">服务器拒绝为请求提供服务,因为请求的实体的格式不为请求方法的资源所支持。</target>
        </trans-unit>
        <trans-unit id="9e40f61b278945136b6bf8c69ccb6441c6101dc0" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">由于请求头字段过大,服务器不愿意处理该请求。减少请求头字段的大小后,可以重新提交请求。</target>
        </trans-unit>
        <trans-unit id="2cabf4085dccd9d1a0d60a5bef8f53aaaa7eb900" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b402009d984cfa7b4aa7445fadf6432930d62bf" translate="yes" xml:space="preserve">
          <source>The server may either refuse the upgrade &amp;mdash; in this case it merely ignores the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header and sends back a regular response (&lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; if it can serve the requested resource, a &lt;code&gt;30x&lt;/code&gt; status code if it wants to perform a redirect, a &lt;code&gt;40x&lt;/code&gt; or &lt;code&gt;50x&lt;/code&gt; one if it can't serve the requested resource) &amp;mdash; or accept the upgrade. In this case, it sends back a &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; with an Upgrade header that specifies the protocol chosen.</source>
          <target state="translated">服务器可以拒绝升级-在这种情况下，它仅忽略 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 标头并发送回常规响应（如果可以为请求的资源提供服务，则返回 &lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; 如果要执行重定向，则返回 &lt;code&gt;30x&lt;/code&gt; 状态代码，一个 &lt;code&gt;40x&lt;/code&gt; 或 &lt;code&gt;50x&lt;/code&gt; 的，如果它不能提供所请求的资源） -或接受升级。在这种情况下，它将发回带有指定指定协议的升级头的 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eb9ea8eac80a46172e3c3d063d37cbb8a09735e" translate="yes" xml:space="preserve">
          <source>The server may specify &quot;*&quot; as a wildcard, thereby allowing any origin to see timing resources.</source>
          <target state="translated">服务器可以指定 &quot;*&quot;作为通配符,从而允许任何原点看到定时资源。</target>
        </trans-unit>
        <trans-unit id="767e4fc07c131eef7a83181be5734574f3f01fab" translate="yes" xml:space="preserve">
          <source>The server now can respond if it will accept a request under these circumstances. In this example, the server response says that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0103c094e5add7857b8d5242900bc764e81c4d56" translate="yes" xml:space="preserve">
          <source>The server now checks the request headers and may respond with a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) response to instruct the client to go ahead and send the message body, or it will send a &lt;a href=&quot;../status/417&quot;&gt;&lt;code&gt;417&lt;/code&gt;&lt;/a&gt; (Expectation Failed) status if any of the expectations cannot be met.</source>
          <target state="translated">服务器现在检查请求标头，并可能以&lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt;（继续）响应进行响应以指示客户端继续发送消息正文，或者如果无法满足任何期望，则服务器将发送&lt;a href=&quot;../status/417&quot;&gt; &lt;code&gt;417&lt;/code&gt; &lt;/a&gt;（预期失败）状态。</target>
        </trans-unit>
        <trans-unit id="e1283857d0934fd62a1b18ee296b4ffd28fea393" translate="yes" xml:space="preserve">
          <source>The server only permits access to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="translated">服务器只允许通过单一来源onlinebanking.jumbobank.com访问专门通过HTTPS加载的文件。</target>
        </trans-unit>
        <trans-unit id="26883acb60acb54540a0e576eaa8444f3824e5cd" translate="yes" xml:space="preserve">
          <source>The server permits access only to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c7fec239224320ece1ddcef09fb8d8afe6a922" translate="yes" xml:space="preserve">
          <source>The server processes the request, sending back its answer, providing a status code and appropriate data.</source>
          <target state="translated">服务器对请求进行处理,发回答复,并提供状态码和相应的数据。</target>
        </trans-unit>
        <trans-unit id="4a76d046fb30a4094df60f730aa186a8214f36f9" translate="yes" xml:space="preserve">
          <source>The server refuses the attempt to brew coffee with a teapot.</source>
          <target state="translated">服务员拒绝了用茶壶冲泡咖啡的尝试。</target>
        </trans-unit>
        <trans-unit id="0521746f768ead6cf341a3de72d80f86946a50aa" translate="yes" xml:space="preserve">
          <source>The server refuses to accept the request without a defined Content-
   Length. The client MAY repeat the request if it adds a valid
   Content-Length header field containing the length of the message-body
   in the request message.</source>
          <target state="translated">服务器拒绝接受没有定义Content-Length的请求。客户端可以重复请求,如果它在请求消息中添加一个有效的Content-Length头字段,其中包含消息体的长度。</target>
        </trans-unit>
        <trans-unit id="098d1595780b213e964cc55bccf5bbf26c81cacc" translate="yes" xml:space="preserve">
          <source>The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header in a 426 response to indicate the required protocol(s).</source>
          <target state="translated">服务器拒绝使用当前协议执行请求，但是在客户端升级到其他协议后，服务器可能愿意这样做。服务器在426响应中发送一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头，以指示所需的协议。</target>
        </trans-unit>
        <trans-unit id="82c879297c83c6c0c7f5e4355a3573667d1d3938" translate="yes" xml:space="preserve">
          <source>The server responds to a client with a &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt; (Unauthorized) response status and provides information on how to authorize with a &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; response header containing at least one challenge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96c620c10c72c2facba569247c0abd76880b504" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and says that &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, and &lt;code&gt;OPTIONS&lt;/code&gt; are viable methods to query the resource in question. This header is similar to the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of CORS.</source>
          <target state="translated">服务器以&lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 进行&lt;/a&gt;响应，并说 &lt;code&gt;POST&lt;/code&gt; ， &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;OPTIONS&lt;/code&gt; 是查询相关资源的可行方法。此标头类似于&amp;ldquo; &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;响应&amp;rdquo;标头，但严格在CORS的上下文中使用。</target>
        </trans-unit>
        <trans-unit id="0adba182e0838c8ba807f3caebecfe1ff5519a80" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; and says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question. Note that this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control.</source>
          <target state="translated">服务器以 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 响应，并说 &lt;code&gt;POST&lt;/code&gt; 和 &lt;code&gt;GET&lt;/code&gt; 是查询有问题资源的可行方法。请注意，此标头类似于&amp;ldquo; &lt;a href=&quot;headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;响应&amp;rdquo;标头，但严格在访问控制的上下文中使用。</target>
        </trans-unit>
        <trans-unit id="50340f4cfb4f858ac4e526eb22f4eb0cf5120e8d" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Origin: http://foo.example&lt;/code&gt;, restricting access to just the requesting origin domain. It also responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, which says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question (this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7efc45419f666af1044e66769f805e285297d7" translate="yes" xml:space="preserve">
          <source>The server responds with the scheme used, indicated by the &lt;code&gt;Content-Encoding&lt;/code&gt; response header.</source>
          <target state="translated">服务器以使用的方案进行响应，该方案由 &lt;code&gt;Content-Encoding&lt;/code&gt; 响应标头指示。</target>
        </trans-unit>
        <trans-unit id="adb6ebfb2d7ba636e549327e9964bd8e4a9aa87e" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status and a &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; header, indicating that a multipart byterange follows. Each part contains its own &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Content-Range&lt;/code&gt; fields and the required boundary parameter specifies the boundary string used to separate each body-part.</source>
          <target state="translated">服务器以&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 状态和&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 进行&lt;/a&gt;响应 &lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; 标头，指示遵循多部分字节范围。每个零件都包含自己的 &lt;code&gt;Content-Type&lt;/code&gt; 和 &lt;code&gt;Content-Range&lt;/code&gt; 字段，并且所需的border参数指定用于分隔每个主体零件的边界字符串。</target>
        </trans-unit>
        <trans-unit id="d9701baf78124c3a98a96cf4e906d3722ade4288" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status:</source>
          <target state="translated">服务器以&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 状态响应：</target>
        </trans-unit>
        <trans-unit id="60a245e6b24fad30a550d86662bff1af7454a2ee" translate="yes" xml:space="preserve">
          <source>The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with this response to indicate the required protocol(s).</source>
          <target state="translated">服务器发送带有此响应的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头，以指示所需的协议。</target>
        </trans-unit>
        <trans-unit id="9542fcfca4223129b519747385fa48be52ecf048" translate="yes" xml:space="preserve">
          <source>The server sends this response to direct the client to get the requested resource at another URI with same method that was used in the prior request. This has the same semantics as the &lt;code&gt;302 Found&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">服务器发送此响应，以指示客户端使用先前请求中使用的相同方法在另一个URI中获取请求的资源。这具有相同的语义 &lt;code&gt;302 Found&lt;/code&gt; HTTP响应代码，不同之处在于用户代理&lt;em&gt;必须不&lt;/em&gt;改变使用的HTTP方法：如果 &lt;code&gt;POST&lt;/code&gt; 是在第一请求中所使用的， &lt;code&gt;POST&lt;/code&gt; 必须在第二请求被使用。</target>
        </trans-unit>
        <trans-unit id="5c7306d33878ab5bc99fecabc06252df15d1029f" translate="yes" xml:space="preserve">
          <source>The server sent this response to direct the client to get the requested resource at another URI with a GET request.</source>
          <target state="translated">服务器发送这个响应,是为了引导客户端通过GET请求在另一个URI上获取所请求的资源。</target>
        </trans-unit>
        <trans-unit id="848c3b9ad4be0c1360d99c2d9af3ef34c33fe75c" translate="yes" xml:space="preserve">
          <source>The server takes the value of the Sec-WebSocket-Key sent in the handshake request, appends &lt;code&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&lt;/code&gt;, takes SHA-1 of the new value, and is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf25e98d428f5cff29ccef9eba702a25e100fa8" translate="yes" xml:space="preserve">
          <source>The server understands and is willing to comply with the client's
   request, via the Upgrade message header field (&lt;a href=&quot;#section-14.42&quot;&gt;section 14.42&lt;/a&gt;), for a
   change in the application protocol being used on this connection. The
   server will switch protocols to those defined by the response's
   Upgrade header field immediately after the empty line which
   terminates the 101 response.

   The protocol SHOULD be switched only when it is advantageous to do
   so. For example, switching to a newer version of HTTP is advantageous
   over older versions, and switching to a real-time, synchronous
   protocol might be advantageous when delivering resources that use
   such features.</source>
          <target state="translated">服务器理解并愿意通过&amp;ldquo;升级消息头&amp;rdquo;字段（&lt;a href=&quot;#section-14.42&quot;&gt;第14.42节&lt;/a&gt;）来满足客户端对在此连接上使用的应用协议进行更改的请求。服务器将在终止101响应的空行之后立即将协议切换到由响应的Upgrade标头字段定义的协议。仅在有利时才应切换协议。例如，切换到新版本的HTTP优于旧版本，并且在传递使用此类功能的资源时，切换到实时同步协议可能是有利的。</target>
        </trans-unit>
        <trans-unit id="1d1ec0c651dbab18735a86dfc8ae8c14372b5e8a" translate="yes" xml:space="preserve">
          <source>The server understood the request, but is refusing to fulfill it.
   Authorization will not help and the request SHOULD NOT be repeated.
   If the request method was not HEAD and the server wishes to make
   public why the request has not been fulfilled, it SHOULD describe the
   reason for the refusal in the entity.  If the server does not wish to
   make this information available to the client, the status code 404
   (Not Found) can be used instead.</source>
          <target state="translated">服务器理解了该请求,但拒绝执行该请求。授权无济于事,请求不应该被重复。如果请求方法不是HEAD,并且服务器希望公开请求未被满足的原因,它应该在实体中描述拒绝的原因。如果服务器不希望向客户端公开这些信息,可以使用状态码404(Not Found)代替。</target>
        </trans-unit>
        <trans-unit id="2bccd21746e24e17c4d6598c2feaeef9e50bab37" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;a href=&quot;headers/sec-websocket-accept&quot;&gt;&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;&lt;/a&gt; header will have a value computed based upon the specified &lt;code&gt;&lt;var&gt;key&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94809fc6f53d174f5374acd4dfb1f7acb678c149" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; header will have a value computed based upon the specified &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">服务器响应的 &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; 标头将具有基于指定 &lt;code&gt;key&lt;/code&gt; 计算的值。</target>
        </trans-unit>
        <trans-unit id="f3ef1a39a25ddc08d8e0d5a5bb5464d92b09bc2a" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, did not receive a
   timely response from the upstream server specified by the URI (e.g.
   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed
   to access in attempting to complete the request.

      Note: Note to implementors: some deployed proxies are known to
      return 400 or 500 when DNS lookups time out.</source>
          <target state="translated">服务器在充当网关或代理时,在试图完成请求时没有收到URI指定的上游服务器(如HTTP、FTP、LDAP)或其他一些需要访问的辅助服务器(如DNS)的及时响应。注:实施者注意:已知一些部署的代理服务器在DNS查找超时时返回400或500。</target>
        </trans-unit>
        <trans-unit id="46e47cc0b16529d905f0b1b3af210872557d572b" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, received an invalid
   response from the upstream server it accessed in attempting to
   fulfill the request.</source>
          <target state="translated">服务器在充当网关或代理时,在试图完成请求时收到了来自其访问的上游服务器的无效响应。</target>
        </trans-unit>
        <trans-unit id="cad9f838a72a1881211f8a63fadbd9aa2da06441" translate="yes" xml:space="preserve">
          <source>The set of common methods for HTTP/1.1 is defined below. Although
   this set can be expanded, additional methods cannot be assumed to
   share the same semantics for separately extended clients and servers.

   The Host request-header field (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) MUST accompany all
   HTTP/1.1 requests.</source>
          <target state="translated">HTTP / 1.1的一组常用方法在下面定义。尽管可以扩展此集合，但是不能假定其他方法可以为单独扩展的客户端和服务器共享相同的语义。主机请求标头字段（&lt;a href=&quot;#section-14.23&quot;&gt;第14.23节&lt;/a&gt;）务必伴随所有HTTP / 1.1请求。</target>
        </trans-unit>
        <trans-unit id="3aa1224052f644e6f5d9789fe1626a5e5119f08c" translate="yes" xml:space="preserve">
          <source>The simplest MIME type consists of a &lt;var&gt;type&lt;/var&gt; and a &lt;var&gt;subtype&lt;/var&gt;; these are each strings which, when concatenated with a slash (&lt;code&gt;/&lt;/code&gt;) between them, comprise a MIME type. No whitespace is allowed in a MIME type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fc403f1552de7486f1009e75d3e485460c6c32" translate="yes" xml:space="preserve">
          <source>The site returns a generic success message confirming the post was published. The server specifies &lt;em&gt;where&lt;/em&gt; the new post is with &lt;code&gt;Content-Location&lt;/code&gt;:</source>
          <target state="translated">该网站返回一条通用成功消息，确认该帖子已发布。服务器指定&lt;em&gt;其中&lt;/em&gt;的新职位是 &lt;code&gt;Content-Location&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d9ec569438b6e170956f6c9751913bd129236874" translate="yes" xml:space="preserve">
          <source>The size of the resource, in decimal number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb8b58154cc46b27e579e11d1cdd3ea67056760" translate="yes" xml:space="preserve">
          <source>The special value ''clear&quot; indicates that the origin requests all alternatives for that origin to be invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40812bee8a9705438af783eaa9ebe956256664d2" translate="yes" xml:space="preserve">
          <source>The special value of '&lt;code&gt;*&lt;/code&gt;' means that the server-driven content negotiation also uses information not conveyed in a header to choose the appropriate content.</source>
          <target state="translated">特殊值' &lt;code&gt;*&lt;/code&gt; '表示服务器驱动的内容协商还使用标头中未传达的信息来选择适当的内容。</target>
        </trans-unit>
        <trans-unit id="8f79a17c3099080cc2dd18760e1e6dd5db53ca77" translate="yes" xml:space="preserve">
          <source>The specification advices that names and descriptions should be kept as short as possible (use abbreviations and omit optional values where possible) to minimize the HTTP overhead.</source>
          <target state="translated">该规范建议,名称和描述应尽量简短(尽可能使用缩写和省略可选值),以减少HTTP开销。</target>
        </trans-unit>
        <trans-unit id="6830140aefcebc442d186cdf8f55cdcc404c9a85" translate="yes" xml:space="preserve">
          <source>The specification has been substantially rewritten for clarity.

   The conditions under which an authenticated response can be cached
   have been clarified.  (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   New status codes can now define that caches are allowed to use
   heuristic freshness with them.  Caches are now allowed to calculate
   heuristic freshness for URIs with query components.  (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The algorithm for calculating age is now less conservative.  Caches
   are now required to handle dates with time zones as if they're
   invalid, because it's not possible to accurately guess.
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;)

   The Content-Location response header field is no longer used to
   determine the appropriate response to use when validating.
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)

   The algorithm for selecting a cached negotiated response to use has
   been clarified in several ways.  In particular, it now explicitly
   allows header-specific canonicalization when processing selecting
   header fields.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   Requirements regarding denial-of-service attack avoidance when
   performing invalidation have been clarified.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache invalidation only occurs when a successful response is
   received.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache directives are explicitly defined to be case-insensitive.
   Handling of multiple instances of cache directives when only one is
   expected is now defined.  (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;)

   The &quot;no-store&quot; request directive doesn't apply to responses; i.e., a
   cache can satisfy a request with no-store on it and does not
   invalidate it.  (&lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;)

   The qualified forms of the private and no-cache cache directives are
   noted to not be widely implemented; for example, &quot;private=foo&quot; is
   interpreted by many caches as simply &quot;private&quot;.  Additionally, the
   meaning of the qualified form of no-cache has been clarified.
   (&lt;a href=&quot;#section-5.2.2&quot;&gt;Section 5.2.2&lt;/a&gt;)

   The &quot;no-cache&quot; response directive's meaning has been clarified.
   (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;) 

   The one-year limit on Expires header field values has been removed;
   instead, the reasoning for using a sensible value is given.
   (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The Pragma header field is now only defined for backwards
   compatibility; future pragmas are deprecated.  (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;)

   Some requirements regarding production and processing of the Warning
   header fields have been relaxed, as it is not widely implemented.
   Furthermore, the Warning header field no longer uses &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   encoding, nor does it allow multiple languages, as these aspects were
   not implemented.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   This specification introduces the Cache Directive and Warn Code
   Registries, and defines considerations for new cache directives.
   (&lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt; and &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;)</source>
          <target state="translated">为了清楚起见，已经对该规范进行了实质性的重写。已经阐明了可以缓存经过身份验证的响应的条件。 （&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;）现在，新的状态代码可以定义允许缓存对其使用启发式新鲜度。现在允许缓存为具有查询组件的URI计算启发式新鲜度。 （&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;）现在，用于计算年龄的算法不再那么保守。现在，高速缓存需要处理带有时区的日期，就好像它们是无效的一样，因为不可能准确猜测。 （&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt;）Content-Location响应标头字段不再用于确定验证时要使用的适当响应。 （&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）以多种方式阐明了选择缓存的协商使用响应的算法。特别是，它现在在处理选择标题字段时显式地允许特定于标题的规范化。 （&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;）阐明了执行无效时避免拒绝服务攻击的要求。 （&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）仅当收到成功的响应时才会发生缓存无效。 （&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）缓存指令被明确定义为不区分大小写。现在定义仅需要一个时就处理高速缓存指令的多个实例。 （&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;）&amp;ldquo; no-store&amp;rdquo;请求指令不适用于响应；即，高速缓存可以满足其上没有存储的请求，并且不会使请求无效。 （&lt;a href=&quot;#section-5.2.1.5&quot;&gt;第5.2.1.5节&lt;/a&gt;）注意，私有和无缓存缓存指令的限定形式并未得到广泛实施；例如，许多缓存将&amp;ldquo; private = foo&amp;rdquo;解释为简单的&amp;ldquo; private&amp;rdquo;。此外，已经阐明了无缓存的合格形式的含义。 （&lt;a href=&quot;#section-5.2.2&quot;&gt;第5.2.2节&lt;/a&gt;）&amp;ldquo; no-cache&amp;rdquo;响应指令的含义已经阐明。 （&lt;a href=&quot;#section-5.2.2.2&quot;&gt;第5.2.2.2节&lt;/a&gt;）已删除了Expires标头字段值的一年限制；而是给出了使用合理值的理由。 （&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）现在仅为了向后兼容而定义了Pragma标头字段；不建议使用将来的实用程序。 （&lt;a href=&quot;#section-5.4&quot;&gt;第5.4节&lt;/a&gt;）关于警告标头字段的生产和处理的一些要求已经放宽，因为它没有得到广泛实施。此外，警告标头字段不再使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; 编码，也不允许多种语言，因为未实现这些方面。 （&lt;a href=&quot;#section-5.5&quot;&gt;第5.5节&lt;/a&gt;）本规范介绍了缓存指令和警告代码注册表，并定义了有关新缓存指令的注意事项。 （&lt;a href=&quot;#section-7.1&quot;&gt;第7.1 &lt;/a&gt;&lt;a href=&quot;#section-7.2&quot;&gt;节&lt;/a&gt;和第7.2节）</target>
        </trans-unit>
        <trans-unit id="69f7236ac3c099aef6887071703596241bc5ffd5" translate="yes" xml:space="preserve">
          <source>The specified HTTPS proxy should be used</source>
          <target state="translated">应该使用指定的HTTPS代理</target>
        </trans-unit>
        <trans-unit id="53a5be96dd5bb71c6d16a8d35e8c39cbe4374a0d" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server (with the specified SOCK version) should be used</source>
          <target state="translated">应使用指定的SOCKS服务器(具有指定的SOCK版本)。</target>
        </trans-unit>
        <trans-unit id="303a58e78e8f8eb268fe6f62c8b7f193b6bc1142" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server should be used</source>
          <target state="translated">应该使用指定的SOCKS服务器</target>
        </trans-unit>
        <trans-unit id="68cc27ab7cd860287da7fdc9be46fedaaa277c72" translate="yes" xml:space="preserve">
          <source>The specified proxy should be used</source>
          <target state="translated">应使用指定的代理。</target>
        </trans-unit>
        <trans-unit id="6b8ade5bf013491609fa2a91c4e3f35610d584fc" translate="yes" xml:space="preserve">
          <source>The standardized header:</source>
          <target state="translated">标准化的标题。</target>
        </trans-unit>
        <trans-unit id="f7bf0204749a2c35928a6f9840f70eb32df13567" translate="yes" xml:space="preserve">
          <source>The start line of an HTTP response, called the &lt;em&gt;status line&lt;/em&gt;, contains the following information:</source>
          <target state="translated">HTTP响应的起始行（称为&lt;em&gt;状态行&lt;/em&gt;）包含以下信息：</target>
        </trans-unit>
        <trans-unit id="f31c6de41f53a39d348494f7a67a1dcc8252643d" translate="yes" xml:space="preserve">
          <source>The start-line and HTTP headers of the HTTP message are collectively known as the &lt;em&gt;head&lt;/em&gt; of the requests, whereas its payload is known as the &lt;em&gt;body&lt;/em&gt;.</source>
          <target state="translated">HTTP消息的起始行和HTTP标头统称为请求的&lt;em&gt;头&lt;/em&gt;，而其有效载荷称为&lt;em&gt;body&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f72d9e6a8a95e3d9c5ddb845c0490a8f4e705e6" translate="yes" xml:space="preserve">
          <source>The status code registry has been updated with the registrations
   below: 

   +-------+-------------------------------+----------------+
   | Value | Description                   | Reference      |
   +-------+-------------------------------+----------------+
   | 100   | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;  |
   | 101   | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;  |
   | 200   | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;  |
   | 201   | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;  |
   | 202   | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;  |
   | 203   | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;  |
   | 204   | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;  |
   | 205   | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;  |
   | 300   | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;  |
   | 301   | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;  |
   | 302   | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;  |
   | 303   | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;  |
   | 305   | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;  |
   | 306   | (Unused)                      | &lt;a href=&quot;#section-6.4.6&quot;&gt;Section 6.4.6&lt;/a&gt;  |
   | 307   | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;  |
   | 400   | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;  |
   | 402   | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;  |
   | 403   | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;  |
   | 404   | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;  |
   | 405   | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;  |
   | 406   | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;  |
   | 408   | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;  |
   | 409   | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;  |
   | 410   | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;  |
   | 411   | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt; |
   | 413   | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt; |
   | 414   | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt; |
   | 415   | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt; |
   | 417   | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt; |
   | 426   | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt; |
   | 500   | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;  |
   | 501   | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;  |
   | 502   | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;  |
   | 503   | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;  |
   | 504   | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;  |
   | 505   | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;  |
   +-------+-------------------------------+----------------+</source>
          <target state="translated">状态代码注册表已使用以下注册进行了更新：+ ------- + ----------------------------- -+ ---------------- + |价值|描述参考| + ------- + ------------------------------- + --------- ------- + | 100 |继续| &lt;a href=&quot;#section-6.2.1&quot;&gt;第6.2.1节&lt;/a&gt; | | 101 |交换协议| &lt;a href=&quot;#section-6.2.2&quot;&gt;第6.2.2节&lt;/a&gt; | | 200 |好的&lt;a href=&quot;#section-6.3.1&quot;&gt;第6.3.1节&lt;/a&gt; | | 201 |已创建| &lt;a href=&quot;#section-6.3.2&quot;&gt;第6.3.2节&lt;/a&gt; | | 202 |接受| &lt;a href=&quot;#section-6.3.3&quot;&gt;第6.3.3节&lt;/a&gt; | | 203 |非权威信息| &lt;a href=&quot;#section-6.3.4&quot;&gt;第6.3.4节&lt;/a&gt; | | 204 |没有内容|&lt;a href=&quot;#section-6.3.5&quot;&gt;第6.3.5节&lt;/a&gt; | | 205 |重置内容| &lt;a href=&quot;#section-6.3.6&quot;&gt;第6.3.6节&lt;/a&gt; | | 300 |多种选择| &lt;a href=&quot;#section-6.4.1&quot;&gt;第6.4.1节&lt;/a&gt; | | 301 |永久移动| &lt;a href=&quot;#section-6.4.2&quot;&gt;第6.4.2节&lt;/a&gt; | | 302 |找到| &lt;a href=&quot;#section-6.4.3&quot;&gt;第6.4.3节&lt;/a&gt; | | 303 |查看其他| &lt;a href=&quot;#section-6.4.4&quot;&gt;第6.4.4节&lt;/a&gt; | | 305 |使用代理| &lt;a href=&quot;#section-6.4.5&quot;&gt;第6.4.5节&lt;/a&gt; | | 306 | （未使用）| &lt;a href=&quot;#section-6.4.6&quot;&gt;第6.4.6节&lt;/a&gt; | | 307 |临时重定向| &lt;a href=&quot;#section-6.4.7&quot;&gt;第6.4.7节&lt;/a&gt; | | 400 |错误的请求| &lt;a href=&quot;#section-6.5.1&quot;&gt;第6.5.1节&lt;/a&gt; | | 402 |需要付款| &lt;a href=&quot;#section-6.5.2&quot;&gt;第6.5.2节&lt;/a&gt; | | 403 |禁止&lt;a href=&quot;#section-6.5.3&quot;&gt;第6.5.3节&lt;/a&gt; | | 404 |找不到&lt;a href=&quot;#section-6.5.4&quot;&gt;第6.5.4节&lt;/a&gt; | | 405 |不允许的方法&lt;a href=&quot;#section-6.5.5&quot;&gt;第6.5.5节&lt;/a&gt; | | 406 |不可接受| &lt;a href=&quot;#section-6.5.6&quot;&gt;第6.5.6节&lt;/a&gt; | | 408 |请求超时| &lt;a href=&quot;#section-6.5.7&quot;&gt;第6.5.7节&lt;/a&gt; | | 409 |冲突| &lt;a href=&quot;#section-6.5.8&quot;&gt;第6.5.8节&lt;/a&gt; | | 410 |去了| &lt;a href=&quot;#section-6.5.9&quot;&gt;第6.5.9节&lt;/a&gt; | | 411 |所需长度| &lt;a href=&quot;#section-6.5.10&quot;&gt;第6.5.10节&lt;/a&gt; | | 413 |有效载荷过大|&lt;a href=&quot;#section-6.5.11&quot;&gt;第6.5.11节&lt;/a&gt; | | 414 | URI太长| &lt;a href=&quot;#section-6.5.12&quot;&gt;第6.5.12节&lt;/a&gt; | | 415 |不支持的媒体类型| &lt;a href=&quot;#section-6.5.13&quot;&gt;第6.5.13节&lt;/a&gt; | | 417 |期望失败| &lt;a href=&quot;#section-6.5.14&quot;&gt;第6.5.14节&lt;/a&gt; | | 426 |需要升级| &lt;a href=&quot;#section-6.5.15&quot;&gt;第6.5.15节&lt;/a&gt; | | 500 |内部服务器错误| &lt;a href=&quot;#section-6.6.1&quot;&gt;第6.6.1节&lt;/a&gt; | | 501 |未实施| &lt;a href=&quot;#section-6.6.2&quot;&gt;第6.6.2节&lt;/a&gt; | | 502 |错误的网关| &lt;a href=&quot;#section-6.6.3&quot;&gt;第6.6.3节&lt;/a&gt; | | 503 |服务不可用| &lt;a href=&quot;#section-6.6.4&quot;&gt;第6.6.4节&lt;/a&gt; | | 504 |网关超时| &lt;a href=&quot;#section-6.6.5&quot;&gt;第6.6.5节&lt;/a&gt; | | 505 | 不支持HTTP版本 &lt;a href=&quot;#section-6.6.6&quot;&gt;第6.6.6节&lt;/a&gt; | + ------- + ------------------------------- + --------- ------- +</target>
        </trans-unit>
        <trans-unit id="ed1c1d835f4a51029a15ccecbb039e7a11e9bd7a" translate="yes" xml:space="preserve">
          <source>The status codes listed below are defined in this specification,
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7232]&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7233]&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;Section&amp;nbsp;3 of
   [RFC7235]&lt;/a&gt;.  The reason phrases listed here are only recommendations
   -- they can be replaced by local equivalents without affecting the
   protocol.

   Responses with status codes that are defined as cacheable by default
   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in
   this specification) can be reused by a cache with heuristic
   expiration unless otherwise indicated by the method definition or
   explicit cache controls [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]; all other status codes are not
   cacheable by default. 

   +------+-------------------------------+--------------------------+
   | Code | Reason-Phrase                 | Defined in...            |
   +------+-------------------------------+--------------------------+
   | 100  | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;            |
   | 101  | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;            |
   | 200  | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;            |
   | 201  | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;            |
   | 202  | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;            |
   | 203  | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;            |
   | 204  | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;            |
   | 205  | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;            |
   | 206  | Partial Content               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7233]&lt;/a&gt; |
   | 300  | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;            |
   | 301  | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;            |
   | 302  | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;            |
   | 303  | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;            |
   | 304  | Not Modified                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt; |
   | 305  | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;            |
   | 307  | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;            |
   | 400  | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;            |
   | 401  | Unauthorized                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7235]&lt;/a&gt; |
   | 402  | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;            |
   | 403  | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;            |
   | 404  | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;            |
   | 405  | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;            |
   | 406  | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;            |
   | 407  | Proxy Authentication Required | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7235]&lt;/a&gt; |
   | 408  | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;            |
   | 409  | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;            |
   | 410  | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;            |
   | 411  | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt;           |
   | 412  | Precondition Failed           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7232]&lt;/a&gt; |
   | 413  | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt;           |
   | 414  | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt;           |
   | 415  | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt;           |
   | 416  | Range Not Satisfiable         | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7233]&lt;/a&gt; |
   | 417  | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt;           |
   | 426  | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;           |
   | 500  | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;            |
   | 501  | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;            |
   | 502  | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;            |
   | 503  | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;            |
   | 504  | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;            |
   | 505  | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;            |
   +------+-------------------------------+--------------------------+ 

   Note that this list is not exhaustive -- it does not include
   extension status codes defined in other specifications.  The complete
   list of status codes is maintained by IANA.  See &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; for
   details.</source>
          <target state="translated">下面列出的状态代码在本说明书中所定义， &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;[RFC7232]的第4节&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;[RFC7233]的第4节&lt;/a&gt;，和&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;[RFC7235]的第3节&lt;/a&gt;。此处列出的原因短语仅是建议-可以用本地等效项替换它们而不会影响协议。状态码默认定义为可缓存的响应（例如，本规范中的200、203、204、206、300、301、404、405、410、414和501）可以被具有启发式到期的缓存重用，除非否则由方法定义或显式缓存控件指示[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;];默认情况下，所有其他状态代码都不可缓存。 + ------ + ------------------------------- + ---------- ---------------- + |代码原因短语|定义于... | + ------ + ------------------------------- + ---------- ---------------- + | 100 |继续| &lt;a href=&quot;#section-6.2.1&quot;&gt;第6.2.1节&lt;/a&gt; | | 101 |交换协议| &lt;a href=&quot;#section-6.2.2&quot;&gt;第6.2.2节&lt;/a&gt; | | 200 |好的&lt;a href=&quot;#section-6.3.1&quot;&gt;第6.3.1节&lt;/a&gt; | | 201 |已创建| &lt;a href=&quot;#section-6.3.2&quot;&gt;第6.3.2节&lt;/a&gt; | | 202 |接受| &lt;a href=&quot;#section-6.3.3&quot;&gt;第6.3.3节&lt;/a&gt; | | 203 |非权威信息| &lt;a href=&quot;#section-6.3.4&quot;&gt;第6.3.4节&lt;/a&gt; | | 204 |没有内容| &lt;a href=&quot;#section-6.3.5&quot;&gt;第6.3.5节&lt;/a&gt; | | 205 |重置内容| &lt;a href=&quot;#section-6.3.6&quot;&gt;第6.3.6节&lt;/a&gt; | | 206 |部分内容| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;[RFC7233]的4.1节&lt;/a&gt; | | 300 |多种选择| &lt;a href=&quot;#section-6.4.1&quot;&gt;第6.4.1节&lt;/a&gt; | | 301 |永久移动| &lt;a href=&quot;#section-6.4.2&quot;&gt;第6.4.2节&lt;/a&gt; | | 302 |找到| &lt;a href=&quot;#section-6.4.3&quot;&gt;第6.4.3节&lt;/a&gt; | | 303 |查看其他| &lt;a href=&quot;#section-6.4.4&quot;&gt;第6.4.4节&lt;/a&gt; | | 304 |未修改| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]的4.1节&lt;/a&gt; | | 305 |使用代理|&lt;a href=&quot;#section-6.4.5&quot;&gt;第6.4.5节&lt;/a&gt; | | 307 |临时重定向| &lt;a href=&quot;#section-6.4.7&quot;&gt;第6.4.7节&lt;/a&gt; | | 400 |错误的请求| &lt;a href=&quot;#section-6.5.1&quot;&gt;第6.5.1节&lt;/a&gt; | | 401 |未经授权| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;[RFC7235]的第3.1节&lt;/a&gt; | | 402 |需要付款| &lt;a href=&quot;#section-6.5.2&quot;&gt;第6.5.2节&lt;/a&gt; | | 403 |禁止&lt;a href=&quot;#section-6.5.3&quot;&gt;第6.5.3节&lt;/a&gt; | | 404 |找不到&lt;a href=&quot;#section-6.5.4&quot;&gt;第6.5.4节&lt;/a&gt; | | 405 |不允许的方法&lt;a href=&quot;#section-6.5.5&quot;&gt;第6.5.5节&lt;/a&gt; | | 406 |不可接受| &lt;a href=&quot;#section-6.5.6&quot;&gt;第6.5.6节&lt;/a&gt; | | 407 |需要代理身份验证| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;[RFC7235]的3.2节&lt;/a&gt; | | 408 |请求超时| &lt;a href=&quot;#section-6.5.7&quot;&gt;第6.5.7节&lt;/a&gt; | | 409 |冲突| &lt;a href=&quot;#section-6.5.8&quot;&gt;第6.5.8节&lt;/a&gt; | | 410 |去了| &lt;a href=&quot;#section-6.5.9&quot;&gt;第6.5.9节&lt;/a&gt; | | 411 |所需长度| &lt;a href=&quot;#section-6.5.10&quot;&gt;第6.5.10节&lt;/a&gt; | | 412 |前提条件失败| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;[RFC7232]的第4.2节&lt;/a&gt; | | 413 |有效载荷过大| &lt;a href=&quot;#section-6.5.11&quot;&gt;第6.5.11节&lt;/a&gt; | | 414 | URI太长| &lt;a href=&quot;#section-6.5.12&quot;&gt;第6.5.12节&lt;/a&gt; | | 415 |不支持的媒体类型|&lt;a href=&quot;#section-6.5.13&quot;&gt;第6.5.13节&lt;/a&gt; | | 416 |范围无法满足| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;[RFC7233]的第4.4节&lt;/a&gt; | | 417 |期望失败| &lt;a href=&quot;#section-6.5.14&quot;&gt;第6.5.14节&lt;/a&gt; | | 426 |需要升级| &lt;a href=&quot;#section-6.5.15&quot;&gt;第6.5.15节&lt;/a&gt; | | 500 |内部服务器错误| &lt;a href=&quot;#section-6.6.1&quot;&gt;第6.6.1节&lt;/a&gt; | | 501 |未实施| &lt;a href=&quot;#section-6.6.2&quot;&gt;第6.6.2节&lt;/a&gt; | | 502 |错误的网关| &lt;a href=&quot;#section-6.6.3&quot;&gt;第6.6.3节&lt;/a&gt; | | 503 |服务不可用| &lt;a href=&quot;#section-6.6.4&quot;&gt;第6.6.4节&lt;/a&gt; | | 504 |网关超时| &lt;a href=&quot;#section-6.6.5&quot;&gt;第6.6.5节&lt;/a&gt; | | 505 | 不支持HTTP版本 &lt;a href=&quot;#section-6.6.6&quot;&gt;第6.6.6节&lt;/a&gt; | + ------ + ------------------------------- + ---------- ---------------- +请注意，此列表并不详尽-不包括其他规范中定义的扩展状态代码。状态代码的完整列表由IANA维护。有关详细信息，请参见&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abe4655086702c287f500adc1ea133906ee1151a" translate="yes" xml:space="preserve">
          <source>The status-code element is a three-digit integer code giving the
   result of the attempt to understand and satisfy the request.

   HTTP status codes are extensible.  HTTP clients are not required to
   understand the meaning of all registered status codes, though such
   understanding is obviously desirable.  However, a client MUST
   understand the class of any status code, as indicated by the first
   digit, and treat an unrecognized status code as being equivalent to
   the x00 status code of that class, with the exception that a
   recipient MUST NOT cache a response with an unrecognized status code.

   For example, if an unrecognized status code of 471 is received by a
   client, the client can assume that there was something wrong with its
   request and treat the response as if it had received a 400 (Bad
   Request) status code.  The response message will usually contain a
   representation that explains the status.

   The first digit of the status-code defines the class of response.
   The last two digits do not have any categorization role.  There are
   five values for the first digit:

   o  1xx (Informational): The request was received, continuing process

   o  2xx (Successful): The request was successfully received,
      understood, and accepted

   o  3xx (Redirection): Further action needs to be taken in order to
      complete the request

   o  4xx (Client Error): The request contains bad syntax or cannot be
      fulfilled 

   o  5xx (Server Error): The server failed to fulfill an apparently
      valid request</source>
          <target state="translated">status-code元素是一个三位数的整数代码,给出了试图理解和满足请求的结果。HTTP状态码是可扩展的。HTTP客户端不需要理解所有注册状态码的含义,尽管这种理解显然是可取的。然而,客户端必须理解任何状态码的类别,如第一个数字所示,并将未识别的状态码视为等同于该类别的x00状态码,例外的是,接收方必须不缓存带有未识别状态码的响应。例如,如果客户端收到了一个471的未识别状态码,客户端可以认为它的请求有问题,并把响应当作它收到了400(坏请求)状态码。响应消息通常会包含一个解释状态的表示。状态码的第一个数字定义了响应的类别。后两位数字没有任何分类作用。第一位数字有五种值:o 1xx(Informational)。o 2xx(成功):请求已收到,继续处理。o 3xx (重定向):请求被成功接收、理解和接受。o 4xx (客户端错误):o 5xx (服务器错误):请求包含错误的语法或不能被满足。服务器未能完成一个明显有效的请求。</target>
        </trans-unit>
        <trans-unit id="ea09a27e31ad55afff5e7a2614ea2f6ce9a594b2" translate="yes" xml:space="preserve">
          <source>The string can contain any number of the following building blocks, separated by a semicolon:</source>
          <target state="translated">该字符串可以包含以下任意数量的构件,用分号分隔。</target>
        </trans-unit>
        <trans-unit id="4d9a1a47b58bb09a0a513706e6f21fd9ec5db53c" translate="yes" xml:space="preserve">
          <source>The string following &lt;code&gt;filename&lt;/code&gt; should always be put into quotes; but, for compatibility reasons, many browsers try to parse unquoted names that contain spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6aeb189468d6962df260c9530bf2336ac50aef" translate="yes" xml:space="preserve">
          <source>The successful result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; is often not a &lt;code&gt;200&lt;/code&gt;&lt;code&gt;OK&lt;/code&gt; but a &lt;a href=&quot;204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt; (or a &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; when the resource is uploaded for the first time).</source>
          <target state="translated">&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;的成功结果通常不是 &lt;code&gt;200&lt;/code&gt; &lt;code&gt;OK&lt;/code&gt; ,而是&lt;a href=&quot;204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; &lt;code&gt;No Content&lt;/code&gt; （或第一次上传资源时 &lt;code&gt;Created&lt;/code&gt; &lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7f017eb4d89aedd499f70986d2b736c586f7c389" translate="yes" xml:space="preserve">
          <source>The syntax for these headers is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a73c4b6342735091b4f2e7334e43ba0cdd039a" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;Server-Timing&lt;/code&gt; header allows you to communicate metrics in different ways: server metric name only, metric with value, metric with value and description, and metric with description.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; 标头的语法允许您以不同的方式传达度量标准：仅服务器度量标准名称，具有值的度量标准，具有值和描述的度量标准以及具有描述的度量标准。</target>
        </trans-unit>
        <trans-unit id="9d244dc96c1e69e051bc4e338a9553169a494af1" translate="yes" xml:space="preserve">
          <source>The syntax of the Slug header is defined using the augmented BNF
   syntax defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;:

       LWS      = &amp;lt;defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC2616]&lt;/a&gt;&amp;gt;
       slugtext = %x20-7E | LWS
       Slug     = &quot;Slug&quot; &quot;:&quot; *slugtext

   The field value is the percent-encoded value of the UTF-8 encoding of
   the character sequence to be included (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC3986]&lt;/a&gt;
   for the definition of percent encoding, and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] for the
   definition of the UTF-8 encoding).

   Implementation note: to produce the field value from a character
   sequence, first encode it using the UTF-8 encoding, then encode all
   octets outside the ranges %20-24 and %26-7E using percent encoding
   (%25 is the ASCII encoding of &quot;%&quot;, thus it needs to be escaped).  To
   consume the field value, first reverse the percent encoding, then run
   the resulting octet sequence through a UTF-8 decoding process.</source>
          <target state="translated">Slug标头的语法使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;[RFC2616]第2.1节中&lt;/a&gt;定义的增强BNF语法定义：LWS = &amp;lt; &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;[RFC2616] 2.2节中&lt;/a&gt;定义的&amp;gt; slugtext =％x20-7E | LWS Slug =&amp;ldquo; Slug&amp;rdquo;&amp;ldquo;：&amp;rdquo; * slugtext字段值是要包含的字符序列的UTF-8编码的百分比编码值（ 有关百分比编码的定义，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;[RFC3986]第2.1节&lt;/a&gt;，[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;]（用于定义UTF-8编码）。实施说明：要从字符序列生成字段值，请先使用UTF-8编码对其进行编码，然后使用百分比编码对％20-24和％26-7E范围以外的所有八位字节进行编码（％25是ASCII编码&amp;ldquo;％&amp;rdquo;，因此需要对其进行转义）。要消耗字段值，请先反转百分比编码，然后通过UTF-8解码过程运行得到的八位位组序列。</target>
        </trans-unit>
        <trans-unit id="ea12de6efa63fc587d1f14a9b9c6eb9b2ffc6913" translate="yes" xml:space="preserve">
          <source>The table below describes the behavior that occurs when a lock
   request is made on a resource.

     +--------------------------+----------------+-------------------+
     | Current State            | Shared Lock OK | Exclusive Lock OK |
     +--------------------------+----------------+-------------------+
     | None                     | True           | True              |
     | Shared Lock              | True           | False             |
     | Exclusive Lock           | False          | False*            |
     +--------------------------+----------------+-------------------+

   Legend: True = lock may be granted.  False = lock MUST NOT be
   granted. *=It is illegal for a principal to request the same lock
   twice.

   The current lock state of a resource is given in the leftmost column,
   and lock requests are listed in the first row.  The intersection of a
   row and column gives the result of a lock request.  For example, if a
   shared lock is held on a resource, and an exclusive lock is
   requested, the table entry is &quot;false&quot;, indicating that the lock must
   not be granted.</source>
          <target state="translated">下表描述了在资源上提出锁请求时发生的行为。+--------------------------+----------------+-------------------+锁定请求的行为如下表所示。图例:True=可以授予锁定,False=锁定必须不被授予。False=鎖必須不被授予。*=主体请求两次相同的锁是非法的。资源的当前锁状态在最左边的列中给出,锁请求在第一行中列出。行和列的交点给出了锁请求的结果。例如,如果一个资源上持有共享锁,而请求的是独占锁,则表项为 &quot;false&quot;,表示不得授予该锁。</target>
        </trans-unit>
        <trans-unit id="b94957031bbb851c3915a1e070dc41a5bc6b1c5f" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, which nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="translated">HTTP请求的目标称为&amp;ldquo;资源&amp;rdquo;，其性质没有进一步定义。它可以是文档，照片或其他任何东西。每个资源都由一个统一资源标识符（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;）标识，该标识符在整个HTTP中都用于标识资源。</target>
        </trans-unit>
        <trans-unit id="a332edd44b965848f63f0bd63edb5a5baade7db6" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, whose nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0027de0398e06b3c16ab5881af95789a5ccae8db" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;.  HTTP does not
   limit the nature of a resource; it merely defines an interface that
   might be used to interact with resources.  Each resource is
   identified by a Uniform Resource Identifier (URI), as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;Section&amp;nbsp;2.7 of [RFC7230]&lt;/a&gt;.

   When a client constructs an HTTP/1.1 request message, it sends the
   target URI in one of various forms, as defined in (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of
   [RFC7230]&lt;/a&gt;).  When a request is received, the server reconstructs an
   effective request URI for the target resource (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;).

   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and a few
   request-modifying header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If there is a conflict
   between the method semantics and any semantic implied by the URI
   itself, as described in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;, the method semantics take
   precedence.</source>
          <target state="translated">HTTP请求的目标称为&amp;ldquo;资源&amp;rdquo;。 HTTP不限制资源的性质；它仅定义了可用于与资源交互的接口。每个资源都由统一资源标识符（URI）标识，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]的2.7节&lt;/a&gt;所述 。客户端构造HTTP / 1.1请求消息时，它将&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;以[RFC7230]的5.3节中&lt;/a&gt;定义的各种形式之一发送目标URI 。收到请求后，服务器将为目标资源重建有效的请求URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]的5.5节&lt;/a&gt;）。 HTTP的一个设计目标是将资源标识与请求语义分开，这是通过将请求语义赋予请求方法来实现的（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;）和一些请求修改标头字段（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果方法语义与URI本身所隐含的任何语义之间存在冲突（如&lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节中&lt;/a&gt;所述），则以方法语义为准。</target>
        </trans-unit>
        <trans-unit id="9418d48752326ff0dff5f0989dac32b59078dac8" translate="yes" xml:space="preserve">
          <source>The text of the error message will be something similar to the following:</source>
          <target state="translated">错误信息的文本将类似于以下内容。</target>
        </trans-unit>
        <trans-unit id="19c4cdcadd110283f71f254a20c3b6bdf9d892cf" translate="yes" xml:space="preserve">
          <source>The time in seconds the object has been in a proxy cache.</source>
          <target state="translated">对象在代理缓存中的时间(秒)。</target>
        </trans-unit>
        <trans-unit id="b56b41274f5f4a39f688c4966d1da21de98a88bd" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that a site is only to be accessed using HTTPS.</source>
          <target state="translated">浏览器应该记住一个网站只能使用HTTPS访问的时间,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="1ab5a5f12646b8f33cf1a6e834273c9a7926c03d" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that this site is only to be accessed using one of the defined keys.</source>
          <target state="translated">浏览器应记住本网站只能使用其中一个定义的键访问的时间,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="4110d2a33eaaff440bedc1360a1f4ce9d0cb92f4" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the object has been in a proxy cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e4cd11bd5edf3670dcbf4e3f786a4428a217a9" translate="yes" xml:space="preserve">
          <source>The total size of the document (or &lt;code&gt;'*'&lt;/code&gt; if unknown).</source>
          <target state="translated">文档的总大小（如果未知，则为 &lt;code&gt;'*'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f6969607248ffc4491cc44dae24cf7138a7b4be2" translate="yes" xml:space="preserve">
          <source>The transfer-length of a message is the length of the message-body as
   it appears in the message; that is, after any transfer-codings have
   been applied. When a message-body is included with a message, the
   transfer-length of that body is determined by one of the following
   (in order of precedence):

   1.Any response message which &quot;MUST NOT&quot; include a message-body (such
     as the 1xx, 204, and 304 responses and any response to a HEAD
     request) is always terminated by the first empty line after the
     header fields, regardless of the entity-header fields present in
     the message.

   2.If a Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;) is present and
     has any value other than &quot;identity&quot;, then the transfer-length is
     defined by use of the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;),
     unless the message is terminated by closing the connection.

   3.If a Content-Length header field (&lt;a href=&quot;#section-14.13&quot;&gt;section 14.13&lt;/a&gt;) is present, its
     decimal value in OCTETs represents both the entity-length and the
     transfer-length. The Content-Length header field MUST NOT be sent
     if these two lengths are different (i.e., if a Transfer-Encoding 

     header field is present). If a message is received with both a
     Transfer-Encoding header field and a Content-Length header field,
     the latter MUST be ignored.

   4.If the message uses the media type &quot;multipart/byteranges&quot;, and the
     ransfer-length is not otherwise specified, then this self-
     elimiting media type defines the transfer-length. This media type
     UST NOT be used unless the sender knows that the recipient can arse
     it; the presence in a request of a Range header with ultiple byte-
     range specifiers from a 1.1 client implies that the lient can parse
     multipart/byteranges responses.

       A range header might be forwarded by a 1.0 proxy that does not
       understand multipart/byteranges; in this case the server MUST
       delimit the message using methods defined in items 1,3 or 5 of
       this section.

   5.By the server closing the connection. (Closing the connection
     cannot be used to indicate the end of a request body, since that
     would leave no possibility for the server to send back a response.)

   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
   containing a message-body MUST include a valid Content-Length header
   field unless the server is known to be HTTP/1.1 compliant. If a
   request contains a message-body and a Content-Length is not given,
   the server SHOULD respond with 400 (bad request) if it cannot
   determine the length of the message, or with 411 (length required) if
   it wishes to insist on receiving a valid Content-Length.

   All HTTP/1.1 applications that receive entities MUST accept the
   &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;), thus allowing this mechanism
   to be used for messages when the message length cannot be determined
   in advance.

   Messages MUST NOT include both a Content-Length header field and a
   non-identity transfer-coding. If the message does include a non-
   identity transfer-coding, the Content-Length MUST be ignored.

   When a Content-Length is given in a message where a message-body is
   allowed, its field value MUST exactly match the number of OCTETs in
   the message-body. HTTP/1.1 user agents MUST notify the user when an
   invalid length is received and detected.</source>
          <target state="translated">消息的传输长度是显示在消息中的消息正文的长度。也就是说，在应用了任何传输编码之后。当消息主体包含在消息中时，该主体的传输长度由以下其中一项（按优先级顺序）确定：1.任何&amp;ldquo;不得&amp;rdquo;包含消息主体的响应消息（例如1xx，204和304响应以及对HEAD请求的任何响应）总是由标头字段之后的第一个空行终止，而不管消息中存在的实体标头字段如何。 2.如果存在传输编码头字段（&lt;a href=&quot;#section-14.41&quot;&gt;第14.41节&lt;/a&gt;），并且具有除&amp;ldquo; identity&amp;rdquo;以外的其他任何值，则使用&amp;ldquo;块&amp;rdquo;定义传输长度转移编码（&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节&lt;/a&gt;），除非该消息通过关闭连接而终止。 3.如果Content-Length标头字段（&lt;a href=&quot;#section-14.13&quot;&gt;14.13节&lt;/a&gt;）存在，其在OCTET中的十进制值表示实体长度和传输长度。如果这两个长度不同（即，如果存在传输编码标头字段），则不得发送Content-Length标头字段。如果收到的消息同时具有传输编码报头字段和内容长度报头字段，则后者必须被忽略。 4.如果消息使用媒体类型&amp;ldquo; multipart / byteranges&amp;rdquo;，并且未另外指定ransfer-length，则此自限制媒体类型将定义传输长度。除非发件人知道收件人可以对此媒体类型使用，否则请勿使用此媒体类型。请求中包含带有从1开始的多字节范围说明符的Range标头。1个客户端表示留置权可以解析多部分/字节范围的响应。范围标头可能由无法理解多部分/字节范围的1.0代理转发。在这种情况下，服务器必须使用本节第1,3或5条中定义的方法对消息进行定界。 5.通过服务器关闭连接。 （关闭连接不能用于指示请求主体的结束，因为这将使服务器无法发送回响应。）为了与HTTP / 1.0应用程序兼容，包含消息主体的HTTP / 1.1请求必须包括有效的Content-Length标头字段，除非已知服务器兼容HTTP / 1.1。如果请求包含消息正文，但未提供Content-Length，如果服务器不能确定消息的长度，则服务器应该以400（错误请求）响应，或者如果它希望坚持接收有效的Content-Length，则应以411（要求长度）响应。所有接收实体的HTTP / 1.1应用程序都必须接受&amp;ldquo;分块&amp;rdquo;传输编码（&lt;a href=&quot;#section-3.6&quot;&gt;3.6节&lt;/a&gt;），因此当无法预先确定消息长度时，可以将此机制用于消息。消息不得同时包含Content-Length头字段和非身份转移编码。如果消息中确实包含非身份转移编码，则必须忽略Content-Length。在允许消息正文的消息中给出Content-Length时，其字段值务必与消息正文中的OCTET数量完全匹配。当接收和检测到无效长度时，HTTP / 1.1用户代理必须通知用户。</target>
        </trans-unit>
        <trans-unit id="38523484ffd68ebb6eb7a5214e3ed27961920f11" translate="yes" xml:space="preserve">
          <source>The two URNs correspond to</source>
          <target state="translated">这两个URN对应的是</target>
        </trans-unit>
        <trans-unit id="ff2f97e2406493e9f79fccc71e1be4f7abf32463" translate="yes" xml:space="preserve">
          <source>The unit for ranges are bytes.</source>
          <target state="translated">范围的单位是字节。</target>
        </trans-unit>
        <trans-unit id="b6b0d4dfd9983f94ad3e71c861ccec5e604be4be" translate="yes" xml:space="preserve">
          <source>The unit in which ranges are specified. This is usually &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">指定范围的单位。通常是 &lt;code&gt;bytes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d38ef4967199ab3d3fb64a4af1f2610ad2fb5dab" translate="yes" xml:space="preserve">
          <source>The user has not specified a preference about tracking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924b5ee64285daafc6521cbe0d29ade1c8958494" translate="yes" xml:space="preserve">
          <source>The user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">用户在给定的时间内发送了太多的请求(&quot;速率限制&quot;)。</target>
        </trans-unit>
        <trans-unit id="9ffdd05f199fbe940ba584fa8cdea1148a035d9b" translate="yes" xml:space="preserve">
          <source>The user prefers not to be tracked on the target site.</source>
          <target state="translated">用户不希望在目标网站上被跟踪。</target>
        </trans-unit>
        <trans-unit id="d71574f65fb3da08e3baf6b4a99a03c89f5a3b91" translate="yes" xml:space="preserve">
          <source>The user prefers to allow tracking on the target site.</source>
          <target state="translated">用户更愿意允许在目标网站上进行跟踪。</target>
        </trans-unit>
        <trans-unit id="91276b37149e1af5a39e9acf956fda9d8e55baac" translate="yes" xml:space="preserve">
          <source>The user requests an illegal resource, such as a web page censored by a government.</source>
          <target state="translated">用户请求一个非法资源,如政府审查的网页。</target>
        </trans-unit>
        <trans-unit id="9b9325341a547bb5d13f713ae99d4c608b9f2504" translate="yes" xml:space="preserve">
          <source>The user's DNT preference can also be read from JavaScript using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt;&lt;code&gt;Navigator.doNotTrack&lt;/code&gt;&lt;/a&gt; property:</source>
          <target state="translated">也可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt; &lt;code&gt;Navigator.doNotTrack&lt;/code&gt; &lt;/a&gt;属性从JavaScript中读取用户的DNT首选项：</target>
        </trans-unit>
        <trans-unit id="ed64b46fa75921957cada3be294011ac523b15f9" translate="yes" xml:space="preserve">
          <source>The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6eca9e7b97463080612be2b9d7493bcb1e1c94" translate="yes" xml:space="preserve">
          <source>The username and the password are combined with a colon (&lt;code&gt;aladdin:opensesame&lt;/code&gt;).</source>
          <target state="translated">用户名和密码用冒号（ &lt;code&gt;aladdin:opensesame&lt;/code&gt; ）组合。</target>
        </trans-unit>
        <trans-unit id="36e6a72462ef3ce7f1b58a51225794379cf53bdb" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal header name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26cfba7c951a6edda6e1e994a33a34814751c61e" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal header name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics. Note that the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header can't be wildcarded and always needs to be listed explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854a2275bb7da001005de950b8d6724a4e032a0a" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal method name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e7dde22649be5d5f9982b5b058ad7e12b419de" translate="yes" xml:space="preserve">
          <source>The value of a property is always a (well-formed) XML fragment.

   XML has been chosen because it is a flexible, self-describing,
   structured data format that supports rich schema definitions, and
   because of its support for multiple character sets.  XML's self-
   describing nature allows any property's value to be extended by
   adding elements.  Clients will not break when they encounter
   extensions because they will still have the data specified in the
   original schema and MUST ignore elements they do not understand. 

   XML's support for multiple character sets allows any human-readable
   property to be encoded and read in a character set familiar to the
   user.  XML's support for multiple human languages, using the &quot;xml:
   lang&quot; attribute, handles cases where the same character set is
   employed by multiple human languages.  Note that xml:lang scope is
   recursive, so an xml:lang attribute on any element containing a
   property name element applies to the property value unless it has
   been overridden by a more locally scoped attribute.  Note that a
   property only has one value, in one language (or language MAY be left
   undefined); a property does not have multiple values in different
   languages or a single value in multiple languages.

   A property is always represented with an XML element consisting of
   the property name, called the &quot;property name element&quot;.  The simplest
   example is an empty property, which is different from a property that
   does not exist:

      &amp;lt;R:title xmlns:R=&quot;http://www.example.com/ns/&quot;&amp;gt;&amp;lt;/R:title&amp;gt;

   The value of the property appears inside the property name element.
   The value may be any kind of well-formed XML content, including both
   text-only and mixed content.  Servers MUST preserve the following XML
   Information Items (using the terminology from [&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]) in
   storage and transmission of dead properties:

   For the property name Element Information Item itself:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;] named &quot;xml:lang&quot; or any such attribute in scope

      [&lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;children&lt;/a&gt;] of type element or character

   On all Element Information Items in the property value:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;]

      [&lt;a href=&quot;#ref-children&quot;&gt;children&lt;/a&gt;] of type element or character 

   On Attribute Information Items in the property value:

      [namespace name]

      [local name]

      [normalized value]

   On Character Information Items in the property value:

      [character code]

   Since prefixes are used in some XML vocabularies (XPath and XML
   Schema, for example), servers SHOULD preserve, for any Information
   Item in the value:

      [&lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;prefix&lt;/a&gt;]

   XML Infoset attributes not listed above MAY be preserved by the
   server, but clients MUST NOT rely on them being preserved.  The above
   rules would also apply by default to live properties, unless defined
   otherwise.

   Servers MUST ignore the XML attribute xml:space if present and never
   use it to change whitespace handling.  Whitespace in property values
   is significant.</source>
          <target state="translated">属性的值始终是（格式正确的）XML片段。选择XML是因为它是一种灵活的，自描述的，结构化的数据格式，可以支持丰富的模式定义，并且因为它支持多个字符集。 XML的自我描述性质允许通过添加元素来扩展任何属性的值。客户端遇到扩展时不会中断，因为它们仍将具有原始架构中指定的数据，并且必须忽略其不理解的元素。 XML对多个字符集的支持允许以用户熟悉的字符集对任何人类可读属性进行编码和读取。 XML使用&amp;ldquo; xml：lang&amp;rdquo;属性对多种人类语言的支持，处理多种人类语言使用相同字符集的情况。请注意，xml：lang范围是递归的，因此包含属性名称元素的任何元素上的xml：lang属性都适用于该属性值，除非已被本地范围更广的属性所覆盖。注意，一个属性只有一种值（用一种语言（或可以不定义语言））；属性没有使用不同语言的多个值或使用多种语言的单个值。一个属性总是用一个由属性名称组成的XML元素表示，称为&amp;ldquo;属性名称元素&amp;rdquo;。最简单的示例是一个空属性，该属性与不存在的属性不同：&amp;lt;R：title xmlns：R =&amp;ldquo; http://www.example.com/ns/&amp;rdquo;&amp;gt; &amp;lt;/ R：title&amp;gt;该属性的值显示在属性名称元素内。该值可以是任何一种格式良好的XML内容，包括纯文本内容和混合内容。服务器务必保留以下XML信息项（使用[&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt; ]），用于存储和传输无效属性：对于属性名称元素信息项本身：[名称空间名称] [本地名称] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;属性&lt;/a&gt; ]名为&amp;ldquo; xml：lang&amp;rdquo;或范围[ &lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;子级&lt;/a&gt;任何此类属性 ]中的属性值中所有元素信息项上元素或字符的类型：[名称空间名称] [本地名称] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;属性&lt;/a&gt; ] [ &lt;a href=&quot;#ref-children&quot;&gt;子&lt;/a&gt;元素类型元素或字符的]在属性值中的属性信息项上：[名称空间名称] [本地名称] [规范化的值]在属性值中的字符信息项中：[字符代码]由于前缀在某些XML词汇表（XPath中使用（例如XML和XML Schema），服务器应为以下任何信息项保留值：[ &lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;前缀&lt;/a&gt; ]上面未列出的XML Infoset属性可以由服务器保留，但是客户端不得依赖于保留它们。除非另有定义，否则以上规则默认情况下也适用于活动属性。服务器必须忽略XML属性xml：space（如果存在），并且永远不要使用它来更改空白处理。属性值中的空白很重要。</target>
        </trans-unit>
        <trans-unit id="fb3e4816a344b23838df3c23c4b5bab0b9342359" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; and &lt;code&gt;'src'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">值 &lt;code&gt;*&lt;/code&gt; （对所有来源启用）或 &lt;code&gt;'none'&lt;/code&gt; （对所有来源禁用）只能单独使用，而 &lt;code&gt;'self'&lt;/code&gt; 和 &lt;code&gt;'src'&lt;/code&gt; 可以与一个或多个来源一起使用。</target>
        </trans-unit>
        <trans-unit id="f91edc1b64b95c9c888baf6cb011efedf5d401fa" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">值 &lt;code&gt;*&lt;/code&gt; （对所有来源启用）或 &lt;code&gt;'none'&lt;/code&gt; （对所有来源禁用）只能单独使用，而 &lt;code&gt;'self'&lt;/code&gt; 可以与一个或多个来源一起使用。</target>
        </trans-unit>
        <trans-unit id="41c9624006fed0c69222297d2493c20e75ba3334" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;SameSite&lt;/code&gt; attribute are case-insensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb79e8e805e8e88b9627449d36415ee11787dcd" translate="yes" xml:space="preserve">
          <source>The version numbers are not relevant. Avoid inferring materials based on these.</source>
          <target state="translated">版本号与此无关。避免根据这些来推断材料。</target>
        </trans-unit>
        <trans-unit id="c896f8683d1b38332492f9add5b7e8036c2af733" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol they follow.</source>
          <target state="translated">它们所遵循的HTTP协议的版本。</target>
        </trans-unit>
        <trans-unit id="af0975667c912879263ed1a3127961e483e13536" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol.</source>
          <target state="translated">HTTP协议的版本。</target>
        </trans-unit>
        <trans-unit id="18e8cb1bbc1cc055f8280b649b640d1c2817543a" translate="yes" xml:space="preserve">
          <source>The version of the protocol used, such as &quot;1.1&quot;.</source>
          <target state="translated">使用的协议版本,如 &quot;1.1&quot;;</target>
        </trans-unit>
        <trans-unit id="8a2eeda1fd5d692f44f72233f1d8f895ceec9038" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action, besides presenting the warning to the
   user.</source>
          <target state="translated">警告文本可以包括任意信息,以提交给人类用户或记录。收到该警告的系统除了向用户发出警告外,不得采取任何自动行动。</target>
        </trans-unit>
        <trans-unit id="15cc2f59f7cbc4d7458f6cc67c3db06644c699c3" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action.</source>
          <target state="translated">警告文本可以包括任意信息,以呈现给人类用户或记录。收到该警告的系统不得采取任何自动行动。</target>
        </trans-unit>
        <trans-unit id="5141799507b06d7b06feb80a1395a0473365c760" translate="yes" xml:space="preserve">
          <source>The web provides functionality and APIs that may have privacy or security risks if abused. In some cases, you may wish to strictly limit how such functionality is used on a website. There are policy-controlled features to allow functionality to be enabled/disabled for specific origins or frames within a website. Where available, the feature integrates with the Permissions API, or feature-specific mechanisms to check if the feature is available.</source>
          <target state="translated">网络提供的功能和API如果被滥用,可能存在隐私或安全风险。在某些情况下,您可能希望严格限制这些功能在网站上的使用方式。有一些策略控制的功能,允许为网站内的特定起源或框架启用/禁用功能。在可用的情况下,该功能与权限API或特定功能机制集成,以检查该功能是否可用。</target>
        </trans-unit>
        <trans-unit id="7dfe76bf0e6f8f40957fd161579016ac421163fe" translate="yes" xml:space="preserve">
          <source>The wildcard value (*) that is mentioned in the latest specification, is not yet implemented in browsers:</source>
          <target state="translated">最新规范中提到的通配符值(*),在浏览器中还没有实现。</target>
        </trans-unit>
        <trans-unit id="1efbe0911ef1776423c120227469a104642f0bff" translate="yes" xml:space="preserve">
          <source>The&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt; HTML5 boilerplate project&lt;/a&gt; has an example on &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;how to configure an Apache server to redirect one domain to the other&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt;HTML5样板项目&lt;/a&gt;有一个例子&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;如何配置Apache服务器重定向到一个域到另一个&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8f25ce63c5964fb8abf78f765646524df92d04" translate="yes" xml:space="preserve">
          <source>Then include an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">然后在 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 元素上包含&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt;属性：</target>
        </trans-unit>
        <trans-unit id="3a105d13d54e1c2eb5dcd554ae6b632346f6c862" translate="yes" xml:space="preserve">
          <source>Then the client could remember that the JSON version is available at that particular URL, skipping content negotation the next time it requests that document.</source>
          <target state="translated">然后,客户端可以记住JSON版本在该特定的URL中可用,在下次请求该文档时跳过内容协商。</target>
        </trans-unit>
        <trans-unit id="ccd8b24095654e9f5577f70574da438aa878682b" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you determine is appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c166069763014ce7a3cf04a150e6d98bc4aa9d06" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you feel is appropriate.</source>
          <target state="translated">然后,你需要设置你的服务器来接收报告;它可以以任何你认为合适的方式存储或处理它们。</target>
        </trans-unit>
        <trans-unit id="303618442946db88c6e44665ba0c19fde299ff1f" translate="yes" xml:space="preserve">
          <source>Then, with every subsequent request to the server, the browser sends back all previously stored cookies to the server using the &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02072bbfa0f86f96f0652069e08e342de2f1a9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to ensure that cookies are sent securely and are not accessed by unintended parties or scripts: the &lt;code&gt;Secure&lt;/code&gt; attribute and the &lt;code&gt;HttpOnly&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19356494f1c284767cfe46395570ff7af7ec9025" translate="yes" xml:space="preserve">
          <source>There are a few header fields which have general applicability for
   both request and response messages, but which do not apply to the
   entity being transferred. These header fields apply only to the 

   message being transmitted.

       general-header = Cache-Control            ; &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;
                      | Connection               ; &lt;a href=&quot;#section-14.10&quot;&gt;Section 14.10&lt;/a&gt;
                      | Date                     ; &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;
                      | Pragma                   ; &lt;a href=&quot;#section-14.32&quot;&gt;Section 14.32&lt;/a&gt;
                      | Trailer                  ; &lt;a href=&quot;#section-14.40&quot;&gt;Section 14.40&lt;/a&gt;
                      | Transfer-Encoding        ; &lt;a href=&quot;#section-14.41&quot;&gt;Section 14.41&lt;/a&gt;
                      | Upgrade                  ; &lt;a href=&quot;#section-14.42&quot;&gt;Section 14.42&lt;/a&gt;
                      | Via                      ; &lt;a href=&quot;#section-14.45&quot;&gt;Section 14.45&lt;/a&gt;
                      | Warning                  ; &lt;a href=&quot;#section-14.46&quot;&gt;Section 14.46&lt;/a&gt;

   General-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields may be given the semantics of general
   header fields if all parties in the communication recognize them to
   be general-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">有几个标头字段对请求和响应消息都具有通用性，但不适用于正在传输的实体。这些头字段仅适用于正在发送的消息。 general-header =缓存控制; &lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt; |连接; &lt;a href=&quot;#section-14.10&quot;&gt;第14.10节&lt;/a&gt; |日期; &lt;a href=&quot;#section-14.18&quot;&gt;第14.18节&lt;/a&gt; |语用; &lt;a href=&quot;#section-14.32&quot;&gt;第14.32节&lt;/a&gt; |预告片 ; &lt;a href=&quot;#section-14.40&quot;&gt;第14.40节&lt;/a&gt; |传输编码&lt;a href=&quot;#section-14.42&quot;&gt;第14.42节&lt;/a&gt; |通过;&lt;a href=&quot;#section-14.41&quot;&gt;第14.41节&lt;/a&gt; |升级;&lt;a href=&quot;#section-14.45&quot;&gt;第14.45节&lt;/a&gt; |警告 ; 只有结合协议版本的更改，才能可靠地扩展&lt;a href=&quot;#section-14.46&quot;&gt;14.46节的&lt;/a&gt;一般标题字段名称。但是，如果通信中的所有各方都将新的或实验性的标题字段视为通用标题字段，则可以为它们指定通用标题字段的语义。无法识别的标头字段被视为实体标头字段。</target>
        </trans-unit>
        <trans-unit id="3cd54b5762f67dada954e548e046b34d36650e6c" translate="yes" xml:space="preserve">
          <source>There are a few rare conditions when this might occur:</source>
          <target state="translated">有一些罕见的情况下,可能会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="d68958166491fcc8ea9c6532f3f7c7286929a632" translate="yes" xml:space="preserve">
          <source>There are certain aspects of the HTTP Authentication Framework that
   put constraints on how new authentication schemes can work:

   o  HTTP authentication is presumed to be stateless: all of the
      information necessary to authenticate a request MUST be provided
      in the request, rather than be dependent on the server remembering
      prior requests.  Authentication based on, or bound to, the
      underlying connection is outside the scope of this specification
      and inherently flawed unless steps are taken to ensure that the
      connection cannot be used by any party other than the
      authenticated user (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7230]&lt;/a&gt;).

   o  The authentication parameter &quot;realm&quot; is reserved for defining
      protection spaces as described in &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;.  New schemes MUST
      NOT use it in a way incompatible with that definition.

   o  The &quot;token68&quot; notation was introduced for compatibility with
      existing authentication schemes and can only be used once per
      challenge or credential.  Thus, new schemes ought to use the
      auth-param syntax instead, because otherwise future extensions
      will be impossible.

   o  The parsing of challenges and credentials is defined by this
      specification and cannot be modified by new authentication
      schemes.  When the auth-param syntax is used, all parameters ought
      to support both token and quoted-string syntax, and syntactical
      constraints ought to be defined on the field value after parsing
      (i.e., quoted-string processing).  This is necessary so that
      recipients can use a generic parser that applies to all
      authentication schemes.

      Note: The fact that the value syntax for the &quot;realm&quot; parameter is
      restricted to quoted-string was a bad design choice not to be
      repeated for new parameters.

   o  Definitions of new schemes ought to define the treatment of
      unknown extension parameters.  In general, a &quot;must-ignore&quot; rule is
      preferable to a &quot;must-understand&quot; rule, because otherwise it will
      be hard to introduce new parameters in the presence of legacy
      recipients.  Furthermore, it's good to describe the policy for
      defining new parameters (such as &quot;update the specification&quot; or
      &quot;use this registry&quot;).

   o  Authentication schemes need to document whether they are usable in
      origin-server authentication (i.e., using WWW-Authenticate),
      and/or proxy authentication (i.e., using Proxy-Authenticate). 

   o  The credentials carried in an Authorization header field are
      specific to the user agent and, therefore, have the same effect on
      HTTP caches as the &quot;private&quot; Cache-Control response directive
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;Section&amp;nbsp;5.2.2.6 of [RFC7234]&lt;/a&gt;), within the scope of the request in
      which they appear.

      Therefore, new authentication schemes that choose not to carry
      credentials in the Authorization header field (e.g., using a newly
      defined header field) will need to explicitly disallow caching, by
      mandating the use of either Cache-Control request directives
      (e.g., &quot;no-store&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;Section&amp;nbsp;5.2.1.5 of [RFC7234]&lt;/a&gt;) or response
      directives (e.g., &quot;private&quot;).</source>
          <target state="translated">HTTP身份验证框架的某些方面限制了新身份验证方案的工作方式：o HTTP身份验证被假定为无状态的：身份验证请求所需的所有信息都必须在请求中提供，而不是依赖于服务器记住先前的请求。基于或绑定到基础连接的身份验证超出了本规范的范围，并且存在固有的缺陷，除非采取措施确保该连接不能被已身份验证的用户以外的任何一方使用（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;[RFC7230]第2.3节）&lt;/a&gt;）。 。 o身份验证参数&amp;ldquo;领域&amp;rdquo;保留用于定义保护空间，如&lt;a href=&quot;#section-2.2&quot;&gt;第2.2节中&lt;/a&gt;所述。新方案不得以与该定义不兼容的方式使用它。 o引入了&amp;ldquo; token68&amp;rdquo;符号是为了与现有的身份验证方案兼容，并且每个质询或凭据只能使用一次。因此，新的方案应该改为使用auth-param语法，因为否则将来的扩展将是不可能的。 o挑战和凭证的解析由本规范定义，不能由新的身份验证方案修改。使用auth-param语法时，所有参数都应同时支持令牌和带引号的字符串语法，并且在解析（即，带引号的字符串处理）之后，应在字段值上定义语法约束。这是必需的，以便收件人可以使用适用于所有身份验证方案的通用解析器。注意：&amp;ldquo; realm&amp;rdquo;参数的值语法仅限于带引号的字符串，这是一个糟糕的设计选择，不能对新参数重复。 o新方案的定义应定义对未知扩展参数的处理。通常，&amp;ldquo;必须忽略&amp;rdquo;规则比&amp;ldquo;必须了解&amp;rdquo;规则更可取，因为否则，在遗留接收者在场的情况下将很难引入新参数。此外，最好描述定义新参数的策略（例如&amp;ldquo;更新规范&amp;rdquo;或&amp;ldquo;使用此注册表&amp;rdquo;）。o身份验证方案需要记录它们是否可用于原始服务器身份验证（即，使用WWW-Authenticate）和/或代理身份验证（即，使用Proxy-Authenticate）。 o Authorization标头字段中携带的凭证是特定于用户代理的，因此对HTTP缓存的影响与&amp;ldquo;专用&amp;rdquo; Cache-Control响应指令（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;[RFC7234]的5.2.2.6节&lt;/a&gt;），在出现它们的请求范围内。因此，通过选择使用任一Cache-Control请求指令（例如，&amp;ldquo; no- store&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;[RFC7234]的5.2.1.5节&lt;/a&gt;）或响应指令（例如&amp;ldquo;私有&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="47def022b2952624e6b7c50d68fc89498c6bcbc8" translate="yes" xml:space="preserve">
          <source>There are different ways to choose which website is &lt;em&gt;canonical&lt;/em&gt;.</source>
          <target state="translated">有多种选择&lt;em&gt;标准&lt;/em&gt;网站的方法。</target>
        </trans-unit>
        <trans-unit id="fb9fab7f67432c45ef3a01bc4e6955ba9af7ef46" translate="yes" xml:space="preserve">
          <source>There are five major rendering engines: Trident, Gecko, Presto, Blink, and WebKit. As sniffing the rendering engines names is common, a lot of user agents added other rendering names to trigger detection. It is therefore important to pay attention not to trigger false-positives when detecting the rendering engine.</source>
          <target state="translated">有五大渲染引擎。Trident、Gecko、Presto、Blink和WebKit。由于嗅探渲染引擎名称很常见,很多用户代理添加了其他渲染名称来触发检测。因此在检测渲染引擎时要注意不要触发假阳性。</target>
        </trans-unit>
        <trans-unit id="ec7265e037a89a08f26052ad3aa1abd61eeef50e" translate="yes" xml:space="preserve">
          <source>There are no legal or technological requirements for its use, but the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header can be used to signal that a web application should disable either its tracking or cross-site user tracking of an individual user. See the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header for more information.</source>
          <target state="translated">其使用没有法律或技术要求，但是&lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;标头可用于表示Web应用程序应禁用其跟踪或对单个用户的跨站点用户跟踪。有关更多信息，请参见&lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="8341be3003600a3499c2c6008b5ac1ba78954829" translate="yes" xml:space="preserve">
          <source>There are numerous request headers available. They can be divided in several groups:</source>
          <target state="translated">有许多请求头可用。它们可以分为几组。</target>
        </trans-unit>
        <trans-unit id="6e686045e6ac4c90ab4cd236500952ba40ae62b2" translate="yes" xml:space="preserve">
          <source>There are numerous response headers available. These can be divided into several groups:</source>
          <target state="translated">有许多可用的响应头。这些可以分为几组。</target>
        </trans-unit>
        <trans-unit id="9222fd28dc57a16808d7c19d6bf6f9df7c972ab4" translate="yes" xml:space="preserve">
          <source>There are numerous use cases for redirects, but as performance is impacted with every redirect, their use should be kept to a minimum.</source>
          <target state="translated">重定向的用例很多,但由于每次重定向都会影响性能,所以应尽量减少使用。</target>
        </trans-unit>
        <trans-unit id="13f9ecbdd18ed16f602f0ce2e3e411623b20ecea" translate="yes" xml:space="preserve">
          <source>There are several kinds of caches: these can be grouped into two main categories: private or shared caches. A &lt;em&gt;shared cache&lt;/em&gt; is a cache that stores responses for reuse by more than one user. A &lt;em&gt;private cache&lt;/em&gt; is dedicated to a single user. This page will mostly talk about browser and proxy caches, but there are also gateway caches, CDN, reverse proxy caches and load balancers that are deployed on web servers for better reliability, performance and scaling of web sites and web applications.</source>
          <target state="translated">缓存有几种：可以分为两大类：专用缓存或共享缓存。甲&lt;em&gt;共享高速缓存&lt;/em&gt;是一个高速缓存用于通过一个以上的用户复用存储的响应。一个&lt;em&gt;私有缓存&lt;/em&gt;专用于单个用户。此页面将主要讨论浏览器和代理缓存，但也将网关缓存，CDN，反向代理缓存和负载平衡器部署在Web服务器上，以提高网站和Web应用程序的可靠性，性能和扩展性。</target>
        </trans-unit>
        <trans-unit id="cb582dbfa4a7b1600d7a27acf7bcaf2e2220c793" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features designed to represent functionality that can negatively impact the user experience. These features include:</source>
          <target state="translated">有几个政策控制的功能,旨在代表可能对用户体验产生负面影响的功能。这些功能包括:</target>
        </trans-unit>
        <trans-unit id="5b36e7ddb912239041ca7ab0dc533b4f7149cde8" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features to help enforce best practices for providing good performance and user experiences.</source>
          <target state="translated">有几个策略控制的功能,帮助执行最佳实践,以提供良好的性能和用户体验。</target>
        </trans-unit>
        <trans-unit id="4c3b7153e2634e73590a4cce2b8c456ab59f6363" translate="yes" xml:space="preserve">
          <source>There are several types of redirects and they fall into three categories: permanent, temporary and special redirections.</source>
          <target state="translated">有几种类型的重定向,它们分为三类:永久、临时和特殊重定向。</target>
        </trans-unit>
        <trans-unit id="8b2d63fe70a304442a6a486676e591c0916f939e" translate="yes" xml:space="preserve">
          <source>There are several types of redirects, sorted into three categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f58fdbcbba9bec3b86fd66d8bc7fa26b8fe6f5" translate="yes" xml:space="preserve">
          <source>There are three possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 有三种可能的指令：</target>
        </trans-unit>
        <trans-unit id="617a6e0c426a32391566dd90c1be40e2204860a0" translate="yes" xml:space="preserve">
          <source>There are three relevant statuses, when working with range requests:</source>
          <target state="translated">在处理范围请求时,有三种相关状态。</target>
        </trans-unit>
        <trans-unit id="0fff28c9c934766aefa1ed8d526b79ea9e2c24ef" translate="yes" xml:space="preserve">
          <source>There are too many &lt;a href=&quot;../cookies&quot;&gt;Cookies&lt;/a&gt; sent in the request</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce50cfd249603fdf3debd56f0ffcb691991a174f" translate="yes" xml:space="preserve">
          <source>There are two classes of type: &lt;strong&gt;discrete&lt;/strong&gt; and &lt;strong&gt;multipart&lt;/strong&gt;. Discrete types are types which represent a single file or medium, such as a single text or music file, or a single video. A multipart type is one which represents a document that's comprised of multiple component parts, each of which may have its own individual MIME type; or, a multipart type may encapsulate multiple files being sent together in one transaction. For example, multipart MIME types are used when attaching multiple files to an email.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae719b0ddb46afe501f7c4d04161647540a420e" translate="yes" xml:space="preserve">
          <source>There are two common use cases:</source>
          <target state="translated">有两种常见的用例。</target>
        </trans-unit>
        <trans-unit id="4d8949bb550cb1be029d6340065449416ee39fb0" translate="yes" xml:space="preserve">
          <source>There are two entity-tag comparison functions, depending on whether
   or not the comparison context allows the use of weak validators:

   o  Strong comparison: two entity-tags are equivalent if both are not
      weak and their opaque-tags match character-by-character.

   o  Weak comparison: two entity-tags are equivalent if their
      opaque-tags match character-by-character, regardless of either or
      both being tagged as &quot;weak&quot;. 

   The example below shows the results for a set of entity-tag pairs and
   both the weak and strong comparison function results:

   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/&quot;1&quot;  | W/&quot;1&quot;  | no match          | match           |
   | W/&quot;1&quot;  | W/&quot;2&quot;  | no match          | no match        |
   | W/&quot;1&quot;  | &quot;1&quot;    | no match          | match           |
   | &quot;1&quot;    | &quot;1&quot;    | match             | match           |
   +--------+--------+-------------------+-----------------+</source>
          <target state="translated">有两种实体标签比较函数,取决于比较上下文是否允许使用弱验证器:o 强比较:如果两个实体标签都不弱,并且它们的不透明标签逐个字符匹配,则两个实体标签是等价的。 o 弱比较:如果两个实体标签的不透明标签逐个字符匹配,则两个实体标签是等价的,不管其中一个或两个都被标记为 &quot;弱&quot;。下面的例子显示了一组实体标记对的结果以及弱比较和强比较函数的结果。</target>
        </trans-unit>
        <trans-unit id="db65cf9eb555812887e466f13f1dfba01665198b" translate="yes" xml:space="preserve">
          <source>There are two kinds of collection write locks.  A depth-0 write lock
   on a collection protects the collection properties plus the internal
   member URLs of that one collection, while not protecting the content
   or properties of member resources (if the collection itself has any
   entity bodies, those are also protected).  A depth-infinity write
   lock on a collection provides the same protection on that collection
   and also provides write lock protection on every member resource.

   Expressed otherwise, a write lock of either kind protects any request
   that would create a new resource in a write locked collection, any
   request that would remove an internal member URL of a write locked
   collection, and any request that would change the segment name of any
   internal member.

   Thus, a collection write lock protects all the following actions:

   o  DELETE a collection's direct internal member, 

   o  MOVE an internal member out of the collection,

   o  MOVE an internal member into the collection,

   o  MOVE to rename an internal member within a collection,

   o  COPY an internal member into a collection, and

   o  PUT or MKCOL request that would create a new internal member.

   The collection's lock token is required in addition to the lock token
   on the internal member itself, if it is locked separately.

   In addition, a depth-infinity lock affects all write operations to
   all members of the locked collection.  With a depth-infinity lock,
   the resource identified by the root of the lock is directly locked,
   and all its members are indirectly locked.

   o  Any new resource added as a descendant of a depth-infinity locked
      collection becomes indirectly locked.

   o  Any indirectly locked resource moved out of the locked collection
      into an unlocked collection is thereafter unlocked.

   o  Any indirectly locked resource moved out of a locked source
      collection into a depth-infinity locked target collection remains
      indirectly locked but is now protected by the lock on the target
      collection (the target collection's lock token will thereafter be
      required to make further changes).

   If a depth-infinity write LOCK request is issued to a collection
   containing member URLs identifying resources that are currently
   locked in a manner that conflicts with the new lock (see &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;,
   point 3), the request MUST fail with a 423 (Locked) status code, and
   the response SHOULD contain the 'no-conflicting-lock' precondition.

   If a lock request causes the URL of a resource to be added as an
   internal member URL of a depth-infinity locked collection, then the
   new resource MUST be automatically protected by the lock.  For
   example, if the collection /a/b/ is write locked and the resource /c
   is moved to /a/b/c, then resource /a/b/c will be added to the write
   lock.</source>
          <target state="translated">收集写锁有两种。集合上的depth-0写入锁可保护该集合的集合属性以及该成员的内部成员URL，而不保护成员资源的内容或属性（如果集合本身具有任何实体主体，则这些实体也将受到保护）。集合上的深度无限写锁定为该集合提供相同的保护，并且还为每个成员资源提供写锁定保护。否则表示，任何一种写锁都将保护在写锁集合中创建新资源的任何请求，将删除写锁集合的内部成员URL的任何请求以及将更改任何写请求集合的段名称的任何请求。内部成员。从而，集合写锁可保护以下所有操作：o删除集合的直接内部成员，o从集合中移出内部成员，o将内部成员移入集合中，o移动以重命名集合中的内部成员，o COPY一个内部成员加入集合，然后o PUT或MKCOL请求将创建一个新的内部成员。如果内部成员本身具有锁定令牌，则该集合的锁定令牌是必需的（如果单独锁定）。此外，深度无限锁定会影响对锁定集合的所有成员的所有写入操作。使用深度无限锁，将直接锁定由锁的根标识的资源，并间接锁定其所有成员。o作为深度无限锁定集合的后代添加的任何新资源将被间接锁定。 o随后，将任何从锁定集合移出到未锁定集合中的间接锁定资源都被解锁。 o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见o随后，将任何从锁定集合移出到未锁定集合中的间接锁定资源都被解锁。 o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见o随后，将任何从锁定集合移出到未锁定集合中的间接锁定资源都被解锁。 o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见&lt;a href=&quot;#section-6.1&quot;&gt;在第6.1节的第&lt;/a&gt; 3点）中，请求必须失败，并带有423（锁定）状态代码，并且响应应包含&amp;ldquo;无冲突锁&amp;rdquo;的前提条件。如果锁定请求导致将资源的URL添加为深度无限锁定集合的内部成员URL，则新资源务必由锁定自动保护。例如，如果集合/ a / b /被写锁定并且资源/ c被移动到/ a / b / c，那么资源/ a / b / c将被添加到写锁定。</target>
        </trans-unit>
        <trans-unit id="d5dc7184e37e2ac541668d7dc3337de81f5981e3" translate="yes" xml:space="preserve">
          <source>There are two multipart types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0970064e3114d24ebea32cf716e29a9559cf977" translate="yes" xml:space="preserve">
          <source>There are two possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea804f8e0e63528d1dd87bc0e827f009664d28b8" translate="yes" xml:space="preserve">
          <source>There are two types of HTTP messages, requests and responses, each with its own format.</source>
          <target state="translated">HTTP消息有两种类型,请求和响应,每种类型都有自己的格式。</target>
        </trans-unit>
        <trans-unit id="fe2bb96492312ef6374bb657cdd41b390e796741" translate="yes" xml:space="preserve">
          <source>There are two types of proxies: &lt;strong&gt;forward proxies&lt;/strong&gt; (or tunnel, or gateway) and&lt;strong&gt; reverse proxies&lt;/strong&gt; (used to control and protect access to a server for load-balancing, authentication, decryption or caching).</source>
          <target state="translated">代理有两种类型：&lt;strong&gt;正向代理&lt;/strong&gt;（或隧道或网关）和&lt;strong&gt;反向代理&lt;/strong&gt;（用于控制和保护对服务器的访问，以进行负载平衡，身份验证，解密或缓存）。</target>
        </trans-unit>
        <trans-unit id="d24023e8db6a2be9a6f15c3bd48794df9fdd2114" translate="yes" xml:space="preserve">
          <source>There is a discussion to add WebP (&lt;code&gt;image/webp&lt;/code&gt;) to this list, but browser vendors are cautious in accepting it.</source>
          <target state="translated">讨论将WebP（ &lt;code&gt;image/webp&lt;/code&gt; ）添加到此列表中，但是浏览器供应商在接受它时保持谨慎。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
