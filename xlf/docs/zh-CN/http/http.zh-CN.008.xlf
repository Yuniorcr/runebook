<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="74a66c2c405c525c313119a786fdc5a7536e3be4" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource. They are only useful when uploading a resource, usually with &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, to check if another resource with the identity has already been uploaded before.</source>
          <target state="translated">星号是代表任何资源的特殊值。仅当通常使用&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;上传资源时，它们才有用，以检查之前是否已上传具有标识的另一个资源。</target>
        </trans-unit>
        <trans-unit id="dc0975dcc835c772deb36f7878cb50959eba5345" translate="yes" xml:space="preserve">
          <source>The asterisk-form of request-target is only used for a server-wide
   OPTIONS request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;Section&amp;nbsp;4.3.7 of [RFC7231]&lt;/a&gt;).

     asterisk-form  = &quot;*&quot;

   When a client wishes to request OPTIONS for the server as a whole, as
   opposed to a specific named resource of that server, the client MUST
   send only &quot;*&quot; (%x2A) as the request-target.  For example,

     OPTIONS * HTTP/1.1

   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query
   component, then the last proxy on the request chain MUST send a
   request-target of &quot;*&quot; when it forwards the request to the indicated
   origin server.

   For example, the request

     OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP/1.1

   would be forwarded by the final proxy as

     OPTIONS * HTTP/1.1
     Host: www.example.org:8001

   after connecting to port 8001 of host &quot;www.example.org&quot;.</source>
          <target state="translated">request-target的星号形式仅用于服务器范围内的OPTIONS请求（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;[RFC7231]的4.3.7节&lt;/a&gt;）。 asterisk-form =&amp;ldquo; *&amp;rdquo;当客户端希望为整个服务器请求OPTIONS时，与该服务器的特定命名资源相反，客户端必须仅发送&amp;ldquo; *&amp;rdquo;（％x2A）作为请求目标。例如，OPTIONS * HTTP / 1.1如果代理接收到带有绝对目标形式的请求目标的OPTIONS请求，其中URI具有空路径且没有查询组件，则请求链上的最后一个代理必须发送请求-目标&amp;ldquo; *&amp;rdquo;将请求转发到指示的原始服务器时。例如，请求OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; 在连接到主机&amp;ldquo; www.example.org&amp;rdquo;的端口8001之后，HTTP / 1.1将由最终代理作为选项转发* HTTP / 1.1主机：www.example.org：8001。</target>
        </trans-unit>
        <trans-unit id="7c769400bb18a5cd534dd7b8c9bf26657988f6ef" translate="yes" xml:space="preserve">
          <source>The authority component of a URL, consisting of the domain name and optionally the port (prefixed by a &lt;code&gt;':'&lt;/code&gt;), is called the &lt;em&gt;authority form&lt;/em&gt;. It is only used with &lt;code&gt;CONNECT&lt;/code&gt; when setting up an HTTP tunnel.</source>
          <target state="translated">URL的权限组成部分由域名和可选的端口（以 &lt;code&gt;':'&lt;/code&gt; 开头）组成，称为&lt;em&gt;权限形式&lt;/em&gt;。仅在设置HTTP隧道时与 &lt;code&gt;CONNECT&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="7687b27068a2ba93c3867498f2559aee586b78c2" translate="yes" xml:space="preserve">
          <source>The authority-form of request-target is only used for CONNECT
   requests (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of [RFC7231]&lt;/a&gt;).

     authority-form = authority

   When making a CONNECT request to establish a tunnel through one or
   more proxies, a client MUST send only the target URI's authority
   component (excluding any userinfo and its &quot;@&quot; delimiter) as the
   request-target.  For example,

     CONNECT www.example.com:80 HTTP/1.1</source>
          <target state="translated">request-target的授权形式仅用于CONNECT请求（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]的4.3.6节&lt;/a&gt;）。权限形式=权限发出CONNECT请求以通过一个或多个代理建立隧道时，客户端必须仅发送目标URI的权限组件（不包括任何userinfo及其&amp;ldquo; @&amp;rdquo;定界符）作为请求目标。例如，CONNECT www.example.com:80 HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="eb218e220bee49a462071f93357caea4eef78a66" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a .pac filename extension:</source>
          <target state="translated">自动配置文件应保存在一个扩展名为.pac的文件中。</target>
        </trans-unit>
        <trans-unit id="b1a30935583f6c8ca798d1fb82e164294a1797dd" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a &lt;code&gt;.pac&lt;/code&gt; filename extension:</source>
          <target state="translated">自动配置文件应保存到文件扩展名为 &lt;code&gt;.pac&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="97bb2f02d88593e20d553e3a3a22148f46c0a1bc" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the &lt;code&gt;REMOTE_ADDR&lt;/code&gt; environment variable in CGI).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885be6e78dcfaa04b9ed4e903a1be4fd5a6bb5be" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the REMOTE_ADDR environment variable in CGI).</source>
          <target state="translated">自动配置文件可以通过CGI脚本输出。例如,当根据客户端IP地址(CGI中的REMOTE_ADDR环境变量)使自动配置文件以不同的方式运行时,这很有用。</target>
        </trans-unit>
        <trans-unit id="654dd208a7e3408c3ffc11bf5374d37d8901160c" translate="yes" xml:space="preserve">
          <source>The basic cache mechanisms in HTTP/1.1 (server-specified expiration
   times and validators) are implicit directives to caches. In some
   cases, a server or client might need to provide explicit directives
   to the HTTP caches. We use the Cache-Control header for this purpose.

   The Cache-Control header allows a client or server to transmit a
   variety of directives in either requests or responses. These
   directives typically override the default caching algorithms. As a
   general rule, if there is any apparent conflict between header
   values, the most restrictive interpretation is applied (that is, the
   one that is most likely to preserve semantic transparency). However, 

   in some cases, cache-control directives are explicitly specified as
   weakening the approximation of semantic transparency (for example,
   &quot;max-stale&quot; or &quot;public&quot;).

   The cache-control directives are described in detail in &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;.</source>
          <target state="translated">HTTP / 1.1中的基本缓存机制（服务器指定的到期时间和验证器）是对缓存的隐式指令。在某些情况下，服务器或客户端可能需要向HTTP缓存提供明确的指令。为此，我们使用Cache-Control标头。 Cache-Control标头允许客户端或服务器在请求或响应中传输各种指令。这些指令通常会覆盖默认的缓存算法。通常，如果标头值之间存在任何明显的冲突，则会应用限制性最强的解释（即，最有可能保留语义透明性的解释）。但是，在某些情况下，显式指定了高速缓存控制指令以削弱语义透明性的近似性（例如，&amp;ldquo; max-stale&amp;rdquo;或&amp;ldquo;公开&amp;rdquo;）。缓存控制指令在以下内容中有详细描述&lt;a href=&quot;#section-14.9&quot;&gt;第14.9条&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="205356eaedd8e0ecc02522f44b70d14ec801fc5f" translate="yes" xml:space="preserve">
          <source>The basic features of the client-server protocol: what it can do and its intended uses.</source>
          <target state="translated">客户机-服务器协议的基本特点:它能做什么和它的预期用途。</target>
        </trans-unit>
        <trans-unit id="0a4f8aeb61f05bae2255b7ec47533f259568b8c3" translate="yes" xml:space="preserve">
          <source>The below status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;. You can find an updated specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&gt;RFC 7231&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7083aadda2c31d227df92dd2fa84ac3833dcfbc" translate="yes" xml:space="preserve">
          <source>The browser is &lt;strong&gt;always&lt;/strong&gt; the entity initiating the request. It is never the server (though some mechanisms have been added over the years to simulate server-initiated messages).</source>
          <target state="translated">浏览器&lt;strong&gt;始终&lt;/strong&gt;是发起请求的实体。它从来都不是服务器（尽管多年来已经添加了一些机制来模拟服务器启动的消息）。</target>
        </trans-unit>
        <trans-unit id="2cbd8e5718ca567c96ddc915f16935aae94c67e0" translate="yes" xml:space="preserve">
          <source>The browser version is often, but not always, put in the value part of the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; token in the User Agent String. This is of course not the case for Internet Explorer (which puts the version number right after the MSIE token), and for Opera after version 10, which has added a Version/&lt;em&gt;VersionNumber&lt;/em&gt; token.</source>
          <target state="translated">浏览器版本通常（但不总是）放在用户代理字符串中&lt;em&gt;BrowserName / VersionNumber&lt;/em&gt;令牌的值部分中。对于Internet Explorer（将版本号放在MSIE令牌后），对于Opera（在版本10之后）（已添加Version / &lt;em&gt;VersionNumber&lt;/em&gt;令牌），当然不是这种情况。</target>
        </trans-unit>
        <trans-unit id="5bdbde6838426248696c94b45cfec9d0fc5ec1db" translate="yes" xml:space="preserve">
          <source>The browser will automatically retry a previously unresponsive proxy after 30 minutes. Additional attempts will continue beginning at one hour, always adding 30 minutes to the elapsed time between attempts.</source>
          <target state="translated">浏览器将在30分钟后自动重试之前没有反应的代理。额外的尝试将从一小时开始继续,尝试之间的时间总是增加30分钟。</target>
        </trans-unit>
        <trans-unit id="887b852d02845ba1a99a4a0744f4797dc2bf5823" translate="yes" xml:space="preserve">
          <source>The cache is disconnected from the rest of the network.</source>
          <target state="translated">缓存与网络的其他部分断开。</target>
        </trans-unit>
        <trans-unit id="2f21d9d6b26c4e6bea5e52cb792172b8c9de3d95" translate="yes" xml:space="preserve">
          <source>The cache must verify the status of the stale resources before using it and expired ones should not be used.</source>
          <target state="translated">缓存在使用前必须验证陈旧资源的状态,过期的资源不应使用。</target>
        </trans-unit>
        <trans-unit id="daeefaacace04c4b349d31a7092c605e7392d449" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response.</source>
          <target state="translated">缓存不应该存储任何关于客户端请求或服务器响应的信息。</target>
        </trans-unit>
        <trans-unit id="6c578830e2a2b4f9372dff694a83a347a725c406" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response. A request is sent to the server and a full response is downloaded each and every time.</source>
          <target state="translated">缓存不应该存储任何关于客户端请求或服务器响应的内容。向服务器发送请求,每次都会下载完整的响应。</target>
        </trans-unit>
        <trans-unit id="7ca27201de90dba7af54bed9d5fa78a31a2d3e2e" translate="yes" xml:space="preserve">
          <source>The challenge and response flow works like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f42630e59bac670b1a39303ea428afbe6e77a0e" translate="yes" xml:space="preserve">
          <source>The character encoding standard.</source>
          <target state="translated">字符编码标准。</target>
        </trans-unit>
        <trans-unit id="fd7f690c409848b22dbd45c29cbfb870b4b15ecf" translate="yes" xml:space="preserve">
          <source>The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the chunk-size, for the sake of
   supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body
   size.

     chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string

   The chunked encoding is specific to each connection and is likely to
   be removed or recoded by each recipient (including intermediaries)
   before any higher-level application would have a chance to inspect
   the extensions.  Hence, use of chunk extensions is generally limited 

   to specialized HTTP services such as &quot;long polling&quot; (where client and
   server can have shared expectations regarding the use of chunk
   extensions) or for padding within an end-to-end secured connection.

   A recipient MUST ignore unrecognized chunk extensions.  A server
   ought to limit the total length of chunk extensions received in a
   request to an amount reasonable for the services provided, in the
   same way that it applies length limitations and timeouts for other
   parts of a message, and generate an appropriate 4xx (Client Error)
   response if that amount is exceeded.</source>
          <target state="translated">chunked编码允许每个chunk包含零个或多个chunk扩展,紧跟在chunk-size之后,以便提供每个chunk元数据(如签名或哈希)、中间消息控制信息或消息体大小的随机化。chunk-ext=*(&quot;;&quot; chunk-ext-name[&quot;=&quot; chunk-ext-val])chunk-ext-name=token chunk-ext-val=token/quoted-string 分块编码是每个连接所特有的,并且很可能在任何更高级别的应用程序有机会检查扩展之前,被每个接收者(包括中间人)删除或重新编码。因此,分块扩展的使用一般仅限于专门的HTTP服务,如 &quot;长轮询&quot;(客户端和服务器可以对分块扩展的使用有共同的期望)或在端到端安全连接中进行填充。接收者必须忽略未识别的分块扩展。服务器应该将请求中接收到的分块扩展的总长度限制在所提供服务的合理范围内,就像它对消息的其他部分应用长度限制和超时一样,如果超过了这个数量,则生成一个适当的4xx(客户端错误)响应。</target>
        </trans-unit>
        <trans-unit id="48e4a91f8067d7ebfdee16e201dcdb0c016dab57" translate="yes" xml:space="preserve">
          <source>The chunked encoding modifies the body of a message in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing entity-header fields. This
   allows dynamically produced content to be transferred along with the
   information necessary for the recipient to verify that it has
   received the full message.

       Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF

       chunk          = chunk-size [ chunk-extension ] CRLF
                        chunk-data CRLF
       chunk-size     = 1*HEX
       last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF

       chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
       chunk-ext-name = token
       chunk-ext-val  = token | quoted-string
       chunk-data     = chunk-size(OCTET)
       trailer        = *(entity-header CRLF)

   The chunk-size field is a string of hex digits indicating the size of
   the chunk. The chunked encoding is ended by any chunk whose size is
   zero, followed by the trailer, which is terminated by an empty line.

   The trailer allows the sender to include additional HTTP header
   fields at the end of the message. The Trailer header field can be
   used to indicate which header fields are included in a trailer (see
   &lt;a href=&quot;#section-14.40&quot;&gt;section 14.40&lt;/a&gt;). 

   A server using chunked transfer-coding in a response MUST NOT use the
   trailer for any header fields unless at least one of the following is
   true:

   a)the request included a TE header field that indicates &quot;trailers&quot; is
     acceptable in the transfer-coding of the  response, as described in
     &lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;; or,

   b)the server is the origin server for the response, the trailer
     fields consist entirely of optional metadata, and the recipient
     could use the message (in a manner acceptable to the origin server)
     without receiving this metadata.  In other words, the origin server
     is willing to accept the possibility that the trailer fields might
     be silently discarded along the path to the client.

   This requirement prevents an interoperability failure when the
   message is being received by an HTTP/1.1 (or later) proxy and
   forwarded to an HTTP/1.0 recipient. It avoids a situation where
   compliance with the protocol would have necessitated a possibly
   infinite buffer on the proxy.

   An example process for decoding a Chunked-Body is presented in
   appendix 19.4.6.

   All HTTP/1.1 applications MUST be able to receive and decode the
   &quot;chunked&quot; transfer-coding, and MUST ignore chunk-extension extensions
   they do not understand.</source>
          <target state="translated">分块编码修改消息的主体，以便将其作为一系列块传输，每个块都有自己的大小指示符，后跟一个包含实体报头字段的可选尾部。这允许动态产生的内容与接收者验证其已收到完整消息所需的信息一起传输。块状主体= *块状最后一个块状拖车CRLF块状=块状大小[块状扩展] CRLF块状数据CRLF块状大小= 1 * HEX块状末尾= 1 *（&amp;ldquo; 0&amp;rdquo;）[块状扩展名] CRLF chunk-extension = *（&amp;ldquo;;&amp;rdquo; chunk-ext-name [&amp;ldquo; =&amp;rdquo;[chunk-ext-val]））chunk-ext-name =令牌chunk-ext-val =令牌| quoted-string块数据=块大小（OCTET）预告片= *（实体标题CRLF）块大小字段是一个十六进制数字字符串，指示块的大小。分块编码以大小为零的任何分块结尾，其后是尾部，尾部以空行结束。预告片允许发件人在消息末尾包含其他HTTP标头字段。 Trailer标头字段可用于指示预告片中包含哪些标头字段（请参见分块编码以大小为零的任何分块结尾，然后是尾部的结尾，该尾部以空行结束。预告片允许发件人在消息末尾包含其他HTTP标头字段。 Trailer标头字段可用于指示预告片中包含哪些标头字段（请参见分块编码以大小为零的任何分块结尾，然后是尾部的结尾，该尾部以空行结束。预告片允许发件人在消息末尾包含其他HTTP标头字段。 Trailer标头字段可用于指示预告片中包含哪些标头字段（请参见 &lt;a href=&quot;#section-14.40&quot;&gt;第14.40条&lt;/a&gt;）。在响应中使用分块传输编码的服务器不得将尾部用于任何报头字段，除非至少满足以下条件之一：a）请求包含一个TE报头字段，该字段指示&amp;ldquo;尾部&amp;rdquo;在传输编码中是可接受的如&lt;a href=&quot;#section-14.39&quot;&gt;第14.39节&lt;/a&gt;所述 ;或者b）服务器是响应的原始服务器，尾部字段完全由可选的元数据组成，并且收件人可以使用消息（以原始服务器可接受的方式）而无需接收此元数据。换句话说，源服务器愿意接受这样的可能性，即拖车字段可能会沿着到客户端的路径被静默丢弃。当消息被HTTP / 1.1（或更高版本）代理接收并转发给HTTP / 1.0接收者时，此要求可防止互操作性失败。它避免了遵守协议会导致代理服务器上可能存在无限缓冲区的情况。附录19.4.6给出了解码块状体的示例过程。所有HTTP / 1。1个应用程序必须能够接收和解码&amp;ldquo;分块&amp;rdquo;传输编码，并且必须忽略它们不理解的块扩展。</target>
        </trans-unit>
        <trans-unit id="a7d9ecd82450ec8dc1ad7713aebafcc7e0d70fa4" translate="yes" xml:space="preserve">
          <source>The chunked transfer coding wraps the payload body in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing header fields.  Chunked
   enables content streams of unknown size to be transferred as a
   sequence of length-delimited buffers, which enables the sender to
   retain connection persistence and the recipient to know when it has
   received the entire message.

     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets

   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets.  The chunked transfer coding is complete
   when a chunk with a chunk-size of zero is received, possibly followed
   by a trailer, and finally terminated by an empty line.

   A recipient MUST be able to parse and decode the chunked transfer
   coding.</source>
          <target state="translated">分块式传输编码将有效载荷体包装起来,以便将其作为一系列分块传输,每个分块都有自己的大小指示器,然后是一个包含头字段的optional预告片。Chunked使得未知大小的内容流可以作为一个长度限定的缓冲区序列进行传输,这使得发送方能够保留连接持久性,接收方也能够知道何时收到了整个消息。chunked-body=*chunk last-chunk trailer-part CRLF chunk=chunk-size[chunk-ext]CRLF chunk-data CRLF chunk-size=1*HEXDIG last-chunk=1*(&quot;0&quot;)[chunk-ext]CRLF chunk-data=1*OCTET;chunk-size八位数的序列 chunk-size字段是一串十六进制数字,以八位数为单位表示chunk-data的大小。当接收到一个chunk-size为0的chunk时,chunk传输编码就完成了,后面可能是一个拖车,最后以空行结束。接收者必须能够解析和解码分块传输编码。</target>
        </trans-unit>
        <trans-unit id="415a4bc5f36b8b74ac665b81439b0f17201eff1f" translate="yes" xml:space="preserve">
          <source>The client IP address</source>
          <target state="translated">客户端IP地址</target>
        </trans-unit>
        <trans-unit id="f4f8621b5597ea11953d56253188393201c5390d" translate="yes" xml:space="preserve">
          <source>The client SHOULD continue with its request. This interim response is
   used to inform the client that the initial part of the request has
   been received and has not yet been rejected by the server. The client
   SHOULD continue by sending the remainder of the request or, if the
   request has already been completed, ignore this response. The server
   MUST send a final response after the request has been completed. See
   &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for detailed discussion of the use and handling of this
   status code.</source>
          <target state="translated">客户应继续其请求。此临时响应用于通知客户端请求的初始部分已被接收并且尚未被服务器拒绝。客户端应该继续发送剩余的请求，或者，如果请求已经完成，则忽略该响应。请求完成后，服务器必须发送最终响应。有关此状态码的使用和处理的详细讨论，请参见 &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cdfa1347854a07ac313ca6b4125f4dd9a9af51d" translate="yes" xml:space="preserve">
          <source>The client did not produce a request within the time that the server
   was prepared to wait. The client MAY repeat the request without
   modifications at any later time.</source>
          <target state="translated">客户端没有在服务器准备等待的时间内产生请求。客户端可以在以后的任何时间不加修改地重复该请求。</target>
        </trans-unit>
        <trans-unit id="7266b1abf9d7b15153ddaf61096e777051f04c74" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.</source>
          <target state="translated">客户端没有访问内容的权利,即他们是未经授权的,所以服务器拒绝给予适当的响应。与401不同的是,服务器知道客户端的身份。</target>
        </trans-unit>
        <trans-unit id="20c408742f6f7b483f2e5d78c14bc1e7549de56d" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content; that is, it is unauthorized, so the server is refusing to give the requested resource. Unlike 401, the client's identity is known to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a06a1a055ac600eef86c86487e70e03abac976" translate="yes" xml:space="preserve">
          <source>The client establishes a TCP connection (or the appropriate connection if the transport layer is not TCP).</source>
          <target state="translated">客户端建立一个TCP连接(如果传输层不是TCP,则建立相应的连接)。</target>
        </trans-unit>
        <trans-unit id="bc64fec6ee0e97b2601f305debb944c7297d99f9" translate="yes" xml:space="preserve">
          <source>The client has indicated preconditions in its headers which the server does not meet.</source>
          <target state="translated">客户端在其头文件中指出了服务器不满足的前提条件。</target>
        </trans-unit>
        <trans-unit id="bfa31c734d07698a1162e761b391639dea1a2247" translate="yes" xml:space="preserve">
          <source>The client issues a request to the canonical domain: &lt;code&gt;http://example.org/whatddup&lt;/code&gt;</source>
          <target state="translated">客户端向规范域发出请求： &lt;code&gt;http://example.org/whatddup&lt;/code&gt; : //example.org/whatddup</target>
        </trans-unit>
        <trans-unit id="517d78c7c821635a0b4548cee1bab26d988c7745" translate="yes" xml:space="preserve">
          <source>The client sends its request, and waits for the answer.</source>
          <target state="translated">客户端发送请求,并等待回答。</target>
        </trans-unit>
        <trans-unit id="ee32a252064fce95d78b27deb30677a6f5f9861f" translate="yes" xml:space="preserve">
          <source>The client should not repeat this request without modification.</source>
          <target state="translated">客户端不应不加修改地重复此请求。</target>
        </trans-unit>
        <trans-unit id="6ecda58cff7b06f0ebd744bad8fc92cd64e7b568" translate="yes" xml:space="preserve">
          <source>The client that initiated the request and subsequent proxies in a chain of proxies.</source>
          <target state="translated">发起请求的客户端以及代理链中的后续代理。</target>
        </trans-unit>
        <trans-unit id="72cded756bfa543235b2ef68f253845e7563a14d" translate="yes" xml:space="preserve">
          <source>The codings defined below can be used to compress the payload of a
   message.</source>
          <target state="translated">下面定义的编码可以用来压缩信息的有效载荷。</target>
        </trans-unit>
        <trans-unit id="971adc7eb81ae93f06509fafd469f5eea13bda5b" translate="yes" xml:space="preserve">
          <source>The comma-separated list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9677ba4a41043c80dd7875428097d17f3b102726" translate="yes" xml:space="preserve">
          <source>The common use case is to return &lt;code&gt;204&lt;/code&gt; as a result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request, updating a resource, without changing the current content of the page displayed to the user. If the resource is created, &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; is returned instead. If the page should be changed to the newly updated page, the &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">常见用例是作为&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;请求的结果返回 &lt;code&gt;204&lt;/code&gt; ，更新资源，而不更改显示给用户的页面的当前内容。如果创建了资源，则返回&lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; 。如果应将页面更改为新更新的页面，则应使用&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e652d732604ca7329e0833f245786713768ed8e7" translate="yes" xml:space="preserve">
          <source>The common use case of this status code is as the result of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request.</source>
          <target state="translated">此状态代码的常见用例是&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求的结果。</target>
        </trans-unit>
        <trans-unit id="5dee61655e811dbf764699bfb5c6ab2c8de25fd2" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. If a listed &lt;code&gt;ETag&lt;/code&gt; has the &lt;code&gt;W/&lt;/code&gt; prefix indicating a weak entity tag, it will never match under this comparison algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04133abc831323a63813210792503c0061624d7" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. This is weakened when the &lt;code&gt;W/&lt;/code&gt; prefix is used in front of the &lt;code&gt;ETag&lt;/code&gt;.</source>
          <target state="translated">与存储的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;比较&lt;/em&gt;使用&lt;em&gt;强比较算法&lt;/em&gt;，这意味着两个文件仅被视为字节对字节。当在 &lt;code&gt;ETag&lt;/code&gt; 前面使用 &lt;code&gt;W/&lt;/code&gt; 前缀时，这会减弱。</target>
        </trans-unit>
        <trans-unit id="72daedd3e8f61f2659bcac2190d51fd4c98967f8" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical if the content is equivalent &amp;mdash; they don't have to be identical byte for byte. For example, two pages that differ by the date of generation in the footer would still be considered as identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2fbb792f71c73497799f887f4d3819b0abaf6" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical not only if they are identical byte to byte, but if the content is equivalent. For example, two pages that would differ only by the date of generation in the footer would be considered as identical.</source>
          <target state="translated">与存储的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;比较&lt;/em&gt;使用&lt;em&gt;弱比较算法&lt;/em&gt;，这意味着两个文件不仅字节对字节相同，而且内容相同也被视为相同。例如，只有页脚的生成日期不同的两个页面将被视为相同。</target>
        </trans-unit>
        <trans-unit id="a0905c4e80c334babf93aeba4446459e7079b76c" translate="yes" xml:space="preserve">
          <source>The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; and send us a pull request.</source>
          <target state="translated">此页面中的兼容性表是根据结构化数据生成的。如果您想贡献数据，请查看&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;并向我们​​发送请求请求。</target>
        </trans-unit>
        <trans-unit id="8eddfd7122309a2d42352867b0fa5b1e063c2c65" translate="yes" xml:space="preserve">
          <source>The concept was originally proposed in 2012 (as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05c38dc87a4c3ad5288313d314048589646b4f9" translate="yes" xml:space="preserve">
          <source>The concrete steps necessary to deliver the HPKP header depend on the web server you use.</source>
          <target state="translated">传递HPKP头的具体步骤取决于你使用的Web服务器。</target>
        </trans-unit>
        <trans-unit id="c5a34df8c7328504dee9ce9f1c7756c81918158f" translate="yes" xml:space="preserve">
          <source>The connection failed due to errors in HTTP protocol not covered by previous errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b1cd5615c2676730c21d276af1a317e38fc749" translate="yes" xml:space="preserve">
          <source>The connection was aborted due to an HTTP protocol error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aee79466e47707e7aaaf37d00efa279a7d1756" translate="yes" xml:space="preserve">
          <source>The content and concepts within are a product of the Atom community
   and the Atompub Working Group.</source>
          <target state="translated">其中的内容和概念是Atom社区和Atompub工作组的产物。</target>
        </trans-unit>
        <trans-unit id="5e832a9cde14ca1e931972542042bbb8f1f01671" translate="yes" xml:space="preserve">
          <source>The content of an &quot;app:accept&quot; element value is a media range as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The media range specifies a type of
   representation that can be POSTed to a Collection.

   The app:accept element is similar to the HTTP Accept request-header
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  Media type parameters are allowed within app:accept, but
   app:accept has no notion of preference -- &quot;accept-params&quot; or &quot;q&quot;
   arguments, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;Section&amp;nbsp;14.1 of [RFC2616]&lt;/a&gt; are not
   significant.

   White space (as defined in [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]) around the app:accept element's
   media range is insignificant and MUST be ignored.

   A value of &quot;application/atom+xml;type=entry&quot; MAY appear in any app:
   accept list of media ranges and indicates that Atom Entry Documents
   can be POSTed to the Collection.  If no app:accept element is
   present, clients SHOULD treat this as equivalent to an app:accept
   element with the content &quot;application/atom+xml;type=entry&quot;.

   If one app:accept element exists and is empty, clients SHOULD assume
   that the Collection does not support the creation of new Entries.

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }</source>
          <target state="translated">&amp;ldquo; app：accept&amp;rdquo;元素值的内容是[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中定义的媒体范围。媒体范围指定了一种可以过帐到集合的表示形式。 app：accept元素类似于HTTP Accept request-header [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]。 app：accept允许使用媒体类型参数，但是app：accept没有优先级概念- &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;[RFC2616]第14.1节中&lt;/a&gt;指定的&amp;ldquo; accept-params&amp;rdquo;或&amp;ldquo; q&amp;rdquo;参数并不重要。空格（如[ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml中&lt;/a&gt;定义]）周围的app：accept元素的媒体范围微不足道，必须忽略。值&amp;ldquo; application / atom + xml; type = entry&amp;rdquo;可能会出现在任何应用程序中：接受媒体范围列表，并指示可以将Atom条目文档发布到集合中。如果不存在app：accept元素，则客户端应将此内容等同于内容为&amp;ldquo; application / atom + xml; type = entry&amp;rdquo;的app：accept元素。如果一个app：accept元素存在且为空，则客户端应假定Collection不支持新条目的创建。 appAccept =元素app：accept {appCommonAttributes，（text？）}</target>
        </trans-unit>
        <trans-unit id="539a35b3718ee8a5aee196d79e2ab252e1794cb2" translate="yes" xml:space="preserve">
          <source>The content security policy</source>
          <target state="translated">内容安全政策</target>
        </trans-unit>
        <trans-unit id="a99f7db56a8fc0d621fb9f438536232235171cde" translate="yes" xml:space="preserve">
          <source>The cookie created above is a &lt;em&gt;session cookie&lt;/em&gt;: it is deleted when the client shuts down, because it didn't specify an &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directive. However, web browsers may use &lt;strong&gt;session restoring&lt;/strong&gt;, which makes most session cookies permanent, as if the browser was never closed.</source>
          <target state="translated">上面创建的cookie是&lt;em&gt;会话cookie&lt;/em&gt;：由于客户端未指定 &lt;code&gt;Expires&lt;/code&gt; 或 &lt;code&gt;Max-Age&lt;/code&gt; 指令，因此在客户端关闭时将其删除。但是，Web浏览器可能会使用&lt;strong&gt;会话还原&lt;/strong&gt;，这会使大多数会话Cookie保持永久状态，就像从未关闭过浏览器一样。</target>
        </trans-unit>
        <trans-unit id="d3ea80f5dbbb07b298e7e569c7ef43ac598c80e1" translate="yes" xml:space="preserve">
          <source>The creator of a lock has special privileges to use the lock to
   modify the resource.  When a locked resource is modified, a server
   MUST check that the authenticated principal matches the lock creator
   (in addition to checking for valid lock token submission).

   The server MAY allow privileged users other than the lock creator to
   destroy a lock (for example, the resource owner or an administrator).
   The 'unlock' privilege in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] was defined to provide that
   permission.

   There is no requirement for servers to accept LOCK requests from all
   users or from anonymous users.

   Note that having a lock does not confer full privilege to modify the
   locked resource.  Write access and other privileges MUST be enforced
   through normal privilege or authentication mechanisms, not based on
   the possible obscurity of lock token values.</source>
          <target state="translated">锁的创建者具有特殊的特权，可以使用锁来修改资源。修改锁定的资源后，服务器必须检查经过身份验证的主体是否与锁定创建者匹配（除了检查有效的锁定令牌提交之外）。服务器可以允许除锁创建者以外的特权用户破坏锁（例如，资源所有者或管理员）。[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744中&lt;/a&gt;的&amp;ldquo;解锁&amp;rdquo;特权定义为提供该权限。不需要服务器接受来自所有用户或匿名用户的LOCK请求。请注意，拥有锁并不授予修改锁定资源的完整特权。写访问权限和其他特权必须通过普通特权或身份验证机制来实施，而不是基于锁令牌值的可能模糊性。</target>
        </trans-unit>
        <trans-unit id="ed6930808b04a49db2a6e882d398fb403c175d9d" translate="yes" xml:space="preserve">
          <source>The credentials are constructed like this:</source>
          <target state="translated">证件的构造是这样的。</target>
        </trans-unit>
        <trans-unit id="7b8947dfbd554435efd90ececbfae32fbeaafdf7" translate="yes" xml:space="preserve">
          <source>The current set of policy-controlled features fall into two broad categories:</source>
          <target state="translated">目前一套政策控制的功能分为两大类。</target>
        </trans-unit>
        <trans-unit id="a8e69d68f3b1fc3a7df5c137fb99fc1e2d0cfdfa" translate="yes" xml:space="preserve">
          <source>The data URL will use the encoded data after the initial header line.</source>
          <target state="translated">数据URL将使用初始头行后的编码数据。</target>
        </trans-unit>
        <trans-unit id="230d58d4d34777b830d4af9d56c4ae6916e8d111" translate="yes" xml:space="preserve">
          <source>The data portion of a data URL is opaque, so an attempt to use a query string (page-specific parameters, with the syntax &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt;) with a data URL will just include the query string in the data the URL represents.</source>
          <target state="translated">数据URL的数据部分是不透明的，因此，尝试将查询字符串（特定于页面的参数，语法为 &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt; ）与数据URL一起使用时，查询字符串将仅包含在URL数据中代表。</target>
        </trans-unit>
        <trans-unit id="a838733e8354e6c49d346e5cb2fb10c66ede3853" translate="yes" xml:space="preserve">
          <source>The data to be sent is already compressed and a second compression won't lead to smaller data to be transmitted. This may be the case with some image formats;</source>
          <target state="translated">要发送的数据已经被压缩,第二次压缩不会导致传输的数据变小。某些图像格式可能会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="7f9129a63093295fb84eccd3b4f61f829c9ef91c" translate="yes" xml:space="preserve">
          <source>The date/time after which the response is considered stale.</source>
          <target state="translated">答复被视为失效的日期/时间。</target>
        </trans-unit>
        <trans-unit id="0911607a468bc8e23c0901e6b8899136c11add6c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;a href=&quot;#allowlist&quot;&gt;allowlist&lt;/a&gt; value is &lt;code&gt;'src'&lt;/code&gt;, so this is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f69faebfa441f8068a5c2a1d971d7bb75686df" translate="yes" xml:space="preserve">
          <source>The default allowlist is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21e6aaa7014c0a77730b148bd0e400306901bc7" translate="yes" xml:space="preserve">
          <source>The default alowlist is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca00dba55294b3adb13ff2e5e265230f2df2011" translate="yes" xml:space="preserve">
          <source>The default value for unsized-media is &lt;code&gt;'*'&lt;/code&gt;, that is unsized media elements are allowed for all origins by default. The page will re-flow every time an image with unknown dimensions is loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b5d6196048d6e0193482609dd5869326eae443" translate="yes" xml:space="preserve">
          <source>The default value in &lt;a href=&quot;https://www.chromestatus.com/feature/5100524789563392&quot;&gt;Google Chrome&lt;/a&gt; is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d048f49a1bc19ccb8bb277e49d40e7c59a0ae5" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'*'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1d97e38222ff903f1be33758664532039e0043" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;'self'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce8a92d4fc085eba2fc0033588db51c48988c071" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bebd0e8a85754c8108d63895e7f002620ba7cd6c" translate="yes" xml:space="preserve">
          <source>The definition of collection state has been fixed so it doesn't vary
   anymore depending on the Request-URI (see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The DAV:source property introduced in &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;Section&amp;nbsp;4.6 of [RFC2518]&lt;/a&gt; was
   removed due to lack of implementation experience.

   The DAV header now allows non-IETF extensions through URIs in
   addition to compliance class tokens.  It also can now be used in
   requests, although this specification does not define any associated
   semantics for the compliance classes defined in here (see
   &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).

   In &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, the definition of the Depth header (&lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;)
   required that, by default, request headers would be applied to each
   resource in scope.  Based on implementation experience, the default
   has now been reversed (see &lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;).

   The definitions of HTTP status code 102 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518], Section&amp;nbsp;10.1&lt;/a&gt;) and
   the Status-URI response header (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;) have been removed due to
   lack of implementation.

   The TimeType format used in the Timeout request header and the
   &quot;timeout&quot; XML element used to be extensible.  Now, only the two
   formats defined by this specification are allowed (see &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;).

Author's Address

   Lisa Dusseault (editor)
   CommerceNet
   2064 Edgewood Dr.
   Palo Alto, CA  94303
   US

   EMail: ldusseault@commerce.net 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Dusseault                   Standards Track                   [Page 127]</source>
          <target state="translated">收集状态的定义已固定，因此不再取决于Request-URI（请参见&lt;a href=&quot;#section-5.2&quot;&gt;5.2节&lt;/a&gt;）。由于缺乏实施经验&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;，[RFC2518] 4.6节中&lt;/a&gt;引入的DAV：source属性已被删除。 DAV标头现在除了符合性类令牌外，还允许通过URI进行非IETF扩展。现在，它也可以在请求中使用，尽管该规范并未为此处定义的合规性类定义任何关联的语义（请参见 &lt;a href=&quot;#section-10.1&quot;&gt;10.1节&lt;/a&gt;）。在&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518中&lt;/a&gt;，深度标头的定义（&lt;a href=&quot;#section-9.2&quot;&gt;第9.2节&lt;/a&gt;）要求，默认情况下，请求标头将应用于范围内的每个资源。根据实施经验，默认设置现已撤销（请参见&lt;a href=&quot;#section-10.2&quot;&gt;10.2节&lt;/a&gt;）。由于缺乏实现，已删除了HTTP状态代码102（&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518]，第10.1节&lt;/a&gt;）和Status-URI响应标头（&lt;a href=&quot;#section-9.7&quot;&gt;第9.7节&lt;/a&gt;）的定义。超时请求标头中使用的TimeType格式和XML元素&amp;ldquo;超时&amp;rdquo;曾经是可扩展的。现在，仅允许使用本规范定义的两种格式（请参见&lt;a href=&quot;#section-10.7&quot;&gt;10.7节）&lt;/a&gt;）。作者的地址Lisa Dusseault（编辑）CommerceNet 2064 Edgewood帕洛阿尔托博士，CA 94303美国电子邮件：ldusseault@commerce.net完整的版权声明版权所有（C）IETF信托（2007）。本文档受&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78中&lt;/a&gt;包含的权利，许可和限制的约束，除非另有说明，否则作者保留所有权利。本文档及其中包含的信息均按&amp;ldquo;原样&amp;rdquo;提供，并且贡献者，他/她代表的组织或赞助者（如果有），互联网社会，IETF信托和互联网工程任务强制免责声明明示或暗示的担保，包括但不限于任何担保，即使用此处的信息不会侵犯任何权利或对特定用途的适销性或适用性的任何默示担保。知识产权IETF对于可能声称与实施或使用本文档中描述的技术有关的任何知识产权或其他权利的有效性或范围，或根据此类权利获得的任何许可可能或不具有的范围，不采取任何立场。可能不可用；它也不表示它已做出任何独立的努力来确定任何此类权利。可以在以下位置找到有关RFC文档中有关权利的程序的信息：&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;。可以获取向IETF秘书处披露的知识产权的副本，以及可以提供的许可的任何保证，或者本规范的实施者或用户尝试获得一般许可或使用此类所有权的许可的结果。从IETF在线IPR存储库中获得，&lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;网址&lt;/a&gt;为 http://www.ietf.org/ipr。 IETF邀请任何感兴趣的团体提请其注意可能涵盖实施本标准所需技术的任何版权，专利或专利申请或其他所有权。请通过ietf-ipr@ietf.org将信息发送给IETF。 RFC编辑器功能的确认资金目前由Internet Society提供。杜赛标准赛道[第127页]</target>
        </trans-unit>
        <trans-unit id="846eb07b1348486cd629ae2d294bdd353ad9d018" translate="yes" xml:space="preserve">
          <source>The definition of validator weakness has been expanded and clarified.
   (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;)

   Weak entity-tags are now allowed in all requests except range
   requests.  (Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;)

   The ETag header field ABNF has been changed to not use quoted-string,
   thus avoiding escaping issues.  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   ETag is defined to provide an entity tag for the selected
   representation, thereby clarifying what it applies to in various
   situations (such as a PUT response).  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   The precedence for evaluation of conditional requests has been
   defined.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)</source>
          <target state="translated">验证者弱点的定义已得到扩展和澄清。 （&lt;a href=&quot;#section-2.1&quot;&gt;第2.1节&lt;/a&gt;）现在，除范围请求外，所有请求中都允许使用弱实体标签。 （第&lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;和&lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;节）ETag标头字段ABNF已更改为不使用带引号的字符串，从而避免了转义问题。 （&lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt;）定义了ETag，以为所选表示形式提供实体标签，从而阐明其在各种情况下（例如PUT响应）的适用范围。 （&lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt;）已经定义了条件请求评估的优先级。 （&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e5328b76256fad750a1749c068a42a24ebf54b5b" translate="yes" xml:space="preserve">
          <source>The delta-seconds rule specifies a non-negative integer, representing
   time in seconds.

     delta-seconds  = 1*DIGIT

   A recipient parsing a delta-seconds value and converting it to binary
   form ought to use an arithmetic type of at least 31 bits of
   non-negative integer range.  If a cache receives a delta-seconds
   value greater than the greatest integer it can represent, or if any
   of its subsequent calculations overflows, the cache MUST consider the
   value to be either 2147483648 (2^31) or the greatest positive integer
   it can conveniently represent.

      Note: The value 2147483648 is here for historical reasons,
      effectively represents infinity (over 68 years), and does not need
      to be stored in binary form; an implementation could produce it as
      a canned string if any overflow occurs, even if the calculations
      are performed with an arithmetic type incapable of directly
      representing that number.  What matters here is that an overflow
      be detected and not treated as a negative value in later
      calculations.</source>
          <target state="translated">delta-seconds规则指定了一个非负整数,代表以秒为单位的时间。 delta-seconds=1*DIGIT 接收者在解析delta-seconds值并将其转换为二进制形式时,应该使用至少31位非负整数范围的算术类型。如果一个缓存接收到的delta-seconds值大于它能表示的最大整数,或者它的任何后续计算溢出,缓存必须认为这个值是2147483648 (2^31)或者它能方便表示的最大正整数。注意:这里的值2147483648是出于历史原因,有效地代表了无穷大(超过68年),并且不需要以二进制形式存储;如果发生任何溢出,一个实现可以把它作为一个罐头字符串产生,即使计算是用一个无法直接代表这个数字的算术类型进行的。这里重要的是要检测到溢出,并且在以后的计算中不作为负值处理。</target>
        </trans-unit>
        <trans-unit id="462deec90237c01c88236d382d44851e9cb76a0d" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">不推荐使用的HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理报告违反内容安全策略的尝试。这些违规报告包含通过HTTP POST请求发送到指定URI的JSON文档。</target>
        </trans-unit>
        <trans-unit id="d2fba7a8d872d32f2df3792a939bb1791a1db637" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">不推荐使用的HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; 指令定义了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Worker&lt;/a&gt;和使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素加载的嵌套浏览上下文的有效源。对于工作人员，用户代理将不符合要求的请求视为致命的网络错误。</target>
        </trans-unit>
        <trans-unit id="e51c9503c283d705f7c21009451fd7fc25c1eae1" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">不推荐使用的HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理报告违反内容安全策略的尝试。这些违规报告包含通过HTTP POST请求发送到指定URI的JSON文档。</target>
        </trans-unit>
        <trans-unit id="fb07dc5196edc576bb2b0f9aa70d416b3225ffb6" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">不推荐使用的HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; 指令定义了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Worker&lt;/a&gt;和使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素加载的嵌套浏览上下文的有效源。对于工作人员，用户代理将不符合要求的请求视为致命的网络错误。</target>
        </trans-unit>
        <trans-unit id="06d89b04e62b26b8ec32aee4540211a4cdd447d1" translate="yes" xml:space="preserve">
          <source>The design of the cookie mechanism is such that a server is unable to confirm that a cookie was set on a secure origin or even to tell &lt;em&gt;where&lt;/em&gt; a cookie was originally set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546d3635c32a2c56e35d6d2aa60b3503528021d5" translate="yes" xml:space="preserve">
          <source>The determination of the best suited representation is made through one of two mechanisms:</source>
          <target state="translated">通过两种机制之一确定最合适的代表。</target>
        </trans-unit>
        <trans-unit id="efd86e58a3f30de9823ac04636ac8858e24077e3" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;POST&lt;/code&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6be54e0040e3b26e0677bc1c6c4c457e76e04c" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="translated">之间的差 &lt;code&gt;PUT&lt;/code&gt; 和&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;PUT&lt;/code&gt; 是等幂：调用它一次或多次连续具有相同的效果（也就是没有&lt;em&gt;侧面&lt;/em&gt;的效果），在那里连续的相同 &lt;code&gt;POST&lt;/code&gt; 可具有额外的效果，如通过顺序数次。</target>
        </trans-unit>
        <trans-unit id="6709d83055ac598235616e01accc6af867f222e8" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), whereas successive identical &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests may have additional effects, akin to placing an order several times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97e83ad793fdb57539f72e47bc2da06f9dd1d1b" translate="yes" xml:space="preserve">
          <source>The different behaviors are defined by the method of the request used, and by the set of headers used for a precondition:</source>
          <target state="translated">不同的行为是由所使用的请求方法和用于前提条件的头文件集来定义的。</target>
        </trans-unit>
        <trans-unit id="80097a5c7491102e72da844144491c63c53e8bbd" translate="yes" xml:space="preserve">
          <source>The different operations that can be done with HTTP: &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, and also less common requests like &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/trace&quot;&gt;&lt;code&gt;TRACE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用HTTP可以执行的不同操作：&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;以及不太常见的请求，例如&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;methods/trace&quot;&gt; &lt;code&gt;TRACE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="611420eeacf58a81127cc81ea72c3d1d0f45c0e6" translate="yes" xml:space="preserve">
          <source>The digest is calculated over the entire representation. The representation itself may be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04de4891d47a19965395d893dcab0798dc6bd5e" translate="yes" xml:space="preserve">
          <source>The directive has no effect in and of itself, but only gains meaning in combination with other directives.</source>
          <target state="translated">该指令本身没有任何效力,只有与其他指令结合在一起才有意义。</target>
        </trans-unit>
        <trans-unit id="ff5b92c5b8f032668f44bf6f84a3cf1d8c8d5495" translate="yes" xml:space="preserve">
          <source>The directive whose enforcement caused the violation.</source>
          <target state="translated">其执行造成违规的指令;</target>
        </trans-unit>
        <trans-unit id="1e1a37c4f62f3222f090827450cdf97da20610e6" translate="yes" xml:space="preserve">
          <source>The directive whose inforcement caused the violation.</source>
          <target state="translated">导致违规的指令的执行情况;</target>
        </trans-unit>
        <trans-unit id="9d6fbbcf7c6fc507f3bb84ba69ad161ef0423583" translate="yes" xml:space="preserve">
          <source>The directives are case-insensitive and have an optional argument, that can use both token and quoted-string syntax. Multiple directives are comma-separated.</source>
          <target state="translated">指令不区分大小写,有一个可选的参数,可以使用标记和引号字符串两种语法。多条指令以逗号分隔。</target>
        </trans-unit>
        <trans-unit id="a323859b4a71cd1636fe58a5af5f7f00fc33a635" translate="yes" xml:space="preserve">
          <source>The directives of the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header can also be applied to &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;标头的指令也可以应用于 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="279baf1d439803980239f8e98d3badd1808c8388" translate="yes" xml:space="preserve">
          <source>The discrete types currently registered with the IANA are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c774d8f9b5eed24a795ffcdff60addf8cc635d" translate="yes" xml:space="preserve">
          <source>The document &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="translated">文档 &lt;code&gt;https://example.com/page.html&lt;/code&gt; 将发送引荐来源网址 &lt;code&gt;https://example.com/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d8ec917bef56223b37a5c1500b0656c3dce3b2f" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation header&lt;/code&gt; has opened another window with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. This is for the same reason as above, namely that they can communicate and thus we cannot allow them to switch processes.</source>
          <target state="translated">具有 &lt;code&gt;Large-Allocation header&lt;/code&gt; 的文档已打开另一个窗口，该窗口具有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; 或其他类似方法，而未设置 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 功能。这是因为与上述相同的原因，即他们可以通信，因此我们不能允许他们切换进程。</target>
        </trans-unit>
        <trans-unit id="4a86ff11f18e76ef15af55380e0e783a222b5261" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in a window which was opened by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. These windows must remain in the same process as their opener, as they can communicate, meaning that we cannot allow them to switch processes.</source>
          <target state="translated">具有 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头的文档已加载到由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; 或其他类似方法打开的窗口中，而未设置 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 功能。这些窗口必须保持与打开程序相同的进程，因为它们可以通信，这意味着我们不能允许它们切换进程。</target>
        </trans-unit>
        <trans-unit id="99747b44d362c4206f7c42047a6a2ac0e7e63002" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. Firefox cannot move an iframe into a new process currently, so the document must load in the current process.</source>
          <target state="translated">具有 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头的文档已加载到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 中&lt;/a&gt;。Firefox当前无法将iframe移动到新进程中，因此文档必须在当前进程中加载​​。</target>
        </trans-unit>
        <trans-unit id="a6f2c4f6f26722715e92610972343c812a59e653" translate="yes" xml:space="preserve">
          <source>The domain name of the forwarded server.</source>
          <target state="translated">转发服务器的域名。</target>
        </trans-unit>
        <trans-unit id="063cfa7dcd340bc61f1b1e374717469ae3ca0edf" translate="yes" xml:space="preserve">
          <source>The domain name of the server (for virtual hosting) or the IP.</source>
          <target state="translated">服务器的域名(用于虚拟主机)或IP。</target>
        </trans-unit>
        <trans-unit id="950978a8462def38d2b11b8a3fe9cb368d430082" translate="yes" xml:space="preserve">
          <source>The ePrivacy Directive in the EU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fdd0cbf82278b018fbbaf65a8801167da2e6c8" translate="yes" xml:space="preserve">
          <source>The effect of certain methods performed on a resource at the origin
   server might cause one or more existing cache entries to become non-
   transparently invalid. That is, although they might continue to be
   &quot;fresh,&quot; they do not accurately reflect what the origin server would
   return for a new request on that resource. 

   There is no way for the HTTP protocol to guarantee that all such
   cache entries are marked invalid. For example, the request that
   caused the change at the origin server might not have gone through
   the proxy where a cache entry is stored. However, several rules help
   reduce the likelihood of erroneous behavior.

   In this section, the phrase &quot;invalidate an entity&quot; means that the
   cache will either remove all instances of that entity from its
   storage, or will mark these as &quot;invalid&quot; and in need of a mandatory
   revalidation before they can be returned in response to a subsequent
   request.

   Some HTTP methods MUST cause a cache to invalidate an entity. This is
   either the entity referred to by the Request-URI, or by the Location
   or Content-Location headers (if present). These methods are:

      - PUT

      - DELETE

      - POST

   In order to prevent denial of service attacks, an invalidation based
   on the URI in a Location or Content-Location header MUST only be
   performed if the host part is the same as in the Request-URI.

   A cache that passes through requests for methods it does not
   understand SHOULD invalidate any entities referred to by the
   Request-URI.</source>
          <target state="translated">在源服务器上对资源执行的某些方法的影响可能会导致一个或多个现有的缓存条目变得非透明无效。也就是说,虽然它们可能继续是 &quot;新鲜的&quot;,但它们并不能准确地反映出源服务器对该资源的新请求所返回的内容。HTTP协议没有办法保证所有这样的缓存条目都被标记为无效。例如,在源服务器上引起变化的请求可能没有经过存储缓存条目的代理。然而,有几条规则有助于降低错误行为的可能性。在本节中,短语 &quot;使一个实体无效 &quot;意味着缓存将从它的存储中删除该实体的所有实例,或者将这些实例标记为 &quot;无效&quot;,并且在响应后续请求之前需要强制重新验证。有些HTTP方法必须使缓存无效化一个实体。这要么是Request-URI,要么是Location或Content-Location头(如果存在的话)所指的实体。这些方法是-PUT-DELETE-POST 为了防止拒绝服务攻击,基于Location或Content-Location头中的URI的无效化必须在主机部分与Request-URI相同的情况下进行。缓存通过请求它不理解的方法时,应该使Request-URI所引用的任何实体无效。</target>
        </trans-unit>
        <trans-unit id="d5ae0833fdb7faa042296f4443d9009502223ddd" translate="yes" xml:space="preserve">
          <source>The encoding algorithm, usually a &lt;a href=&quot;compression&quot;&gt;compression algorithm&lt;/a&gt;, that can be used on the resource sent back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96733518a6ff2858b2648088ac99a8575b177584" translate="yes" xml:space="preserve">
          <source>The entity-body (if any) sent with an HTTP request or response is in
   a format and encoding defined by the entity-header fields.

       entity-body    = *OCTET

   An entity-body is only present in a message when a message-body is
   present, as described in &lt;a href=&quot;#section-4.3&quot;&gt;section 4.3&lt;/a&gt;. The entity-body is obtained
   from the message-body by decoding any Transfer-Encoding that might
   have been applied to ensure safe and proper transfer of the message.</source>
          <target state="translated">与HTTP请求或响应一起发送的实体（如果有的话）采用由实体头字段定义的格式和编码。实体-主体= * OCTET实体-主体仅在消息主体存在时出现在消息中，如&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;所述。通过解码可能已应用来确保安全和正确传输消息的任何Transfer-Encoding，可以从消息主体获取实体主体。</target>
        </trans-unit>
        <trans-unit id="446ffc851c64954297de6b7856c3aaf1d655d3fb" translate="yes" xml:space="preserve">
          <source>The entity-length of a message is the length of the message-body
   before any transfer-codings have been applied. &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; defines
   how the transfer-length of a message-body is determined.</source>
          <target state="translated">消息的实体长度是在应用任何传输编码之前消息主体的长度。&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;定义了如何确定消息正文的传输长度。</target>
        </trans-unit>
        <trans-unit id="430808f49439af4bf0997780d867503fb8ae80aa" translate="yes" xml:space="preserve">
          <source>The equivalent &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response would have included the headers &lt;a href=&quot;../headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/content-location&quot;&gt;&lt;code&gt;Content-Location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">等效的&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 响应将包括标头&lt;a href=&quot;../headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../headers/content-location&quot;&gt; &lt;code&gt;Content-Location&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69c5ab4621c4edd07f710f991794d1e78a2f9d36" translate="yes" xml:space="preserve">
          <source>The exact directive for setting headers depends on your web server. In Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6274c604e308e30d74c2f35a4f5fe3102aafe5" translate="yes" xml:space="preserve">
          <source>The exact resource identified by an Internet request is determined by
   examining both the Request-URI and the Host header field.

   An origin server that does not allow resources to differ by the
   requested host MAY ignore the Host header field value when
   determining the resource identified by an HTTP/1.1 request. (But see
   &lt;a href=&quot;#section-19.6.1.1&quot;&gt;section 19.6.1.1&lt;/a&gt; for other requirements on Host support in HTTP/1.1.)

   An origin server that does differentiate resources based on the host
   requested (sometimes referred to as virtual hosts or vanity host
   names) MUST use the following rules for determining the requested
   resource on an HTTP/1.1 request:

   1. If Request-URI is an absoluteURI, the host is part of the
     Request-URI. Any Host header field value in the request MUST be
     ignored.

   2. If the Request-URI is not an absoluteURI, and the request includes
     a Host header field, the host is determined by the Host header
     field value.

   3. If the host as determined by rule 1 or 2 is not a valid host on
     the server, the response MUST be a 400 (Bad Request) error message.

   Recipients of an HTTP/1.0 request that lacks a Host header field MAY
   attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to determine what
   exact resource is being requested.</source>
          <target state="translated">通过检查Request-URI和Host标头字段来确定Internet请求标识的确切资源。在确定由HTTP / 1.1请求标识的资源时，不允许资源因请求的主机而异的原始服务器可以忽略Host标头字段值。（但请参阅 &lt;a href=&quot;#section-19.6.1.1&quot;&gt;第19.6.1.1节&lt;/a&gt;有关HTTP / 1.1中对主机支持的其他要求。）根据原始主机（有时称为虚拟主机或虚名主机名）来区分资源的原始服务器必须使用以下规则来确定HTTP / 1.1上的请求资源1.1请求：1.如果Request-URI是absoluteURI，则主机是Request-URI的一部分。请求中的任何主机头字段值都必须忽略。 2.如果Request-URI不是absoluteURI，并且请求包含一个Host标头字段，则主机由Host标头字段值确定。 3.如果规则1或2所确定的主机不是服务器上的有效主机，则响应必须为400（错误请求）错误消息。缺少Host标头字段的HTTP / 1.0请求的接收者可以尝试使用启发式（例如，检查URI路径以查找特定主机所独有的内容），以便确定请求的确切资源。</target>
        </trans-unit>
        <trans-unit id="b7709fb173b9a7682e88163b1524346d08926812" translate="yes" xml:space="preserve">
          <source>The example above creates an XML body to send with the &lt;code&gt;POST&lt;/code&gt; request. Also, a non-standard HTTP &lt;code&gt;X-PINGOTHER&lt;/code&gt; request header is set. Such headers are not part of HTTP/1.1, but are generally useful to web applications. Since the request uses a &lt;code&gt;Content-Type&lt;/code&gt; of &lt;code&gt;application/xml&lt;/code&gt;, and since a custom header is set, this request is preflighted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d41666eafa2d743345a256aece9bd1b22af0421" translate="yes" xml:space="preserve">
          <source>The examples at the end of this document are complete. There is no additional syntax needed to save it into a file and use it. (Of course, the JavaScripts must be edited to reflect your site's domain name and/or subnets.)</source>
          <target state="translated">本文档末尾的例子是完整的。没有额外的语法需要将其保存到一个文件中并使用它。当然,必须对JavaScripts进行编辑,以反映您网站的域名和/或子网)。</target>
        </trans-unit>
        <trans-unit id="4044137ba9e4a5b42152e40cc16d223426864ffc" translate="yes" xml:space="preserve">
          <source>The exception to this is if the worker script's origin is a globally unique identifier (for example, if its URL has a scheme of data or blob). In this case, the worker does inherit the content security policy of the document or worker that created it.</source>
          <target state="translated">例外情况是,如果worker脚本的来源是一个全球唯一的标识符(例如,如果它的URL具有数据或blob的方案)。在这种情况下,工作者确实继承了创建它的文档或工作者的内容安全策略。</target>
        </trans-unit>
        <trans-unit id="25060abe4601e57cbdab7b0fcd2e4d780cee3888" translate="yes" xml:space="preserve">
          <source>The expectation given in an Expect request-header field (see &lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) could not be met by this server, or, if the server is a proxy,
   the server has unambiguous evidence that the request could not be met
   by the next-hop server.</source>
          <target state="translated">此服务器无法满足在Expect请求标头字段（请参见&lt;a href=&quot;#section-14.20&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20 &lt;/a&gt;节）中给出的期望，或者，如果该服务器是代理，则该服务器有明确的证据表明下一跳服务器无法满足该请求。 。</target>
        </trans-unit>
        <trans-unit id="e89474435ba5cceae8038928368d478ddd9d1651" translate="yes" xml:space="preserve">
          <source>The expected size of the allocation to be performed, in megabytes.</source>
          <target state="translated">要执行的分配的预期大小,以兆字节为单位。</target>
        </trans-unit>
        <trans-unit id="ed4c70c74d035f0ea716b0ccb4bd9c7c87a82ce4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;headers/accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7187b470d2aaa46b6160031b6302821aeaad40ea" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="translated">实验性&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt;列出了服务器可以使用的配置数据，以选择适当的响应。有效值为：</target>
        </trans-unit>
        <trans-unit id="4c1f313837ffc811f5a2970246c6c36e4cf61462" translate="yes" xml:space="preserve">
          <source>The expiration time is computed as follows:</source>
          <target state="translated">过期时间的计算方法如下:</target>
        </trans-unit>
        <trans-unit id="85e3770a3188fd2db74ea558b54fe9b64ff2f7c6" translate="yes" xml:space="preserve">
          <source>The expiration time of an entity MAY be specified by the origin
   server using the Expires header (see &lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;). Alternatively,
   it MAY be specified using the max-age directive in a response. When
   the max-age cache-control directive is present in a cached response,
   the response is stale if its current age is greater than the age
   value given (in seconds) at the time of a new request for that
   resource. The max-age directive on a response implies that the
   response is cacheable (i.e., &quot;public&quot;) unless some other, more
   restrictive cache directive is also present.

   If a response includes both an Expires header and a max-age
   directive, the max-age directive overrides the Expires header, even
   if the Expires header is more restrictive. This rule allows an origin
   server to provide, for a given response, a longer expiration time to
   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be
   useful if certain HTTP/1.0 caches improperly calculate ages or
   expiration times, perhaps due to desynchronized clocks.

   Many HTTP/1.0 cache implementations will treat an Expires value that
   is less than or equal to the response Date value as being equivalent
   to the Cache-Control response directive &quot;no-cache&quot;. If an HTTP/1.1
   cache receives such a response, and the response does not include a
   Cache-Control header field, it SHOULD consider the response to be
   non-cacheable in order to retain compatibility with HTTP/1.0 servers.

       Note: An origin server might wish to use a relatively new HTTP
       cache control feature, such as the &quot;private&quot; directive, on a
       network including older caches that do not understand that
       feature. The origin server will need to combine the new feature
       with an Expires field whose value is less than or equal to the
       Date value. This will prevent older caches from improperly
       caching the response. 

   s-maxage
       If a response includes an s-maxage directive, then for a shared
       cache (but not for a private cache), the maximum age specified by
       this directive overrides the maximum age specified by either the
       max-age directive or the Expires header. The s-maxage directive
       also implies the semantics of the proxy-revalidate directive (see
       &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt;), i.e., that the shared cache must not use the
       entry after it becomes stale to respond to a subsequent request
       without first revalidating it with the origin server. The s-
       maxage directive is always ignored by a private cache.

   Note that most older caches, not compliant with this specification,
   do not implement any cache-control directives. An origin server
   wishing to use a cache-control directive that restricts, but does not
   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the
   requirement that the max-age directive overrides the Expires header,
   and the fact that pre-HTTP/1.1-compliant caches do not observe the
   max-age directive.

   Other directives allow a user agent to modify the basic expiration
   mechanism. These directives MAY be specified on a request:

   max-age
      Indicates that the client is willing to accept a response whose
      age is no greater than the specified time in seconds. Unless max-
      stale directive is also included, the client is not willing to
      accept a stale response.

   min-fresh
      Indicates that the client is willing to accept a response whose
      freshness lifetime is no less than its current age plus the
      specified time in seconds. That is, the client wants a response
      that will still be fresh for at least the specified number of
      seconds.

   max-stale
      Indicates that the client is willing to accept a response that has
      exceeded its expiration time. If max-stale is assigned a value,
      then the client is willing to accept a response that has exceeded
      its expiration time by no more than the specified number of
      seconds. If no value is assigned to max-stale, then the client is
      willing to accept a stale response of any age.

   If a cache returns a stale response, either because of a max-stale
   directive on a request, or because the cache is configured to
   override the expiration time of a response, the cache MUST attach a
   Warning header to the stale response, using Warning 110 (Response is
   stale). 

   A cache MAY be configured to return stale responses without
   validation, but only if this does not conflict with any &quot;MUST&quot;-level
   requirements concerning cache validation (e.g., a &quot;must-revalidate&quot;
   cache-control directive).

   If both the new request and the cached entry include &quot;max-age&quot;
   directives, then the lesser of the two values is used for determining
   the freshness of the cached entry for that request.</source>
          <target state="translated">实体的到期时间可以由原始服务器使用Expires标头指定（参见&lt;a href=&quot;#section-14.21&quot;&gt;第14.21节）&lt;/a&gt;）。或者，可以在响应中使用max-age指令指定它。当缓存响应中存在max-age cache-control指令时，如果响应的当前年龄大于对该资源的新请求时给定的年龄值（以秒为单位），则该响应为过时的。响应上的max-age指令表示该响应是可缓存的（即&amp;ldquo;公共&amp;rdquo;），除非还存在其他一些限制性更强的缓存指令。如果响应中同时包含Expires标头和max-age指令，则即使Expires标头的限制性更强，max-age指令也会覆盖Expires标头。此规则允许源服务器针对给定的响应，为HTTP / 1.1（或更高版本）缓存提供比HTTP / 1.0缓存更长的到期时间。如果某些HTTP / 1.0缓存可能由于时钟不同步而无法正确计算使用期限或到期时间，则这可能很有用。许多HTTP / 1.0缓存实现会将小于或等于响应日期值的Expires值视为等同于Cache-Control响应指令&amp;ldquo; no-cache&amp;rdquo;。如果HTTP / 1.1缓存接收到这样的响应，并且该响应不包含Cache-Control头字段，则它应将响应视为不可缓存的，以保持与HTTP / 1.0服务器的兼容性。注意：源服务器可能希望在网络上使用相对较新的HTTP缓存控制功能，例如&amp;ldquo; private&amp;rdquo;指令，该网络包括不了解该功能的较早缓存。原始服务器将需要将新功能与值小于或等于日期值的Expires字段组合。这将防止较早的缓存不适当地缓存响应。 s-maxage如果响应中包含s-maxage指令，则对于共享缓存（但不针对私有缓存），此指令指定的最大期限将覆盖max-age指令或Expires标头指定的最大期限。 s-maxage指令还暗含了proxy-revalidate指令的语义（请参阅然后对于共享缓存（而不是专用缓存），此伪指令指定的最大期限将覆盖max-age伪指令或Expires标头指定的最大期限。 s-maxage指令还暗含了proxy-revalidate指令的语义（请参阅然后对于共享缓存（而不是专用缓存），此伪指令指定的最大期限将覆盖max-age伪指令或Expires标头指定的最大期限。 s-maxage指令还暗含了proxy-revalidate指令的语义（请参阅 &lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节&lt;/a&gt;），即，共享缓存在失效之前不能使用该条目来响应后续请求，而不必先通过原始服务器对其进行验证。专用高速缓存始终会忽略s-maxage指令。请注意，大多数不符合此规范的较早的缓存均未实现任何缓存控制指令。希望使用缓存控制指令限制但不阻止HTTP / 1.1兼容的缓存的原始服务器可以利用max-age指令覆盖Expires标头的要求以及HTTP之前的事实兼容/1.1的缓存不遵守max-age指令。其他指令允许用户代理修改基本到期机制。这些指令可以在请求中指定：max-age表示客户端愿意接受其年龄不超过指定时间（以秒为单位）的响应。除非还包括maxstale指令，否则客户端将不愿接受过时的响应。 min-fresh表示客户端愿意接受其新鲜度寿命不小于其当前时间加上指定时间（以秒为单位）的响应。也就是说，客户端希望响应至少在指定的秒数内仍保持新鲜。 max-stale表示客户端愿意接受超过其到期时间的响应。如果为max-stale分配了一个值，那么客户端愿意接受超过其到期时间不超过指定秒数的响应。如果没有为max-stale分配任何值，则客户端愿意接受任何年龄的过时响应。如果由于请求中的max-stale指令，或者由于将高速缓存配置为覆盖响应的过期时间而使高速缓存返回了过期响应，则高速缓存务必使用警告110将警告标头附加到过期响应中（响应已过期）。可以将缓存配置为不进行验证就返回过期响应，但前提是该缓存不与任何有关缓存验证的&amp;ldquo;必须&amp;rdquo;级要求（例如，&amp;ldquo;必须重新验证&amp;rdquo;缓存控制指令）相冲突。如果新请求和缓存条目均包含&amp;ldquo; max-age&amp;rdquo;指令，则使用两个值中的较小者来确定该请求的缓存条目的新鲜度。</target>
        </trans-unit>
        <trans-unit id="a65d812882b0aba90b93b31c9c8f523446f0f382" translate="yes" xml:space="preserve">
          <source>The features include (see &lt;a href=&quot;headers/feature-policy#Directives&quot;&gt;Features list&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3993f15811c93a67d3ec5d0d92f253093020cabe" translate="yes" xml:space="preserve">
          <source>The features include:</source>
          <target state="translated">其特点包括:</target>
        </trans-unit>
        <trans-unit id="c73ddc20bc1d282151f4ec68084bc6164972b4dc" translate="yes" xml:space="preserve">
          <source>The file consists of a function called &lt;code&gt;FindProxyForURL&lt;/code&gt;. The example below will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">该文件包含一个名为 &lt;code&gt;FindProxyForURL&lt;/code&gt; 的函数。以下示例将在设置内部DNS服务器的环境中工作，使其只能解析内部主机名，并且目标是仅对无法解析的主机使用代理：</target>
        </trans-unit>
        <trans-unit id="ce8df497bc37efd316beaa79c7a58e65942dbc0b" translate="yes" xml:space="preserve">
          <source>The file firefox.js passes preference names and values to the pref() function. For example:</source>
          <target state="translated">文件firefox.js将偏好名称和值传递给pref()函数。例如</target>
        </trans-unit>
        <trans-unit id="5b3cb207abfe237d7efa942f6a8fef274b6ca29a" translate="yes" xml:space="preserve">
          <source>The final block is a data block, which contains the optional data.</source>
          <target state="translated">最后一个块是数据块,其中包含了可选的数据。</target>
        </trans-unit>
        <trans-unit id="82d496b5f7760cf0c1c546e8d1a28c4fc534cf8d" translate="yes" xml:space="preserve">
          <source>The final block is an optional data block, which may contain further data mainly used by the POST method.</source>
          <target state="translated">最后一个数据块是一个可选的数据块,它可能包含主要由POST方法使用的进一步数据。</target>
        </trans-unit>
        <trans-unit id="45bd5c32307d77b9998e20d89babbacc1a08c8ee" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;OPTIONS&lt;/code&gt;, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477b8ca70c884ab091243f614c5d70eeeab51fd8" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, DELETE, or OPTIONS, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="translated">请求的最后一部分是它的主体。并非所有请求都具有一个请求：诸如 &lt;code&gt;GET&lt;/code&gt; ， &lt;code&gt;HEAD&lt;/code&gt; ，DELETE或OPTIONS之类的获取资源的请求通常不需要一个。一些请求将数据发送到服务器以对其进行更新：与 &lt;code&gt;POST&lt;/code&gt; 请求（包含HTML表单数据）一样。</target>
        </trans-unit>
        <trans-unit id="a7bd7db1836bd8959bc7e0d7e27321e685761ca2" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="translated">请求的最终接收者应该反映接收到消息，不包括一些字段下面描述的，返回给客户端为具有一个200（OK）响应的消息主体&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;message/http&lt;/code&gt; 。最终收件人是原始服务器或第一个在请求中接收&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt;值的服务器。</target>
        </trans-unit>
        <trans-unit id="fa5fe1af847469a3d3023206916eb30deabd5583" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec16b4ce596bd77bc971178dc4e6a8899896e2cb" translate="yes" xml:space="preserve">
          <source>The first 40 characters of the inline script, event handler, or style that caused the violation.</source>
          <target state="translated">导致违规的内联脚本、事件处理程序或样式的前40个字符。</target>
        </trans-unit>
        <trans-unit id="30b3cc93d61693c25216e29c69eecc3a87dde174" translate="yes" xml:space="preserve">
          <source>The first line contains a request method followed by its parameters:</source>
          <target state="translated">第一行包含一个请求方法,后面是其参数。</target>
        </trans-unit>
        <trans-unit id="0ce913e069990d2088bde8127d92db28b9c6593c" translate="yes" xml:space="preserve">
          <source>The first line of a Response message is the Status-Line, consisting
   of the protocol version followed by a numeric status code and its
   associated textual phrase, with each element separated by SP
   characters. No CR or LF is allowed except in the final CRLF sequence.

       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</source>
          <target state="translated">响应消息的第一行是状态行,由协议版本组成,后面是一个数字状态码及其相关的文字短语,每个元素用SP字符分隔。除最后的CRLF序列外,不允许有CR或LF。状态行=HTTP-Version SP状态码SP理由短语CRLF(CRLF)</target>
        </trans-unit>
        <trans-unit id="34ccf4b003a3910dffb0926766714dc4dd11b6eb" translate="yes" xml:space="preserve">
          <source>The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another
   space, a possibly empty textual phrase describing the status code,
   and ending with CRLF.

     status-line = HTTP-version SP status-code SP reason-phrase CRLF

   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request.  The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt; for information about the semantics of
   status codes, including the classes of status code (indicated by the
   first digit), the status codes defined by this specification,
   considerations for the definition of new status codes, and the IANA
   registry.

     status-code    = 3DIGIT

   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were
   more frequently used with interactive text clients.  A client SHOULD
   ignore the reason-phrase content.

     reason-phrase  = *( HTAB / SP / VCHAR / obs-text )</source>
          <target state="translated">响应消息的第一行是状态行，由协议版本，空格（SP），状态代码，另一个空格，描述状态代码的可能为空的文本短语组成，并以CRLF结尾。 status-line = HTTP版本SP状态代码SP原因短语CRLF状态代码元素是一个3位整数代码，描述服务器尝试理解并满足客户端相应请求的结果。响应消息的其余部分将根据为该状态代码定义的语义进行解释。参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]的第6节&lt;/a&gt;有关状态码语义的信息，包括状态码的类别（由第一位数字表示），由本规范定义的状态码，对新状态码的定义的注意事项以及IANA注册中心。 status-code = 3DIGIT原因短语元素的存在仅是为了提供与数字状态代码关联的文本描述，这主要是出于对较早用于交互式文本客户端的Internet应用程序协议的尊重。客户应忽略原因短语内容。原因短语= *（HTAB / SP / VCHAR / obs-text）</target>
        </trans-unit>
        <trans-unit id="83e62459a880f4c5afe20430a0ef17081dbab746" translate="yes" xml:space="preserve">
          <source>The first line, the &lt;em&gt;status line&lt;/em&gt;, consists of an acknowledgment of the HTTP version used, followed by a status request (and its brief meaning in human-readable text).</source>
          <target state="translated">第一行是&lt;em&gt;状态行&lt;/em&gt;，由对所使用的HTTP版本的确认以及随后的状态请求（及其在人类可读文本中的简短含义）组成。</target>
        </trans-unit>
        <trans-unit id="5ae099fefbfad76e3dc77d1838fdc9c03df6ff4f" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is always &lt;code&gt;form-data&lt;/code&gt;. Additional parameters are case-insensitive and have arguments that use quoted-string syntax after the &lt;code&gt;'='&lt;/code&gt; sign. Multiple parameters are separated by a semi-colon (&lt;code&gt;';'&lt;/code&gt;).</source>
          <target state="translated">HTTP上下文中的第一个参数始终是 &lt;code&gt;form-data&lt;/code&gt; 。其他参数不区分大小写，并且在 &lt;code&gt;'='&lt;/code&gt; 符号后使用引号字符串语法的参数。多个参数之间用分号（ &lt;code&gt;';'&lt;/code&gt; ）分隔。</target>
        </trans-unit>
        <trans-unit id="1fe827f01fdf9c514ffb2a7b42770124ec3e2359" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is either &lt;code&gt;inline&lt;/code&gt; (default value, indicating it can be displayed inside the Web page, or as the Web page) or &lt;code&gt;attachment&lt;/code&gt; (indicating it should be downloaded; most browsers presenting a 'Save as' dialog, prefilled with the value of the &lt;code&gt;filename&lt;/code&gt; parameters if present).</source>
          <target state="translated">HTTP上下文中的第一个参数是 &lt;code&gt;inline&lt;/code&gt; （默认值，表明可以在网页内显示，也可以作为网页显示）或 &lt;code&gt;attachment&lt;/code&gt; （指示应下载；大多数浏览器会先显示&amp;ldquo;另存为&amp;rdquo;对话框）加上 &lt;code&gt;filename&lt;/code&gt; 参数的值（如果存在）。</target>
        </trans-unit>
        <trans-unit id="ce28a16fac0b2bc02f8a3ca48fc7babba03c0403" translate="yes" xml:space="preserve">
          <source>The first time your site is accessed using HTTPS and it returns the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, the browser records this information, so that future attempts to load the site using HTTP will automatically use HTTPS instead.</source>
          <target state="translated">首次使用HTTPS访问您的站点并返回 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; 标头时，浏览器会记录此信息，以便将来使用HTTP加载站点的尝试将自动使用HTTPS。</target>
        </trans-unit>
        <trans-unit id="36a8e92e02612d193d4f4ea4835f02c068455028" translate="yes" xml:space="preserve">
          <source>The first upload of a resource is an edge case of the previous. Like any update of a resource, it is subject to a race condition if two clients try to perform at the similar times. To prevent this, conditional requests can be used: by adding &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; with the special value of &lt;code&gt;'*'&lt;/code&gt;, representing any etag. The request will succeed, only if the resource didn't exist before:</source>
          <target state="translated">资源的首次上传是前一个资源的优势。像任何资源更新一样，如果两个客户端尝试在相同的时间执行资源，则该资源也会受到争用条件的影响。为防止这种情况，可以使用条件请求：通过添加具有特殊值 &lt;code&gt;'*'&lt;/code&gt; 的&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;来表示任何etag。仅当资源之前不存在时，请求才会成功：</target>
        </trans-unit>
        <trans-unit id="cc100946d8979f9ce8df35a1f6c26e450e867343" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91a68110a72942d37f1a34f4d6ec060c7f1376a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;被阻止，无法加载：</target>
        </trans-unit>
        <trans-unit id="d9b73c421a277665ab08a8298b8930b892f83d26" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485ecd6f231e048f16edaf6c17d5ccf5b1cb2429" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;被阻止，无法加载：</target>
        </trans-unit>
        <trans-unit id="63f869c917c180bee24835b4bf30ef56f30bb133" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;被阻止，无法加载：</target>
        </trans-unit>
        <trans-unit id="2bd3ab38162171d160acbfdeffc4df3e7c14c331" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素被阻止并且不会加载：</target>
        </trans-unit>
        <trans-unit id="af33c524092efa46a9bc5e3da17591ca7a2dfed3" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">以下&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;元素被阻止并且不会加载：</target>
        </trans-unit>
        <trans-unit id="613e74e65709c0a5a289fb76a70fe4d72cdf7122" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">以下 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc90632d3761290b941626aad0314e6c02769a1e" translate="yes" xml:space="preserve">
          <source>The following Java code sets CORS response headers. Notice how the code sets the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">以下Java代码设置了CORS响应标头。注意，代码如何将 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 值设置为与&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;请求标头相同的值。</target>
        </trans-unit>
        <trans-unit id="94255118119d25126914c95e1d87df4cff5fadb0" translate="yes" xml:space="preserve">
          <source>The following are all valid JavaScript MIME types according to the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt;.</source>
          <target state="translated">以下是根据&lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME嗅探标准的&lt;/a&gt;所有有效JavaScript MIME类型。</target>
        </trans-unit>
        <trans-unit id="81369c9bb8b849666e492d12305470dc3ab76aac" translate="yes" xml:space="preserve">
          <source>The following command will extract the Base64 encoded information for a website.</source>
          <target state="translated">以下命令将提取一个网站的Base64编码信息。</target>
        </trans-unit>
        <trans-unit id="386280384a9e1e846fc762abee1b45fa8528a42c" translate="yes" xml:space="preserve">
          <source>The following commands will help you extract the Base64 encoded information from a key file, a certificate signing request, or a certificate.</source>
          <target state="translated">以下命令将帮助你从密钥文件、证书签名请求或证书中提取Base64编码信息。</target>
        </trans-unit>
        <trans-unit id="509ad4a6b5b143b75559c314a8f0880abef072e8" translate="yes" xml:space="preserve">
          <source>The following connections are blocked and won't load:</source>
          <target state="translated">以下连接被阻止,无法加载。</target>
        </trans-unit>
        <trans-unit id="ce04653c2a877eee1709cad576d94e84ea8ac4bc" translate="yes" xml:space="preserve">
          <source>The following cookie will be rejected if set by a server hosted on &lt;code&gt;example.com&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f830b6e4479681c906a8958ca927a242872bc6bc" translate="yes" xml:space="preserve">
          <source>The following cookie will be rejected if set by a server hosted on &lt;code&gt;originalcompany.com&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41623b548495875f7a172266a4ccbfc78a26525c" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF
   (line feed), OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible US-ASCII character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     RWS           = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     comment       = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     partial-URI   = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt; 

     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），HTAB（水平标签），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符）。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：BWS = &amp;lt;BWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; RWS = &amp;lt;RWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]， 3.2.3节&lt;/a&gt; &amp;gt; URI引用= &amp;lt;URI引用，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt;&amp;gt; absolute-URI = &amp;lt;绝对URI，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt; &amp;gt; comment = &amp;lt;注释，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt; field-name = &amp;lt;注释，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]，第3.2节&lt;/a&gt; &amp;gt; 部分- URI = &amp;lt;部分URI，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;引用的字符串，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt; token = &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c0942541cf8ef1d402170eff33c293ebc3cc0b4" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   Note that all rules derived from token are to be compared
   case-insensitively, like range-unit and acceptable-ranges.

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS        = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     token      = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date  = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;
     entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符） ）。请注意，所有源自令牌的规则都应不区分大小写地进行比较，例如range-unit和acceptable-ranges。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt;令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;以下规则在其他部分中定义：HTTP -date = &amp;lt;HTTP日期，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]，第7.1.1.1节&lt;/a&gt; &amp;gt;实体标签= &amp;lt;实体标签，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]，第2.3节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb819c2dfc07123960d680297955265860aae754" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符） ）。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：BWS = &amp;lt;BWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="af8790fbb4ed65c1be1cf1a4b4f340c4491c4f9d" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     pseudonym     = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符） ）。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt;字段名= &amp;lt;字段名，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]，第3.2节&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string ，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;端口= &amp;lt;端口，看到&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]第2.7节&lt;/a&gt; &amp;gt;假名= &amp;lt;假名，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]第5.7.1节&lt;/a&gt; &amp;gt; uri-host = &amp;lt;uri-host，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]第2.7节&lt;/a&gt; &amp;gt;以下规则在其他部分中定义：HTTP- date = &amp;lt;HTTP日期，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]，第7.1.1.1节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="bde3f83ba4fdea6e1247cb746890cdb2c25a10cd" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     obs-text      = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;定义的下列核心规则供参考 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9） ，DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的US-ASCII字符） ）。以下规则在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 中定义：OWS = &amp;lt;OWS，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; obs-text = &amp;lt;obs-text，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;以下规则在其他部分：HTTP日期= &amp;lt;HTTP日期，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]，第7.1.1.1节&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="8084bb34a7c23d1e9e812c435cfc66928e96c80b" translate="yes" xml:space="preserve">
          <source>The following example shows the same copy operation being performed,
   but with the Overwrite header set to &quot;F.&quot; A response of 412
   (Precondition Failed) is returned because the destination URL is
   already mapped to a resource.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html
     Overwrite: F 

   &amp;gt;&amp;gt;Response

     HTTP/1.1 412 Precondition Failed</source>
          <target state="translated">下面的示例显示了相同的复制操作，但是Overwrite标头设置为&amp;ldquo; F&amp;rdquo;。由于目标URL已映射到资源，因此返回412（前提条件失败）响应。&amp;gt;&amp;gt;请求COPY /~fielding/index.html HTTP / 1.1主机：www.example.com目的地：http://www.example.com/users/f/fielding/index.html覆盖：F &amp;gt;&amp;gt;响应HTTP / 1.1 412前提条件失败</target>
        </trans-unit>
        <trans-unit id="8d3395be0d0b51b8ffa7605b7ec7844c4e4a39c7" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to &lt;code&gt;foo.example&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acf3453f8031411e0b71e19213cb90990e8cb3a" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to foo.example.</source>
          <target state="translated">下面的例子指定了证书透明度的执行时间为24小时,并向foo.example报告违规行为。</target>
        </trans-unit>
        <trans-unit id="94b32d3de424f684aa74d5609ddab84fb75dd925" translate="yes" xml:space="preserve">
          <source>The following font resource loading is blocked and won't load:</source>
          <target state="translated">以下字体资源加载受阻,无法加载。</target>
        </trans-unit>
        <trans-unit id="354531c678665d3125c2ef3c1112692d5b4fe889" translate="yes" xml:space="preserve">
          <source>The following headers are involved in the WebSocket upgrade process. Other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, the rest are generally optional or handled for you by the browser and server when they're talking to each other.</source>
          <target state="translated">WebSocket升级过程涉及以下头。除了&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头外，其余的通常是可选的，或者由浏览器和服务器在彼此通信时为您处理。</target>
        </trans-unit>
        <trans-unit id="bb8db65f4711517dd753e17a8cd07fb37a9810cb" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted.</source>
          <target state="translated">下面是一个将被预亮的请求的例子。</target>
        </trans-unit>
        <trans-unit id="f2caa1f526d805ff5feea71e36486901a1b33c7b" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6166015c4ad889984ba227b210f2740bda4740b4" translate="yes" xml:space="preserve">
          <source>The following line with your relevant key information (pin-sha256=&quot;...&quot; fields) will enable HPKP on lighttpd.</source>
          <target state="translated">以下一行加上您的相关密钥信息(pin-sha256=&quot;...&quot;字段)将启用lighttpd上的HPKP。</target>
        </trans-unit>
        <trans-unit id="2ae960e358cb5178ea4e99046d9b426fbe630cc9" translate="yes" xml:space="preserve">
          <source>The following list summarizes HTTP headers by their usage category. For an alphabetical list, see the navigation on the left side.</source>
          <target state="translated">下面的列表按照使用类别总结了HTTP头文件。按字母顺序排列的列表,请参见左侧的导航。</target>
        </trans-unit>
        <trans-unit id="c48b8f944a040a3a451f5a0b5b3b5d6f5f32bae2" translate="yes" xml:space="preserve">
          <source>The following object keys can be specified in the NEL header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0132826bcd8328191613e887dc58c7bad941d249" translate="yes" xml:space="preserve">
          <source>The following parameters are defined:

   SETTINGS_HEADER_TABLE_SIZE (0x1):  Allows the sender to inform the
      remote endpoint of the maximum size of the header compression
      table used to decode header blocks, in octets.  The encoder can
      select any size equal to or less than this value by using
      signaling specific to the header compression format inside a
      header block (see [&lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt;]).  The initial value is 4,096
      octets.

   SETTINGS_ENABLE_PUSH (0x2):  This setting can be used to disable
      server push (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;).  An endpoint MUST NOT send a
      PUSH_PROMISE frame if it receives this parameter set to a value of
      0.  An endpoint that has both set this parameter to 0 and had it
      acknowledged MUST treat the receipt of a PUSH_PROMISE frame as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

      The initial value is 1, which indicates that server push is
      permitted.  Any value other than 0 or 1 MUST be treated as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   SETTINGS_MAX_CONCURRENT_STREAMS (0x3):  Indicates the maximum number
      of concurrent streams that the sender will allow.  This limit is
      directional: it applies to the number of streams that the sender
      permits the receiver to create.  Initially, there is no limit to
      this value.  It is recommended that this value be no smaller than
      100, so as to not unnecessarily limit parallelism.

      A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be
      treated as special by endpoints.  A zero value does prevent the
      creation of new streams; however, this can also happen for any 

      limit that is exhausted with active streams.  Servers SHOULD only
      set a zero value for short durations; if a server does not wish to
      accept requests, closing the connection is more appropriate.

   SETTINGS_INITIAL_WINDOW_SIZE (0x4):  Indicates the sender's initial
      window size (in octets) for stream-level flow control.  The
      initial value is 2^16-1 (65,535) octets.

      This setting affects the window size of all streams (see
      &lt;a href=&quot;#section-6.9.2&quot;&gt;Section 6.9.2&lt;/a&gt;).

      Values above the maximum flow-control window size of 2^31-1 MUST
      be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      FLOW_CONTROL_ERROR.

   SETTINGS_MAX_FRAME_SIZE (0x5):  Indicates the size of the largest
      frame payload that the sender is willing to receive, in octets.

      The initial value is 2^14 (16,384) octets.  The value advertised
      by an endpoint MUST be between this initial value and the maximum
      allowed frame size (2^24-1 or 16,777,215 octets), inclusive.
      Values outside this range MUST be treated as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   SETTINGS_MAX_HEADER_LIST_SIZE (0x6):  This advisory setting informs a
      peer of the maximum size of header list that the sender is
      prepared to accept, in octets.  The value is based on the
      uncompressed size of header fields, including the length of the
      name and value in octets plus an overhead of 32 octets for each
      header field.

      For any given request, a lower limit than what is advertised MAY
      be enforced.  The initial value of this setting is unlimited.

   An endpoint that receives a SETTINGS frame with any unknown or
   unsupported identifier MUST ignore that setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd371c0bd518c2c5a7f7101657c16841e787471" translate="yes" xml:space="preserve">
          <source>The following pseudo-header fields are defined for HTTP/2 requests:

   o  The &quot;:method&quot; pseudo-header field includes the HTTP method
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4&quot;&gt;[RFC7231], Section&amp;nbsp;4&lt;/a&gt;).

   o  The &quot;:scheme&quot; pseudo-header field includes the scheme portion of
      the target URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;).

      &quot;:scheme&quot; is not restricted to &quot;http&quot; and &quot;https&quot; schemed URIs.  A
      proxy or gateway can translate requests for non-HTTP schemes,
      enabling the use of HTTP to interact with non-HTTP services.

   o  The &quot;:authority&quot; pseudo-header field includes the authority
      portion of the target URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;).  The authority
      MUST NOT include the deprecated &quot;userinfo&quot; subcomponent for &quot;http&quot;
      or &quot;https&quot; schemed URIs.

      To ensure that the HTTP/1.1 request line can be reproduced
      accurately, this pseudo-header field MUST be omitted when
      translating from an HTTP/1.1 request that has a request target in
      origin or asterisk form (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230], Section&amp;nbsp;5.3&lt;/a&gt;).  Clients
      that generate HTTP/2 requests directly SHOULD use the &quot;:authority&quot;
      pseudo-header field instead of the Host header field.  An
      intermediary that converts an HTTP/2 request to HTTP/1.1 MUST
      create a Host header field if one is not present in a request by
      copying the value of the &quot;:authority&quot; pseudo-header field.

   o  The &quot;:path&quot; pseudo-header field includes the path and query parts
      of the target URI (the &quot;path-absolute&quot; production and optionally a
      '?' character followed by the &quot;query&quot; production (see Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
      and 3.4 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]).  A request in asterisk form includes the
      value '*' for the &quot;:path&quot; pseudo-header field.

      This pseudo-header field MUST NOT be empty for &quot;http&quot; or &quot;https&quot;
      URIs; &quot;http&quot; or &quot;https&quot; URIs that do not contain a path component
      MUST include a value of '/'.  The exception to this rule is an
      OPTIONS request for an &quot;http&quot; or &quot;https&quot; URI that does not include
      a path component; these MUST include a &quot;:path&quot; pseudo-header field
      with a value of '*' (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3.4&quot;&gt;[RFC7230], Section&amp;nbsp;5.3.4&lt;/a&gt;). 

   All HTTP/2 requests MUST include exactly one valid value for the
   &quot;:method&quot;, &quot;:scheme&quot;, and &quot;:path&quot; pseudo-header fields, unless it is
   a CONNECT request (&lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;).  An HTTP request that omits
   mandatory pseudo-header fields is malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).

   HTTP/2 does not define a way to carry the version identifier that is
   included in the HTTP/1.1 request line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb997113b54cfb7ed6ae28493a5cfaf71d6f764b" translate="yes" xml:space="preserve">
          <source>The following request body for a PROPFIND method is illegal.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
       &amp;lt;D:propname/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The definition of the propfind element only allows for the allprop or
   the propname element, not both.  Thus, the above is an error and must
   be responded to with a 400 (Bad Request).

   Imagine, however, that a server wanted to be &quot;kind&quot; and decided to
   pick the allprop element as the true element and respond to it.  A
   client running over a bandwidth limited line who intended to execute
   a propname would be in for a big surprise if the server treated the
   command as an allprop.

   Additionally, if a server were lenient and decided to reply to this
   request, the results would vary randomly from server to server, with
   some servers executing the allprop directive, and others executing
   the propname directive.  This reduces interoperability rather than
   increasing it.</source>
          <target state="translated">以下对PROPFIND方法的请求正文是非法的。 &amp;lt;？xml version =&amp;ldquo; 1.0&amp;rdquo; encoding =&amp;ldquo; utf-8&amp;rdquo;吗？&amp;gt; &amp;lt;D：propfind xmlns：D =&amp;ldquo; DAV：&amp;rdquo;&amp;gt; &amp;lt;D：allprop /&amp;gt; &amp;lt;D：propname /&amp;gt; &amp;lt;/ D：propfind&amp;gt;定义该propfind元素仅允许allprop或propname元素，而不能同时允许两者。因此，以上内容是错误，必须使用400（错误请求）进行响应。但是，想象一下，一个服务器想成为&amp;ldquo;同类&amp;rdquo;服务器，并决定选择allprop元素作为真正的元素并做出响应。如果服务器将命令视为allprop，则在带宽受限的行上运行并打算执行propname的客户端将大吃一惊。此外，如果服务器宽容并决定回复此请求，结果会随服务器的不同而随机变化，其中一些服务器执行allprop指令，而其他服务器执行propname指令。这会降低互操作性，而不是增加互操作性。</target>
        </trans-unit>
        <trans-unit id="afe5b5f9e1c6d81603d280407ff45a5bd4095d77" translate="yes" xml:space="preserve">
          <source>The following request header fields are sent by a user agent to
   engage in proactive negotiation of the response content, as defined
   in &lt;a href=&quot;#section-3.4.1&quot;&gt;Section 3.4.1&lt;/a&gt;.  The preferences sent in these fields apply to any
   content in the response, including representations of the target
   resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear
   within the protocol.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | Accept            | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt; |
   | Accept-Charset    | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt; |
   | Accept-Encoding   | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   | Accept-Language   | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">以下请求标头字段由用户代理发送，以参与对响应内容的主动协商，如&lt;a href=&quot;#section-3.4.1&quot;&gt;第3.4.1节中&lt;/a&gt;所定义。在这些字段中发送的首选项适用于响应中的任何内容，包括目标资源的表示，错误或处理状态的表示，甚至可能会出现在协议中的其他文本字符串。 + ------------------- + --------------- + |标头字段名称|定义于... | + ------------------- + --------------- + |接受| &lt;a href=&quot;#section-5.3.2&quot;&gt;第5.3.2节&lt;/a&gt; | |接受字符集| &lt;a href=&quot;#section-5.3.3&quot;&gt;第5.3.3节&lt;/a&gt; | |接受编码| &lt;a href=&quot;#section-5.3.4&quot;&gt;第5.3.4节&lt;/a&gt; | |接受语言| &lt;a href=&quot;#section-5.3.5&quot;&gt;第5.3.5节&lt;/a&gt;| + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="b87d45a3e8d029bf68f7eb8d73ed362bd6af38eb" translate="yes" xml:space="preserve">
          <source>The following request header fields provide additional information
   about the request context, including information about the user, user
   agent, and resource behind the request.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | From              | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | Referer           | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | User-Agent        | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">以下请求标头字段提供有关请求上下文的其他信息，包括有关用户，用户代理和请求背后资源的信息。+ ------------------- + --------------- + | 标头字段名称| 定义于... | + ------------------- + --------------- + | 来自| &lt;a href=&quot;#section-5.5.1&quot;&gt;第5.5.1节&lt;/a&gt; | | 推荐人| &lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt; | | 用户代理| &lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节&lt;/a&gt; | + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="0c838a2a126c25c04d28baea5afb318e21afbddd" translate="yes" xml:space="preserve">
          <source>The following rules are used throughout this specification to
   describe basic parsing constructs. The US-ASCII coded character set
   is defined by ANSI X3.4-1986 [&lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]. 

       OCTET          = &amp;lt;any 8-bit sequence of data&amp;gt;
       CHAR           = &amp;lt;any US-ASCII character (octets 0 - 127)&amp;gt;
       UPALPHA        = &amp;lt;any US-ASCII uppercase letter &quot;A&quot;..&quot;Z&quot;&amp;gt;
       LOALPHA        = &amp;lt;any US-ASCII lowercase letter &quot;a&quot;..&quot;z&quot;&amp;gt;
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = &amp;lt;any US-ASCII digit &quot;0&quot;..&quot;9&quot;&amp;gt;
       CTL            = &amp;lt;any US-ASCII control character
                        (octets 0 - 31) and DEL (127)&amp;gt;
       CR             = &amp;lt;US-ASCII CR, carriage return (13)&amp;gt;
       LF             = &amp;lt;US-ASCII LF, linefeed (10)&amp;gt;
       SP             = &amp;lt;US-ASCII SP, space (32)&amp;gt;
       HT             = &amp;lt;US-ASCII HT, horizontal-tab (9)&amp;gt;
       &amp;lt;&quot;&amp;gt;            = &amp;lt;US-ASCII double-quote mark (34)&amp;gt;

   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all
   protocol elements except the entity-body (see appendix 19.3 for
   tolerant applications). The end-of-line marker within an entity-body
   is defined by its associated media type, as described in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;.

       CRLF           = CR LF

   HTTP/1.1 header field values can be folded onto multiple lines if the
   continuation line begins with a space or horizontal tab. All linear
   white space, including folding, has the same semantics as SP. A
   recipient MAY replace any linear white space with a single SP before
   interpreting the field value or forwarding the message downstream.

       LWS            = [CRLF] 1*( SP | HT )

   The TEXT rule is only used for descriptive field contents and values
   that are not intended to be interpreted by the message parser. Words
   of *TEXT MAY contain characters from character sets other than ISO-
   8859-1 [&lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt;] only when encoded according to the rules of &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

       TEXT           = &amp;lt;any OCTET except CTLs,
                        but including LWS&amp;gt;

   A CRLF is allowed in the definition of TEXT only as part of a header
   field continuation. It is expected that the folding LWS will be
   replaced with a single SP before interpretation of the TEXT value.

   Hexadecimal numeric characters are used in several protocol elements.

       HEX            = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
                      | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | DIGIT 

   Many HTTP/1.1 header field values consist of words separated by LWS
   or special characters. These special characters MUST be in a quoted
   string to be used within a parameter value (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;).

       token          = 1*&amp;lt;any CHAR except CTLs or separators&amp;gt;
       separators     = &quot;(&quot; | &quot;)&quot; | &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;@&quot;
                      | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &amp;lt;&quot;&amp;gt;
                      | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                      | &quot;{&quot; | &quot;}&quot; | SP | HT

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.
   In all other fields, parentheses are considered part of the field
   value.

       comment        = &quot;(&quot; *( ctext | quoted-pair | comment ) &quot;)&quot;
       ctext          = &amp;lt;any TEXT excluding &quot;(&quot; and &quot;)&quot;&amp;gt;

   A string of text is parsed as a single word if it is quoted using
   double-quote marks.

       quoted-string  = ( &amp;lt;&quot;&amp;gt; *(qdtext | quoted-pair ) &amp;lt;&quot;&amp;gt; )
       qdtext         = &amp;lt;any TEXT except &amp;lt;&quot;&amp;gt;&amp;gt;

   The backslash character (&quot;\&quot;) MAY be used as a single-character
   quoting mechanism only within quoted-string and comment constructs.

       quoted-pair    = &quot;\&quot; CHAR</source>
          <target state="translated">在整个说明书中，使用以下规则来描述基本的解析结构。US-ASCII编码字符集由ANSI X3.4-1986 [&lt;a href=&quot;#ref-21&quot;&gt; 21&lt;/a&gt;]。 OCTET = &amp;lt;任何8位数据序列&amp;gt; CHAR = &amp;lt;任何US-ASCII字符（八位字节0-127）&amp;gt; UPALPHA = &amp;lt;任何US-ASCII大写字母&amp;ldquo; A&amp;rdquo; ..&amp;ldquo; Z&amp;rdquo;&amp;gt; LOALPHA = &amp;lt;任何US-ASCII ASCII小写字母&amp;ldquo; a&amp;rdquo; ..&amp;ldquo; z&amp;rdquo;&amp;gt; ALPHA = UPALPHA | LOALPHA DIGIT = &amp;lt;任何US-ASCII数字&amp;ldquo; 0&amp;rdquo; ..&amp;ldquo; 9&amp;rdquo;&amp;gt; CTL = &amp;lt;任何US-ASCII控制字符（八位字节0-31）和DEL（127）&amp;gt; CR = &amp;lt;US-ASCII CR，回车（ 13）&amp;gt; LF = &amp;lt;US-ASCII LF，换行（10）&amp;gt; SP = &amp;lt;US-ASCII SP，空格（32）&amp;gt; HT = &amp;lt;US-ASCII HT，水平制表符（9）&amp;gt; &amp;lt;&amp;ldquo;&amp;gt; = &amp;lt;US-ASCII双引号（34）&amp;gt; HTTP / 1.1将序列CR LF定义为除实体主体之外的所有协议元素的行尾标记（有关允许的应用，请参见附录19.3）。实体中的行尾标记由其关联的媒体类型定义，如&lt;a href=&quot;#section-3.7&quot;&gt;第3.7节&lt;/a&gt;。如果继续行以空格或水平制表符开头，则CRLF = CR LF HTTP / 1.1标头字段值可以折叠为多行。所有线性空白（包括折叠）都具有与SP相同的语义。接收者可以在解释字段值或向下游转发消息之前用单个SP替换任何线性空格。 LWS = [CRLF] 1 *（SP | HT）TEXT规则仅用于描述性字段内容和消息解析器不打算解释的值。 * TEXT单词仅当按照&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt; ]的规则编码时，可能包含ISO-8859-1 [ &lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt; ] 以外的字符集中的字符]。 TEXT = &amp;lt;除CTL之外但包括LWS的任何OCTET&amp;gt; TEXT的定义中仅允许CRLF作为标头字段继续的一部分。预期在解释TEXT值之前，将折叠LWS替换为单个SP。十六进制数字字符用于多个协议元素。十六进制=&amp;ldquo; A&amp;rdquo; | &amp;ldquo; B&amp;rdquo; | &amp;ldquo; C&amp;rdquo; | &amp;ldquo; D&amp;rdquo; | &amp;ldquo; E&amp;rdquo; | &amp;ldquo; F&amp;rdquo; | &amp;ldquo; a&amp;rdquo; | &amp;ldquo; b&amp;rdquo; | &amp;ldquo; c&amp;rdquo; | &amp;ldquo; d&amp;rdquo; | &amp;ldquo; e&amp;rdquo; | &amp;ldquo; f&amp;rdquo; | DIGIT许多HTTP / 1.1标头字段值由用LWS或特殊字符分隔的单词组成。这些特殊字符必须在带引号的字符串中，以便在参数值中使用（如本&lt;a href=&quot;#section-3.6&quot;&gt;节中所定义）&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;这些特殊字符必须在带引号的字符串中，以在参数值中使用（如3.6&lt;/a&gt;）。令牌= 1 * &amp;lt;除CTL或分隔符外的任何CHAR&amp;gt;分隔符=&amp;ldquo;（&amp;rdquo; |&amp;ldquo;）&amp;rdquo; | &amp;ldquo; &amp;lt;&amp;rdquo; | &amp;ldquo;&amp;gt;&amp;rdquo; | &amp;ldquo; @&amp;rdquo; | &amp;ldquo;，&amp;rdquo; | &amp;ldquo;;&amp;rdquo; | &amp;ldquo;：&amp;rdquo; | &amp;ldquo; \&amp;rdquo; | &amp;lt;&amp;ldquo;&amp;gt; |&amp;rdquo; /&amp;ldquo; |&amp;rdquo; [&amp;ldquo; |&amp;rdquo;]&amp;ldquo; |&amp;rdquo;？&amp;ldquo; |&amp;rdquo; =&amp;ldquo; |&amp;rdquo; {&amp;ldquo; |&amp;rdquo;}&amp;ldquo; | SP | HT通过将注释文本括在中间，可以将注释包含在某些HTTP标头字段中圆括号。仅在包含&amp;ldquo;注释&amp;rdquo;作为其字段值定义的一部分的字段中才允许使用注释。在所有其他字段中，圆括号被视为字段值的一部分。comment =&amp;ldquo;（&amp;rdquo; *（ctext | quoted-pair | comment）&amp;ldquo; ）&amp;rdquo;ctext = &amp;lt;不含&amp;ldquo;（&amp;rdquo;和&amp;ldquo;）&amp;rdquo;的任何文本&amp;ldquo;&amp;gt;如果使用双引号将文本字符串引用，则将其解析为单个单词。 quoted-string =（&amp;lt;&amp;ldquo;&amp;gt; *（qdtext | quoted-pair）&amp;lt;&amp;rdquo;&amp;gt;）qdtext = &amp;lt;除&amp;lt;&amp;ldquo; &amp;gt;&amp;gt;之外的任何文本反斜杠字符（&amp;rdquo; \&amp;ldquo;）只能在带引号的字符串和注释构造。quoted-pair =&amp;ldquo; \&amp;rdquo; CHAR）只能在带引号的字符串和注释构造中用作单字符引用机制。 quoted-pair =&amp;ldquo; \&amp;rdquo; CHAR）只能在带引号的字符串和注释构造中用作单字符引用机制。 quoted-pair =&amp;ldquo; \&amp;rdquo; CHAR</target>
        </trans-unit>
        <trans-unit id="94fbcc64e65bdd0aa51395bd7a796209855490ba" translate="yes" xml:space="preserve">
          <source>The following sections describe the LOCK method, which is used to
   take out a lock of any access type and to refresh an existing lock.
   These sections on the LOCK method describe only those semantics that
   are specific to the LOCK method and are independent of the access
   type of the lock being requested.

   Any resource that supports the LOCK method MUST, at minimum, support
   the XML request and response formats defined herein.

   This method is neither idempotent nor safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">以下各节介绍LOCK方法，该方法用于取出任何访问类型的锁并刷新现有的锁。LOCK方法的这些部分仅描述LOCK方法特有的语义，并且与所请求锁的访问类型无关。任何支持LOCK方法的资源都必须至少支持本文定义的XML请求和响应格式。此方法既不是幂等也不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="abeecd90959a6815a68add2040eb84d9caaab598" translate="yes" xml:space="preserve">
          <source>The following status codes are added to those defined in HTTP/1.1
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].</source>
          <target state="translated">将以下状态代码添加到HTTP / 1.1 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中定义的状态代码中。</target>
        </trans-unit>
        <trans-unit id="9b6537480c704b017f88ab825b88e92592b9fb1e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the way major browser vendors indicate that their browsers are running on a mobile device:</source>
          <target state="translated">下表总结了主要浏览器厂商表示其浏览器在移动设备上运行的方式。</target>
        </trans-unit>
        <trans-unit id="dd1549ac99aae5d800f9a7d9d93287604b603639" translate="yes" xml:space="preserve">
          <source>The following warning might appear in your console:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d447214f0a07951f17fa8b161dc87650490e95" translate="yes" xml:space="preserve">
          <source>The format for &lt;code&gt;data&lt;/code&gt; URLs is very simple, but it's easy to forget to put a comma before the &quot;data&quot; segment, or to incorrectly encode the data into base64 format.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; URL 的格式非常简单，但是很容易忘记在&amp;ldquo;数据&amp;rdquo;段前加上逗号，或者将数据错误地编码为base64格式。</target>
        </trans-unit>
        <trans-unit id="d7ba8c7d265a4018beb38838d1f5b22bd2735b93" translate="yes" xml:space="preserve">
          <source>The format problem might be due to the request's indicated &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, or as a result of inspecting the data directly.</source>
          <target state="translated">格式问题可能是由于请求所指示的&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;，或者是直接检查数据的结果。</target>
        </trans-unit>
        <trans-unit id="f6417d40b5bbb94e0ab0361d59b5efbe6a9c03d8" translate="yes" xml:space="preserve">
          <source>The forward slash (&lt;code&gt;/&lt;/code&gt;) character is interpreted as a directory separator, and subdirectories will be matched as well: for &lt;code&gt;Path=/docs&lt;/code&gt;, &lt;code&gt;/docs&lt;/code&gt;, &lt;code&gt;/docs/Web/&lt;/code&gt;, and &lt;code&gt;/docs/Web/HTTP&lt;/code&gt; will all match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd102c31666a18bf73247dbe968b9437a20ca82e" translate="yes" xml:space="preserve">
          <source>The forwarded protocol (http or https).</source>
          <target state="translated">转发协议(http或https)。</target>
        </trans-unit>
        <trans-unit id="5ad0214c4fd4e5e15f5b8411cc3e3ac722291550" translate="yes" xml:space="preserve">
          <source>The framework for HTTP Authentication is now defined by this
   document, rather than &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.

   The &quot;realm&quot; parameter is no longer always required on challenges;
   consequently, the ABNF allows challenges without any auth parameters.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   The &quot;token68&quot; alternative to auth-param lists has been added for
   consistency with legacy authentication schemes such as &quot;Basic&quot;.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   This specification introduces the Authentication Scheme Registry,
   along with considerations for new authentication schemes.
   (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)</source>
          <target state="translated">现在，此文档而不是&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;定义了HTTP身份验证的框架。挑战不再总是需要&amp;ldquo; realm&amp;rdquo;参数；因此，ABNF允许没有任何身份验证参数的挑战。 （&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;）已添加auth-param列表的&amp;ldquo; token68&amp;rdquo;替代项，以与诸如&amp;ldquo; Basic&amp;rdquo;之类的传统身份验证方案保持一致。 （&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;）本规范介绍了身份验证方案注册表，以及对新身份验证方案的注意事项。 （&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4d91b5b813304e8a213249cb1c603b64a74abb68" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-Control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81a90a6f49982e97eba3c1cef4effa451cb6b9f" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime. Finally, if neither header is present, look for a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; header. If this header is present, then the cache's freshness lifetime is equal to the value of the &lt;code&gt;Date&lt;/code&gt; header minus the value of the &lt;code&gt;Last-modified&lt;/code&gt; header divided by 10.</source>
          <target state="translated">新鲜度寿命是基于多个标头计算的。如果指定了&amp;ldquo; &lt;code&gt;Cache-control: max-age=N&lt;/code&gt; &amp;rdquo;标头，则新鲜度生存期等于N。如果不存在此标头（通常是这种情况），则检查是否存在&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;标头。如果存在 &lt;code&gt;Expires&lt;/code&gt; 标头，则其值减去&lt;a href=&quot;headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;标头的值将确定保鲜期。最后，如果两个标题都不存在，请查找&amp;ldquo; &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &amp;rdquo;&lt;/a&gt;标题。如果存在此标头，则高速缓存的新鲜度生存期等于 &lt;code&gt;Date&lt;/code&gt; 标头的值减去 &lt;code&gt;Last-modified&lt;/code&gt; 标头的值除以10。</target>
        </trans-unit>
        <trans-unit id="512b0319b59cba71ca1e2c65af451cb82702e739" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework</source>
          <target state="translated">一般的HTTP认证框架</target>
        </trans-unit>
        <trans-unit id="2a68383800c3c6e98cc63558c863f3f6c90c1d56" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework is used by several authentication schemes. Schemes can differ in security strength and in their availability in client or server software.</source>
          <target state="translated">一般的HTTP认证框架被几种认证方案所使用。这些方案在安全强度和在客户端或服务器软件中的可用性方面可以有所不同。</target>
        </trans-unit>
        <trans-unit id="047e5f84cba0657a76fe5fac248fc74bc7cb3a90" translate="yes" xml:space="preserve">
          <source>The general principle is that there should be an intuitive or non-breaking way for web developers to detect or handle the case when the feature is disabled. Newly introduced features may have an explicit API to signal the state. Existing features that later integrate with Feature Policy will typically use existing mechanisms. Some approaches include:</source>
          <target state="translated">总的原则是,当功能被禁用时,应该有一种直观的或非破坏性的方式让Web开发人员检测或处理该功能的情况。新引入的功能可能会有一个明确的API来发出状态信号。现有的功能如果以后与功能策略集成,通常会使用现有的机制。一些方法包括:</target>
        </trans-unit>
        <trans-unit id="4082c3c3add497840e14f2e91b541fe68c6e3568" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; attribute is used on HTML elements to indicate the language of an entire &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; document or parts of it.</source>
          <target state="translated">全局 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; 属性用于HTML元素，以指示整个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt;文档或部分文档的语言。</target>
        </trans-unit>
        <trans-unit id="b96cd855a9766df4b3721ceeb897076805d066a4" translate="yes" xml:space="preserve">
          <source>The header contains identifiers for one or more digest algorithms that the sender wishes the responder to use to create the digest. The sender may use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality values&lt;/a&gt; to indicate its preference ordering among the choices it offers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f2be6c87684acab7e795f4366c55ff9f31e0e7" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between :// and the first : or / after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="translated">从URL中提取的主机名。这只是为了方便起见,它与://和后面的第一个:或/之间的字符串相同。端口号不包含在这个参数中。必要时可以从URL中提取。</target>
        </trans-unit>
        <trans-unit id="5f24db479cf2b72fa937bcb464d99834bc0f6796" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between &lt;code&gt;://&lt;/code&gt; and the first &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b2c30b24be1ada27dc38a1f58fce4304459396" translate="yes" xml:space="preserve">
          <source>The hostname from the URL (excluding port number).</source>
          <target state="translated">来自URL的主机名(不包括端口号)。</target>
        </trans-unit>
        <trans-unit id="e2ca20155497fac3b42eb54e6e58c4e5f8398358" translate="yes" xml:space="preserve">
          <source>The hostname from the URL.</source>
          <target state="translated">URL中的主机名。</target>
        </trans-unit>
        <trans-unit id="7bcc834a08945d7f53b90ecdf02df16cd4cbc61a" translate="yes" xml:space="preserve">
          <source>The identity and the location of resources on the Web are mostly given by a single URL (Uniform Resource Locator, a kind of URI). There are sometimes reasons identity and location are not given by the same URI: HTTP uses a specific HTTP header, &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; when the resource requested wants the client to access it at another location.</source>
          <target state="translated">Web上资源的标识和位置通常由单个URL（统一资源定位器，一种URI）给出。有时会有相同的URI不能给出身份和位置的原因：当请求的资源希望客户端在另一个位置访问HTTP时，HTTP使用特定的HTTP标头&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1e67e8b2786357d4a6663a2bc15f636eb756e8f" translate="yes" xml:space="preserve">
          <source>The iframe allow attribute</source>
          <target state="translated">iframe的允许属性</target>
        </trans-unit>
        <trans-unit id="651815c795a02ba38593f0882335db6d832e2b91" translate="yes" xml:space="preserve">
          <source>The implementation of this prefetching in some browsers allows domain name resolution to occur in parallel with (instead of in serial with) the fetching of actual page content. By doing this, the high-latency domain name resolution process doesn't cause any delay while fetching content.</source>
          <target state="translated">在一些浏览器中实现这种预取功能,可以使域名解析与实际页面内容的获取同步进行(而不是串行进行)。通过这样做,高延迟的域名解析过程不会在获取内容时造成任何延迟。</target>
        </trans-unit>
        <trans-unit id="37f7cdd7fd1331a83928f974ca15680ae3b0af4f" translate="yes" xml:space="preserve">
          <source>The inclusion of the &quot;app:draft&quot; element represents a request by the
   client to control the visibility of a Member Resource.  The app:draft
   element MAY be ignored by the server.

   The number of app:draft elements in app:control MUST be zero or one.
   The content of an app:draft element MUST be one of &quot;yes&quot; or &quot;no&quot;.  If
   the element contains &quot;no&quot;, this indicates a client request that the
   Member Resource be made publicly visible.  If the app:draft element
   is not present, then servers that support the extension MUST behave
   as though an app:draft element containing &quot;no&quot; was sent.</source>
          <target state="translated">包含 &quot;app:draft &quot;元素表示客户端请求控制成员资源的可见性。app:draft 元素可以被服务器忽略。app:control 中的 app:draft 元素的数量必须为 0 或 1。app:draft 元素的内容必须是 &quot;yes &quot;或 &quot;no &quot;中的一个。如果该元素包含 &quot;no&quot;,则表示客户端请求将成员资源公开可见。如果不存在 app:draft 元素,那么支持扩展的服务器必须像发送包含 &quot;no &quot;的 app:draft 元素一样行事。</target>
        </trans-unit>
        <trans-unit id="ff9cab94e579758912dbc34c45bff0d14c466bcf" translate="yes" xml:space="preserve">
          <source>The information below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">以下信息已从MDN的GitHub（&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;）中提取。</target>
        </trans-unit>
        <trans-unit id="89f19b58853606bc26aa103de926f33f0228de47" translate="yes" xml:space="preserve">
          <source>The information by the client is quite verbose (HTTP/2 header compression mitigates this problem) and a privacy risk (HTTP fingerprinting)</source>
          <target state="translated">客户端提供的信息相当啰嗦(HTTP/2头压缩缓解了这个问题),而且存在隐私风险(HTTP指纹)。</target>
        </trans-unit>
        <trans-unit id="88371e0de52c1ea4ce93bd3a2050533f57795785" translate="yes" xml:space="preserve">
          <source>The information shown below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">下面显示的信息已从MDN的GitHub（&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;）中提取。</target>
        </trans-unit>
        <trans-unit id="3cf93a0d825024937b080186cbf88ae3afde9002" translate="yes" xml:space="preserve">
          <source>The initial range unit registry contains the registrations below:

   +-------------+---------------------------------------+-------------+
   | Range Unit  | Description                           | Reference   |
   | Name        |                                       |             |
   +-------------+---------------------------------------+-------------+
   | bytes       | a range of octets                     | &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt; |
   | none        | reserved as keyword, indicating no    | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   |             | ranges are supported                  |             |
   +-------------+---------------------------------------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">初始范围单位注册表包含以下注册：+ ------------- + ------------------------- -------------- + ------------- + |范围单位|描述参考| |姓名| | | + ------------- + ----------------------------------- ---- + ------------- + |字节|八位字节的范围| &lt;a href=&quot;#section-2.1&quot;&gt;第2.1节&lt;/a&gt; | |无|保留为关键字，表示否| &lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt; | | |支持范围| | + ------------- + ----------------------------------- ---- + ------------- +更改控制者为：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ebd17564840526ee148efdaf203fca839e5379a4" translate="yes" xml:space="preserve">
          <source>The initial version of HTTP had no version number; it has been later called 0.9 to differentiate it from the later versions. HTTP/0.9 is extremely simple: requests consist of a single line and start with the only possible method &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; followed by the path to the resource (not the URL as both the protocol, server, and port are unnecessary once connected to the server).</source>
          <target state="translated">HTTP的初始版本没有版本号。它后来被称为0.9，以区别于更高版本。HTTP / 0.9非常简单：请求由一行组成，并以唯一可能的方法&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;开头，后跟资源的路径（而不是URL，因为一旦连接到服务器，就不需要协议，服务器和端口）。</target>
        </trans-unit>
        <trans-unit id="aa546185419767d20a05e2cb4df36ea1b19d66d3" translate="yes" xml:space="preserve">
          <source>The interface where the request came in to the proxy server.</source>
          <target state="translated">请求进入代理服务器的界面。</target>
        </trans-unit>
        <trans-unit id="7c3952a320aa0697f4c57ed16e077bfea2eed9ae" translate="yes" xml:space="preserve">
          <source>The introduction of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt;&lt;code&gt;Client-Hints&lt;/code&gt;&lt;/a&gt; allows the browser, or client, to proactively communicate information about its requirements, or hardware constraints, to the server.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt; &lt;code&gt;Client-Hints&lt;/code&gt; &lt;/a&gt;的引入使浏览器或客户端可以将有关其要求或硬件限制的信息主动传达给服务器。</target>
        </trans-unit>
        <trans-unit id="b38d9075a389a16460fcd684d2635f8653d50eed" translate="yes" xml:space="preserve">
          <source>The introduction of security-related prefixes in the &lt;a href=&quot;../headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header, now helps guarantee a secure cookie has not been altered.</source>
          <target state="translated">&lt;a href=&quot;../headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;标头中引入了与安全性相关的前缀，现在可以帮助确保安全的cookie未被更改。</target>
        </trans-unit>
        <trans-unit id="5e730b1eec3af5f9a050a8a9662df02e4c7599c2" translate="yes" xml:space="preserve">
          <source>The issued request looks like this:</source>
          <target state="translated">发出的请求是这样的。</target>
        </trans-unit>
        <trans-unit id="c84804fc4afa331bf0f09b76ea2770dfd6b62155" translate="yes" xml:space="preserve">
          <source>The key for this request to upgrade. The client adds this if it wishes to do so, and the server will include in the response a key of its own, which the client will validate before delivering the upgrade response to you.</source>
          <target state="translated">本次请求升级的密钥。客户端如果愿意的话会添加这个,服务器会在响应中包含一个自己的密钥,客户端会在向你发送升级响应之前验证这个密钥。</target>
        </trans-unit>
        <trans-unit id="9a15e6847a0ff9b62775caf043875cd4c43edfc3" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   An implementation is not compliant if it fails to satisfy one or more
   of the MUST or REQUIRED level requirements for the protocols it
   implements. An implementation that satisfies all the MUST or REQUIRED
   level and all the SHOULD level requirements for its protocols is said
   to be &quot;unconditionally compliant&quot;; one that satisfies all the MUST
   level requirements but not all the SHOULD level requirements for its
   protocols is said to be &quot;conditionally compliant.&quot;</source>
          <target state="translated">本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应不&amp;rdquo;，&amp;ldquo;建议&amp;rdquo;，&amp;ldquo;可&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;按照&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]中的描述进行解释。如果某个实现无法满足其实现的协议的一个或多个&amp;ldquo;必须&amp;rdquo;或&amp;ldquo;必需&amp;rdquo;级别要求，则它不符合要求。满足其协议的所有MUST或REQUIRED级别以及所有SHOULD级别要求的实现被称为&amp;ldquo;无条件兼容&amp;rdquo;。满足所有MUST级别要求但不满足其协议的所有SHOULD级别要求的协议被称为&amp;ldquo;有条件地兼容&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="48f7d02ccdd6151055ec019221672e2ab74e0330" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   All numeric values are in network byte order.  Values are unsigned
   unless otherwise indicated.  Literal values are provided in decimal
   or hexadecimal as appropriate.  Hexadecimal literals are prefixed
   with &quot;0x&quot; to distinguish them from decimal literals.

   The following terms are used:

   client:  The endpoint that initiates an HTTP/2 connection.  Clients
      send HTTP requests and receive HTTP responses.

   connection:  A transport-layer connection between two endpoints.

   connection error:  An error that affects the entire HTTP/2
      connection.

   endpoint:  Either the client or server of the connection. 

   frame:  The smallest unit of communication within an HTTP/2
      connection, consisting of a header and a variable-length sequence
      of octets structured according to the frame type.

   peer:  An endpoint.  When discussing a particular endpoint, &quot;peer&quot;
      refers to the endpoint that is remote to the primary subject of
      discussion.

   receiver:  An endpoint that is receiving frames.

   sender:  An endpoint that is transmitting frames.

   server:  The endpoint that accepts an HTTP/2 connection.  Servers
      receive HTTP requests and send HTTP responses.

   stream:  A bidirectional flow of frames within the HTTP/2 connection.

   stream error:  An error on the individual HTTP/2 stream.

   Finally, the terms &quot;gateway&quot;, &quot;intermediary&quot;, &quot;proxy&quot;, and &quot;tunnel&quot;
   are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7230]&lt;/a&gt;.  Intermediaries act as both
   client and server at different times.

   The term &quot;payload body&quot; is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7230]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4a2293d2f84b8a5fd8f2e4def5c748288282ce" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].</source>
          <target state="translated">本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;不应&amp;rdquo;，&amp;ldquo;建议&amp;rdquo;，&amp;ldquo;可以&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;是按照[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]中所述进行解释。</target>
        </trans-unit>
        <trans-unit id="f9eac2de940bf2c082a5aa542b14155a2665a0ba" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.</source>
          <target state="translated">本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;不应&amp;rdquo;，&amp;ldquo;建议&amp;rdquo;，&amp;ldquo;可以&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;是按照[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]中所述进行解释。关于错误处理的符合性标准和注意事项在&lt;a href=&quot;#section-2.5&quot;&gt;2.5节&lt;/a&gt;中定义。</target>
        </trans-unit>
        <trans-unit id="6a63eeb5f4d9a57b187d7fb929309ed70bf0dbac" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;Section&amp;nbsp;2.5 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;不应&amp;rdquo;，&amp;ldquo;建议&amp;rdquo;，&amp;ldquo;可以&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;是按照[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]中所述进行解释。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;[RFC7230]的2.5节&lt;/a&gt;中定义了有关错误处理的符合性标准和注意事项。</target>
        </trans-unit>
        <trans-unit id="bb75c6ee1cca0ad36d986b0e355cb0e843e6e2f2" translate="yes" xml:space="preserve">
          <source>The kind of validation is independent of the validator used. Both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; allow both types of validation, though the complexity to implement it on the server side may vary. HTTP uses strong validation by default, and it specifies when weak validation can be used.</source>
          <target state="translated">验证的种类与所使用的验证器无关。双方&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; 标&lt;/a&gt;允许两种类型的验证，虽然复杂性来实现它在服务器端可能会有所不同。HTTP默认情况下使用强验证，它指定何时可以使用弱验证。</target>
        </trans-unit>
        <trans-unit id="d08a92729e395511c2581a4dfc33791c98b63230" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communication created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the companies, but SSL 2.0 and its successors SSL 3.0 and SSL 3.1 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with version 1.0, 1.1, and 1.2 appearing successfully to close vulnerabilities. TLS 1.3 is currently in the making.</source>
          <target state="translated">早在1994年底,HTTP就发生了最大的变化。网景通信公司没有在基本的TCP/IP协议栈上发送HTTP,而是在其上创建了一个额外的加密传输层。SSL SSL 1.0从未在公司外部发布,但SSL 2.0及其后续的SSL 3.0和SSL 3.1通过加密和保证服务器和客户端之间交换的消息的真实性,允许创建电子商务网站。SSL被纳入标准轨道,最终成为TLS,1.0、1.1、1.2版本的出现成功弥补了漏洞。目前TLS 1.3正在酝酿中。</target>
        </trans-unit>
        <trans-unit id="cedd0ab48b46862829d9707f126e162c35e1388c" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communications created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the company, but SSL 2.0 and its successor SSL 3.0 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with versions 1.0, 1.1, 1.2, and 1.3 appearing successfully to close vulnerabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afbff65f36ae363825e270b4816f35143b381cc" translate="yes" xml:space="preserve">
          <source>The last modification date of the resource, used to compare several versions of the same resource. It is less accurate than &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but easier to calculate in some environments. Conditional requests using &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9022ae767f477f1c7bcdb68243b1fa5a2efe966" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code that sufficiently answers the request without the need for corresponding payload (like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt;) usually don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01d212bb5fa98e344dced612706d97e4c48d614" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code, like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;, usually don't.</source>
          <target state="translated">回应的最后一部分是身体。并非所有响应都有一个：状态码（如&lt;a href=&quot;status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; )的&lt;/a&gt;响应通常没有。</target>
        </trans-unit>
        <trans-unit id="13fd2da68ff6f625ec41f864542e44b06721f081" translate="yes" xml:space="preserve">
          <source>The length in decimal number of octets.</source>
          <target state="translated">以十进制八位数为单位的长度。</target>
        </trans-unit>
        <trans-unit id="fc5fa9bc684bf265ecd239fcfb6b1be61af94a10" translate="yes" xml:space="preserve">
          <source>The length of a message body is determined by one of the following
   (in order of precedence):

   1.  Any response to a HEAD request and any response with a 1xx
       (Informational), 204 (No Content), or 304 (Not Modified) status
       code is always terminated by the first empty line after the
       header fields, regardless of the header fields present in the
       message, and thus cannot contain a message body.

   2.  Any 2xx (Successful) response to a CONNECT request implies that
       the connection will become a tunnel immediately after the empty
       line that concludes the header fields.  A client MUST ignore any
       Content-Length or Transfer-Encoding header fields received in
       such a message.

   3.  If a Transfer-Encoding header field is present and the chunked
       transfer coding (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) is the final encoding, the message
       body length is determined by reading and decoding the chunked
       data until the transfer coding indicates the data is complete.

       If a Transfer-Encoding header field is present in a response and
       the chunked transfer coding is not the final encoding, the
       message body length is determined by reading the connection until
       it is closed by the server.  If a Transfer-Encoding header field
       is present in a request and the chunked transfer coding is not
       the final encoding, the message body length cannot be determined
       reliably; the server MUST respond with the 400 (Bad Request)
       status code and then close the connection.

       If a message is received with both a Transfer-Encoding and a
       Content-Length header field, the Transfer-Encoding overrides the
       Content-Length.  Such a message might indicate an attempt to
       perform request smuggling (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;) or response splitting
       (&lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;) and ought to be handled as an error.  A sender MUST
       remove the received Content-Length field prior to forwarding such
       a message downstream.

   4.  If a message is received without Transfer-Encoding and with
       either multiple Content-Length header fields having differing
       field-values or a single Content-Length header field having an
       invalid value, then the message framing is invalid and the
       recipient MUST treat it as an unrecoverable error.  If this is a
       request message, the server MUST respond with a 400 (Bad Request)
       status code and then close the connection.  If this is a response
       message received by a proxy, the proxy MUST close the connection
       to the server, discard the received response, and send a 502 (Bad 

       Gateway) response to the client.  If this is a response message
       received by a user agent, the user agent MUST close the
       connection to the server and discard the received response.

   5.  If a valid Content-Length header field is present without
       Transfer-Encoding, its decimal value defines the expected message
       body length in octets.  If the sender closes the connection or
       the recipient times out before the indicated number of octets are
       received, the recipient MUST consider the message to be
       incomplete and close the connection.

   6.  If this is a request message and none of the above are true, then
       the message body length is zero (no message body is present).

   7.  Otherwise, this is a response message without a declared message
       body length, so the message body length is determined by the
       number of octets received prior to the server closing the
       connection.

   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.

   A server MAY reject a request that contains a message body but not a
   Content-Length by responding with 411 (Length Required).

   Unless a transfer coding other than chunked has been applied, a
   client that sends a request containing a message body SHOULD use a
   valid Content-Length header field if the message body length is known
   in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a 411 (Length Required)
   status code even though they understand the chunked transfer coding.
   This is typically because such services are implemented via a gateway
   that requires a content-length in advance of being called and the
   server is unable or unwilling to buffer the entire request before
   processing.

   A user agent that sends a request containing a message body MUST send
   a valid Content-Length header field if it does not know the server
   will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version
   of a prior received response.

   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user
   agent MAY discard the remaining data or attempt to determine if that 

   data belongs as part of the prior response body, which might be the
   case if the prior message's Content-Length value is incorrect.  A
   client MUST NOT process, cache, or forward such extra data as a
   separate response, since such behavior would be vulnerable to cache
   poisoning.</source>
          <target state="translated">消息正文的长度由以下一项（按优先级顺序）确定：1.对HEAD请求的任何响应以及任何带有1xx（信息性），204（无内容）或304（未修改）的响应状态消息始终由标头字段之后的第一个空行终止，而不管消息中存在的标头字段如何，因此状态代码不能包含消息正文。2.对CONNECT请求的任何2xx（成功）响应都意味着该连接将在结束标头字段的空行之后立即成为隧道。客户必须忽略在这样的消息中收到的任何Content-Length或Transfer-Encoding头字段。3.如果存在Transfer-Encoding标头字段，并且分块后的传输编码（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;）是最终编码，消息主体长度是通过读取和解码分块数据确定的，直到传输编码指示数据完成为止。如果响应中存在Transfer-Encoding头字段，并且分块的传输编码不是最终编码，则通过读取连接直到服务器将其关闭才确定消息主体的长度。如果请求中存在Transfer-Encoding头字段，并且分块的传输编码不是最终编码，则无法可靠地确定消息正文长度；服务器必须使用400（错误请求）状态码进行响应，然后关闭连接。如果同时收到带有传输编码和内容长度标头字段的消息，传输编码会覆盖内容长度。此类消息可能表示尝试执行请求走私（&lt;a href=&quot;#section-9.5&quot;&gt;9.5节&lt;/a&gt;）或响应拆分（&lt;a href=&quot;#section-9.4&quot;&gt; 9.4节）&lt;/a&gt;），应将其视为错误。发送者必须在向下游转发这样的消息之前删除接收到的Content-Length字段。 4.如果收到的消息没有传输编码，并且具有多个具有不同字段值的Content-Length头字段或具有无效值的单个Content-Length头字段，则该消息框架无效，并且接收者必须对其进行处理作为不可恢复的错误。如果这是一个请求消息，则服务器必须以400（错误请求）状态码响应，然后关闭连接。如果这是代理接收到的响应消息，则代理必须关闭与服务器的连接，丢弃接收到的响应，并向客户端发送502（错误网关）响应。如果这是用户代理收到的响应消息，则用户代理必须关闭与服务器的连接并丢弃收到的响应。 5.如果存在有效的Content-Length标头字段，但没有Transfer-Encoding，则其十进制值以八位字节定义期望的消息正文长度。如果发送方关闭了连接或接收方在接收到指定数量的八位字节之前超时，则接收方必须认为该消息不完整并关闭连接。 6.如果这是请求消息，并且以上都不是，则消息正文长度为零（不存在消息正文）。 7.否则，这是一条没有声明的消息正文长度的响应消息，因此，邮件正文长度由服务器关闭连接之前接收到的八位字节数确定。由于没有办法将成功完成的，用分隔符分隔的消息与由于网络故障而中断的部分接收的消息区分开，因此服务器应尽可能生成编码或用长度分隔的消息。存在封闭定界功能主要是为了与HTTP / 1.0向后兼容。服务器可以通过响应411（必需的长度）来拒绝包含消息正文但不包含内容长度的请求。除非已经应用了分块之外的传输编码，否则如果发送者预先知道消息主体的长度，则发送包含消息主体的请求的客户端应该使用有效的Content-Length标头字段，而不是分块传输编码，因为某些现有服务即使知道了分块传输编码，也会以411（所需长度）状态码响应分块。这通常是因为此类服务是通过网关实现的，该网关要求在被调用之前具有内容长度，并且服务器无法或不愿意在处理之前缓冲整个请求。发送包含消息正文的请求的用户代理，如果不知道服务器将处理HTTP / 1.1（或更高版本）请求，则必须发送有效的Content-Length标头字段；这些知识可以采用特定用户配置的形式，也可以通过记住先前收到的响应的版本来实现。如果已经完全接收到对连接上最后一个请求的最终响应，并且还有其他要读取的数据，则用户代理可以丢弃剩余的数据，或者尝试确定该数据是否属于先前响应主体的一部分，这可能是如果先前消息的Content-Length值不正确，则为这种情况。客户端绝不能处理，缓存或转发额外的数据作为单独的响应，因为这样的行为容易受到缓存中毒的影响。因为这样的行为很容易受到缓存中毒的影响。因为这样的行为很容易受到缓存中毒的影响。</target>
        </trans-unit>
        <trans-unit id="3e37cbe5ee6782b6ab613b55eb65c69ee9c91d78" translate="yes" xml:space="preserve">
          <source>The lifecycle of a stream is shown in Figure 2.

                                +--------+
                        send PP |        | recv PP
                       ,--------|  idle  |--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------| reserved |          | recv H    | reserved |------.
       |      | (local)  |          |           | (remote) |      |
       |      +----------+          v           +----------+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------|  open  |-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +--------+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half   |          |           |   half   |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----------+          |           +----------+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           | send R /       v        send R / |           |
       |           | recv R     +--------+   recv R   |           |
       | send R /  `-----------&amp;gt;|        |&amp;lt;-----------'  send R / |
       | recv R                 | closed |               recv R   |
       `-----------------------&amp;gt;|        |&amp;lt;----------------------'
                                +--------+

          send:   endpoint sends this frame
          recv:   endpoint receives this frame

          H:  HEADERS frame (with implied CONTINUATIONs)
          PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
          ES: END_STREAM flag
          R:  RST_STREAM frame

                          Figure 2: Stream States

   Note that this diagram shows stream state transitions and the frames
   and flags that affect those transitions only.  In this regard,
   CONTINUATION frames do not result in state transitions; they are
   effectively part of the HEADERS or PUSH_PROMISE that they follow. 

   For the purpose of state transitions, the END_STREAM flag is
   processed as a separate event to the frame that bears it; a HEADERS
   frame with the END_STREAM flag set can cause two state transitions.

   Both endpoints have a subjective view of the state of a stream that
   could be different when frames are in transit.  Endpoints do not
   coordinate the creation of streams; they are created unilaterally by
   either endpoint.  The negative consequences of a mismatch in states
   are limited to the &quot;closed&quot; state after sending RST_STREAM, where
   frames might be received for some time after closing.

   Streams have the following states:

   idle:
      All streams start in the &quot;idle&quot; state.

      The following transitions are valid from this state:

      *  Sending or receiving a HEADERS frame causes the stream to
         become &quot;open&quot;.  The stream identifier is selected as described
         in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;.  The same HEADERS frame can also cause a
         stream to immediately become &quot;half-closed&quot;.

      *  Sending a PUSH_PROMISE frame on another stream reserves the
         idle stream that is identified for later use.  The stream state
         for the reserved stream transitions to &quot;reserved (local)&quot;.

      *  Receiving a PUSH_PROMISE frame on another stream reserves an
         idle stream that is identified for later use.  The stream state
         for the reserved stream transitions to &quot;reserved (remote)&quot;.

      *  Note that the PUSH_PROMISE frame is not sent on the idle stream
         but references the newly reserved stream in the Promised Stream
         ID field.

      Receiving any frame other than HEADERS or PRIORITY on a stream in
      this state MUST be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;)
      of type PROTOCOL_ERROR.

   reserved (local):
      A stream in the &quot;reserved (local)&quot; state is one that has been
      promised by sending a PUSH_PROMISE frame.  A PUSH_PROMISE frame
      reserves an idle stream by associating the stream with an open
      stream that was initiated by the remote peer (see &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;). 

      In this state, only the following transitions are possible:

      *  The endpoint can send a HEADERS frame.  This causes the stream
         to open in a &quot;half-closed (remote)&quot; state.

      *  Either endpoint can send a RST_STREAM frame to cause the stream
         to become &quot;closed&quot;.  This releases the stream reservation.


      An endpoint MUST NOT send any type of frame other than HEADERS,
      RST_STREAM, or PRIORITY in this state.

      A PRIORITY or WINDOW_UPDATE frame MAY be received in this state.
      Receiving any type of frame other than RST_STREAM, PRIORITY, or
      WINDOW_UPDATE on a stream in this state MUST be treated as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   reserved (remote):
      A stream in the &quot;reserved (remote)&quot; state has been reserved by a
      remote peer.

      In this state, only the following transitions are possible:

      *  Receiving a HEADERS frame causes the stream to transition to
         &quot;half-closed (local)&quot;.

      *  Either endpoint can send a RST_STREAM frame to cause the stream
         to become &quot;closed&quot;.  This releases the stream reservation.

      An endpoint MAY send a PRIORITY frame in this state to
      reprioritize the reserved stream.  An endpoint MUST NOT send any
      type of frame other than RST_STREAM, WINDOW_UPDATE, or PRIORITY in
      this state.

      Receiving any type of frame other than HEADERS, RST_STREAM, or
      PRIORITY on a stream in this state MUST be treated as a connection
      error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   open:
      A stream in the &quot;open&quot; state may be used by both peers to send
      frames of any type.  In this state, sending peers observe
      advertised stream-level flow-control limits (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

      From this state, either endpoint can send a frame with an
      END_STREAM flag set, which causes the stream to transition into
      one of the &quot;half-closed&quot; states.  An endpoint sending an 

      END_STREAM flag causes the stream state to become &quot;half-closed
      (local)&quot;; an endpoint receiving an END_STREAM flag causes the
      stream state to become &quot;half-closed (remote)&quot;.

      Either endpoint can send a RST_STREAM frame from this state,
      causing it to transition immediately to &quot;closed&quot;.

   half-closed (local):
      A stream that is in the &quot;half-closed (local)&quot; state cannot be used
      for sending frames other than WINDOW_UPDATE, PRIORITY, and
      RST_STREAM.

      A stream transitions from this state to &quot;closed&quot; when a frame that
      contains an END_STREAM flag is received or when either peer sends
      a RST_STREAM frame.

      An endpoint can receive any type of frame in this state.
      Providing flow-control credit using WINDOW_UPDATE frames is
      necessary to continue receiving flow-controlled frames.  In this
      state, a receiver can ignore WINDOW_UPDATE frames, which might
      arrive for a short period after a frame bearing the END_STREAM
      flag is sent.

      PRIORITY frames received in this state are used to reprioritize
      streams that depend on the identified stream.

   half-closed (remote):
      A stream that is &quot;half-closed (remote)&quot; is no longer being used by
      the peer to send frames.  In this state, an endpoint is no longer
      obligated to maintain a receiver flow-control window.

      If an endpoint receives additional frames, other than
      WINDOW_UPDATE, PRIORITY, or RST_STREAM, for a stream that is in
      this state, it MUST respond with a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of
      type STREAM_CLOSED.

      A stream that is &quot;half-closed (remote)&quot; can be used by the
      endpoint to send frames of any type.  In this state, the endpoint
      continues to observe advertised stream-level flow-control limits
      (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

      A stream can transition from this state to &quot;closed&quot; by sending a
      frame that contains an END_STREAM flag or when either peer sends a
      RST_STREAM frame. 

   closed:
      The &quot;closed&quot; state is the terminal state.

      An endpoint MUST NOT send frames other than PRIORITY on a closed
      stream.  An endpoint that receives any frame other than PRIORITY
      after receiving a RST_STREAM MUST treat that as a stream error
      (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type STREAM_CLOSED.  Similarly, an endpoint
      that receives any frames after receiving a frame with the
      END_STREAM flag set MUST treat that as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type STREAM_CLOSED, unless the frame is
      permitted as described below.

      WINDOW_UPDATE or RST_STREAM frames can be received in this state
      for a short period after a DATA or HEADERS frame containing an
      END_STREAM flag is sent.  Until the remote peer receives and
      processes RST_STREAM or the frame bearing the END_STREAM flag, it
      might send frames of these types.  Endpoints MUST ignore
      WINDOW_UPDATE or RST_STREAM frames received in this state, though
      endpoints MAY choose to treat frames that arrive a significant
      time after sending END_STREAM as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

      PRIORITY frames can be sent on closed streams to prioritize
      streams that are dependent on the closed stream.  Endpoints SHOULD
      process PRIORITY frames, though they can be ignored if the stream
      has been removed from the dependency tree (see &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;).

      If this state is reached as a result of sending a RST_STREAM
      frame, the peer that receives the RST_STREAM might have already
      sent -- or enqueued for sending -- frames on the stream that
      cannot be withdrawn.  An endpoint MUST ignore frames that it
      receives on closed streams after it has sent a RST_STREAM frame.
      An endpoint MAY choose to limit the period over which it ignores
      frames and treat frames that arrive after this time as being in
      error.

      Flow-controlled frames (i.e., DATA) received after sending
      RST_STREAM are counted toward the connection flow-control window.
      Even though these frames might be ignored, because they are sent
      before the sender receives the RST_STREAM, the sender will
      consider the frames to count against the flow-control window.

      An endpoint might receive a PUSH_PROMISE frame after it sends
      RST_STREAM.  PUSH_PROMISE causes a stream to become &quot;reserved&quot;
      even if the associated stream has been reset.  Therefore, a
      RST_STREAM is needed to close an unwanted promised stream. 

   In the absence of more specific guidance elsewhere in this document,
   implementations SHOULD treat the receipt of a frame that is not
   expressly permitted in the description of a state as a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  Note that PRIORITY can
   be sent and received in any stream state.  Frames of unknown types
   are ignored.

   An example of the state transitions for an HTTP request/response
   exchange can be found in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.  An example of the state
   transitions for server push can be found in Sections &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; and &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc721cb7f57681a68e8ffe39db25deee64045b40" translate="yes" xml:space="preserve">
          <source>The lifetime of a cookie can be defined in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51d769847399f42de0ee4cd02eb8aff1ca2aada" translate="yes" xml:space="preserve">
          <source>The link header contains parameters, which are separated with &lt;code&gt;;&lt;/code&gt; and are equivalent to attributes of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de35152ee3c77722bc9537cad929955d73dab593" translate="yes" xml:space="preserve">
          <source>The list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">允许的&lt;a href=&quot;../methods&quot;&gt;HTTP请求方法&lt;/a&gt;列表。</target>
        </trans-unit>
        <trans-unit id="2d4513b7f363144d73199955a36973cf7c46be3c" translate="yes" xml:space="preserve">
          <source>The maximum amount of time a resource is considered fresh. Unlike &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15263fb5ed512784dbb85f5e27d3d988105feb1f" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the detailed format. If not specified, the cookie will have the lifetime of a &lt;strong&gt;session cookie. &lt;/strong&gt;A session is finished when the client is shut down meaning that session cookies will get removed at that point. However, many web browsers have a feature called session restore that will save all your tabs and have them come back next time you use the browser. Cookies will also be present and it's like you had never actually closed the browser.</source>
          <target state="translated">Cookie的最长生存期，以HTTP日期为时间戳。有关详细格式，请参见&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;。如果未指定，则cookie将具有&lt;strong&gt;会话cookie&lt;/strong&gt;的生存期&lt;strong&gt;。&lt;/strong&gt;当客户端关闭时，会话结束，这意味着会话cookie将在此时被删除。但是，许多Web浏览器都具有称为会话还原的功能，该功能将保存您的所有标签页，并在您下次使用浏览器时再次显示。Cookies也会出现，就好像您从未真正关闭浏览器一样。</target>
        </trans-unit>
        <trans-unit id="d852a80087f1759845814ae78b7b6a4cc10fa2cf" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the required formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63c2c824f245057f299d57750e6b8789678a89a" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 32kB</source>
          <target state="translated">支持的最大尺寸为32kB</target>
        </trans-unit>
        <trans-unit id="c27432dd9f890b43b972ceef8be06ebeb078000d" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 4GB</source>
          <target state="translated">支持的最大容量为4GB</target>
        </trans-unit>
        <trans-unit id="6711070acb52353698f99e67ae8f7a23d80cf676" translate="yes" xml:space="preserve">
          <source>The meaning of a success depends on the HTTP request method:</source>
          <target state="translated">成功的意义取决于HTTP请求方法。</target>
        </trans-unit>
        <trans-unit id="ed1aebd9e25e31bb79bed64a7c6d90aa83890cf3" translate="yes" xml:space="preserve">
          <source>The media format of the requested data is not supported by the server, so the server is rejecting the request.</source>
          <target state="translated">服务器不支持请求数据的媒体格式,所以服务器拒绝该请求。</target>
        </trans-unit>
        <trans-unit id="6d8af46d85f95f2c6776a4511c1248db0db1fa9e" translate="yes" xml:space="preserve">
          <source>The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;.

     message-body = *OCTET

   The rules for when a message body is allowed in a message differ for
   requests and responses.

   The presence of a message body in a request is signaled by a
   Content-Length or Transfer-Encoding header field.  Request message
   framing is independent of method semantics, even if the method does
   not define any use for a message body.

   The presence of a message body in a response depends on both the
   request method to which it is responding and the response status code
   (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;).  Responses to the HEAD request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2
   of [RFC7231]&lt;/a&gt;) never include a message body because the associated
   response header fields (e.g., Transfer-Encoding, Content-Length,
   etc.), if present, indicate only what their values would have been if
   the request method had been GET (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;). 2xx
   (Successful) responses to a CONNECT request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;) switch to tunnel mode instead of having a message body.
   All 1xx (Informational), 204 (No Content), and 304 (Not Modified)
   responses do not include a message body.  All other responses do
   include a message body, although the body might be of zero length.</source>
          <target state="translated">HTTP消息的消息正文（如果有）用于承载该请求或响应的有效内容正文。消息主体与有效载荷主体相同，除非已应用传输编码（如&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节中&lt;/a&gt;所述）。 message-body = * OCTET对于请求和响应，何时在消息中允许消息正文的规则有所不同。通过Content-Length或Transfer-Encoding标头字段可以指示请求中消息正文的存在。请求消息框架独立于方法语义，即使该方法未定义消息主体的任何用法。响应中消息体的存在取决于它所响应的请求方法和响应状态代码（&lt;a href=&quot;#section-3.1.2&quot;&gt;第3.1.2节）&lt;/a&gt;）。对HEAD请求方法的响应（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;[RFC7231]的4.3.2节&lt;/a&gt;）从不包含消息正文，因为相关的响应标头字段（例如Transfer-Encoding，Content-Length等）（如果存在）仅指示其值如果请求方法是GET（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]的4.3.1节&lt;/a&gt;），则应该是这样。对CONNECT请求方法的2xx（成功）响应（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]的第4.3.6节）&lt;/a&gt;）切换到隧道模式，而不要显示消息正文。所有1xx（信息性），204（无内容）和304（未修改）响应均不包含消息正文。所有其他响应都包括消息正文，尽管该正文的长度可能为零。</target>
        </trans-unit>
        <trans-unit id="4e8aaa241374a41dac239673c7a83e9b31912343" translate="yes" xml:space="preserve">
          <source>The message header fields below should be added to the permanent
   registry (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;]).</source>
          <target state="translated">下面的消息头字段应添加到永久注册表中（请参阅[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; ]）。</target>
        </trans-unit>
        <trans-unit id="5e0a346350c18fe7ecba53dc40c76384937c220e" translate="yes" xml:space="preserve">
          <source>The message-body (if any) of an HTTP message is used to carry the
   entity-body associated with the request or response. The message-body
   differs from the entity-body only when a transfer-coding has been
   applied, as indicated by the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;).

       message-body = entity-body
                    | &amp;lt;entity-body encoded as per Transfer-Encoding&amp;gt;

   Transfer-Encoding MUST be used to indicate any transfer-codings
   applied by an application to ensure safe and proper transfer of the
   message. Transfer-Encoding is a property of the message, not of the 

   entity, and thus MAY be added or removed by any application along the
   request/response chain. (However, &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt; places restrictions on
   when certain transfer-codings may be used.)

   The rules for when a message-body is allowed in a message differ for
   requests and responses.

   The presence of a message-body in a request is signaled by the
   inclusion of a Content-Length or Transfer-Encoding header field in
   the request's message-headers. A message-body MUST NOT be included in
   a request if the specification of the request method (&lt;a href=&quot;#section-5.1.1&quot;&gt;section 5.1.1&lt;/a&gt;)
   does not allow sending an entity-body in requests. A server SHOULD
   read and forward a message-body on any request; if the request method
   does not include defined semantics for an entity-body, then the
   message-body SHOULD be ignored when handling the request.

   For response messages, whether or not a message-body is included with
   a message is dependent on both the request method and the response
   status code (&lt;a href=&quot;#section-6.1.1&quot;&gt;section 6.1.1&lt;/a&gt;). All responses to the HEAD request method
   MUST NOT include a message-body, even though the presence of entity-
   header fields might lead one to believe they do. All 1xx
   (informational), 204 (no content), and 304 (not modified) responses
   MUST NOT include a message-body. All other responses do include a
   message-body, although it MAY be of zero length.</source>
          <target state="translated">HTTP消息的消息主体（如果有）用于承载与请求或响应关联的实体主体。消息主体与实体主体只有在应用了传输编码时才有所不同，如Transfer-Encoding头字段所示（&lt;a href=&quot;#section-14.41&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41 &lt;/a&gt;节）。 message-body =实体-主体| &amp;lt;按Transfer-Encoding编码的实体-主体&amp;gt; Transfer-Encoding必须用于指示应用程序所应用的任何传输编码，以确保安全正确地传输消息。传输编码是消息的属性，而不是实体的属性，因此可以由请求/响应链中的任何应用程序添加或删除。 （但是，&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节&lt;/a&gt;对何时可以使用某些传输编码设置了限制。）何时在消息中允许消息正文的规则因请求和响应而异。通过在请求的消息头中包含Content-Length或Transfer-Encoding头字段，可以指示请求中消息主体的存在。如果请求方法的规范（&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节）&lt;/a&gt;，则消息正文不得包含在请求中）不允许在请求中发送实体。服务器应根据任何请求读取并转发消息正文；如果请求方法不包括为实体主体定义的语义，则在处理请求时应忽略消息主体。对于响应消息，消息中是否包含消息正文取决于请求方法和响应状态代码（&lt;a href=&quot;#section-6.1.1&quot;&gt;第6.1.1节&lt;/a&gt;）。对HEAD请求方法的所有响应都不得包含消息正文，即使实体标头字段的存在可能会使人相信它们确实也是如此。所有的1xx（信息性），204（无内容）和304（未修改）响应均不得包含消息正文。所有其他响应都包括一个消息正文，尽管它的长度可以为零。</target>
        </trans-unit>
        <trans-unit id="a40c2c2dfbf9c25f98c934df39c7f7ed182fe5cf" translate="yes" xml:space="preserve">
          <source>The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for
   all &quot;message&quot; types regarding line length and encodings.

   Type name:  message

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed message (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body.

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted 

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Magic number(s):  N/A

      Deprecated alias names for this type:  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">消息/ http类型可用于封装单个HTTP请求或响应消息，只要它遵守所有有关行长和编码的&amp;ldquo;消息&amp;rdquo;类型的MIME限制。类型名称：message子类型名称：http必需参数：N / A可选参数：version，msgtype version：所包含消息的HTTP版本号（例如&amp;ldquo; 1.1&amp;rdquo;）。如果不存在，则可以从正文的第一行确定版本。 msgtype：消息类型-&amp;ldquo;请求&amp;rdquo;或&amp;ldquo;响应&amp;rdquo;。如果不存在，则可以从主体的第一行确定类型。编码注意事项：仅允许使用&amp;ldquo; 7bit&amp;rdquo;，&amp;ldquo; 8bit&amp;rdquo;或&amp;ldquo; binary&amp;rdquo;安全性注意事项：见&lt;a href=&quot;#section-9&quot;&gt;第9节&lt;/a&gt; 互操作性注意事项：N / A发布的规范：此规范（请参阅&lt;a href=&quot;#section-8.3.1&quot;&gt;第8.3.1节&lt;/a&gt;）。使用此媒体类型的应用程序：N / A片段标识符注意事项：N / A其他信息：幻数：N / A此类型已弃用的别名：N / A文件扩展名：N / A Macintosh文件类型代码：N / A要获取更多信息，请联系个人和电子邮件地址：请参见作者地址部分。预期用途：公共使用限制：N / A作者：请参阅作者地址部分。变更负责人：IESG</target>
        </trans-unit>
        <trans-unit id="0249133f37d2157bb5d5d75cceeb4bf6c3634006" translate="yes" xml:space="preserve">
          <source>The method and the body of the original request are reused to perform the redirected request. In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give an answer to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resources, but a confirmation message (like &quot;You successfully uploaded XYZ&quot;).</source>
          <target state="translated">重用原始请求的方法和主体以执行重定向的请求。在您希望将方法更改为&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 的情况下&lt;/a&gt;，请使用&lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; &lt;/a&gt;。当您想提供一个不是上载资源而是一个确认消息（例如&amp;ldquo;您已成功上载XYZ&amp;rdquo;）的&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;方法的答案时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="9c74b76d94e666b868875958cf478928caee388b" translate="yes" xml:space="preserve">
          <source>The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb5ff63a9c845a973320d106a4e7a8f6258bc0a" translate="yes" xml:space="preserve">
          <source>The method specified in the Request-Line is not allowed for the
   resource identified by the Request-URI. The response MUST include an
   Allow header containing a list of valid methods for the requested
   resource.</source>
          <target state="translated">Request-Line中指定的方法对于Request-URI标识的资源是不允许的。响应必须包含一个Allow头,包含请求资源的有效方法列表。</target>
        </trans-unit>
        <trans-unit id="c61cd0e1f1485b50b5d1e9ad93568afa1f7867e5" translate="yes" xml:space="preserve">
          <source>The misunderstood X-XSS-Protection &amp;ndash; blog.innerht.ml</source>
          <target state="translated">误解的X-XSS-Protection &amp;ndash; blog.innerht.ml</target>
        </trans-unit>
        <trans-unit id="6aa0132e5f88b4993af9157a3eacfea873d280a5" translate="yes" xml:space="preserve">
          <source>The more we use cached resources, the better the responsiveness and the performance of a Web site will be. To optimize this, good practices recommend to set expiration times as far in the future as possible. This is possible on resources that are regularly updated, or often, but is problematic for resources that are rarely and infrequently updated. They are the resources that would benefit the most from caching resources, yet this makes them very difficult to update. This is typical of the technical resources included and linked from each Web pages: JavaScript and CSS files change infrequently, but when they change you want them to be updated quickly.</source>
          <target state="translated">我们使用缓存资源越多,网站的响应速度和性能就越好。为了优化这一点,良好的实践建议将过期时间设置在尽可能远的未来。这在定期更新或经常更新的资源上是可行的,但对于很少更新和不经常更新的资源来说就有问题了。它们是最能从缓存资源中获益的资源,然而这却使它们很难更新。这就是典型的技术资源,包括和每个网页链接的技术资源。JavaScript和CSS文件变化不频繁,但当它们变化时,你希望它们能快速更新。</target>
        </trans-unit>
        <trans-unit id="2b2d80c0ac04c3f4350cef824a1e1156d252f06e" translate="yes" xml:space="preserve">
          <source>The most &quot;original&quot; implementation of PAC and its JavaScript libraries is, therefore, &lt;code&gt;nsProxyAutoConfig.js&lt;/code&gt; found in early versions of Firefox. These utilities are found in many other open-source systems including &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/proxy_resolver/pac_js_library.h&quot;&gt;Chromium&lt;/a&gt;. Firefox later integrated the file into &lt;code&gt;&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/source/netwerk/base/ProxyAutoConfig.cpp&quot;&gt;ProxyAutoConfig.cpp&lt;/a&gt;&lt;/code&gt; as a C++ string literal. To extract it into its own file, it suffices to copy the chunk into JavaScript with a &lt;code&gt;console.log&lt;/code&gt; directive to print it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900a5182069f7643f5a96c3714605f7b28cd3d50" translate="yes" xml:space="preserve">
          <source>The most basic form of lock is an exclusive lock.  Exclusive locks
   avoid having to deal with content change conflicts, without requiring
   any coordination other than the methods described in this
   specification.

   However, there are times when the goal of a lock is not to exclude
   others from exercising an access right but rather to provide a
   mechanism for principals to indicate that they intend to exercise
   their access rights.  Shared locks are provided for this case.  A
   shared lock allows multiple principals to receive a lock.  Hence any
   principal that has both access privileges and a valid lock can use
   the locked resource.

   With shared locks, there are two trust sets that affect a resource.
   The first trust set is created by access permissions.  Principals who
   are trusted, for example, may have permission to write to the
   resource.  Among those who have access permission to write to the
   resource, the set of principals who have taken out a shared lock also
   must trust each other, creating a (typically) smaller trust set
   within the access permission write set.

   Starting with every possible principal on the Internet, in most
   situations the vast majority of these principals will not have write
   access to a given resource.  Of the small number who do have write
   access, some principals may decide to guarantee their edits are free
   from overwrite conflicts by using exclusive write locks.  Others may
   decide they trust their collaborators will not overwrite their work
   (the potential set of collaborators being the set of principals who
   have write permission) and use a shared lock, which informs their
   collaborators that a principal may be working on the resource.

   The WebDAV extensions to HTTP do not need to provide all of the
   communications paths necessary for principals to coordinate their
   activities.  When using shared locks, principals may use any out-of-
   band communication channel to coordinate their work (e.g., face-to-
   face interaction, written notes, post-it notes on the screen,
   telephone conversation, email, etc.)  The intent of a shared lock is
   to let collaborators know who else may be working on a resource.

   Shared locks are included because experience from Web-distributed
   authoring systems has indicated that exclusive locks are often too
   rigid.  An exclusive lock is used to enforce a particular editing
   process: take out an exclusive lock, read the resource, perform
   edits, write the resource, release the lock.  This editing process
   has the problem that locks are not always properly released, for
   example, when a program crashes or when a lock creator leaves without 

   unlocking a resource.  While both timeouts (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;) and
   administrative action can be used to remove an offending lock,
   neither mechanism may be available when needed; the timeout may be
   long or the administrator may not be available.

   A successful request for a new shared lock MUST result in the
   generation of a unique lock associated with the requesting principal.
   Thus, if five principals have taken out shared write locks on the
   same resource, there will be five locks and five lock tokens, one for
   each principal.</source>
          <target state="translated">锁的最基本形式是排他锁。排他锁避免处理内容更改冲突，而不需要本规范中描述的方法以外的任何协调。但是，有时锁定的目的不是要排除其他人行使访问权，而是要为主体提供一种机制，以表明主体打算行使其访问权。在这种情况下提供了共享锁。共享锁允许多个主体接收一个锁。因此，既具有访问权限又具有有效锁定的任何主体都可以使用锁定的资源。使用共享锁，有两个影响资源的信任集。第一个信任集是由访问权限创建的。受信任的校长，例如，可能具有写入资源的权限。在具有写资源访问权限的主体中，已采取共享锁的主体组也必须彼此信任，从而在访问许可写入集中创建一个（通常）较小的信任集。从Internet上的每个可能的主体开始，在大多数情况下，这些主体中的绝大多数将不具有对给定资源的写权限。在确实具有写访问权的少数用户中，某些负责人可能会决定通过使用排他写锁定来确保其编辑不存在覆盖冲突。其他人可能会决定他们相信合作者不会覆盖他们的工作（潜在的合作者集合是具有写许可权的主体集合）并使用共享锁，通知其合作者委托人可能正在使用该资源。 WebDAV对HTTP的扩展不需要提供委托人协调其活动所需的所有通信路径。使用共享锁时，校长可以使用任何带外通信渠道来协调其工作（例如，面对面的交互，书面说明，屏幕上的便笺，电话交谈，电子邮件等）。共享锁的目的是让协作者知道谁可能还在处理资源。之所以包含共享锁，是因为Web分布式创作系统的经验表明，排他锁通常过于僵化。排他锁用于强制执行特定的编辑过程：取出排他锁，读取资源，执行编辑，编写资源，释放锁。此编辑过程存在一个问题，例如，当程序崩溃或当锁创建者在没有解锁资源的情况下离开时，锁并不总是被正确释放。虽然两个超时（&lt;a href=&quot;#section-6.6&quot;&gt;&lt;/a&gt;可以使用第6.6节）和管理措施来删除有问题的锁，必要时两种机制都不可用；超时时间可能很长，或者管理员可能不可用。对新共享锁的成功请求必须导致生成与请求主体相关联的唯一锁。因此，如果五个委托人对同一资源采取了共享写锁，则将有五个锁和五个锁令牌，每个委托人一个。</target>
        </trans-unit>
        <trans-unit id="a156ff3c58c5769ef6c6729d1da6678b0896af60" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme which is introduced in more details below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="translated">最常见的身份验证方案是&amp;ldquo;基本&amp;rdquo;身份验证方案，下面将对其进行详细介绍。IANA维护&lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;身份验证方案&lt;/a&gt;的列表，但是主机服务（例如Amazon AWS）还提供其他方案。常见的身份验证方案包括：</target>
        </trans-unit>
        <trans-unit id="255966f9ca10cd047714babaf260d4a6e24ab848" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme, which is introduced in more detail below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c5a495d4e0bf178a13835396e7d4610c8dd302" translate="yes" xml:space="preserve">
          <source>The most common form of URI is the Uniform Resource Locator (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;), which is known as the &lt;em&gt;web address&lt;/em&gt;.</source>
          <target state="translated">URI的最常见形式是统一资源定位符（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;），即&lt;em&gt;网址&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="441408fdebb55a519d6ec56cfba9f8cfcf41c9d1" translate="yes" xml:space="preserve">
          <source>The most common form of request-target is the origin-form.

     origin-form    = absolute-path [ &quot;?&quot; query ]

   When making a request directly to an origin server, other than a
   CONNECT or server-wide OPTIONS request (as detailed below), a client
   MUST send only the absolute path and query components of the target
   URI as the request-target.  If the target URI's path component is
   empty, the client MUST send &quot;/&quot; as the path within the origin-form of
   request-target.  A Host header field is also sent, as defined in
   &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;.

   For example, a client wishing to retrieve a representation of the
   resource identified as

     http://www.example.org/where?q=now

   directly from the origin server would open (or reuse) a TCP
   connection to port 80 of the host &quot;www.example.org&quot; and send the
   lines:

     GET /where?q=now HTTP/1.1
     Host: www.example.org

   followed by the remainder of the request message.</source>
          <target state="translated">请求目标的最常见形式是起源形式。origin-form =绝对路径[&amp;ldquo;？&amp;rdquo; 当直接向原始服务器发出请求时，除了CONNECT或服务器范围内的OPTIONS请求（如下所述）外，客户端必须仅发送目标URI的绝对路径和查询组件作为请求目标。如果目标URI的路径部分为空，则客户端必须在请求目标的源形式内发送&amp;ldquo; /&amp;rdquo;作为路径。还发送了一个Host标头字段，如 &lt;a href=&quot;#section-5.4&quot;&gt;第5.4节所述&lt;/a&gt;。例如，希望直接从源服务器检索标识为http://www.example.org/where?q=now的资源的表示形式的客户端将打开（或重用）到主机端口80的TCP连接&amp;ldquo; www.example.org&amp;rdquo;并发送以下行：GET / where？q = now HTTP / 1.1主机：www.example.org，后跟请求消息的其余部分。</target>
        </trans-unit>
        <trans-unit id="46ee34a68e260d2ac9a208c1c10ecca4cdb7c99d" translate="yes" xml:space="preserve">
          <source>The most common reason to perform user agent sniffing is to determine which type of device the browser runs on. The goal is to serve different HTML to different device types.</source>
          <target state="translated">执行用户代理嗅探的最常见原因是确定浏览器运行在哪种类型的设备上。目标是向不同的设备类型提供不同的HTML。</target>
        </trans-unit>
        <trans-unit id="61e4993d071956d95f174a16357fd080a1122e7b" translate="yes" xml:space="preserve">
          <source>The most common use case for conditional requests is updating a cache. With an empty cache, or without a cache, the requested resource is sent back with a status of &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">条件请求最常见的用例是更新缓存。在具有空缓存或没有缓存的情况下，以&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 的状态发送回所请求的资源。</target>
        </trans-unit>
        <trans-unit id="63916efe76674061fe4628e66838f4f65d786f1d" translate="yes" xml:space="preserve">
          <source>The most common use case is to resume a download, to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">最常见的用例是恢复下载,以保证存储的资源在收到最后一个片段后没有被修改。</target>
        </trans-unit>
        <trans-unit id="a9d5d6bfeb55ebb232d3c55e050956f34dcf4435" translate="yes" xml:space="preserve">
          <source>The most common use case is to update a cached entity that has no associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最常见的用例是更新没有关联的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;的缓存实体。</target>
        </trans-unit>
        <trans-unit id="f8e294a410237a9ceaa795c432872e161168f9e7" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server. The modern &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;Fetch API&lt;/code&gt;&lt;/a&gt; provides the same features with a more powerful and flexible feature set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e5095bac19f7e957fc81b9fc8a8c4dfee3e4ef" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on top of HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server.</source>
          <target state="translated">基于HTTP的最常用的API是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API，可用于在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;和服务器之间交换数据。</target>
        </trans-unit>
        <trans-unit id="0a53cc937fbb9dc05f3c30062aeb2e10f7633a16" translate="yes" xml:space="preserve">
          <source>The most commonly used MIME types used for web content are listed below. This isn't a complete list of all the types that may be available, however. See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers&quot;&gt;media container formats&lt;/a&gt; guide for that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e318c21bd25e3fadc6435097a45df0a0fc7f22d3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &quot;&lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;&quot; which is the maximum amount of time a resource will be considered fresh. Contrary to &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, this directive is relative to the time of the request. For the files in the application that will not change, you can usually add aggressive caching. This includes static files such as images, CSS files and JavaScript files, for example.</source>
          <target state="translated">此处最重要的指令是&amp;ldquo; &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt; &amp;rdquo;，这是资源被视为新鲜的最长时间。与&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;相反，此指令是相对于请求时间的。对于应用程序中不会更改的文件，通常可以添加主动缓存。例如，这包括静态文件，例如图像，CSS文件和JavaScript文件。</target>
        </trans-unit>
        <trans-unit id="ec18430cf06631edb1cb32f0734bdaa2055f42e3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;, which is the maximum amount of time in which a resource will be considered fresh. This directive is relative to the time of the request, and overrides the &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header (if set). For the files in the application that will not change, you can normally use aggressive caching. This includes static files such as images, CSS files, and JavaScript files, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de54066611634f9bbfbe66c8f61f170f030f4d4" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;和CORS 公开的最有趣的功能是发出&amp;ldquo;凭据&amp;rdquo;请求的功能，这些请求知道&lt;a href=&quot;cookies&quot;&gt;HTTP cookie&lt;/a&gt;和HTTP身份验证信息。默认情况下，在跨站点 &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; 或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;调用中，浏览器将&lt;strong&gt;不&lt;/strong&gt;发送凭据。调用 &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; 对象或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;构造函数时，必须设置特定标志。</target>
        </trans-unit>
        <trans-unit id="1f1f72e7e757ea8a76c23e50644af8cf17ebd184" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1c1a63ba9f8dd30771846a530a5374e05d9e6e" translate="yes" xml:space="preserve">
          <source>The name of a supported request header. The header may list any number of headers, separated by commas.</source>
          <target state="translated">支持的请求头的名称。该头可以列出任何数量的头,用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="0efb14ebcb5f0fce2ff3b286a2ffd2165a867e1e" translate="yes" xml:space="preserve">
          <source>The name of the policy section that was violated.</source>
          <target state="translated">违反的政策部分的名称。</target>
        </trans-unit>
        <trans-unit id="844cb327de813003d80319f4e20e97ec08ef266e" translate="yes" xml:space="preserve">
          <source>The name of the software or (sub) product that handles the requests.</source>
          <target state="translated">处理请求的软件或(子)产品的名称。</target>
        </trans-unit>
        <trans-unit id="d061e432c2a538045e603ec2696ad4093da4b49d" translate="yes" xml:space="preserve">
          <source>The name of the software or product that handled the request. Usually in a format similar to &lt;a href=&quot;user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbecb7545401e92e7f01c19b30802601bc05d85b" translate="yes" xml:space="preserve">
          <source>The name or pseudonym of the server or software adding the &lt;code&gt;Warning&lt;/code&gt; header (might be &quot;-&quot; when the agent is unknown).</source>
          <target state="translated">添加 &lt;code&gt;Warning&lt;/code&gt; 标头的服务器或软件的名称或化名（如果代理未知，则可能为&amp;ldquo;-&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="80bbc4479b72889e3d5c281d5038ca7ef63f0a3b" translate="yes" xml:space="preserve">
          <source>The navigation request was triggered by a user activation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58047e7a458a00060b7fa6474885924a7bbd022e" translate="yes" xml:space="preserve">
          <source>The navigation request was triggered by something other than a user activation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0040305cef3180d6d7255c0c077b8782a6cc726f" translate="yes" xml:space="preserve">
          <source>The next major version of HTTP, HTTP/3, will use QUIC instead TCP/TLS for the transport layer portion.</source>
          <target state="translated">HTTP的下一个主要版本HTTP/3,将使用QUIC代替TCP/TLS来传输层部分。</target>
        </trans-unit>
        <trans-unit id="b8b5231ea957c239b67921ea4d3ca6986e579896" translate="yes" xml:space="preserve">
          <source>The non-Chromium Edge puts its engine version after the &lt;em&gt;Edge/&lt;/em&gt; token, not the application version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a49012952b5d13c3bc899a210b34a7392e5f266" translate="yes" xml:space="preserve">
          <source>The non-standard &lt;code&gt;Large-Allocation&lt;/code&gt; response header tells the browser that the page being loaded is going to want to perform a large allocation. It is currently only implemented in Firefox, but is harmless to send to every browser.</source>
          <target state="translated">非标准的 &lt;code&gt;Large-Allocation&lt;/code&gt; 响应标头告诉浏览器正在加载的页面要执行大分配。它目前仅在Firefox中实现，但发送到每个浏览器都无害。</target>
        </trans-unit>
        <trans-unit id="ba5026e86262d6245f07b3191a146bd8bb62bfc9" translate="yes" xml:space="preserve">
          <source>The notion of HTTP headers has been introduced, both for the requests and the responses, allowing metadata to be transmitted and making the protocol extremely flexible and extensible.</source>
          <target state="translated">无论是请求还是响应,都引入了HTTP头的概念,允许传输元数据,使协议变得极其灵活和可扩展。</target>
        </trans-unit>
        <trans-unit id="5a8511f9154b7d1710ad96380db408589218a6d1" translate="yes" xml:space="preserve">
          <source>The number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host of the received message as a known &lt;code&gt;Expect-CT&lt;/code&gt; host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c597b22723fbfd913584650ba834a8d38d96da2" translate="yes" xml:space="preserve">
          <source>The number of seconds for which the alternative service is considered fresh. If omitted, it defaults to 24 hours. Alternative service entries can be cached for up to &lt;em&gt;&amp;lt;max-age&amp;gt;&lt;/em&gt; seconds, minus the age of the response (from the &lt;a href=&quot;age&quot;&gt;&lt;code&gt;Age&lt;/code&gt;&lt;/a&gt; header). If the cached entry expires, the client can no longer use this alternative service for new connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebe7f3b1e1476fa1411cff9686fdc49ff3da815" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt;&lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;  directive.</source>
          <target state="translated">过时的&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt; &lt;code&gt;referrer&lt;/code&gt; &lt;/a&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="8ee97cde545a5282f8eb8711464102b13b2f6dec" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Cookie2&lt;/code&gt; HTTP request header used to advise the server that the user agent understands &quot;new-style&quot; cookies, but nowadays user agents will use the &lt;a href=&quot;cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header instead, not this one.</source>
          <target state="translated">&lt;code&gt;Cookie2&lt;/code&gt; HTTP请求标头已过时，用于通知服务器用户代理可以理解&amp;ldquo;新型&amp;rdquo; cookie，但是如今，用户代理将改用&lt;a href=&quot;cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;标头，而不是此标头。</target>
        </trans-unit>
        <trans-unit id="33c769b0c666a82869a02203951c2b8b5edec421" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP response header used to send cookies from the server to the user agent, but has been deprecated by the specification. Use &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">用于将cookie从服务器发送到用户代理的过时的 &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP响应标头，但已被规范弃用。请改用&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd9be51f044c110f50b29c3226b55ae882be5f1e" translate="yes" xml:space="preserve">
          <source>The only allowed methods are:</source>
          <target state="translated">唯一允许的方法是:</target>
        </trans-unit>
        <trans-unit id="cc061ae17eb93f938e35cb15516a270a95c70f3c" translate="yes" xml:space="preserve">
          <source>The only allowed values for the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header are:</source>
          <target state="translated">&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;标头的唯一允许值为：</target>
        </trans-unit>
        <trans-unit id="12f64d0b6bf68050154b5d92dd4e2be1345a3197" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;307&lt;/code&gt; and &lt;a href=&quot;302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;307&lt;/code&gt; guarantees that the method and the body will not be changed when the redirected request is made. With &lt;code&gt;302&lt;/code&gt;, some old clients were incorrectly changing the method to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;: the behavior with non-&lt;code&gt;GET&lt;/code&gt; methods and &lt;code&gt;302&lt;/code&gt; is then unpredictable on the Web, whereas the behavior with &lt;code&gt;307&lt;/code&gt; is predictable. For &lt;code&gt;GET&lt;/code&gt; requests, their behavior is identical.</source>
          <target state="translated">&lt;code&gt;307&lt;/code&gt; 和&lt;a href=&quot;302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt;之间的唯一区别是 &lt;code&gt;307&lt;/code&gt; 保证在发出重定向请求时，方法和主体不会更改。随着 &lt;code&gt;302&lt;/code&gt; ，一些老客户被错误地改变的方法&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;：与非的行为 &lt;code&gt;GET&lt;/code&gt; 方法和 &lt;code&gt;302&lt;/code&gt; 然后在网络上不可预测的，而与行为 &lt;code&gt;307&lt;/code&gt; 是可预测的。对于 &lt;code&gt;GET&lt;/code&gt; 请求，它们的行为是相同的。</target>
        </trans-unit>
        <trans-unit id="d4019eec51fe05092ad2db95b5b089e76d4b1742" translate="yes" xml:space="preserve">
          <source>The only expectation defined in the specification is &lt;code&gt;Expect: 100-continue&lt;/code&gt;, to which the server shall respond with:</source>
          <target state="translated">规范中定义的唯一期望是 &lt;code&gt;Expect: 100-continue&lt;/code&gt; ，服务器应使用以下响应：</target>
        </trans-unit>
        <trans-unit id="8582b84a04fd3c0703aeb779483786b9e1fec4ab" translate="yes" xml:space="preserve">
          <source>The only valid value for this header is &lt;code&gt;true&lt;/code&gt; (case-sensitive). If you don't need credentials, omit this header entirely (rather than setting its value to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">此标头的唯一有效值为 &lt;code&gt;true&lt;/code&gt; （区分大小写）。如果不需要凭据，请完全忽略此标头（而不是将其值设置为 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="57e0edd3cec8916417007e47f389d457d3b92156" translate="yes" xml:space="preserve">
          <source>The order in which header fields with differing field names are
   received is not significant.  However, it is good practice to send
   header fields that contain control data first, such as Host on
   requests and Date on responses, so that implementations can decide
   when not to handle a message as early as possible.  A server MUST NOT
   apply a request to the target resource until the entire request 

   header section is received, since later header fields might include
   conditionals, authentication credentials, or deliberately misleading
   duplicate header fields that would impact request processing.

   A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).

   A recipient MAY combine multiple header fields with the same field
   name into one &quot;field-name: field-value&quot; pair, without changing the
   semantics of the message, by appending each subsequent field value to
   the combined field value in order, separated by a comma.  The order
   in which header fields with the same field name are received is
   therefore significant to the interpretation of the combined field
   value; a proxy MUST NOT change the order of these field values when
   forwarding a message.

      Note: In practice, the &quot;Set-Cookie&quot; header field ([&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]) often
      appears multiple times in a response message and does not use the
      list syntax, violating the above requirements on multiple header
      fields with the same name.  Since it cannot be combined into a
      single field-value, recipients ought to handle &quot;Set-Cookie&quot; as a
      special case while processing header fields.  (See &lt;a href=&quot;#appendix-A.2.3&quot;&gt;Appendix A.2.3&lt;/a&gt;
      of [&lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;] for details.)</source>
          <target state="translated">具有不同字段名称的头字段的接收顺序并不重要。但是，优良作法是首先发送包含控制数据的标头字段，例如&amp;ldquo; Host on request&amp;rdquo;和&amp;ldquo; Date on response&amp;rdquo;，以便实现可以决定何时不尽早处理消息。在接收到整个请求标头部分之前，服务器不得将请求应用于目标资源，因为后面的标头字段可能包括条件，身份验证凭据或故意误导重复的标头字段，这会影响请求处理。发件人不得在消息中生成具有相同字段名称的多个标头字段，除非该标头字段的整个字段值都定义为以逗号分隔的列表[即，＃（values）]或标头字段是众所周知的异常（如下所述）。接收者可以通过将每个随后的字段值按顺序附加到合并的字段值上并用逗号分隔，将具有相同字段名的多个报头字段组合成一对&amp;ldquo;字段名：字段值&amp;rdquo;，而不会改变消息的语义。逗号。因此，接收具有相同字段名称的头字段的顺序对于组合字段值的解释很重要。代理转发消息时不得更改这些字段值的顺序。注意：实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[通过将每个后续字段值按顺序附加到组合的字段值（以逗号分隔），而无需更改消息的语义。因此，接收具有相同字段名称的头字段的顺序对于组合字段值的解释很重要。代理转发消息时不得更改这些字段值的顺序。注意：实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[通过将每个后续字段值按顺序附加到组合的字段值（以逗号分隔），而无需更改消息的语义。因此，接收具有相同字段名称的头字段的顺序对于组合字段值的解释很重要。代理转发消息时不得更改这些字段值的顺序。注意：实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[实际上，&amp;ldquo; Set-Cookie&amp;rdquo;标题字段（[&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]）通常在响应消息中出现多次，并且不使用列表语法，这违反了对具有相同名称的多个标头字段的上述要求。由于不能将其组合为单个字段值，因此收件人在处理标头字段时应作为特殊情况处理&amp;ldquo; Set-Cookie&amp;rdquo;。（有关详细信息，请参见 [ &lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt; ]的&lt;a href=&quot;#appendix-A.2.3&quot;&gt;附录A.2.3&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="18149c10ff86aae91ec06cd0aef8f5de4440363f" translate="yes" xml:space="preserve">
          <source>The origin is a URI indicating the server from which the request initiated. It does not include any path information, but only the server name.</source>
          <target state="translated">origin是一个URI,表示请求是从哪个服务器发起的,它不包括任何路径信息,只包括服务器名称。它不包括任何路径信息,只包括服务器名称。</target>
        </trans-unit>
        <trans-unit id="26e7668fe582d80ecc70504dac9a50d81f54d606" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="translated">源服务器要求请求是有条件的。目的是为了防止 &quot;丢失更新 &quot;的问题,即客户端GET一个资源的状态,修改它,然后把它送回服务器,而与此同时,第三方已经修改了服务器上的状态,从而导致冲突。</target>
        </trans-unit>
        <trans-unit id="73f93eb007ff12547887950cf639f167d2aeb94c" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. This response is intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28b7e0ef7daf83cb81a618727021028721dfa63" translate="yes" xml:space="preserve">
          <source>The original WebDAV model for locking unmapped URLs created &quot;lock-
   null resources&quot;.  This model was over-complicated and some
   interoperability and implementation problems were discovered.  The
   new WebDAV model for locking unmapped URLs (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;) creates
   &quot;locked empty resources&quot;.  Lock-null resources are deprecated.  This
   section discusses the original model briefly because clients MUST be
   able to handle either model.

   In the original &quot;lock-null resource&quot; model, which is no longer
   recommended for implementation:

   o  A lock-null resource sometimes appeared as &quot;Not Found&quot;.  The
      server responds with a 404 or 405 to any method except for PUT,
      MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK.

   o  A lock-null resource does however show up as a member of its
      parent collection.

   o  The server removes the lock-null resource entirely (its URI
      becomes unmapped) if its lock goes away before it is converted to
      a regular resource.  Recall that locks go away not only when they
      expire or are unlocked, but are also removed if a resource is
      renamed or moved, or if any parent collection is renamed or moved. 

   o  The server converts the lock-null resource into a regular resource
      if a PUT request to the URL is successful.

   o  The server converts the lock-null resource into a collection if a
      MKCOL request to the URL is successful (though interoperability
      experience showed that not all servers followed this requirement).

   o  Property values were defined for DAV:lockdiscovery and DAV:
      supportedlock properties but not necessarily for other properties
      like DAV:getcontenttype.

   Clients can easily interoperate both with servers that support the
   old model &quot;lock-null resources&quot; and the recommended model of &quot;locked
   empty resources&quot; by only attempting PUT after a LOCK to an unmapped
   URL, not MKCOL or GET.</source>
          <target state="translated">用于锁定未映射URL的原始WebDAV模型创建了&amp;ldquo;锁定空资源&amp;rdquo;。该模型过于复杂，并且发现了一些互操作性和实现问题。用于锁定未映射URL的新WebDAV模型（请参见&lt;a href=&quot;#section-7.3&quot;&gt;7.3节）&lt;/a&gt;）创建&amp;ldquo;锁定的空资源&amp;rdquo;。不推荐使用空锁资源。本节简要讨论原始模型，因为客户端必须能够处理任何一个模型。在原始的&amp;ldquo;锁空资源&amp;rdquo;模型中，不再建议实施该模型：o锁空资源有时显示为&amp;ldquo;未找到&amp;rdquo;。服务器以404或405响应除PUT，MKCOL，OPTIONS，PROPFIND，LOCK和UNLOCK之外的任何方法。 o锁空资源确实会显示为其父集合的成员。 o如果服务器的锁在转换为常规资源之前消失了，则服务器将完全删除该锁为空的资源（其URI变为未映射）。回想一下，锁不仅会在过期或解锁时消失，但如果重命名或移动资源，或者重命名或移动任何父集合，也会被删除。 o如果对URL的PUT请求成功，则服务器会将空锁资源转换为常规资源。 o如果对URL的MKCOL请求成功，则服务器会将锁空资源转换为集合（尽管互操作性经验表明并非所有服务器都遵循此要求）。 o为DAV：lockdiscovery和DAV：supportedlock属性定义了属性值，但未为DAV：getcontenttype等其他属性定义属性值。客户端可以轻松地与支持旧模型&amp;ldquo;锁定空资源&amp;rdquo;和建议模型&amp;ldquo;锁定空资源&amp;rdquo;的服务器进行互操作。通过仅在锁定到未映射的URL（而不是MKCOL或GET）之后尝试PUT。</target>
        </trans-unit>
        <trans-unit id="bd67e38aa52dda3f2ef7884d2b5f132dc5a16c44" translate="yes" xml:space="preserve">
          <source>The original header name &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; is a misspelling of the word &quot;referrer&quot;. The &lt;code&gt;Referrer-Policy&lt;/code&gt; header does not share this misspelling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351291dcc2c8f40b6fda3d0b9fb11a63f52c019f" translate="yes" xml:space="preserve">
          <source>The original model of HTTP, and the default one in HTTP/1.0, is &lt;em&gt;short-lived connections&lt;/em&gt;. Each HTTP request is completed on its own connection; this means a TCP handshake happens before each HTTP request, and these are serialized.</source>
          <target state="translated">HTTP的原始模型（即HTTP / 1.0中的默认模型）是&lt;em&gt;短期连接&lt;/em&gt;。每个HTTP请求都在其自己的连接上完成；这意味着TCP握手在每个HTTP请求之前发生，并且已被序列化。</target>
        </trans-unit>
        <trans-unit id="79e460eb743f85621e4024af0b7bff004e6c3d39" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP header.</source>
          <target state="translated">由 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP标头指定的原始策略。</target>
        </trans-unit>
        <trans-unit id="4893fed57017b899f622f28734ae6d2fe80b3b77" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP header.</source>
          <target state="translated">由 &lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP标头指定的原始策略。</target>
        </trans-unit>
        <trans-unit id="65440960b2a3f39f3e1fd7555605568089a8d96a" translate="yes" xml:space="preserve">
          <source>The original vision of Tim Berners-Lee for the Web wasn't a read-only medium. He envisioned a Web where people can add and move documents remotely, a kind of distributed file system. Around 1996, HTTP has been extended to allow authoring, and a standard called WebDAV was created. It has been further extended for specific applications like CardDAV to handle address book entries and CalDAV to deal with calendars. But all these *DAV extensions had a flaw: they had to be implemented by the servers to be used, which was quite complex. Their use on Web realms stayed confidential.</source>
          <target state="translated">蒂姆-伯纳斯-李最初对网络的设想并不是一个只读的媒介。他设想的Web是人们可以远程添加和移动文档,是一种分布式文件系统。大约在1996年,HTTP已经被扩展到允许编写,并创建了一个名为WebDAV的标准。它被进一步扩展到特定的应用中,比如CardDAV处理地址簿条目,CalDAV处理日历。但所有这些*DAV扩展都有一个缺陷:它们必须由服务器来实现才能使用,这相当复杂。它们在网络领域的使用是保密的。</target>
        </trans-unit>
        <trans-unit id="ec62cbdca93d2ad4ec39377f99d81883dfe1d146" translate="yes" xml:space="preserve">
          <source>The output will look something like this:</source>
          <target state="translated">输出将是这样的。</target>
        </trans-unit>
        <trans-unit id="aa47362e2b58ce7c1d4859c59d1d577c32eab05a" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the same origin as the page itself. The spec leaves it up to browser vendors to decide whether this option applies to the top level, the parent, or the whole chain, although it is argued that the option is not very useful unless all ancestors are also in the same origin (see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;bug 725490&lt;/a&gt;). Also see &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; for support details.</source>
          <target state="translated">该页面只能以与页面本身相同的原点显示在框架中。该规范由浏览器供应商决定该选项是适用于顶层，父级还是整个链，尽管有人认为该选项不是很有用，除非所有祖先的起源都相同（请参见&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;错误） 725490&lt;/a&gt;）。另请参阅&lt;a href=&quot;#Browser_compatibility&quot;&gt;浏览器兼容性&lt;/a&gt;以获取支持详细信息。</target>
        </trans-unit>
        <trans-unit id="87ed0031ffdd1f701402da552456ef09ffc21cb3" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the specified origin. Note that in Firefox this still suffers from the same problem as &lt;code&gt;sameorigin&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin.</source>
          <target state="translated">该页面只能显示在指定原点的框架中。请注意，在Firefox中，这仍然遇到与 &lt;code&gt;sameorigin&lt;/code&gt; 相同的问题-它不会检查框架祖先是否起源于同一来源。</target>
        </trans-unit>
        <trans-unit id="6fd708bba3250a928bde72e278816558269ceee3" translate="yes" xml:space="preserve">
          <source>The page cannot be displayed in a frame, regardless of the site attempting to do so.</source>
          <target state="translated">无论网站是否试图这样做,该页面都不能在框架中显示。</target>
        </trans-unit>
        <trans-unit id="7e65beef9355c724f3b8565f6ab1fad05b9ee018" translate="yes" xml:space="preserve">
          <source>The parameters &quot;filename&quot; and &quot;filename*&quot; differ only in that &quot;filename*&quot; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &quot;filename&quot; and &quot;filename*&quot; are present in a single header field value, &quot;filename*&quot; is preferred over &quot;filename&quot; when both are understood.</source>
          <target state="translated">参数&amp;ldquo; filename&amp;rdquo;和&amp;ldquo; filename *&amp;rdquo;的区别仅在于&amp;ldquo; filename *&amp;rdquo;使用&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987中&lt;/a&gt;定义的编码。如果在单个标头字段值中同时存在&amp;ldquo;文件名&amp;rdquo;和&amp;ldquo;文件名*&amp;rdquo;，则当两者都理解时，&amp;ldquo;文件名*&amp;rdquo;比&amp;ldquo;文件名&amp;rdquo;更可取。</target>
        </trans-unit>
        <trans-unit id="acecd71c2fad3b28645f1a60d768a752cf9279b0" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; differ only in that &lt;code&gt;filename*&lt;/code&gt; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; are present in a single header field value, &lt;code&gt;filename*&lt;/code&gt; is preferred over &lt;code&gt;filename&lt;/code&gt; when both are understood.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73b0f673ad4f6ff6cd78d437d63486d3077a18d" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">要获取的资源的路径；资源的URL从上下文中显而易见的元素中剥离出来，例如，没有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;协议&lt;/a&gt;（ &lt;code&gt;http://&lt;/code&gt; ），&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;域&lt;/a&gt;（此处为 &lt;code&gt;developer.mozilla.org&lt;/code&gt; ）或TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;端口&lt;/a&gt;（此处为 &lt;code&gt;80&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d2379dd36e7935200c9bebfe54ad165f2211a593" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here, &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here, &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99d23287797e1b6634cb61b5bed379b6d4f6060" translate="yes" xml:space="preserve">
          <source>The payload of a SETTINGS frame consists of zero or more parameters,
   each consisting of an unsigned 16-bit setting identifier and an
   unsigned 32-bit value.

    +-------------------------------+
    |       Identifier (16)         |
    +-------------------------------+-------------------------------+
    |                        Value (32)                             |
    +---------------------------------------------------------------+

                         Figure 10: Setting Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d24dd0cdd0a56d270ae234ba2ae51b6e5cb97c" translate="yes" xml:space="preserve">
          <source>The performance of web sites and applications can be significantly improved by reusing previously fetched resources. Web caches reduce latency and network traffic and thus lessen the time needed to display a representation of a resource. By making use of HTTP caching, Web sites become more responsive.</source>
          <target state="translated">通过重复使用以前获取的资源,可以显著提高网站和应用程序的性能。网络缓存减少了延迟和网络流量,从而减少了显示资源表示所需的时间。通过利用HTTP缓存,Web网站的响应速度变得更快。</target>
        </trans-unit>
        <trans-unit id="4ef7dc4ef4177a90ccc5fba5f3743824b87bfd8e" translate="yes" xml:space="preserve">
          <source>The policy is a string containing the policy directives describing your Content Security Policy.</source>
          <target state="translated">策略是一个字符串,包含描述您的内容安全策略的策略指令。</target>
        </trans-unit>
        <trans-unit id="04ca5099ed1ac07e8e246737ce5ea3bb570048a1" translate="yes" xml:space="preserve">
          <source>The policy is only effective for &lt;a href=&quot;https://fetch.spec.whatwg.org/#concept-request-mode&quot;&gt;&lt;samp&gt;no-cors&lt;/samp&gt;&lt;/a&gt; requests, which are issued by default for CORS-safelisted methods/headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cde3605fdc2afc6de4d0a52e9aa9896f47fafaf" translate="yes" xml:space="preserve">
          <source>The policy:</source>
          <target state="translated">该政策:</target>
        </trans-unit>
        <trans-unit id="776afe838427d09cf840d7fc30aa63d4eaa2c3d9" translate="yes" xml:space="preserve">
          <source>The precondition given in one or more of the request-header fields
   evaluated to false when it was tested on the server. This response
   code allows the client to place preconditions on the current resource
   metainformation (header field data) and thus prevent the requested
   method from being applied to a resource other than the one intended.</source>
          <target state="translated">在服务器上测试时,一个或多个请求头字段中给出的前提条件被评估为false。这个响应代码允许客户机对当前的资源元信息(头字段数据)设置先决条件,从而防止所请求的方法被应用于目标资源以外的资源。</target>
        </trans-unit>
        <trans-unit id="82d265543b246e66360f0830a564b27c84119c7f" translate="yes" xml:space="preserve">
          <source>The preferred way to target content to a device form factor is to use CSS Media Queries. However, if you use UA sniffing to target content to a device form factor, please look for &lt;strong&gt;Mobi&lt;/strong&gt; (to include Opera Mobile, which uses &quot;Mobi&quot;) for the phone form factor and do &lt;strong&gt;not&lt;/strong&gt; assume any correlation between &quot;Android&quot; and the device form factor. This way, your code will work if/when Firefox ships on other phone/tablet operating systems or Android is used for laptops. Also, please use touch detection to find touch devices rather than looking for &quot;Mobi&quot; or &quot;Tablet&quot;, since there may be touch devices which are not tablets.</source>
          <target state="translated">将内容定位到设备尺寸的首选方法是使用CSS Media Queries。但是，如果您使用UA嗅探目标内容到设备的外形尺寸，请认准&lt;strong&gt;摩比&lt;/strong&gt;（包括Opera移动，它采用&amp;ldquo;牧高笛&amp;rdquo;）手机的外形和你&lt;strong&gt;没有&lt;/strong&gt;承担的&amp;ldquo;Android&amp;rdquo;和器件之间的任何关联构成因素。这样，如果/当Firefox在其他电话/平板电脑操作系统上附带或Android用于笔记本电脑时，您的代码将起作用。另外，请使用触摸检测来查找触摸设备，而不要查找&amp;ldquo; Mobi&amp;rdquo;或&amp;ldquo;平板电脑&amp;rdquo;，因为可能存在不是平板电脑的触摸设备。</target>
        </trans-unit>
        <trans-unit id="3f39eef261f64576ec5b25a729b1ec139f8018df" translate="yes" xml:space="preserve">
          <source>The preflight request below tells the server that we want to send a CORS &lt;code&gt;GET&lt;/code&gt; request that has the headers listed in &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;x-requested-with&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="336e39ad55330caf3f7eb800fefcd2e0dc7dd455" translate="yes" xml:space="preserve">
          <source>The preflight request simply suffered any kind of networking error that might ordinarily occur.</source>
          <target state="translated">飞行前的请求只是遭受了任何一种通常可能发生的网络错误。</target>
        </trans-unit>
        <trans-unit id="debdc150f8d10727246ce79b174d0a3a9962d2c4" translate="yes" xml:space="preserve">
          <source>The previous example was illegal because it contained two elements
   that were explicitly banned from appearing together in the propfind
   element.  However, XML is an extensible language, so one can imagine
   new elements being defined for use with propfind.  Below is the
   request body of a PROPFIND and, like the previous example, must be
   rejected with a 400 (Bad Request) by a server that does not
   understand the expired-props element.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
      xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;E:expired-props/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   To understand why a 400 (Bad Request) is returned, let us look at the
   request body as the server unfamiliar with expired-props sees it.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   As the server does not understand the 'expired-props' element,
   according to the WebDAV-specific XML processing rules specified in
   &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;, it must process the request as if the element were not
   there.  Thus, the server sees an empty propfind, which by the
   definition of the propfind element is illegal.

   Please note that had the extension been additive, it would not
   necessarily have resulted in a 400 (Bad Request).  For example,
   imagine the following request body for a PROPFIND:


      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;D:propname/&amp;gt;
       &amp;lt;E:leave-out&amp;gt;*boss*&amp;lt;/E:leave-out&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The previous example contains the fictitious element leave-out.  Its
   purpose is to prevent the return of any property whose name matches
   the submitted pattern.  If the previous example were submitted to a
   server unfamiliar with 'leave-out', the only result would be that the
   'leave-out' element would be ignored and a propname would be
   executed.</source>
          <target state="translated">前面的示例是非法的，因为它包含两个元素，这些元素被明确禁止在propfind元素中一起出现。但是，XML是一种可扩展的语言，因此可以想象定义了供propfind使用的新元素。以下是PROPFIND的请求正文，并且与前面的示例一样，不了解expired-props元素的服务器必须使用400（错误请求）将其拒绝。 &amp;lt;？xml版本=&amp;ldquo; 1.0&amp;rdquo;编码=&amp;ldquo; utf-8&amp;rdquo;吗？&amp;gt; &amp;lt;D：属性xmlns：D =&amp;ldquo; DAV：&amp;rdquo; xmlns：E =&amp;ldquo; http://www.example.com/standards/props/&amp;rdquo;&amp;gt; &amp;lt;E：expired-props /&amp;gt; &amp;lt;/ D：propfind&amp;gt;要了解为什么返回400（错误请求）的原因，让我们看一下请求正文，因为不熟悉expire-props的服务器会看到它。 &amp;lt;？xml版本=&amp;ldquo; 1.0&amp;rdquo;编码=&amp;ldquo; utf-8&amp;rdquo;？&amp;gt; &amp;lt;D：属性xmlns：D =&amp;ldquo; DAV：&amp;rdquo; xmlns：E =&amp;ldquo; http://www.example.com/standards/props/&amp;rdquo;&amp;gt; &amp;lt; / D：propfind&amp;gt;由于服务器无法理解'expired-props'元素，因此请根据在WebDAV中指定的XML处理规则 &lt;a href=&quot;#section-17&quot;&gt;第17节&lt;/a&gt;，它必须像处理元素不存在一样处理请求。因此，服务器看到一个空的propfind，根据propfind元素的定义，这是非法的。请注意，如果扩展名是加性的，则不一定会导致400（错误请求）。例如，假设对PROPFIND的以下请求正文：&amp;lt;？xml version =&amp;ldquo; 1.0&amp;rdquo; encoding =&amp;ldquo; utf-8&amp;rdquo;？&amp;gt; &amp;lt;D：propfind xmlns：D =&amp;ldquo; DAV：&amp;rdquo; xmlns：E =&amp;ldquo; http：// www.example.com/standards/props /&amp;ldquo;&amp;gt; &amp;lt;D：propname /&amp;gt; &amp;lt;E：leave-out&amp;gt; * boss * &amp;lt;/ E：leave-out&amp;gt; &amp;lt;/ D：propfind&amp;gt;上一个示例包含假想元素出来其目的是防止返回名称与提交的模式匹配的任何属性。如果将先前的示例提交给不熟悉&amp;ldquo; leave-out&amp;rdquo;的服务器，则唯一的结果是将忽略&amp;ldquo; leave-out&amp;rdquo;元素并执行属性名。</target>
        </trans-unit>
        <trans-unit id="1ae30a0f00a7837d72ecd861dd4a6d9fd65f4447" translate="yes" xml:space="preserve">
          <source>The primary changes in this revision have been editorial in nature:
   extracting the messaging syntax and partitioning HTTP semantics into
   separate documents for the core features, conditional requests,
   partial requests, caching, and authentication.  The conformance
   language has been revised to clearly target requirements and the
   terminology has been improved to distinguish payload from
   representations and representations from resources.

   A new requirement has been added that semantics embedded in a URI be
   disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   An algorithm has been added for determining if a payload is
   associated with a specific identifier.  (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;)

   The default charset of ISO-8859-1 for text media types has been
   removed; the default is now whatever the media type definition says.
   Likewise, special treatment of ISO-8859-1 has been removed from the
   Accept-Charset header field.  (&lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; and &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;)

   The definition of Content-Location has been changed to no longer
   affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;)

   To be consistent with the method-neutral parsing algorithm of
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], the definition of GET has been relaxed so that requests
   can have a body, even though a body has no meaning for GET.
   (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;)

   Servers are no longer required to handle all Content-* header fields
   and use of Content-Range has been explicitly banned in PUT requests.
   (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;)

   Definition of the CONNECT method has been moved from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;] to
   this specification.  (&lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt;)

   The OPTIONS and TRACE request methods have been defined as being
   safe.  (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; and &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) 

   The Expect header field's extension mechanism has been removed due to
   widely-deployed broken implementations.  (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)

   The Max-Forwards header field has been restricted to the OPTIONS and
   TRACE methods; previously, extension methods could have used it as
   well.  (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;)

   The &quot;about:blank&quot; URI has been suggested as a value for the Referer
   header field when no referring URI is applicable, which distinguishes
   that case from others where the Referer field is not sent or has been
   removed.  (&lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;)

   The following status codes are now cacheable (that is, they can be
   stored and reused by a cache without explicit freshness information
   present): 204, 404, 405, 414, 501.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)

   The 201 (Created) status description has been changed to allow for
   the possibility that more than one resource has been created.
   (&lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;)

   The definition of 203 (Non-Authoritative Information) has been
   broadened to include cases of payload transformations as well.
   (&lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;)

   The set of request methods that are safe to automatically redirect is
   no longer closed; user agents are able to make that determination
   based upon the request method semantics.  The redirect status codes
   301, 302, and 307 no longer have normative requirements on response
   payloads and user interaction.  (&lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;)

   The status codes 301 and 302 have been changed to allow user agents
   to rewrite the method from POST to GET.  (Sections &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; and &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;)

   The description of the 303 (See Other) status code has been changed
   to allow it to be cached if explicit freshness information is given,
   and a specific definition has been added for a 303 response to GET.
   (&lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;)

   The 305 (Use Proxy) status code has been deprecated due to security
   concerns regarding in-band configuration of a proxy.  (&lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;)

   The 400 (Bad Request) status code has been relaxed so that it isn't
   limited to syntax errors.  (&lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;)

   The 426 (Upgrade Required) status code has been incorporated from
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;].  (&lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;) 

   The target of requirements on HTTP-date and the Date header field
   have been reduced to those systems generating the date, rather than
   all systems sending a date.  (&lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;)

   The syntax of the Location header field has been changed to allow all
   URI references, including relative references and fragments, along
   with some clarifications as to when use of fragments would not be
   appropriate.  (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;)

   Allow has been reclassified as a response header field, removing the
   option to specify it in a PUT request.  Requirements relating to the
   content of Allow have been relaxed; correspondingly, clients are not
   required to always trust its value.  (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;)

   A Method Registry has been defined.  (&lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;)

   The Status Code Registry has been redefined by this specification;
   previously, it was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.
   (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;)

   Registration of content codings has been changed to require IETF
   Review.  (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;)

   The Content-Disposition header field has been removed since it is now
   defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt;].

   The Content-MD5 header field has been removed because it was
   inconsistently implemented with respect to partial responses.</source>
          <target state="translated">此修订版的主要更改本质上是编辑性的：提取消息传递语法并将HTTP语义划分为用于核心功能，条件请求，部分请求，缓存和身份验证的单独文档。对符合性语言进行了修订，以明确地针对需求，并且对术语进行了改进，以区分有效载荷与表示形式以及资源与表示形式。添加了新要求，即当那些语义与请求方法不一致时，禁用嵌入在URI中的语义，因为这是互操作性失败的常见原因。 （&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;）添加了一种算法，用于确定有效载荷是否与特定标识符相关联。 （&lt;a href=&quot;#section-3.1.4.1&quot;&gt;第3.1.4.1节&lt;/a&gt;）已删除文本媒体类型的默认ISO-8859-1字符集；现在，默认值是媒体类型定义说的内容。同样，已从Accept-Charset标头字段中删除了对ISO-8859-1的特殊处理。 （&lt;a href=&quot;#section-3.1.1.3&quot;&gt;第3.1.1.3节&lt;/a&gt;和&lt;a href=&quot;#section-5.3.3&quot;&gt;第5.3.3节&lt;/a&gt;）由于实施支持不佳以及可能破坏内容中相对链接的不良影响，已更改Content-Location的定义，使其不再影响解析相对URI引用的基本URI。协商资源。 （&lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt;）与[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;的方法无关的解析算法一致]，则放宽了GET的定义，即使主体对GET没有意义，请求也可以具有主体。 （&lt;a href=&quot;#section-4.3.1&quot;&gt;第4.3.1节&lt;/a&gt;）不再要求服务器处理所有Content- *标头字段，并且PUT请求中已明确禁止使用Content-Range。 （&lt;a href=&quot;#section-4.3.4&quot;&gt;第4.3.4节&lt;/a&gt;）CONNECT方法的定义已从[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]移至本规范。 （&lt;a href=&quot;#section-4.3.6&quot;&gt;第4.3.6节&lt;/a&gt;）OPTIONS和TRACE请求方法已定义为安全的。 （&lt;a href=&quot;#section-4.3.7&quot;&gt;第4.3.7节&lt;/a&gt;和&lt;a href=&quot;#section-4.3.8&quot;&gt;第4.3.8节&lt;/a&gt;）由于广泛采用的破坏性实现，Expect标头字段的扩展机制已删除。 （&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt;）Max-Forwards标头字段仅限于OPTIONS和TRACE方法；以前，扩展方法也可以使用它。 （&lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1.2节&lt;/a&gt;）当没有引用URI适用时，建议将&amp;ldquo; about：blank&amp;rdquo; URI用作Referer头字段的值，这可以将这种情况与没有发送或已删除Referer字段的其他情况区分开。 （&lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt;）现在，以下状态代码是可缓存的（即，可以在不存在显式新鲜度信息的情况下由缓存存储和重用它们）：204、404、405、414、501。（&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）201（已更改状态描述，以允许创建多个资源的可能性。 （&lt;a href=&quot;#section-6.3.2&quot;&gt;第6.3.2节&lt;/a&gt;）203（非权威性信息）的定义已扩展到包括有效负载转换的情况。 （&lt;a href=&quot;#section-6.3.4&quot;&gt;第6.3.4节&lt;/a&gt;）安全关闭的自动重定向请求方法集不再关闭；用户代理能够基于请求方法的语义进行该确定。重定向状态代码301、302和307不再对响应有效负载和用户交互具有规范性要求。 （&lt;a href=&quot;#section-6.4&quot;&gt;第6.4节&lt;/a&gt;）状态代码301和302已更改，以允许用户代理将方法从POST重写为GET。 （第&lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt;和&lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;节）状态303（请参阅其他）状态代码的描述已更改，以便在给出明确的新鲜度信息时可以对其进行缓存，并且已为303对GET的响应添加了特定的定义。 （&lt;a href=&quot;#section-6.4.4&quot;&gt;第6.4.4节&lt;/a&gt;）由于与代理的带内配置有关的安全问题，不建议使用305（使用代理）状态代码。 （&lt;a href=&quot;#section-6.4.5&quot;&gt;第6.4.5节&lt;/a&gt;）放宽了400（错误请求）状态码，使其不仅限于语法错误。 （&lt;a href=&quot;#section-6.5.1&quot;&gt;第6.5.1节&lt;/a&gt;）426（需要升级）状态代码已从[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]中合并。 （&lt;a href=&quot;#section-6.5.15&quot;&gt;第6.5.15节&lt;/a&gt;）对HTTP-date和Date标头字段的要求目标已降低为生成日期的系统，而不是所有发送日期的系统。 （&lt;a href=&quot;#section-7.1.1&quot;&gt;第7.1.1节&lt;/a&gt;）Location标头字段的语法已更改，以允许所有URI引用，包括相对引用和片段，以及一些有关何时不适合使用片段的说明。 （&lt;a href=&quot;#section-7.1.2&quot;&gt;第7.1.2节&lt;/a&gt;）Allow被重新分类为响应头字段，删除了在PUT请求中指定它的选项。放宽了关于&amp;ldquo;允许&amp;rdquo;内容的要求；相应地，客户无需始终信任其价值。 （&lt;a href=&quot;#section-7.4.1&quot;&gt;第7.4.1节&lt;/a&gt;）已经定义了方法注册表。 （&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;）状态代码注册表已由本规范重新定义；先前，它是在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;[RFC2817]的7.1节&lt;/a&gt;中定义的。（&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节&lt;/a&gt;）内容编码的注册已更改为需要IETF审核。（&lt;a href=&quot;#section-8.4&quot;&gt;第8.4节&lt;/a&gt;）因为[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt; ] 现在定义了Content-Disposition标头字段，所以已将其删除。Content-MD5标头字段已删除，因为相对于部分响应不一致地实现了该字段。</target>
        </trans-unit>
        <trans-unit id="e12309a2843027455af9add0576f0892e2a69fde" translate="yes" xml:space="preserve">
          <source>The primary difference between the HTTP header and the &lt;code&gt;allow&lt;/code&gt; attribute is that the allow attribute only controls features within an iframe. The header controls features in the response and any embedded content within the page.</source>
          <target state="translated">HTTP标头和 &lt;code&gt;allow&lt;/code&gt; 属性之间的主要区别在于allow属性仅控制iframe中的功能。标头控制响应中的功能以及页面内的任何嵌入式内容。</target>
        </trans-unit>
        <trans-unit id="b50ebcbe3e89d6447760b75f1e616af6abba5bb8" translate="yes" xml:space="preserve">
          <source>The principle behind entity tags is that only the service author
   knows the semantics of a resource well enough to select an
   appropriate cache validation mechanism, and the specification of any
   validator comparison function more complex than byte-equality would
   open up a can of worms. Thus, comparisons of any other headers
   (except Last-Modified, for compatibility with HTTP/1.0) are never
   used for purposes of validating a cache entry.</source>
          <target state="translated">实体标签背后的原则是,只有服务作者才清楚资源的语义,才能选择合适的缓存验证机制,而任何验证器比较功能的规范都会比字节均衡更复杂,这将会打开一个麻烦的罐子。因此,任何其他头文件的比较(除了Last-Modified,为了与HTTP/1.0兼容)都不会被用于验证缓存条目。</target>
        </trans-unit>
        <trans-unit id="e894f8457ed794b88882865f6c9931e22354537d" translate="yes" xml:space="preserve">
          <source>The principle behind entity-tags is that only the service author
   knows the implementation of a resource well enough to select the most
   accurate and efficient validation mechanism for that resource, and
   that any such mechanism can be mapped to a simple sequence of octets
   for easy comparison.  Since the value is opaque, there is no need for
   the client to be aware of how each entity-tag is constructed.

   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.  Other
   implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.

   An origin server SHOULD send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity-tag's use in conditional requests and
   evaluating cache freshness ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]) can result in a substantial
   reduction of HTTP network traffic and can be a significant factor in
   improving service scalability and reliability.</source>
          <target state="translated">实体标签背后的原理是，只有服务作者才足够了解资源的实现，可以为该资源选择最准确，最有效的验证机制，并且任何此类机制都可以映射到简单的八位字节序列以进行比较。由于该值是不透明的，因此客户端无需知道如何构造每个实体标签。例如，对所有更改都应用了特定于实现的版本控制的资源可能会使用内部修订号（可能与用于内容协商的方差标识符结合使用）来准确区分表示形式。其他实现可能会使用表示内容的防碰撞哈希，各种文件属性的组合，或具有亚秒分辨率的修改时间戳。原始服务器应该为可以合理而一致地确定更改检测结果的任何选定表示形式发送一个ETag，因为实体标签在条件请求中使用并评估缓存的新鲜度（[&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]）可以大大减少HTTP网络流量，并且可以成为提高服务可伸缩性和可靠性的重要因素。</target>
        </trans-unit>
        <trans-unit id="c1875060cbf6a72a618b42c5d094d85aee6d41e8" translate="yes" xml:space="preserve">
          <source>The principle is simple, but there is one potential problem: if the downloaded resource has been modified between both downloads, the obtained ranges will correspond to two different versions of the resource, and the final document will be corrupted.</source>
          <target state="translated">原理很简单,但有一个潜在的问题:如果下载的资源在两次下载之间都被修改过,那么得到的范围就会对应两个不同版本的资源,最后的文档就会被破坏。</target>
        </trans-unit>
        <trans-unit id="f6827a30a4e8cddeb55d2c26c8c9c575effc09d9" translate="yes" xml:space="preserve">
          <source>The protocol defined in this document has two identifiers.

   o  The string &quot;h2&quot; identifies the protocol where HTTP/2 uses
      Transport Layer Security (TLS) [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;].  This identifier is used
      in the TLS application-layer protocol negotiation (ALPN) extension
      [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;] field and in any place where HTTP/2 over TLS is
      identified.

      The &quot;h2&quot; string is serialized into an ALPN protocol identifier as
      the two-octet sequence: 0x68, 0x32.

   o  The string &quot;h2c&quot; identifies the protocol where HTTP/2 is run over
      cleartext TCP.  This identifier is used in the HTTP/1.1 Upgrade
      header field and in any place where HTTP/2 over TCP is identified.

      The &quot;h2c&quot; string is reserved from the ALPN identifier space but
      describes a protocol that does not use TLS.

   Negotiating &quot;h2&quot; or &quot;h2c&quot; implies the use of the transport, security,
   framing, and message semantics described in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f036bd357e0e56c778c2d79ff8ac18d032812cb" translate="yes" xml:space="preserve">
          <source>The protocol that is used. Usually it is the HTTP protocol or its secured version, HTTPS.</source>
          <target state="translated">使用的协议。通常是HTTP协议或其安全版本HTTPS。</target>
        </trans-unit>
        <trans-unit id="2ec525dcadd68d3467f5291ea2396006096b487a" translate="yes" xml:space="preserve">
          <source>The purpose of an HTTP cache is to store information received in
   response to requests for use in responding to future requests. In
   many cases, a cache simply returns the appropriate parts of a
   response to the requester. However, if the cache holds a cache entry
   based on a previous response, it might have to combine parts of a new
   response with what is held in the cache entry.</source>
          <target state="translated">HTTP缓存的目的是存储响应请求时收到的信息,以便在响应未来的请求时使用。在许多情况下,缓存只是将响应的适当部分返回给请求者。然而,如果缓存持有基于之前响应的缓存条目,它可能必须将新响应的部分与缓存条目中的内容结合起来。</target>
        </trans-unit>
        <trans-unit id="6728c1b09c31f5d826dfb315c8231a9800e8a7de" translate="yes" xml:space="preserve">
          <source>The purpose of the 100 (Continue) status (see &lt;a href=&quot;#section-10.1.1&quot;&gt;section 10.1.1&lt;/a&gt;) is to
   allow a client that is sending a request message with a request body
   to determine if the origin server is willing to accept the request
   (based on the request headers) before the client sends the request
   body. In some cases, it might either be inappropriate or highly
   inefficient for the client to send the body if the server will reject
   the message without looking at the body.

   Requirements for HTTP/1.1 clients:

      - If a client will wait for a 100 (Continue) response before
        sending the request body, it MUST send an Expect request-header
        field (&lt;a href=&quot;#section-14.20&quot;&gt;section 14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation.

      - A client MUST NOT send an Expect request-header field (&lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation if it does not intend
        to send a request body.

   Because of the presence of older implementations, the protocol allows
   ambiguous situations in which a client may send &quot;Expect: 100-
   continue&quot; without receiving either a 417 (Expectation Failed) status
   or a 100 (Continue) status. Therefore, when a client sends this
   header field to an origin server (possibly via a proxy) from which it
   has never seen a 100 (Continue) status, the client SHOULD NOT wait
   for an indefinite period before sending the request body.

   Requirements for HTTP/1.1 origin servers:

      - Upon receiving a request which includes an Expect request-header
        field with the &quot;100-continue&quot; expectation, an origin server MUST
        either respond with 100 (Continue) status and continue to read
        from the input stream, or respond with a final status code. The
        origin server MUST NOT wait for the request body before sending
        the 100 (Continue) response. If it responds with a final status
        code, it MAY close the transport connection or it MAY continue 

        to read and discard the rest of the request.  It MUST NOT
        perform the requested method if it returns a final status code.

      - An origin server SHOULD NOT send a 100 (Continue) response if
        the request message does not include an Expect request-header
        field with the &quot;100-continue&quot; expectation, and MUST NOT send a
        100 (Continue) response if such a request comes from an HTTP/1.0
        (or earlier) client. There is an exception to this rule: for
        compatibility with &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, a server MAY send a 100 (Continue)
        status in response to an HTTP/1.1 PUT or POST request that does
        not include an Expect request-header field with the &quot;100-
        continue&quot; expectation. This exception, the purpose of which is
        to minimize any client processing delays associated with an
        undeclared wait for 100 (Continue) status, applies only to
        HTTP/1.1 requests, and not to requests with any other HTTP-
        version value.

      - An origin server MAY omit a 100 (Continue) response if it has
        already received some or all of the request body for the
        corresponding request.

      - An origin server that sends a 100 (Continue) response MUST
        ultimately send a final status code, once the request body is
        received and processed, unless it terminates the transport
        connection prematurely.

      - If an origin server receives a request that does not include an
        Expect request-header field with the &quot;100-continue&quot; expectation,
        the request includes a request body, and the server responds
        with a final status code before reading the entire request body
        from the transport connection, then the server SHOULD NOT close
        the transport connection until it has read the entire request,
        or until the client closes the connection. Otherwise, the client
        might not reliably receive the response message. However, this
        requirement is not be construed as preventing a server from
        defending itself against denial-of-service attacks, or from
        badly broken client implementations.

   Requirements for HTTP/1.1 proxies:

      - If a proxy receives a request that includes an Expect request-
        header field with the &quot;100-continue&quot; expectation, and the proxy
        either knows that the next-hop server complies with HTTP/1.1 or
        higher, or does not know the HTTP version of the next-hop
        server, it MUST forward the request, including the Expect header
        field. 

      - If the proxy knows that the version of the next-hop server is
        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST
        respond with a 417 (Expectation Failed) status.

      - Proxies SHOULD maintain a cache recording the HTTP version
        numbers received from recently-referenced next-hop servers.

      - A proxy MUST NOT forward a 100 (Continue) response if the
        request message was received from an HTTP/1.0 (or earlier)
        client and did not include an Expect request-header field with
        the &quot;100-continue&quot; expectation. This requirement overrides the
        general rule for forwarding of 1xx responses (see &lt;a href=&quot;#section-10.1&quot;&gt;section 10.1&lt;/a&gt;).</source>
          <target state="translated">100（继续）状态（请参阅&lt;a href=&quot;#section-10.1.1&quot;&gt;第10.1.1节&lt;/a&gt;）的目的是允许正在发送带有请求正文的请求消息的客户端确定源服务器是否愿意接受请求（基于请求标头）在客户端发送请求正文之前。在某些情况下，如果服务器在不查看正文的情况下拒绝邮件，则客户端发送正文可能是不合适的，或者效率很低。 HTTP / 1.1客户端的要求：-如果客户端在发送请求正文之前将等待100（继续）响应，则必须发送带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段（&lt;a href=&quot;#section-14.20&quot;&gt;第14.20节&lt;/a&gt;）。 -客户端不得发送Expect请求标头字段（&lt;a href=&quot;#section-14.20&quot;&gt;部分&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;），如果它不打算发送请求正文，则期望为&amp;ldquo; 100-continue&amp;rdquo;。由于存在较早的实现，因此该协议允许模棱两可的情况，即客户端可以发送&amp;ldquo;期望：100-继续&amp;rdquo;，而不会接收到417（期望失败）状态或100（继续）状态。因此，当客户端将此标头字段发送到从未从其看到100（继续）状态的源服务器（可能通过代理）时，客户端不应在发送请求正文之前等待不确定的时间。 HTTP / 1.1原始服务器的要求：-收到包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段的请求后，源服务器必须以100（继续）状态响应并继续从输入流中读取，或以最终状态代码响应。原始服务器在发送100（继续）响应之前，绝对不能等待请求正文。如果它以最终状态代码响应，则可以关闭传输连接，或者可以继续读取并丢弃其余请求。如果返回最终状态代码，则不得执行所请求的方法。 -如果请求消息中不包含带有&amp;ldquo; 100-continue&amp;rdquo;期望值的Expect请求报头字段，则源服务器不应发送100（&amp;ldquo;继续&amp;rdquo;响应），并且如果此类请求到来，则不得发送100（&amp;ldquo;继续&amp;rdquo;）响应来自HTTP / 1.0（或更早版本）的客户端。此规则有一个例外：为了与&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;，服务器可以发送100（继续）状态，以响应HTTP / 1.1 PUT或POST请求，该请求不包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段。此异常的目的是最大程度减少与未声明的等待100（继续）状态相关的任何客户端处理延迟，该异常仅适用于HTTP / 1.1请求，而不适用于具有任何其他HTTP版本值的请求。 -如果原始服务器已经接收到相应请求的部分或全部请求主体，则它可以忽略100（继续）响应。 -一旦收到并处理了请求正文，发送100（继续）响应的原始服务器必须最终发送最终状态代码，除非它过早地终止传输连接。 -如果原始服务器收到的请求中不包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段，则该请求包含一个请求正文，并且服务器会从读取的整个请求正文之前返回最终状态代码进行响应传输连接，则服务器在读取整个请求之前或客户端关闭连接之前，不应关闭传输连接。否则，客户端可能无法可靠地接收响应消息。但是，此要求不能解释为阻止服务器防御拒绝服务攻击或严重破坏客户端实施的防御。HTTP / 1.1代理的要求：-如果代理收到的请求包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求标头字段，并且该代理知道下一跳服务器符合HTTP / 1.1或更高版本，或不知道下一跳服务器的HTTP版本，它必须转发请求，包括Expect标头字段。 -如果代理知道下一跳服务器的版本为HTTP / 1.0或更低版本，则它不得转发请求，并且必须以417（预期失败）状态进行响应。 -代理应该维护一个缓存，该缓存记录从最近引用的下一跳服务器接收到的HTTP版本号。-如果从HTTP / 1.0（或更早版本）的客户端接收到请求消息，并且代理不包含带有&amp;ldquo; 100-continue&amp;rdquo;期望的Expect请求报头字段，则代理不得转发100（&amp;ldquo; Continue&amp;rdquo;）响应。此要求优先于转发1xx响应的一般规则（请参阅&lt;a href=&quot;#section-10.1&quot;&gt;10.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0b61f958141b9100243d1bc18970ced7c1dcafec" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded &lt;em&gt;Subject Public Key Information&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future. See below on how to extract this information out of a certificate or key file.</source>
          <target state="translated">引用的字符串是Base64编码的&lt;em&gt;主题公共密钥信息&lt;/em&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;）指纹。可以为不同的公共密钥指定多个引脚。某些浏览器将来可能会允许使用SHA-256以外的其他哈希算法。请参阅以下有关如何从证书或密钥文件中提取此信息的信息。</target>
        </trans-unit>
        <trans-unit id="caac15f88bc560faaa8d23301f149cd934db87b9" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded Subject Public Key Information (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future.</source>
          <target state="translated">引用的字符串是Base64编码的主题公用密钥信息（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;）指纹。可以为不同的公共密钥指定多个引脚。某些浏览器将来可能会允许使用SHA-256以外的其他哈希算法。</target>
        </trans-unit>
        <trans-unit id="1e7090e603b1c8468593db08ace13cc460b311c3" translate="yes" xml:space="preserve">
          <source>The quoted string specifying the alternative authority which consists of an optional host override, a colon, and a mandatory port number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048868ca8bba5de4473c03e4f113e14a03b3840f" translate="yes" xml:space="preserve">
          <source>The range specified by the &lt;code&gt;Range&lt;/code&gt; header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.</source>
          <target state="translated">无法满足请求中&amp;ldquo; &lt;code&gt;Range&lt;/code&gt; 标头字段指定的范围；范围可能超出目标URI数据的大小。</target>
        </trans-unit>
        <trans-unit id="1d2b5330a14328ad92bbc96c72d50b3c95138424" translate="yes" xml:space="preserve">
          <source>The recommendation is to compress data as much as possible and therefore to use this field, but some types of resources, such as jpeg images, are already compressed. Sometimes, using additional compression doesn't reduce payload size and can even make the payload longer.</source>
          <target state="translated">建议尽可能地压缩数据,因此使用这个字段,但有些类型的资源,如jpeg图像,已经被压缩了。有时,使用额外的压缩并不能减少有效载荷大小,甚至会使有效载荷变长。</target>
        </trans-unit>
        <trans-unit id="b4310de37bf5d5b890a2b93359f92ce5fd4a2747" translate="yes" xml:space="preserve">
          <source>The recommended way of sniffing for Gecko-based browsers (if you &lt;em&gt;have to&lt;/em&gt; sniff for the browser engine instead of using feature detection) is by the presence of the &quot;&lt;code&gt;Gecko&lt;/code&gt;&quot; and &quot;&lt;code&gt;rv:&lt;/code&gt;&quot; strings, since some other browsers include a &quot;&lt;code&gt;like Gecko&lt;/code&gt;&quot; token.</source>
          <target state="translated">对于基于Gecko的浏览器，嗅探的推荐方法（如果您&lt;em&gt;必须对&lt;/em&gt;浏览器引擎&lt;em&gt;进行&lt;/em&gt;嗅探而不是使用功能检测）是通过存在&amp;ldquo; &lt;code&gt;Gecko&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;rv:&lt;/code&gt; &amp;rdquo;字符串，因为其他一些浏览器都包含&amp;ldquo; &lt;code&gt;like Gecko&lt;/code&gt; 令牌。</target>
        </trans-unit>
        <trans-unit id="835a33da74dbfed0d3a5afc284d8d5f7eeac4750" translate="yes" xml:space="preserve">
          <source>The referrer of the document in which the violation occurred.</source>
          <target state="translated">发生侵权行为的文件的提交人;</target>
        </trans-unit>
        <trans-unit id="060f5108fa86aba94bed9d14146f77e7e9a8271d" translate="yes" xml:space="preserve">
          <source>The referring resource is a local &quot;file&quot; or &quot;data&quot; URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457d2e04c3cca60af5bcc1e43cb940e66612e208" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +-----------+----------------------------------+---------------+
   | Warn Code | Short Description                | Reference     |
   +-----------+----------------------------------+---------------+
   | 110       | Response is Stale                | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | 111       | Revalidation Failed              | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | 112       | Disconnected Operation           | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   | 113       | Heuristic Expiration             | &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt; |
   | 199       | Miscellaneous Warning            | &lt;a href=&quot;#section-5.5.5&quot;&gt;Section 5.5.5&lt;/a&gt; |
   | 214       | Transformation Applied           | &lt;a href=&quot;#section-5.5.6&quot;&gt;Section 5.5.6&lt;/a&gt; |
   | 299       | Miscellaneous Persistent Warning | &lt;a href=&quot;#section-5.5.7&quot;&gt;Section 5.5.7&lt;/a&gt; |
   +-----------+----------------------------------+---------------+</source>
          <target state="translated">该注册表已使用以下注册填充：+ ----------- + --------------------------- ------- + --------------- + |警告代码|简短说明|参考| + ----------- + ---------------------------------- +- ------------- + | 110 |回应是过时的| &lt;a href=&quot;#section-5.5.1&quot;&gt;第5.5.1节&lt;/a&gt; | | 111 |重新验证失败| &lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt; | | 112 |断开连接的操作| &lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节&lt;/a&gt; | | 113 |启发式到期| &lt;a href=&quot;#section-5.5.4&quot;&gt;第5.5.4节&lt;/a&gt; | | 199 |其他警告| &lt;a href=&quot;#section-5.5.5&quot;&gt;第5.5.5节&lt;/a&gt; | | 214 |转化应用| &lt;a href=&quot;#section-5.5.6&quot;&gt;第5.5.6节&lt;/a&gt;| | 299 |其他持续警告| &lt;a href=&quot;#section-5.5.7&quot;&gt;第5.5.7节&lt;/a&gt; | + ----------- + ---------------------------------- +- ------------- +</target>
        </trans-unit>
        <trans-unit id="6bfb04acf1092d994bf84da7df6bb36e8f3a785e" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +------------------------+----------------------------------+
   | Cache Directive        | Reference                        |
   +------------------------+----------------------------------+
   | max-age                | &lt;a href=&quot;#section-5.2.1.1&quot;&gt;Section 5.2.1.1&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt; |
   | max-stale              | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;Section 5.2.1.2&lt;/a&gt;                  |
   | min-fresh              | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;Section 5.2.1.3&lt;/a&gt;                  |
   | must-revalidate        | &lt;a href=&quot;#section-5.2.2.1&quot;&gt;Section 5.2.2.1&lt;/a&gt;                  |
   | no-cache               | &lt;a href=&quot;#section-5.2.1.4&quot;&gt;Section 5.2.1.4&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt; |
   | no-store               | &lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.3&quot;&gt;Section 5.2.2.3&lt;/a&gt; |
   | no-transform           | &lt;a href=&quot;#section-5.2.1.6&quot;&gt;Section 5.2.1.6&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.4&quot;&gt;Section 5.2.2.4&lt;/a&gt; |
   | only-if-cached         | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;Section 5.2.1.7&lt;/a&gt;                  |
   | private                | &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Section 5.2.2.6&lt;/a&gt;                  |
   | proxy-revalidate       | &lt;a href=&quot;#section-5.2.2.7&quot;&gt;Section 5.2.2.7&lt;/a&gt;                  |
   | public                 | &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Section 5.2.2.5&lt;/a&gt;                  |
   | s-maxage               | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;                  |
   | stale-if-error         | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861], Section&amp;nbsp;4&lt;/a&gt;             |
   | stale-while-revalidate | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861], Section&amp;nbsp;3&lt;/a&gt;             |
   +------------------------+----------------------------------+</source>
          <target state="translated">该注册表已使用以下注册填充：+ ------------------------ + -------------- -------------------- + |缓存指令|参考| + ------------------------ + ------------------------ ---------- + |最大年龄| &lt;a href=&quot;#section-5.2.1.1&quot;&gt;第5.2.1.1 &lt;/a&gt;&lt;a href=&quot;#section-5.2.2.8&quot;&gt;节&lt;/a&gt;，第5.2.2.8节 | |最大陈旧| &lt;a href=&quot;#section-5.2.1.2&quot;&gt;第5.2.1.2节&lt;/a&gt; | |最小新鲜&lt;a href=&quot;#section-5.2.1.3&quot;&gt;第5.2.1.3节&lt;/a&gt; | |必须重新验证| &lt;a href=&quot;#section-5.2.2.1&quot;&gt;第5.2.2.1节&lt;/a&gt; | |无缓存| &lt;a href=&quot;#section-5.2.1.4&quot;&gt;第5.2.1.4 &lt;/a&gt;&lt;a href=&quot;#section-5.2.2.2&quot;&gt;节&lt;/a&gt;，第5.2.2.2节 | |无店| &lt;a href=&quot;#section-5.2.1.5&quot;&gt;第5.2.1.5节&lt;/a&gt;，&lt;a href=&quot;#section-5.2.2.3&quot;&gt;第5.2.2.3节&lt;/a&gt; | | 无变换| &lt;a href=&quot;#section-5.2.1.6&quot;&gt;第5.2.1.6 &lt;/a&gt;&lt;a href=&quot;#section-5.2.2.4&quot;&gt;节&lt;/a&gt;，第5.2.2.4节 | | 仅当缓存时| &lt;a href=&quot;#section-5.2.1.7&quot;&gt;第5.2.1.7节&lt;/a&gt; | | 私人| &lt;a href=&quot;#section-5.2.2.6&quot;&gt;第5.2.2.6节&lt;/a&gt; | | 代理重新验证| &lt;a href=&quot;#section-5.2.2.7&quot;&gt;第5.2.2.7节&lt;/a&gt; | | 公共| &lt;a href=&quot;#section-5.2.2.5&quot;&gt;第5.2.2.5节&lt;/a&gt; | | s-maxage | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;第5.2.2.9节&lt;/a&gt; | | 错误过时| &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861]，第4节&lt;/a&gt; | | 重新验证时失效| &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861]，第3节&lt;/a&gt; | + ------------------------ + ------------------------ ---------- +</target>
        </trans-unit>
        <trans-unit id="6c3e9e6ad9f0e3368fa4d44e9aa2e2c33c90d7a5" translate="yes" xml:space="preserve">
          <source>The relevant RFC document for the &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Upgrade header field is RFC 7230, section 6.7&lt;/a&gt;. The standard establishes rules for upgrading or changing to a different protocol on the current client, server, transport protocol connection. For example, this header standard allows a client to change from HTTP 1.1 to HTTP 2.0, assuming the server decides to acknowledge and implement the Upgrade header field. Neither party is required to accept the terms specified in the Upgrade header field. It can be used in both client and server headers. If the Upgrade header field is specified, then the sender MUST also send the Connection header field with the upgrade option specified. For details on the Connection header field &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;please see section 6.1 of the aforementioned RFC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;升级标头字段&lt;/a&gt;的相关RFC文档是RFC 7230的6.7节。该标准建立了在当前客户端，服务器，传输协议连接上升级或更改为其他协议的规则。例如，假设服务器决定确认并实现&amp;ldquo;升级&amp;rdquo;标头字段，则此标头标准允许客户端从HTTP 1.1更改为HTTP 2.0。双方均不需要接受&amp;ldquo;升级标题&amp;rdquo;字段中指定的条款。可以在客户端和服务器标头中使用它。如果指定了升级头字段，那么发送者还必须发送带有指定升级选项的连接头字段。有关Connection标头字段的详细信息，&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;请参见上述RFC的6.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9681bfccce6746b808712df87789877aff1a0a08" translate="yes" xml:space="preserve">
          <source>The remaining response header fields provide more information about
   the target resource for potential use in later requests.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Accept-Ranges     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7233]&lt;/a&gt; |
   | Allow             | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;            |
   | Server            | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;            |
   +-------------------+--------------------------+</source>
          <target state="translated">其余的响应头字段提供有关目标资源的更多信息，以供以后的请求中潜在使用。 + ------------------- + -------------------------- + |标头字段名称|定义于... | + ------------------- + -------------------------- + |接受范围| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;[RFC7233]第2.3节&lt;/a&gt; | |允许| &lt;a href=&quot;#section-7.4.1&quot;&gt;第7.4.1节&lt;/a&gt; | |服务器| &lt;a href=&quot;#section-7.4.2&quot;&gt;第7.4.2节&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="4af6457a5675ed1ed5b26a3a3626f6948e42d207" translate="yes" xml:space="preserve">
          <source>The report JSON object contains the following data:</source>
          <target state="translated">报告JSON对象包含以下数据:</target>
        </trans-unit>
        <trans-unit id="3cf9e42ccc33aee82c7b770f8203f6eabbfa160c" translate="yes" xml:space="preserve">
          <source>The reporting group referenced above is defined in the usual manner within the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Report-To&quot;&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/a&gt; header, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5baf54425251a0af52438742ec528ea5d7cad288" translate="yes" xml:space="preserve">
          <source>The representation data associated with an HTTP message is either
   provided as the payload body of the message or referred to by the
   message semantics and the effective request URI.  The representation
   data is in a format and encoding defined by the representation
   metadata header fields.

   The data type of the representation data is determined via the header
   fields Content-Type and Content-Encoding.  These define a two-layer,
   ordered encoding model:

     representation-data := Content-Encoding( Content-Type( bits ) )</source>
          <target state="translated">与HTTP消息相关联的表示数据要么作为消息的有效载荷体提供,要么由消息语义和有效请求URI引用。表示数据的格式和编码由表示元数据头字段定义。表示数据的数据类型通过头字段Content-Type和Content-Encoding决定。这两个字段定义了一个两层有序的编码模型:representation-data :=Content-Encoding(Content-Type(bits ))</target>
        </trans-unit>
        <trans-unit id="57fb990a7173c920416af3c97b46113340011437" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
   state of the resource. This code is only allowed in situations where
   it is expected that the user might be able to resolve the conflict
   and resubmit the request. The response body SHOULD include enough 

   information for the user to recognize the source of the conflict.
   Ideally, the response entity would include enough information for the
   user or user agent to fix the problem; however, that might not be
   possible and is not required.

   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the entity being PUT
   included changes to a resource which conflict with those made by an
   earlier (third-party) request, the server might use the 409 response
   to indicate that it can't complete the request. In this case, the
   response entity would likely contain a list of the differences
   between the two versions in a format defined by the response
   Content-Type.</source>
          <target state="translated">由于与资源的当前状态冲突,请求无法完成。只有在用户可能解决冲突并重新提交请求的情况下,才允许使用该代码。响应体应该包括足够的信息,以便用户识别冲突的来源。理想情况下,响应实体将包括足够的信息,让用户或用户代理能够解决问题;然而,这可能是不可能的,也不是必须的。冲突最可能发生在响应PUT请求时。例如,如果正在使用版本管理,并且被 PUT 的实体包含了对资源的更改,而这些更改与早期(第三方)请求所做的更改相冲突,服务器可能会使用 409 响应来表明它不能完成请求。在这种情况下,响应实体可能会包含两个版本之间的差异列表,其格式由响应Content-Type定义。</target>
        </trans-unit>
        <trans-unit id="62943efc1c331624006dfa87f2880914c04923b3" translate="yes" xml:space="preserve">
          <source>The request could not be understood by the server due to malformed
   syntax. The client SHOULD NOT repeat the request without
   modifications.</source>
          <target state="translated">由于语法错误,服务器无法理解该请求。客户端不应该不加修改地重复该请求。</target>
        </trans-unit>
        <trans-unit id="a5f388607fcf883d14ee29792afda2dc8c83b32d" translate="yes" xml:space="preserve">
          <source>The request failed due to failure of a previous request.</source>
          <target state="translated">由于之前的请求失败,导致请求失败。</target>
        </trans-unit>
        <trans-unit id="80b2b18dab161f54208331e259eefdc84181c453" translate="yes" xml:space="preserve">
          <source>The request has been accepted for processing, but the processing has
   not been completed.  The request might or might not eventually be
   acted upon, as it might be disallowed when processing actually takes
   place. There is no facility for re-sending a status code from an
   asynchronous operation such as this.

   The 202 response is intentionally non-committal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The entity returned with this
   response SHOULD include an indication of the request's current status
   and either a pointer to a status monitor or some estimate of when the
   user can expect the request to be fulfilled.</source>
          <target state="translated">请求已被受理,但处理工作尚未完成。该请求最终可能会被执行,也可能不会被执行,因为在实际处理时可能会被拒绝。没有从这样的异步操作中重新发送状态码的功能。202响应是有意的非承诺性的。它的目的是允许服务器接受对其他进程的请求(也许是一个每天只运行一次的面向批次的进程),而不要求用户代理与服务器的连接持续到进程完成。与这个响应一起返回的实体应该包括请求的当前状态的指示,以及指向状态监视器的指针或用户可以期望请求被完成的时间的某种估计。</target>
        </trans-unit>
        <trans-unit id="3496a6a34429a71d096b5d661e42c1a9bb755e60" translate="yes" xml:space="preserve">
          <source>The request has been fulfilled and resulted in a new resource being
   created. The newly created resource can be referenced by the URI(s)
   returned in the entity of the response, with the most specific URI
   for the resource given by a Location header field. The response
   SHOULD include an entity containing a list of resource
   characteristics and location(s) from which the user or user agent can
   choose the one most appropriate. The entity format is specified by
   the media type given in the Content-Type header field. The origin
   server MUST create the resource before returning the 201 status code.
   If the action cannot be carried out immediately, the server SHOULD
   respond with 202 (Accepted) response instead.

   A 201 response MAY contain an ETag response header field indicating
   the current value of the entity tag for the requested variant just
   created, see &lt;a href=&quot;#section-14.19&quot;&gt;section 14.19&lt;/a&gt;.</source>
          <target state="translated">该请求已完成，并导致创建了新资源。可以通过响应实体中返回的URI引用新创建的资源，其中最具体的URI由Location头字段给出。响应应该包括一个实体，其中包含资源特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由Content-Type标头字段中提供的媒体类型指定。原始服务器必须在返回201状态码之前创建资源。如果不能立即执行该操作，则服务器应以202（已接受）响应代替。201响应可能包含ETag响应标头字段，该字段指示刚刚创建的所请求变体的实体标签的当前值，请参见&lt;a href=&quot;#section-14.19&quot;&gt;第14.19条&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7d84e18807de0c6356f2f62e25c75fb03b74e11" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">该请求已被接收,但尚未采取行动。它是非承诺性的,意味着在HTTP中没有办法在以后发送一个异步响应来表示处理请求的结果。它的目的是用于另一个进程或服务器处理请求的情况,或者用于批处理。</target>
        </trans-unit>
        <trans-unit id="585082aac4586ccf5aebfeb0d6987e1358cca064" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is noncommittal, since there is no way in HTTP to later send an asynchronous response indicating the outcome of the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b875d4acb8b65c4bd9ffe04a6f98e27644fbcab" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. (There is no standardized way of choosing one of the responses, but HTML links to the possibilities are recommended so the user can pick.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563c97ec35447bf615f29b9828050c09a712103e" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. There is no standardized way of choosing one of the responses.</source>
          <target state="translated">该请求有一个以上可能的响应。用户代理或用户应选择其中之一。没有标准化的方式来选择其中一个响应。</target>
        </trans-unit>
        <trans-unit id="5487d137616e521aa017175b35b13aa2e3f74d3d" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a POST request, or after some PUT requests.</source>
          <target state="translated">请求已经成功,并因此创建了一个新的资源。这通常是在POST请求后或一些PUT请求后发送的响应。</target>
        </trans-unit>
        <trans-unit id="135d9441de12a3afffc64aee3e0646575c72a5dc" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result. This is typically the response sent after &lt;code&gt;POST&lt;/code&gt; requests, or some &lt;code&gt;PUT&lt;/code&gt; requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ecc9cc6596038de67ec68a577d983da6a673ef" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The information returned with the response
   is dependent on the method used in the request, for example:

   GET    an entity corresponding to the requested resource is sent in
          the response;

   HEAD   the entity-header fields corresponding to the requested
          resource are sent in the response without any message-body;

   POST   an entity describing or containing the result of the action; 

   TRACE  an entity containing the request message as received by the
          end server.</source>
          <target state="translated">请求已经成功。响应返回的信息取决于请求中使用的方法,例如。GET在响应中发送与请求资源相对应的实体;HEAD在响应中发送与请求资源相对应的实体头字段,不含任何消息体;POST是描述或包含操作结果的实体;TRACE是包含终端服务器收到的请求消息的实体。</target>
        </trans-unit>
        <trans-unit id="f565b6003126123248442292df2bf9baaa5e391b" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of a success varies depending on the HTTP method:</source>
          <target state="translated">请求成功了。成功的含义根据HTTP方法的不同而不同。</target>
        </trans-unit>
        <trans-unit id="9bd73430623220d33656725bff084d01a5160eeb" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of the success depends on the HTTP method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ea2a026f2515cb348f3705c18e0640e28ad870" translate="yes" xml:space="preserve">
          <source>The request header of note is &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, which shows that the invocation is coming from &lt;code&gt;https://foo.example&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11383f57aada516934509a2d3957090ac4763bc" translate="yes" xml:space="preserve">
          <source>The request looks something like this (less interesting headers are omitted here):</source>
          <target state="translated">请求看起来像这样(这里省略了不太有趣的标题)。</target>
        </trans-unit>
        <trans-unit id="0c671ed51daf22d159e04d7c4fd432023c8f3806" translate="yes" xml:space="preserve">
          <source>The request method and the body will not be altered, whereas &lt;a href=&quot;301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; may incorrectly sometimes be changed to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">请求方法和主体不会更改，而&lt;a href=&quot;301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;有时可能会错误地更改为&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="e391f1f093da1eaf3c8079eb9f1cb969d2137823" translate="yes" xml:space="preserve">
          <source>The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;, must never be disabled and should not return this error code.</source>
          <target state="translated">服务器知道该请求方法，但已被禁用，无法使用。例如，API可能禁止删除资源。决不能禁用两个强制方法 &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;HEAD&lt;/code&gt; ，并且不应返回此错误代码。</target>
        </trans-unit>
        <trans-unit id="3868804eb59e6799895608f9d8fc1f4241a46d74" translate="yes" xml:space="preserve">
          <source>The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">服务器不支持请求方法，无法处理该请求方法。要求服务器支持的唯一方法（因此不能返回此代码）是 &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cacbb0963918be12f6522f203c0731acc095523b" translate="yes" xml:space="preserve">
          <source>The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.

   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;)
   if those additional semantics do not conflict with the method.  For
   example, a client can send conditional request header fields
   (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) to make the requested action conditional on the current
   state of the target resource ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]).

     method = token

   HTTP was originally designed to be usable as an interface to
   distributed object systems.  The request method was envisioned as
   applying semantics to a target resource in much the same way as
   invoking a defined method on an identified object would apply
   semantics.  The method token is case-sensitive because it might be
   used as a gateway to object-based systems with case-sensitive method
   names.

   Unlike distributed objects, the standardized request methods in HTTP
   are not resource-specific, since uniform interfaces provide for
   better visibility and reuse in network-based systems [&lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;].  Once
   defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.

   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.  By
   convention, standardized methods are defined in all-uppercase
   US-ASCII letters. 

   +---------+-------------------------------------------------+-------+
   | Method  | Description                                     | Sec.  |
   +---------+-------------------------------------------------+-------+
   | GET     | Transfer a current representation of the target | 4.3.1 |
   |         | resource.                                       |       |
   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |
   |         | and header section.                             |       |
   | POST    | Perform resource-specific processing on the     | 4.3.3 |
   |         | request payload.                                |       |
   | PUT     | Replace all current representations of the      | 4.3.4 |
   |         | target resource with the request payload.       |       |
   | DELETE  | Remove all current representations of the       | 4.3.5 |
   |         | target resource.                                |       |
   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |
   |         | the target resource.                            |       |
   | OPTIONS | Describe the communication options for the      | 4.3.7 |
   |         | target resource.                                |       |
   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |
   |         | to the target resource.                         |       |
   +---------+-------------------------------------------------+-------+

   All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.

   Additional methods, outside the scope of this specification, have
   been standardized for use in HTTP.  All such methods ought to be
   registered within the &quot;Hypertext Transfer Protocol (HTTP) Method
   Registry&quot; maintained by IANA, as defined in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   The set of methods allowed by a target resource can be listed in an
   Allow header field (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;).  However, the set of allowed
   methods can change dynamically.  When a request method is received
   that is unrecognized or not implemented by an origin server, the
   origin server SHOULD respond with the 501 (Not Implemented) status
   code.  When a request method is received that is known by an origin
   server but not allowed for the target resource, the origin server
   SHOULD respond with the 405 (Method Not Allowed) status code.</source>
          <target state="translated">请求方法令牌是请求语义的主要来源。它指示客户端发出此请求的目的以及客户端期望成功的结果。如果请求方法中存在一些附加字段，则这些方法的语义可能会被某些标头字段的语义进一步专门化（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。例如，客户端可以发送条件请求标头字段（&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;），以使请求的操作基于目标资源的当前状态（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232]&lt;/a&gt;]）。 method =令牌HTTP最初旨在用作分布式对象系统的接口。可以将请求方法设想为将语义应用于目标资源的方式与在已标识的对象上调用定义的方法将应用语义的方式几乎相同。方法令牌区分大小写，因为它可以用作区分大小写的方法名称的基于对象的系统的网关。与分布式对象不同，HTTP中的标准化请求方法不是特定于资源的，因为统一的接口可在基于网络的系统中提供更好的可见性和重用性[ &lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;]。一旦定义，标准化方法在应用于任何资源时应具有相同的语义，尽管每个资源都自行确定是实现还是允许这些语义。下表概述了此规范定义了HTTP中常用的许多标准化方法。按照惯例，标准化方法以全大写的US-ASCII字母定义。 + --------- + --------------------------------------- ---------- + ------- + |方法描述秒| + --------- + --------------------------------------- ---------- + ------- + | GET |转移目标的当前表示| 4.3.1 | | |资源。 | | |头|与GET相同，但仅转移状态行| 4.3.2 | | |和标题部分。 | | |发布|对|执行特定于资源的处理4.3.3 | | |请求有效负载。 | | |放置|替换|的所有当前表示形式。 4.3.4 | | |具有请求有效负载的目标资源。 | | |删除删除|的所有当前表示。 4.3.5 | | |目标资源。 | | |连接|建立到由|标识的服务器的隧道4.3.6 | | |目标资源。 | | |选项|描述|的通讯选项。 4.3.7 | | |目标资源。| | |追踪|沿路径执行消息环回测试4.3.8 | | |到目标资源。 | | + --------- + --------------------------------------- ---------- + ------- +所有通用服务器必须支持GET和HEAD方法。所有其他方法都是可选的。在本规范范围之外的其他方法已经标准化，可以在HTTP中使用。所有此类方法都应在IANA维护的&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;中进行注册，如| | + --------- + --------------------------------------- ---------- + ------- +所有通用服务器必须支持GET和HEAD方法。所有其他方法都是可选的。在本规范范围之外的其他方法已经标准化，可以在HTTP中使用。所有此类方法都应在IANA维护的&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;中进行注册，如| | + --------- + --------------------------------------- ---------- + ------- +所有通用服务器必须支持GET和HEAD方法。所有其他方法都是可选的。在本规范范围之外的其他方法已经标准化，可以在HTTP中使用。所有此类方法都应在IANA维护的&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;中进行注册，如&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;。目标资源允许的方法集可以在&amp;ldquo;允许&amp;rdquo;标头字段中列出（&lt;a href=&quot;#section-7.4.1&quot;&gt;第7.4.1节&lt;/a&gt;）。但是，允许的方法集可以动态更改。当接收到源服务器无法识别或未实现的请求方法时，源服务器应以501（未实现）状态码响应。当接收到一个请求方法，该请求方法是源服务器已知的，但不允许目标资源使用时，源服务器应以405（方法不允许）状态码响应。</target>
        </trans-unit>
        <trans-unit id="ea4723439e12f3374a0c44c124fcfaaf67f0d247" translate="yes" xml:space="preserve">
          <source>The request requires user authentication. The response MUST include a
   WWW-Authenticate header field (&lt;a href=&quot;#section-14.47&quot;&gt;section 14.47&lt;/a&gt;) containing a challenge
   applicable to the requested resource. The client MAY repeat the
   request with a suitable Authorization header field (&lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;). If
   the request already included Authorization credentials, then the 401
   response indicates that authorization has been refused for those
   credentials. If the 401 response contains the same challenge as the
   prior response, and the user agent has already attempted
   authentication at least once, then the user SHOULD be presented the
   entity that was given in the response, since that entity might
   include relevant diagnostic information. HTTP access authentication
   is explained in &quot;HTTP Authentication: Basic and Digest Access
   Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">该请求需要用户认证。响应必须包括一个WWW-Authenticate头域（&lt;a href=&quot;#section-14.47&quot;&gt;第14.47节&lt;/a&gt;），该域包含适用于所请求资源的质询。客户端可以使用适当的Authorization标头字段重复请求（&lt;a href=&quot;#section-14.8&quot;&gt;第14.8节）&lt;/a&gt;）。如果请求已包含授权凭证，则401响应指示已拒绝这些凭证的授权。如果401响应包含与先前响应相同的质询，并且用户代理已经尝试了至少一次身份验证，则应该向用户提供响应中给定的实体，因为该实体可能包括相关的诊断信息。 HTTP访问身份验证在&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]中进行了说明。</target>
        </trans-unit>
        <trans-unit id="536c30469835dbdbadd49c3051aea9ea66357e5b" translate="yes" xml:space="preserve">
          <source>The request to TLS can be made either optionally or mandatorily.</source>
          <target state="translated">对TLS的请求可以是选择性的,也可以是强制性的。</target>
        </trans-unit>
        <trans-unit id="c08d03b683f62c643ba894d3c2dd507993993fdd" translate="yes" xml:space="preserve">
          <source>The request was aborted due to a detected redirect loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab19f93fa18ca65854665f21139e776133cce6e1" translate="yes" xml:space="preserve">
          <source>The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.</source>
          <target state="translated">该请求指向的服务器无法产生响应。这可能是由未配置为对请求URI中包含的方案和权限组合产生响应的服务器发出的。</target>
        </trans-unit>
        <trans-unit id="e88680dcf3022af1b9dae0ac257cac1136f1dced" translate="yes" xml:space="preserve">
          <source>The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight</source>
          <target state="translated">该请求被重定向到'https://example.com/foo',这对于需要预检的跨源请求是不允许的。</target>
        </trans-unit>
        <trans-unit id="f7233ccb2f021155bf357e2393734dc2cb1fd475" translate="yes" xml:space="preserve">
          <source>The request was well-formed but was unable to be followed due to semantic errors.</source>
          <target state="translated">该请求格式良好,但由于语义错误而无法执行。</target>
        </trans-unit>
        <trans-unit id="c92c57474b6ca0ed55b1d1a0fed53a9265911a89" translate="yes" xml:space="preserve">
          <source>The request-header fields allow the client to pass additional
   information about the request, and about the client itself, to the
   server. These fields act as request modifiers, with semantics
   equivalent to the parameters on a programming language method
   invocation.

       request-header = Accept                   ; &lt;a href=&quot;#section-14.1&quot;&gt;Section 14.1&lt;/a&gt;
                      | Accept-Charset           ; &lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;
                      | Accept-Encoding          ; &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;
                      | Accept-Language          ; &lt;a href=&quot;#section-14.4&quot;&gt;Section 14.4&lt;/a&gt;
                      | Authorization            ; &lt;a href=&quot;#section-14.8&quot;&gt;Section 14.8&lt;/a&gt;
                      | Expect                   ; &lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;
                      | From                     ; &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;
                      | Host                     ; &lt;a href=&quot;#section-14.23&quot;&gt;Section 14.23&lt;/a&gt;
                      | If-Match                 ; &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt; 

                      | If-Modified-Since        ; &lt;a href=&quot;#section-14.25&quot;&gt;Section 14.25&lt;/a&gt;
                      | If-None-Match            ; &lt;a href=&quot;#section-14.26&quot;&gt;Section 14.26&lt;/a&gt;
                      | If-Range                 ; &lt;a href=&quot;#section-14.27&quot;&gt;Section 14.27&lt;/a&gt;
                      | If-Unmodified-Since      ; &lt;a href=&quot;#section-14.28&quot;&gt;Section 14.28&lt;/a&gt;
                      | Max-Forwards             ; &lt;a href=&quot;#section-14.31&quot;&gt;Section 14.31&lt;/a&gt;
                      | Proxy-Authorization      ; &lt;a href=&quot;#section-14.34&quot;&gt;Section 14.34&lt;/a&gt;
                      | Range                    ; &lt;a href=&quot;#section-14.35&quot;&gt;Section 14.35&lt;/a&gt;
                      | Referer                  ; &lt;a href=&quot;#section-14.36&quot;&gt;Section 14.36&lt;/a&gt;
                      | TE                       ; &lt;a href=&quot;#section-14.39&quot;&gt;Section 14.39&lt;/a&gt;
                      | User-Agent               ; &lt;a href=&quot;#section-14.43&quot;&gt;Section 14.43&lt;/a&gt;

   Request-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of request-
   header fields if all parties in the communication recognize them to
   be request-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">请求标头字段允许客户端将有关请求以及有关客户端本身的其他信息传递给服务器。这些字段充当请求修饰符，其语义等效于编程语言方法调用中的参数。 request-header =接受; &lt;a href=&quot;#section-14.1&quot;&gt;第14.1节&lt;/a&gt; |接受字符集&lt;a href=&quot;#section-14.2&quot;&gt;第14.2节&lt;/a&gt; |接受编码&lt;a href=&quot;#section-14.3&quot;&gt;第14.3节&lt;/a&gt; |接受语言&lt;a href=&quot;#section-14.4&quot;&gt;第14.4节&lt;/a&gt; |授权; &lt;a href=&quot;#section-14.8&quot;&gt;第14.8节&lt;/a&gt; |期望; &lt;a href=&quot;#section-14.20&quot;&gt;第14.20节&lt;/a&gt; |来自; &lt;a href=&quot;#section-14.22&quot;&gt;第14.22节&lt;/a&gt; |主持人; &lt;a href=&quot;#section-14.23&quot;&gt;第14.23节&lt;/a&gt; |如果匹配&lt;a href=&quot;#section-14.24&quot;&gt;第14.24节&lt;/a&gt; | If-Modified-Since; &lt;a href=&quot;#section-14.25&quot;&gt;第14.25节&lt;/a&gt; |如果不匹配&lt;a href=&quot;#section-14.26&quot;&gt;第14.26节&lt;/a&gt; | If-Range; &lt;a href=&quot;#section-14.27&quot;&gt;第14.27节&lt;/a&gt; | If-Unmodified-Since; &lt;a href=&quot;#section-14.28&quot;&gt;第14.28节&lt;/a&gt; | Max-Forwards；&lt;a href=&quot;#section-14.31&quot;&gt;第14.31节&lt;/a&gt; |代理授权&lt;a href=&quot;#section-14.34&quot;&gt;第14.34节&lt;/a&gt; |范围 ; &lt;a href=&quot;#section-14.35&quot;&gt;第14.35节&lt;/a&gt; |推荐人; &lt;a href=&quot;#section-14.36&quot;&gt;第14.36节&lt;/a&gt; | TE; &lt;a href=&quot;#section-14.39&quot;&gt;第14.39节&lt;/a&gt; |用户代理 ; 只有结合协议版本的更改，才能可靠地扩展&lt;a href=&quot;#section-14.43&quot;&gt;14.43节的&lt;/a&gt;请求标头字段名称。但是，如果通信中的所有各方都将它们视为请求标头字段，则可以为新的或实验性标头字段赋予请求标头字段的语义。无法识别的标头字段被视为实体标头字段。</target>
        </trans-unit>
        <trans-unit id="00ee3240d5b62db652acaaec1c517dfc4187762e" translate="yes" xml:space="preserve">
          <source>The requested resource MUST be accessed through the proxy given by
   the Location field. The Location field gives the URI of the proxy.
   The recipient is expected to repeat this single request via the
   proxy. 305 responses MUST only be generated by origin servers.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; was not clear that 305 was intended to redirect a
      single request, and to be generated by origin servers only.  Not
      observing these limitations has significant security consequences.</source>
          <target state="translated">所请求的资源必须通过位置字段给出的代理访问。位置字段提供代理的URI。预计收件人将通过代理重复此单个请求。305个响应只能由原始服务器生成。注意：&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;不清楚305是否旨在重定向单个请求，并且仅由原始服务器生成。不遵守这些限制会产生重大的安全后果。</target>
        </trans-unit>
        <trans-unit id="d984d2d7ff09514806eb927c4043ee9bc91f6a1d" translate="yes" xml:space="preserve">
          <source>The requested resource corresponds to any one of a set of
   representations, each with its own specific location, and agent-
   driven negotiation information (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) is being provided so that
   the user (or user agent) can select a preferred representation and
   redirect its request to that location.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of resource characteristics and location(s) from
   which the user or user agent can choose the one most appropriate. The
   entity format is specified by the media type given in the Content-
   Type header field. Depending upon the format and the capabilities of 

   the user agent, selection of the most appropriate choice MAY be
   performed automatically. However, this specification does not define
   any standard for such automatic selection.

   If the server has a preferred choice of representation, it SHOULD
   include the specific URI for that representation in the Location
   field; user agents MAY use the Location field value for automatic
   redirection. This response is cacheable unless indicated otherwise.</source>
          <target state="translated">所请求的资源对应于一组表示中的任何一个，每个表示都有自己的特定位置，以及代理驱动的协商信息（&lt;a href=&quot;#section-12&quot;&gt;第12节）&lt;/a&gt;），以便用户（或用户代理）可以选择首选的表示形式并将其请求重定向到该位置。除非它是HEAD请求，否则响应应包含一个实体，其中包含资源特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由&amp;ldquo;内容类型&amp;rdquo;标头字段中提供的媒体类型指定。根据用户代理的格式和功能，可以自动执行最合适的选择。但是，该规范没有为这种自动选择定义任何标准。如果服务器具有首选的表示形式，则应在&amp;ldquo;位置&amp;rdquo;字段中包含该表示形式的特定URI；用户代理可以使用&amp;ldquo;位置&amp;rdquo;字段值进行自动重定向。除非另有说明，否则此响应是可缓存的。</target>
        </trans-unit>
        <trans-unit id="e7c77b9895c801f0e66c9d13d10555d8495d972e" translate="yes" xml:space="preserve">
          <source>The requested resource has been assigned a new permanent URI and any
   future references to this resource SHOULD use one of the returned
   URIs.  Clients with link editing capabilities ought to automatically
   re-link references to the Request-URI to one or more of the new
   references returned by the server, where possible. This response is
   cacheable unless indicated otherwise.

   The new permanent URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

   If the 301 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: When automatically redirecting a POST request after
      receiving a 301 status code, some existing HTTP/1.0 user agents
      will erroneously change it into a GET request.</source>
          <target state="translated">被请求的资源已经被分配了一个新的永久URI,今后对该资源的任何引用都应该使用返回的URI之一。具有链接编辑功能的客户机应该尽可能自动地将对Request-URI的引用重新链接到服务器返回的一个或多个新的引用。除非另有说明,否则这个响应是可以缓存的。新的永久URI应该由响应中的Location字段给出。除非请求方法是HEAD,否则响应的实体应该包含一个简短的超文本注释,其中有指向新URI的超链接。如果301状态码是在响应GET或HEAD以外的请求时收到的,用户代理不应该自动重定向请求,除非它能被用户确认,因为这可能会改变发出请求的条件。注意:当收到301状态码后自动重定向POST请求时,一些现有的HTTP/1.0用户代理会错误地将其改为GET请求。</target>
        </trans-unit>
        <trans-unit id="84c9980aa16b04f88efc81ddd498027c5e617c08" translate="yes" xml:space="preserve">
          <source>The requested resource is no longer available at the server and no
   forwarding address is known. This condition is expected to be
   considered permanent. Clients with link editing capabilities SHOULD
   delete references to the Request-URI after user approval. If the
   server does not know, or has no facility to determine, whether or not
   the condition is permanent, the status code 404 (Not Found) SHOULD be
   used instead. This response is cacheable unless indicated otherwise.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer working at the server's site. It is not
   necessary to mark all permanently unavailable resources as &quot;gone&quot; or
   to keep the mark for any length of time -- that is left to the
   discretion of the server owner.</source>
          <target state="translated">所请求的资源在服务器上已不可用,且不知道转发地址。这种情况会被认为是永久性的。具有链接编辑功能的客户端应该在用户批准后删除对Request-URI的引用。如果服务器不知道或没有设施确定该条件是否是永久性的,应使用状态代码404(Not Found)来代替。除非另有说明,否则该响应是可缓存的。410 响应的主要目的是通过通知接收者该资源是故意不可用的,以及服务器所有者希望删除指向该资源的远程链接来协助网络维护工作。这种事件常见于限时、促销服务和属于个人不再在服务器站点工作的资源。没有必要将所有永久不可用的资源标记为 &quot;消失&quot;,也没有必要在任何时间内保持这一标记 ----这由服务器所有者自行决定。</target>
        </trans-unit>
        <trans-unit id="3a016e600e3bce12c26484b50fa5be354243d903" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection MAY be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s) , since many pre-HTTP/1.1 user agents do not
   understand the 307 status. Therefore, the note SHOULD contain the
   information necessary for a user to repeat the original request on
   the new URI.

   If the 307 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.</source>
          <target state="translated">请求的资源暂时驻留在不同的URI下。由于重定向可能偶尔会被改变,所以客户端应该在未来的请求中继续使用Request-URI。这个响应只有在Cache-Control或Expires头字段显示的情况下才是可缓存的。临时URI应该由响应中的Location字段给出。除非请求方法是HEAD,否则响应的实体应该包含一个简短的超文本注释,并带有指向新URI的超链接,因为许多前HTTP/1.1的用户代理不理解307状态。因此,该注释应包含必要的信息,以便用户在新的URI上重复原始请求。如果307状态码是在响应GET或HEAD以外的请求时收到的,除非用户确认,否则用户代理不得自动重定向该请求,因为这可能会改变发出请求的条件。</target>
        </trans-unit>
        <trans-unit id="a9d909310ffffdfd39320376da2640abfbc56135" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection might be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s). 

   If the 302 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; specify that the client is not allowed
      to change the method on the redirected request.  However, most
      existing user agent implementations treat 302 as if it were a 303
      response, performing a GET on the Location field-value regardless
      of the original request method. The status codes 303 and 307 have
      been added for servers that wish to make unambiguously clear which
      kind of reaction is expected of the client.</source>
          <target state="translated">所请求的资源临时位于其他URI下。由于重定向有时可能会更改，因此客户端应继续将Request-URI用于将来的请求。仅当由Cache-Control或Expires标头字段指示时，此响应才可缓存。临时URI应该由响应中的Location字段给出。除非请求方法是HEAD，否则响应的实体应包含简短的超文本注释，并带有指向新URI的超链接。如果响应GET或HEAD以外的请求而接收到302状态码，则用户代理不得自动重定向该请求，除非用户可以确认，因为这可能会更改发出该请求的条件。注意：&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;指定不允许客户端更改重定向请求上的方法。但是，大多数现有的用户代理实现都将302视为303响应，而不管原始请求方法如何，都对Location字段值执行GET。已为希望明确弄清客户端期望哪种反应的服务器添加了状态代码303和307。</target>
        </trans-unit>
        <trans-unit id="24d06f0884418e17262e5806d51e7313670997da" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host header
   field (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), report an error if it is missing from an
   HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) are among
   the most important changes defined by HTTP/1.1. 

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed.  The Host header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional
   requirements were placed on all HTTP/1.1 requests in order to ensure
   complete adoption.  At the time of this writing, most HTTP-based
   services are dependent upon the Host header field for targeting
   requests.</source>
          <target state="translated">客户端和服务器支持主机标头字段（&lt;a href=&quot;#section-5.4&quot;&gt;第5.4节&lt;/a&gt;）的要求，如果HTTP / 1.1请求中缺少该错误，则报告错误，并接受绝对URI（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节）&lt;/a&gt;）是HTTP / 1.1定义的最重要的更改之一。较旧的HTTP / 1.0客户端假定IP地址和服务器是一对一的关系。除了将请求定向到的IP地址之外，没有其他成熟的机制可用于区分请求的目标服务器。 Host标头字段是在HTTP / 1.1的开发过程中引入的，尽管大多数HTTP / 1.0浏览器很快实现了Host标头字段，但对所有HTTP / 1.1请求都提出了附加要求，以确保完全采用。在撰写本文时，大多数基于HTTP的服务都依赖于Host Header字段来定向请求。</target>
        </trans-unit>
        <trans-unit id="554d1e6bd5194783475ebafadd7bbf4b3ceb10ad" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host request-
   header, report an error if the Host request-header (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) is
   missing from an HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.1.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;) are among the most important changes defined by this
   specification.

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The changes outlined above will
   allow the Internet, once older HTTP clients are no longer common, to
   support multiple Web sites from a single IP address, greatly
   simplifying large operational Web servers, where allocation of many
   IP addresses to a single host has created serious problems. The
   Internet will also be able to recover the IP addresses that have been
   allocated for the sole purpose of allowing special-purpose domain
   names to be used in root-level HTTP URLs. Given the rate of growth of
   the Web, and the number of servers already deployed, it is extremely 

   important that all implementations of HTTP (including updates to
   existing HTTP/1.0 applications) correctly implement these
   requirements:

      - Both clients and servers MUST support the Host request-header.

      - A client that sends an HTTP/1.1 request MUST send a Host header.

      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1
        request does not include a Host request-header.

      - Servers MUST accept absolute URIs.</source>
          <target state="translated">客户端和服务器支持主机请求标头的要求，如果HTTP / 1.1请求中缺少主机请求标头（&lt;a href=&quot;#section-14.23&quot;&gt;第14.23节&lt;/a&gt;），则报告错误，并接受绝对URI（&lt;a href=&quot;#section-5.1.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2 &lt;/a&gt;节））是本规范定义的最重要的更改之一。较旧的HTTP / 1.0客户端假定IP地址和服务器是一对一的关系。除了将请求定向到的IP地址之外，没有其他成熟的机制可用于区分请求的目标服务器。上面概述的更改将使Internet（不再使用较旧的HTTP客户端时）可以从单个IP地址支持多个网站，从而大大简化了大型可操作Web服务器，其中将多个IP地址分配给单个主机会造成严重问题。互联网也将能够恢复已分配的IP地址，其唯一目的是允许在根级HTTP URL中使用特殊用途的域名。鉴于网络的增长速度，以及已经部署的服务器数量，所有HTTP实现（包括对现有HTTP / 1.0应用程序的更新）正确实现以下要求非常重要：-客户端和服务器都必须支持主机请求头。 -发送HTTP / 1.1请求的客户端必须发送主机标头。 -如果HTTP / 1.1请求不包含主机请求标头，则服务器必须报告400（错误请求）错误。 -服务器必须接受绝对URI。1个请求务必发送一个Host标头。 -如果HTTP / 1.1请求不包含主机请求标头，则服务器必须报告400（错误请求）错误。 -服务器必须接受绝对URI。1个请求必须发送一个Host标头。 -如果HTTP / 1.1请求不包含主机请求标头，则服务器必须报告400（错误请求）错误。 -服务器必须接受绝对URI。</target>
        </trans-unit>
        <trans-unit id="b85098c9f819adbf87cde9578f01517d8065c6c2" translate="yes" xml:space="preserve">
          <source>The resource identified by the request is only capable of generating
   response entities which have content characteristics not acceptable
   according to the accept headers sent in the request.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of available entity characteristics and location(s)
   from which the user or user agent can choose the one most
   appropriate. The entity format is specified by the media type given
   in the Content-Type header field. Depending upon the format and the
   capabilities of the user agent, selection of the most appropriate
   choice MAY be performed automatically. However, this specification
   does not define any standard for such automatic selection.

      Note: HTTP/1.1 servers are allowed to return responses which are
      not acceptable according to the accept headers sent in the
      request. In some cases, this may even be preferable to sending a
      406 response. User agents are encouraged to inspect the headers of
      an incoming response to determine if it is acceptable.

   If the response could be unacceptable, a user agent SHOULD
   temporarily stop receipt of more data and query the user for a
   decision on further actions.</source>
          <target state="translated">请求所确定的资源只能生成响应实体,这些实体的内容特征根据请求中发送的接受头不能接受。除非是HEAD请求,否则响应应该包括一个实体,其中包含一个可用的实体特性和位置的列表,用户或用户代理可以从中选择一个最合适的实体。实体格式由Content-Type头域中给出的媒体类型指定。根据格式和用户代理的能力,可以自动选择最合适的选择。但是,本规范并没有为这种自动选择定义任何标准。注意:HTTP/1.1服务器允许返回根据请求中发送的accept头不能接受的响应。在某些情况下,这甚至可能比发送406响应更可取。我们鼓励用户代理检查传入响应的头信息,以确定它是否可以接受。如果响应可能是不可接受的,用户代理showould暂时停止接收更多的数据,并询问用户以决定进一步的行动。</target>
        </trans-unit>
        <trans-unit id="7d38c9e9eed37f8ebb054ffe20689cb741c8e1bf" translate="yes" xml:space="preserve">
          <source>The resource that is being accessed is locked.</source>
          <target state="translated">正在访问的资源被锁定。</target>
        </trans-unit>
        <trans-unit id="2e6d65ce6753d6adca24d41c2f2aab6cad178c87" translate="yes" xml:space="preserve">
          <source>The response from the server may include these.</source>
          <target state="translated">服务器的响应可能包括这些。</target>
        </trans-unit>
        <trans-unit id="90c2bdf40568a1e2ecdbf3f858aafd5dbb66fd4d" translate="yes" xml:space="preserve">
          <source>The response header below will cause compatible user agents to disallow cross-origin no-cors requests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0596f7bd46252bc01ceca1b37ff3abcdb40b4bc7" translate="yes" xml:space="preserve">
          <source>The response header fields allow the server to pass additional
   information about the response beyond what is placed in the
   status-line.  These header fields give information about the server,
   about further access to the target resource, or about related
   resources.

   Although each response header field has a defined meaning, in
   general, the precise semantics might be further refined by the
   semantics of the request method and/or response status code.</source>
          <target state="translated">响应头字段允许服务器在状态行中的内容之外传递关于响应的附加信息。这些头字段给出了关于服务器的信息,关于进一步访问目标资源的信息,或者关于相关资源的信息。虽然每个响应头字段都有确定的含义,但一般来说,精确的语义可能会由请求方法和/或响应状态码的语义进一步细化。</target>
        </trans-unit>
        <trans-unit id="ff7a362ee27a0f1762005f0ec6ebc5bb964259ee" translate="yes" xml:space="preserve">
          <source>The response is extremely simple too: it only consisted of the file itself.</source>
          <target state="translated">响应也极其简单:它只由文件本身组成。</target>
        </trans-unit>
        <trans-unit id="a187e434f07fa362732384aa76405b41edb39ff9" translate="yes" xml:space="preserve">
          <source>The response may &lt;strong&gt;not&lt;/strong&gt; be stored in &lt;em&gt;any&lt;/em&gt; cache. Note that this will not prevent a valid &lt;em&gt;pre-existing&lt;/em&gt; cached response being returned. Clients can set &lt;code&gt;max-age=0&lt;/code&gt; to also clear existing cache responses, as this forces the cache to revalidate with the server (no other directives have an effect when used with &lt;code&gt;no-store&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="175c4a1ccf44338f289e8f6a8f5b206b71c5531a" translate="yes" xml:space="preserve">
          <source>The response may be stored by &lt;em&gt;any&lt;/em&gt; cache, even if the response is normally non-cacheable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2982c4aaa9bc3f78fafab7d00a3ebb08a20bc3" translate="yes" xml:space="preserve">
          <source>The response may be stored by &lt;em&gt;any&lt;/em&gt; cache, even if the response is normally non-cacheable. However, the stored response MUST &lt;em&gt;always&lt;/em&gt; go through validation with the origin server first before using it, therefore, you cannot use &lt;code&gt;no-cache&lt;/code&gt; in-conjunction with &lt;code&gt;immutable&lt;/code&gt;. &lt;code&gt;no-store&lt;/code&gt;&lt;em&gt;This directive is not effective in preventing caches from storing your response.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa0d406c5950086dcf14084183c400a270e03bf" translate="yes" xml:space="preserve">
          <source>The response may be stored only by a &lt;em&gt;browser's&lt;/em&gt; cache, even if the response is normally non-cacheable. &lt;code&gt;no-store&lt;/code&gt;&lt;em&gt;This directive is not effective in preventing caches from storing your response.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18efe3bb77387fcf6dc94b18b57204fcd81a30a1" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header that holds the allowed methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513c2898705ac68cc3e3ee06f80d9c90116f1922" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header with the allowed methods:</source>
          <target state="translated">然后，响应包含带有允许方法的&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;标头：</target>
        </trans-unit>
        <trans-unit id="18088efa80d68a5ff78b12db71323e5708eee380" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is missing the required &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, which is used to determine whether or not the resource can be accessed by content operating within the current origin.</source>
          <target state="translated">对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求的响应缺少必需的&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;标头，该标头用于确定当前源内操作的内容是否可以访问资源。</target>
        </trans-unit>
        <trans-unit id="bacd2f05b83c3c39f0e7214a569bb88e96978d01" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid header name.</source>
          <target state="translated">服务器发送的对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求的响应包括一个&lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;头，该头包括至少一个无效的头名。</target>
        </trans-unit>
        <trans-unit id="15a529998feb2d569f6cffb35b10491d075a60be" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid method name.</source>
          <target state="translated">服务器发送的对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求的响应包括一个&lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;标头，该标头包含至少一个无效的方法名称。</target>
        </trans-unit>
        <trans-unit id="2ae0be16c13fe096b642ef89520ae9e65e43a5c6" translate="yes" xml:space="preserve">
          <source>The response to the request can be found under a different URI and
   SHOULD be retrieved using a GET method on that resource. This method
   exists primarily to allow the output of a POST-activated script to
   redirect the user agent to a selected resource. The new URI is not a
   substitute reference for the originally requested resource. The 303
   response MUST NOT be cached, but the response to the second
   (redirected) request might be cacheable.

   The different URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

      Note: Many pre-HTTP/1.1 user agents do not understand the 303
      status. When interoperability with such clients is a concern, the
      302 status code may be used instead, since most user agents react
      to a 302 response as described here for 303.</source>
          <target state="translated">对请求的响应可以在不同的URI下找到,并且应该使用该资源的GET方法来检索。这种方法的存在主要是为了允许POST激活脚本的输出将用户代理重定向到选定的资源。新的URI不能替代最初请求的资源的引用。303响应必须不被缓存,但第二个(重定向)请求的响应可能是可缓存的。不同的URI应该由响应中的Location字段给出。除非请求方法是HEAD,否则响应的实体应该包含一个简短的超文本注释,并带有指向新URI的超链接。注意:许多HTTP/1.1之前的用户代理不理解303状态。当与这些客户机的互操作性是一个问题时,可以使用302状态代码来代替,因为大多数用户代理对302响应的反应就像这里对303的描述。</target>
        </trans-unit>
        <trans-unit id="12506b704a003858abdf13381ee9b21f91a7f1af" translate="yes" xml:space="preserve">
          <source>The response-header fields allow the server to pass additional
   information about the response which cannot be placed in the Status-
   Line. These header fields give information about the server and about
   further access to the resource identified by the Request-URI.

       response-header = Accept-Ranges           ; &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;
                       | Age                     ; &lt;a href=&quot;#section-14.6&quot;&gt;Section 14.6&lt;/a&gt;
                       | ETag                    ; &lt;a href=&quot;#section-14.19&quot;&gt;Section 14.19&lt;/a&gt;
                       | Location                ; &lt;a href=&quot;#section-14.30&quot;&gt;Section 14.30&lt;/a&gt;
                       | Proxy-Authenticate      ; &lt;a href=&quot;#section-14.33&quot;&gt;Section 14.33&lt;/a&gt; 

                       | Retry-After             ; &lt;a href=&quot;#section-14.37&quot;&gt;Section 14.37&lt;/a&gt;
                       | Server                  ; &lt;a href=&quot;#section-14.38&quot;&gt;Section 14.38&lt;/a&gt;
                       | Vary                    ; &lt;a href=&quot;#section-14.44&quot;&gt;Section 14.44&lt;/a&gt;
                       | WWW-Authenticate        ; &lt;a href=&quot;#section-14.47&quot;&gt;Section 14.47&lt;/a&gt;

   Response-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of response-
   header fields if all parties in the communication recognize them to
   be response-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">响应头字段允许服务器传递关于响应的其他信息，这些信息不能放在状态行中。这些头字段提供有关服务器以及对由Request-URI标识的资源的进一步访问的信息。 response-header =接受范围；&lt;a href=&quot;#section-14.5&quot;&gt;第14.5节&lt;/a&gt; |年龄; &lt;a href=&quot;#section-14.6&quot;&gt;第14.6节&lt;/a&gt; | ETag; &lt;a href=&quot;#section-14.19&quot;&gt;第14.19节&lt;/a&gt; |位置 ; &lt;a href=&quot;#section-14.30&quot;&gt;第14.30节&lt;/a&gt; |代理验证&lt;a href=&quot;#section-14.33&quot;&gt;第14.33节&lt;/a&gt; |重试后&lt;a href=&quot;#section-14.37&quot;&gt;第14.37节&lt;/a&gt; | 服务器; &lt;a href=&quot;#section-14.38&quot;&gt;第14.38节&lt;/a&gt; | 变化; &lt;a href=&quot;#section-14.44&quot;&gt;第14.44节&lt;/a&gt; | WWW认证 只有结合协议版本的更改，才能可靠地扩展&lt;a href=&quot;#section-14.47&quot;&gt;14.47节的&lt;/a&gt;响应头字段名称。但是，如果通信中的所有各方都将它们识别为响应头字段，则可以为新的或实验性的头字段赋予响应头字段的语义。无法识别的标头字段被视为实体标头字段。</target>
        </trans-unit>
        <trans-unit id="de697a10218156ed8950f6eb5d8f3042358089a2" translate="yes" xml:space="preserve">
          <source>The result of applying the digest algorithm to the resource representation and encoding the result. The choice of digest algorithm also determines the encoding to use: for example &lt;code&gt;SHA-256&lt;/code&gt; uses base64 encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9dacdcee08be9c8b87ede18aa52688f460db02e" translate="yes" xml:space="preserve">
          <source>The resulting string is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded (&lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt;).</source>
          <target state="translated">结果字符串是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt;编码的（ &lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe3f7b6dc9ffc173061b38ba8ad0c8201cfdcbaa" translate="yes" xml:space="preserve">
          <source>The returned metainformation in the entity-header is not the
   definitive set as available from the origin server, but is gathered
   from a local or a third-party copy. The set presented MAY be a subset
   or superset of the original version. For example, including local
   annotation information about the resource might result in a superset
   of the metainformation known by the origin server. Use of this
   response code is not required and is only appropriate when the
   response would otherwise be 200 (OK).</source>
          <target state="translated">实体头中返回的元信息并不是来自原服务器的最终集合,而是从本地或第三方副本中收集的。显示的集合可能是原始版本的子集或超集。例如,包含资源的本地注释信息可能会导致源服务器已知的元信息的超集。不需要使用此响应代码,只有在响应为200(OK)时才适合使用。</target>
        </trans-unit>
        <trans-unit id="18a95000f2ca8553876b3106954ec5daa00d8eec" translate="yes" xml:space="preserve">
          <source>The revision version added to revved resources doesn't need to be a classical revision string like 1.1.3, or even a monotonously growing suite of number. It can be anything that prevent collisions, like a hash or a date.</source>
          <target state="translated">添加到已修订资源中的修订版本不需要是像 1.1.3 这样的经典修订字符串,甚至不需要是一个单调增长的数字套件。它可以是任何可以防止碰撞的东西,比如哈希值或日期。</target>
        </trans-unit>
        <trans-unit id="b125ccbfa7a0e3bda312abb6c814a3f729297ece" translate="yes" xml:space="preserve">
          <source>The root of a Category Document is the &quot;app:categories&quot; element.  An
   app:categories element can contain zero or more atom:category
   elements from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] namespace
   (&quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;).

   An atom:category child element that has no &quot;scheme&quot; attribute
   inherits the attribute from its app:categories parent.  An atom:
   category child element with an existing &quot;scheme&quot; attribute does not
   inherit the &quot;scheme&quot; value of its app:categories parent element. 

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       }

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories</source>
          <target state="translated">类别文档的根是&amp;ldquo; app：categories&amp;rdquo;元素。 app：categories元素可以包含零个或多个来自Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]名称空间（&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &amp;rdquo;的atom：category元素没有&amp;ldquo; scheme&amp;rdquo;属性的atom：category子元素会从其app：categories父级继承该属性。具有现有&amp;ldquo; scheme&amp;rdquo;属性的atom：category子元素不会继承其app的&amp;ldquo; scheme&amp;rdquo;值：Category父元素。 &amp;ldquo; no&amp;rdquo;} ?，属性方案{atomURI} ?,（atomCategory *，undefinedContent）} appOutOfLineCategories =元素app：类别{属性href {atomURI}，undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories</target>
        </trans-unit>
        <trans-unit id="dac1669f4b5c683593043fc93e45f9e39b9b3183" translate="yes" xml:space="preserve">
          <source>The root of a Service Document is the &quot;app:service&quot; element.

   The app:service element is the container for service information
   associated with one or more Workspaces.  An app:service element MUST
   contain one or more app:workspace elements.

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   start = appService

   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }</source>
          <target state="translated">服务文档的根是&amp;ldquo; app：service&amp;rdquo;元素。 app：service元素是与一个或多个工作区关联的服务信息的容器。一个app：service元素必须包含一个或多个app：workspace元素。名称空间app =&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;rdquo; start = appService appService =元素app：service {appCommonAttributes，（appWorkspace +＆extensionElement *）}}</target>
        </trans-unit>
        <trans-unit id="7cc82da0d72b8678f1e0f58ad59a34e42ed94203" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ded409a46c9e2ba7534a99504667ab5ee8ab0f" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. In this case, it is an intermediate proxy that requires authentication. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="translated">相同的质询和响应机制可用于&lt;em&gt;代理身份验证&lt;/em&gt;。在这种情况下，它是需要身份验证的中间代理。由于资源认证和代理认证可以共存，因此需要不同的头和状态码集。在代理的情况下，具有挑战性的状态码为&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt;（需要代理身份验证），&amp;ldquo; &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;响应标头包含至少一个适用于代理的质询，并且&amp;ldquo; &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;请求标头用于向代理提供凭据服务器。</target>
        </trans-unit>
        <trans-unit id="0fb319a198a96a066c14d3602f889f224011cec2" translate="yes" xml:space="preserve">
          <source>The same-site attribute can have one of two values:</source>
          <target state="translated">同站点属性可以有两个值中的一个。</target>
        </trans-unit>
        <trans-unit id="a4b6e8afc97244358680d329fe8d9b651eecefb1" translate="yes" xml:space="preserve">
          <source>The second way to use Feature Policy is for controlling content within an iframe. Use the &lt;code&gt;allow&lt;/code&gt; attribute to specify a policy list for embedded content.</source>
          <target state="translated">使用功能策略的第二种方法是控制iframe中的内容。使用 &lt;code&gt;allow&lt;/code&gt; 属性为嵌入式内容指定策略列表。</target>
        </trans-unit>
        <trans-unit id="fe3498e5bef07e6ed03f63dc1e56c45eca481341" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Access Control Requests&lt;/a&gt; shows a header exchange between client and server. A server resource responding to a preflight requests needs to be able to make the following determinations:</source>
          <target state="translated">在部分&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;预检访问控制请求&lt;/a&gt;示出客户机和服务器之间的报头交换。响应预检请求的服务器资源需要能够做出以下确定：</target>
        </trans-unit>
        <trans-unit id="90f4ec1e7f4c071f00d99bb58a633629eba8d99f" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Access Control Requests&lt;/a&gt; shows you the header exchanges between client and server. Here is a PHP code segment that handles a Simple Request:</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;cors#Simple_requests&quot;&gt;简单访问控制请求&lt;/a&gt; &amp;rdquo;部分向您显示了客户端和服务器之间的标头交换。这是一个处理简单请求的PHP代码段：</target>
        </trans-unit>
        <trans-unit id="fa4d350781530c820391fd6c19e201ae2a7686b3" translate="yes" xml:space="preserve">
          <source>The semantics of GET are unchanged when applied to a collection,
   since GET is defined as, &quot;retrieve whatever information (in the form
   of an entity) is identified by the Request-URI&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  GET, when
   applied to a collection, may return the contents of an &quot;index.html&quot;
   resource, a human-readable view of the contents of the collection, or
   something else altogether.  Hence, it is possible that the result of
   a GET on a collection will bear no correlation to the membership of
   the collection.

   Similarly, since the definition of HEAD is a GET without a response
   message body, the semantics of HEAD are unmodified when applied to
   collection resources.</source>
          <target state="translated">GET的语义在应用于集合时不会更改，因为GET被定义为&amp;ldquo;检索Request-URI标识的任何信息（以实体的形式）&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]。当将GET应用于集合时，它可以返回&amp;ldquo; index.html&amp;rdquo;资源的内容，该集合的内容的人类可读视图或其他所有内容。因此，集合上GET的结果可能与集合的成员资格不相关。同样，由于HEAD的定义是没有响应消息主体的GET，因此将HEAD的语义应用于集合资源时不会被修改。</target>
        </trans-unit>
        <trans-unit id="396399030f5f70b59d96457aab0c93681f8f8559" translate="yes" xml:space="preserve">
          <source>The sender provides a list of digests which it is prepared to accept, and the server uses one of them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fa260f74b6e3042ef94427143bf9ccc1a0c47d" translate="yes" xml:space="preserve">
          <source>The server MUST generate an &lt;code&gt;Allow&lt;/code&gt; header field in a 405 response containing a list of the target resource's currently supported methods.</source>
          <target state="translated">服务器必须在405响应中生成 &lt;code&gt;Allow&lt;/code&gt; 标头字段，其中包含目标资源当前支持的方法的列表。</target>
        </trans-unit>
        <trans-unit id="0562c768d353635c49184c6fe08601647efdac48" translate="yes" xml:space="preserve">
          <source>The server also sends &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; with a value of &quot;&lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt;&quot;, confirming that these are permitted headers to be used with the actual request. Like &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; is a comma separated list of acceptable headers.</source>
          <target state="translated">服务器还发送值为&amp;ldquo; &lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt; &amp;rdquo;的 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ，确认这些是允许与实际请求一起使用的标头。像 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 一样， &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 是逗号分隔的可接受标题列表。</target>
        </trans-unit>
        <trans-unit id="583376e0dba516f5c2825a92214abd5ad5c19f01" translate="yes" xml:space="preserve">
          <source>The server answers with a code &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; with the header &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt;.</source>
          <target state="translated">服务器用标头 &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt; 的代码&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;回答：http://example.org/whaddup。</target>
        </trans-unit>
        <trans-unit id="9ba7f7b6673dbfa8ce3c9b9d755ecdbe8064fd0d" translate="yes" xml:space="preserve">
          <source>The server can choose to ignore the request, for any reason, in which case it should just respond as though the &lt;code&gt;Upgrade&lt;/code&gt; header had not been sent (for example, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200 OK&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51013a828db296ccfd288d288af04cf909401777" translate="yes" xml:space="preserve">
          <source>The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.</source>
          <target state="translated">服务器找不到请求的资源。在浏览器中,这意味着URL未被识别。在API中,这也意味着端点有效,但资源本身不存在。服务器也可能会发送这个响应而不是403,以向未经授权的客户端隐藏资源的存在。这个响应代码可能是最著名的一个,因为它在网络上经常出现。</target>
        </trans-unit>
        <trans-unit id="5c4ccfae2be68876da45c9c1dc793bd8e937dfdb" translate="yes" xml:space="preserve">
          <source>The server can not find the requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurrence on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79671e2c7c02bbc1b0253a58c7f5460d4f719ccf" translate="yes" xml:space="preserve">
          <source>The server can now redirect to a secure version of the site. A &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header can be used so that the site isn't served by caches to clients that don&amp;rsquo;t support the upgrade mechanism.</source>
          <target state="translated">服务器现在可以重定向到站点的安全版本。一个&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;头部可以用来让网站不会被缓存投放到不支持升级机制的客户。</target>
        </trans-unit>
        <trans-unit id="c5445db0622182456257f92e9ecf6bebf5eeb4a0" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource and if both values match (that is, the resource has not changed), the server send back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Not Modified&lt;/code&gt; status, without any body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="translated">服务器将客户端的 &lt;code&gt;ETag&lt;/code&gt; （通过 &lt;code&gt;If-None-Match&lt;/code&gt; 发送）与 &lt;code&gt;ETag&lt;/code&gt; 进行比较，以获取其当前资源版本，如果两个值都匹配（即资源未更改），则服务器会发送&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Not Modified&lt;/code&gt; 状态，没有任何主体，它告诉客户端响应的缓存版本仍然可以很好地使用（&lt;em&gt;新鲜&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="605fba61796e65ffe01c32b3fab960c6c121a075" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource, and if both values match (that is, the resource has not changed), the server sends back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; status, without a body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c7564335ef677861a44bea5af3ab893bbca1c3" translate="yes" xml:space="preserve">
          <source>The server could also consider other &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, such as &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">服务器还可以考虑其他&lt;a href=&quot;../content_negotiation&quot;&gt;内容协&lt;/a&gt;商标头，例如&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de85219a30abbe89bbf789c793cb5b7464c7af45" translate="yes" xml:space="preserve">
          <source>The server could not understand the request due to invalid syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96160ecd7ee13608af383e3bb73b0b35b5d6fb42" translate="yes" xml:space="preserve">
          <source>The server detected an infinite loop while processing the request.</source>
          <target state="translated">服务器在处理该请求时检测到一个无限循环。</target>
        </trans-unit>
        <trans-unit id="d4d0d326b4b9b27451ac87954663d1d88395013c" translate="yes" xml:space="preserve">
          <source>The server did not respond to the actual request (even if it responded to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;Preflight request&lt;/a&gt;). One scenario might be an HTTP service being developed that panicked without returning any data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718a8af818cfbe608b72da24119ebf87df3d139e" translate="yes" xml:space="preserve">
          <source>The server does not support any of the requested digest algorithms, so responds with a 400 error and includes another &lt;code&gt;Want-Digest&lt;/code&gt; header, listing the algorithms that it does support:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e228c6efc54e191da08ed522fb1aa98706bc14" translate="yes" xml:space="preserve">
          <source>The server does not support any of the requested digest algorithms, so uses a different algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedec016c5b57cc11eff3c532c6a93596d64f0f6" translate="yes" xml:space="preserve">
          <source>The server does not support the functionality required to fulfill the
   request. This is the appropriate response when the server does not
   recognize the request method and is not capable of supporting it for
   any resource.</source>
          <target state="translated">服务器不支持完成请求所需的功能。当服务器不识别请求方法,并且不能支持任何资源时,这是适当的响应。</target>
        </trans-unit>
        <trans-unit id="b05cf7bf3fff0832cc499297170da1dced108414" translate="yes" xml:space="preserve">
          <source>The server does not support, or refuses to support, the HTTP protocol
   version that was used in the request message. The server is
   indicating that it is unable or unwilling to complete the request
   using the same major version as the client, as described in &lt;a href=&quot;#section-3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;, other than with this error message. The response SHOULD contain
   an entity describing why that version is not supported and what other
   protocols are supported by that server.</source>
          <target state="translated">服务器不支持或拒绝支持请求消息中使用的HTTP协议版本。服务器会指示它无法或不愿意使用与客户端相同的主要版本（如&lt;a href=&quot;#section-3.1&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1 &lt;/a&gt;节中所述）来完成请求，但带有此错误消息除外。响应应该包含一个实体，描述为什么不支持该版本以及该服务器支持哪些其他协议。</target>
        </trans-unit>
        <trans-unit id="c06e31cc29dd99d9a9450fd0a50b146873ff8448" translate="yes" xml:space="preserve">
          <source>The server doesn't have total knowledge of the browser. Even with the Client Hints extension, it has not a complete knowledge of the capabilities of the browser. Unlike reactive content negotiation where the client makes the choice, the server choice is always somewhat arbitrary.</source>
          <target state="translated">服务器并不完全了解浏览器的情况。即使有客户端提示扩展,它对浏览器的功能也没有完全的了解。与反应式内容协商由客户端做出选择不同,服务器的选择总是有些随意性。</target>
        </trans-unit>
        <trans-unit id="59d4cf28c9831ade812e9ba3919040baedea9266" translate="yes" xml:space="preserve">
          <source>The server encountered an unexpected condition which prevented it
   from fulfilling the request.</source>
          <target state="translated">服务器遇到了意外情况,无法完成请求。</target>
        </trans-unit>
        <trans-unit id="10710baff0a022ad3a742df8fef3c65957eb66a8" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.</source>
          <target state="translated">服务器内部配置错误:所选择的变体资源本身被配置为参与透明内容协商,因此不是协商过程中的适当端点。</target>
        </trans-unit>
        <trans-unit id="706ed34301bbcc058a72a5142e2a23a25bb1303a" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: transparent content negotiation for the request results in a circular reference.</source>
          <target state="translated">服务器内部配置错误:请求的透明内容协商导致循环引用。</target>
        </trans-unit>
        <trans-unit id="d758b127d939bbbe9c83eda748c2d96b939c4dc5" translate="yes" xml:space="preserve">
          <source>The server has encountered a situation it doesn't know how to handle.</source>
          <target state="translated">服务器遇到了不知道如何处理的情况。</target>
        </trans-unit>
        <trans-unit id="5cf27f01c140eea8ea3c01504b142779b0027690" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a &lt;code&gt;GET&lt;/code&gt; request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30dd73b04a13c811e1dbf9b2319193169edb03c" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="translated">服务器已经完成了对资源的GET请求,响应是应用于当前实例的一个或多个实例操作结果的表示。</target>
        </trans-unit>
        <trans-unit id="e118a9d32f4f8ee5d1a291b20a7b4b379a234f47" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the partial GET request for the resource.
   The request MUST have included a Range header field (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;)
   indicating the desired range, and MAY have included an If-Range
   header field (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) to make the request conditional.

   The response MUST include the following header fields:

      - Either a Content-Range header field (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;) indicating
        the range included with this response, or a multipart/byteranges
        Content-Type including Content-Range fields for each part. If a
        Content-Length header field is present in the response, its
        value MUST match the actual number of OCTETs transmitted in the
        message-body.

      - Date

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request 

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the 206 response is the result of an If-Range request that used a
   strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), the response SHOULD NOT
   include other entity-headers. If the response is the result of an
   If-Range request that used a weak validator, the response MUST NOT
   include other entity-headers; this prevents inconsistencies between
   cached entity-bodies and updated headers. Otherwise, the response
   MUST include all of the entity-headers that would have been returned
   with a 200 (OK) response to the same request.

   A cache MUST NOT combine a 206 response with other previously cached
   content if the ETag or Last-Modified headers do not match exactly,
   see 13.5.4.

   A cache that does not support the Range and Content-Range headers
   MUST NOT cache 206 (Partial) responses.</source>
          <target state="translated">服务器已完成对资源的部分GET请求。该请求必须包含指示所需范围的Range标头字段（&lt;a href=&quot;#section-14.35&quot;&gt;第14.35节&lt;/a&gt;），并且可能包含If-Range标头字段（&lt;a href=&quot;#section-14.27&quot;&gt;第14.27节&lt;/a&gt;）以使请求成为条件请求。响应必须包含以下标头字段：-一个Content-Range标头字段（&lt;a href=&quot;#section-14.16&quot;&gt;第14.16节）&lt;/a&gt;）表示此响应所包含的范围，或者是一个多部分/字节范围的Content-Type，其中包括每个部分的Content-Range字段。如果响应中存在Content-Length头字段，则其值必须与消息正文中发送的OCTET的实际数量匹配。 -日期-ETag和/或Content-Location（如果标头是在对同一请求的200响应中发送的）-Expires，Cache-Control和/或Vary（如果字段值可能与任何发送的字段值不同）相同变体的先前响应如果206响应是使用强缓存验证器的If-Range请求的结果（请参见&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3节）&lt;/a&gt;），则响应不应包含其他实体标题。如果该响应是使用弱验证器的If-Range请求的结果，则该响应务必不包括其他实体标头；这可以防止缓存的实体与更新的标头之间的不一致。否则，响应必须包括所有对同一请求返回200（确定）响应的实体头。如果ETag或Last-Modified头不完全匹配，则缓存不得将206响应与其他先前缓存的内容组合在一起，请参见13.5.4。不支持Range和Content-Range头的缓存必须不缓存206（部分）响应。</target>
        </trans-unit>
        <trans-unit id="9154c7f74bf47c2abcfe8e8637f31d473b4ccf8a" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request and the user agent SHOULD reset
   the document view which caused the request to be sent. This response
   is primarily intended to allow input for actions to take place via
   user input, followed by a clearing of the form in which the input is
   given so that the user can easily initiate another input action. The
   response MUST NOT include an entity.</source>
          <target state="translated">服务器已经满足了请求,用户代理应该重新设置导致请求发送的文档视图。这个响应主要是为了允许通过用户输入来进行操作,然后清除输入的表单,以便用户可以轻松地发起另一个输入操作。响应必须不包括实体。</target>
        </trans-unit>
        <trans-unit id="0ee5c3ee094642bb5d46e9cb3d051a90abd31149" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request but does not need to return an
   entity-body, and might want to return updated metainformation. The
   response MAY include new or updated metainformation in the form of
   entity-headers, which if present SHOULD be associated with the
   requested variant.

   If the client is a user agent, it SHOULD NOT change its document view
   from that which caused the request to be sent. This response is
   primarily intended to allow input for actions to take place without
   causing a change to the user agent's active document view, although
   any new or updated metainformation SHOULD be applied to the document
   currently in the user agent's active view.

   The 204 response MUST NOT include a message-body, and thus is always
   terminated by the first empty line after the header fields.</source>
          <target state="translated">服务器已经满足了请求,但不需要返回实体主体,可能希望返回更新的元信息。响应可能包括以实体头形式出现的新的或更新的元信息,如果存在的话,这些元信息应该与请求的变体相关联。如果客户机是用户代理,它不应该改变导致发送请求的文档视图。这个响应主要是为了允许输入动作,而不引起用户代理的活动文档视图的改变,尽管任何新的或更新的元信息都应该应用到当前用户代理活动视图中的文档。204响应必须不包括消息体,因此总是以头字段后的第一行空结束。</target>
        </trans-unit>
        <trans-unit id="8c2ef715f1697c767e016f66e48a9c5ad3088fc4" translate="yes" xml:space="preserve">
          <source>The server has not found anything matching the Request-URI. No
   indication is given of whether the condition is temporary or
   permanent. The 410 (Gone) status code SHOULD be used if the server
   knows, through some internally configurable mechanism, that an old
   resource is permanently unavailable and has no forwarding address.
   This status code is commonly used when the server does not wish to
   reveal exactly why the request has been refused, or when no other
   response is applicable.</source>
          <target state="translated">服务器没有找到任何与Request-URI匹配的内容。没有说明这种情况是暂时的还是永久的。如果服务器通过一些内部可配置的机制知道一个旧的资源是永久不可用的,并且没有转发地址,那么应该使用410(Gone)状态码。这种状态码通常用于服务器不希望确切地揭示请求被拒绝的原因,或者没有其他适用的响应时。</target>
        </trans-unit>
        <trans-unit id="1d3eb58f597e0c6c5fa76c0069741d7639896309" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d2c9e44a151f75cad87b75d25351ab5902d469" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">服务器在此响应中包括一个&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;响应标头，以指示它切换到的协议。&lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;协议升级机制&lt;/a&gt;一文中详细描述了该过程。</target>
        </trans-unit>
        <trans-unit id="be80728dab68882cff956fbc4def7165d17d07e6" translate="yes" xml:space="preserve">
          <source>The server is currently unable to handle the request due to a
   temporary overloading or maintenance of the server. The implication
   is that this is a temporary condition which will be alleviated after
   some delay. If known, the length of the delay MAY be indicated in a
   Retry-After header. If no Retry-After is given, the client SHOULD
   handle the response as it would for a 500 response.

      Note: The existence of the 503 status code does not imply that a
      server must use it when becoming overloaded. Some servers may wish
      to simply refuse the connection.</source>
          <target state="translated">由于服务器暂时超载或维护,服务器目前无法处理该请求。这意味着这是一种暂时性的状况,将在一定的延迟后得到缓解。如果知道,延迟的长度可以在Retry-After头中表示。如果没有Retry-After,客户端应该像处理500响应那样处理响应。注意:503状态码的存在并不意味着服务器必须在超载时使用它。有些服务器可能希望直接拒绝连接。</target>
        </trans-unit>
        <trans-unit id="baf2d9062e2499753136835fe0c821934d565f38" translate="yes" xml:space="preserve">
          <source>The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the &lt;code&gt;Retry-After:&lt;/code&gt; HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.</source>
          <target state="translated">服务器尚未准备好处理请求。常见原因是服务器因维护而停机或过载。请注意，与此响应一起，应发送一个说明问题的用户友好页面。此响应应用于临时条件，并且 &lt;code&gt;Retry-After:&lt;/code&gt; HTTP标头应尽可能包含恢复服务之前的估计时间。网站管理员还必须注意与该响应一起发送的与缓存相关的标头，因为通常不应缓存这些临时条件响应。</target>
        </trans-unit>
        <trans-unit id="30401629d5451d683706de07ce99fc1a19648e2c" translate="yes" xml:space="preserve">
          <source>The server is overloaded and cannot afford the computational overhead induced by the compression requirement. Typically, Microsoft recommends not to compress if a server uses more than 80% of its computational power.</source>
          <target state="translated">服务器负荷过重,无法承受压缩要求带来的计算开销。通常情况下,如果服务器使用的计算能力超过80%,微软建议不要进行压缩。</target>
        </trans-unit>
        <trans-unit id="91058d54183ce48b758a3923ca1dd0add318d618" translate="yes" xml:space="preserve">
          <source>The server is refusing to process a request because the request
   entity is larger than the server is willing or able to process. The
   server MAY close the connection to prevent the client from continuing
   the request.

   If the condition is temporary, the server SHOULD include a Retry-
   After header field to indicate that it is temporary and after what
   time the client MAY try again.</source>
          <target state="translated">服务器拒绝处理请求,因为请求实体大于服务器愿意或能够处理的范围。服务器可以关闭连接以防止客户端继续请求。如果这种情况是暂时的,服务器应该包含一个Retry-After头,以表明这是暂时的,在什么时间之后客户端可以再试。</target>
        </trans-unit>
        <trans-unit id="555c0a61bfb0c95cce342015880bc471fe52028d" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the Request-URI
   is longer than the server is willing to interpret. This rare
   condition is only likely to occur when a client has improperly
   converted a POST request to a GET request with long query
   information, when the client has descended into a URI &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself), or when the server is under attack by a client attempting to
   exploit security holes present in some servers using fixed-length
   buffers for reading or manipulating the Request-URI.</source>
          <target state="translated">服务器拒绝服务该请求,因为Request-URI比服务器愿意解释的长。这种罕见的情况只有在以下情况下才有可能发生:客户端将POST请求不适当地转换为带有长查询信息的GET请求,客户端陷入URI重定向的 &quot;黑洞&quot;(例如,重定向的URI前缀指向自身的后缀),或者服务器受到客户端的攻击,客户端试图利用某些服务器中存在的安全漏洞,使用固定长度的缓冲区来读取或操作Request-URI。</target>
        </trans-unit>
        <trans-unit id="b7583fbc3987a772449c07846db7b69d3aab25c3" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the entity of
   the request is in a format not supported by the requested resource
   for the requested method.</source>
          <target state="translated">服务器拒绝为请求提供服务,因为请求的实体的格式不为请求方法的资源所支持。</target>
        </trans-unit>
        <trans-unit id="9e40f61b278945136b6bf8c69ccb6441c6101dc0" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">由于请求头字段过大,服务器不愿意处理该请求。减少请求头字段的大小后,可以重新提交请求。</target>
        </trans-unit>
        <trans-unit id="2cabf4085dccd9d1a0d60a5bef8f53aaaa7eb900" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b402009d984cfa7b4aa7445fadf6432930d62bf" translate="yes" xml:space="preserve">
          <source>The server may either refuse the upgrade &amp;mdash; in this case it merely ignores the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header and sends back a regular response (&lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; if it can serve the requested resource, a &lt;code&gt;30x&lt;/code&gt; status code if it wants to perform a redirect, a &lt;code&gt;40x&lt;/code&gt; or &lt;code&gt;50x&lt;/code&gt; one if it can't serve the requested resource) &amp;mdash; or accept the upgrade. In this case, it sends back a &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; with an Upgrade header that specifies the protocol chosen.</source>
          <target state="translated">服务器可以拒绝升级-在这种情况下，它仅忽略 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 标头并发送回常规响应（如果可以为请求的资源提供服务，则返回 &lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; 如果要执行重定向，则返回 &lt;code&gt;30x&lt;/code&gt; 状态代码，一个 &lt;code&gt;40x&lt;/code&gt; 或 &lt;code&gt;50x&lt;/code&gt; 的，如果它不能提供所请求的资源） -或接受升级。在这种情况下，它将发回带有指定指定协议的升级头的 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eb9ea8eac80a46172e3c3d063d37cbb8a09735e" translate="yes" xml:space="preserve">
          <source>The server may specify &quot;*&quot; as a wildcard, thereby allowing any origin to see timing resources.</source>
          <target state="translated">服务器可以指定 &quot;*&quot;作为通配符,从而允许任何原点看到定时资源。</target>
        </trans-unit>
        <trans-unit id="767e4fc07c131eef7a83181be5734574f3f01fab" translate="yes" xml:space="preserve">
          <source>The server now can respond if it will accept a request under these circumstances. In this example, the server response says that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0103c094e5add7857b8d5242900bc764e81c4d56" translate="yes" xml:space="preserve">
          <source>The server now checks the request headers and may respond with a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) response to instruct the client to go ahead and send the message body, or it will send a &lt;a href=&quot;../status/417&quot;&gt;&lt;code&gt;417&lt;/code&gt;&lt;/a&gt; (Expectation Failed) status if any of the expectations cannot be met.</source>
          <target state="translated">服务器现在检查请求标头，并可能以&lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt;（继续）响应进行响应以指示客户端继续发送消息正文，或者如果无法满足任何期望，则服务器将发送&lt;a href=&quot;../status/417&quot;&gt; &lt;code&gt;417&lt;/code&gt; &lt;/a&gt;（预期失败）状态。</target>
        </trans-unit>
        <trans-unit id="e1283857d0934fd62a1b18ee296b4ffd28fea393" translate="yes" xml:space="preserve">
          <source>The server only permits access to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="translated">服务器只允许通过单一来源onlinebanking.jumbobank.com访问专门通过HTTPS加载的文件。</target>
        </trans-unit>
        <trans-unit id="26883acb60acb54540a0e576eaa8444f3824e5cd" translate="yes" xml:space="preserve">
          <source>The server permits access only to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c7fec239224320ece1ddcef09fb8d8afe6a922" translate="yes" xml:space="preserve">
          <source>The server processes the request, sending back its answer, providing a status code and appropriate data.</source>
          <target state="translated">服务器对请求进行处理,发回答复,并提供状态码和相应的数据。</target>
        </trans-unit>
        <trans-unit id="4a76d046fb30a4094df60f730aa186a8214f36f9" translate="yes" xml:space="preserve">
          <source>The server refuses the attempt to brew coffee with a teapot.</source>
          <target state="translated">服务员拒绝了用茶壶冲泡咖啡的尝试。</target>
        </trans-unit>
        <trans-unit id="0521746f768ead6cf341a3de72d80f86946a50aa" translate="yes" xml:space="preserve">
          <source>The server refuses to accept the request without a defined Content-
   Length. The client MAY repeat the request if it adds a valid
   Content-Length header field containing the length of the message-body
   in the request message.</source>
          <target state="translated">服务器拒绝接受没有定义Content-Length的请求。客户端可以重复请求,如果它在请求消息中添加一个有效的Content-Length头字段,其中包含消息体的长度。</target>
        </trans-unit>
        <trans-unit id="098d1595780b213e964cc55bccf5bbf26c81cacc" translate="yes" xml:space="preserve">
          <source>The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header in a 426 response to indicate the required protocol(s).</source>
          <target state="translated">服务器拒绝使用当前协议执行请求，但是在客户端升级到其他协议后，服务器可能愿意这样做。服务器在426响应中发送一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头，以指示所需的协议。</target>
        </trans-unit>
        <trans-unit id="82c879297c83c6c0c7f5e4355a3573667d1d3938" translate="yes" xml:space="preserve">
          <source>The server responds to a client with a &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt; (Unauthorized) response status and provides information on how to authorize with a &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; response header containing at least one challenge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96c620c10c72c2facba569247c0abd76880b504" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and says that &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, and &lt;code&gt;OPTIONS&lt;/code&gt; are viable methods to query the resource in question. This header is similar to the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of CORS.</source>
          <target state="translated">服务器以&lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 进行&lt;/a&gt;响应，并说 &lt;code&gt;POST&lt;/code&gt; ， &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;OPTIONS&lt;/code&gt; 是查询相关资源的可行方法。此标头类似于&amp;ldquo; &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;响应&amp;rdquo;标头，但严格在CORS的上下文中使用。</target>
        </trans-unit>
        <trans-unit id="0adba182e0838c8ba807f3caebecfe1ff5519a80" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; and says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question. Note that this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control.</source>
          <target state="translated">服务器以 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 响应，并说 &lt;code&gt;POST&lt;/code&gt; 和 &lt;code&gt;GET&lt;/code&gt; 是查询有问题资源的可行方法。请注意，此标头类似于&amp;ldquo; &lt;a href=&quot;headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;响应&amp;rdquo;标头，但严格在访问控制的上下文中使用。</target>
        </trans-unit>
        <trans-unit id="50340f4cfb4f858ac4e526eb22f4eb0cf5120e8d" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Origin: http://foo.example&lt;/code&gt;, restricting access to just the requesting origin domain. It also responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, which says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question (this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7efc45419f666af1044e66769f805e285297d7" translate="yes" xml:space="preserve">
          <source>The server responds with the scheme used, indicated by the &lt;code&gt;Content-Encoding&lt;/code&gt; response header.</source>
          <target state="translated">服务器以使用的方案进行响应，该方案由 &lt;code&gt;Content-Encoding&lt;/code&gt; 响应标头指示。</target>
        </trans-unit>
        <trans-unit id="adb6ebfb2d7ba636e549327e9964bd8e4a9aa87e" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status and a &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; header, indicating that a multipart byterange follows. Each part contains its own &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Content-Range&lt;/code&gt; fields and the required boundary parameter specifies the boundary string used to separate each body-part.</source>
          <target state="translated">服务器以&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 状态和&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 进行&lt;/a&gt;响应 &lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; 标头，指示遵循多部分字节范围。每个零件都包含自己的 &lt;code&gt;Content-Type&lt;/code&gt; 和 &lt;code&gt;Content-Range&lt;/code&gt; 字段，并且所需的border参数指定用于分隔每个主体零件的边界字符串。</target>
        </trans-unit>
        <trans-unit id="d9701baf78124c3a98a96cf4e906d3722ade4288" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status:</source>
          <target state="translated">服务器以&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 状态响应：</target>
        </trans-unit>
        <trans-unit id="60a245e6b24fad30a550d86662bff1af7454a2ee" translate="yes" xml:space="preserve">
          <source>The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with this response to indicate the required protocol(s).</source>
          <target state="translated">服务器发送带有此响应的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头，以指示所需的协议。</target>
        </trans-unit>
        <trans-unit id="9542fcfca4223129b519747385fa48be52ecf048" translate="yes" xml:space="preserve">
          <source>The server sends this response to direct the client to get the requested resource at another URI with same method that was used in the prior request. This has the same semantics as the &lt;code&gt;302 Found&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">服务器发送此响应，以指示客户端使用先前请求中使用的相同方法在另一个URI中获取请求的资源。这具有相同的语义 &lt;code&gt;302 Found&lt;/code&gt; HTTP响应代码，不同之处在于用户代理&lt;em&gt;必须不&lt;/em&gt;改变使用的HTTP方法：如果 &lt;code&gt;POST&lt;/code&gt; 是在第一请求中所使用的， &lt;code&gt;POST&lt;/code&gt; 必须在第二请求被使用。</target>
        </trans-unit>
        <trans-unit id="5c7306d33878ab5bc99fecabc06252df15d1029f" translate="yes" xml:space="preserve">
          <source>The server sent this response to direct the client to get the requested resource at another URI with a GET request.</source>
          <target state="translated">服务器发送这个响应,是为了引导客户端通过GET请求在另一个URI上获取所请求的资源。</target>
        </trans-unit>
        <trans-unit id="848c3b9ad4be0c1360d99c2d9af3ef34c33fe75c" translate="yes" xml:space="preserve">
          <source>The server takes the value of the Sec-WebSocket-Key sent in the handshake request, appends &lt;code&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&lt;/code&gt;, takes SHA-1 of the new value, and is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf25e98d428f5cff29ccef9eba702a25e100fa8" translate="yes" xml:space="preserve">
          <source>The server understands and is willing to comply with the client's
   request, via the Upgrade message header field (&lt;a href=&quot;#section-14.42&quot;&gt;section 14.42&lt;/a&gt;), for a
   change in the application protocol being used on this connection. The
   server will switch protocols to those defined by the response's
   Upgrade header field immediately after the empty line which
   terminates the 101 response.

   The protocol SHOULD be switched only when it is advantageous to do
   so. For example, switching to a newer version of HTTP is advantageous
   over older versions, and switching to a real-time, synchronous
   protocol might be advantageous when delivering resources that use
   such features.</source>
          <target state="translated">服务器理解并愿意通过&amp;ldquo;升级消息头&amp;rdquo;字段（&lt;a href=&quot;#section-14.42&quot;&gt;第14.42节&lt;/a&gt;）来满足客户端对在此连接上使用的应用协议进行更改的请求。服务器将在终止101响应的空行之后立即将协议切换到由响应的Upgrade标头字段定义的协议。仅在有利时才应切换协议。例如，切换到新版本的HTTP优于旧版本，并且在传递使用此类功能的资源时，切换到实时同步协议可能是有利的。</target>
        </trans-unit>
        <trans-unit id="1d1ec0c651dbab18735a86dfc8ae8c14372b5e8a" translate="yes" xml:space="preserve">
          <source>The server understood the request, but is refusing to fulfill it.
   Authorization will not help and the request SHOULD NOT be repeated.
   If the request method was not HEAD and the server wishes to make
   public why the request has not been fulfilled, it SHOULD describe the
   reason for the refusal in the entity.  If the server does not wish to
   make this information available to the client, the status code 404
   (Not Found) can be used instead.</source>
          <target state="translated">服务器理解了该请求,但拒绝执行该请求。授权无济于事,请求不应该被重复。如果请求方法不是HEAD,并且服务器希望公开请求未被满足的原因,它应该在实体中描述拒绝的原因。如果服务器不希望向客户端公开这些信息,可以使用状态码404(Not Found)代替。</target>
        </trans-unit>
        <trans-unit id="2bccd21746e24e17c4d6598c2feaeef9e50bab37" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;a href=&quot;headers/sec-websocket-accept&quot;&gt;&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;&lt;/a&gt; header will have a value computed based upon the specified &lt;code&gt;&lt;var&gt;key&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94809fc6f53d174f5374acd4dfb1f7acb678c149" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; header will have a value computed based upon the specified &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">服务器响应的 &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; 标头将具有基于指定 &lt;code&gt;key&lt;/code&gt; 计算的值。</target>
        </trans-unit>
        <trans-unit id="f3ef1a39a25ddc08d8e0d5a5bb5464d92b09bc2a" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, did not receive a
   timely response from the upstream server specified by the URI (e.g.
   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed
   to access in attempting to complete the request.

      Note: Note to implementors: some deployed proxies are known to
      return 400 or 500 when DNS lookups time out.</source>
          <target state="translated">服务器在充当网关或代理时,在试图完成请求时没有收到URI指定的上游服务器(如HTTP、FTP、LDAP)或其他一些需要访问的辅助服务器(如DNS)的及时响应。注:实施者注意:已知一些部署的代理服务器在DNS查找超时时返回400或500。</target>
        </trans-unit>
        <trans-unit id="46e47cc0b16529d905f0b1b3af210872557d572b" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, received an invalid
   response from the upstream server it accessed in attempting to
   fulfill the request.</source>
          <target state="translated">服务器在充当网关或代理时,在试图完成请求时收到了来自其访问的上游服务器的无效响应。</target>
        </trans-unit>
        <trans-unit id="cad9f838a72a1881211f8a63fadbd9aa2da06441" translate="yes" xml:space="preserve">
          <source>The set of common methods for HTTP/1.1 is defined below. Although
   this set can be expanded, additional methods cannot be assumed to
   share the same semantics for separately extended clients and servers.

   The Host request-header field (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) MUST accompany all
   HTTP/1.1 requests.</source>
          <target state="translated">HTTP / 1.1的一组常用方法在下面定义。尽管可以扩展此集合，但是不能假定其他方法可以为单独扩展的客户端和服务器共享相同的语义。主机请求标头字段（&lt;a href=&quot;#section-14.23&quot;&gt;第14.23节&lt;/a&gt;）务必伴随所有HTTP / 1.1请求。</target>
        </trans-unit>
        <trans-unit id="3aa1224052f644e6f5d9789fe1626a5e5119f08c" translate="yes" xml:space="preserve">
          <source>The simplest MIME type consists of a &lt;var&gt;type&lt;/var&gt; and a &lt;var&gt;subtype&lt;/var&gt;; these are each strings which, when concatenated with a slash (&lt;code&gt;/&lt;/code&gt;) between them, comprise a MIME type. No whitespace is allowed in a MIME type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fc403f1552de7486f1009e75d3e485460c6c32" translate="yes" xml:space="preserve">
          <source>The site returns a generic success message confirming the post was published. The server specifies &lt;em&gt;where&lt;/em&gt; the new post is with &lt;code&gt;Content-Location&lt;/code&gt;:</source>
          <target state="translated">该网站返回一条通用成功消息，确认该帖子已发布。服务器指定&lt;em&gt;其中&lt;/em&gt;的新职位是 &lt;code&gt;Content-Location&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7fbace9bd6e583c6dea1bfd3ddf4f66e59607425" translate="yes" xml:space="preserve">
          <source>The size of a frame payload is limited by the maximum size that a
   receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.  This
   setting can have any value between 2^14 (16,384) and 2^24-1
   (16,777,215) octets, inclusive.

   All implementations MUST be capable of receiving and minimally
   processing frames up to 2^14 octets in length, plus the 9-octet frame
   header (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;).  The size of the frame header is not included
   when describing frame sizes.

      Note: Certain frame types, such as PING (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;), impose
      additional limits on the amount of payload data allowed.

   An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame
   exceeds the size defined in SETTINGS_MAX_FRAME_SIZE, exceeds any
   limit defined for the frame type, or is too small to contain
   mandatory frame data.  A frame size error in a frame that could alter
   the state of the entire connection MUST be treated as a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;); this includes any frame carrying a header
   block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) (that is, HEADERS, PUSH_PROMISE, and
   CONTINUATION), SETTINGS, and any frame with a stream identifier of 0. 

   Endpoints are not obligated to use all available space in a frame.
   Responsiveness can be improved by using frames that are smaller than
   the permitted maximum size.  Sending large frames can result in
   delays in sending time-sensitive frames (such as RST_STREAM,
   WINDOW_UPDATE, or PRIORITY), which, if blocked by the transmission of
   a large frame, could affect performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ec569438b6e170956f6c9751913bd129236874" translate="yes" xml:space="preserve">
          <source>The size of the resource, in decimal number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb8b58154cc46b27e579e11d1cdd3ea67056760" translate="yes" xml:space="preserve">
          <source>The special value ''clear&quot; indicates that the origin requests all alternatives for that origin to be invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40812bee8a9705438af783eaa9ebe956256664d2" translate="yes" xml:space="preserve">
          <source>The special value of '&lt;code&gt;*&lt;/code&gt;' means that the server-driven content negotiation also uses information not conveyed in a header to choose the appropriate content.</source>
          <target state="translated">特殊值' &lt;code&gt;*&lt;/code&gt; '表示服务器驱动的内容协商还使用标头中未传达的信息来选择适当的内容。</target>
        </trans-unit>
        <trans-unit id="8f79a17c3099080cc2dd18760e1e6dd5db53ca77" translate="yes" xml:space="preserve">
          <source>The specification advices that names and descriptions should be kept as short as possible (use abbreviations and omit optional values where possible) to minimize the HTTP overhead.</source>
          <target state="translated">该规范建议,名称和描述应尽量简短(尽可能使用缩写和省略可选值),以减少HTTP开销。</target>
        </trans-unit>
        <trans-unit id="6830140aefcebc442d186cdf8f55cdcc404c9a85" translate="yes" xml:space="preserve">
          <source>The specification has been substantially rewritten for clarity.

   The conditions under which an authenticated response can be cached
   have been clarified.  (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   New status codes can now define that caches are allowed to use
   heuristic freshness with them.  Caches are now allowed to calculate
   heuristic freshness for URIs with query components.  (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The algorithm for calculating age is now less conservative.  Caches
   are now required to handle dates with time zones as if they're
   invalid, because it's not possible to accurately guess.
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;)

   The Content-Location response header field is no longer used to
   determine the appropriate response to use when validating.
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)

   The algorithm for selecting a cached negotiated response to use has
   been clarified in several ways.  In particular, it now explicitly
   allows header-specific canonicalization when processing selecting
   header fields.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   Requirements regarding denial-of-service attack avoidance when
   performing invalidation have been clarified.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache invalidation only occurs when a successful response is
   received.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache directives are explicitly defined to be case-insensitive.
   Handling of multiple instances of cache directives when only one is
   expected is now defined.  (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;)

   The &quot;no-store&quot; request directive doesn't apply to responses; i.e., a
   cache can satisfy a request with no-store on it and does not
   invalidate it.  (&lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;)

   The qualified forms of the private and no-cache cache directives are
   noted to not be widely implemented; for example, &quot;private=foo&quot; is
   interpreted by many caches as simply &quot;private&quot;.  Additionally, the
   meaning of the qualified form of no-cache has been clarified.
   (&lt;a href=&quot;#section-5.2.2&quot;&gt;Section 5.2.2&lt;/a&gt;)

   The &quot;no-cache&quot; response directive's meaning has been clarified.
   (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;) 

   The one-year limit on Expires header field values has been removed;
   instead, the reasoning for using a sensible value is given.
   (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The Pragma header field is now only defined for backwards
   compatibility; future pragmas are deprecated.  (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;)

   Some requirements regarding production and processing of the Warning
   header fields have been relaxed, as it is not widely implemented.
   Furthermore, the Warning header field no longer uses &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   encoding, nor does it allow multiple languages, as these aspects were
   not implemented.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   This specification introduces the Cache Directive and Warn Code
   Registries, and defines considerations for new cache directives.
   (&lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt; and &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;)</source>
          <target state="translated">为了清楚起见，已经对该规范进行了实质性的重写。已经阐明了可以缓存经过身份验证的响应的条件。 （&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;）现在，新的状态代码可以定义允许缓存对其使用启发式新鲜度。现在允许缓存为具有查询组件的URI计算启发式新鲜度。 （&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;）现在，用于计算年龄的算法不再那么保守。现在，高速缓存需要处理带有时区的日期，就好像它们是无效的一样，因为不可能准确猜测。 （&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt;）Content-Location响应标头字段不再用于确定验证时要使用的适当响应。 （&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）以多种方式阐明了选择缓存的协商使用响应的算法。特别是，它现在在处理选择标题字段时显式地允许特定于标题的规范化。 （&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;）阐明了执行无效时避免拒绝服务攻击的要求。 （&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）仅当收到成功的响应时才会发生缓存无效。 （&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）缓存指令被明确定义为不区分大小写。现在定义仅需要一个时就处理高速缓存指令的多个实例。 （&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;）&amp;ldquo; no-store&amp;rdquo;请求指令不适用于响应；即，高速缓存可以满足其上没有存储的请求，并且不会使请求无效。 （&lt;a href=&quot;#section-5.2.1.5&quot;&gt;第5.2.1.5节&lt;/a&gt;）注意，私有和无缓存缓存指令的限定形式并未得到广泛实施；例如，许多缓存将&amp;ldquo; private = foo&amp;rdquo;解释为简单的&amp;ldquo; private&amp;rdquo;。此外，已经阐明了无缓存的合格形式的含义。 （&lt;a href=&quot;#section-5.2.2&quot;&gt;第5.2.2节&lt;/a&gt;）&amp;ldquo; no-cache&amp;rdquo;响应指令的含义已经阐明。 （&lt;a href=&quot;#section-5.2.2.2&quot;&gt;第5.2.2.2节&lt;/a&gt;）已删除了Expires标头字段值的一年限制；而是给出了使用合理值的理由。 （&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）现在仅为了向后兼容而定义了Pragma标头字段；不建议使用将来的实用程序。 （&lt;a href=&quot;#section-5.4&quot;&gt;第5.4节&lt;/a&gt;）关于警告标头字段的生产和处理的一些要求已经放宽，因为它没有得到广泛实施。此外，警告标头字段不再使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; 编码，也不允许多种语言，因为未实现这些方面。 （&lt;a href=&quot;#section-5.5&quot;&gt;第5.5节&lt;/a&gt;）本规范介绍了缓存指令和警告代码注册表，并定义了有关新缓存指令的注意事项。 （&lt;a href=&quot;#section-7.1&quot;&gt;第7.1 &lt;/a&gt;&lt;a href=&quot;#section-7.2&quot;&gt;节&lt;/a&gt;和第7.2节）</target>
        </trans-unit>
        <trans-unit id="69f7236ac3c099aef6887071703596241bc5ffd5" translate="yes" xml:space="preserve">
          <source>The specified HTTPS proxy should be used</source>
          <target state="translated">应该使用指定的HTTPS代理</target>
        </trans-unit>
        <trans-unit id="53a5be96dd5bb71c6d16a8d35e8c39cbe4374a0d" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server (with the specified SOCK version) should be used</source>
          <target state="translated">应使用指定的SOCKS服务器(具有指定的SOCK版本)。</target>
        </trans-unit>
        <trans-unit id="303a58e78e8f8eb268fe6f62c8b7f193b6bc1142" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server should be used</source>
          <target state="translated">应该使用指定的SOCKS服务器</target>
        </trans-unit>
        <trans-unit id="68cc27ab7cd860287da7fdc9be46fedaaa277c72" translate="yes" xml:space="preserve">
          <source>The specified proxy should be used</source>
          <target state="translated">应使用指定的代理。</target>
        </trans-unit>
        <trans-unit id="6b8ade5bf013491609fa2a91c4e3f35610d584fc" translate="yes" xml:space="preserve">
          <source>The standardized header:</source>
          <target state="translated">标准化的标题。</target>
        </trans-unit>
        <trans-unit id="f7bf0204749a2c35928a6f9840f70eb32df13567" translate="yes" xml:space="preserve">
          <source>The start line of an HTTP response, called the &lt;em&gt;status line&lt;/em&gt;, contains the following information:</source>
          <target state="translated">HTTP响应的起始行（称为&lt;em&gt;状态行&lt;/em&gt;）包含以下信息：</target>
        </trans-unit>
        <trans-unit id="f31c6de41f53a39d348494f7a67a1dcc8252643d" translate="yes" xml:space="preserve">
          <source>The start-line and HTTP headers of the HTTP message are collectively known as the &lt;em&gt;head&lt;/em&gt; of the requests, whereas its payload is known as the &lt;em&gt;body&lt;/em&gt;.</source>
          <target state="translated">HTTP消息的起始行和HTTP标头统称为请求的&lt;em&gt;头&lt;/em&gt;，而其有效载荷称为&lt;em&gt;body&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f72d9e6a8a95e3d9c5ddb845c0490a8f4e705e6" translate="yes" xml:space="preserve">
          <source>The status code registry has been updated with the registrations
   below: 

   +-------+-------------------------------+----------------+
   | Value | Description                   | Reference      |
   +-------+-------------------------------+----------------+
   | 100   | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;  |
   | 101   | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;  |
   | 200   | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;  |
   | 201   | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;  |
   | 202   | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;  |
   | 203   | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;  |
   | 204   | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;  |
   | 205   | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;  |
   | 300   | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;  |
   | 301   | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;  |
   | 302   | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;  |
   | 303   | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;  |
   | 305   | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;  |
   | 306   | (Unused)                      | &lt;a href=&quot;#section-6.4.6&quot;&gt;Section 6.4.6&lt;/a&gt;  |
   | 307   | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;  |
   | 400   | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;  |
   | 402   | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;  |
   | 403   | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;  |
   | 404   | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;  |
   | 405   | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;  |
   | 406   | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;  |
   | 408   | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;  |
   | 409   | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;  |
   | 410   | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;  |
   | 411   | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt; |
   | 413   | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt; |
   | 414   | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt; |
   | 415   | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt; |
   | 417   | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt; |
   | 426   | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt; |
   | 500   | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;  |
   | 501   | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;  |
   | 502   | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;  |
   | 503   | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;  |
   | 504   | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;  |
   | 505   | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;  |
   +-------+-------------------------------+----------------+</source>
          <target state="translated">状态代码注册表已使用以下注册进行了更新：+ ------- + ----------------------------- -+ ---------------- + |价值|描述参考| + ------- + ------------------------------- + --------- ------- + | 100 |继续| &lt;a href=&quot;#section-6.2.1&quot;&gt;第6.2.1节&lt;/a&gt; | | 101 |交换协议| &lt;a href=&quot;#section-6.2.2&quot;&gt;第6.2.2节&lt;/a&gt; | | 200 |好的&lt;a href=&quot;#section-6.3.1&quot;&gt;第6.3.1节&lt;/a&gt; | | 201 |已创建| &lt;a href=&quot;#section-6.3.2&quot;&gt;第6.3.2节&lt;/a&gt; | | 202 |接受| &lt;a href=&quot;#section-6.3.3&quot;&gt;第6.3.3节&lt;/a&gt; | | 203 |非权威信息| &lt;a href=&quot;#section-6.3.4&quot;&gt;第6.3.4节&lt;/a&gt; | | 204 |没有内容|&lt;a href=&quot;#section-6.3.5&quot;&gt;第6.3.5节&lt;/a&gt; | | 205 |重置内容| &lt;a href=&quot;#section-6.3.6&quot;&gt;第6.3.6节&lt;/a&gt; | | 300 |多种选择| &lt;a href=&quot;#section-6.4.1&quot;&gt;第6.4.1节&lt;/a&gt; | | 301 |永久移动| &lt;a href=&quot;#section-6.4.2&quot;&gt;第6.4.2节&lt;/a&gt; | | 302 |找到| &lt;a href=&quot;#section-6.4.3&quot;&gt;第6.4.3节&lt;/a&gt; | | 303 |查看其他| &lt;a href=&quot;#section-6.4.4&quot;&gt;第6.4.4节&lt;/a&gt; | | 305 |使用代理| &lt;a href=&quot;#section-6.4.5&quot;&gt;第6.4.5节&lt;/a&gt; | | 306 | （未使用）| &lt;a href=&quot;#section-6.4.6&quot;&gt;第6.4.6节&lt;/a&gt; | | 307 |临时重定向| &lt;a href=&quot;#section-6.4.7&quot;&gt;第6.4.7节&lt;/a&gt; | | 400 |错误的请求| &lt;a href=&quot;#section-6.5.1&quot;&gt;第6.5.1节&lt;/a&gt; | | 402 |需要付款| &lt;a href=&quot;#section-6.5.2&quot;&gt;第6.5.2节&lt;/a&gt; | | 403 |禁止&lt;a href=&quot;#section-6.5.3&quot;&gt;第6.5.3节&lt;/a&gt; | | 404 |找不到&lt;a href=&quot;#section-6.5.4&quot;&gt;第6.5.4节&lt;/a&gt; | | 405 |不允许的方法&lt;a href=&quot;#section-6.5.5&quot;&gt;第6.5.5节&lt;/a&gt; | | 406 |不可接受| &lt;a href=&quot;#section-6.5.6&quot;&gt;第6.5.6节&lt;/a&gt; | | 408 |请求超时| &lt;a href=&quot;#section-6.5.7&quot;&gt;第6.5.7节&lt;/a&gt; | | 409 |冲突| &lt;a href=&quot;#section-6.5.8&quot;&gt;第6.5.8节&lt;/a&gt; | | 410 |去了| &lt;a href=&quot;#section-6.5.9&quot;&gt;第6.5.9节&lt;/a&gt; | | 411 |所需长度| &lt;a href=&quot;#section-6.5.10&quot;&gt;第6.5.10节&lt;/a&gt; | | 413 |有效载荷过大|&lt;a href=&quot;#section-6.5.11&quot;&gt;第6.5.11节&lt;/a&gt; | | 414 | URI太长| &lt;a href=&quot;#section-6.5.12&quot;&gt;第6.5.12节&lt;/a&gt; | | 415 |不支持的媒体类型| &lt;a href=&quot;#section-6.5.13&quot;&gt;第6.5.13节&lt;/a&gt; | | 417 |期望失败| &lt;a href=&quot;#section-6.5.14&quot;&gt;第6.5.14节&lt;/a&gt; | | 426 |需要升级| &lt;a href=&quot;#section-6.5.15&quot;&gt;第6.5.15节&lt;/a&gt; | | 500 |内部服务器错误| &lt;a href=&quot;#section-6.6.1&quot;&gt;第6.6.1节&lt;/a&gt; | | 501 |未实施| &lt;a href=&quot;#section-6.6.2&quot;&gt;第6.6.2节&lt;/a&gt; | | 502 |错误的网关| &lt;a href=&quot;#section-6.6.3&quot;&gt;第6.6.3节&lt;/a&gt; | | 503 |服务不可用| &lt;a href=&quot;#section-6.6.4&quot;&gt;第6.6.4节&lt;/a&gt; | | 504 |网关超时| &lt;a href=&quot;#section-6.6.5&quot;&gt;第6.6.5节&lt;/a&gt; | | 505 | 不支持HTTP版本 &lt;a href=&quot;#section-6.6.6&quot;&gt;第6.6.6节&lt;/a&gt; | + ------- + ------------------------------- + --------- ------- +</target>
        </trans-unit>
        <trans-unit id="ed1c1d835f4a51029a15ccecbb039e7a11e9bd7a" translate="yes" xml:space="preserve">
          <source>The status codes listed below are defined in this specification,
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7232]&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7233]&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;Section&amp;nbsp;3 of
   [RFC7235]&lt;/a&gt;.  The reason phrases listed here are only recommendations
   -- they can be replaced by local equivalents without affecting the
   protocol.

   Responses with status codes that are defined as cacheable by default
   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in
   this specification) can be reused by a cache with heuristic
   expiration unless otherwise indicated by the method definition or
   explicit cache controls [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]; all other status codes are not
   cacheable by default. 

   +------+-------------------------------+--------------------------+
   | Code | Reason-Phrase                 | Defined in...            |
   +------+-------------------------------+--------------------------+
   | 100  | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;            |
   | 101  | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;            |
   | 200  | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;            |
   | 201  | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;            |
   | 202  | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;            |
   | 203  | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;            |
   | 204  | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;            |
   | 205  | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;            |
   | 206  | Partial Content               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7233]&lt;/a&gt; |
   | 300  | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;            |
   | 301  | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;            |
   | 302  | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;            |
   | 303  | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;            |
   | 304  | Not Modified                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt; |
   | 305  | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;            |
   | 307  | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;            |
   | 400  | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;            |
   | 401  | Unauthorized                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7235]&lt;/a&gt; |
   | 402  | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;            |
   | 403  | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;            |
   | 404  | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;            |
   | 405  | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;            |
   | 406  | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;            |
   | 407  | Proxy Authentication Required | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7235]&lt;/a&gt; |
   | 408  | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;            |
   | 409  | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;            |
   | 410  | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;            |
   | 411  | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt;           |
   | 412  | Precondition Failed           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7232]&lt;/a&gt; |
   | 413  | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt;           |
   | 414  | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt;           |
   | 415  | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt;           |
   | 416  | Range Not Satisfiable         | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7233]&lt;/a&gt; |
   | 417  | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt;           |
   | 426  | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;           |
   | 500  | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;            |
   | 501  | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;            |
   | 502  | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;            |
   | 503  | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;            |
   | 504  | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;            |
   | 505  | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;            |
   +------+-------------------------------+--------------------------+ 

   Note that this list is not exhaustive -- it does not include
   extension status codes defined in other specifications.  The complete
   list of status codes is maintained by IANA.  See &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; for
   details.</source>
          <target state="translated">下面列出的状态代码在本说明书中所定义， &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;[RFC7232]的第4节&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;[RFC7233]的第4节&lt;/a&gt;，和&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;[RFC7235]的第3节&lt;/a&gt;。此处列出的原因短语仅是建议-可以用本地等效项替换它们而不会影响协议。状态码默认定义为可缓存的响应（例如，本规范中的200、203、204、206、300、301、404、405、410、414和501）可以被具有启发式到期的缓存重用，除非否则由方法定义或显式缓存控件指示[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;];默认情况下，所有其他状态代码都不可缓存。 + ------ + ------------------------------- + ---------- ---------------- + |代码原因短语|定义于... | + ------ + ------------------------------- + ---------- ---------------- + | 100 |继续| &lt;a href=&quot;#section-6.2.1&quot;&gt;第6.2.1节&lt;/a&gt; | | 101 |交换协议| &lt;a href=&quot;#section-6.2.2&quot;&gt;第6.2.2节&lt;/a&gt; | | 200 |好的&lt;a href=&quot;#section-6.3.1&quot;&gt;第6.3.1节&lt;/a&gt; | | 201 |已创建| &lt;a href=&quot;#section-6.3.2&quot;&gt;第6.3.2节&lt;/a&gt; | | 202 |接受| &lt;a href=&quot;#section-6.3.3&quot;&gt;第6.3.3节&lt;/a&gt; | | 203 |非权威信息| &lt;a href=&quot;#section-6.3.4&quot;&gt;第6.3.4节&lt;/a&gt; | | 204 |没有内容| &lt;a href=&quot;#section-6.3.5&quot;&gt;第6.3.5节&lt;/a&gt; | | 205 |重置内容| &lt;a href=&quot;#section-6.3.6&quot;&gt;第6.3.6节&lt;/a&gt; | | 206 |部分内容| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;[RFC7233]的4.1节&lt;/a&gt; | | 300 |多种选择| &lt;a href=&quot;#section-6.4.1&quot;&gt;第6.4.1节&lt;/a&gt; | | 301 |永久移动| &lt;a href=&quot;#section-6.4.2&quot;&gt;第6.4.2节&lt;/a&gt; | | 302 |找到| &lt;a href=&quot;#section-6.4.3&quot;&gt;第6.4.3节&lt;/a&gt; | | 303 |查看其他| &lt;a href=&quot;#section-6.4.4&quot;&gt;第6.4.4节&lt;/a&gt; | | 304 |未修改| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]的4.1节&lt;/a&gt; | | 305 |使用代理|&lt;a href=&quot;#section-6.4.5&quot;&gt;第6.4.5节&lt;/a&gt; | | 307 |临时重定向| &lt;a href=&quot;#section-6.4.7&quot;&gt;第6.4.7节&lt;/a&gt; | | 400 |错误的请求| &lt;a href=&quot;#section-6.5.1&quot;&gt;第6.5.1节&lt;/a&gt; | | 401 |未经授权| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;[RFC7235]的第3.1节&lt;/a&gt; | | 402 |需要付款| &lt;a href=&quot;#section-6.5.2&quot;&gt;第6.5.2节&lt;/a&gt; | | 403 |禁止&lt;a href=&quot;#section-6.5.3&quot;&gt;第6.5.3节&lt;/a&gt; | | 404 |找不到&lt;a href=&quot;#section-6.5.4&quot;&gt;第6.5.4节&lt;/a&gt; | | 405 |不允许的方法&lt;a href=&quot;#section-6.5.5&quot;&gt;第6.5.5节&lt;/a&gt; | | 406 |不可接受| &lt;a href=&quot;#section-6.5.6&quot;&gt;第6.5.6节&lt;/a&gt; | | 407 |需要代理身份验证| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;[RFC7235]的3.2节&lt;/a&gt; | | 408 |请求超时| &lt;a href=&quot;#section-6.5.7&quot;&gt;第6.5.7节&lt;/a&gt; | | 409 |冲突| &lt;a href=&quot;#section-6.5.8&quot;&gt;第6.5.8节&lt;/a&gt; | | 410 |去了| &lt;a href=&quot;#section-6.5.9&quot;&gt;第6.5.9节&lt;/a&gt; | | 411 |所需长度| &lt;a href=&quot;#section-6.5.10&quot;&gt;第6.5.10节&lt;/a&gt; | | 412 |前提条件失败| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;[RFC7232]的第4.2节&lt;/a&gt; | | 413 |有效载荷过大| &lt;a href=&quot;#section-6.5.11&quot;&gt;第6.5.11节&lt;/a&gt; | | 414 | URI太长| &lt;a href=&quot;#section-6.5.12&quot;&gt;第6.5.12节&lt;/a&gt; | | 415 |不支持的媒体类型|&lt;a href=&quot;#section-6.5.13&quot;&gt;第6.5.13节&lt;/a&gt; | | 416 |范围无法满足| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;[RFC7233]的第4.4节&lt;/a&gt; | | 417 |期望失败| &lt;a href=&quot;#section-6.5.14&quot;&gt;第6.5.14节&lt;/a&gt; | | 426 |需要升级| &lt;a href=&quot;#section-6.5.15&quot;&gt;第6.5.15节&lt;/a&gt; | | 500 |内部服务器错误| &lt;a href=&quot;#section-6.6.1&quot;&gt;第6.6.1节&lt;/a&gt; | | 501 |未实施| &lt;a href=&quot;#section-6.6.2&quot;&gt;第6.6.2节&lt;/a&gt; | | 502 |错误的网关| &lt;a href=&quot;#section-6.6.3&quot;&gt;第6.6.3节&lt;/a&gt; | | 503 |服务不可用| &lt;a href=&quot;#section-6.6.4&quot;&gt;第6.6.4节&lt;/a&gt; | | 504 |网关超时| &lt;a href=&quot;#section-6.6.5&quot;&gt;第6.6.5节&lt;/a&gt; | | 505 | 不支持HTTP版本 &lt;a href=&quot;#section-6.6.6&quot;&gt;第6.6.6节&lt;/a&gt; | + ------ + ------------------------------- + ---------- ---------------- +请注意，此列表并不详尽-不包括其他规范中定义的扩展状态代码。状态代码的完整列表由IANA维护。有关详细信息，请参见&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abe4655086702c287f500adc1ea133906ee1151a" translate="yes" xml:space="preserve">
          <source>The status-code element is a three-digit integer code giving the
   result of the attempt to understand and satisfy the request.

   HTTP status codes are extensible.  HTTP clients are not required to
   understand the meaning of all registered status codes, though such
   understanding is obviously desirable.  However, a client MUST
   understand the class of any status code, as indicated by the first
   digit, and treat an unrecognized status code as being equivalent to
   the x00 status code of that class, with the exception that a
   recipient MUST NOT cache a response with an unrecognized status code.

   For example, if an unrecognized status code of 471 is received by a
   client, the client can assume that there was something wrong with its
   request and treat the response as if it had received a 400 (Bad
   Request) status code.  The response message will usually contain a
   representation that explains the status.

   The first digit of the status-code defines the class of response.
   The last two digits do not have any categorization role.  There are
   five values for the first digit:

   o  1xx (Informational): The request was received, continuing process

   o  2xx (Successful): The request was successfully received,
      understood, and accepted

   o  3xx (Redirection): Further action needs to be taken in order to
      complete the request

   o  4xx (Client Error): The request contains bad syntax or cannot be
      fulfilled 

   o  5xx (Server Error): The server failed to fulfill an apparently
      valid request</source>
          <target state="translated">status-code元素是一个三位数的整数代码,给出了试图理解和满足请求的结果。HTTP状态码是可扩展的。HTTP客户端不需要理解所有注册状态码的含义,尽管这种理解显然是可取的。然而,客户端必须理解任何状态码的类别,如第一个数字所示,并将未识别的状态码视为等同于该类别的x00状态码,例外的是,接收方必须不缓存带有未识别状态码的响应。例如,如果客户端收到了一个471的未识别状态码,客户端可以认为它的请求有问题,并把响应当作它收到了400(坏请求)状态码。响应消息通常会包含一个解释状态的表示。状态码的第一个数字定义了响应的类别。后两位数字没有任何分类作用。第一位数字有五种值:o 1xx(Informational)。o 2xx(成功):请求已收到,继续处理。o 3xx (重定向):请求被成功接收、理解和接受。o 4xx (客户端错误):o 5xx (服务器错误):请求包含错误的语法或不能被满足。服务器未能完成一个明显有效的请求。</target>
        </trans-unit>
        <trans-unit id="ea09a27e31ad55afff5e7a2614ea2f6ce9a594b2" translate="yes" xml:space="preserve">
          <source>The string can contain any number of the following building blocks, separated by a semicolon:</source>
          <target state="translated">该字符串可以包含以下任意数量的构件,用分号分隔。</target>
        </trans-unit>
        <trans-unit id="4d9a1a47b58bb09a0a513706e6f21fd9ec5db53c" translate="yes" xml:space="preserve">
          <source>The string following &lt;code&gt;filename&lt;/code&gt; should always be put into quotes; but, for compatibility reasons, many browsers try to parse unquoted names that contain spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6aeb189468d6962df260c9530bf2336ac50aef" translate="yes" xml:space="preserve">
          <source>The successful result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; is often not a &lt;code&gt;200&lt;/code&gt;&lt;code&gt;OK&lt;/code&gt; but a &lt;a href=&quot;204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt; (or a &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; when the resource is uploaded for the first time).</source>
          <target state="translated">&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;的成功结果通常不是 &lt;code&gt;200&lt;/code&gt; &lt;code&gt;OK&lt;/code&gt; ,而是&lt;a href=&quot;204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; &lt;code&gt;No Content&lt;/code&gt; （或第一次上传资源时 &lt;code&gt;Created&lt;/code&gt; &lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7f017eb4d89aedd499f70986d2b736c586f7c389" translate="yes" xml:space="preserve">
          <source>The syntax for these headers is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a73c4b6342735091b4f2e7334e43ba0cdd039a" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;Server-Timing&lt;/code&gt; header allows you to communicate metrics in different ways: server metric name only, metric with value, metric with value and description, and metric with description.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; 标头的语法允许您以不同的方式传达度量标准：仅服务器度量标准名称，具有值的度量标准，具有值和描述的度量标准以及具有描述的度量标准。</target>
        </trans-unit>
        <trans-unit id="9d244dc96c1e69e051bc4e338a9553169a494af1" translate="yes" xml:space="preserve">
          <source>The syntax of the Slug header is defined using the augmented BNF
   syntax defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;:

       LWS      = &amp;lt;defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC2616]&lt;/a&gt;&amp;gt;
       slugtext = %x20-7E | LWS
       Slug     = &quot;Slug&quot; &quot;:&quot; *slugtext

   The field value is the percent-encoded value of the UTF-8 encoding of
   the character sequence to be included (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC3986]&lt;/a&gt;
   for the definition of percent encoding, and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] for the
   definition of the UTF-8 encoding).

   Implementation note: to produce the field value from a character
   sequence, first encode it using the UTF-8 encoding, then encode all
   octets outside the ranges %20-24 and %26-7E using percent encoding
   (%25 is the ASCII encoding of &quot;%&quot;, thus it needs to be escaped).  To
   consume the field value, first reverse the percent encoding, then run
   the resulting octet sequence through a UTF-8 decoding process.</source>
          <target state="translated">Slug标头的语法使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;[RFC2616]第2.1节中&lt;/a&gt;定义的增强BNF语法定义：LWS = &amp;lt; &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;[RFC2616] 2.2节中&lt;/a&gt;定义的&amp;gt; slugtext =％x20-7E | LWS Slug =&amp;ldquo; Slug&amp;rdquo;&amp;ldquo;：&amp;rdquo; * slugtext字段值是要包含的字符序列的UTF-8编码的百分比编码值（ 有关百分比编码的定义，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;[RFC3986]第2.1节&lt;/a&gt;，[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;]（用于定义UTF-8编码）。实施说明：要从字符序列生成字段值，请先使用UTF-8编码对其进行编码，然后使用百分比编码对％20-24和％26-7E范围以外的所有八位字节进行编码（％25是ASCII编码&amp;ldquo;％&amp;rdquo;，因此需要对其进行转义）。要消耗字段值，请先反转百分比编码，然后通过UTF-8解码过程运行得到的八位位组序列。</target>
        </trans-unit>
        <trans-unit id="ea12de6efa63fc587d1f14a9b9c6eb9b2ffc6913" translate="yes" xml:space="preserve">
          <source>The table below describes the behavior that occurs when a lock
   request is made on a resource.

     +--------------------------+----------------+-------------------+
     | Current State            | Shared Lock OK | Exclusive Lock OK |
     +--------------------------+----------------+-------------------+
     | None                     | True           | True              |
     | Shared Lock              | True           | False             |
     | Exclusive Lock           | False          | False*            |
     +--------------------------+----------------+-------------------+

   Legend: True = lock may be granted.  False = lock MUST NOT be
   granted. *=It is illegal for a principal to request the same lock
   twice.

   The current lock state of a resource is given in the leftmost column,
   and lock requests are listed in the first row.  The intersection of a
   row and column gives the result of a lock request.  For example, if a
   shared lock is held on a resource, and an exclusive lock is
   requested, the table entry is &quot;false&quot;, indicating that the lock must
   not be granted.</source>
          <target state="translated">下表描述了在资源上提出锁请求时发生的行为。+--------------------------+----------------+-------------------+锁定请求的行为如下表所示。图例:True=可以授予锁定,False=锁定必须不被授予。False=鎖必須不被授予。*=主体请求两次相同的锁是非法的。资源的当前锁状态在最左边的列中给出,锁请求在第一行中列出。行和列的交点给出了锁请求的结果。例如,如果一个资源上持有共享锁,而请求的是独占锁,则表项为 &quot;false&quot;,表示不得授予该锁。</target>
        </trans-unit>
        <trans-unit id="b94957031bbb851c3915a1e070dc41a5bc6b1c5f" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, which nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="translated">HTTP请求的目标称为&amp;ldquo;资源&amp;rdquo;，其性质没有进一步定义。它可以是文档，照片或其他任何东西。每个资源都由一个统一资源标识符（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;）标识，该标识符在整个HTTP中都用于标识资源。</target>
        </trans-unit>
        <trans-unit id="a332edd44b965848f63f0bd63edb5a5baade7db6" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, whose nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0027de0398e06b3c16ab5881af95789a5ccae8db" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;.  HTTP does not
   limit the nature of a resource; it merely defines an interface that
   might be used to interact with resources.  Each resource is
   identified by a Uniform Resource Identifier (URI), as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;Section&amp;nbsp;2.7 of [RFC7230]&lt;/a&gt;.

   When a client constructs an HTTP/1.1 request message, it sends the
   target URI in one of various forms, as defined in (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of
   [RFC7230]&lt;/a&gt;).  When a request is received, the server reconstructs an
   effective request URI for the target resource (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;).

   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and a few
   request-modifying header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If there is a conflict
   between the method semantics and any semantic implied by the URI
   itself, as described in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;, the method semantics take
   precedence.</source>
          <target state="translated">HTTP请求的目标称为&amp;ldquo;资源&amp;rdquo;。 HTTP不限制资源的性质；它仅定义了可用于与资源交互的接口。每个资源都由统一资源标识符（URI）标识，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]的2.7节&lt;/a&gt;所述 。客户端构造HTTP / 1.1请求消息时，它将&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;以[RFC7230]的5.3节中&lt;/a&gt;定义的各种形式之一发送目标URI 。收到请求后，服务器将为目标资源重建有效的请求URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]的5.5节&lt;/a&gt;）。 HTTP的一个设计目标是将资源标识与请求语义分开，这是通过将请求语义赋予请求方法来实现的（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;）和一些请求修改标头字段（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果方法语义与URI本身所隐含的任何语义之间存在冲突（如&lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节中&lt;/a&gt;所述），则以方法语义为准。</target>
        </trans-unit>
        <trans-unit id="9418d48752326ff0dff5f0989dac32b59078dac8" translate="yes" xml:space="preserve">
          <source>The text of the error message will be something similar to the following:</source>
          <target state="translated">错误信息的文本将类似于以下内容。</target>
        </trans-unit>
        <trans-unit id="19c4cdcadd110283f71f254a20c3b6bdf9d892cf" translate="yes" xml:space="preserve">
          <source>The time in seconds the object has been in a proxy cache.</source>
          <target state="translated">对象在代理缓存中的时间(秒)。</target>
        </trans-unit>
        <trans-unit id="b56b41274f5f4a39f688c4966d1da21de98a88bd" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that a site is only to be accessed using HTTPS.</source>
          <target state="translated">浏览器应该记住一个网站只能使用HTTPS访问的时间,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="1ab5a5f12646b8f33cf1a6e834273c9a7926c03d" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that this site is only to be accessed using one of the defined keys.</source>
          <target state="translated">浏览器应记住本网站只能使用其中一个定义的键访问的时间,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="4110d2a33eaaff440bedc1360a1f4ce9d0cb92f4" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the object has been in a proxy cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e4cd11bd5edf3670dcbf4e3f786a4428a217a9" translate="yes" xml:space="preserve">
          <source>The total size of the document (or &lt;code&gt;'*'&lt;/code&gt; if unknown).</source>
          <target state="translated">文档的总大小（如果未知，则为 &lt;code&gt;'*'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f6969607248ffc4491cc44dae24cf7138a7b4be2" translate="yes" xml:space="preserve">
          <source>The transfer-length of a message is the length of the message-body as
   it appears in the message; that is, after any transfer-codings have
   been applied. When a message-body is included with a message, the
   transfer-length of that body is determined by one of the following
   (in order of precedence):

   1.Any response message which &quot;MUST NOT&quot; include a message-body (such
     as the 1xx, 204, and 304 responses and any response to a HEAD
     request) is always terminated by the first empty line after the
     header fields, regardless of the entity-header fields present in
     the message.

   2.If a Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;) is present and
     has any value other than &quot;identity&quot;, then the transfer-length is
     defined by use of the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;),
     unless the message is terminated by closing the connection.

   3.If a Content-Length header field (&lt;a href=&quot;#section-14.13&quot;&gt;section 14.13&lt;/a&gt;) is present, its
     decimal value in OCTETs represents both the entity-length and the
     transfer-length. The Content-Length header field MUST NOT be sent
     if these two lengths are different (i.e., if a Transfer-Encoding 

     header field is present). If a message is received with both a
     Transfer-Encoding header field and a Content-Length header field,
     the latter MUST be ignored.

   4.If the message uses the media type &quot;multipart/byteranges&quot;, and the
     ransfer-length is not otherwise specified, then this self-
     elimiting media type defines the transfer-length. This media type
     UST NOT be used unless the sender knows that the recipient can arse
     it; the presence in a request of a Range header with ultiple byte-
     range specifiers from a 1.1 client implies that the lient can parse
     multipart/byteranges responses.

       A range header might be forwarded by a 1.0 proxy that does not
       understand multipart/byteranges; in this case the server MUST
       delimit the message using methods defined in items 1,3 or 5 of
       this section.

   5.By the server closing the connection. (Closing the connection
     cannot be used to indicate the end of a request body, since that
     would leave no possibility for the server to send back a response.)

   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
   containing a message-body MUST include a valid Content-Length header
   field unless the server is known to be HTTP/1.1 compliant. If a
   request contains a message-body and a Content-Length is not given,
   the server SHOULD respond with 400 (bad request) if it cannot
   determine the length of the message, or with 411 (length required) if
   it wishes to insist on receiving a valid Content-Length.

   All HTTP/1.1 applications that receive entities MUST accept the
   &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;), thus allowing this mechanism
   to be used for messages when the message length cannot be determined
   in advance.

   Messages MUST NOT include both a Content-Length header field and a
   non-identity transfer-coding. If the message does include a non-
   identity transfer-coding, the Content-Length MUST be ignored.

   When a Content-Length is given in a message where a message-body is
   allowed, its field value MUST exactly match the number of OCTETs in
   the message-body. HTTP/1.1 user agents MUST notify the user when an
   invalid length is received and detected.</source>
          <target state="translated">消息的传输长度是显示在消息中的消息正文的长度。也就是说，在应用了任何传输编码之后。当消息主体包含在消息中时，该主体的传输长度由以下其中一项（按优先级顺序）确定：1.任何&amp;ldquo;不得&amp;rdquo;包含消息主体的响应消息（例如1xx，204和304响应以及对HEAD请求的任何响应）总是由标头字段之后的第一个空行终止，而不管消息中存在的实体标头字段如何。 2.如果存在传输编码头字段（&lt;a href=&quot;#section-14.41&quot;&gt;第14.41节&lt;/a&gt;），并且具有除&amp;ldquo; identity&amp;rdquo;以外的其他任何值，则使用&amp;ldquo;块&amp;rdquo;定义传输长度转移编码（&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节&lt;/a&gt;），除非该消息通过关闭连接而终止。 3.如果Content-Length标头字段（&lt;a href=&quot;#section-14.13&quot;&gt;14.13节&lt;/a&gt;）存在，其在OCTET中的十进制值表示实体长度和传输长度。如果这两个长度不同（即，如果存在传输编码标头字段），则不得发送Content-Length标头字段。如果收到的消息同时具有传输编码报头字段和内容长度报头字段，则后者必须被忽略。 4.如果消息使用媒体类型&amp;ldquo; multipart / byteranges&amp;rdquo;，并且未另外指定ransfer-length，则此自限制媒体类型将定义传输长度。除非发件人知道收件人可以对此媒体类型使用，否则请勿使用此媒体类型。请求中包含带有从1开始的多字节范围说明符的Range标头。1个客户端表示留置权可以解析多部分/字节范围的响应。范围标头可能由无法理解多部分/字节范围的1.0代理转发。在这种情况下，服务器必须使用本节第1,3或5条中定义的方法对消息进行定界。 5.通过服务器关闭连接。 （关闭连接不能用于指示请求主体的结束，因为这将使服务器无法发送回响应。）为了与HTTP / 1.0应用程序兼容，包含消息主体的HTTP / 1.1请求必须包括有效的Content-Length标头字段，除非已知服务器兼容HTTP / 1.1。如果请求包含消息正文，但未提供Content-Length，如果服务器不能确定消息的长度，则服务器应该以400（错误请求）响应，或者如果它希望坚持接收有效的Content-Length，则应以411（要求长度）响应。所有接收实体的HTTP / 1.1应用程序都必须接受&amp;ldquo;分块&amp;rdquo;传输编码（&lt;a href=&quot;#section-3.6&quot;&gt;3.6节&lt;/a&gt;），因此当无法预先确定消息长度时，可以将此机制用于消息。消息不得同时包含Content-Length头字段和非身份转移编码。如果消息中确实包含非身份转移编码，则必须忽略Content-Length。在允许消息正文的消息中给出Content-Length时，其字段值务必与消息正文中的OCTET数量完全匹配。当接收和检测到无效长度时，HTTP / 1.1用户代理必须通知用户。</target>
        </trans-unit>
        <trans-unit id="38523484ffd68ebb6eb7a5214e3ed27961920f11" translate="yes" xml:space="preserve">
          <source>The two URNs correspond to</source>
          <target state="translated">这两个URN对应的是</target>
        </trans-unit>
        <trans-unit id="4126df10224ce6149afe3c692dbb573c02f4b6df" translate="yes" xml:space="preserve">
          <source>The type of the network error may be one of the following pre-defined values from the specification, but browsers can add and send their own error types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2f97e2406493e9f79fccc71e1be4f7abf32463" translate="yes" xml:space="preserve">
          <source>The unit for ranges are bytes.</source>
          <target state="translated">范围的单位是字节。</target>
        </trans-unit>
        <trans-unit id="b6b0d4dfd9983f94ad3e71c861ccec5e604be4be" translate="yes" xml:space="preserve">
          <source>The unit in which ranges are specified. This is usually &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">指定范围的单位。通常是 &lt;code&gt;bytes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5af5f6da44581e8c2be8542aa108c546975539ef" translate="yes" xml:space="preserve">
          <source>The user agent successfully received a response, but it had a &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5&quot;&gt;4xx&lt;/a&gt; or &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.6&quot;&gt;5xx&lt;/a&gt; status code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38ef4967199ab3d3fb64a4af1f2610ad2fb5dab" translate="yes" xml:space="preserve">
          <source>The user has not specified a preference about tracking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924b5ee64285daafc6521cbe0d29ade1c8958494" translate="yes" xml:space="preserve">
          <source>The user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">用户在给定的时间内发送了太多的请求(&quot;速率限制&quot;)。</target>
        </trans-unit>
        <trans-unit id="9ffdd05f199fbe940ba584fa8cdea1148a035d9b" translate="yes" xml:space="preserve">
          <source>The user prefers not to be tracked on the target site.</source>
          <target state="translated">用户不希望在目标网站上被跟踪。</target>
        </trans-unit>
        <trans-unit id="d71574f65fb3da08e3baf6b4a99a03c89f5a3b91" translate="yes" xml:space="preserve">
          <source>The user prefers to allow tracking on the target site.</source>
          <target state="translated">用户更愿意允许在目标网站上进行跟踪。</target>
        </trans-unit>
        <trans-unit id="91276b37149e1af5a39e9acf956fda9d8e55baac" translate="yes" xml:space="preserve">
          <source>The user requests an illegal resource, such as a web page censored by a government.</source>
          <target state="translated">用户请求一个非法资源,如政府审查的网页。</target>
        </trans-unit>
        <trans-unit id="c2570aabe29d82468d07516df77cc2dacb787ebd" translate="yes" xml:space="preserve">
          <source>The user's DNS server is unreachable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde98a07efaff68f2ccfa98c53613a6d16bf7576" translate="yes" xml:space="preserve">
          <source>The user's DNS server responded but was unable to resolve an IP address for the requested URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9325341a547bb5d13f713ae99d4c608b9f2504" translate="yes" xml:space="preserve">
          <source>The user's DNT preference can also be read from JavaScript using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt;&lt;code&gt;Navigator.doNotTrack&lt;/code&gt;&lt;/a&gt; property:</source>
          <target state="translated">也可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt; &lt;code&gt;Navigator.doNotTrack&lt;/code&gt; &lt;/a&gt;属性从JavaScript中读取用户的DNT首选项：</target>
        </trans-unit>
        <trans-unit id="ed64b46fa75921957cada3be294011ac523b15f9" translate="yes" xml:space="preserve">
          <source>The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6eca9e7b97463080612be2b9d7493bcb1e1c94" translate="yes" xml:space="preserve">
          <source>The username and the password are combined with a colon (&lt;code&gt;aladdin:opensesame&lt;/code&gt;).</source>
          <target state="translated">用户名和密码用冒号（ &lt;code&gt;aladdin:opensesame&lt;/code&gt; ）组合。</target>
        </trans-unit>
        <trans-unit id="36e6a72462ef3ce7f1b58a51225794379cf53bdb" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal header name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26cfba7c951a6edda6e1e994a33a34814751c61e" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal header name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics. Note that the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header can't be wildcarded and always needs to be listed explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854a2275bb7da001005de950b8d6724a4e032a0a" translate="yes" xml:space="preserve">
          <source>The value &quot;&lt;code&gt;*&lt;/code&gt;&quot; only counts as a special wildcard value for requests without credentials (requests without &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; or HTTP authentication information). In requests with credentials, it is treated as the literal method name &quot;&lt;code&gt;*&lt;/code&gt;&quot; without special semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2ea3fa86a0e7cfbb653b4bde310cf9741eba62" translate="yes" xml:space="preserve">
          <source>The value is a Boolean Structured Header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e7dde22649be5d5f9982b5b058ad7e12b419de" translate="yes" xml:space="preserve">
          <source>The value of a property is always a (well-formed) XML fragment.

   XML has been chosen because it is a flexible, self-describing,
   structured data format that supports rich schema definitions, and
   because of its support for multiple character sets.  XML's self-
   describing nature allows any property's value to be extended by
   adding elements.  Clients will not break when they encounter
   extensions because they will still have the data specified in the
   original schema and MUST ignore elements they do not understand. 

   XML's support for multiple character sets allows any human-readable
   property to be encoded and read in a character set familiar to the
   user.  XML's support for multiple human languages, using the &quot;xml:
   lang&quot; attribute, handles cases where the same character set is
   employed by multiple human languages.  Note that xml:lang scope is
   recursive, so an xml:lang attribute on any element containing a
   property name element applies to the property value unless it has
   been overridden by a more locally scoped attribute.  Note that a
   property only has one value, in one language (or language MAY be left
   undefined); a property does not have multiple values in different
   languages or a single value in multiple languages.

   A property is always represented with an XML element consisting of
   the property name, called the &quot;property name element&quot;.  The simplest
   example is an empty property, which is different from a property that
   does not exist:

      &amp;lt;R:title xmlns:R=&quot;http://www.example.com/ns/&quot;&amp;gt;&amp;lt;/R:title&amp;gt;

   The value of the property appears inside the property name element.
   The value may be any kind of well-formed XML content, including both
   text-only and mixed content.  Servers MUST preserve the following XML
   Information Items (using the terminology from [&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]) in
   storage and transmission of dead properties:

   For the property name Element Information Item itself:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;] named &quot;xml:lang&quot; or any such attribute in scope

      [&lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;children&lt;/a&gt;] of type element or character

   On all Element Information Items in the property value:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;]

      [&lt;a href=&quot;#ref-children&quot;&gt;children&lt;/a&gt;] of type element or character 

   On Attribute Information Items in the property value:

      [namespace name]

      [local name]

      [normalized value]

   On Character Information Items in the property value:

      [character code]

   Since prefixes are used in some XML vocabularies (XPath and XML
   Schema, for example), servers SHOULD preserve, for any Information
   Item in the value:

      [&lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;prefix&lt;/a&gt;]

   XML Infoset attributes not listed above MAY be preserved by the
   server, but clients MUST NOT rely on them being preserved.  The above
   rules would also apply by default to live properties, unless defined
   otherwise.

   Servers MUST ignore the XML attribute xml:space if present and never
   use it to change whitespace handling.  Whitespace in property values
   is significant.</source>
          <target state="translated">属性的值始终是（格式正确的）XML片段。选择XML是因为它是一种灵活的，自描述的，结构化的数据格式，可以支持丰富的模式定义，并且因为它支持多个字符集。 XML的自我描述性质允许通过添加元素来扩展任何属性的值。客户端遇到扩展时不会中断，因为它们仍将具有原始架构中指定的数据，并且必须忽略其不理解的元素。 XML对多个字符集的支持允许以用户熟悉的字符集对任何人类可读属性进行编码和读取。 XML使用&amp;ldquo; xml：lang&amp;rdquo;属性对多种人类语言的支持，处理多种人类语言使用相同字符集的情况。请注意，xml：lang范围是递归的，因此包含属性名称元素的任何元素上的xml：lang属性都适用于该属性值，除非已被本地范围更广的属性所覆盖。注意，一个属性只有一种值（用一种语言（或可以不定义语言））；属性没有使用不同语言的多个值或使用多种语言的单个值。一个属性总是用一个由属性名称组成的XML元素表示，称为&amp;ldquo;属性名称元素&amp;rdquo;。最简单的示例是一个空属性，该属性与不存在的属性不同：&amp;lt;R：title xmlns：R =&amp;ldquo; http://www.example.com/ns/&amp;rdquo;&amp;gt; &amp;lt;/ R：title&amp;gt;该属性的值显示在属性名称元素内。该值可以是任何一种格式良好的XML内容，包括纯文本内容和混合内容。服务器务必保留以下XML信息项（使用[&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt; ]），用于存储和传输无效属性：对于属性名称元素信息项本身：[名称空间名称] [本地名称] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;属性&lt;/a&gt; ]名为&amp;ldquo; xml：lang&amp;rdquo;或范围[ &lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;子级&lt;/a&gt;任何此类属性 ]中的属性值中所有元素信息项上元素或字符的类型：[名称空间名称] [本地名称] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;属性&lt;/a&gt; ] [ &lt;a href=&quot;#ref-children&quot;&gt;子&lt;/a&gt;元素类型元素或字符的]在属性值中的属性信息项上：[名称空间名称] [本地名称] [规范化的值]在属性值中的字符信息项中：[字符代码]由于前缀在某些XML词汇表（XPath中使用（例如XML和XML Schema），服务器应为以下任何信息项保留值：[ &lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;前缀&lt;/a&gt; ]上面未列出的XML Infoset属性可以由服务器保留，但是客户端不得依赖于保留它们。除非另有定义，否则以上规则默认情况下也适用于活动属性。服务器必须忽略XML属性xml：space（如果存在），并且永远不要使用它来更改空白处理。属性值中的空白很重要。</target>
        </trans-unit>
        <trans-unit id="fb3e4816a344b23838df3c23c4b5bab0b9342359" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; and &lt;code&gt;'src'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">值 &lt;code&gt;*&lt;/code&gt; （对所有来源启用）或 &lt;code&gt;'none'&lt;/code&gt; （对所有来源禁用）只能单独使用，而 &lt;code&gt;'self'&lt;/code&gt; 和 &lt;code&gt;'src'&lt;/code&gt; 可以与一个或多个来源一起使用。</target>
        </trans-unit>
        <trans-unit id="f91edc1b64b95c9c888baf6cb011efedf5d401fa" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">值 &lt;code&gt;*&lt;/code&gt; （对所有来源启用）或 &lt;code&gt;'none'&lt;/code&gt; （对所有来源禁用）只能单独使用，而 &lt;code&gt;'self'&lt;/code&gt; 可以与一个或多个来源一起使用。</target>
        </trans-unit>
        <trans-unit id="41c9624006fed0c69222297d2493c20e75ba3334" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;SameSite&lt;/code&gt; attribute are case-insensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb79e8e805e8e88b9627449d36415ee11787dcd" translate="yes" xml:space="preserve">
          <source>The version numbers are not relevant. Avoid inferring materials based on these.</source>
          <target state="translated">版本号与此无关。避免根据这些来推断材料。</target>
        </trans-unit>
        <trans-unit id="c896f8683d1b38332492f9add5b7e8036c2af733" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol they follow.</source>
          <target state="translated">它们所遵循的HTTP协议的版本。</target>
        </trans-unit>
        <trans-unit id="af0975667c912879263ed1a3127961e483e13536" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol.</source>
          <target state="translated">HTTP协议的版本。</target>
        </trans-unit>
        <trans-unit id="18e8cb1bbc1cc055f8280b649b640d1c2817543a" translate="yes" xml:space="preserve">
          <source>The version of the protocol used, such as &quot;1.1&quot;.</source>
          <target state="translated">使用的协议版本,如 &quot;1.1&quot;;</target>
        </trans-unit>
        <trans-unit id="be45aceeb5134141e742c9ee174ea085d4d54965" translate="yes" xml:space="preserve">
          <source>The warning appears because any cookie that requests &lt;code&gt;SameSite=None&lt;/code&gt; but is not marked &lt;code&gt;Secure&lt;/code&gt; will be rejected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ee5181aca77b1eb5d9d19b58966bc71984796c" translate="yes" xml:space="preserve">
          <source>The warning appears because the &lt;code&gt;SameSite&lt;/code&gt; policy for a cookie has not specified explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2eeda1fd5d692f44f72233f1d8f895ceec9038" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action, besides presenting the warning to the
   user.</source>
          <target state="translated">警告文本可以包括任意信息,以提交给人类用户或记录。收到该警告的系统除了向用户发出警告外,不得采取任何自动行动。</target>
        </trans-unit>
        <trans-unit id="15cc2f59f7cbc4d7458f6cc67c3db06644c699c3" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action.</source>
          <target state="translated">警告文本可以包括任意信息,以呈现给人类用户或记录。收到该警告的系统不得采取任何自动行动。</target>
        </trans-unit>
        <trans-unit id="5141799507b06d7b06feb80a1395a0473365c760" translate="yes" xml:space="preserve">
          <source>The web provides functionality and APIs that may have privacy or security risks if abused. In some cases, you may wish to strictly limit how such functionality is used on a website. There are policy-controlled features to allow functionality to be enabled/disabled for specific origins or frames within a website. Where available, the feature integrates with the Permissions API, or feature-specific mechanisms to check if the feature is available.</source>
          <target state="translated">网络提供的功能和API如果被滥用,可能存在隐私或安全风险。在某些情况下,您可能希望严格限制这些功能在网站上的使用方式。有一些策略控制的功能,允许为网站内的特定起源或框架启用/禁用功能。在可用的情况下,该功能与权限API或特定功能机制集成,以检查该功能是否可用。</target>
        </trans-unit>
        <trans-unit id="7dfe76bf0e6f8f40957fd161579016ac421163fe" translate="yes" xml:space="preserve">
          <source>The wildcard value (*) that is mentioned in the latest specification, is not yet implemented in browsers:</source>
          <target state="translated">最新规范中提到的通配符值(*),在浏览器中还没有实现。</target>
        </trans-unit>
        <trans-unit id="1efbe0911ef1776423c120227469a104642f0bff" translate="yes" xml:space="preserve">
          <source>The&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt; HTML5 boilerplate project&lt;/a&gt; has an example on &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;how to configure an Apache server to redirect one domain to the other&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt;HTML5样板项目&lt;/a&gt;有一个例子&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;如何配置Apache服务器重定向到一个域到另一个&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8f25ce63c5964fb8abf78f765646524df92d04" translate="yes" xml:space="preserve">
          <source>Then include an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">然后在 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 元素上包含&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt;属性：</target>
        </trans-unit>
        <trans-unit id="5b298470c1b05d975bfb02d7b35971fafe965683" translate="yes" xml:space="preserve">
          <source>Then on subsequent requests the client might send &lt;code&gt;DPR&lt;/code&gt; header back:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cacc625cf3f9a66a41f951c41016e7992de78fa8" translate="yes" xml:space="preserve">
          <source>Then on subsequent requests the client might send &lt;code&gt;Device-Memory&lt;/code&gt; header back:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a105d13d54e1c2eb5dcd554ae6b632346f6c862" translate="yes" xml:space="preserve">
          <source>Then the client could remember that the JSON version is available at that particular URL, skipping content negotation the next time it requests that document.</source>
          <target state="translated">然后,客户端可以记住JSON版本在该特定的URL中可用,在下次请求该文档时跳过内容协商。</target>
        </trans-unit>
        <trans-unit id="ccd8b24095654e9f5577f70574da438aa878682b" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you determine is appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c166069763014ce7a3cf04a150e6d98bc4aa9d06" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you feel is appropriate.</source>
          <target state="translated">然后,你需要设置你的服务器来接收报告;它可以以任何你认为合适的方式存储或处理它们。</target>
        </trans-unit>
        <trans-unit id="303618442946db88c6e44665ba0c19fde299ff1f" translate="yes" xml:space="preserve">
          <source>Then, with every subsequent request to the server, the browser sends back all previously stored cookies to the server using the &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02072bbfa0f86f96f0652069e08e342de2f1a9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to ensure that cookies are sent securely and are not accessed by unintended parties or scripts: the &lt;code&gt;Secure&lt;/code&gt; attribute and the &lt;code&gt;HttpOnly&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19356494f1c284767cfe46395570ff7af7ec9025" translate="yes" xml:space="preserve">
          <source>There are a few header fields which have general applicability for
   both request and response messages, but which do not apply to the
   entity being transferred. These header fields apply only to the 

   message being transmitted.

       general-header = Cache-Control            ; &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;
                      | Connection               ; &lt;a href=&quot;#section-14.10&quot;&gt;Section 14.10&lt;/a&gt;
                      | Date                     ; &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;
                      | Pragma                   ; &lt;a href=&quot;#section-14.32&quot;&gt;Section 14.32&lt;/a&gt;
                      | Trailer                  ; &lt;a href=&quot;#section-14.40&quot;&gt;Section 14.40&lt;/a&gt;
                      | Transfer-Encoding        ; &lt;a href=&quot;#section-14.41&quot;&gt;Section 14.41&lt;/a&gt;
                      | Upgrade                  ; &lt;a href=&quot;#section-14.42&quot;&gt;Section 14.42&lt;/a&gt;
                      | Via                      ; &lt;a href=&quot;#section-14.45&quot;&gt;Section 14.45&lt;/a&gt;
                      | Warning                  ; &lt;a href=&quot;#section-14.46&quot;&gt;Section 14.46&lt;/a&gt;

   General-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields may be given the semantics of general
   header fields if all parties in the communication recognize them to
   be general-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">有几个标头字段对请求和响应消息都具有通用性，但不适用于正在传输的实体。这些头字段仅适用于正在发送的消息。 general-header =缓存控制; &lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt; |连接; &lt;a href=&quot;#section-14.10&quot;&gt;第14.10节&lt;/a&gt; |日期; &lt;a href=&quot;#section-14.18&quot;&gt;第14.18节&lt;/a&gt; |语用; &lt;a href=&quot;#section-14.32&quot;&gt;第14.32节&lt;/a&gt; |预告片 ; &lt;a href=&quot;#section-14.40&quot;&gt;第14.40节&lt;/a&gt; |传输编码&lt;a href=&quot;#section-14.42&quot;&gt;第14.42节&lt;/a&gt; |通过;&lt;a href=&quot;#section-14.41&quot;&gt;第14.41节&lt;/a&gt; |升级;&lt;a href=&quot;#section-14.45&quot;&gt;第14.45节&lt;/a&gt; |警告 ; 只有结合协议版本的更改，才能可靠地扩展&lt;a href=&quot;#section-14.46&quot;&gt;14.46节的&lt;/a&gt;一般标题字段名称。但是，如果通信中的所有各方都将新的或实验性的标题字段视为通用标题字段，则可以为它们指定通用标题字段的语义。无法识别的标头字段被视为实体标头字段。</target>
        </trans-unit>
        <trans-unit id="3cd54b5762f67dada954e548e046b34d36650e6c" translate="yes" xml:space="preserve">
          <source>There are a few rare conditions when this might occur:</source>
          <target state="translated">有一些罕见的情况下,可能会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="d68958166491fcc8ea9c6532f3f7c7286929a632" translate="yes" xml:space="preserve">
          <source>There are certain aspects of the HTTP Authentication Framework that
   put constraints on how new authentication schemes can work:

   o  HTTP authentication is presumed to be stateless: all of the
      information necessary to authenticate a request MUST be provided
      in the request, rather than be dependent on the server remembering
      prior requests.  Authentication based on, or bound to, the
      underlying connection is outside the scope of this specification
      and inherently flawed unless steps are taken to ensure that the
      connection cannot be used by any party other than the
      authenticated user (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7230]&lt;/a&gt;).

   o  The authentication parameter &quot;realm&quot; is reserved for defining
      protection spaces as described in &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;.  New schemes MUST
      NOT use it in a way incompatible with that definition.

   o  The &quot;token68&quot; notation was introduced for compatibility with
      existing authentication schemes and can only be used once per
      challenge or credential.  Thus, new schemes ought to use the
      auth-param syntax instead, because otherwise future extensions
      will be impossible.

   o  The parsing of challenges and credentials is defined by this
      specification and cannot be modified by new authentication
      schemes.  When the auth-param syntax is used, all parameters ought
      to support both token and quoted-string syntax, and syntactical
      constraints ought to be defined on the field value after parsing
      (i.e., quoted-string processing).  This is necessary so that
      recipients can use a generic parser that applies to all
      authentication schemes.

      Note: The fact that the value syntax for the &quot;realm&quot; parameter is
      restricted to quoted-string was a bad design choice not to be
      repeated for new parameters.

   o  Definitions of new schemes ought to define the treatment of
      unknown extension parameters.  In general, a &quot;must-ignore&quot; rule is
      preferable to a &quot;must-understand&quot; rule, because otherwise it will
      be hard to introduce new parameters in the presence of legacy
      recipients.  Furthermore, it's good to describe the policy for
      defining new parameters (such as &quot;update the specification&quot; or
      &quot;use this registry&quot;).

   o  Authentication schemes need to document whether they are usable in
      origin-server authentication (i.e., using WWW-Authenticate),
      and/or proxy authentication (i.e., using Proxy-Authenticate). 

   o  The credentials carried in an Authorization header field are
      specific to the user agent and, therefore, have the same effect on
      HTTP caches as the &quot;private&quot; Cache-Control response directive
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;Section&amp;nbsp;5.2.2.6 of [RFC7234]&lt;/a&gt;), within the scope of the request in
      which they appear.

      Therefore, new authentication schemes that choose not to carry
      credentials in the Authorization header field (e.g., using a newly
      defined header field) will need to explicitly disallow caching, by
      mandating the use of either Cache-Control request directives
      (e.g., &quot;no-store&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;Section&amp;nbsp;5.2.1.5 of [RFC7234]&lt;/a&gt;) or response
      directives (e.g., &quot;private&quot;).</source>
          <target state="translated">HTTP身份验证框架的某些方面限制了新身份验证方案的工作方式：o HTTP身份验证被假定为无状态的：身份验证请求所需的所有信息都必须在请求中提供，而不是依赖于服务器记住先前的请求。基于或绑定到基础连接的身份验证超出了本规范的范围，并且存在固有的缺陷，除非采取措施确保该连接不能被已身份验证的用户以外的任何一方使用（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;[RFC7230]第2.3节）&lt;/a&gt;）。 。 o身份验证参数&amp;ldquo;领域&amp;rdquo;保留用于定义保护空间，如&lt;a href=&quot;#section-2.2&quot;&gt;第2.2节中&lt;/a&gt;所述。新方案不得以与该定义不兼容的方式使用它。 o引入了&amp;ldquo; token68&amp;rdquo;符号是为了与现有的身份验证方案兼容，并且每个质询或凭据只能使用一次。因此，新的方案应该改为使用auth-param语法，因为否则将来的扩展将是不可能的。 o挑战和凭证的解析由本规范定义，不能由新的身份验证方案修改。使用auth-param语法时，所有参数都应同时支持令牌和带引号的字符串语法，并且在解析（即，带引号的字符串处理）之后，应在字段值上定义语法约束。这是必需的，以便收件人可以使用适用于所有身份验证方案的通用解析器。注意：&amp;ldquo; realm&amp;rdquo;参数的值语法仅限于带引号的字符串，这是一个糟糕的设计选择，不能对新参数重复。 o新方案的定义应定义对未知扩展参数的处理。通常，&amp;ldquo;必须忽略&amp;rdquo;规则比&amp;ldquo;必须了解&amp;rdquo;规则更可取，因为否则，在遗留接收者在场的情况下将很难引入新参数。此外，最好描述定义新参数的策略（例如&amp;ldquo;更新规范&amp;rdquo;或&amp;ldquo;使用此注册表&amp;rdquo;）。o身份验证方案需要记录它们是否可用于原始服务器身份验证（即，使用WWW-Authenticate）和/或代理身份验证（即，使用Proxy-Authenticate）。 o Authorization标头字段中携带的凭证是特定于用户代理的，因此对HTTP缓存的影响与&amp;ldquo;专用&amp;rdquo; Cache-Control响应指令（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;[RFC7234]的5.2.2.6节&lt;/a&gt;），在出现它们的请求范围内。因此，通过选择使用任一Cache-Control请求指令（例如，&amp;ldquo; no- store&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;[RFC7234]的5.2.1.5节&lt;/a&gt;）或响应指令（例如&amp;ldquo;私有&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="47def022b2952624e6b7c50d68fc89498c6bcbc8" translate="yes" xml:space="preserve">
          <source>There are different ways to choose which website is &lt;em&gt;canonical&lt;/em&gt;.</source>
          <target state="translated">有多种选择&lt;em&gt;标准&lt;/em&gt;网站的方法。</target>
        </trans-unit>
        <trans-unit id="fb9fab7f67432c45ef3a01bc4e6955ba9af7ef46" translate="yes" xml:space="preserve">
          <source>There are five major rendering engines: Trident, Gecko, Presto, Blink, and WebKit. As sniffing the rendering engines names is common, a lot of user agents added other rendering names to trigger detection. It is therefore important to pay attention not to trigger false-positives when detecting the rendering engine.</source>
          <target state="translated">有五大渲染引擎。Trident、Gecko、Presto、Blink和WebKit。由于嗅探渲染引擎名称很常见,很多用户代理添加了其他渲染名称来触发检测。因此在检测渲染引擎时要注意不要触发假阳性。</target>
        </trans-unit>
        <trans-unit id="ec7265e037a89a08f26052ad3aa1abd61eeef50e" translate="yes" xml:space="preserve">
          <source>There are no legal or technological requirements for its use, but the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header can be used to signal that a web application should disable either its tracking or cross-site user tracking of an individual user. See the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header for more information.</source>
          <target state="translated">其使用没有法律或技术要求，但是&lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;标头可用于表示Web应用程序应禁用其跟踪或对单个用户的跨站点用户跟踪。有关更多信息，请参见&lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="8341be3003600a3499c2c6008b5ac1ba78954829" translate="yes" xml:space="preserve">
          <source>There are numerous request headers available. They can be divided in several groups:</source>
          <target state="translated">有许多请求头可用。它们可以分为几组。</target>
        </trans-unit>
        <trans-unit id="6e686045e6ac4c90ab4cd236500952ba40ae62b2" translate="yes" xml:space="preserve">
          <source>There are numerous response headers available. These can be divided into several groups:</source>
          <target state="translated">有许多可用的响应头。这些可以分为几组。</target>
        </trans-unit>
        <trans-unit id="9222fd28dc57a16808d7c19d6bf6f9df7c972ab4" translate="yes" xml:space="preserve">
          <source>There are numerous use cases for redirects, but as performance is impacted with every redirect, their use should be kept to a minimum.</source>
          <target state="translated">重定向的用例很多,但由于每次重定向都会影响性能,所以应尽量减少使用。</target>
        </trans-unit>
        <trans-unit id="13f9ecbdd18ed16f602f0ce2e3e411623b20ecea" translate="yes" xml:space="preserve">
          <source>There are several kinds of caches: these can be grouped into two main categories: private or shared caches. A &lt;em&gt;shared cache&lt;/em&gt; is a cache that stores responses for reuse by more than one user. A &lt;em&gt;private cache&lt;/em&gt; is dedicated to a single user. This page will mostly talk about browser and proxy caches, but there are also gateway caches, CDN, reverse proxy caches and load balancers that are deployed on web servers for better reliability, performance and scaling of web sites and web applications.</source>
          <target state="translated">缓存有几种：可以分为两大类：专用缓存或共享缓存。甲&lt;em&gt;共享高速缓存&lt;/em&gt;是一个高速缓存用于通过一个以上的用户复用存储的响应。一个&lt;em&gt;私有缓存&lt;/em&gt;专用于单个用户。此页面将主要讨论浏览器和代理缓存，但也将网关缓存，CDN，反向代理缓存和负载平衡器部署在Web服务器上，以提高网站和Web应用程序的可靠性，性能和扩展性。</target>
        </trans-unit>
        <trans-unit id="cb582dbfa4a7b1600d7a27acf7bcaf2e2220c793" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features designed to represent functionality that can negatively impact the user experience. These features include:</source>
          <target state="translated">有几个政策控制的功能,旨在代表可能对用户体验产生负面影响的功能。这些功能包括:</target>
        </trans-unit>
        <trans-unit id="5b36e7ddb912239041ca7ab0dc533b4f7149cde8" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features to help enforce best practices for providing good performance and user experiences.</source>
          <target state="translated">有几个策略控制的功能,帮助执行最佳实践,以提供良好的性能和用户体验。</target>
        </trans-unit>
        <trans-unit id="4c3b7153e2634e73590a4cce2b8c456ab59f6363" translate="yes" xml:space="preserve">
          <source>There are several types of redirects and they fall into three categories: permanent, temporary and special redirections.</source>
          <target state="translated">有几种类型的重定向,它们分为三类:永久、临时和特殊重定向。</target>
        </trans-unit>
        <trans-unit id="8b2d63fe70a304442a6a486676e591c0916f939e" translate="yes" xml:space="preserve">
          <source>There are several types of redirects, sorted into three categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f58fdbcbba9bec3b86fd66d8bc7fa26b8fe6f5" translate="yes" xml:space="preserve">
          <source>There are three possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 有三种可能的指令：</target>
        </trans-unit>
        <trans-unit id="617a6e0c426a32391566dd90c1be40e2204860a0" translate="yes" xml:space="preserve">
          <source>There are three relevant statuses, when working with range requests:</source>
          <target state="translated">在处理范围请求时,有三种相关状态。</target>
        </trans-unit>
        <trans-unit id="0fff28c9c934766aefa1ed8d526b79ea9e2c24ef" translate="yes" xml:space="preserve">
          <source>There are too many &lt;a href=&quot;../cookies&quot;&gt;Cookies&lt;/a&gt; sent in the request</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce50cfd249603fdf3debd56f0ffcb691991a174f" translate="yes" xml:space="preserve">
          <source>There are two classes of type: &lt;strong&gt;discrete&lt;/strong&gt; and &lt;strong&gt;multipart&lt;/strong&gt;. Discrete types are types which represent a single file or medium, such as a single text or music file, or a single video. A multipart type is one which represents a document that's comprised of multiple component parts, each of which may have its own individual MIME type; or, a multipart type may encapsulate multiple files being sent together in one transaction. For example, multipart MIME types are used when attaching multiple files to an email.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae719b0ddb46afe501f7c4d04161647540a420e" translate="yes" xml:space="preserve">
          <source>There are two common use cases:</source>
          <target state="translated">有两种常见的用例。</target>
        </trans-unit>
        <trans-unit id="4d8949bb550cb1be029d6340065449416ee39fb0" translate="yes" xml:space="preserve">
          <source>There are two entity-tag comparison functions, depending on whether
   or not the comparison context allows the use of weak validators:

   o  Strong comparison: two entity-tags are equivalent if both are not
      weak and their opaque-tags match character-by-character.

   o  Weak comparison: two entity-tags are equivalent if their
      opaque-tags match character-by-character, regardless of either or
      both being tagged as &quot;weak&quot;. 

   The example below shows the results for a set of entity-tag pairs and
   both the weak and strong comparison function results:

   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/&quot;1&quot;  | W/&quot;1&quot;  | no match          | match           |
   | W/&quot;1&quot;  | W/&quot;2&quot;  | no match          | no match        |
   | W/&quot;1&quot;  | &quot;1&quot;    | no match          | match           |
   | &quot;1&quot;    | &quot;1&quot;    | match             | match           |
   +--------+--------+-------------------+-----------------+</source>
          <target state="translated">有两种实体标签比较函数,取决于比较上下文是否允许使用弱验证器:o 强比较:如果两个实体标签都不弱,并且它们的不透明标签逐个字符匹配,则两个实体标签是等价的。 o 弱比较:如果两个实体标签的不透明标签逐个字符匹配,则两个实体标签是等价的,不管其中一个或两个都被标记为 &quot;弱&quot;。下面的例子显示了一组实体标记对的结果以及弱比较和强比较函数的结果。</target>
        </trans-unit>
        <trans-unit id="db65cf9eb555812887e466f13f1dfba01665198b" translate="yes" xml:space="preserve">
          <source>There are two kinds of collection write locks.  A depth-0 write lock
   on a collection protects the collection properties plus the internal
   member URLs of that one collection, while not protecting the content
   or properties of member resources (if the collection itself has any
   entity bodies, those are also protected).  A depth-infinity write
   lock on a collection provides the same protection on that collection
   and also provides write lock protection on every member resource.

   Expressed otherwise, a write lock of either kind protects any request
   that would create a new resource in a write locked collection, any
   request that would remove an internal member URL of a write locked
   collection, and any request that would change the segment name of any
   internal member.

   Thus, a collection write lock protects all the following actions:

   o  DELETE a collection's direct internal member, 

   o  MOVE an internal member out of the collection,

   o  MOVE an internal member into the collection,

   o  MOVE to rename an internal member within a collection,

   o  COPY an internal member into a collection, and

   o  PUT or MKCOL request that would create a new internal member.

   The collection's lock token is required in addition to the lock token
   on the internal member itself, if it is locked separately.

   In addition, a depth-infinity lock affects all write operations to
   all members of the locked collection.  With a depth-infinity lock,
   the resource identified by the root of the lock is directly locked,
   and all its members are indirectly locked.

   o  Any new resource added as a descendant of a depth-infinity locked
      collection becomes indirectly locked.

   o  Any indirectly locked resource moved out of the locked collection
      into an unlocked collection is thereafter unlocked.

   o  Any indirectly locked resource moved out of a locked source
      collection into a depth-infinity locked target collection remains
      indirectly locked but is now protected by the lock on the target
      collection (the target collection's lock token will thereafter be
      required to make further changes).

   If a depth-infinity write LOCK request is issued to a collection
   containing member URLs identifying resources that are currently
   locked in a manner that conflicts with the new lock (see &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;,
   point 3), the request MUST fail with a 423 (Locked) status code, and
   the response SHOULD contain the 'no-conflicting-lock' precondition.

   If a lock request causes the URL of a resource to be added as an
   internal member URL of a depth-infinity locked collection, then the
   new resource MUST be automatically protected by the lock.  For
   example, if the collection /a/b/ is write locked and the resource /c
   is moved to /a/b/c, then resource /a/b/c will be added to the write
   lock.</source>
          <target state="translated">收集写锁有两种。集合上的depth-0写入锁可保护该集合的集合属性以及该成员的内部成员URL，而不保护成员资源的内容或属性（如果集合本身具有任何实体主体，则这些实体也将受到保护）。集合上的深度无限写锁定为该集合提供相同的保护，并且还为每个成员资源提供写锁定保护。否则表示，任何一种写锁都将保护在写锁集合中创建新资源的任何请求，将删除写锁集合的内部成员URL的任何请求以及将更改任何写请求集合的段名称的任何请求。内部成员。从而，集合写锁可保护以下所有操作：o删除集合的直接内部成员，o从集合中移出内部成员，o将内部成员移入集合中，o移动以重命名集合中的内部成员，o COPY一个内部成员加入集合，然后o PUT或MKCOL请求将创建一个新的内部成员。如果内部成员本身具有锁定令牌，则该集合的锁定令牌是必需的（如果单独锁定）。此外，深度无限锁定会影响对锁定集合的所有成员的所有写入操作。使用深度无限锁，将直接锁定由锁的根标识的资源，并间接锁定其所有成员。o作为深度无限锁定集合的后代添加的任何新资源将被间接锁定。 o随后，将任何从锁定集合移出到未锁定集合中的间接锁定资源都被解锁。 o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见o随后，将任何从锁定集合移出到未锁定集合中的间接锁定资源都被解锁。 o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见o随后，将任何从锁定集合移出到未锁定集合中的间接锁定资源都被解锁。 o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见o从锁定源集合移出到深度无限锁定目标集合中的任何间接锁定资源将保持间接锁定，但现在受到目标集合上锁的保护（此后将需要目标集合的锁令牌进行进一步更改）。如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见如果向包含成员URL的集合发出深度无限写LOCK请求，该成员URL标识当前以与新锁冲突的方式锁定的资源（请参见&lt;a href=&quot;#section-6.1&quot;&gt;在第6.1节的第&lt;/a&gt; 3点）中，请求必须失败，并带有423（锁定）状态代码，并且响应应包含&amp;ldquo;无冲突锁&amp;rdquo;的前提条件。如果锁定请求导致将资源的URL添加为深度无限锁定集合的内部成员URL，则新资源务必由锁定自动保护。例如，如果集合/ a / b /被写锁定并且资源/ c被移动到/ a / b / c，那么资源/ a / b / c将被添加到写锁定。</target>
        </trans-unit>
        <trans-unit id="d5dc7184e37e2ac541668d7dc3337de81f5981e3" translate="yes" xml:space="preserve">
          <source>There are two multipart types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0970064e3114d24ebea32cf716e29a9559cf977" translate="yes" xml:space="preserve">
          <source>There are two possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea804f8e0e63528d1dd87bc0e827f009664d28b8" translate="yes" xml:space="preserve">
          <source>There are two types of HTTP messages, requests and responses, each with its own format.</source>
          <target state="translated">HTTP消息有两种类型,请求和响应,每种类型都有自己的格式。</target>
        </trans-unit>
        <trans-unit id="fe2bb96492312ef6374bb657cdd41b390e796741" translate="yes" xml:space="preserve">
          <source>There are two types of proxies: &lt;strong&gt;forward proxies&lt;/strong&gt; (or tunnel, or gateway) and&lt;strong&gt; reverse proxies&lt;/strong&gt; (used to control and protect access to a server for load-balancing, authentication, decryption or caching).</source>
          <target state="translated">代理有两种类型：&lt;strong&gt;正向代理&lt;/strong&gt;（或隧道或网关）和&lt;strong&gt;反向代理&lt;/strong&gt;（用于控制和保护对服务器的访问，以进行负载平衡，身份验证，解密或缓存）。</target>
        </trans-unit>
        <trans-unit id="d24023e8db6a2be9a6f15c3bd48794df9fdd2114" translate="yes" xml:space="preserve">
          <source>There is a discussion to add WebP (&lt;code&gt;image/webp&lt;/code&gt;) to this list, but browser vendors are cautious in accepting it.</source>
          <target state="translated">讨论将WebP（ &lt;code&gt;image/webp&lt;/code&gt; ）添加到此列表中，但是浏览器供应商在接受它时保持谨慎。</target>
        </trans-unit>
        <trans-unit id="973c4945198f89ca852f9330ea8ecbaa87253ef7" translate="yes" xml:space="preserve">
          <source>There is effort from browsers in moving to a stricter default value, namely &lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; (see &lt;a href=&quot;https://github.com/whatwg/fetch/pull/952&quot;&gt;https://github.com/whatwg/fetch/pull/952&lt;/a&gt;), consider using this value (or a stricter one), if possible, when changing the Referrer-Policy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357745e961c49e7808944a7f96ad3fca2b616dd4" translate="yes" xml:space="preserve">
          <source>There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.</source>
          <target state="translated">这个请求没有内容要发送,但头文件可能有用。用户代理可能会用新的头文件来更新这个资源的缓存头文件。</target>
        </trans-unit>
        <trans-unit id="2f5a6e5a3d7f30adf4bc4c7e14047c3ad52fec62" translate="yes" xml:space="preserve">
          <source>There is no way to deal with this problem without annoying one of the two clients. However, lost updates and race conditions are to be avoided. We want predictable results, and expect that the clients are notified when their changes are rejected.</source>
          <target state="translated">在不烦扰两个客户端中的一个客户端的情况下,没有办法处理这个问题。但是,要避免丢失更新和比赛条件。我们希望得到可预测的结果,并希望客户的更改被拒绝时能得到通知。</target>
        </trans-unit>
        <trans-unit id="5746b1d21828f38918b30138869ef276f2228158" translate="yes" xml:space="preserve">
          <source>There is one associative array already defined (because a JavaScript currently cannot define them on its own):</source>
          <target state="translated">已经定义了一个关联数组(因为目前JavaScript无法自行定义它们)。</target>
        </trans-unit>
        <trans-unit id="d277b5fa967b80dbc6939e7b654fcee1641c47de" translate="yes" xml:space="preserve">
          <source>There may be cases where a client wishes to submit state tokens, but
   doesn't want the request to fail just because the state token isn't
   current anymore.  One simple way to do this is to include a Condition
   that is known to always evaluate to true, such as in:

     If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;)
       (Not &amp;lt;DAV:no-lock&amp;gt;)

   &quot;DAV:no-lock&quot; is known to never represent a current lock token.  Lock
   tokens are assigned by the server, following the uniqueness
   requirements described in &lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;, therefore cannot use the
   &quot;DAV:&quot; scheme.  Thus, by applying &quot;Not&quot; to a state token that is 

   known not to be current, the Condition always evaluates to true.
   Consequently, the whole If header will always evaluate to true, and
   the lock token urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 will be
   submitted in any case.</source>
          <target state="translated">在某些情况下，客户希望提交状态令牌，但不希望仅因为状态令牌不再有效而导致请求失败。一种简单的方法是包含一个条件，该条件始终被评估为true，例如：If：（&amp;lt;urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;）（Not &amp;lt;DAV：no- lock&amp;gt;）已知&amp;ldquo; DAV：no-lock&amp;rdquo;从不代表当前的锁定令牌。锁定令牌由服务器分配，遵循&lt;a href=&quot;#section-6.5&quot;&gt;第6.5节中&lt;/a&gt;描述的唯一性要求，因此不能使用&amp;ldquo; DAV：&amp;rdquo;方案。因此，通过对已知不是当前状态的状态令牌应用&amp;ldquo;非&amp;rdquo;，条件始终评估为true。因此，整个If标头将始终为true，并且无论如何都将提交锁定令牌urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2。</target>
        </trans-unit>
        <trans-unit id="ea32afad30d9372a076356ddcbf2224780548842" translate="yes" xml:space="preserve">
          <source>There may be other regulations governing the use of cookies in your locality. The burden is on you to know and comply with these regulations. There are companies that offer &quot;cookie banner&quot; code that helps you comply with these regulations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2490d9396fd52fc708c5e36b206a6d2e488dee63" translate="yes" xml:space="preserve">
          <source>There should always be a confirmation required for any sensitive action.</source>
          <target state="translated">任何敏感的行动都应该有一个确认的要求。</target>
        </trans-unit>
        <trans-unit id="291573b8b0016bfdbfee8add5e78d0c5e2c87fdd" translate="yes" xml:space="preserve">
          <source>There was one associative array (object) already defined, because at the time JavaScript code was unable to define it by itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8936e6969eea24b3ea42fd8769c85fdddd316b" translate="yes" xml:space="preserve">
          <source>These HTTP codes are not redefined, but their use is somewhat
   extended by WebDAV methods and requirements.  In general, many HTTP
   status codes can be used in response to any request, not just in
   cases described in this document.  Note also that WebDAV servers are
   known to use 300-level redirect responses (and early interoperability
   tests found clients unprepared to see those responses).  A 300-level
   response MUST NOT be used when the server has created a new resource
   in response to the request.</source>
          <target state="translated">这些HTTP代码并没有被重新定义,但它们的使用在一定程度上被WebDAV方法和要求所扩展。一般来说,许多HTTP状态码可以用于响应任何请求,而不仅仅是本文档中描述的情况。还请注意,WebDAV服务器已知使用300级重定向响应(早期的互操作性测试发现客户端没有准备好看到这些响应)。当服务器为响应请求而创建了新的资源时,决不能使用300级响应。</target>
        </trans-unit>
        <trans-unit id="d2011ed2f18ef5bdd96144452aa6435ca84d3624" translate="yes" xml:space="preserve">
          <source>These URLs are examples &amp;mdash; the site could serve the different filetypes with any URL patterns it wishes, such as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;query string parameter&lt;/a&gt;: &lt;code&gt;/documents/foo?format=json&lt;/code&gt;, &lt;code&gt;/documents/foo?format=xml&lt;/code&gt;, and so on.</source>
          <target state="translated">这些URL是示例-网站可以使用其希望的任何URL模式提供不同的文件类型，例如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;查询字符串参数&lt;/a&gt;： &lt;code&gt;/documents/foo?format=json&lt;/code&gt; ， &lt;code&gt;/documents/foo?format=xml&lt;/code&gt; 等等。</target>
        </trans-unit>
        <trans-unit id="19ac2e7adff1466c1a8f79fcbd5235600c8aac56" translate="yes" xml:space="preserve">
          <source>These URLs will be rewritten before the request is made, meaning that no insecure requests will hit the network. Note that, if the requested resource is not actually available via HTTPS, the request will fail without any fallback to HTTP.</source>
          <target state="translated">这些URL将在请求之前被重写,这意味着不会有不安全的请求冲击网络。请注意,如果请求的资源实际上无法通过HTTPS获得,则请求将失败,而不会回退到HTTP。</target>
        </trans-unit>
        <trans-unit id="14aea1eca27b905f4bb97521d425369003cb4f07" translate="yes" xml:space="preserve">
          <source>These are some sample UA strings from other Gecko-based browsers on various platforms. Note that many of these have not yet been released on Gecko 2.0!</source>
          <target state="translated">这是一些来自不同平台上其他基于Gecko的浏览器的UA字符串示例。请注意,其中许多还没有在Gecko 2.0上发布。</target>
        </trans-unit>
        <trans-unit id="f6caceedce573b19f722b4be7d0ac77739c262ca" translate="yes" xml:space="preserve">
          <source>These are the values sent when the context doesn't give better information. Note that all browsers add the &lt;code&gt;*/*&lt;/code&gt; MIME Type to cover all cases. This is typically used for requests initiated via the address bar of a browser, or via an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">这些是在上下文无法提供更好信息时发送的值。请注意，所有浏览器都会添加 &lt;code&gt;*/*&lt;/code&gt; MIME类型以涵盖所有情况。通常用于通过浏览器的地址栏或HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt;元素发起的请求。</target>
        </trans-unit>
        <trans-unit id="63ded4498d8ac164d315a41831a90dda911d2194" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="translated">这四个构建基块已在1990年底完成，并且第一批服务器已在1991年初在CERN外部运行。1991年8月6 &lt;sup&gt;日&lt;/sup&gt;，蒂姆&amp;middot;伯纳斯&amp;middot;李（Tim Berners-Lee）在公共&lt;em&gt;alt.post&lt;/em&gt;上的&lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;帖子&lt;/a&gt;现在被认为是官方的互联网作为公共项目的开始。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0baa00267d012f566fcf313a5a48be2638b11dd3" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe283302753b3d4f0050a7e568fff6e5641e1e65" translate="yes" xml:space="preserve">
          <source>These functions can be used in building the PAC file:</source>
          <target state="translated">这些功能可以用于建立PAC文件。</target>
        </trans-unit>
        <trans-unit id="1a84013246b548f38ea0c6cbcd4306fd09b1fd50" translate="yes" xml:space="preserve">
          <source>These headers &lt;em&gt;must&lt;/em&gt; be transmitted to the final recipient of the message: the server for a request, or the client for a response. Intermediate proxies must retransmit these headers unmodified and caches must store them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adec7a72aca0f353da15e6ce23d6fb621cfcba41" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection and must not be retransmitted by proxies or cached. Such headers are: &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="translated">这些标头仅对单个传输级连接有意义，并且不得由代理重新传输或缓存。这样的标头是：&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;。请注意，只能使用&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;常规标头设置逐跳标头。</target>
        </trans-unit>
        <trans-unit id="c6d30d003653ac1d60828803e6858dd6022c5e88" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection, and &lt;em&gt;must not&lt;/em&gt; be retransmitted by proxies or cached. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed24fa2e76be943bae964dfeca098c8b6b9d0285" translate="yes" xml:space="preserve">
          <source>These headers must be transmitted to the final recipient of the message; that is, the server for a request or the client for a response. Intermediate proxies must retransmit end-to-end headers unmodified and caches must store them.</source>
          <target state="translated">这些报头必须传送给消息的最终接收者,即请求的服务器或响应的客户端。中间代理必须不加修改地重传端到端报头,缓存必须存储这些报头。</target>
        </trans-unit>
        <trans-unit id="49c4698bda080192aa7cae79c66f0082e395ce72" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it get traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="translated">引入这些新颖性并不是为了共同努力，而是作为1991-1995年间的一种试用方法：服务器和浏览器添加了一个功能，并观察了它是否吸引了人们。许多互操作性问题很常见。为了解决这些烦恼，1996年11月，发布了描述通用做法的信息文档&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;。这是HTTP / 1.0的定义，值得注意的是，它不是官方标准。</target>
        </trans-unit>
        <trans-unit id="970955263d6d4ddd63f73c663170a288a2997da3" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it got traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3e47aa5ab3cee6753961966b6b7cea5b1c2b29" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should no longer be used, and replaced with the new one.Search engine robots, RSS readers, and other crawlers will update the original URL for the resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c006f1681899103b8b2e153338a77be2fac29883" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should not be used anymore and that the new one is preferred. Search engine robots trigger an update of the associated URL for the resource in their indexes.</source>
          <target state="translated">这些重定向的目的是为了永久保存。它们意味着原来的URL不应再被使用,新的URL是首选。搜索引擎机器人会触发其索引中资源的相关URL的更新。</target>
        </trans-unit>
        <trans-unit id="a400740c640b1a2456fc464d677ae89fe9a9ea33" translate="yes" xml:space="preserve">
          <source>These regulations have global reach, because they apply to any site on the &lt;em&gt;World Wide&lt;/em&gt; Web that is accessed by users from these jurisdictions (the EU and California, with the caveat that California's law applies only to entities with gross revenue over 25 million USD, among other things.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d896ad159048e4b552eaa0836d02af56e04f2aad" translate="yes" xml:space="preserve">
          <source>These regulations include requirements such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3faadcdd29a9a6bfd08a2c7df57422c7e3b140f" translate="yes" xml:space="preserve">
          <source>These types of manipulations can be prevented by disallowing Javascript via the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; CSP directive.</source>
          <target state="translated">可以通过使用&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; CSP指令禁止Javascript来阻止这些类型的操作。</target>
        </trans-unit>
        <trans-unit id="b94cf424727db244876c5a0b8a36ae1be82af513" translate="yes" xml:space="preserve">
          <source>They exist. They are hard to defend against. Research continues.
   Beware.</source>
          <target state="translated">它们是存在的。它们很难抵御。研究还在继续。小心。</target>
        </trans-unit>
        <trans-unit id="2b2bbfc5127ae16613bef18603ec77b3984aa83a" translate="yes" xml:space="preserve">
          <source>They should always provide a way to overcome the server-chosen language, e.g., by providing a language menu on the site. Most user-agents provide a default value for the &lt;code&gt;Accept-Language&lt;/code&gt; header, adapted to the user interface language and end users often do not modify it, either by not knowing how, or by not being able to do it, as in an Internet caf&amp;eacute; for instance.</source>
          <target state="translated">他们应该始终提供一种克服服务器选择的语言的方法，例如，通过在站点上提供语言菜单。大多数用户代理会为 &lt;code&gt;Accept-Language&lt;/code&gt; 标头提供默认值，以适应用户界面语言，并且最终用户通常不了解它，或者因为不知道如何或无法做到而不能修改它，例如在网吧中例如。</target>
        </trans-unit>
        <trans-unit id="d3bab67bcd21378560c58ae4bc5a035031a2e0e6" translate="yes" xml:space="preserve">
          <source>Third-party cookies</source>
          <target state="translated">第三方饼干</target>
        </trans-unit>
        <trans-unit id="78174180aec78d0cf1800defae73ef9440efe127" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; and worker are blocked and won't load:</source>
          <target state="translated">此&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;和worker被阻止，无法加载：</target>
        </trans-unit>
        <trans-unit id="f02d516991c23089fc7ef470b5b1f7122a1b1ddc" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; can enable cross-site HTTP requests for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd32e06ea9f72392b7e2d0f29fca1199727c26bb" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; is used to enable cross-site HTTP requests for:</source>
          <target state="translated">此&lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;跨域共享标准&lt;/a&gt;用于为以下站点启用跨站点HTTP请求：</target>
        </trans-unit>
        <trans-unit id="881b9b16e882da2c89e10f1e6cd38cf9b040fadb" translate="yes" xml:space="preserve">
          <source>This Feature Policy directive was at one point defined as &lt;code&gt;xr&lt;/code&gt; (but implemented in Chrome as &lt;a href=&quot;vr&quot;&gt;&lt;code&gt;vr&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;xr-spatial-tracking&quot;&gt;&lt;code&gt;xr-spatial-tracking&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451546fb091c1c1b7ec24fc3cf824086880d3078" translate="yes" xml:space="preserve">
          <source>This Warning code MUST be added by a proxy if it applies any
   transformation to the representation, such as changing the
   content-coding, media-type, or modifying the representation data,
   unless this Warning code already appears in the response.</source>
          <target state="translated">如果代理对表示进行任何转换,例如改变内容编码、媒体类型或修改表示数据,则必须添加此Warning代码,除非此Warning代码已经出现在响应中。</target>
        </trans-unit>
        <trans-unit id="8c5ceee1b632af499883fff54e65911348e83c82" translate="yes" xml:space="preserve">
          <source>This Webpage has a redirect loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ecbc255cf2ecd1c85dbf2f6ac85289ceb68820" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;X-My-Custom-Header&lt;/code&gt; and &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; headers to be exposed to the browser.</source>
          <target state="translated">这允许 &lt;code&gt;X-My-Custom-Header&lt;/code&gt; 和 &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; 标题公开给浏览器。</target>
        </trans-unit>
        <trans-unit id="d793e4bdbd751c7b733ab0e15d263a1a9069b84e" translate="yes" xml:space="preserve">
          <source>This appendix is informative.

   The Relax NG schema explicitly excludes elements in the Atom Protocol
   namespace that are not defined in this revision of the specification.
   Requirements for Atom Protocol processors encountering such markup
   are given in Sections &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   The Schema for Service Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace xhtml = &quot;&lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appService

   # common:attrs

   atomURI = text

   appCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag  }?,
      attribute xml:space {&quot;default&quot;|&quot;preserved&quot;}?,
      undefinedAttribute*

   atomCommonAttributes = appCommonAttributes

   undefinedAttribute = attribute * - (xml:base | xml:space  | xml:lang
     | local:*) { text }

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   } 

   atomDateConstruct =
       appCommonAttributes,
       xsd:dateTime

   # app:service
   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }

   # app:workspace

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }

   # app:collection

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }

   # app:categories

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # app:accept

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }

   # Simple Extension

   simpleSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         text
      }

   simpleExtensionElement =
      element * - (app:*) {
         text
      }

   # Structured Extension

   structuredSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      } 

   structuredExtensionElement =
      element * - (app:*) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      }

   # Other Extensibility

   extensionSansTitleElement =
    simpleSansTitleExtensionElement|structuredSansTitleExtensionElement

   extensionElement = simpleExtensionElement |
      structuredExtensionElement

   undefinedContent = (text|anyForeignElement)*

   # Extensions

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - app:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   atomPlainTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;text&quot; | &quot;html&quot; }?,
       text

   atomXHTMLTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;xhtml&quot; },
       xhtmlDiv

   atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct 

   anyXHTML = element xhtml:* {
       (attribute * { text }
        | text
        | anyXHTML)*
   }

   xhtmlDiv = element xhtml:div {
     (attribute * { text }
      | text
      | anyXHTML)*
   }

   # EOF

   The Schema for Category Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appCategories

   atomCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag }?,
      undefinedAttribute*

   undefinedAttribute = attribute * - (xml:base | xml:lang | local:*) {
     text }

   atomURI = text

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   }

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           (empty)
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # Extensibility

   undefinedContent = (text|anyForeignElement)*

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - atom:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   # EOF 

Authors' Addresses

   Joe Gregorio (editor)
   Google

   EMail: joe@bitworking.org
   URI:   &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt;


   Bill de hOra (editor)
   NewBay Software

   EMail: bill@dehora.net
   URI:   &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Gregorio &amp;amp; de hOra          Standards Track                    [Page 53]</source>
          <target state="translated">本附录内容丰富。 Relax NG模式明确排除了Atom协议名称空间中在此规范修订版中未定义的元素。遇到这种标记的Atom协议处理器的要求在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]的&lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;和&lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;节中给出。服务文档的架构：＃-*-rnc-*-＃Atom协议名称空间的RELAX NG紧凑语法语法=&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;rdquo;名称空间atom =&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http：// www.w3.org/2005/Atom&lt;/a&gt; &amp;ldquo;名称空间xsd =&amp;rdquo; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt; &amp;ldquo;名称空间xhtml =&amp;rdquo; &lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&amp;ldquo;名称空间local =&amp;rdquo;&amp;ldquo;开始= appService＃common：attrs atomURI =文本appCommonAttributes =属性xml：base {atomURI} ?，属性xml：lang {atomLanguageTag} ?，属性xml：space {&amp;rdquo; default&amp;ldquo; |&amp;rdquo;保存&amp;ldquo;}？ ，undefinedAttribute * atomCommonAttributes = appCommonAttributes undefinedAttribute =属性*-（xml：base | xml：space | xml：lang | local：*）{text} atomLanguageTag = xsd：string {pattern =&amp;ldquo;（[[A-Za-z] {1 ，8}（-[A-Za-z0-9] {1,8}）*）？&amp;ldquo;}} atomDateConstruct = appCommonAttributes，xsd：dateTime＃app：service appService =元素app：service {appCommonAttributes，（appWorkspace +＆extensionElement * }}＃app：workspace appWorkspace =元素app：工作区{appCommonAttributes，（atomTitle＆appCollection *＆extensionSansTitleElement *）} atomTitle =元素atom：title {atomTextConstruct}＃app：collection appCollection =元素app：collection {appCommonAttributes，属性href {atomURI}，（atomTitle＆appAccept *＆appCategories * ＆extensionSansTitleElement *）}＃app：categories atomCategory =元素atom：category {atomCommonAttributes，属性项{text}，属性方案{atomURI} ?，属性标签{text} ？， undefinedContent} appInlineCategories =元素app：categories {属性已固定{ &amp;ldquo;是&amp;rdquo; | &amp;ldquo; no&amp;rdquo;} ?,属性方案{atomURI} ?,（atomCategory *，undefinedContent）} appOutOfLineCategories =元素app：categories {attribute href {atomURI}，undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories＃app：accept appAccept =元素app：accept {appCommonAttributes，（text？）}＃简单扩展simpleSansTitleExtensionElement = element *-（app：* | atom：title）{text} simpleExtensionElement = element *-（app：*）{文本}＃结构化扩展结构化SansTitleExtensionElement =元素*-（app：* | atom：title）{（属性* {文本} +，（text | anyElement）*）| （属性* {文本} *，（文本？，anyElement +，（text | anyElement）*））} StructuralExtensionElement =元素*-（app：*）{（attribute * {text} +，（text | anyElement）*）| （attribute * {text} *，（text ?, anyElement +，（text | anyElement）*））}＃其他可扩展性extensionSansTitleElement = simpleSansTitleExtensionElement | structuredSansTitleExtensionElement extensionElement = simpleExtensionElement | StructuralExtensionElement undefinedContent =（text | anyForeignElement）*＃扩展anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-app：* {（attribute {{text} | text | anyElement）* } atomPlainTextConstruct = atomCommonAttributes，属性类型{&amp;ldquo; text&amp;rdquo; | &amp;ldquo; html&amp;rdquo;} ?，文本atomXHTMLTextConstruct = atomCommonAttributes，属性类型{&amp;ldquo; xhtml&amp;rdquo;}，xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML =元素xhtml：* {（属性* {文本} |文本| anyXHTML）*} xhtmlDiv =元素xhtml：div {（属性* {文本} |文本| anyXHTML）*}＃EOF类别文档的架构：＃ -*-rnc-*-＃Atom协议名称空间应用的RELAX NG精简语法=xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML =元素xhtml：* {（属性* {文本} |文本| anyXHTML）*} xhtmlDiv =元素xhtml：div {（属性* {文本} |文本| anyXHTML）*}＃EOF类别文档的架构：＃ -*-rnc-*-＃Atom协议名称空间app的RELAX NG紧凑语法语法=&amp;ldquo;xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML =元素xhtml：* {（属性* {文本} |文本| anyXHTML）*} xhtmlDiv =元素xhtml：div {（属性* {文本} |文本| anyXHTML）*}＃EOF类别文档的架构：＃ -*-rnc-*-＃Atom协议名称空间应用的RELAX NG精简语法=&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;ldquo;命名空间atom =&amp;rdquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &amp;ldquo;命名空间xsd =&amp;rdquo; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&amp;ldquo;名称空间local =&amp;rdquo;&amp;ldquo;开始= appCategories atomCommonAttributes =属性xml：base {atomURI} ?，属性xml：lang {atomLanguageTag} ?， undefinedAttribute * undefinedAttribute =属性*-（xml：base | xml：lang | local：*）{文字} atomURI =文字atomLanguageTag = xsd：string {模式=&amp;ldquo;（[[A-Za-z] {1,8}（-[A-Za-z0-9] {1,8}）*）？&amp;rdquo;}} atomCategory =元素atom：category {atomCommonAttributes，属性术语{text}，属性方案{atomURI} ？，属性标签{text} ？， undefinedContent} appInlineCategories =元素app：categories {属性固定{&amp;ldquo; yes&amp;rdquo; |&amp;ldquo; no&amp;rdquo;} ？，属性方案{atomURI} ?,（atomCategory *，undefinedContent）} appOutOfLineCategories =元素app：categories {attribute href {atomURI}，（empty）} appCategories = appInlineCategories | appOutOfLineCategories＃可扩展性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（{attribute * {text} | text | anyElement）* }＃EOF作者的地址Joe Gregorio（编辑）Google电子邮件：joe@bitworking.org URI：（空）} appCategories = appInlineCategories | appOutOfLineCategories＃可扩展性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（attribute {{text} | text | anyElement）* }＃EOF作者的地址Joe Gregorio（编辑）Google电子邮件：joe@bitworking.org URI：（空）} appCategories = appInlineCategories | appOutOfLineCategories＃可扩展性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（attribute {{text} | text | anyElement）* }＃EOF作者的地址Joe Gregorio（编辑）Google电子邮件：joe@bitworking.org URI：* {（属性* {文本} |文本| anyElement）*}＃EOF作者的地址Joe Gregorio（编辑）Google EMail：joe@bitworking.org URI：* {（属性* {文本} |文本| anyElement）*}＃EOF作者的地址Joe Gregorio（编辑）Google EMail：joe@bitworking.org URI： &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt; Bill de hOra（编辑）NewBay Software电子邮件：bill@dehora.net URI：&lt;a href=&quot;http://dehora.net/&quot;&gt;http&lt;/a&gt; ://dehora.net/ 完整的版权声明版权所有（C）IETF Trust（2007年）。本文档受&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78中&lt;/a&gt;包含的权利，许可和限制的约束，除非另有说明，否则作者保留所有权利。本文档及其中包含的信息均按&amp;ldquo;原样&amp;rdquo;提供，并且贡献者，他/她代表的组织或赞助者（如果有），互联网社会，IETF信托和互联网工程任务强制免责声明明示或暗示的担保，包括但不限于任何担保，即使用此处的信息不会侵犯任何权利或对特定用途的适销性或适用性的任何默示担保。知识产权IETF对于可能声称与实施或使用本文档中描述的技术有关的任何知识产权或其他权利的有效性或范围，或根据此类权利获得的任何许可可能或不具有的范围，不采取任何立场。可能不可用；它也不表示它已做出任何独立的努力来确定任何此类权利。可以在以下位置找到有关RFC文档中有关权利的程序的信息：&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;。可以获取向IETF秘书处披露的IPR的副本，以及可以提供的任何许可保证，或者本规范的实施者或用户尝试获得一般许可或使用此类所有权的许可的结果。从&lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;的IETF在线IPR存储库中获得 。 IETF邀请任何感兴趣的一方提请其注意任何版权，专利或专利申请，或可能涵盖实施该标准所需技术的其他所有权。请通过ietf-ipr@ietf.org将信息发送给IETF。 Gregorio＆de hOra标准跟踪[页53]</target>
        </trans-unit>
        <trans-unit id="2da261bce7b3f1d3df96b4c74a292834af8e4041" translate="yes" xml:space="preserve">
          <source>This article documents the default values for the HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; header for specific inputs and browser versions.</source>
          <target state="translated">本文记录了特定输入和浏览器版本的HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; 标头的默认值。</target>
        </trans-unit>
        <trans-unit id="76ccc899841c5ef0fd03f785dbd8994ed74b0227" translate="yes" xml:space="preserve">
          <source>This article is a general discussion of Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.</source>
          <target state="translated">本文是对跨源资源共享的一般性讨论,包括对必要的HTTP头文件的讨论。</target>
        </trans-unit>
        <trans-unit id="f43366408332e68939fb55f17a9ba0a7c3e2020f" translate="yes" xml:space="preserve">
          <source>This article provides guidance on how to choose whether to use a www-prefixed domain or not, along with the consequences of that choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ec7728272d28393919275489b46845b2a0bf81" translate="yes" xml:space="preserve">
          <source>This can be done easily using the command-line &lt;code&gt;uuencode&lt;/code&gt; utility on Linux and Mac OS X systems:</source>
          <target state="translated">使用Linux和Mac OS X系统上的命令行 &lt;code&gt;uuencode&lt;/code&gt; 实用程序可以轻松完成此操作：</target>
        </trans-unit>
        <trans-unit id="11f06821ff38b68a8a006d81f07fe9d41afdd57e" translate="yes" xml:space="preserve">
          <source>This can be useful for serving content dynamically, for example. When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. If you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. In addition, it can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">例如，这对于动态提供内容很有用。使用 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 标头时，缓存服务器在决定是否从缓存中提供页面时应考虑用户代理。如果您要向移动用户提供不同的内容，则可以帮助您避免缓存可能会错误地为移动用户提供网站的桌面版本。此外，它还可以帮助Google和其他搜索引擎发现网页的移动版本，并且还可以告诉他们没有&lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;隐瞒&lt;/a&gt;的意图。</target>
        </trans-unit>
        <trans-unit id="18b253862e749024a5a8be5438a282e1f0a396b5" translate="yes" xml:space="preserve">
          <source>This can happen if the JavaScript code is running with enhanced privileges allowing it access to multiple domains' content, for example.</source>
          <target state="translated">例如,如果JavaScript代码运行时具有增强的权限,允许它访问多个域的内容,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d58af569eba5200f4747d5689b8ff7e7d1d52941" translate="yes" xml:space="preserve">
          <source>This class of status code indicates a provisional response,
   consisting only of the Status-Line and optional headers, and is
   terminated by an empty line. There are no required headers for this
   class of status code. Since HTTP/1.0 did not define any 1xx status
   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client
   except under experimental conditions.

   A client MUST be prepared to accept one or more 1xx status responses
   prior to a regular response, even if the client does not expect a 100
   (Continue) status message. Unexpected 1xx status responses MAY be
   ignored by a user agent.

   Proxies MUST forward 1xx responses, unless the connection between the
   proxy and its client has been closed, or unless the proxy itself
   requested the generation of the 1xx response. (For example, if a 

   proxy adds a &quot;Expect: 100-continue&quot; field when it forwards a request,
   then it need not forward the corresponding 100 (Continue)
   response(s).)</source>
          <target state="translated">这类状态码表示临时响应,仅由状态行和可选的头信息组成,并以空行结束。这类状态码没有必要的头信息。由于HTTP/1.0没有定义任何1xx状态码,服务器必须不向HTTP/1.0客户端发送1xx响应,除非在实验条件下。客户端必须准备好在常规响应之前接受一个或多个1xx状态响应,即使客户端不期望100(Continue)状态消息。意外的1xx状态响应可以被用户代理忽略。代理必须转发1xx响应,除非代理和它的客户端之间的连接已经关闭,或者除非代理自己要求生成1xx响应。(例如,如果代理在转发请求时添加了 &quot;期待:100-continue &quot;字段,那么它就不需要转发相应的100(Continue)响应。)</target>
        </trans-unit>
        <trans-unit id="6b9a408e9c3b7b54fbf759cb196264221abed170" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that further action needs to be
   taken by the user agent in order to fulfill the request.  The action
   required MAY be carried out by the user agent without interaction
   with the user if and only if the method used in the second request is
   GET or HEAD. A client SHOULD detect infinite redirection loops, since
   such loops generate network traffic for each redirection.

      Note: previous versions of this specification recommended a
      maximum of five redirections. Content developers should be aware
      that there might be clients that implement such a fixed
      limitation.</source>
          <target state="translated">这一类状态码表示需要用户代理采取进一步的行动才能完成请求。如果且仅当第二个请求中使用的方法是GET或HEAD时,所需的操作可以由用户代理在不与用户交互的情况下进行。客户端应该检测到无限重定向环路,因为这种环路会为每次重定向产生网络流量。注意:本规范以前的版本建议最多使用五个重定向。内容开发者应该意识到,可能有一些客户端实现了这样的固定限制。</target>
        </trans-unit>
        <trans-unit id="dbcc4967400bddc90f0377f2e1ba98fce661236c" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that the client's request was
   successfully received, understood, and accepted.</source>
          <target state="translated">这一类状态码表示客户端的请求已成功接收、理解和接受。</target>
        </trans-unit>
        <trans-unit id="aa0eac6f65fb6440a25f249695197fc412fc43a4" translate="yes" xml:space="preserve">
          <source>This code indicates that the server has received and is processing the request, but no response is available yet.</source>
          <target state="translated">该代码表示服务器已经收到并正在处理该请求,但还没有响应。</target>
        </trans-unit>
        <trans-unit id="3a6a8f72886b84a7449d24f613f3e53c70e794a8" translate="yes" xml:space="preserve">
          <source>This code is reserved for future use.</source>
          <target state="translated">此代码保留给将来使用。</target>
        </trans-unit>
        <trans-unit id="ffadfb15e2eb2fc2bbccd496410791acc5ffa9e9" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header by the client, and indicates the protocol the server is switching to.</source>
          <target state="translated">客户端发送此代码以响应&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;请求标头，并指示服务器要切换到的协议。</target>
        </trans-unit>
        <trans-unit id="aa1e5327237aabe301b48a95db0d8c6c85cc5f0b" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header from the client, and indicates the protocol the server is switching to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0827e7feb1318caf938fa97aff681eecc88f25e" translate="yes" xml:space="preserve">
          <source>This code is similar to 401 (Unauthorized), but indicates that the
   client must first authenticate itself with the proxy. The proxy MUST
   return a Proxy-Authenticate header field (&lt;a href=&quot;#section-14.33&quot;&gt;section 14.33&lt;/a&gt;) containing a
   challenge applicable to the proxy for the requested resource. The
   client MAY repeat the request with a suitable Proxy-Authorization
   header field (&lt;a href=&quot;#section-14.34&quot;&gt;section 14.34&lt;/a&gt;). HTTP access authentication is explained
   in &quot;HTTP Authentication: Basic and Digest Access Authentication&quot;
   [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">此代码类似于401（未经授权），但表示客户端必须首先使用代理对其进行身份验证。代理务必返回一个Proxy-Authenticate头域（&lt;a href=&quot;#section-14.33&quot;&gt;第14.33节&lt;/a&gt;），其中包含适用于所请求资源的代理的质询。客户可以用合适的代理授权头域（&lt;a href=&quot;#section-14.34&quot;&gt;第14.34节&lt;/a&gt;）重复请求。HTTP访问身份验证在&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]中进行了说明。</target>
        </trans-unit>
        <trans-unit id="a79aa67f6b67e62ec228c4830d6fa231aff1cf84" translate="yes" xml:space="preserve">
          <source>This design technique involves developing your Web site in 'layers', using a bottom-up approach, starting with a simpler layer and improving the capabilities of the site in successive layers, each using more features.</source>
          <target state="translated">这种设计技术涉及到在 &quot;层 &quot;中开发你的网站,使用自下而上的方法,从一个较简单的层开始,在连续的层中提高网站的功能,每个层使用更多的功能。</target>
        </trans-unit>
        <trans-unit id="c4f2bfc459cbc9d47da09ed899ca07996d8c748f" translate="yes" xml:space="preserve">
          <source>This directive is meaningless for the Public-Key-Pins-Report-Only header, it will be ignored by user agents and the header will not be cached.</source>
          <target state="translated">这个指令对于Public-Key-Pins-Report-Only头是没有意义的,它将被用户代理忽略,头也不会被缓存。</target>
        </trans-unit>
        <trans-unit id="f32511f74b3172e453c0eb1a2d75c8552c9a2edb" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element or by the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素或&lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt; &lt;/a&gt;标头字段不支持此伪指令。</target>
        </trans-unit>
        <trans-unit id="9d0590723290af17baff140ec8796150f9341847" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中不支持此指令。</target>
        </trans-unit>
        <trans-unit id="9666f84cadce7c6f50435b52cac971eac2053a67" translate="yes" xml:space="preserve">
          <source>This document creates two registrations for the identification of
   HTTP/2 (see &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) in the &quot;Application-Layer Protocol
   Negotiation (ALPN) Protocol IDs&quot; registry established in [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;].

   The &quot;h2&quot; string identifies HTTP/2 when used over TLS:

   Protocol:  HTTP/2 over TLS

   Identification Sequence:  0x68 0x32 (&quot;h2&quot;)

   Specification:  This document

   The &quot;h2c&quot; string identifies HTTP/2 when used over cleartext TCP:

   Protocol:  HTTP/2 over TCP 

   Identification Sequence:  0x68 0x32 0x63 (&quot;h2c&quot;)

   Specification:  This document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b819d9b6f80f6df35168312b4868b28bd76e9d1" translate="yes" xml:space="preserve">
          <source>This document describes an extension to the HTTP/1.1 protocol that
   allows clients to perform remote Web content authoring operations.
   This extension provides a coherent set of methods, headers, request
   entity body formats, and response entity body formats that provide
   operations for:

   Properties: The ability to create, remove, and query information
   about Web pages, such as their authors, creation dates, etc.

   Collections: The ability to create sets of documents and to retrieve
   a hierarchical membership listing (like a directory listing in a file
   system).

   Locking: The ability to keep more than one person from working on a
   document at the same time.  This prevents the &quot;lost update problem&quot;,
   in which modifications are lost as first one author, then another,
   writes changes without merging the other author's changes.

   Namespace Operations: The ability to instruct the server to copy and
   move Web resources, operations that change the mapping from URLs to
   resources.

   Requirements and rationale for these operations are described in a
   companion document, &quot;Requirements for a Distributed Authoring and
   Versioning Protocol for the World Wide Web&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].

   This document does not specify the versioning operations suggested by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].  That work was done in a separate document, &quot;Versioning
   Extensions to WebDAV&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;].

   The sections below provide a detailed introduction to various WebDAV
   abstractions: resource properties (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), collections of
   resources (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), locks (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) in general, and write locks
   (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) specifically.

   These abstractions are manipulated by the WebDAV-specific HTTP
   methods (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;) and the extra HTTP headers (&lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;) used with
   WebDAV methods.  General considerations for handling HTTP requests
   and responses in WebDAV are found in &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   While the status codes provided by HTTP/1.1 are sufficient to
   describe most error conditions encountered by WebDAV methods, there
   are some errors that do not fall neatly into the existing categories.
   This specification defines extra status codes developed for WebDAV
   methods (&lt;a href=&quot;#section-11&quot;&gt;Section 11&lt;/a&gt;) and describes existing HTTP status codes
   (&lt;a href=&quot;#section-12&quot;&gt;Section 12&lt;/a&gt;) as used in WebDAV.  Since some WebDAV methods may 

   operate over many resources, the Multi-Status response (&lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt;)
   has been introduced to return status information for multiple
   resources.  Finally, this version of WebDAV introduces precondition
   and postcondition (&lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) XML elements in error response bodies.

   WebDAV uses XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) for property names and some values, and
   also uses XML to marshal complicated requests and responses.  This
   specification contains DTD and text definitions of all properties
   (&lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;) and all other XML elements (&lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) used in
   marshalling.  WebDAV includes a few special rules on extending WebDAV
   XML marshalling in backwards-compatible ways (&lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;).

   Finishing off the specification are sections on what it means for a
   resource to be compliant with this specification (&lt;a href=&quot;#section-18&quot;&gt;Section 18&lt;/a&gt;), on
   internationalization support (&lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;), and on security
   (&lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).</source>
          <target state="translated">本文档介绍了对HTTP / 1.1协议的扩展，该扩展允许客户端执行远程Web内容创作操作。此扩展程序提供了一组连贯的方法，标头，请求实体正文格式和响应实体正文格式，这些格式提供以下操作：属性：具有创建，删除和查询有关网页信息（例如其作者，创建日期，集合：创建文档集并检索层次结构成员资格列表（如文件系统中的目录列表）的能力。锁定：可以防止多个人同时处理文档的能力。这样可以避免出现&amp;ldquo;丢失更新问题&amp;rdquo;，在丢失问题中，修改是作为第一位作者然后是另一位作者丢失的，在不合并其他作者的更改的情况下编写更改。命名空间操作：指示服务器复制和移动Web资源的功能，这种操作将URL映射更改为资源。这些操作的要求和原理在随附的文档&amp;ldquo;万维网的分布式创作和版本控制协议的要求&amp;rdquo;中进行了描述[&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]。本文档未指定[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ] 建议的版本控制操作。这项工作是在单独的文档&amp;ldquo; WebDAV的版本扩展&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]中完成的。以下各节详细介绍了各种WebDAV抽象：资源属性（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;），资源集合（&lt;a href=&quot;#section-5&quot;&gt;第5 &lt;/a&gt;&lt;a href=&quot;#section-6&quot;&gt;节&lt;/a&gt;），一般的锁（第6节），以及专门的写锁（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）。这些抽象由特定于WebDAV的HTTP方法（&lt;a href=&quot;#section-9&quot;&gt;第9节&lt;/a&gt;）和额外的HTTP标头（&lt;a href=&quot;#section-10&quot;&gt;第10节）处理。&lt;/a&gt;）与WebDAV方法一起使用。在&lt;a href=&quot;#section-8&quot;&gt;第8节中&lt;/a&gt;可以找到在WebDAV中处理HTTP请求和响应的一般注意事项。虽然HTTP / 1.1提供的状态代码足以描述WebDAV方法遇到的大多数错误情况，但有些错误并没有很好地归类到现有类别中。该规范定义了为WebDAV方法开发的额外状态代码（&lt;a href=&quot;#section-11&quot;&gt;第11节&lt;/a&gt;），并描述了WebDAV中使用的现有HTTP状态代码（&lt;a href=&quot;#section-12&quot;&gt;第12节&lt;/a&gt;）。由于某些WebDAV方法可能会在许多资源上运行，因此多状态响应（&lt;a href=&quot;#section-13&quot;&gt;第13节&lt;/a&gt;已引入）以返回多个资源的状态信息。最后，此版本的WebDAV 在错误响应主体中引入了前置条件和后置条件（&lt;a href=&quot;#section-16&quot;&gt;第16节&lt;/a&gt;）XML元素。 WebDAV使用XML（[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]）作为属性名称和某些值，并且还使用XML封送复杂的请求和响应。该规范包含DTD和编组中使用的所有属性（&lt;a href=&quot;#section-15&quot;&gt;第15节&lt;/a&gt;）和所有其他XML元素（&lt;a href=&quot;#section-14&quot;&gt;第14 &lt;/a&gt;节）的文本定义。 WebDAV包含一些以向后兼容的方式扩展WebDAV XML编组的特殊规则（&lt;a href=&quot;#section-17&quot;&gt;第17节）&lt;/a&gt;）。规范的最后部分是关于资源符合该规范的含义（&lt;a href=&quot;#section-18&quot;&gt;第18节&lt;/a&gt;），国际化支持（&lt;a href=&quot;#section-19&quot;&gt;第19节&lt;/a&gt;）和安全性（&lt;a href=&quot;#section-20&quot;&gt;第20节&lt;/a&gt;）的部分。</target>
        </trans-unit>
        <trans-unit id="d12cc0f3aacd5b3de7f5ba6d1f64c9e830a68a99" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了Firefox 4和更高版本以及基于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0和更高版本的应用程序中使用的用户代理字符串。有关Gecko 2.0中字符串更改的详细信息，请参阅&lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Firefox 4的最终用户代理字符串&lt;/a&gt;（博客文章）。另请参阅有关&lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;用户代理嗅探的&lt;/a&gt;本文档和此&lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77d126757eafa5a2c1ec7b146581b7a094dfa302" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了Firefox 4和更高版本以及基于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0和更高版本的应用程序中使用的用户代理字符串。有关Gecko 2.0中字符串更改的详细信息，请参阅&lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Firefox 4的最终用户代理字符串&lt;/a&gt;（博客文章）。另请参阅有关&lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;用户代理嗅探的&lt;/a&gt;本文档和此&lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b57385183fbc92e2837db521b9c0af9d5e6a089" translate="yes" xml:space="preserve">
          <source>This document establishes a registry for HTTP/2 error codes.  The
   &quot;HTTP/2 Error Code&quot; registry manages a 32-bit space.  The &quot;HTTP/2
   Error Code&quot; registry operates under the &quot;Expert Review&quot; policy
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;].

   Registrations for error codes are required to include a description
   of the error code.  An expert reviewer is advised to examine new
   registrations for possible duplication with existing error codes.
   Use of existing registrations is to be encouraged, but not mandated.

   New registrations are advised to provide the following information:

   Name:  A name for the error code.  Specifying an error code name is
      optional.

   Code:  The 32-bit error code value.

   Description:  A brief description of the error code semantics, longer
      if no detailed specification is provided. 

   Specification:  An optional reference for a specification that
      defines the error code.

   The entries in the following table are registered by this document.

   +---------------------+------+----------------------+---------------+
   | Name                | Code | Description          | Specification |
   +---------------------+------+----------------------+---------------+
   | NO_ERROR            | 0x0  | Graceful shutdown    | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | PROTOCOL_ERROR      | 0x1  | Protocol error       | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | detected             |               |
   | INTERNAL_ERROR      | 0x2  | Implementation fault | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | FLOW_CONTROL_ERROR  | 0x3  | Flow-control limits  | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | exceeded             |               |
   | SETTINGS_TIMEOUT    | 0x4  | Settings not         | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | acknowledged         |               |
   | STREAM_CLOSED       | 0x5  | Frame received for   | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | closed stream        |               |
   | FRAME_SIZE_ERROR    | 0x6  | Frame size incorrect | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | REFUSED_STREAM      | 0x7  | Stream not processed | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | CANCEL              | 0x8  | Stream cancelled     | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   | COMPRESSION_ERROR   | 0x9  | Compression state    | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | not updated          |               |
   | CONNECT_ERROR       | 0xa  | TCP connection error | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | for CONNECT method   |               |
   | ENHANCE_YOUR_CALM   | 0xb  | Processing capacity  | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | exceeded             |               |
   | INADEQUATE_SECURITY | 0xc  | Negotiated TLS       | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | parameters not       |               |
   |                     |      | acceptable           |               |
   | HTTP_1_1_REQUIRED   | 0xd  | Use HTTP/1.1 for the | &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;     |
   |                     |      | request              |               |
   +---------------------+------+----------------------+---------------+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faecb381f710b16b72849f7c98fe2e1b97f46ebf" translate="yes" xml:space="preserve">
          <source>This document establishes a registry for HTTP/2 frame type codes.
   The &quot;HTTP/2 Frame Type&quot; registry manages an 8-bit space.  The &quot;HTTP/2
   Frame Type&quot; registry operates under either of the &quot;IETF Review&quot; or
   &quot;IESG Approval&quot; policies [&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;] for values between 0x00 and 0xef,
   with values between 0xf0 and 0xff being reserved for Experimental
   Use.

   New entries in this registry require the following information:

   Frame Type:  A name or label for the frame type.

   Code:  The 8-bit code assigned to the frame type.

   Specification:  A reference to a specification that includes a
      description of the frame layout, its semantics, and flags that the
      frame type uses, including any parts of the frame that are
      conditionally present based on the value of flags.

   The entries in the following table are registered by this document.

   +---------------+------+--------------+
   | Frame Type    | Code | Section      |
   +---------------+------+--------------+
   | DATA          | 0x0  | &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;  |
   | HEADERS       | 0x1  | &lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;  |
   | PRIORITY      | 0x2  | &lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;  |
   | RST_STREAM    | 0x3  | &lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;  |
   | SETTINGS      | 0x4  | &lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;  |
   | PUSH_PROMISE  | 0x5  | &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;  |
   | PING          | 0x6  | &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;  |
   | GOAWAY        | 0x7  | &lt;a href=&quot;#section-6.8&quot;&gt;Section 6.8&lt;/a&gt;  |
   | WINDOW_UPDATE | 0x8  | &lt;a href=&quot;#section-6.9&quot;&gt;Section 6.9&lt;/a&gt;  |
   | CONTINUATION  | 0x9  | &lt;a href=&quot;#section-6.10&quot;&gt;Section 6.10&lt;/a&gt; |
   +---------------+------+--------------+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="434a26cb19aff51c4ded66c4fa66f2ee39778b92" translate="yes" xml:space="preserve">
          <source>This document establishes a registry for HTTP/2 settings.  The
   &quot;HTTP/2 Settings&quot; registry manages a 16-bit space.  The &quot;HTTP/2
   Settings&quot; registry operates under the &quot;Expert Review&quot; policy
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC5226&lt;/a&gt;] for values in the range from 0x0000 to 0xefff, with values
   between and 0xf000 and 0xffff being reserved for Experimental Use. 

   New registrations are advised to provide the following information:

   Name:  A symbolic name for the setting.  Specifying a setting name is
      optional.

   Code:  The 16-bit code assigned to the setting.

   Initial Value:  An initial value for the setting.

   Specification:  An optional reference to a specification that
      describes the use of the setting.

   The entries in the following table are registered by this document.

   +------------------------+------+---------------+---------------+
   | Name                   | Code | Initial Value | Specification |
   +------------------------+------+---------------+---------------+
   | HEADER_TABLE_SIZE      | 0x1  | 4096          | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | ENABLE_PUSH            | 0x2  | 1             | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | MAX_CONCURRENT_STREAMS | 0x3  | (infinite)    | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | INITIAL_WINDOW_SIZE    | 0x4  | 65535         | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | MAX_FRAME_SIZE         | 0x5  | 16384         | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   | MAX_HEADER_LIST_SIZE   | 0x6  | (infinite)    | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt; |
   +------------------------+------+---------------+---------------+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcb90a7a70de2cd5491bcc598340f2ac5156315" translate="yes" xml:space="preserve">
          <source>This document registers the &quot;h2c&quot; upgrade token in the &quot;HTTP Upgrade
   Tokens&quot; registry (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.6&quot;&gt;[RFC7230], Section&amp;nbsp;8.6&lt;/a&gt;).

   Value:  h2c

   Description:  Hypertext Transfer Protocol version 2 (HTTP/2)

   Expected Version Tokens:  None

   Reference:  &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; of this document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e60b8e7d814d2b2e8b9e1b3562ab67f85484b1c" translate="yes" xml:space="preserve">
          <source>This document registers the 421 (Misdirected Request) HTTP status
   code in the &quot;HTTP Status Codes&quot; registry (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.2&quot;&gt;[RFC7231], Section&amp;nbsp;8.2&lt;/a&gt;).

   Status Code:  421

   Short Description:  Misdirected Request

   Specification:  &lt;a href=&quot;#section-9.1.2&quot;&gt;Section 9.1.2&lt;/a&gt; of this document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83d25b1239accfb20c5eb5ac032a6055e8ac00e" translate="yes" xml:space="preserve">
          <source>This edition of HTTP/1.1 builds on the many contributions that went
   into &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, including
   substantial contributions made by the previous authors, editors, and
   Working Group Chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   and Paul J. Leach.  Mark Nottingham oversaw this effort as Working
   Group Chair.

   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:

   Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole,
   Adrien W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek
   Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha
   Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier,
   Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,
   Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander
   Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin
   Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern
   Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, Brian Kell,
   Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens,
   Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann,
   Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus
   Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg,
   Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave
   Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty,
   Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan
   Adler, Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D.
   Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla, Erik
   Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian
   Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser,
   Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham,
   Gili Tzabari, Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz
   Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik
   Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel,
   Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson, Ido
   Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll,
   James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie 

   Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges (who came up with
   the term 'effective Request-URI'), Jeff Pinner, Jeff Walden, Jim
   Luther, Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel
   Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp,
   John Panzer, John Schneider, John Stracke, John Sullivan, Jonas
   Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore,
   Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien
   Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin
   James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith
   Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin
   Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault,
   Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark
   Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler,
   Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin Thomson,
   Matt Lynch, Matthew Cox, Matthew Kerwin, Max Clark, Menachem Dodge,
   Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael
   Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen,
   Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin,
   Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, Nicholas
   Shanks, Nico Williams, Nicolas Alvarez, Nicolas Mailhot, Noah Slater,
   Osama Mazahir, Pablo Castro, Pat Hayes, Patrick R. McManus, Paul E.
   Jones, Paul Hoffman, Paul Marquess, Pete Resnick, Peter Lepeska,
   Peter Occil, Peter Saint-Andre, Peter Watkins, Phil Archer, Phil
   Hunt, Philippe Mougin, Phillip Hallam-Baker, Piotr Dobrogost, Poul-
   Henning Kamp, Preethi Natarajan, Rajeev Bector, Ray Polk, Reto
   Bachmann-Gmuer, Richard Barnes, Richard Cyganiak, Rob Trace, Robby
   Simpson, Robert Brewer, Robert Collins, Robert Mattson, Robert
   O'Callahan, Robert Olofsson, Robert Sayre, Robert Siemer, Robert de
   Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny
   Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam
   Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence
   (who maintained the original issues list), Sean B. Palmer, Sean
   Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon
   Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane
   Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin, Stuart
   Williams, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares,
   Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya
   Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas
   Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim Bray, Tim
   Morgan, Tim Olsen, Tom Zhou, Travis Snoozy, Tyler Close, Vincent
   Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez
   Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang,
   Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang,
   Yuchung Cheng, Yutaka Oiwa, Yves Lafon (long-time member of the
   editor team), Zed A. Shaw, and Zhong Yu.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;Section&amp;nbsp;16 of [RFC2616]&lt;/a&gt; for additional acknowledgements from
   prior revisions.</source>
          <target state="translated">此版本的HTTP / 1.1建立在&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;的许多贡献的基础上包括以前的作者，编辑和工作组主席做出的重大贡献：蒂姆&amp;middot;伯纳斯&amp;middot;李，阿里&amp;middot;洛顿宁，罗伊&amp;middot;菲尔丁，亨里克&amp;middot;弗里斯蒂克&amp;middot;尼尔森，吉姆&amp;middot;盖蒂斯，杰弗里&amp;middot;C&amp;middot;莫古尔，拉里&amp;middot;马森特和保罗&amp;middot;J&amp;middot;里奇。马克&amp;middot;诺丁汉（Mark Nottingham）担任工作组主席期间监督了这项工作。自1999年以来，以下贡献者通过报告错误，提出聪明的问题，起草或审阅文本以及评估未解决的问题，帮助改进了HTTP规范：Adam Barth，Adam Roach，Addison Phillips，Adrian Chadd，Adrian Cole，Adrien W. de Croy ，艾伦&amp;middot;福特（Alan Ford），艾伦&amp;middot;鲁滕伯格（Alan Ruttenberg），艾伯特&amp;middot;伦德，阿勒克&amp;middot;暴风雨，亚历克斯&amp;middot;鲁斯科夫，亚历山大&amp;middot;莫高特，阿列克谢&amp;middot;梅尔尼科夫，艾丽莎&amp;middot;史密斯，阿米猜&amp;middot;罗斯曼，阿米特&amp;middot;克莱因，阿莫斯&amp;middot;杰弗里斯，安德里亚斯&amp;middot;迈耶，安德里亚斯&amp;middot;彼得森，安德烈&amp;middot;波波夫，阿尼尔&amp;middot;夏尔马，安妮&amp;middot;范&amp;middot;凯森安东尼&amp;middot;布莱恩（Anthony Bryan），阿斯比约恩&amp;middot;乌尔斯堡（Abjorn Ulsberg），阿肖克&amp;middot;库马尔（Ashok Kumar），巴拉切德&amp;middot;克里希那穆尔西（Balachander Krishnamurthy），巴里&amp;middot;雷巴（Barry Leiba），本&amp;middot;劳里（Ben Laurie），本杰明&amp;middot;卡莱尔（Benjamin Carlyle），本杰明&amp;middot;尼文&amp;middot;詹金斯（Benjait Claise），比尔&amp;middot;科里（Bill Corry），比尔&amp;middot;伯克（Ber Burke），比约恩&amp;middot;霍尔曼（Bjoern Hoehrmann），鲍勃&amp;middot;谢弗勒（Bob Scheifler），鲍里斯&amp;middot;扎伯斯基（Boris Zbarsky），布雷特&amp;middot;斯拉特金（Brett Slatkin） Brian McBarron，Brian Pane，Brian Raymor，Brian Smith，Bruce Perens，Bryce Nesbitt，Cameron Heavon-Jones，Carl Kugler，Carsten Bormann，Charles Fry，Chris Burdess，Chris Newman，Christian Huitema，Cyrus Daboo，Dale Robert Anderson和Dan Wing ，Dan Winship，Daniel Stenberg，Darrel Miller，Dave Cridland，Dave Crocker，Dave Kristol，Dave Thaler，David Booth，David Singer，David W.Morris，Diwakar Shetty，Dmitry Kurochkin，Drummond Reed，Duane Wessels，Edward Lee，Eitan Adler ，艾略特&amp;middot;李尔，埃米尔&amp;middot;斯蒂芬，伊兰&amp;middot;哈默-拉哈夫，埃里克&amp;middot;威廉姆斯，埃里克&amp;middot;鲍曼，埃里克&amp;middot;劳伦斯（Eric Lawrence），埃里克&amp;middot;雷斯科拉（Eric Rescorla），埃里克&amp;middot;阿隆斯蒂（Erik Aronesty），翁俊义，埃文&amp;middot;普罗德鲁穆，费利克斯&amp;middot;盖森多尔弗（Felix Geisendoerfer），弗洛里安&amp;middot;韦默（Florian Weimer），弗兰克&amp;middot;埃勒曼（Fred Ellermann），弗雷德&amp;middot;阿卡林（Fred Akalin），弗雷德&amp;middot;博勒（Fred Bohle），弗雷德里克&amp;middot;凯泽（Gabor Molnar），加布里埃尔&amp;middot;黑山（Gabriel Montenegro），杰弗里&amp;middot;斯内登（Geborrey Shamdon） ，格雷格&amp;middot;斯莱帕克（Greg Slepak），格雷格&amp;middot;威尔金斯（Greg Wilkins），格热戈兹&amp;middot;科尔科夫斯基（Grzegorz Calkowski），哈拉德&amp;middot;特维特&amp;middot;阿尔维斯特朗德（Harald Tveit Alvestrand），哈里&amp;middot;哈尔平（Hal Halpin），海尔格&amp;middot;赫斯（Herge Hess），亨里克&amp;middot;诺德斯特罗姆（Henrik Nordstrom），亨利&amp;middot;汤普森（Henry S. ，Ido Safruti，Ilari Liusvaara，Ilya Grigorik，Ingo Struck，J.Ross Nicoll，James Cloos，James H.Manger，James Lacey，James M.Snell，Jamie Lokier，Jan Algermissen，Jari Arkko，Jeff Hodges（谁提出了术语&amp;ldquo;有效的请求URI&amp;rdquo;），杰夫&amp;middot;平纳，杰夫&amp;middot;沃尔登，吉姆&amp;middot;路德，吉图&amp;middot;帕德希，乔&amp;middot;威廉姆斯，Joe Gregorio，Joe Orton，Joel Jaeggli，John C.Klensin，John C.Mallery，John Cowan，John Kemp，John Panzer，John Schneider，John Stracke，John Sullivan，Jonas Sicking，Jonathan A.Rees，Jonathan Billington，Jonathan Moore ，乔纳森&amp;middot;西尔维拉（Jonathan Silvera），乔迪&amp;middot;罗斯（Jordi Ros），尤里斯&amp;middot;多贝尔斯汀（Joris Dobbelsteen），乔什&amp;middot;科恩（Josh Cohen），朱利安&amp;middot;皮埃尔（Jenshi Pierre），申希克&amp;middot;辛（Justshik Shin），贾斯汀&amp;middot;查普韦斯凯（Justin Chapweske），贾斯汀&amp;middot;埃伦克兰兹（Justin Erenkrantz），贾斯汀&amp;middot;詹姆斯（James James），卡尔文德&amp;middot;辛格（Karlvinder Singh），卡尔&amp;middot;杜伯斯特（Kathleen Moriarty），基思&amp;middot;霍夫曼，基思&amp;middot;霍夫曼，基思&amp;middot;摩尔，肯&amp;middot;默奇森&amp;middot;科斯坦，科恩&amp;middot;霍尔特曼沃龙科夫（Voronkov），克里斯&amp;middot;齐普（Kris Zyp），莱夫&amp;middot;赫德斯特罗姆（Leif Hedstrom），莱昂内尔&amp;middot;莫兰德（Lionel Morand），丽莎&amp;middot;杜塞特（Lisa Dusseault），马克西&amp;middot;斯塔乔维克（Maciej Stachowiak），马努&amp;middot;斯波尼（Manu Sporny），马克&amp;middot;施耐德（Marc Sl​​emko），马克&amp;middot;贝克（Mark Ba​​ker），马克&amp;middot;保利（Mark Pauley），马克&amp;middot;沃森（Mark Watson），马库斯&amp;middot;伊索马克（Markus Isomaki），马库斯&amp;middot;兰萨勒（Markus Lanthaler），马丁&amp;middot;杜尔斯特（Martin J. Nilsson，Martin Thomson，Matt Lynch，Matthew Cox，Matthew Kerwin，Max Clark，Menachem Dodge，Meral Shirazipour，Michael Burrows，Michael Hausenblas，Michael Scharf，Michael Sweet，Michael Tuexen，Michael Welzl，Mike Amundsen，Mike Belshe，Mike Bishop，Mike Kelly，Mike Schinkel，Miles Sabin，Murray S.Kucherawy，Mykyta Yevstifeyev，Nathan Rixham，尼古拉斯&amp;middot;香克斯（Nicholas Shanks），尼科&amp;middot;威廉姆斯（Nico Williams），尼古拉斯&amp;middot;阿尔瓦雷斯（Nicolas Alvarez），尼古拉斯&amp;middot;梅霍特（Nicolas Mailhot），诺亚&amp;middot;斯莱特（Noah Slater），乌萨马&amp;middot;马扎希尔（Osama Mazahir），帕勃罗&amp;middot;卡斯特罗（Pablo Castro），帕特&amp;middot;海斯（Pat Hayes），帕特里克&amp;middot;麦克马纳斯（Patrick R.McManus），保罗&amp;middot;E&amp;middot;琼斯（Paul E.圣安德烈，彼得&amp;middot;沃特金斯，菲尔&amp;middot;阿彻，菲尔&amp;middot;亨特，菲利普&amp;middot;穆金，菲利普&amp;middot;哈兰&amp;middot;贝克，皮奥特&amp;middot;多布罗格斯特，波尔&amp;middot;亨宁&amp;middot;坎普，普雷特西&amp;middot;纳塔拉扬，拉杰夫&amp;middot;贝克特，雷&amp;middot;波克，雷托&amp;middot;巴赫曼&amp;middot;格默尔，理查德&amp;middot;巴恩斯，理查德&amp;middot;加尼亚克，罗布跟踪，罗比&amp;middot;辛普森，罗伯特&amp;middot;布鲁尔，罗伯特&amp;middot;柯林斯，罗伯特&amp;middot;马特森，罗伯特&amp;middot;奥卡拉汉，Robert Olofsson，Robert Sayre，Robert Siemer，Robert de Wilde，Roberto Javier Godoy，Roberto Peon，Roland Zink，Ronny Widjaja，Ryan Hamilton，S.Mike Dierken，Salvatore Loreto，Sam Johnston，Sam Pullara，Sam Ruby，Saurabh Kulkarni，Scott劳伦斯（保留原始问题清单），肖恩&amp;middot;B&amp;middot;帕尔默，肖恩&amp;middot;特纳，塞巴斯蒂安&amp;middot;巴努德，沙恩&amp;middot;麦卡伦，大木重树，西蒙&amp;middot;雅德，斯特凡&amp;middot;埃辛，斯特凡&amp;middot;蒂尔科夫，斯特凡诺斯&amp;middot;哈拉拉基斯，斯蒂芬&amp;middot;博茨迈尔，斯蒂芬&amp;middot;法雷尔，斯蒂芬&amp;middot;肯特，斯蒂芬&amp;middot;鲁丁，斯图尔特&amp;middot;威廉姆斯，Subbu Allamaraju，Subramanian Moonesamy，Susan Hares，Sylvain Hellegouarch，Tapan Divekar，Tatsuhiro Tsujikawa，Tatsuya Hayashi，Ted Hardie，Ted Lemon，Thomas Broyer，Thomas Fossati，Thomas Maslen，Thomas Nadeau，Thomas Nordin，Thomas Roessler，Tim布雷，蒂姆&amp;middot;摩根，蒂姆&amp;middot;奥尔森，汤姆&amp;middot;周，特拉维斯&amp;middot;斯努兹，泰勒&amp;middot;罗斯特（Tyler Close），文森特&amp;middot;墨菲（Vincent Murphy），朱文波，韦纳&amp;middot;鲍曼，维尔伯&amp;middot;斯特雷特，威尔弗雷多&amp;middot;桑切斯&amp;middot;维加，威廉&amp;middot;A&amp;middot;罗维&amp;middot;小威廉姆&amp;middot;陈，威利&amp;middot;塔罗，王小书，亚伦&amp;middot;戈兰德，伊格薇&amp;middot;尼瑟特&amp;middot;佩特森，约夫&amp;middot;尼尔，约格&amp;middot;邦，尤忠，Yutaka Oiwa，Yves Lafon（编辑团队的长期成员），Zed A. Shaw和Zhong Yu。看到&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;[RFC2616]的第16节&lt;/a&gt;提供了来自先前修订版的其他确认。</target>
        </trans-unit>
        <trans-unit id="ee24423cc6a36dea3e2a80b1cc45bcc1e29b0c7b" translate="yes" xml:space="preserve">
          <source>This error can also occur if the response includes more than one &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header.</source>
          <target state="translated">如果响应包含多个 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头，也会发生此错误。</target>
        </trans-unit>
        <trans-unit id="0e1d7d044ce568115a051e7914a52c456d823802" translate="yes" xml:space="preserve">
          <source>This error means that the document was not loaded at the top level of an user-opened or noopener-opened tab or window. It can occur in these situations:</source>
          <target state="translated">该错误意味着该文档未在用户打开或未打开的标签页或窗口的顶部加载。在这些情况下可能会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="852ff1bb35f3874b9a14a70ab4ee1ec671ff8707" translate="yes" xml:space="preserve">
          <source>This error occurs when attempting to preflight a header that is not expressly allowed (that is, it's not included in the list specified by the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header sent by the server). To fix this, the server needs to be updated so that it allows the indicated header, or you need to avoid using that header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1884120a66eaf56447e8f0aecbc8de6969d27e9d" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="translated">这个错误响应是一个通用的 &quot;万能 &quot;响应。有时,服务器管理员会将类似500状态码的错误响应记录下来,并附上更多关于请求的细节,以防止将来再次发生错误。</target>
        </trans-unit>
        <trans-unit id="bf47d90cae9806b4c78cd4a0f7b36fa115bda893" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Usually, this indicates the server cannot find a better 5xx error code to response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9439e46ba591022a7d8217b7752ce9ccbf400eb2" translate="yes" xml:space="preserve">
          <source>This error response is given when the server is acting as a gateway and cannot get a response in time.</source>
          <target state="translated">当服务器作为网关,不能及时得到响应时,会给出这个错误响应。</target>
        </trans-unit>
        <trans-unit id="eab61895b7f6d33786618e886763053a4551a6b6" translate="yes" xml:space="preserve">
          <source>This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.</source>
          <target state="translated">这个错误响应意味着服务器在作为网关获取处理请求所需的响应时,得到了一个无效的响应。</target>
        </trans-unit>
        <trans-unit id="f68650d4dca44929b9f30e96e89144cfc0f2f700" translate="yes" xml:space="preserve">
          <source>This error shouldn't happen on well-tested production systems, but can be found more often while testing a new system.</source>
          <target state="translated">这个错误不应该发生在经过良好测试的生产系统上,但在测试一个新系统时可能会经常发现。</target>
        </trans-unit>
        <trans-unit id="483909e9171e2699ed78d6021cf1843f1935c891" translate="yes" xml:space="preserve">
          <source>This evolution of HTTP proves its extensibility and simplicity, liberating creation of many applications and compelling the adoption of the protocol. The environment in which HTTP is used today is quite different from that seen in the early 1990s. HTTP's original design proved to be a masterpiece, allowing the Web to evolve over a quarter of a century, without the need of a mutiny. By healing flaws, yet retaining the flexibility and extensibility which made HTTP such a success, the adoption of HTTP/2 hints at a bright future for the protocol.</source>
          <target state="translated">HTTP的这种演变证明了它的可扩展性和简单性,解放了许多应用的创建,迫使人们采用该协议。今天HTTP的使用环境与20世纪90年代初看到的环境完全不同。事实证明,HTTP最初的设计是一个杰作,使Web在四分之一个世纪的时间里得以发展,而不需要叛变。通过弥补缺陷,同时又保留了使HTTP如此成功的灵活性和可扩展性,HTTP/2的采用预示着该协议的光明前景。</target>
        </trans-unit>
        <trans-unit id="781912733ac5a2c031d25e3e8b5988cba0dcdce0" translate="yes" xml:space="preserve">
          <source>This example allows &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; content on a particular origin to access the user's location:</source>
          <target state="translated">此示例允许特定来源上的 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 内容访问用户的位置：</target>
        </trans-unit>
        <trans-unit id="ca8e2b99c120ccf6c9a6bffe95a381cde5380542" translate="yes" xml:space="preserve">
          <source>This example creates a collection called /webdisc/xfiles/ on the
   server www.example.com. 

   &amp;gt;&amp;gt;Request

     MKCOL /webdisc/xfiles/ HTTP/1.1
     Host: www.example.com


   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created</source>
          <target state="translated">本示例在服务器www.example.com上创建一个名为/ webdisc / xfiles /的集合。&amp;gt;&amp;gt;请求MKCOL / webdisc / xfiles / HTTP / 1.1主机：www.example.com &amp;gt;&amp;gt;响应HTTP / 1.1 201已创建</target>
        </trans-unit>
        <trans-unit id="a0811554d7dd6c0c801a3a83158f7a56615c10fc" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers - as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2ce892d1c3a6298b72aa271eaca87af850694a" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers -- as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="translated">这个例子比较复杂。有四(4)个代理服务器;其中一个是其他所有代理服务器的热备份,所以如果其余三个中的任何一个瘫痪,第四个将接管。此外,剩下的三个代理服务器根据URL模式分担负载,这使得他们的缓存更加有效(任何文档在三个服务器上只有一个副本--而不是每个服务器上都有一个副本)。负载是这样分配的。</target>
        </trans-unit>
        <trans-unit id="f8d7c446d07bc06ec9ae31c4aecccef522ea44ec" translate="yes" xml:space="preserve">
          <source>This example response is taken from the IETF RFC (see below) and contains a reference to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python's Life of Brian&lt;/a&gt;.</source>
          <target state="translated">此示例响应取自IETF RFC（请参见下文），其中包含对&lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python的Brian生平的&lt;/a&gt;引用。</target>
        </trans-unit>
        <trans-unit id="999b4d428320409a219f5dc5012ceca8d2b38d22" translate="yes" xml:space="preserve">
          <source>This example shows &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; when it specifies support for multiple headers.</source>
          <target state="translated">此示例在指定支持多个标 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 时显示Access-Control-Allow-Headers。</target>
        </trans-unit>
        <trans-unit id="0b1f58893a7cb8a1c12815693f3befaeab5b7414" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being copied to the
   location http://www.example.com/users/f/fielding/index.html.  The 204
   (No Content) status code indicates that the existing resource at the
   destination was overwritten.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 204 No Content</source>
          <target state="translated">本示例显示资源http://www.example.com/~fielding/index.html复制到位置http://www.example.com/users/f/fielding/index.html。状态码为204（无内容）指示目标处的现有资源已被覆盖。&amp;gt;&amp;gt;请求COPY /~fielding/index.html HTTP / 1.1主机：www.example.com目的地：http://www.example.com/users/f/fielding/index.html &amp;gt;&amp;gt;响应HTTP / 1.1 204否内容</target>
        </trans-unit>
        <trans-unit id="fa023a88dd9876a6752395fc5752087af07a81f6" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being moved to the
   location http://www.example.com/users/f/fielding/index.html.  The
   contents of the destination resource would have been overwritten if
   the destination URL was already mapped to a resource.  In this case,
   since there was nothing at the destination resource, the response
   code is 201 (Created).

   &amp;gt;&amp;gt;Request

     MOVE /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created
     Location: http://www.example.com/users/f/fielding/index.html</source>
          <target state="translated">此示例显示资源http://www.example.com/~fielding/index.html被移到位置http://www.example.com/users/f/fielding/index.html。如果目标URL已映射到资源，则目标资源的内容将被覆盖。在这种情况下，由于目标资源上没有任何内容，因此响应代码为201（已创建）。 &amp;gt;&amp;gt;请求MOVE /~fielding/index.html HTTP / 1.1主机：www.example.com目的地：http：//www.example/users/f/fielding/index.html &amp;gt;&amp;gt;响应HTTP / 1.1 201创建位置： http://www.example.com/users/f/fielding/index.html</target>
        </trans-unit>
        <trans-unit id="e00417a4554c87f42e03a721ef55ecfe0950a2cf" translate="yes" xml:space="preserve">
          <source>This example will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">这个例子将适用于这样的环境,即内部DNS服务器被设置为只能解析内部主机名,而目标是只对不可解析的主机使用代理。</target>
        </trans-unit>
        <trans-unit id="a76e357a372c477fb919b2dd879c8bc24b00a2e5" translate="yes" xml:space="preserve">
          <source>This extensible nature of HTTP has, over time, allowed for more control and functionality of the Web. Cache or authentication methods were functions handled early in HTTP history. The ability to relax the &lt;em&gt;origin constraint&lt;/em&gt;, by contrast, has only been added in the 2010s.</source>
          <target state="translated">随着时间的流逝，HTTP的这种可扩展性质允许对Web进行更多控制和功能。缓存或身份验证方法是HTTP历史记录中早期处理的函数。相比之下，放宽&lt;em&gt;原点约束的功能&lt;/em&gt;仅在2010年代才添加。</target>
        </trans-unit>
        <trans-unit id="60964c2acb63a5e80056aab53d36efc81e0dae97" translate="yes" xml:space="preserve">
          <source>This feature has been removed from the Web standards. Though some browsers may still support it, it is in the process of being dropped. Avoid using it and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="translated">此功能已从Web标准中删除。尽管某些浏览器可能仍支持它，但是它正在被删除。避免使用它，并尽可能更新现有代码；请参阅此页面底部的&lt;a href=&quot;#Browser_compatibility&quot;&gt;兼容性表&lt;/a&gt;以指导您做出决定。请注意，此功能可能随时停止起作用。</target>
        </trans-unit>
        <trans-unit id="04e8879adf91055abe755b306ecdfa7377e41ed0" translate="yes" xml:space="preserve">
          <source>This feature is available only in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;secure contexts&lt;/a&gt; (HTTPS), in some or all &lt;a href=&quot;#Browser_compatibility&quot;&gt;supporting browsers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f97d5c5e8a61c76b7ca883b249f65188e1add95" translate="yes" xml:space="preserve">
          <source>This feature is commonly used to allow a resource to be cached in uncompressed and (various) compressed forms, and served appropriately to user agents based on the encodings that they support. For example, a server can set &lt;code&gt;Vary: Accept-Encoding&lt;/code&gt; to ensure that a separate version of a resource is cached for all requests that specify support for a particular set of encodings, e.g. &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fdac85d6009334c365dfdd6eb6bef5e4374b26" translate="yes" xml:space="preserve">
          <source>This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad63cac1625affd2a84d66756a720def351fb2b3" translate="yes" xml:space="preserve">
          <source>This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.</source>
          <target state="translated">这个功能是非标准的,不在标准轨道上。不要在面向Web的生产站点上使用它:它不会对每个用户都有效。不同的实现之间也可能存在很大的不兼容性,而且未来的行为可能会改变。</target>
        </trans-unit>
        <trans-unit id="59314e7aec66910164f6914bdc2ab1c6bad7e1f6" translate="yes" xml:space="preserve">
          <source>This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.</source>
          <target state="translated">这个功能已经过时了。虽然它可能在某些浏览器中仍然有效,但不鼓励使用它,因为它可能随时被删除。尽量避免使用它。</target>
        </trans-unit>
        <trans-unit id="44d6d26ec2012e7ff67a4bdfd287c446e6ad0a4f" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: What happens under the hood when you click on a link in your browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc17d0049c62a76188340a479b6da749df640b09" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: what happens under the hood when you click on a link in your browser&amp;hellip;</source>
          <target state="translated">这篇基础文章描述了一个典型的HTTP会话：单击浏览器中的链接时幕后发生的事情&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9f93380bea42618419d88a1e2ec92eb06b4070a2" translate="yes" xml:space="preserve">
          <source>This header can be used either with a &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">此标头可以与&lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;验证器一起使用，也可以与&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;一起使用，但不能同时使用。</target>
        </trans-unit>
        <trans-unit id="e2108a313bc4bb54663d17af6f772b5774776cf7" translate="yes" xml:space="preserve">
          <source>This header from the server tells the client to store a cookie.</source>
          <target state="translated">这个来自服务器的头告诉客户端存储一个cookie。</target>
        </trans-unit>
        <trans-unit id="9f3041471fef5fbbbbc5c294aaefd72cf8e4b8e6" translate="yes" xml:space="preserve">
          <source>This header is a hint to be used when the server has no way of determining the language via another way, like a specific URL, that is controlled by an explicit user decision. It is recommended that the server never overrides an explicit decision. The content of the &lt;code&gt;Accept-Language&lt;/code&gt; is often out of the control of the user (like when traveling and using an Internet Cafe in a different country); the user may also want to visit a page in another language than the locale of their user interface.</source>
          <target state="translated">当服务器无法通过另一种方式（例如，由明确的用户决定控制的特定URL）来确定语言时，将使用此头提示。建议服务器不要覆盖明确的决定。在内容 &lt;code&gt;Accept-Language&lt;/code&gt; 往往是出于用户（旅行，在不同的国家使用网吧时等）的控制; 用户可能还希望以其用户界面的语言环境以外的其他语言访问页面。</target>
        </trans-unit>
        <trans-unit id="0e9bd72b00debb383ca11d6751998799ac99152f" translate="yes" xml:space="preserve">
          <source>This header is automatically added by clients that choose to use it; it cannot be added using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt;&lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">此标头由选择使用它的客户端自动添加；不能使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt; &lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt; &lt;/a&gt;方法添加它。</target>
        </trans-unit>
        <trans-unit id="4737f0640e2626ce2c86bf3453432d3e8fdff2b5" translate="yes" xml:space="preserve">
          <source>This header is not supported inside a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素内部不支持此标头。</target>
        </trans-unit>
        <trans-unit id="4ac57abc80887b57bdf2fcf4f45fa8fc42191101" translate="yes" xml:space="preserve">
          <source>This header is required if the request has an &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">如果请求具有&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;标头，则此标头是必需的。</target>
        </trans-unit>
        <trans-unit id="737f8eaab76cbd788575174bfce1b83385303b75" translate="yes" xml:space="preserve">
          <source>This header is still in an experimental state, and is subject to change at any time. Be wary of this when implementing it on your website. The header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae9e9e16dbee7cb2e940a19073f03abae67dabc" translate="yes" xml:space="preserve">
          <source>This header is used for debugging, statistics, and generating location-dependent content and by design it exposes privacy sensitive information, such as the IP address of the client. Therefore the user's privacy must be kept in mind when deploying this header.</source>
          <target state="translated">这个头用于调试、统计和生成与位置相关的内容,通过设计,它暴露了隐私敏感信息,如客户端的IP地址。因此,在部署这个头时,必须牢记用户的隐私。</target>
        </trans-unit>
        <trans-unit id="e339b1a060076bad3fa562c3df51670b4975b5b9" translate="yes" xml:space="preserve">
          <source>This header must be sent if the server responds with a &lt;a href=&quot;../status/405&quot;&gt;&lt;code&gt;405&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Method Not Allowed&lt;/code&gt; status code to indicate which request methods can be used. An empty &lt;code&gt;Allow&lt;/code&gt; header indicates that the resource allows no request methods, which might occur temporarily for a given resource, for example.</source>
          <target state="translated">如果服务器响应&lt;a href=&quot;../status/405&quot;&gt; &lt;code&gt;405&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Method Not Allowed&lt;/code&gt; 状态码以指示可以使用哪些请求方法，则必须发送此标头。空的 &lt;code&gt;Allow&lt;/code&gt; 标头表示该资源不允许使用任何请求方法，例如，对于给定资源而言，这可能会暂时发生。</target>
        </trans-unit>
        <trans-unit id="d038bd6662fb532b2ff18177eb47f5f8cd56f9cb" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, or &lt;a href=&quot;https://secure.wphackedhelp.com/blog/wordpress-malware-redirect-hack-cleanup/&quot;&gt;malware redirects&lt;/a&gt;, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cd8f4bdbc85c57584352cda936cbf16cec5740" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">此标头报告可能发生的违规情况。您可以使用它来迭代处理内容安全策略。您观察站点的行为，观察违规报告，然后选择由&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;标头实施的所需策略。</target>
        </trans-unit>
        <trans-unit id="6406ecfb1884f34413b4947c4224d8b102734485" translate="yes" xml:space="preserve">
          <source>This header was introduced by Microsoft in IE 8 as a way for webmasters to block content sniffing that was happening and could transform non-executable MIME types into executable MIME types. Since then, other browsers have introduced it, even if their MIME sniffing algorithms were less aggressive.</source>
          <target state="translated">这个头是微软在IE 8中引入的,作为网站管理员阻止正在发生的内容嗅探的一种方式,可以将不可执行的MIME类型转化为可执行的MIME类型。从那时起,其他浏览器也引入了它,即使他们的MIME嗅探算法不那么激进。</target>
        </trans-unit>
        <trans-unit id="ff8f924b302448210e272cb74eecb8ba48436a36" translate="yes" xml:space="preserve">
          <source>This header was originally defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt;, but the definition of &quot;selected representation&quot; in &lt;a href=&quot;https://www.rfc-editor.org/info/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; made the original definition inconsistent with current HTTP specifications. When released, The &quot;Resource Digests for HTTP&quot; draft therefore will obsolete RFC 3230 and will update the standard to be consistent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7910eee90b814ebcea921d5e05f3e798655b01a9" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue the request, or ignore the response if the request is already finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77a8aadedd58ca97eb678dcd40675e7891feafc" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">这个临时响应表明到目前为止一切正常,客户机应该继续请求,如果已经完成,则忽略它。</target>
        </trans-unit>
        <trans-unit id="97f1b290f6e916924cd7cb715ba859fdd697edc8" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown header name with the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">通过修改服务器的配置，不再通过 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 标头发送无效或未知的标头名称，此问题很可能只能在服务器端解决。还可能需要检查以确保您在客户端上使用的用户代理或HTTP库是最新的。</target>
        </trans-unit>
        <trans-unit id="5ca266f84de58335a9fa22c96177ea4b42712957" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown method name with the &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">通过修改服务器配置，不再通过 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 标头发送无效或未知的方法名称，很可能只能在服务器端解决此问题。还可能需要检查以确保您在客户端上使用的用户代理或HTTP库是最新的。</target>
        </trans-unit>
        <trans-unit id="68654c9820232d31d9835d660a42416043e4d6e6" translate="yes" xml:space="preserve">
          <source>This is a top-down approach in which you build the best possible site using all the features you want, then tweak it to make it work on older browsers. This can be harder to do, and less effective, than progressive enhancement, but may be useful in some cases.</source>
          <target state="translated">这是一种自上而下的方法,在这种方法中,你使用所有你想要的功能建立一个最好的网站,然后调整它,使其在旧的浏览器上工作。与渐进式增强相比,这可能更难做到,也更不有效,但在某些情况下可能是有用的。</target>
        </trans-unit>
        <trans-unit id="ddb9ae3d96d8b78e1be6c37fe9e53f2fec150502" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="translated">这是一个非常主观的话题，可以看作是一个&lt;a href=&quot;http://bikeshed.com/&quot;&gt;骑自行车的&lt;/a&gt;问题。如果您想深入阅读，请参阅有关该主题的&lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;许多&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="641095a78e4ebe2abe2b4166aac4c4584c32cfcf" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;https://www.netlify.com/blog/2017/02/28/to-www-or-not-www/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80608a6f9119cc7c4582aee9309cf18792c53923" translate="yes" xml:space="preserve">
          <source>This is an improvement over earlier &lt;code&gt;Accept&lt;/code&gt; headers as it no longer ranks &lt;code&gt;image/png&lt;/code&gt; above &lt;code&gt;text/html&lt;/code&gt;</source>
          <target state="translated">这是对早期的 &lt;code&gt;Accept&lt;/code&gt; 标头的改进，因为它不再将 &lt;code&gt;image/png&lt;/code&gt; 置于 &lt;code&gt;text/html&lt;/code&gt; 之上</target>
        </trans-unit>
        <trans-unit id="b2128edd161faa94a80e6eb961a49e5e2001c4b7" translate="yes" xml:space="preserve">
          <source>This is an obsolete directive that no longer works in modern browsers. Don't use it. In supporting legacy browsers, a page can be displayed in a frame only on the specified origin &lt;em&gt;uri&lt;/em&gt;. Note that in the legacy Firefox implementation this still suffered from the same problem as &lt;code&gt;SAMEORIGIN&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin. The &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header has a &lt;a href=&quot;content-security-policy/frame-ancestors&quot;&gt;&lt;code&gt;frame-ancestors&lt;/code&gt;&lt;/a&gt; directive which you can use instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">这相当于:</target>
        </trans-unit>
        <trans-unit id="f3c017ea67402b333e111c91d0d8c835c18ed46a" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers. If the etag doesn't match the original file, or if the file has been modified since it has been obtained, the change is simply rejected with a &lt;a href=&quot;status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error. It is then up to the client to deal with the error: either by notifying the user to start again (this time on the newest version), or by showing the user a &lt;em&gt;diff &lt;/em&gt;of both versions, helping them decide which changes they wish to keep.</source>
          <target state="translated">这是使用&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;标头实现的。如果etag与原始文件不匹配，或者自获取以来已对文件进行了修改，则更改将被简单拒绝，并显示&lt;a href=&quot;status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 错误。然后由客户端来处理错误：通过通知用户重新启动（这次是最新版本），或者向用户显示两个版本的&lt;em&gt;差异&lt;/em&gt;，以帮助他们确定希望保留哪些更改。 。</target>
        </trans-unit>
        <trans-unit id="124f23444ec9f501d1f80c6afe1cad1494209a7a" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints &lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="translated">这是称为&amp;ldquo; &lt;em&gt;客户端提示&lt;/em&gt; &amp;rdquo;的&lt;strong&gt;实验&lt;/strong&gt;技术的一部分，仅在Chrome 61或更高版本中可用。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8cd6fbb7a4f7885010a0bffbaf4241fed054fc3" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cd90cf410e959cd661c8e83d47ed919723c7b5" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt;. Initial support is in Chrome 46 or later. The Device-Memory value is in Chrome 61 or later.</source>
          <target state="translated">这是称为&amp;ldquo; &lt;em&gt;客户提示&lt;/em&gt; &amp;rdquo;的&lt;strong&gt;实验&lt;/strong&gt;技术的一部分。最初的支持在Chrome 46或更高版本中。设备内存值在Chrome 61或更高版本中。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c9b9f265a030439ad0eded89740990c1cd0e705" translate="yes" xml:space="preserve">
          <source>This is similar to 401 but authentication is needed to be done by a proxy.</source>
          <target state="translated">这与401类似,但需要通过代理进行认证。</target>
        </trans-unit>
        <trans-unit id="eeed176b4c6d9e486d6e3b46cc4c1482f2ae547b" translate="yes" xml:space="preserve">
          <source>This is the default behavior if no policy is specified, or if the provided value is invalid. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/path&quot;&gt;path&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/querystring&quot;&gt;querystring&lt;/a&gt; of the URL are sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS) or improves (HTTP&amp;rarr;HTTPS), but isn't sent to less secure destinations (HTTPS&amp;rarr;HTTP).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1bfe2beacf7098474167acd9a0dc8c20186348" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary &lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="translated">这是二进制文件的默认设置。因为它意味着&lt;em&gt;未知的二进制&lt;/em&gt;文件，所以浏览器通常不执行它，甚至询问是否应该执行它。他们就像将&lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt;标头设置为 &lt;code&gt;attachment&lt;/code&gt; ，并提出&amp;ldquo;另存为&amp;rdquo;对话框。</target>
        </trans-unit>
        <trans-unit id="763b865e8143c4b06adf307c51b45264f147e5ff" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary&lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1fbd395e24ae5276bcd50aae6f6286330fa789" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &quot;unknown textual file,&quot; browsers assume they can display it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9273da9e8fd5fcf9c3bde1b24ef99c570ddd6fd7" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &lt;em&gt;unknown textual&lt;/em&gt; file, browsers assume they can display it.</source>
          <target state="translated">这是文本文件的默认设置。即使确实意味着&lt;em&gt;未知的文本&lt;/em&gt;文件，浏览器也会假定他们可以显示该文件。</target>
        </trans-unit>
        <trans-unit id="65a6727795861e19e32215df8fff896b8941c0ee" translate="yes" xml:space="preserve">
          <source>This is the default value. Allows the document to be added to its opener's browsing context group unless the opener itself has a COOP of &lt;code&gt;same-origin&lt;/code&gt; or &lt;code&gt;same-origin-allow-popups&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e6e8d58bc61269a54fd031cb14f2fe33969d30" translate="yes" xml:space="preserve">
          <source>This is the default value. Allows the document to fetch cross-origin resources without giving explicit permission through the CORS protocol or the &lt;a href=&quot;cross-origin-resource-policy&quot;&gt;&lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89b69639ed3c3449649e0ef238ba09b307791ec" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The URL is sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS), but isn't sent to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">如果未指定策略，这是用户代理的默认行为。当协议安全级别保持不变（HTTP&amp;rarr;HTTP，HTTPS&amp;rarr;HTTPS）但未发送到安全性较低的目的地（HTTPS&amp;rarr;HTTP）时，URL将作为引荐来源发送。</target>
        </trans-unit>
        <trans-unit id="aec6ea7897565c6f7f8de375d3405f1846b40c5a" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The origin is sent as referrer to a-priori as-much-secure destination (HTTPS-&amp;gt;HTTPS), but isn't sent to a less secure destination (HTTPS-&amp;gt;HTTP).</source>
          <target state="translated">如果未指定策略，这是用户代理的默认行为。原始服务器将作为引荐来源发送到非常安全的先验目标（HTTPS-&amp;gt; HTTPS），但不会发送到安全性较低的目标（HTTPS-&amp;gt; HTTP）。</target>
        </trans-unit>
        <trans-unit id="176fe26e859db9d8a79b1329a0c4c540c8bdb602" translate="yes" xml:space="preserve">
          <source>This is used for caching purposes. It tells the client that the response has not been modified, so the client can continue to use the same cached version of the response.</source>
          <target state="translated">这是为缓存目的而使用的,它告诉客户机响应没有被修改,所以客户机可以继续使用响应的缓存版本。它告诉客户端响应没有被修改,所以客户端可以继续使用相同的缓存版本的响应。</target>
        </trans-unit>
        <trans-unit id="db5ca9d8b582bb760db634b162cc4217b98dc46c" translate="yes" xml:space="preserve">
          <source>This is usually a bad practice, but there are some cases in which this is necessary. In these cases, you should first analyze your situation to be sure it's really necessary. Can you prevent it by adding some non-semantic &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; elements? The difficulty of successfully using user agent detection is worth a few disruptions to the purity of your HTML. Also, rethink your design: can you use progressive enhancement or fluid layouts to help remove the need to do this?</source>
          <target state="translated">这通常是一种不好的做法，但是在某些情况下有必要这样做。在这种情况下，您应该首先分析您的情况以确保确实有必要。您可以通过添加一些非语义性的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; &lt;/a&gt;元素来防止这种情况吗？成功使用用户代理检测的困难值得您为HTML的纯净度做一些破坏。另外，请重新考虑您的设计：您可以使用渐进式增强或流畅布局来帮助消除这样做的需要吗？</target>
        </trans-unit>
        <trans-unit id="0d42afd2b8cd7621e5970bc258f4d2e2f724c681" translate="yes" xml:space="preserve">
          <source>This means that if you do not need to support legacy browsers, it is recommended that you use &lt;code&gt;&lt;a href=&quot;content-security-policy&quot;&gt;Content-Security-Policy&lt;/a&gt;&lt;/code&gt; without allowing &lt;code&gt;unsafe-inline&lt;/code&gt; scripts instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17702de3201465eb14c00b1b36262a93968df79b" translate="yes" xml:space="preserve">
          <source>This means that the resource is now permanently located at another URI, specified by the &lt;code&gt;Location:&lt;/code&gt; HTTP Response header. This has the same semantics as the &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">这意味着资源现在永久位于&amp;ldquo; &lt;code&gt;Location:&lt;/code&gt; HTTP响应&amp;rdquo;标头指定的另一个URI 。这具有相同的语义 &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP响应代码，不同之处在于用户代理&lt;em&gt;必须不&lt;/em&gt;改变使用的HTTP方法：如果 &lt;code&gt;POST&lt;/code&gt; 是在第一请求中所使用的， &lt;code&gt;POST&lt;/code&gt; 必须在第二请求被使用。</target>
        </trans-unit>
        <trans-unit id="37f8e68ab017e83ab3d110757c8a5ccd4bf55d28" translate="yes" xml:space="preserve">
          <source>This mechanism is always client initiated (with one exception: it's possible for the server to &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;require an upgrade to TLS&lt;/a&gt;), and the server may accept or refuse the switch to the new protocol. This makes it possible to start a connection using a commonly-used protocol, such as HTTP/1.1, then request that the connection switch to HTTP/2 or even to WebSockets.</source>
          <target state="translated">这种机制总是由客户端启动的（一个例外：服务器可能&lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;需要升级到TLS&lt;/a&gt;），并且服务器可以接受或拒绝切换到新协议。这样就可以使用常用协议（例如HTTP / 1.1）启动连接，然后请求将连接切换到HTTP / 2或WebSockets。</target>
        </trans-unit>
        <trans-unit id="6fd8e35050a88061004785e66da5be5ef6c4558f" translate="yes" xml:space="preserve">
          <source>This mechanism is optional; it cannot be used to insist on a protocol change. Implementations can choose not to take advantage of an upgrade even if they support the new protocol, and in practice, this mechanism is used mostly to bootstrap a WebSockets connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930c017a0341cb94a246a09014c32e54c099c6b0" translate="yes" xml:space="preserve">
          <source>This message means that the browser saw the &lt;code&gt;Large-Allocation&lt;/code&gt; header, and was able to reload the page into a new process which should have more available contiguous memory.</source>
          <target state="translated">该消息表示浏览器看到了 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头，并且能够将页面重新加载到应该具有更多可用连续内存的新进程中。</target>
        </trans-unit>
        <trans-unit id="7884c1f5aebded20cacbf12f85bb3629712f95c4" translate="yes" xml:space="preserve">
          <source>This model is the default model used in HTTP/1.0 (if there is no &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header, or if its value is set to &lt;code&gt;close&lt;/code&gt;). In HTTP/1.1, this model is only used when the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header is sent with a value of &lt;code&gt;close&lt;/code&gt;.</source>
          <target state="translated">该模型是HTTP / 1.0中使用的默认模型（如果没有&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头，或者其值设置为 &lt;code&gt;close&lt;/code&gt; ）。在HTTP / 1.1中，仅当发送&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;头的值为 &lt;code&gt;close&lt;/code&gt; 时才使用此模型。</target>
        </trans-unit>
        <trans-unit id="4f8dd381093e02d3c56d8bf2d6a1a2b6d6c9bc23" translate="yes" xml:space="preserve">
          <source>This page is not complete.</source>
          <target state="translated">本页不完整。</target>
        </trans-unit>
        <trans-unit id="2700ae9496ac92696a2d7d32affc7822518ebd17" translate="yes" xml:space="preserve">
          <source>This page was loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">由于&amp;ldquo; &lt;code&gt;Large-Allocation&lt;/code&gt; 标头，此页面已在新流程中加载。</target>
        </trans-unit>
        <trans-unit id="0cac347b43837064b316648d4989da0372112872" translate="yes" xml:space="preserve">
          <source>This page would be loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header, however &lt;code&gt;Large-Allocation&lt;/code&gt; process creation is disabled on non-Win32 platforms.</source>
          <target state="translated">由于&amp;ldquo; &lt;code&gt;Large-Allocation&lt;/code&gt; 标头，此页面将被加载到新进程中，但是在非Win32平台上禁用了&amp;ldquo; &lt;code&gt;Large-Allocation&lt;/code&gt; 进程的创建。</target>
        </trans-unit>
        <trans-unit id="24edd3164f6204b4aeaaef84edccb45a164270bb" translate="yes" xml:space="preserve">
          <source>This pattern of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; headers is the simplest use of the access control protocol. If the resource owners at &lt;code&gt;https://bar.other&lt;/code&gt; wished to restrict access to the resource to requests &lt;em&gt;only&lt;/em&gt; from &lt;code&gt;https://foo.example&lt;/code&gt;, (i.e no domain other than &lt;code&gt;https://foo.example&lt;/code&gt; can access the resource in a cross-site manner) they would send:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bca8347d8092d11755f1e4e5691c56881328bb" translate="yes" xml:space="preserve">
          <source>This performs a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012dc0221186c93aa5f93e94a45c4ed8bd7f1e8a" translate="yes" xml:space="preserve">
          <source>This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">这个策略会将TLS保护的资源的起源和路径泄露给不安全的起源。请仔细考虑此设置的影响。</target>
        </trans-unit>
        <trans-unit id="e32c67984e9c6672ef8d338fdf20280130724f78" translate="yes" xml:space="preserve">
          <source>This policy will leak potentially-private information from HTTPS resource URLs to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777df6e36502c801cccff6604d845d23f1626c6e" translate="yes" xml:space="preserve">
          <source>This prefetching is performed in the background, so that the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; is likely to have been resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.</source>
          <target state="translated">该预取是在后台执行的，因此在需要引用的项目之前，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt;可能已经解析。这样可以减少用户单击链接时的延迟。</target>
        </trans-unit>
        <trans-unit id="322ff44ffffc8c1929757a32b5dd54ce49618142" translate="yes" xml:space="preserve">
          <source>This rapid adoption rate was likely as HTTP/2 does not require adaptation of Web sites and applications: using HTTP/1.1 or HTTP/2 is transparent for them. Having an up-to-date server communicating with a recent browser is enough to enable its use: only a limited set of groups were needed to trigger adoption, and as legacy browser and server versions are renewed, usage has naturally increased, without further Web developer efforts.</source>
          <target state="translated">这种快速的采用率很可能是因为HTTP/2不需要对网站和应用程序进行调整:使用HTTP/1.1或HTTP/2对它们来说是透明的。拥有一个与最新浏览器通信的最新服务器就足以使其使用:只需要一组有限的群体就可以触发采用,而且随着传统的浏览器和服务器版本的更新,使用量自然而然地增加了,而不需要网络开发人员进一步努力。</target>
        </trans-unit>
        <trans-unit id="9bd4e192aba5cf8728bcb7d85247e143a7a701f5" translate="yes" xml:space="preserve">
          <source>This represents an HTML resource whose contents are:</source>
          <target state="translated">这表示一个HTML资源,其内容是:</target>
        </trans-unit>
        <trans-unit id="88b4a61039714ba204509f652a8c7c13f179e1ae" translate="yes" xml:space="preserve">
          <source>This request does not relate to any context like site, origin, or frame. This can happen when user had initiated this request by, e.g. directly entering a URL in the address bar, opening a bookmark, or draging-and-dropping a file into the browser window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1a08d4ddad6242047c3f07fe630aad370f9ebd" translate="yes" xml:space="preserve">
          <source>This response code is no longer used, it is just reserved currently. It was used in a previous version of the HTTP 1.1 specification.</source>
          <target state="translated">这个响应代码已经不再使用,只是目前保留了。它在以前的HTTP 1.1规范版本中使用过。</target>
        </trans-unit>
        <trans-unit id="8d9b5cfc9ffb70c58676155836edb7100932e47c" translate="yes" xml:space="preserve">
          <source>This response code is no longer used; it is just reserved. It was used in a previous version of the HTTP/1.1 specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196c5e3984dee3a01e3d4870bc32fe1976f373ee" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.</source>
          <target state="translated">这个响应代码是为将来使用而保留的。创建此代码的最初目的是将其用于数字支付系统,但目前尚未使用。</target>
        </trans-unit>
        <trans-unit id="2dd19a171f836779710936f505245545bdd2344b" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. The initial aim for creating this code was using it for digital payment systems, however this status code is used very rarely and no standard convention exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17caf511cbbea70b5e359bd60edd742730612bb2" translate="yes" xml:space="preserve">
          <source>This response code is sent after accomplishing request to tell user agent reset document view which sent this request.</source>
          <target state="translated">该响应代码是在完成请求后发送的,用于告诉发送该请求的用户代理重置文档视图。</target>
        </trans-unit>
        <trans-unit id="a6e3073e4af982c8216898b651b8900b118d9707" translate="yes" xml:space="preserve">
          <source>This response code is used because of range header sent by the client to separate download into multiple streams.</source>
          <target state="translated">这个响应代码是由于客户端发送的范围头将下载分成多个流而使用的。</target>
        </trans-unit>
        <trans-unit id="b0b3091267e6eb1f6619e52e3332c6b0eef55bd5" translate="yes" xml:space="preserve">
          <source>This response code is used when the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header is sent from the client to request only part of a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54001a8a74f4230a78d081c9dd427598feb0b64e" translate="yes" xml:space="preserve">
          <source>This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.</source>
          <target state="translated">这个响应代码意味着返回的元信息集与源服务器上的不完全相同,而是从本地或第三方副本中收集的。除此条件外,应首选200 OK响应,而不是此响应。</target>
        </trans-unit>
        <trans-unit id="adaff7b5972a65eef381227188ec9967318ffddd" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. Further changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48afdbe246b4285c52a497fa58e9555d4417761" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="translated">此响应代码表示所请求资源的URI已&lt;em&gt;临时&lt;/em&gt;更改。将来可能会在URI中进行新的更改。因此，客户端应在以后的请求中使用相同的URI。</target>
        </trans-unit>
        <trans-unit id="796776b8f699ee7445564de16ff0f1e7a6734445" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of the requested resource has been changed. Probably, the new URI would be given in the response.</source>
          <target state="translated">这个响应代码意味着请求的资源的URI已经被改变。可能在响应中会给出新的URI。</target>
        </trans-unit>
        <trans-unit id="d31becaff4260704a27003cc76245a28d6fbfe6e" translate="yes" xml:space="preserve">
          <source>This response code means the expectation indicated by the &lt;code&gt;Expect&lt;/code&gt; request header field can't be met by the server.</source>
          <target state="translated">此响应代码表示服务器无法满足&amp;ldquo; &lt;code&gt;Expect&lt;/code&gt; 请求标头&amp;rdquo;字段指示的期望。</target>
        </trans-unit>
        <trans-unit id="f85333520aaa3b92348b920c927ea684bb37f464" translate="yes" xml:space="preserve">
          <source>This response code means the returned meta-information is not exactly the same as is available from the origin server, but is collected from a local or a third-party copy. This is mostly used for mirrors or backups of another resource. Except for that specific case, the &quot;200 OK&quot; response is preferred to this status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276e87f04788008ea8cf8cd65690a3af4d8541d7" translate="yes" xml:space="preserve">
          <source>This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.</source>
          <target state="translated">这个响应是由一些服务器在一个空闲的连接上发送的,甚至在客户端没有任何先前的请求的情况下。这意味着服务器想关闭这个未使用的连接。由于一些浏览器,如Chrome、Firefox 27+或IE9,使用HTTP预连接机制来加快冲浪速度,所以这个响应使用得更多。另外要注意的是,有些服务器只是关闭了连接,而没有发送这个消息。</target>
        </trans-unit>
        <trans-unit id="2c19fa8f26e55768b081e1362d43a2a5e678955c" translate="yes" xml:space="preserve">
          <source>This response is sent when a request conflicts with the current state of the server.</source>
          <target state="translated">当一个请求与服务器的当前状态发生冲突时,就会发送这个响应。</target>
        </trans-unit>
        <trans-unit id="e9b8041c4bfcb3ea983601ee1d46fb89425a8ff6" translate="yes" xml:space="preserve">
          <source>This response is sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c23f72de698fc46f7f3192934a03283e62349b8" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content following the criteria given by the user agent.</source>
          <target state="translated">当Web服务器在执行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;服务器驱动的内容协商后&lt;/a&gt;，没有找到符合用户代理给出的条件的任何内容时，将发送此响应。</target>
        </trans-unit>
        <trans-unit id="f98b7a29dead3c53a44ae4ec7ab268f3fe1c0fc6" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content that conforms to the criteria given by the user agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20edf11481196ba8cc7fb946fd061c712997616b" translate="yes" xml:space="preserve">
          <source>This response is used much more since some browsers, like Chrome, Firefox 27+, and IE9, use HTTP pre-connection mechanisms to speed up surfing.</source>
          <target state="translated">由于一些浏览器,如Chrome、Firefox 27+和IE9,使用HTTP预连接机制来加快冲浪速度,所以这个响应使用得更多。</target>
        </trans-unit>
        <trans-unit id="efe292862f7c79acb9c2cf06d20c3228017f8092" translate="yes" xml:space="preserve">
          <source>This response means that server could not understand the request due to invalid syntax.</source>
          <target state="translated">这个响应意味着服务器由于语法无效而无法理解该请求。</target>
        </trans-unit>
        <trans-unit id="b752e6a7b8c6d84ac6a300b6dfb2535f1b47b8ae" translate="yes" xml:space="preserve">
          <source>This response would be sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="translated">当请求的内容已从服务器上永久删除,且没有转发地址时,将发送此响应。客户端应该删除他们的缓存和资源链接。HTTP规范打算将此状态码用于 &quot;限时、促销服务&quot;。API不应该觉得必须用这个状态码来表示已经删除的资源。</target>
        </trans-unit>
        <trans-unit id="25f3e97dc8e2e8ca7707d926d10342dc166ba356" translate="yes" xml:space="preserve">
          <source>This restriction solves &quot;layout instability&quot; problem caused by providing default dimensions for images whose size is not specified in advance so that image doesn't change size after loading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0cde7eef9a19e7d58639cfa5c60f6f2574ad52" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields for applying preconditions on requests.  &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt; defines
   when the preconditions are applied.  &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; defines the order of
   evaluation when more than one precondition is present.</source>
          <target state="translated">本节定义了HTTP / 1.1标头字段的语法和语义，用于在请求上应用前提条件。 &lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;定义了何时应用前提条件。 &lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;定义了存在多个前提条件时的评估顺序。</target>
        </trans-unit>
        <trans-unit id="84857579e8f4c4b00cf5ec7e227da62c2cbe3299" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields related to caching.</source>
          <target state="translated">本节定义了与缓存相关的HTTP/1.1头域的语法和语义。</target>
        </trans-unit>
        <trans-unit id="0e8dc398bfb18bf438574e9ca86e1a588f2447e3" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of all standard
   HTTP/1.1 header fields. For entity-header fields, both sender and
   recipient refer to either the client or the server, depending on who
   sends and who receives the entity.</source>
          <target state="translated">本节定义了所有标准 HTTP/1.1 头字段的语法和语义。对于实体头字段,发送者和接收者都指客户端或服务器,这取决于谁发送和谁接收实体。</target>
        </trans-unit>
        <trans-unit id="96ccae596f81c60b228fa76095eeb49aec1c38ba" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of header fields
   related to the HTTP authentication framework.</source>
          <target state="translated">本节定义了与HTTP认证框架相关的头字段的语法和语义。</target>
        </trans-unit>
        <trans-unit id="b059e4393c3ed5f02e30040602db1e13b843ebfb" translate="yes" xml:space="preserve">
          <source>This section describes problems that commonly occur when creating and using &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">本节描述了在创建和使用 &lt;code&gt;data&lt;/code&gt; URL 时常见的问题。</target>
        </trans-unit>
        <trans-unit id="cea338a7477f06ca64266e85820b20d68a3f92ae" translate="yes" xml:space="preserve">
          <source>This section describes restrictions on the TLS 1.2 feature set that
   can be used with HTTP/2.  Due to deployment limitations, it might not
   be possible to fail TLS negotiation when these restrictions are not
   met.  An endpoint MAY immediately terminate an HTTP/2 connection that
   does not meet these TLS requirements with a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type INADEQUATE_SECURITY.

   A deployment of HTTP/2 over TLS 1.2 MUST disable compression.  TLS
   compression can lead to the exposure of information that would not
   otherwise be revealed [&lt;a href=&quot;https://tools.ietf.org/html/rfc3749&quot;&gt;RFC3749&lt;/a&gt;].  Generic compression is unnecessary
   since HTTP/2 provides compression features that are more aware of
   context and therefore likely to be more appropriate for use for
   performance, security, or other reasons.

   A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation.  An
   endpoint MUST treat a TLS renegotiation as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  Note that disabling 

   renegotiation can result in long-lived connections becoming unusable
   due to limits on the number of messages the underlying cipher suite
   can encipher.

   An endpoint MAY use renegotiation to provide confidentiality
   protection for client credentials offered in the handshake, but any
   renegotiation MUST occur prior to sending the connection preface.  A
   server SHOULD request a client certificate if it sees a renegotiation
   request immediately after establishing a connection.

   This effectively prevents the use of renegotiation in response to a
   request for a specific protected resource.  A future specification
   might provide a way to support this use case.  Alternatively, a
   server might use an error (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;) of type HTTP_1_1_REQUIRED to
   request the client use a protocol that supports renegotiation.

   Implementations MUST support ephemeral key exchange sizes of at least
   2048 bits for cipher suites that use ephemeral finite field Diffie-
   Hellman (DHE) [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;] and 224 bits for cipher suites that use
   ephemeral elliptic curve Diffie-Hellman (ECDHE) [&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;RFC4492&lt;/a&gt;].  Clients
   MUST accept DHE sizes of up to 4096 bits.  Endpoints MAY treat
   negotiation of key sizes smaller than the lower limits as a
   connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type INADEQUATE_SECURITY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509645587a49cf601fb027d0d0b3f365b9c1a570" translate="yes" xml:space="preserve">
          <source>This section describes the semantics specific to the write lock type.
   The write lock is a specific instance of a lock type, and is the only
   lock type described in this specification.

   An exclusive write lock protects a resource: it prevents changes by
   any principal other than the lock creator and in any case where the
   lock token is not submitted (e.g., by a client process other than the
   one holding the lock).

   Clients MUST submit a lock-token they are authorized to use in any
   request that modifies a write-locked resource.  The list of
   modifications covered by a write-lock include:

   1.  A change to any of the following aspects of any write-locked
       resource:

       *  any variant,

       *  any dead property,

       *  any live property that is lockable (a live property is
          lockable unless otherwise defined.)

   2.  For collections, any modification of an internal member URI.  An
       internal member URI of a collection is considered to be modified
       if it is added, removed, or identifies a different resource.
       More discussion on write locks and collections is found in
       &lt;a href=&quot;#section-7.4&quot;&gt;Section 7.4&lt;/a&gt;.

   3.  A modification of the mapping of the root of the write lock,
       either to another resource or to no resource (e.g., DELETE).

   Of the methods defined in HTTP and WebDAV, PUT, POST, PROPPATCH,
   LOCK, UNLOCK, MOVE, COPY (for the destination resource), DELETE, and
   MKCOL are affected by write locks.  All other HTTP/WebDAV methods
   defined so far -- GET in particular -- function independently of a
   write lock.

   The next few sections describe in more specific terms how write locks
   interact with various operations.</source>
          <target state="translated">本节描述了特定于写锁定类型的语义。写锁是锁类型的特定实例，并且是本规范中描述的唯一锁类型。排他式写锁可以保护资源：它可以防止除锁创建者以外的任何主体进行更改，并且在任何情况下（例如，由持有锁的客户端进程以外的其他客户端进程）不提交锁令牌时，都可以防止更改。客户必须提交他们有权在修改写锁资源的任何请求中使用的锁令牌。写锁涵盖的修改列表包括：1.对任何写锁资源的以下任何方面进行更改：*任何变体，*任何无效属性，*任何可锁定的活动属性（除非另行定义，否则活动属性是可锁定的。）2.对于集合，内部成员URI的任何修改。如果集合的内部成员URI被添加，删除或标识其他资源，则认为该集合的内部成员URI被修改。有关写锁和集合的更多讨论，请参见 &lt;a href=&quot;#section-7.4&quot;&gt;7.4节&lt;/a&gt;。 3.修改写锁定的根到另一个资源或没有资源的映射（例如DELETE）。在HTTP和WebDAV中定义的方法中，PUT，POST，PROPPATCH，LOCK，UNLOCK，MOVE，COPY（用于目标资源），DELETE和MKCOL受写锁定的影响。到目前为止定义的所有其他HTTP / WebDAV方法（特别是GET）的功能独立于写锁。接下来的几节将更具体地描述写锁如何与各种操作交互。</target>
        </trans-unit>
        <trans-unit id="1b8caae975a03a8390b52fa0ed5d2957f9b87b19" translate="yes" xml:space="preserve">
          <source>This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.</source>
          <target state="translated">本节旨在告知应用开发者、信息提供者和用户本文档所描述的HTTP/1.1的安全限制。本节的讨论并不包括对所揭示问题的明确解决方案,尽管它确实提出了一些降低安全风险的建议。</target>
        </trans-unit>
        <trans-unit id="e14dd174357a0e5e555989561acf1df199436583" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns relevant to HTTP semantics and
   its use for transferring information over the Internet.
   Considerations related to message syntax, parsing, and routing are
   discussed in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;Section&amp;nbsp;9 of [RFC7230]&lt;/a&gt;.

   The list of considerations below is not exhaustive.  Most security
   concerns related to HTTP semantics are about securing server-side
   applications (code behind the HTTP interface), securing user agent 

   processing of payloads received via HTTP, or secure use of the
   Internet in general, rather than security of the protocol.  Various
   organizations maintain topical information and links to current
   research on Web application security (e.g., [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]).</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户与HTTP语义有关的已知安全问题及其在Internet上传输信息的用途。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;[RFC7230]的第9节&lt;/a&gt;讨论了与消息语法，解析和路由相关的注意事项。以下注意事项列表并不详尽。与HTTP语义相关的大多数安全问题都与保护服务器端应用程序（HTTP接口后面的代码），保护通过HTTP接收的有效负载的用户代理处理或总体上安全使用Internet而不是协议的安全性有关。各种组织维护主题信息并链接到有关Web应用程序安全性的最新研究（例如[ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ]）。</target>
        </trans-unit>
        <trans-unit id="cc5ec5ca15ce6b7e4d99013caa23973be65f1836" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP authentication.
   More general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Everything about the topic of HTTP authentication is a security
   consideration, so the list of considerations below is not exhaustive.
   Furthermore, it is limited to security considerations regarding the
   authentication framework, in general, rather than discussing all of
   the potential considerations for specific authentication schemes
   (which ought to be documented in the specifications that define those
   schemes).  Various organizations maintain topical information and
   links to current research on Web application security (e.g.,
   [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]), including common pitfalls for implementing and using the
   authentication schemes found in practice.</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户有关HTTP身份验证的已知安全问题。在HTTP消息传递[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]和语义[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 中解决了更一般的安全注意事项。]。关于HTTP身份验证主题的所有内容都是出于安全考虑，因此下面的注意事项列表并不详尽。此外，一般来说，它仅限于关于认证框架的安全性考虑，而不是讨论特定认证方案的所有潜在考虑因素（应在定义那些方案的规范中进行记录）。各种组织维护主题信息并链接到有关Web应用程序安全性的最新研究（例如&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;），包括实施和使用实践中发现的身份验证方案的常见陷阱。</target>
        </trans-unit>
        <trans-unit id="d7b61cbd1c222657e3948d017b4f1b45bdc23901" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP caching.  More
   general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Caches expose additional potential vulnerabilities, since the
   contents of the cache represent an attractive target for malicious
   exploitation.  Because cache contents persist after an HTTP request
   is complete, an attack on the cache can reveal information long after
   a user believes that the information has been removed from the
   network.  Therefore, cache contents need to be protected as sensitive
   information.

   In particular, various attacks might be amplified by being stored in
   a shared cache; such &quot;cache poisoning&quot; attacks use the cache to
   distribute a malicious payload to many clients, and are especially
   effective when an attacker can use implementation flaws, elevated
   privileges, or other techniques to insert such a response into a
   cache.  One common attack vector for cache poisoning is to exploit
   differences in message parsing on proxies and in user agents; see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;Section&amp;nbsp;3.3.3 of [RFC7230]&lt;/a&gt; for the relevant requirements.

   Likewise, implementation flaws (as well as misunderstanding of cache
   operation) might lead to caching of sensitive information (e.g.,
   authentication credentials) that is thought to be private, exposing
   it to unauthorized parties. 

   Furthermore, the very use of a cache can bring about privacy
   concerns.  For example, if two users share a cache, and the first one
   browses to a site, the second may be able to detect that the other
   has been to that site, because the resources from it load more
   quickly, thanks to the cache.

   Note that the Set-Cookie response header field [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] does not
   inhibit caching; a cacheable response with a Set-Cookie header field
   can be (and often is) used to satisfy subsequent requests to caches.
   Servers who wish to control caching of these responses are encouraged
   to emit appropriate Cache-Control response header fields.</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户有关HTTP缓存的已知安全问题。在HTTP消息传递[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]和语义[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 中解决了更一般的安全注意事项。]。缓存会暴露出其他潜在的漏洞，因为缓存的内容代表了诱人的恶意利用目标。由于高速缓存的内容在HTTP请求完成后仍然存在，因此在用户认为信息已从网络中删除之后很长时间，对高速缓存的攻击就会泄露信息。因此，需要将缓存内容作为敏感信息进行保护。特别是，各种攻击可能会通过存储在共享缓存中而被放大。此类&amp;ldquo;缓存中毒&amp;rdquo;攻击使用缓存将恶意有效负载分发给许多客户端，当攻击者可以使用实现缺陷，提升的特权或其他技术将此类响应插入缓存时，这种攻击尤其有效。缓存中毒的一种常见攻击媒介是利用代理和用户代理中的消息解析差异。看到 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;[RFC7230]的3.3.3节介绍&lt;/a&gt;了相关要求。同样，实现缺陷（以及对缓存操作的误解）可能会导致缓存敏感信息（例如，身份验证凭据）被认为是私有的，从而将其暴露给未授权方。此外，仅使用高速缓存会带来隐私问题。例如，如果两个用户共享一个缓存，而第一个用户浏览到一个站点，则第二个用户可能能够检测到另一个用户已经访问了该站点，因为有了该缓存，来自该站点的资源可以更快地加载。请注意，Set-Cookie响应标头字段[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]不禁止缓存；具有Set-Cookie标头字段的可缓存响应可以（并且经常）用于满足对缓存的后续请求。鼓励希望控制这些响应的缓存的服务器发出适当的Cache-Control响应标头字段。</target>
        </trans-unit>
        <trans-unit id="0e335c0656016c7e9ffd0c440c556a3faf33fe1d" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP conditional
   request mechanisms.  More general security considerations are
   addressed in HTTP &quot;Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and
   &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. 

   The validators defined by this specification are not intended to
   ensure the validity of a representation, guard against malicious
   changes, or detect man-in-the-middle attacks.  At best, they enable
   more efficient cache updates and optimistic concurrent writes when
   all participants are behaving nicely.  At worst, the conditions will
   fail and the client will receive a response that is no more harmful
   than an HTTP exchange without conditional requests.

   An entity-tag can be abused in ways that create privacy risks.  For
   example, a site might deliberately construct a semantically invalid
   entity-tag that is unique to the user or user agent, send it in a
   cacheable response with a long freshness time, and then read that
   entity-tag in later conditional requests as a means of re-identifying
   that user or user agent.  Such an identifying tag would become a
   persistent identifier for as long as the user agent retained the
   original cache entry.  User agents that cache representations ought
   to ensure that the cache is cleared or replaced whenever the user
   performs privacy-maintaining actions, such as clearing stored cookies
   or changing to a private browsing mode.</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户特定于HTTP条件请求机制的已知安全问题。HTTP&amp;ldquo;消息语法和路由&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]和&amp;ldquo;语义和内容&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 解决了更多常规安全注意事项。]。本规范定义的验证器并非旨在确保表示的有效性，防止恶意更改或检测中间人攻击。最好的情况是，当所有参与者都表现良好时，它们可以实现更有效的缓存更新和乐观的并发写入。最坏的情况是，条件将失败，并且客户端将收到比没有条件请求的HTTP交换有害的响应。实体标签可能会以造成隐私风险的方式被滥用。例如，某个网站可能故意构造一个用户或用户代理特有的在语义上无效的实体标签，以较长的刷新时间在可缓存的响应中发送该标签，然后在以后的条件请求中读取该实体标签，以重新标识该用户或用户代理。只要用户代理保留了原始缓存条目，这种识别标签就将成为永久性标识符。缓存表示形式的用户代理应确保每当用户执行隐私维护操作（例如清除存储的Cookie或更改为私有浏览模式）时，便清除或替换缓存。</target>
        </trans-unit>
        <trans-unit id="a8b6ada4af46edbc538acb5ee5cd9d1e819c9d08" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP range
   request mechanisms.  More general security considerations are
   addressed in HTTP messaging [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户有关HTTP范围请求机制的已知安全问题。在HTTP消息传递[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]和语义[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 中解决了更一般的安全注意事项。</target>
        </trans-unit>
        <trans-unit id="20f34b6144b38a6c6e8c314d3b99c718e19c16cf" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security considerations relevant to HTTP message
   syntax, parsing, and routing.  Security considerations about HTTP
   semantics and payloads are addressed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">本部分旨在向开发人员，信息提供者和用户通知与HTTP消息语法，解析和路由相关的已知安全注意事项。有关HTTP语义和有效负载的安全性注意事项，请参见[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="6807589d15db566935fa0b36f3c986f0dcb8f1e1" translate="yes" xml:space="preserve">
          <source>This section is provided to detail issues concerning security
   implications of which WebDAV applications need to be aware.

   All of the security considerations of HTTP/1.1 (discussed in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]) and XML (discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]) also apply to WebDAV.  In
   addition, the security risks inherent in remote authoring require
   stronger authentication technology, introduce several new privacy
   concerns, and may increase the hazards from poor server design.
   These issues are detailed below.</source>
          <target state="translated">提供本节的内容是为了详细说明有关WebDAV应用程序需要注意的安全隐患的问题。 HTTP / 1.1（在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中讨论）和XML（在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]中讨论）的所有安全考虑因素也适用于WebDAV。此外，远程创作固有的安全风险需要更强大的身份验证技术，引入了一些新的隐私问题，并可能增加不良的服务器设计带来的危害。这些问题在下面详细介绍。</target>
        </trans-unit>
        <trans-unit id="b6f1686ad83954bc21d87d0b2feab0950aa7dc14" translate="yes" xml:space="preserve">
          <source>This section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers using cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; capability do not have to set any cross-origin sharing request headers programmatically.</source>
          <target state="translated">本节列出了客户端在发出HTTP请求时可以使用的标头，以利用跨域共享功能。请注意，在调用服务器时会为您设置这些标头。使用跨站点&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;功能的开发人员不必以编程方式设置任何跨域共享请求标头。</target>
        </trans-unit>
        <trans-unit id="2596221fd857bbcaea04d0cd1a4ea6fd1d357430" translate="yes" xml:space="preserve">
          <source>This section lists major changes between this document and &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;,
   starting with those that are likely to result in implementation
   changes.  Servers will advertise support for all changes in this
   specification by returning the compliance class &quot;3&quot; in the DAV
   response header (see Sections &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; and &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;).</source>
          <target state="translated">本节列出了本文档与&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;之间的主要更改，从可能导致实现更改的内容开始。服务器将通过在DAV响应标头中返回符合性类&amp;ldquo; 3&amp;rdquo;来公布对本规范中所有更改的支持（请参见&lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;和&lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="fd619925c99ba3f120ebdc079103c35edf44f771" translate="yes" xml:space="preserve">
          <source>This section lists the HTTP response headers that servers send back for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.</source>
          <target state="translated">本节列出了跨源资源共享规范所定义的服务器为访问控制请求发回的HTTP响应头。上一节概述了这些内容的作用。</target>
        </trans-unit>
        <trans-unit id="27698771798e35901c64b1cc865da252efad8115" translate="yes" xml:space="preserve">
          <source>This section outlines attributes of the HTTP protocol that improve
   interoperability, reduce exposure to known security vulnerabilities,
   or reduce the potential for implementation variation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256b3572a114f6830fdfb27c4527ad2a42aa41b3" translate="yes" xml:space="preserve">
          <source>This section provides a concise model for how locking behaves.  Later
   sections will provide more detail on some of the concepts and refer
   back to these model statements.  Normative statements related to LOCK
   and UNLOCK method handling can be found in the sections on those
   methods, whereas normative statements that cover any method are
   gathered here.

   1.  A lock either directly or indirectly locks a resource.

   2.  A resource becomes directly locked when a LOCK request to a URL
       of that resource creates a new lock.  The &quot;lock-root&quot; of the new
       lock is that URL.  If at the time of the request, the URL is not
       mapped to a resource, a new empty resource is created and
       directly locked.

   3.  An exclusive lock (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;) conflicts with any other kind of
       lock on the same resource, whether either lock is direct or
       indirect.  A server MUST NOT create conflicting locks on a
       resource.

   4.  For a collection that is locked with a depth-infinity lock L, all
       member resources are indirectly locked.  Changes in membership of
       such a collection affect the set of indirectly locked resources:

       *  If a member resource is added to the collection, the new
          member resource MUST NOT already have a conflicting lock,
          because the new resource MUST become indirectly locked by L.

       *  If a member resource stops being a member of the collection,
          then the resource MUST no longer be indirectly locked by L.

   5.  Each lock is identified by a single globally unique lock token
       (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;).

   6.  An UNLOCK request deletes the lock with the specified lock token.
       After a lock is deleted, no resource is locked by that lock.

   7.  A lock token is &quot;submitted&quot; in a request when it appears in an
       &quot;If&quot; header (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;, &quot;Write Lock&quot;, discusses when token
       submission is required for write locks).

   8.  If a request causes the lock-root of any lock to become an
       unmapped URL, then the lock MUST also be deleted by that request.</source>
          <target state="translated">本节提供了有关锁定行为的简洁模型。后面的部分将提供有关某些概念的更多详细信息，并返回参考这些模型语句。与LOCK和UNLOCK方法处理相关的规范性语句可以在关于这些方法的部分中找到，而涵盖所有方法的规范性语句均在此处收集。 1.锁直接或间接锁定资源。 2.当对资源的URL的LOCK请求创建新的锁定时，资源将直接锁定。新锁的&amp;ldquo;锁根&amp;rdquo;是该URL。如果在请求时URL没有映射到资源，则创建一个新的空资源并将其直接锁定。 3.排他锁（&lt;a href=&quot;#section-6.2&quot;&gt;第6.2节&lt;/a&gt;）与同一资源上的任何其他类型的锁（无论是直接锁还是间接锁）冲突。服务器不得在资源上创建冲突的锁。 4.对于使用深度无限锁L锁定的集合，所有成员资源都被间接锁定。此类集合的成员资格更改会影响间接锁定资源的集合：*如果将成员资源添加到集合中，则新成员资源不得已经具有冲突的锁，因为新资源必须被L间接锁定。如果成员资源不再是集合的成员，则该资源必须不再被L间接锁定。5.每个锁定都由单个全局唯一的锁定令牌（&lt;a href=&quot;#section-6.5&quot;&gt;6.5节&lt;/a&gt;）。 6. UNLOCK请求删除具有指定锁令牌的锁。删除锁后，该锁不会锁定任何资源。 7.当请求中出现&amp;ldquo;如果&amp;rdquo;标头时，请求中将&amp;ldquo;提交&amp;rdquo;锁令牌（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt; &amp;ldquo;写锁&amp;rdquo;讨论写锁何时需要提交令牌）。 8.如果一个请求导致任何锁的锁根变成未映射的URL，则该锁也必须被该请求删除。</target>
        </trans-unit>
        <trans-unit id="b4b255e71c5acf2b758f6ac1313183b4a6e6c569" translate="yes" xml:space="preserve">
          <source>This section provides a description of a type of Web resource, the
   collection, and discusses its interactions with the HTTP URL
   namespace and with HTTP methods.  The purpose of a collection
   resource is to model collection-like objects (e.g., file system
   directories) within a server's namespace. 

   All DAV-compliant resources MUST support the HTTP URL namespace model
   specified herein.</source>
          <target state="translated">本节提供了对Web资源的一种类型--集合的描述,并讨论了它与HTTP URL命名空间和与HTTP方法的交互。集合资源的目的是在服务器的命名空间中模拟类似集合的对象(例如,文件系统目录)。所有符合DAV的资源都必须支持这里指定的HTTP URL命名空间模型。</target>
        </trans-unit>
        <trans-unit id="41f24be581ad6f64eda1b3a4bd3c9c3eed891392" translate="yes" xml:space="preserve">
          <source>This section provides examples of some common security policy scenarios.</source>
          <target state="translated">本节提供了一些常见的安全策略场景的例子。</target>
        </trans-unit>
        <trans-unit id="791632f4a575a961d693dba3896ef6d189e33a10" translate="yes" xml:space="preserve">
          <source>This section registers the &quot;PRI&quot; method in the &quot;HTTP Method Registry&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.1&quot;&gt;[RFC7231], Section&amp;nbsp;8.1&lt;/a&gt;).

   Method Name:  PRI

   Safe:  Yes

   Idempotent:  Yes

   Specification document(s):  &lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt; of this document

   Related information:  This method is never used by an actual client.
      This method will appear to be used when an HTTP/1.1 server or
      intermediary attempts to parse an HTTP/2 connection preface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8a15caa0998b07cccc63db3b596341d80032d0" translate="yes" xml:space="preserve">
          <source>This section registers the HTTP2-Settings header field in the
   &quot;Permanent Message Header Field Names&quot; registry [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Header field name:  HTTP2-Settings

   Applicable protocol:  http

   Status:  standard

   Author/Change controller:  IETF 

   Specification document(s):  &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt; of this document

   Related information:  This header field is only used by an HTTP/2
      client for Upgrade-based negotiation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ae1108ba21e7623f0028b8a84ebb3b288cc03e" translate="yes" xml:space="preserve">
          <source>This section shows HTTP/1.1 requests and responses, with
   illustrations of equivalent HTTP/2 requests and responses.

   An HTTP GET request includes request header fields and no payload
   body and is therefore transmitted as a single HEADERS frame, followed
   by zero or more CONTINUATION frames containing the serialized block
   of request header fields.  The HEADERS frame in the following has
   both the END_HEADERS and END_STREAM flags set; no CONTINUATION frames
   are sent.

     GET /resource HTTP/1.1           HEADERS
     Host: example.org          ==&amp;gt;     + END_STREAM
     Accept: image/jpeg                 + END_HEADERS
                                          :method = GET
                                          :scheme = https
                                          :path = /resource
                                          host = example.org
                                          accept = image/jpeg 

   Similarly, a response that includes only response header fields is
   transmitted as a HEADERS frame (again, followed by zero or more
   CONTINUATION frames) containing the serialized block of response
   header fields.

     HTTP/1.1 304 Not Modified        HEADERS
     ETag: &quot;xyzzy&quot;              ==&amp;gt;     + END_STREAM
     Expires: Thu, 23 Jan ...           + END_HEADERS
                                          :status = 304
                                          etag = &quot;xyzzy&quot;
                                          expires = Thu, 23 Jan 

   An HTTP POST request that includes request header fields and payload
   data is transmitted as one HEADERS frame, followed by zero or more
   CONTINUATION frames containing the request header fields, followed by
   one or more DATA frames, with the last CONTINUATION (or HEADERS)
   frame having the END_HEADERS flag set and the final DATA frame having
   the END_STREAM flag set:

     POST /resource HTTP/1.1          HEADERS
     Host: example.org          ==&amp;gt;     - END_STREAM
     Content-Type: image/jpeg           - END_HEADERS
     Content-Length: 123                  :method = POST
                                          :path = /resource
     {binary data}                        :scheme = https

                                      CONTINUATION
                                        + END_HEADERS
                                          content-type = image/jpeg
                                          host = example.org
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}

   Note that data contributing to any given header field could be spread
   between header block fragments.  The allocation of header fields to
   frames in this example is illustrative only.

   A response that includes header fields and payload data is
   transmitted as a HEADERS frame, followed by zero or more CONTINUATION
   frames, followed by one or more DATA frames, with the last DATA frame
   in the sequence having the END_STREAM flag set: 

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==&amp;gt;     - END_STREAM
     Content-Length: 123                + END_HEADERS
                                          :status = 200
     {binary data}                        content-type = image/jpeg
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}

   An informational response using a 1xx status code other than 101 is
   transmitted as a HEADERS frame, followed by zero or more CONTINUATION
   frames.

   Trailing header fields are sent as a header block after both the
   request or response header block and all the DATA frames have been
   sent.  The HEADERS frame starting the trailers header block has the
   END_STREAM flag set.

   The following example includes both a 100 (Continue) status code,
   which is sent in response to a request containing a &quot;100-continue&quot;
   token in the Expect header field, and trailing header fields:

     HTTP/1.1 100 Continue            HEADERS
     Extension-Field: bar       ==&amp;gt;     - END_STREAM
                                        + END_HEADERS
                                          :status = 100
                                          extension-field = bar

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==&amp;gt;     - END_STREAM
     Transfer-Encoding: chunked         + END_HEADERS
     Trailer: Foo                         :status = 200
                                          content-length = 123
     123                                  content-type = image/jpeg
     {binary data}                        trailer = Foo
     0
     Foo: bar                         DATA
                                        - END_STREAM
                                      {binary data}

                                      HEADERS
                                        + END_STREAM
                                        + END_HEADERS
                                          foo = bar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdc290f371b09817d92044b4802c7dcaa78a48b" translate="yes" xml:space="preserve">
          <source>This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.</source>
          <target state="translated">本节总结了HTTP/1.0和HTTP/1.1版本之间的主要区别。</target>
        </trans-unit>
        <trans-unit id="ff966b2d60be3de0767cef83a4ad73d50f777ddf" translate="yes" xml:space="preserve">
          <source>This section, as with similar sections for other methods, provides
   some guidance on error codes and preconditions or postconditions
   (defined in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) that might be particularly useful with
   PROPFIND.

   403 Forbidden - A server MAY reject PROPFIND requests on collections
   with depth header of &quot;Infinity&quot;, in which case it SHOULD use this
   error with the precondition code 'propfind-finite-depth' inside the
   error body.</source>
          <target state="translated">本节与其他方法的类似部分一样，提供了有关错误代码以及前置条件或后置条件（在&lt;a href=&quot;#section-16&quot;&gt;第16节中&lt;/a&gt;定义）的一些指导，这些指导可能对PROPFIND尤其有用。403禁止-服务器可以拒绝深度标头为&amp;ldquo; Infinity&amp;rdquo;的集合上的PROPFIND请求，在这种情况下，服务器应在错误体内使用带有前提条件代码&amp;ldquo; propfind-depth-depth&amp;rdquo;的错误。</target>
        </trans-unit>
        <trans-unit id="ee00e4e33c5031393996d9cbbb32237668a87ffc" translate="yes" xml:space="preserve">
          <source>This shows the server sending headers to tell the client to store a pair of cookies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639667e8ad5d2c48599430916aed509755cbbadd" translate="yes" xml:space="preserve">
          <source>This simple HTML file will be saved as a regular download rather than displayed in the browser. Most browsers will propose to save it under the &lt;code&gt;cool.html&lt;/code&gt; filename (by default).</source>
          <target state="translated">这个简单的HTML文件将被保存为常规下载文件，而不是显示在浏览器中。大多数浏览器建议将其保存在 &lt;code&gt;cool.html&lt;/code&gt; 文件名下（默认情况下）。</target>
        </trans-unit>
        <trans-unit id="1c7309d7bb5ffc950761c7540724deee943ec907" translate="yes" xml:space="preserve">
          <source>This simple model held an innate limitation on performance: opening each TCP connection is a resource-consuming operation. Several messages must be exchanged between the client and the server. Network latency and bandwidth affect performance when a request needs sending. Modern Web pages require many requests (a dozen or more) to serve the amount of information needed, proving this earlier model inefficient.</source>
          <target state="translated">这个简单的模型对性能有一个先天的限制:打开每个TCP连接都是一个耗费资源的操作。客户端和服务器之间必须交换几个消息。当一个请求需要发送时,网络延迟和带宽会影响性能。现代网页需要许多请求(十几个或更多)才能提供所需的信息量,证明这种早期的模型效率低下。</target>
        </trans-unit>
        <trans-unit id="484f69d86199a4745f12e506b1b55024069115fc" translate="yes" xml:space="preserve">
          <source>This solution is more efficient, but slightly less flexible, as only one etag can be used in the condition. Rarely is such additional flexibility needed.</source>
          <target state="translated">这种解决方案效率较高,但灵活性稍差,因为条件中只能使用一个etag。很少需要这种额外的灵活性。</target>
        </trans-unit>
        <trans-unit id="01774d0c8108df34d3eb470ca203ddd51442235b" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit&quot; to the Atom Registry of Link
   Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  The value of &quot;edit&quot;
   specifies that the value of the href attribute is the IRI of an
   editable Member Entry.  When appearing within an atom:entry, the href
   IRI can be used to retrieve, update, and delete the Resource
   represented by that Entry.  An atom:entry MUST NOT contain more than
   one &quot;edit&quot; link relation.</source>
          <target state="translated">该规范在链接关系的Atom注册中心添加值&amp;ldquo; edit&amp;rdquo;（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287]的7.1节&lt;/a&gt;）。&amp;ldquo; edit&amp;rdquo;的值指定href属性的值是可编辑成员条目的IRI。当出现在atom：entry中时，href IRI可用于检索，更新和删除该Entry表示的资源。一个atom：entry不得包含多个&amp;ldquo; edit&amp;rdquo;链接关系。</target>
        </trans-unit>
        <trans-unit id="87fe0975464508a17f30a33c7f745b43a75fae60" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit-media&quot; to the Atom Registry
   of Link Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  When appearing
   within an atom:entry, the value of the href attribute is an IRI that
   can be used to modify a Media Resource associated with that Entry.

   An atom:entry element MAY contain zero or more &quot;edit-media&quot; link
   relations.  An atom:entry MUST NOT contain more than one atom:link
   element with a &quot;rel&quot; attribute value of &quot;edit-media&quot; that has the
   same &quot;type&quot; and &quot;hreflang&quot; attribute values.  All &quot;edit-media&quot; link
   relations in the same Entry reference the same Resource.  If a client
   encounters multiple &quot;edit-media&quot; link relations in an Entry then it
   SHOULD choose a link based on the client preferences for &quot;type&quot; and
   &quot;hreflang&quot;.  If a client encounters multiple &quot;edit-media&quot; link
   relations in an Entry and has no preference based on the &quot;type&quot; and
   &quot;hreflang&quot; attributes then the client SHOULD pick the first &quot;edit-
   media&quot; link relation in document order.</source>
          <target state="translated">该规范将值&amp;ldquo; edit-media&amp;rdquo;添加到链接关系的Atom注册中心（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287]的7.1节）&lt;/a&gt;）。当出现在atom：entry中时，href属性的值是一个IRI，可用于修改与该Entry关联的媒体资源。一个atom：entry元素可以包含零个或多个&amp;ldquo; edit-media&amp;rdquo;链接关系。一个atom：entry不得包含一个以上的atom：link元素，这些元素的&amp;ldquo; rel&amp;rdquo;属性值为&amp;ldquo; edit-media&amp;rdquo;，具有相同的&amp;ldquo; type&amp;rdquo;和&amp;ldquo; hreflang&amp;rdquo;属性。同一条目中的所有&amp;ldquo;编辑媒体&amp;rdquo;链接关系都引用相同的资源。如果一个客户在一个条目中遇到多个&amp;ldquo;编辑媒体&amp;rdquo;链接关系，那么它应该根据客户对&amp;ldquo;类型&amp;rdquo;和&amp;ldquo; hreflang&amp;rdquo;的偏好选择一个链接。如果客户遇到多个&amp;ldquo;编辑媒体&amp;rdquo;条目中的链接关系，并且没有基于&amp;ldquo;类型&amp;rdquo;和&amp;ldquo; hreflang&amp;rdquo;属性的首选项，则客户端应按文档顺序选择第一个&amp;ldquo;编辑媒体&amp;rdquo;链接关系。</target>
        </trans-unit>
        <trans-unit id="b2a53f987b042cdfef40437d4b21f1000736b54d" translate="yes" xml:space="preserve">
          <source>This specification defines a new &quot;type&quot; parameter for use with the
   &quot;application/atom+xml&quot; media type.  The &quot;type&quot; parameter has a value
   of &quot;entry&quot; or &quot;feed&quot;.

   Neither the parameter name nor its value are case sensitive. 

   The value &quot;entry&quot; indicates that the media type identifies an Atom
   Entry Document.  The root element of the document MUST be atom:entry.

   The value &quot;feed&quot; indicates that the media type identifies an Atom
   Feed Document.  The root element of the document MUST be atom:feed.

   If not specified, the type is assumed to be unspecified, requiring
   Atom processors to examine the root element to determine the type of
   Atom document.</source>
          <target state="translated">本规范定义了一个新的 &quot;类型 &quot;参数,用于 &quot;application/atom+xml &quot;媒体类型。类型 &quot;参数的值为 &quot;entry &quot;或 &quot;feed&quot;。参数名和其值都不区分大小写。值 &quot;entry &quot;表示该媒体类型标识一个Atom条目文档。文档的根元素必须是atom:entry。值 &quot;feed &quot;表示该媒体类型标识一个 Atom Feed Document。文档的根元素必须是 atom:feed。如果没有指定,则假定类型是未指定的,需要Atom处理器检查根元素以确定Atom文档的类型。</target>
        </trans-unit>
        <trans-unit id="f81e275d5b5e2405f6e31db20010a4f63cffd1c9" translate="yes" xml:space="preserve">
          <source>This specification defines a number of frame types, each identified
   by a unique 8-bit type code.  Each frame type serves a distinct
   purpose in the establishment and management either of the connection
   as a whole or of individual streams.

   The transmission of specific frame types can alter the state of a
   connection.  If endpoints fail to maintain a synchronized view of the
   connection state, successful communication within the connection will
   no longer be possible.  Therefore, it is important that endpoints
   have a shared comprehension of how the state is affected by the use
   any given frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978449461dd375d2f22dc902ad77e42eee391e36" translate="yes" xml:space="preserve">
          <source>This specification defines an Atom Format Structured Extension, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;, for publishing control within the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace.</source>
          <target state="translated">该规范定义了&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]第6节中&lt;/a&gt;定义的Atom格式结构化扩展，用于在&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;rdquo;命名空间内发布控件。</target>
        </trans-unit>
        <trans-unit id="91a1e7bdc7ea038fc4979f4ad8ada34b2e46af01" translate="yes" xml:space="preserve">
          <source>This specification defines the HTTP status codes

   o  207 Multi-Status (&lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;)

   o  422 Unprocessable Entity (&lt;a href=&quot;#section-11.2&quot;&gt;Section 11.2&lt;/a&gt;),

   o  423 Locked (&lt;a href=&quot;#section-11.3&quot;&gt;Section 11.3&lt;/a&gt;),

   o  424 Failed Dependency (&lt;a href=&quot;#section-11.4&quot;&gt;Section 11.4&lt;/a&gt;) and

   o  507 Insufficient Storage (&lt;a href=&quot;#section-11.5&quot;&gt;Section 11.5&lt;/a&gt;),

   to be updated in the registry at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   Note: the HTTP status code 102 (Processing) has been removed in this
   specification; its IANA registration should continue to reference &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;.</source>
          <target state="translated">该规范定义了HTTP状态代码o 207多状态（&lt;a href=&quot;#section-11.1&quot;&gt;第11.1节&lt;/a&gt;）o 422不可处理实体（&lt;a href=&quot;#section-11.2&quot;&gt;第11.2节&lt;/a&gt;），o 423锁定（&lt;a href=&quot;#section-11.3&quot;&gt;第11.3节&lt;/a&gt;），o 424依赖关系失败（&lt;a href=&quot;#section-11.4&quot;&gt;第11.4节&lt;/a&gt;）和o 507存储不足（&lt;a href=&quot;#section-11.5&quot;&gt;第11.5节&lt;/a&gt;） ，可在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 的注册表中进行更新。注意：在此规范中，HTTP状态代码102（正在处理）已被删除；其IANA注册应继续参考&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e1fe7c5f8c6eb66628d934996aa12f9c804ee43" translate="yes" xml:space="preserve">
          <source>This specification defines two URI schemes:

   1.  the &quot;opaquelocktoken&quot; scheme defined in &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;, and

   2.  the &quot;DAV&quot; URI scheme, which historically was used in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] to
       disambiguate WebDAV property and XML element names and which
       continues to be used for that purpose in this specification and
       others extending WebDAV.  Creation of identifiers in the &quot;DAV:&quot;
       namespace is controlled by the IETF.

   Note that defining new URI schemes for XML namespaces is now
   discouraged.  &quot;DAV:&quot; was defined before standard best practices
   emerged.</source>
          <target state="translated">该规范定义了两个URI方案：1. &lt;a href=&quot;#appendix-C&quot;&gt;附录C中&lt;/a&gt;定义的&amp;ldquo; opaquelocktoken&amp;rdquo;方案，以及2.&amp;ldquo; DAV&amp;rdquo; URI方案，该方案在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ]中曾用于消除WebDAV属性和XML元素名称的歧义，并且继续使用在本规范和其他扩展WebDAV中用于该目的。在&amp;ldquo; DAV：&amp;rdquo;命名空间中标识符的创建由IETF控制。请注意，现在不建议为XML名称空间定义新的URI方案。在标准最佳实践出现之前就定义了&amp;ldquo; DAV：&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="21623dc11b6c2f043255281513da10df5c7cbec3" translate="yes" xml:space="preserve">
          <source>This specification defines two forms of metadata that are commonly
   used to observe resource state and test for preconditions:
   modification dates (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;) and opaque entity tags
   (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;).  Additional metadata that reflects resource state has
   been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning (WebDAV, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt;]), that are beyond the
   scope of this specification.  A resource metadata value is referred
   to as a &quot;validator&quot; when it is used within a precondition.</source>
          <target state="translated">本规范定义了两种常用于观察资源状态和测试前提条件的元数据形式：修改日期（&lt;a href=&quot;#section-2.2&quot;&gt;第2.2节&lt;/a&gt;）和不透明的实体标签（&lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt;）。 HTTP的各种扩展定义了反映资源状态的其他元数据，例如Web分布式创作和版本控制（WebDAV，[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt; ]），这些扩展超出了本规范的范围。当在前提条件中使用资源元数据值时，将其称为&amp;ldquo;验证器&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="187fe63d0c83c4fa38b37175ce98332747f01af0" translate="yes" xml:space="preserve">
          <source>This specification defines two kinds of documents -- Category
   Documents and Service Documents.

   A Category Document (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) contains lists of categories
   specified using the &quot;atom:category&quot; element from the Atom Syndication
   Format (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC4287]&lt;/a&gt;).

   A Service Document (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) groups available Collections into
   Workspaces.

   The namespace name [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;] for either kind of document is:

       &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;

   Atom Publishing Protocol XML Documents MUST be &quot;namespace-well-
   formed&quot; as specified in Section 7 of [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;].

   This specification uses the prefix &quot;app:&quot; for the namespace name.
   The prefix &quot;atom:&quot; is used for &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;, the
   namespace name of the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  These
   namespace prefixes are not semantically significant.

   This specification does not define any DTDs for Atom Protocol
   formats, and hence does not require them to be &quot;valid&quot; in the sense
   used by [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">本规范定义了两种文档-类别文档和服务文档。类别文档（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）包含使用Atom联合组织格式中的&amp;ldquo; atom：category&amp;rdquo;元素指定的类别列表（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;[RFC4287]的第4.2.2节&lt;/a&gt;）。服务文档（&lt;a href=&quot;#section-8&quot;&gt;第8节&lt;/a&gt;）将可用的集合归为工作区。任一种文档&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;的名称&lt;/a&gt;空间名称[ REC-xml-names ]都是：&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http&lt;/a&gt; : //www.w3.org/2007/app Atom发布协议XML文档必须按照第7章第7节的规定进行&amp;ldquo;命名空间格式&amp;rdquo;的定义。 [ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-名称&lt;/a&gt;]。本规范使用前缀&amp;ldquo; app：&amp;rdquo;作为名称空间名称。前缀&amp;ldquo; atom：&amp;rdquo;用于&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &amp;rdquo;，这是Atom联合组织格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 的名称空间名称。这些名称空间前缀在语义上并不重要。该规范没有为Atom协议格式定义任何DTD，因此从[ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] 使用的意义上讲，它们并不要求它们&amp;ldquo;有效&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="6f49469a7f998d6aa7fb1c171080afd01320be81" translate="yes" xml:space="preserve">
          <source>This specification does not define the behavior of the PUT method for
   existing collections.  A PUT request to an existing collection MAY be
   treated as an error (405 Method Not Allowed).

   The MKCOL method is defined to create collections.</source>
          <target state="translated">本规范没有定义现有集合的PUT方法的行为。对现有集合的PUT请求可能会被视为错误(405 Method Not Allowed)。MKCOL方法被定义为创建集合。</target>
        </trans-unit>
        <trans-unit id="d7d3f4f1fc7a5db64d2f982f26f4448b11b753a7" translate="yes" xml:space="preserve">
          <source>This specification encourages the use of &quot;A Universally Unique
   Identifier (UUID) URN Namespace&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]) for lock tokens
   (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), in order to guarantee their uniqueness across space
   and time.  Version 1 UUIDs (defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) MAY contain a
   &quot;node&quot; field that &quot;consists of an IEEE 802 MAC address, usually the
   host address.  For systems with multiple IEEE addresses, any
   available one can be used&quot;.  Since a WebDAV server will issue many
   locks over its lifetime, the implication is that it may also be
   publicly exposing its IEEE 802 address.

   There are several risks associated with exposure of IEEE 802
   addresses.  Using the IEEE 802 address:

   o  It is possible to track the movement of hardware from subnet to
      subnet.

   o  It may be possible to identify the manufacturer of the hardware
      running a WebDAV server.

   o  It may be possible to determine the number of each type of
      computer running WebDAV.

   This risk only applies to host-address-based UUID versions.  &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;4 of [RFC4122]&lt;/a&gt; describes several other mechanisms for generating
   UUIDs that do not involve the host address and therefore do not
   suffer from this risk.</source>
          <target state="translated">本规范鼓励对锁令牌（&lt;a href=&quot;#section-6.5&quot;&gt;第6.5节&lt;/a&gt;）使用&amp;ldquo;通用唯一标识符（UUID）URN命名空间&amp;rdquo;（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt; ]），以确保其在空间和时间上的唯一性。版本1 UUID（在&lt;a href=&quot;#section-4&quot;&gt;第4节中&lt;/a&gt;定义））可以包含一个&amp;ldquo;节点&amp;rdquo;字段，该字段&amp;ldquo;由IEEE 802 MAC地址（通常是主机地址）组成。对于具有多个IEEE地址的系统，可以使用任何可用的地址&amp;rdquo;。由于WebDAV服务器将在其整个生命周期内发出许多锁，因此，这意味着它也可能公开公开其IEEE 802地址。与IEEE 802地址的公开存在若干风险。使用IEEE 802地址：o可以跟踪硬件在子网之间的移动。 o可以确定运行WebDAV服务器的硬件的制造商。 o可以确定运行WebDAV的每种计算机的数量。此风险仅适用于基于主机地址的UUID版本。 &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;[RFC4122]的&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;第&lt;/a&gt;4 节描述了其他几种生成UUID的机制，这些机制不涉及主机地址，因此不会遭受这种风险。</target>
        </trans-unit>
        <trans-unit id="37eee64d4bf2bb8f0591eb5fc58512e72f0c0858" translate="yes" xml:space="preserve">
          <source>This specification has been carefully audited to correct and
   disambiguate key word usage; &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; had many problems in respect to
   the conventions laid out in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   Clarified which error code should be used for inbound server failures
   (e.g. DNS failures). (&lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;). 

   CREATE had a race that required an Etag be sent when a resource is
   first created. (&lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;).

   Content-Base was deleted from the specification: it was not
   implemented widely, and there is no simple, safe way to introduce it
   without a robust extension mechanism. In addition, it is used in a
   similar, but not identical fashion in MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;].

   Transfer-coding and message lengths all interact in ways that
   required fixing exactly when chunked encoding is used (to allow for
   transfer encoding that may not be self delimiting); it was important
   to straighten out exactly how message lengths are computed. (Sections
   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)

   A content-coding of &quot;identity&quot; was introduced, to solve problems
   discovered in caching. (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;)

   Quality Values of zero should indicate that &quot;I don't want something&quot;
   to allow clients to refuse a representation. (&lt;a href=&quot;#section-3.9&quot;&gt;Section 3.9&lt;/a&gt;)

   The use and interpretation of HTTP version numbers has been clarified
   by &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;. Require proxies to upgrade requests to highest protocol
   version they support to deal with problems discovered in HTTP/1.0
   implementations (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   Charset wildcarding is introduced to avoid explosion of character set
   names in accept headers. (&lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;)

   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage
   was introduced to add this missing case. (Sections &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;, &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;, &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;,
   14.9.3)

   The Cache-Control: max-age directive was not properly defined for
   responses. (&lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;)

   There are situations where a server (especially a proxy) does not
   know the full length of a response but is capable of serving a
   byterange request. We therefore need a mechanism to allow byteranges
   with a content-range not indicating the full length of the message.
   (&lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;)

   Range request responses would become very verbose if all meta-data
   were always returned; by allowing the server to only send needed
   headers in a 206 response, this problem can be avoided. (&lt;a href=&quot;#section-10.2.7&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3, and 14.27) 

   Fix problem with unsatisfiable range requests; there are two cases:
   syntactic problems, and range doesn't exist in the document. The 416
   status code was needed to resolve this ambiguity needed to indicate
   an error for a byte range request that falls outside of the actual
   contents of a document. (&lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;, 14.16)

   Rewrite of message transmission requirements to make it much harder
   for implementors to get it wrong, as the consequences of errors here
   can have significant impact on the Internet, and to deal with the
   following problems:

      1. Changing &quot;HTTP/1.1 or later&quot; to &quot;HTTP/1.1&quot;, in contexts where
         this was incorrectly placing a requirement on the behavior of
         an implementation of a future version of HTTP/1.x

      2. Made it clear that user-agents should retry requests, not
         &quot;clients&quot; in general.

      3. Converted requirements for clients to ignore unexpected 100
         (Continue) responses, and for proxies to forward 100 responses,
         into a general requirement for 1xx responses.

      4. Modified some TCP-specific language, to make it clearer that
         non-TCP transports are possible for HTTP.

      5. Require that the origin server MUST NOT wait for the request
         body before it sends a required 100 (Continue) response.

      6. Allow, rather than require, a server to omit 100 (Continue) if
         it has already seen some of the request body.

      7. Allow servers to defend against denial-of-service attacks and
         broken clients.

   This change adds the Expect header and 417 status code. The message
   transmission requirements fixes are in sections &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;,
   8.1.2.2, 13.11, and 14.20.

   Proxies should be able to add Content-Length when appropriate.
   (&lt;a href=&quot;#section-13.5.2&quot;&gt;Section 13.5.2&lt;/a&gt;)

   Clean up confusion between 403 and 404 responses. (&lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;,
   10.4.5, and 10.4.11)

   Warnings could be cached incorrectly, or not updated appropriately.
   (&lt;a href=&quot;#section-13.1.2&quot;&gt;Section 13.1.2&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning
   also needed to be a general header, as PUT or other methods may have
   need for it in requests. 

   Transfer-coding had significant problems, particularly with
   interactions with chunked encoding. The solution is that transfer-
   codings become as full fledged as content-codings. This involves
   adding an IANA registry for transfer-codings (separate from content
   codings), a new header field (TE) and enabling trailer headers in the
   future. Transfer encoding is a major performance benefit, so it was
   worth fixing [&lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt;]. TE also solves another, obscure, downward
   interoperability problem that could have occurred due to interactions
   between authentication trailers, chunked encoding and HTTP/1.0
   clients.(&lt;a href=&quot;#section-3.6&quot;&gt;Section 3.6&lt;/a&gt;, 3.6.1, and 14.39)

   The PATCH, LINK, UNLINK methods were defined but not commonly
   implemented in previous versions of this specification. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;
   [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].

   The Alternates, Content-Version, Derived-From, Link, URI, Public and
   Content-Base header fields were defined in previous versions of this
   specification, but not commonly implemented. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">该规范已经过仔细审核，以纠正和消除关键字的使用；&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;在&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]中列出的约定方面存在许多问题。阐明了应将哪些错误代码用于入站服务器故障（例如DNS故障）。 （&lt;a href=&quot;#section-10.5.5&quot;&gt;第10.5.5节&lt;/a&gt;）。 CREATE的比赛要求在首次创建资源时发送Etag。 （&lt;a href=&quot;#section-10.2.2&quot;&gt;第10.2.2节&lt;/a&gt;）。 Content-Base已从规范中删除：它并未得到广泛实施，并且没有简单，安全的方法来引入它，而没有强大的扩展机制。此外，它在MHTML中以相似但不完全相同的方式使用[ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;]。当使用分块编码时，传输编码和消息长度都以需要精确解决的方式进行交互（以允许传输编码可能不是自定界的）；弄清楚准确计算消息长度的方式非常重要。 （第3.6、4.4、7.2.2、13.5.2、14.13、14.16节）引入了&amp;ldquo;身份&amp;rdquo;的内容编码，以解决在缓存中发现的问题。 （&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）质量值零应表示&amp;ldquo;我不要&amp;rdquo;，以允许客户拒绝表示。 （&lt;a href=&quot;#section-3.9&quot;&gt;第3.9节&lt;/a&gt;）&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;阐明了HTTP版本号的使用和解释。要求代理将请求升级到它们支持的最高协议版本，以处理HTTP / 1.0实现中发现的问题（&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;）引入了字符集通配符，以避免在接受标头中字符集名称激增。 （&lt;a href=&quot;#section-14.2&quot;&gt;第14.2节&lt;/a&gt;）HTTP / 1.1的Cache-Control模型中缺少一个案例；引入了s-maxage来添加这种丢失的情况。 （第&lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;，&lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;，&lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;，14.9.3）将Cache-Control：max-age的指令是不正确的响应定义。 （&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt;）在某些情况下，服务器（尤其是代理服务器）不知道响应的完整长度，但能够处理字节范围请求。因此，我们需要一种机制，以允许具有内容范围的字节范围不指示消息的全长。 （&lt;a href=&quot;#section-14.16&quot;&gt;第14.16节&lt;/a&gt;）如果始终返回所有元数据，则范围请求响应将变得非常冗长。通过允许服务器仅在206响应中发送所需的标头，可以避免此问题。 （&lt;a href=&quot;#section-10.2.7&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7 &lt;/a&gt;节，13.5.3和14.27）解决了范围请求无法满足的问题；有两种情况：语法问题，并且文档中不存在范围。需要使用416状态代码来解决这种歧义，该歧义需要为超出文档实际内容的字节范围请求指示错误。 （&lt;a href=&quot;#section-10.4.17&quot;&gt;第10.4.17节&lt;/a&gt;，14.16）重写消息传输要求，以使实现者更容易出错，因为此处的错误后果可能会对Internet产生重大影响，并处理以下问题：1.更改&amp;ldquo; HTTP / 1.1或稍后&amp;rdquo;到&amp;ldquo; HTTP / 1.1&amp;rdquo;，在这种情况下错误地对将来的HTTP / 1.x 2版本的实现行为提出了要求。请明确指出用户代理应重试请求，而不是&amp;ldquo;客户端&amp;ldquo; 一般来说。 3.将客户忽略无意的100（继续）响应以及代理转发100响应的要求转换为1xx响应的一般要求。 4.修改了一些特定于TCP的语言，明确指出HTTP可以使用非TCP传输。 5.要求原始服务器在发送必需的100（继续）响应之前，不得等待请求正文。 6.如果服务器已经看到一些请求正文，则允许而不是要求服务器省略100（继续）。 7.允许服务器防御拒绝服务攻击和损坏的客户端。此更改将添加Expect标头和417状态代码。消息传输要求修复的内容在部分中如果服务器已经看到一些请求正文，则省略100（继续）。 7.允许服务器防御拒绝服务攻击和损坏的客户端。此更改将添加Expect标头和417状态代码。消息传输要求修复的内容在部分中如果服务器已经看到一些请求正文，则省略100（继续）。 7.允许服务器防御拒绝服务攻击和损坏的客户端。此更改将添加Expect标头和417状态代码。消息传输要求修复的内容在部分中&lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;，&lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;，8.1.2.2，13.11，14.20和。代理应能够在适当的时候添加Content-Length。 （&lt;a href=&quot;#section-13.5.2&quot;&gt;第13.5.2节&lt;/a&gt;）清理403和404响应之间的混淆。 （&lt;a href=&quot;#section-10.4.4&quot;&gt;第10.4.4、10.4.5&lt;/a&gt;和10.4.11节）警告可能被错误地缓存或未适当更新。 （&lt;a href=&quot;#section-13.1.2&quot;&gt;第13.1.2节&lt;/a&gt;，13.2.4、13.5.2、13.5.3、14.9.3和14.46）警告也必须是通用标头，因为在请求中PUT或其他方法可能需要它。传输编码存在重大问题，尤其是与分块编码的交互时。解决方案是，传输编码与内容编码一样成熟。这涉及添加用于传输编码（与内容编码分开）的IANA注册中心，新的标头字段（TE），并在将来启用尾标头。传输编码是主要的性能优势，因此值得修复[ &lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt; ]。 TE还解决了另一个由于身份验证尾部，分块编码和HTTP / 1.0客户端之间的交互而可能发生的，晦涩的，向下的互操作性问题。（&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节）&lt;/a&gt;，3.6.1和14.39）定义了PATCH，LINK和UNLINK方法，但在本规范的先前版本中并不常用。参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]。Alternates，Content-Version，Derived-From，Link，URI，Public和Content-Base标头字段在本规范的先前版本中定义，但并不常用。参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="5c3aed10c6ed1ff4c98e713111fede52cc2146bd" translate="yes" xml:space="preserve">
          <source>This specification makes heavy use of the augmented BNF and generic
   constructs defined by David H. Crocker for &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Similarly, it
   reuses many of the definitions provided by Nathaniel Borenstein and
   Ned Freed for MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. We hope that their inclusion in this
   specification will help reduce past confusion over the relationship
   between HTTP and Internet mail message formats.

   The HTTP protocol has evolved considerably over the years. It has
   benefited from a large and active developer community--the many
   people who have participated on the www-talk mailing list--and it is
   that community which has been most responsible for the success of
   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert
   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois
   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob
   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc
   VanHeyningen deserve special recognition for their efforts in
   defining early aspects of the protocol.

   This document has benefited greatly from the comments of all those
   participating in the HTTP-WG. In addition to those already mentioned,
   the following individuals have contributed to this specification: 

       Gary Adams                  Ross Patterson
       Harald Tveit Alvestrand     Albert Lunde
       Keith Ball                  John C. Mallery
       Brian Behlendorf            Jean-Philippe Martin-Flatin
       Paul Burchard               Mitra
       Maurizio Codogno            David Morris
       Mike Cowlishaw              Gavin Nicol
       Roman Czyborra              Bill Perry
       Michael A. Dolan            Jeffrey Perry
       David J. Fiander            Scott Powers
       Alan Freier                 Owen Rees
       Marc Hedlund                Luigi Rizzo
       Greg Herlihy                David Robinson
       Koen Holtman                Marc Salomon
       Alex Hopmann                Rich Salz
       Bob Jernigan                Allan M. Schiffman
       Shel Kaphan                 Jim Seidman
       Rohit Khare                 Chuck Shotton
       John Klensin                Eric W. Sink
       Martijn Koster              Simon E. Spero
       Alexei Kosut                Richard N. Taylor
       David M. Kristol            Robert S. Thau
       Daniel LaLiberte            Bill (BearHeart) Weinman
       Ben Laurie                  Francois Yergeau
       Paul J. Leach               Mary Ellen Zurko
       Daniel DuBois               Josh Cohen


   Much of the content and presentation of the caching design is due to
   suggestions and comments from individuals including: Shel Kaphan,
   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.

   Most of the specification of ranges is based on work originally done
   by Ari Luotonen and John Franks, with additional input from Steve
   Zilles.

   Thanks to the &quot;cave men&quot; of Palo Alto. You know who you are.

   Jim Gettys (the current editor of this document) wishes particularly
   to thank Roy Fielding, the previous editor of this document, along
   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen
   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and
   Larry Masinter for their help. And thanks go particularly to Jeff
   Mogul and Scott Lawrence for performing the &quot;MUST/MAY/SHOULD&quot; audit. 

   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik
   Frystyk implemented &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; early, and we wish to thank them for the
   discovery of many of the problems that this document attempts to
   rectify.</source>
          <target state="translated">该规范大量使用了David H. Crocker为&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] 定义的增强BNF和通用结构。同样，它重用了Nathaniel Borenstein和Ned Freed为MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;提供的许多定义。]。我们希望将它们包含在本规范中将有助于减少过去对HTTP和Internet邮件格式之间关系的混淆。多年来，HTTP协议已经有了很大的发展。它受益于庞大而活跃的开发人员社区-许多人都参加了www-talk邮件列表-正是该社区对HTTP和Internet的成功与否负有最大责任。一般。 Marc Andreessen，Robert Cailliau，Daniel W.Connolly，Bob Denny，John Franks，Jean-Francois Groff，Phillip M.Hallam-Baker，Hakon W.Lie，Ari Luotonen，Rob McCool，Lou Montulli，Dave Raggett，Tony Sanders和马克&amp;middot;范海宁根（Marc VanHeyningen）在定义协议的早期方面所做的努力值得特别认可。所有参与HTTP-WG的人员的评论都使该文档受益匪浅。除已提及的人员外，以下人员还对此规范做出了贡献：加里&amp;middot;亚当斯&amp;middot;罗斯&amp;middot;帕特森&amp;middot;哈拉德&amp;middot;特维特&amp;middot;阿尔维斯特朗德&amp;middot;阿尔伯特&amp;middot;伦德&amp;middot;基思&amp;middot;鲍尔罗马Czyborra Bill Perry Michael A.Dolan Jeffrey Perry David J.Fiander Scott Powers Alan Freier Owen Rees Marc Hedlund Luigi Rizzo Greg Herlihy David Robinson Koen Holtman Marc Salomon Alex Hopmann Rich Salz Bob Jernigan Allan M.Schiffman Shel Kaphan Jim Seidman Rohit Khare Chuck Shotton John Klensin Eric W.Sink Martijn Koster Simon E.科索特&amp;middot;理查德&amp;middot;N&amp;middot;泰勒&amp;middot;大卫&amp;middot;克里斯托尔&amp;middot;罗伯特&amp;middot;S&amp;middot;休&amp;middot;丹尼尔&amp;middot;拉伯特&amp;middot;比尔（BearHeart）温曼&amp;middot;本&amp;middot;劳里&amp;middot;弗朗索瓦&amp;middot;叶尔盖&amp;middot;保罗&amp;middot;J。玛丽&amp;middot;艾伦&amp;middot;祖尔科（Mary Ellen Zurko）丹尼尔&amp;middot;杜波依斯（Joseph Cohen）缓存设计的大部分内容和演示都来自以下个人的建议和评论：谢尔&amp;middot;卡潘，保罗&amp;middot;利奇，科恩&amp;middot;霍尔特曼，戴维&amp;middot;莫里斯和拉里&amp;middot;马辛特。范围的大多数规范是基于Ari Luotonen和John Franks最初完成的工作，再加上Steve Zilles的投入。感谢帕洛阿尔托的&amp;ldquo;洞穴人&amp;rdquo;。你知道你是谁。 Jim Gettys（本文档的当前编辑）尤其要感谢本文档的前编辑Roy Fielding，以及John Klensin，Jeff Mogul，Paul Leach，Dave Kristol，Koen Holtman，John Franks，Josh Cohen，Alex Hopmann， Scott Lawrence和Larry Masinter的帮助。尤其要感谢Jeff Mogul和Scott Lawrence进行了&amp;ldquo;必须/要/应该&amp;rdquo;的审核。阿帕奇（Apache）小组的作者，拼图（Jigsaw）的作者安瑟姆&amp;middot;贝尔德&amp;middot;史密斯（Anselm Baird-Smith）和亨里克&amp;middot;弗里斯蒂克（Henrik Frystyk）&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;早期，我们希望感谢他们发现了本文档尝试纠正的许多问题。</target>
        </trans-unit>
        <trans-unit id="3fad4602c9c700895f3ed6117008bdc18c9fc181" translate="yes" xml:space="preserve">
          <source>This specification reserves the method name CONNECT for use with a
   proxy that can dynamically switch to being a tunnel (e.g. SSL
   tunneling [&lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt;]).</source>
          <target state="translated">该规范保留了方法名称CONNECT以便与可以动态切换为隧道（例如SSL隧道[ &lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt; ]）的代理一起使用。</target>
        </trans-unit>
        <trans-unit id="672729314726c61a4c205fd539620a1ce076c9fe" translate="yes" xml:space="preserve">
          <source>This specification takes over the definition of the HTTP
   Authentication Framework, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.  We thank
   John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D.
   Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for
   their work on that specification.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC2617]&lt;/a&gt; for
   further acknowledgements.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt; for the Acknowledgments related to this
   document revision.</source>
          <target state="translated">该规范接管了先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617中&lt;/a&gt;定义的HTTP身份验证框架的定义。感谢John Franks，Phillip M.Hallam-Baker，Jeffery L.Hostetler，Scott D.Lawrence，Paul J.Leach，Ari Luotonen和Lawrence C.Stewart在该规范上的工作。进一步的确认，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;[RFC2617]的第6节&lt;/a&gt;。有关与本文档修订版有关的确认，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;[RFC7230]的第10节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="199a33e3a0bbdd6ce39373b856043ea2c7f5f848" translate="yes" xml:space="preserve">
          <source>This specification targets conformance criteria according to the role
   of a participant in HTTP communication.  Hence, HTTP requirements are
   placed on senders, recipients, clients, servers, user agents,
   intermediaries, origin servers, proxies, gateways, or caches,
   depending on what behavior is being constrained by the requirement.
   Additional (social) requirements are placed on implementations,
   resource owners, and protocol element registrations when they apply
   beyond the scope of a single communication.

   The verb &quot;generate&quot; is used instead of &quot;send&quot; where a requirement
   differentiates between creating a protocol element and merely
   forwarding a received element downstream.

   An implementation is considered conformant if it complies with all of
   the requirements associated with the roles it partakes in HTTP.

   Conformance includes both the syntax and semantics of protocol
   elements.  A sender MUST NOT generate protocol elements that convey a
   meaning that is known by that sender to be false.  A sender MUST NOT
   generate protocol elements that do not match the grammar defined by
   the corresponding ABNF rules.  Within a given message, a sender MUST
   NOT generate protocol elements or syntax alternatives that are only
   allowed to be generated by participants in other roles (i.e., a role
   that the sender does not have for that message).

   When a received protocol element is parsed, the recipient MUST be
   able to parse any value of reasonable length that is applicable to
   the recipient's role and that matches the grammar defined by the
   corresponding ABNF rules.  Note, however, that some received protocol
   elements might not be parsed.  For example, an intermediary 

   forwarding a message might parse a header-field into generic
   field-name and field-value components, but then forward the header
   field without further parsing inside the field-value.

   HTTP does not have specific length limitations for many of its
   protocol elements because the lengths that might be appropriate will
   vary widely, depending on the deployment context and purpose of the
   implementation.  Hence, interoperability between senders and
   recipients depends on shared expectations regarding what is a
   reasonable length for each protocol element.  Furthermore, what is
   commonly understood to be a reasonable length for some protocol
   elements has changed over the course of the past two decades of HTTP
   use and is expected to continue changing in the future.

   At a minimum, a recipient MUST be able to parse and process protocol
   element lengths that are at least as long as the values that it
   generates for those same protocol elements in other messages.  For
   example, an origin server that publishes very long URI references to
   its own resources needs to be able to parse and process those same
   references when received as a request target.

   A recipient MUST interpret a received protocol element according to
   the semantics defined for it by this specification, including
   extensions to this specification, unless the recipient has determined
   (through experience or configuration) that the sender incorrectly
   implements what is implied by those semantics.  For example, an
   origin server might disregard the contents of a received
   Accept-Encoding header field if inspection of the User-Agent header
   field indicates a specific implementation version that is known to
   fail on receipt of certain content codings.

   Unless noted otherwise, a recipient MAY attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct
   impact on security, since different applications of the protocol
   require different error handling strategies.  For example, a Web
   browser might wish to transparently recover from a response where the
   Location header field doesn't parse according to the ABNF, whereas a
   systems control client might consider any form of error recovery to
   be dangerous.</source>
          <target state="translated">本规范根据HTTP通信中参与者的角色来确定一致性标准。因此,HTTP要求被放置在发送者、接收者、客户端、服务器、用户代理、中间人、源服务器、代理、网关或缓存上,这取决于要求所限制的行为。当额外的(社会)需求的适用范围超出单一通信的范围时,就会对实现、资源所有者和协议元素注册提出额外的要求。在需求区分创建协议元素和仅仅是将接收到的元素转发到下游时,用动词 &quot;生成 &quot;代替 &quot;发送&quot;。如果一个实现符合与它在HTTP中的角色相关的所有要求,那么它就被认为是符合性的。符合性包括协议元素的语法和语义。一个发送者决不能生成传达一个由发送者已知为假的意义的协议元素。发送者必须不产生不符合相应的ABNF规则所定义的语法的协议元素。在一个给定的消息中,发送者不得生成只允许由其他角色的参与者生成的协议元素或语法选择(即发送者对该消息不具有的角色)。当解析接收到的协议元素时,接收者必须能够解析任何合理长度的值,该值适用于接收者的角色,并与相应的ABNF规则定义的语法相匹配。但是,请注意,一些接收的协议元素可能不会被解析。例如,转发消息的中间人可能会将一个头字段解析成通用的字段名和字段值组件,但是在转发头字段时,不会在字段值内部进行进一步的解析。HTTP对许多协议元素没有特定的长度限制,因为根据部署环境和实现的目的,可能合适的长度会有很大的不同。因此,发送者和接收者之间的互操作性取决于对每个协议元素的合理长度的共同期望。此外,在过去20年的HTTP使用过程中,人们通常理解的一些协议元素的合理长度已经发生了变化,并且预计在未来会继续变化。至少,接收者必须能够解析和处理协议元素的长度,这些长度至少与它在其他消息中为这些相同的协议元素生成的值一样长。例如,一个发布了很长的URI引用到它自己的资源的源服务器需要能够在作为请求目标接收时解析和处理这些相同的引用。接收者必须根据本规范为其定义的语义来解释接收到的协议元素,包括本规范的扩展,除非接收者(通过经验或配置)确定发送者不正确地实现了这些语义所暗示的内容。例如,如果对User-Agent头域的检查表明了特定的实现版本,已知该版本在接收某些内容编码时失败,则源服务器可能会忽略接收到的Accept-Encoding头域的内容。除非另有说明,接收者可以尝试从无效的构造中恢复一个可用的协议元素。HTTP没有定义特定的错误处理机制,除非它们对安全有直接影响,因为协议的不同应用需要不同的错误处理策略。例如,Web浏览器可能希望透明地从一个Location头字段没有根据ABNF解析的响应中恢复,而系统控制客户端可能认为任何形式的错误恢复都是危险的。</target>
        </trans-unit>
        <trans-unit id="facba0308af11f7848962366e11eb270544c791e" translate="yes" xml:space="preserve">
          <source>This specification uses a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.

   connection
      A transport layer virtual circuit established between two programs
      for the purpose of communication.

   message
      The basic unit of HTTP communication, consisting of a structured
      sequence of octets matching the syntax defined in &lt;a href=&quot;#section-4&quot;&gt;section 4&lt;/a&gt; and
      transmitted via the connection.

   request
      An HTTP request message, as defined in &lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;.

   response
      An HTTP response message, as defined in &lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;. 

   resource
      A network data object or service that can be identified by a URI,
      as defined in &lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;. Resources may be available in multiple
      representations (e.g. multiple languages, data formats, size, and
      resolutions) or vary in other ways.

   entity
      The information transferred as the payload of a request or
      response. An entity consists of metainformation in the form of
      entity-header fields and content in the form of an entity-body, as
      described in &lt;a href=&quot;#section-7&quot;&gt;section 7&lt;/a&gt;.

   representation
      An entity included with a response that is subject to content
      negotiation, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. There may exist multiple
      representations associated with a particular response status.

   content negotiation
      The mechanism for selecting the appropriate representation when
      servicing a request, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. The
      representation of entities in any response can be negotiated
      (including error responses).

   variant
      A resource may have one, or more than one, representation(s)
      associated with it at any given instant. Each of these
      representations is termed a `varriant'.  Use of the term `variant'
      does not necessarily imply that the resource is subject to content
      negotiation.

   client
      A program that establishes connections for the purpose of sending
      requests.

   user agent
      The client which initiates a request. These are often browsers,
      editors, spiders (web-traversing robots), or other end user tools.

   server
      An application program that accepts connections in order to
      service requests by sending back responses. Any given program may
      be capable of being both a client and a server; our use of these
      terms refers only to the role being performed by the program for a
      particular connection, rather than to the program's capabilities
      in general. Likewise, any server may act as an origin server,
      proxy, gateway, or tunnel, switching behavior based on the nature
      of each request. 

   origin server
      The server on which a given resource resides or is to be created.

   proxy
      An intermediary program which acts as both a server and a client
      for the purpose of making requests on behalf of other clients.
      Requests are serviced internally or by passing them on, with
      possible translation, to other servers. A proxy MUST implement
      both the client and server requirements of this specification. A
      &quot;transparent proxy&quot; is a proxy that does not modify the request or
      response beyond what is required for proxy authentication and
      identification. A &quot;non-transparent proxy&quot; is a proxy that modifies
      the request or response in order to provide some added service to
      the user agent, such as group annotation services, media type
      transformation, protocol reduction, or anonymity filtering. Except
      where either transparent or non-transparent behavior is explicitly
      stated, the HTTP proxy requirements apply to both types of
      proxies.

   gateway
      A server which acts as an intermediary for some other server.
      Unlike a proxy, a gateway receives requests as if it were the
      origin server for the requested resource; the requesting client
      may not be aware that it is communicating with a gateway.

   tunnel
      An intermediary program which is acting as a blind relay between
      two connections. Once active, a tunnel is not considered a party
      to the HTTP communication, though the tunnel may have been
      initiated by an HTTP request. The tunnel ceases to exist when both
      ends of the relayed connections are closed.

   cache
      A program's local store of response messages and the subsystem
      that controls its message storage, retrieval, and deletion. A
      cache stores cacheable responses in order to reduce the response
      time and network bandwidth consumption on future, equivalent
      requests. Any client or server may include a cache, though a cache
      cannot be used by a server that is acting as a tunnel.

   cacheable
      A response is cacheable if a cache is allowed to store a copy of
      the response message for use in answering subsequent requests. The
      rules for determining the cacheability of HTTP responses are
      defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;. Even if a resource is cacheable, there may
      be additional constraints on whether a cache can use the cached
      copy for a particular request. 

   first-hand
      A response is first-hand if it comes directly and without
      unnecessary delay from the origin server, perhaps via one or more
      proxies. A response is also first-hand if its validity has just
      been checked directly with the origin server.

   explicit expiration time
      The time at which the origin server intends that an entity should
      no longer be returned by a cache without further validation.

   heuristic expiration time
      An expiration time assigned by a cache when no explicit expiration
      time is available.

   age
      The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.

   freshness lifetime
      The length of time between the generation of a response and its
      expiration time.

   fresh
      A response is fresh if its age has not yet exceeded its freshness
      lifetime.

   stale
      A response is stale if its age has passed its freshness lifetime.

   semantically transparent
      A cache behaves in a &quot;semantically transparent&quot; manner, with
      respect to a particular response, when its use affects neither the
      requesting client nor the origin server, except to improve
      performance. When a cache is semantically transparent, the client
      receives exactly the same response (except for hop-by-hop headers)
      that it would have received had its request been handled directly
      by the origin server.

   validator
      A protocol element (e.g., an entity tag or a Last-Modified time)
      that is used to find out whether a cache entry is an equivalent
      copy of an entity.

   upstream/downstream
      Upstream and downstream describe the flow of a message: all
      messages flow from upstream to downstream. 

   inbound/outbound
      Inbound and outbound refer to the request and response paths for
      messages: &quot;inbound&quot; means &quot;traveling toward the origin server&quot;,
      and &quot;outbound&quot; means &quot;traveling toward the user agent&quot;</source>
          <target state="translated">本规范使用许多术语来指代参与者在HTTP通信中扮演的角色和对象。连接在两个程序之间建立的传输层虚拟电路，用于通信。消息HTTP通信的基本单元，由与&lt;a href=&quot;#section-4&quot;&gt;第4节中&lt;/a&gt;定义的语法相匹配的结构化字节序列组成，并通过连接进行传输。 request HTTP请求消息，如&lt;a href=&quot;#section-5&quot;&gt;第5节中&lt;/a&gt;所定义。 response HTTP响应消息，如&lt;a href=&quot;#section-6&quot;&gt;第6节中&lt;/a&gt;所定义。资源（resource）可以由URI标识的网络数据对象或服务，如&lt;a href=&quot;#section-3.2&quot;&gt;3.2节中&lt;/a&gt;所定义。资源可能以多种表示形式（例如，多种语言，数据格式，大小和分辨率）可用或以其他方式变化。实体作为请求或响应的有效负载传输的信息。实体由实体标题字段形式的元信息和实体实体形式的内容组成，如&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;所述。表示（representation），包含在响应中的实体，要进行内容协商，如&lt;a href=&quot;#section-12&quot;&gt;第12节&lt;/a&gt;所述。可能存在与特定响应状态关联的多种表示形式。内容协商内容处理机制，用于在处理请求时选择适当的表示形式，如&lt;a href=&quot;#section-12&quot;&gt;第12节&lt;/a&gt;所述。实体在任何响应中的表示形式都可以协商（包括错误响应）。变体在任何给定瞬间，资源可能具有一个或多个与之关联的表示形式。这些表示中的每一个都称为&amp;ldquo; varriant&amp;rdquo;。使用术语&amp;ldquo;变体&amp;rdquo;并不一定意味着该资源需要进行内容协商。客户端（client）为发送请求而建立连接的程序。用户代理发起请求的客户端。这些通常是浏览器，编辑器，爬虫（网络遍历机器人）或其他最终用户工具。服务器（server）接受连接以便通过发送回响应来处理请求的应用程序。任何给定的程序都可能既是客户端又是服务器。我们对这些术语的使用仅指程序为特定连接执行的角色，而不是指程序的一般功能。同样，任何服务器都可以充当源服务器，代理，网关或隧道，并根据每个请求的性质进行切换。源服务器（origin server）特定资源所在或将要在其上创建的服务器。代理（proxy）一个中介程序，既充当服务器又充当客户端，以便代表其他客户端发出请求。请求可以在内部进行服务，也可以通过可能的转换将其传递给其他服务器。代理必须同时实现本规范的客户端和服务器要求。&amp;ldquo;透明代理&amp;rdquo;是不会修改请求或响应超出代理身份验证和标识所需的内容的代理。 &amp;ldquo;非透明代理&amp;rdquo;是一种修改请求或响应以便向用户代理提供一些附加服务的代理，例如组批注服务，媒体类型转换，协议减少或匿名过滤。除非明确声明透明或非透明行为，否则HTTP代理要求适用于两种类型的代理。网关充当其他服务器中介的服务器。与代理不同，网关接收请求时就好像它是所请求资源的原始服务器一样。请求客户端可能不知道它正在与网关通信。隧道（tunnel）一种中间程序，充当两个连接之间的盲中继。一旦激活，隧道就不会被认为是HTTP通信的一方，尽管该隧道可能是由HTTP请求发起的。当中继连接的两端都关闭时，隧道将不复存在。缓存（cache）程序在本地的响应消息存储，以及控制其消息存储，检索和删除的子系统。缓存存储可缓存的响应，以减少响应时间和未来等效请求的网络带宽消耗。任何客户端或服务器都可以包括缓存，尽管充当隧道的服务器无法使用缓存。可缓存的如果响应允许缓存存储响应消息的副本以用于响应后续请求，则响应是可缓存的。确定HTTP响应的可缓存性的规则在&lt;a href=&quot;#section-13&quot;&gt;第13条&lt;/a&gt;。即使资源是可缓存的，对于缓存是否可以针对特定请求使用缓存的副本，也可能存在其他限制。第一手响应如果响应是直接发生的，则可能是通过一个或多个代理从源服务器发出的，而没有不必要的延迟，则是第一手的。如果直接通过原始服务器检查了响应的有效性，则该响应也是第一手的。显式到期时间（explicit Expiration time）在没有进一步验证的情况下，原始服务器打算不再由缓存返回实体的时间。启发式到期时间当没有明确的到期时间可用时，由高速缓存分配的到期时间。年龄响应的年龄是指源服务器发送或成功验证其以来的时间。新鲜度有效期（freshiness life）响应的生成与其到期时间之间的时间长度。新鲜如果响应的年龄尚未超过其新鲜寿命，则它是新鲜的。如果响应的年龄已经过了新鲜度，那么响应就是陈旧的。语义透明高速缓存的使用既不影响请求的客户端也不影响原始服务器，除了提高性能外，对于特定的响应，它以&amp;ldquo;语义透明&amp;rdquo;的方式运行。如果缓存在语义上是透明的，则客户端将收到与原始服务器直接处理其请求时完全相同的响应（逐跳头除外）。验证器协议元素（例如，实体标签或上次修改时间），用于查找缓存条目是否是实体的等效副本。上游/下游上游和下游描述消息的流：所有消息从上游流向下游。入站/出站入站和出站是指消息的请求和响应路径：&amp;ldquo;入站&amp;rdquo;是指&amp;ldquo;向原始服务器移动&amp;rdquo;，&amp;ldquo;出站&amp;rdquo;是指&amp;ldquo;向用户代理移动&amp;rdquo;入站/出站入站和出站是指消息的请求和响应路径：&amp;ldquo;入站&amp;rdquo;是指&amp;ldquo;向原始服务器移动&amp;rdquo;，&amp;ldquo;出站&amp;rdquo;是指&amp;ldquo;向用户代理移动&amp;rdquo;入站/出站入站和出站是指消息的请求和响应路径：&amp;ldquo;入站&amp;rdquo;是指&amp;ldquo;向原始服务器移动&amp;rdquo;，&amp;ldquo;出站&amp;rdquo;是指&amp;ldquo;向用户代理移动&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="5366fbe830e07db7f7079781b54e53bea8e2feb6" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;,
   that allows for compact definition of comma-separated lists using a
   '#' operator (similar to how the '*' operator indicates repetition).
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; shows the collected grammar with all list operators
   expanded to standard ABNF notation.

   The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234], Appendix&amp;nbsp;B.1&lt;/a&gt;: ALPHA (letters), CR (carriage return), CRLF
   (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line
   feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any
   visible [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;] character).

   As a convention, ABNF rule names prefixed with &quot;obs-&quot; denote
   &quot;obsolete&quot; grammar rules that appear for historical reasons.</source>
          <target state="translated">本规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 的增强Backus-Naur格式（ABNF）表示法，具有在&lt;a href=&quot;#section-7&quot;&gt;第7节中&lt;/a&gt;定义的列表扩展名，该列表扩展名允许使用'＃'运算符来紧凑定义逗号分隔的列表（类似于'* '运算符表示重复）。 &lt;a href=&quot;#appendix-B&quot;&gt;附录B&lt;/a&gt;显示了收集的语法，所有列表运算符均扩展为标准ABNF表示法。以下核心规则作为参考包含在内，如&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;所定义。 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9），DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），HTAB （水平标签），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的[ &lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ]字符）。按照惯例，以&amp;ldquo; obs-&amp;rdquo;为前缀的ABNF规则名称表示出于历史原因而出现的&amp;ldquo;过时&amp;rdquo;语法规则。</target>
        </trans-unit>
        <trans-unit id="3f746953f3428a5eccba921f06abcdb82aa34c60" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">该规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 的增强Backus-Naur格式（ABNF）表示法和具有列表扩展名的扩展名，该扩展名在&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]的第7节中&lt;/a&gt;定义，允许使用'＃'运算符来紧凑定义逗号分隔的列表（类似于&amp;ldquo; *&amp;rdquo;运算符如何表示重复）。 &lt;a href=&quot;#appendix-B&quot;&gt;附录B&lt;/a&gt;描述了从其他文档导入的规则。 &lt;a href=&quot;#appendix-C&quot;&gt;附录C&lt;/a&gt;显示了收集的语法，所有列表运算符均扩展为标准ABNF表示法。</target>
        </trans-unit>
        <trans-unit id="faf3c32d78c2b6483745156433268b97ba91a18a" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">该规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 的增强Backus-Naur格式（ABNF）表示法和具有列表扩展名的扩展名，该扩展名在&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]的第7节中&lt;/a&gt;定义，允许使用'＃'运算符来紧凑定义逗号分隔的列表（类似于&amp;ldquo; *&amp;rdquo;运算符如何表示重复）。 &lt;a href=&quot;#appendix-C&quot;&gt;附录C&lt;/a&gt;描述了从其他文档导入的规则。 &lt;a href=&quot;#appendix-D&quot;&gt;附录D&lt;/a&gt;显示了收集的语法，所有列表运算符均扩展为标准ABNF表示法。</target>
        </trans-unit>
        <trans-unit id="ee23ef0e85f4f9cd9d0acebbd9b86ac08e046506" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation. 

   This specification uses the terms &quot;character&quot;, &quot;character encoding
   scheme&quot;, &quot;charset&quot;, and &quot;protocol element&quot; as they are defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].</source>
          <target state="translated">该规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 的增强Backus-Naur格式（ABNF）表示法和具有列表扩展名的扩展名，该扩展名在&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]的第7节中&lt;/a&gt;定义，允许使用'＃'运算符来紧凑定义逗号分隔的列表（类似于&amp;ldquo; *&amp;rdquo;运算符如何表示重复）。 &lt;a href=&quot;#appendix-C&quot;&gt;附录C&lt;/a&gt;描述了从其他文档导入的规则。 &lt;a href=&quot;#appendix-D&quot;&gt;附录D&lt;/a&gt;显示了收集的语法，所有列表运算符均扩展为标准ABNF表示法。本规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ] 中定义的术语&amp;ldquo;字符&amp;rdquo;，&amp;ldquo;字符编码方案&amp;rdquo;，&amp;ldquo;字符集&amp;rdquo;和&amp;ldquo;协议元素&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="98343664a6355afcb4ca38df251b44b6714d8a1e" translate="yes" xml:space="preserve">
          <source>This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS (&quot;bad&quot; whitespace).

   The OWS rule is used where zero or more linear whitespace octets
   might appear.  For protocol elements where optional whitespace is
   preferred to improve readability, a sender SHOULD generate the
   optional whitespace as a single SP; otherwise, a sender SHOULD NOT
   generate optional whitespace except as needed to white out invalid or
   unwanted protocol elements during in-place message filtering.

   The RWS rule is used when at least one linear whitespace octet is
   required to separate field tokens.  A sender SHOULD generate RWS as a
   single SP.

   The BWS rule is used where the grammar allows optional whitespace
   only for historical reasons.  A sender MUST NOT generate BWS in
   messages.  A recipient MUST parse for such bad whitespace and remove
   it before interpreting the protocol element. 

     OWS            = *( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; &quot;bad&quot; whitespace</source>
          <target state="translated">本规范使用三种规则来表示线性空白的使用。OWS(可选空白)、RWS(必需空白)和BWS(&quot;坏 &quot;空白)。OWS规则用于零或多个线性空白八位数可能出现的地方。对于为了提高可读性而选择可选的whitespace的协议元素,发送者应该将可选的whitespace作为一个SP生成;否则,发送者不应该生成可选的whitespace,除非在原地消息过滤过程中需要将无效的或不需要的协议元素删除。当至少需要一个线性whitespace八位组来分隔字段标记时,会使用RWS规则。发送者应该将RWS作为一个SP生成。BWS规则用于语法只允许出于历史原因而使用可选的空白的情况。发送者必须不在消息中生成BWS。接收者必须在解释协议元素之前,解析这种坏的whitespace并删除它。OWS=*(SP/HTAB );可选的whitespace RWS=1*(SP/HTAB );需要的whitespace BWS=OWS;&quot;坏 &quot;whitespace。</target>
        </trans-unit>
        <trans-unit id="aff04232d95d6c1171cd6ab1415e3e08026d9557" translate="yes" xml:space="preserve">
          <source>This specification uses two new media types that conform to the
   registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt;], a new message header that
   conforms to the registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;], and two
   new link relations that conform to the registry mechanism described
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].</source>
          <target state="translated">本说明书中使用了符合注册机制两个新的媒体类型中[描述&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt; ]，一个新的消息报头符合所述注册机制在[描述&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;符合注册表机构]，和两个新的链接关系，在[描述&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="230704ae6595086f8b4b75eab8034387112b13dd" translate="yes" xml:space="preserve">
          <source>This status can also send a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header, telling the requester when to check back to see if the functionality is supported by then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755885b5d7d7ceb53dac1ececfff6ea91ddc944f" translate="yes" xml:space="preserve">
          <source>This status code is primarily intended to be used with the &lt;a href=&quot;headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header, letting the user agent start &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content&quot;&gt;preloading&lt;/a&gt; resources while the server prepares a response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168a50454b53ca416e50a221ecab212a73004d2b" translate="yes" xml:space="preserve">
          <source>This status code is used in HTTP 1.1 only for Request-URIs, not URIs
   in other locations.</source>
          <target state="translated">这个状态码在HTTP 1.1中只用于Request-URI,不用于其他位置的URI。</target>
        </trans-unit>
        <trans-unit id="e6542819db91e2214f7b4c25edf572e8a36dacaa" translate="yes" xml:space="preserve">
          <source>This status is not generated by origin servers, but by intercepting proxies that control access to the network.</source>
          <target state="translated">这个状态不是由起源服务器产生的,而是由控制网络访问的拦截代理产生的。</target>
        </trans-unit>
        <trans-unit id="372dd7c8c17bd1505f433437b7bcad8e716c04b8" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">该状态与&lt;a href=&quot;../headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;标头一起发送，该标头包含有关如何正确授权的信息。</target>
        </trans-unit>
        <trans-unit id="a3cd34d9e9d7109fa13e3c0395c58eb46cc7b8a7" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">该状态与&lt;a href=&quot;../headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;标头一起发送，该标头包含有关如何正确授权的信息。</target>
        </trans-unit>
        <trans-unit id="8a9d71b9023a06f11edab66435c308dc6a0ee383" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;, but in this case, re-authenticating will make no difference. The access is permanently forbidden and tied to the application logic, such as insufficient rights to a resource.</source>
          <target state="translated">此状态类似于&lt;a href=&quot;401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt;，但是在这种情况下，重新认证不会有任何区别。永久禁止访问并将访问与应用程序逻辑绑定在一起，例如对资源的权限不足。</target>
        </trans-unit>
        <trans-unit id="a37c225e3a7cdee05e8c812d332fa6e17571a6c3" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;, but in this case, authentication is possible.</source>
          <target state="translated">此状态类似于&lt;a href=&quot;403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt;，但是在这种情况下，可以进行身份​​验证。</target>
        </trans-unit>
        <trans-unit id="d740e14cfb624c7102c236e54e55ea5db95b95e3" translate="yes" xml:space="preserve">
          <source>This technique does work for internal links, but try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request occurs). If you can avoid it by correcting internal links, you should fix those links instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be28e288a13627a68b1784eb600b0e65cfd5a0de" translate="yes" xml:space="preserve">
          <source>This technique has an additional benefit: updating two cached resources at the same time will not lead to the situation where the out-dated version of one resource is used in combination with the new version of the other one. This is very important when web sites have CSS stylesheets or JS scripts that have mutual dependencies, i.e., they depend on each other because they refer to the same HTML elements.</source>
          <target state="translated">这种技术还有一个好处:同时更新两个缓存资源,不会导致一个资源的过时版本与另一个资源的新版本结合使用的情况。当网站的CSS样式表或JS脚本具有相互依赖性时,这一点非常重要,即它们相互依赖,因为它们引用了相同的HTML元素。</target>
        </trans-unit>
        <trans-unit id="3aeab72cfc99a5f7f9ea4900285e4bd674414a02" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt;&lt;code&gt;network.http.accept.default&lt;/code&gt;&lt;/a&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">可以使用&lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt; &lt;code&gt;network.http.accept.default&lt;/code&gt; &lt;/a&gt;参数修改此值。&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;资源&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a0945e40dcef867b66faa0e27a1bd4227d6481c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l3779&quot;&gt;source&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7de26255283cc9167d1e4ab5cca6cdf380b11c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">可以使用 &lt;code&gt;image.http.accept&lt;/code&gt; 参数修改此值。&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;资源&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b50b2cc5848103a486b6389534eb105140db6ea" translate="yes" xml:space="preserve">
          <source>This will lead to a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="translated">这将导致客户端和服务器之间的简单交换,使用CORS头来处理权限。</target>
        </trans-unit>
        <trans-unit id="81a97739f75df445cadaa8f98d4fa5c5bdf3f859" translate="yes" xml:space="preserve">
          <source>This works roughly the same way as a client-initiated upgrade; an optional upgrade is requested by adding the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header to any message. A mandatory upgrade, though, works slightly differently, in that it requests the upgrade by replying to a message it receives with the &lt;a href=&quot;status/426&quot;&gt;&lt;code&gt;426&lt;/code&gt;&lt;/a&gt; status code, like this:</source>
          <target state="translated">这与客户端启动的升级大致相同。通过将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头添加到任何消息来请求可选升级。但是，强制升级的工作方式略有不同，因为它通过回复收到的带有&lt;a href=&quot;status/426&quot;&gt; &lt;code&gt;426&lt;/code&gt; &lt;/a&gt;状态代码的消息来请求升级，如下所示：</target>
        </trans-unit>
        <trans-unit id="fa3701a77f1cf83ff8e3fe524326c23f848bc1ab" translate="yes" xml:space="preserve">
          <source>This would allow CORS requests from Mozilla, Google, Microsoft, and Apple's domains.</source>
          <target state="translated">这将允许来自Mozilla、谷歌、微软和苹果的域名的CORS请求。</target>
        </trans-unit>
        <trans-unit id="a59129b8ca208dcde27e54fb7891ca5c8b965bb9" translate="yes" xml:space="preserve">
          <source>Though Feature Policy provides control of multiple features using a consistent syntax, the behavior of policy controlled features varies and depends on several factors.</source>
          <target state="translated">虽然特征策略使用一致的语法提供了对多个特征的控制,但策略控制的特征的行为是不同的,并取决于几个因素。</target>
        </trans-unit>
        <trans-unit id="35b0c32c11633fd5293f1721594a37c0441531d3" translate="yes" xml:space="preserve">
          <source>Though HTTP/2 adds some complexity, by embedding HTTP messages in frames to improve performance, the basic structure of messages has stayed the same since HTTP/1.0. Session flow remains simple, allowing it to be investigated, and debugged with a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP message monitor&lt;/a&gt;.</source>
          <target state="translated">尽管HTTP / 2增加了一些复杂性，但通过将HTTP消息嵌入帧中以提高性能，消息的基本结构自HTTP / 1.0起一直保持不变。会话流保持简单，可以对其进行调查，并使用简单的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP消息监视器进行&lt;/a&gt;调试。</target>
        </trans-unit>
        <trans-unit id="9a15157e510ae4fb6f9c552a8502c5d3c090f5d9" translate="yes" xml:space="preserve">
          <source>Though fixed in Firefox 69, previous 32-bit versions of Firefox running on 64-bit processors would report that the system is using a 32-bit CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1440c92eaa6c1b3552c42a43600691971d67871" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; is not supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6645a896cbe79649d39568f2032a9ab20c38bc" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">尽管&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;指令旨在替换不推荐使用的 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令，但大多数浏览器尚不支持&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;。因此，为了与当前浏览器兼容，同时在浏览器获得&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;支持时增加前向兼容性，可以同时指定 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 和&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="2d2996b4c0f8fba5d4ab332690b5f78e0e30f92d" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">尽管&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;指令旨在替换不推荐使用的 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令，但大多数浏览器尚不支持&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;。因此，为了与当前浏览器兼容，同时在浏览器获得&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;支持时增加前向兼容性，可以同时指定 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 和&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0c3769f4cf6b7264f228cc766b7de9065e61137e" translate="yes" xml:space="preserve">
          <source>Though there are legitimate uses of this header for selecting content, &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;it is considered bad practice&lt;/a&gt; to rely on it to define what features are supported by the user agent.</source>
          <target state="translated">尽管此标头用于选择内容有合法用途，&lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;但&lt;/a&gt;依靠它定义用户代理支持哪些功能被认为是一种不好的做法。</target>
        </trans-unit>
        <trans-unit id="b228606ae426f931604823fecbe96f6aa2850ab0" translate="yes" xml:space="preserve">
          <source>Threats</source>
          <target state="translated">Threats</target>
        </trans-unit>
        <trans-unit id="02283ca03b246291fac06381aab094d267592b90" translate="yes" xml:space="preserve">
          <source>Tighter Control Over Your Referrers &amp;ndash; Mozilla Security Blog</source>
          <target state="translated">严格控制引荐来源&amp;ndash; Mozilla安全博客</target>
        </trans-unit>
        <trans-unit id="7197d879754a435ef6abdac823a28530b7748197" translate="yes" xml:space="preserve">
          <source>Time based conditions</source>
          <target state="translated">基于时间的条件</target>
        </trans-unit>
        <trans-unit id="d21434199b502487596cffe0f83fce73f8fae46d" translate="yes" xml:space="preserve">
          <source>TimeOut = &quot;Timeout&quot; &quot;:&quot; 1#TimeType
      TimeType = (&quot;Second-&quot; DAVTimeOutVal | &quot;Infinite&quot;)
                 ; No LWS allowed within TimeType
      DAVTimeOutVal = 1*DIGIT

   Clients MAY include Timeout request headers in their LOCK requests.
   However, the server is not required to honor or even consider these
   requests.  Clients MUST NOT submit a Timeout request header with any
   method other than a LOCK method.

   The &quot;Second&quot; TimeType specifies the number of seconds that will
   elapse between granting of the lock at the server, and the automatic
   removal of the lock.  The timeout value for TimeType &quot;Second&quot; MUST
   NOT be greater than 2^32-1.

   See &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt; for a description of lock timeout behavior.</source>
          <target state="translated">TimeOut =&amp;ldquo; Timeout&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃TimeType TimeType =（&amp;ldquo; Second-&amp;rdquo; DAVTimeOutVal |&amp;ldquo; Infinite&amp;rdquo;）; TimeType DAVTimeOutVal = 1 * DIGIT内不允许的LWS客户端可以在其LOCK请求中包括超时请求标头。但是，不需要服务器满足或什至考虑这些请求。客户端不得使用LOCK方法以外的任何方法提交超时请求标头。 &amp;ldquo;第二&amp;rdquo; TimeType指定在服务器上授予锁与自动删除锁之间经过的秒数。 TimeType&amp;ldquo; Second&amp;rdquo;的超时值一定不能大于2 ^ 32-1。有关锁定超时行为的说明，请参见&lt;a href=&quot;#section-6.6&quot;&gt;第6.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bbd92323b129c3217bf6942ecefc96c45003532" translate="yes" xml:space="preserve">
          <source>Timing-Allow-Origin</source>
          <target state="translated">Timing-Allow-Origin</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="6916244a87f04cf740dd467f9478fda4624dfa30" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI
   of the Collection.

   Successful member creation is indicated with a 201 (&quot;Created&quot;)
   response code.  When the Collection responds with a status code of
   201, it SHOULD also return a response body, which MUST be an Atom
   Entry Document representing the newly created Resource.  Since the
   server is free to alter the POSTed Entry, for example, by changing
   the content of the atom:id element, returning the Entry can be useful
   to the client, enabling it to correlate the client and server views
   of the new Entry.

   When a Member Resource is created, its Member Entry URI MUST be
   returned in a Location header in the Collection's response. 

   If the creation request contained an Atom Entry Document, and the
   subsequent response from the server contains a Content-Location
   header that matches the Location header character-for-character, then
   the client is authorized to interpret the response entity as being a
   complete representation of the newly created Entry.  Without a
   matching Content-Location header, the client MUST NOT assume the
   returned entity is a complete representation of the created Resource.

   The request body sent with the POST need not be an Atom Entry.  For
   example, it might be a picture or a movie.  Collections MAY return a
   response with a status code of 415 (&quot;Unsupported Media Type&quot;) to
   indicate that the media type of the POSTed entity is not allowed or
   supported by the Collection.  For a discussion of the issues in
   creating such content, see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.</source>
          <target state="translated">要将成员添加到集合，客户端将POST请求发送到集合的URI。成功创建成员时将显示201（&amp;ldquo;已创建&amp;rdquo;）响应代码。当集合以状态码201响应时，它还应该返回一个响应主体，该主体必须是代表新创建的资源的Atom Entry文档。由于服务器可以自由地更改POSTed条目，例如，通过更改atom：id元素的内容，因此返回条目对客户端可能是有用的，从而使其能够关联新条目的客户端和服务器视图。创建成员资源后，其成员条目URI必须在集合响应的Location标头中返回。如果创建请求包含Atom进入文档，并且服务器的后续响应中包含一个Content-Location标头，该Content-Location标头与字符的Location标头匹配，然后授权客户端将响应实体解释为新创建的Entry的完整表示。如果没有匹配的Content-Location标头，则客户端不得假定返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见看到看到然后授权客户将响应实体解释为新创建条目的完整表示。如果没有匹配的Content-Location标头，则客户端不得假定返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见然后授权客户将响应实体解释为新创建条目的完整表示。如果没有匹配的Content-Location标头，则客户端不得假定返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见客户端不得假设返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见客户端不得假定返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见），以指示Collection不允许或支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见），以指示Collection不允许或支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见&lt;a href=&quot;#section-9.6&quot;&gt;9.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="386b4890041dd717ecf8b7b91609bc0b0530ef7e" translate="yes" xml:space="preserve">
          <source>To additionally expose a custom header, like &lt;code&gt;X-Kuma-Revision&lt;/code&gt;, you can specify multiple headers separated by a comma:</source>
          <target state="translated">要另外公开自定义标头（如 &lt;code&gt;X-Kuma-Revision&lt;/code&gt; )，可以指定多个标头，并用逗号分隔：</target>
        </trans-unit>
        <trans-unit id="a180bdbe7008f814531ba52754a31bdde24cb15f" translate="yes" xml:space="preserve">
          <source>To allow &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; to see timing resources, you can specify:</source>
          <target state="translated">要允许 &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; 查看计时资源，可以指定：</target>
        </trans-unit>
        <trans-unit id="ac82a05a9215546227ac811284787b043b688757" translate="yes" xml:space="preserve">
          <source>To allow any resource to see timing resources:</source>
          <target state="translated">要允许任何资源看到定时资源。</target>
        </trans-unit>
        <trans-unit id="de9aa903d9e34061f0b89ba2ccd4efede6a71126" translate="yes" xml:space="preserve">
          <source>To allow any site to make CORS requests &lt;em&gt;without&lt;/em&gt; using the &lt;code&gt;*&lt;/code&gt; wildcard (for example, to enable credentials), your server must read the value of the request's &lt;code&gt;Origin&lt;/code&gt; header and use that value to set &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, and must also set a &lt;code&gt;Vary: Origin&lt;/code&gt; header to indicate that some headers are being set dynamically depending on the origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed12e1286c2fe40563eb11b075acdb101da5456e" translate="yes" xml:space="preserve">
          <source>To allow inline scripts and inline event handlers, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">为了允许内联脚本和内联事件处理程序，可以指定 &lt;code&gt;'unsafe-inline'&lt;/code&gt; ，与内联块匹配的nonce-source或hash-source。</target>
        </trans-unit>
        <trans-unit id="f0269ea1c1b256b968def48a5f2f52309ec5262a" translate="yes" xml:space="preserve">
          <source>To allow inline styles, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">要允许内联样式，可以指定 &lt;code&gt;'unsafe-inline'&lt;/code&gt; ，与内联块匹配的nonce-source或hash-source。</target>
        </trans-unit>
        <trans-unit id="13976356a231a259baf5887e2defcf39ece5cf88" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a directory or only certain pages, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf2613fc6493f70145cca53cbfd72435e9e8e80" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a folder or a subset of the pages only, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="translated">要将重定向仅应用于文件夹或页面的子集，请使用 &lt;code&gt;rewrite&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="bb7179c9bb0b7e4c55288f5bc188620cf66f5d11" translate="yes" xml:space="preserve">
          <source>To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. That is, the default allowlist is &lt;code&gt;'*'&lt;/code&gt; for each feature. Preventing the use of the sub-optimal functionality requires explicitly specifying a policy that disables the features.</source>
          <target state="translated">为避免破坏现有的Web内容，此类策略控制功能的默认设置是允许所有来源使用该功能。也就是说，每个功能的默认允许列表为 &lt;code&gt;'*'&lt;/code&gt; 。禁止使用次优功能需要明确指定禁用功能的策略。</target>
        </trans-unit>
        <trans-unit id="4241af7f93eeeca05ab65287e814f22f52b1e121" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary requests and duplicated cache entries, caching servers should use &lt;strong&gt;normalization &lt;/strong&gt;to pre-process the request and cache only files that are needed. For example, in the case of &lt;code&gt;Accept-Encoding&lt;/code&gt; you could check for &lt;code&gt;gzip&lt;/code&gt; and other compression types in the header before doing further processing, and otherwise unset the header. In &quot;pseudo code&quot; this might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23e40255a27317ad4c5e7988f79e6d83e22e91b" translate="yes" xml:space="preserve">
          <source>To check if cross origin isolation has been successful, you can test against the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/crossOriginIsolated&quot;&gt;crossOriginIsolated&lt;/a&gt;&lt;/code&gt; property available to window and worker contexts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87498cccdcb4487afbcf49b5c7bb695ac3af44f7" translate="yes" xml:space="preserve">
          <source>To check if cross-origin isolation has been successful, you can test against the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/crossOriginIsolated&quot;&gt;crossOriginIsolated&lt;/a&gt;&lt;/code&gt; property available to window and worker contexts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa4823e36d63b17b94087b674887608e0551a24" translate="yes" xml:space="preserve">
          <source>To configure Apache to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header for all pages, add this to your site's configuration:</source>
          <target state="translated">要将Apache配置为发送所有页面的 &lt;code&gt;X-Frame-Options&lt;/code&gt; 标头，请将其添加到站点的配置中：</target>
        </trans-unit>
        <trans-unit id="ed88de8ec706b4b0a28b855a26786e3ee2a0c543" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; DENY, add this to your site's configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80d381b0c7feec0a158d29c3338a640577b5bd0" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; deny , add this to your site's configuration:</source>
          <target state="translated">要将Apache配置为设置 &lt;code&gt;X-Frame-Options&lt;/code&gt; deny，请将其添加到站点的配置中：</target>
        </trans-unit>
        <trans-unit id="b534ad3f3a442c64de937628acf24797af926fef" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; to &lt;code&gt;allow-from&lt;/code&gt; a specific Host , add this to your site's configuration:</source>
          <target state="translated">要将Apache配置 &lt;code&gt;allow-from&lt;/code&gt; 特定主机将 &lt;code&gt;X-Frame-Options&lt;/code&gt; 设置为allow，请将其添加到站点的配置中：</target>
        </trans-unit>
        <trans-unit id="c6efccd4af9ebeaf527c38eab55daa0481a50728" translate="yes" xml:space="preserve">
          <source>To configure Express to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, you can use &lt;a href=&quot;https://helmetjs.github.io/&quot;&gt;helmet&lt;/a&gt; which uses &lt;a href=&quot;https://helmetjs.github.io/docs/frameguard/&quot;&gt;frameguard&lt;/a&gt; to set the header. Add this to your server configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845c7d45d2e5670380ce094b42f8d93ca377f4d0" translate="yes" xml:space="preserve">
          <source>To configure HAProxy to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your front-end, listen, or backend configuration:</source>
          <target state="translated">要将HAProxy配置为发送 &lt;code&gt;X-Frame-Options&lt;/code&gt; 标头，请将其添加到前端，侦听或后端配置中：</target>
        </trans-unit>
        <trans-unit id="d8ead758c64a8732b962f9c079ccbcb8977cec05" translate="yes" xml:space="preserve">
          <source>To configure IIS to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your site's &lt;code&gt;Web.config&lt;/code&gt; file:</source>
          <target state="translated">要将IIS配置为发送 &lt;code&gt;X-Frame-Options&lt;/code&gt; 标头，请将其添加到站点的 &lt;code&gt;Web.config&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="40d91183fa2ac507cab6f74e7d193a9cc7597506" translate="yes" xml:space="preserve">
          <source>To configure nginx to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this either to your http, server or location configuration:</source>
          <target state="translated">要将nginx配置为发送 &lt;code&gt;X-Frame-Options&lt;/code&gt; 标头，请将其添加到http，服务器或位置配置中：</target>
        </trans-unit>
        <trans-unit id="f87ea35dcc44f41e60725e0641384c547d99d798" translate="yes" xml:space="preserve">
          <source>To correct this problem on the client side, simply ensure that the credentials flag's value is &lt;code&gt;false&lt;/code&gt; when issuing your CORS request.</source>
          <target state="translated">要在客户端纠正此问题，只需在发出CORS请求时确保凭据标志的值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d348d55722c44b500e4b7059e9ff9d2fa1dddb00" translate="yes" xml:space="preserve">
          <source>To delete a Member Resource, a client sends a DELETE request to its
   Member URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The deletion of a Media Link
   Entry SHOULD result in the deletion of the corresponding Media
   Resource.</source>
          <target state="translated">要删除成员资源，客户端将向其成员URI发送DELETE请求，如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中所指定。媒体链接条目的删除应该导致相应媒体资源的删除。</target>
        </trans-unit>
        <trans-unit id="72f4f993e89f8fbf65e0d29a84346e687a67b7ba" translate="yes" xml:space="preserve">
          <source>To disable caching of a resource, you can send the following response header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d139058a76ad3d2cff70e2b313580511ed4b4b" translate="yes" xml:space="preserve">
          <source>To disallow all plugins, the &lt;a href=&quot;object-src&quot;&gt;&lt;code&gt;object-src&lt;/code&gt;&lt;/a&gt; directive should be set to &lt;code&gt;'none'&lt;/code&gt; which will disallow plugins. The &lt;code&gt;plugin-types&lt;/code&gt; directive is only used if you are allowing plugins with &lt;code&gt;object-src&lt;/code&gt; at all.</source>
          <target state="translated">要禁止所有插件，应将&lt;a href=&quot;object-src&quot;&gt; &lt;code&gt;object-src&lt;/code&gt; &lt;/a&gt;指令设置为 &lt;code&gt;'none'&lt;/code&gt; ，这将禁止插件。该 &lt;code&gt;plugin-types&lt;/code&gt; ，如果您允许使用插件指令仅用于 &lt;code&gt;object-src&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="92b682f994622384b1029f2cc2b8c3099145173c" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &quot;https:&quot;. For example, to disallow insecure http images:</source>
          <target state="translated">要在更细的层面上禁止http资产,你也可以将单个指令设置为 &quot;https:&quot;。例如,要禁止不安全的http图片。</target>
        </trans-unit>
        <trans-unit id="a213397329a4dbbb753416e90e80c6286443a758" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &lt;code&gt;https:&lt;/code&gt;. For example, to disallow nonsecure HTTP images:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76414f91106f2a76e27289d53511ec4aff7ac9a8" translate="yes" xml:space="preserve">
          <source>To do this, HTTP uses a mechanism similar to the content negotiation for end-to-end compression: the node transmitting the request advertizes its will using the &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; header and the other node chooses the adequate method, applies it, and indicates its choice with the &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">为此，HTTP使用类似于内容协商的机制进行端到端压缩：传输请求的节点使用&lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;头广告其意愿，另一个节点选择适当的方法，应用该方法，并用的&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;报头。</target>
        </trans-unit>
        <trans-unit id="2695ec4a2bbfc44084d656ae8935110af8816675" translate="yes" xml:space="preserve">
          <source>To ease deployment, CSP can be deployed in report-only mode. The policy is not enforced, but any violations are reported to a provided URI. Additionally, a report-only header can be used to test a future revision to a policy without actually deploying it.</source>
          <target state="translated">为了便于部署,CSP可以在仅报告模式下部署。策略不会被强制执行,但任何违规行为都会被报告到提供的URI中。此外,只报告头可以用来测试未来对策略的修订,而无需实际部署。</target>
        </trans-unit>
        <trans-unit id="75b596875abd418e26e2741605ac5a556d421f5c" translate="yes" xml:space="preserve">
          <source>To edit a Member Resource, a client sends a PUT request to its Member
   URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   To avoid unintentional loss of data when editing Member Entries or
   Media Link Entries, an Atom Protocol client SHOULD preserve all
   metadata that has not been intentionally modified, including unknown
   foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">要编辑成员资源，客户端将PUT请求发送到其成员URI，如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中所指定。为了避免在编辑成员条目或媒体链接条目时意外丢失数据，Atom协议客户端应保留所有未经有意修改的元数据，包括&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]第6节中&lt;/a&gt;定义的未知外部标记。</target>
        </trans-unit>
        <trans-unit id="65a702b04aa6a54fd3c8430997ab1bc38d37ad8c" translate="yes" xml:space="preserve">
          <source>To eliminate this error by changing the server's configuration, adjust the server's configuration to set the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header's value to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">要通过更改服务器的配置来消除此错误，请调整服务器的配置以将 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 标头的值设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfa8844d0259c7d70df5b60e696f31e2bbcd03c1" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header (sometimes you will see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore).</source>
          <target state="translated">要启用CSP，您需要配置Web服务器以返回&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP标头（有时您会看到 &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; 标头的提法，但这是一个较旧的版本，不需要再指定一次）。</target>
        </trans-unit>
        <trans-unit id="19b1b9201d67c0e13d81834b3ed7b51ae71bba12" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header. (Sometimes you may see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9df87dcc5fcb972c46f913809c87fec6f3d341b" translate="yes" xml:space="preserve">
          <source>To enable this feature for your site, you need to return the &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; HTTP header when your site is accessed over HTTPS:</source>
          <target state="translated">要为您的站点启用此功能，当通过HTTPS访问站点时，您需要返回&lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; HTTP标头：</target>
        </trans-unit>
        <trans-unit id="d7620e1e33a6d347685e1ebb3aa8b33714970a09" translate="yes" xml:space="preserve">
          <source>To ensure the authenticity of a server's public key used in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; sessions, this public key is wrapped into a X.509 certificate which is usually signed by a certificate authority (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;). Web clients such as browsers trust a lot of these CAs, which can all create certificates for arbitrary domain names. If an attacker is able to compromise a single CA, they can perform MITM attacks on various TLS connections. HPKP can circumvent this threat for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; protocol by telling the client which public key belongs to a certain web server.</source>
          <target state="translated">为了确保&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;会话中使用的服务器公钥的真实性，此公钥被包装到X.509证书中，该证书通常由证书颁发机构（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;）签名。浏览器之类的Web客户端信任许多这样的CA，它们都可以为任意域名创建证书。如果攻击者能够入侵单个CA，则他们可以对各种TLS连接执行MITM攻击。 HPKP可以通过告诉客户端哪个公钥属于某个Web服务器来规避&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;协议的这种威胁。</target>
        </trans-unit>
        <trans-unit id="bb1ec08765a8cde8081dbd27d2c650bba3f705fa" translate="yes" xml:space="preserve">
          <source>To expose a non-CORS-safelisted request header, you can specify:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9c68887239fed95f26110a7e627ff78bd12cc1" translate="yes" xml:space="preserve">
          <source>To expose a non-simple response header, you can specify:</source>
          <target state="translated">要暴露一个非简单的响应头,你可以指定。</target>
        </trans-unit>
        <trans-unit id="c49b225b0a37fb347c33ef070bf2b8ce3177f370" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;) response headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0114a346ce11f11d1f933758ffbbdf2f5442cd43" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for CORS) response headers.</source>
          <target state="translated">要确定服务器是否支持 &lt;code&gt;PATCH&lt;/code&gt; ，服务器可以通过将其添加到&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;（对于CORS）响应标头中的列表中来通告其支持。</target>
        </trans-unit>
        <trans-unit id="f3e43c65e3e2914cd34ba18edec78bc17058b478" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use curl and issue an OPTIONS request:</source>
          <target state="translated">要想知道服务器支持哪些请求方式,可以使用curl并发出options请求。</target>
        </trans-unit>
        <trans-unit id="94a06678a04eb20207fc7bb6378a7dadaf3ba84d" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use the &lt;code&gt;curl&lt;/code&gt; command-line program to issue an &lt;code&gt;OPTIONS&lt;/code&gt; request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e18f6487121f857662c6a85c3a47051c59f1876" translate="yes" xml:space="preserve">
          <source>To fix the problem, update your code to use the new URL as reported by the redirect, thereby avoiding the redirect.</source>
          <target state="translated">要解决这个问题,请更新您的代码,使用重定向报告的新URL,从而避免重定向。</target>
        </trans-unit>
        <trans-unit id="32dbd3b679bd14efe132327b76684a2c87a18ba4" translate="yes" xml:space="preserve">
          <source>To fix this problem on the client side, revise the code to not request the use of credentials.</source>
          <target state="translated">为了解决客户端的这个问题,修改代码,不要求使用凭证。</target>
        </trans-unit>
        <trans-unit id="35039835a23cd330912a1e328fb92250be4508c7" translate="yes" xml:space="preserve">
          <source>To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIs, Web Fonts (&lt;code&gt;@font-face&lt;/code&gt;), and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL&quot;&gt;WebGL textures&lt;/a&gt;, and XSL stylesheets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2617321bfe1280098dd397ad19ede4778814a0fc" translate="yes" xml:space="preserve">
          <source>To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS.</source>
          <target state="translated">要解决这个问题,只需确保在发出涉及CORS的请求时使用HTTPS URL即可。</target>
        </trans-unit>
        <trans-unit id="f21f1534d5e4a79d894d05095d228a6afa694b9f" translate="yes" xml:space="preserve">
          <source>To fix this, you will have to add the &lt;code&gt;Secure&lt;/code&gt; attribute to your &lt;code&gt;SameSite=None&lt;/code&gt; cookies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15680ede5ec99b5956f1bf553d855c87853f86ba" translate="yes" xml:space="preserve">
          <source>To have a server check the request's headers, a client must send &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: 100-continue&lt;/code&gt; as a header in its initial request and receive a &lt;code&gt;100 Continue&lt;/code&gt; status code in response before sending the body.</source>
          <target state="translated">要让服务器检查请求的标头，客户端必须在其初始请求中发送&lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: 100-continue&lt;/code&gt; 作为标头，并在发送正文之前收到 &lt;code&gt;100 Continue&lt;/code&gt; 状态码作为响应。</target>
        </trans-unit>
        <trans-unit id="a8e97e24a55d2464483db3779fca7d3ac69353bb" translate="yes" xml:space="preserve">
          <source>To list the Members of a Collection, the client sends a GET request
   to the URI of a Collection.  An Atom Feed Document is returned whose
   Entries contain the IRIs of Member Resources.  The returned Feed may
   describe all, or only a partial list, of the Members in a Collection
   (see &lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;).

   Client                          Server
     |                                |
     |  1.) GET to Collection URI     |
     |-------------------------------&amp;gt;|
     |                                |
     |  2.) 200 Ok                    |
     |      Atom Feed Document        |
     |&amp;lt;-------------------------------|
     |                                |

   1.  The client sends a GET request to the URI of the Collection.

   2.  The server responds with an Atom Feed Document containing the
       IRIs of the Collection Members.</source>
          <target state="translated">要列出集合的成员，客户端将GET请求发送到集合的URI。返回一个Atom Feed文档，其条目包含成员资源的IRI。返回的Feed可能会描述集合中所有或部分成员列表（请参阅&lt;a href=&quot;#section-10&quot;&gt;第10节）&lt;/a&gt;）。客户端服务器| | | 1.）GET to Collection URI | | -------------------------------&amp;gt; | | | | 2.）200好| | Atom Feed文档| | &amp;lt;------------------------------- | | | 1.客户端将GET请求发送到集合的URI。2.服务器以Atom Feed文档作为响应，其中包含Collection成员的IRI。</target>
        </trans-unit>
        <trans-unit id="40d4be7657f2f51d2de5be0cbaac7191b3c8a653" translate="yes" xml:space="preserve">
          <source>To load an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; you must specify &lt;code&gt;application/x-java-applet&lt;/code&gt;:</source>
          <target state="translated">要加载&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;，必须指定 &lt;code&gt;application/x-java-applet&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8d201d9342cffef73d7a41bc9cba81a23914667e" translate="yes" xml:space="preserve">
          <source>To password-protect a directory on an Apache server, you will need a &lt;code&gt;.htaccess&lt;/code&gt; and a &lt;code&gt;.htpasswd&lt;/code&gt; file.</source>
          <target state="translated">要用密码保护Apache服务器上的目录，您将需要一个 &lt;code&gt;.htaccess&lt;/code&gt; 文件和一个 &lt;code&gt;.htpasswd&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="2b1b9e12e5ed28875fdd87d9931a916a268928e4" translate="yes" xml:space="preserve">
          <source>To present a Web page, the browser sends an original request to fetch the HTML document from the page. It then parses this file, fetching additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</source>
          <target state="translated">为了呈现一个网页,浏览器会发送一个原始请求,从网页中获取HTML文件。然后,它对这个文件进行解析,获取与执行脚本、要显示的布局信息(CSS)以及页面中包含的子资源(通常是图片和视频)相对应的附加请求。然后,Web浏览器将这些资源混合在一起,向用户呈现一个完整的文档,即网页。浏览器执行的脚本可以在后期获取更多的资源,浏览器也会相应地更新网页。</target>
        </trans-unit>
        <trans-unit id="9e60dfe4ac6141599165a832cd24e1d13bc8342c" translate="yes" xml:space="preserve">
          <source>To present a Web page, the browser sends an original request to fetch the HTML document that represents the page. It then parses this file, making additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc3791377cf289d3e10d82216c0c34f70d22305" translate="yes" xml:space="preserve">
          <source>To prevent cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks, &lt;code&gt;HttpOnly&lt;/code&gt; cookies are inaccessible to JavaScript's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; API; they are only sent to the server. For example, cookies that persist server-side sessions don't need to be available to JavaScript, and the &lt;code&gt;HttpOnly&lt;/code&gt; flag should be set.</source>
          <target state="translated">为了防止跨站点脚本（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）攻击，JavaScript的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; API 无法访问 &lt;code&gt;HttpOnly&lt;/code&gt; cookie ；它们仅发送到服务器。例如，持久化服务器端会话的cookie不需要对JavaScript可用，并且应该设置 &lt;code&gt;HttpOnly&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="72ede2114830d9b5c365d2af6457cc4237ba98cd" translate="yes" xml:space="preserve">
          <source>To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation on the server side, allowing a document to become a patchwork of information sourced from different domains; there could even be security-related reasons to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da58d84bcbf609daa347015eaf4c1596d9aec024" translate="yes" xml:space="preserve">
          <source>To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation server-side, allowing a document to become a patchwork of information sourced from different domains (there could even be security-related reasons to do so).</source>
          <target state="translated">为了防止监听和其他隐私入侵，Web浏览器在网站之间强制严格隔离。只有具有&lt;strong&gt;相同来源的&lt;/strong&gt;页面才能访问网页的所有信息。尽管这种约束是服务器的负担，但是HTTP标头可以放松服务器端的严格分隔，使文档成为来自不同域的信息的拼凑而成（这样做甚至可能与安全性相关）。</target>
        </trans-unit>
        <trans-unit id="6fdb9fa15e3fd167189ceff75fae693acf53ca4b" translate="yes" xml:space="preserve">
          <source>To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</source>
          <target state="translated">为防止这种情况，将使用条件请求。对于范围，有两种方法可以执行此操作。一种更灵活的方法是使用&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;，如果前提条件失败，服务器将返回错误；否则，服务器将返回错误。然后客户端从头开始重新下载：</target>
        </trans-unit>
        <trans-unit id="51d6446ef1d59700324bbaf38bfb84d4a066a702" translate="yes" xml:space="preserve">
          <source>To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae0931ca2f4a9bdada593d70fdcc9e0e5795272" translate="yes" xml:space="preserve">
          <source>To provide information about the proxy itself (not about the client connecting to it), the &lt;code&gt;Via&lt;/code&gt; header can be used.</source>
          <target state="translated">要提供有关代理本身的信息（而不是有关连接到它的客户端的信息），可以使用 &lt;code&gt;Via&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="39f35e596ed723bf2514b5c1b49a714286137491" translate="yes" xml:space="preserve">
          <source>To request a mandatory upgrade to TLS&amp;mdash;that is, to upgrade and fail the connection if the upgrade is not successful&amp;mdash;your first request must be an &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request, like this:</source>
          <target state="translated">要请求强制升级到TLS（即，如果升级不成功，则升级并导致连接失败），您的第一个请求必须是&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;请求，例如：</target>
        </trans-unit>
        <trans-unit id="0ac4a6a255bea42439869af2e4020d47f12f5638" translate="yes" xml:space="preserve">
          <source>To see stored cookies (and other storage that a web page can use), you can enable the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&quot;&gt;Storage Inspector&lt;/a&gt; in Developer Tools and select Cookies from the storage tree.</source>
          <target state="translated">要查看存储的cookie（以及网页可以使用的其他存储），可以在Developer Tools中启用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&quot;&gt;Storage Inspector&lt;/a&gt;，然后从存储树中选择Cookies。</target>
        </trans-unit>
        <trans-unit id="bc330ab165d9d2700ffdde233d29f19baad1a79d" translate="yes" xml:space="preserve">
          <source>To select the algorithm to use, browsers and servers use &lt;a href=&quot;content_negotiation&quot;&gt;proactive content negotiation&lt;/a&gt;. The browser sends an &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header with the algorithm it supports and its order of precedence, the server picks one, uses it to compress the body of the response and uses the &lt;a href=&quot;headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; header to tell the browser the algorithm it has chosen. As content negotiation has been used to choose a representation based on its encoding, the server must send a &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header containing at least &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; alongside this header in the response; that way, caches will be able to cache the different representations of the resource.</source>
          <target state="translated">为了选择要使用的算法，浏览器和服务器使用&lt;a href=&quot;content_negotiation&quot;&gt;主动内容协商&lt;/a&gt;。浏览器发送带有其支持的算法及其优先级顺序的&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;标头，服务器选择一个，使用它压缩响应的正文，并使用&lt;a href=&quot;headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;标头将其选择的算法告诉浏览器。由于已经使用内容协商来选择基于其编码的表示形式，因此服务器必须在响应中在该标头旁边发送至少包含&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;标头；这样，缓存将能够缓存资源的不同表示形式。</target>
        </trans-unit>
        <trans-unit id="634a9fb6a29c3c70ac67df06d1d205bf0ae96039" translate="yes" xml:space="preserve">
          <source>To set allowed types for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, use the &lt;a href=&quot;plugin-types&quot;&gt;&lt;code&gt;plugin-types&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">要为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素设置允许的类型，请使用&lt;a href=&quot;plugin-types&quot;&gt; &lt;code&gt;plugin-types&lt;/code&gt; &lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="1df8505922402bf519c64877c4fe5b468a0d15a0" translate="yes" xml:space="preserve">
          <source>To turn off caching, you can send the following response header. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Pragma&lt;/code&gt; headers.</source>
          <target state="translated">要关闭缓存，您可以发送以下响应头。此外，另请参见 &lt;code&gt;Expires&lt;/code&gt; 和 &lt;code&gt;Pragma&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="dd73224596457324eeb7f6a3787968a990efcb06" translate="yes" xml:space="preserve">
          <source>To turn on the enforcement of all the best practices, specify the policy as below.</source>
          <target state="translated">要开启所有最佳做法的执行,请指定以下政策。</target>
        </trans-unit>
        <trans-unit id="e986abf32e5ea3dcadc05857dd5f7dc3d3e31912" translate="yes" xml:space="preserve">
          <source>To understand the underlying issue with the CORS configuration, you need to find out which request is at fault and why. These steps may help you do so:</source>
          <target state="translated">要了解CORS配置的根本问题,您需要找出哪个请求出了问题以及原因。这些步骤可能会帮助你做到这一点。</target>
        </trans-unit>
        <trans-unit id="a5de27ea55a3c3a2648dd523ae819b4dad29f351" translate="yes" xml:space="preserve">
          <source>To upgrade to TLS optionally (that is, allowing the connection to continue in cleartext if the upgrade to TLS fails), you simply use the &lt;code&gt;Upgrade&lt;/code&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers as expected. For example, given the original request:</source>
          <target state="translated">要可选地升级到TLS（即，如果升级到TLS失败，则允许连接以明文形式继续），您只需按预期使用 &lt;code&gt;Upgrade&lt;/code&gt; 和&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头。例如，给定原始请求：</target>
        </trans-unit>
        <trans-unit id="044deb9959ba1185df13d8adce29060324260efa" translate="yes" xml:space="preserve">
          <source>Today, every HTTP/1.1-compliant proxy and server should support pipelining, though many have limitations in practice: a significant reason no modern browser activates this feature by default.</source>
          <target state="translated">今天,每个符合HTTP/1.1标准的代理和服务器都应该支持管道化,尽管许多代理和服务器在实践中都有局限性:一个重要的原因是没有现代浏览器默认激活这个功能。</target>
        </trans-unit>
        <trans-unit id="e354edd2f2d8086de47823e3cb62b62a590f4266" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;&lt;strong&gt;&lt;a href=&quot;require-trusted-types-for&quot;&gt;require-trusted-types-for&lt;/a&gt;&lt;/strong&gt;&lt;/code&gt; directive, this allows authors to define rules guarding writing values to the DOM and thus reducing the DOM XSS attack surface to small, isolated parts of the web application codebase, facilitating their monitoring and code review. This directive declares an allow-list of trusted type policy names created with &lt;code&gt;TrustedTypes.createPolicy&lt;/code&gt; from Trusted Types API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33aad73dfe686c313271fd5a3616235aaa85ae94" translate="yes" xml:space="preserve">
          <source>Together with the resource, the validators are sent in the headers. In this example, both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; are sent, but it could equally have been only one of them. These validators are cached with the resource (like all headers) and will be used to craft conditional requests, once the cache becomes stale.</source>
          <target state="translated">验证器与资源一起在标头中发送。在此示例中，&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;均被发送，但同样可能只是其中之一。这些验证器与资源一起缓存（就像所有标头一样），并且一旦缓存失效，就将用于生成条件请求。</target>
        </trans-unit>
        <trans-unit id="0525ab49d332c5db40375b0a9f6ea89615d60e2c" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; resources</source>
          <target state="translated">工具与资源</target>
        </trans-unit>
        <trans-unit id="b9ddad26522153eb9872297e87c93c799247f043" translate="yes" xml:space="preserve">
          <source>Tools to check your cache-related headers</source>
          <target state="translated">检查缓存相关头文件的工具</target>
        </trans-unit>
        <trans-unit id="7b5272923a452bc32a23884c3fe28dc343ef4efe" translate="yes" xml:space="preserve">
          <source>Top-level navigation blocked to data:// URIs</source>
          <target state="translated">顶层导航被屏蔽为data://URIs。</target>
        </trans-unit>
        <trans-unit id="e81a151bd05091f9935dc3aba219eed346e7bb4f" translate="yes" xml:space="preserve">
          <source>Tracking</source>
          <target state="translated">Tracking</target>
        </trans-unit>
        <trans-unit id="5dcb619778c5a48fbe9ce0ea8e4e07da0e9aea7d" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression</source>
          <target state="translated">追踪偏好表达</target>
        </trans-unit>
        <trans-unit id="2af5d6ecb9eb76a6bccbc8c68b541e6b6b396809" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression (DNT)&lt;br/&gt;&lt;small&gt;The definition of 'DNT Header Field for HTTP Requests' in that specification.&lt;/small&gt;</source>
          <target state="translated">跟踪首选项表达式（DNT）&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo; HTTP请求的DNT标头字段&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="84aa830d1d5897f6ae5f7fca1156da8d8706f8cb" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression (DNT)&lt;br/&gt;&lt;small&gt;The definition of 'Tk header field' in that specification.&lt;/small&gt;</source>
          <target state="translated">跟踪首选项表达式（DNT）&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo; Tk标头字段&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d37a3197e485b933cb995fe9c9d3f25f9de908c0" translate="yes" xml:space="preserve">
          <source>Tracking and privacy</source>
          <target state="translated">追踪和隐私</target>
        </trans-unit>
        <trans-unit id="8e5bd5bfa384bf004de3147d61aadd3993d2c684" translate="yes" xml:space="preserve">
          <source>Tracking with consent. The origin server believes it has received prior consent for tracking this user, user agent, or device.</source>
          <target state="translated">经同意的跟踪。源服务器认为它已经收到了跟踪该用户、用户代理或设备的事先同意。</target>
        </trans-unit>
        <trans-unit id="a58efd8405db46a290d75d073d8104640ac8bf79" translate="yes" xml:space="preserve">
          <source>Tracking.</source>
          <target state="translated">Tracking.</target>
        </trans-unit>
        <trans-unit id="26013bccba39d56f3505ecd08b5aabdc74ef7701" translate="yes" xml:space="preserve">
          <source>Trailer</source>
          <target state="translated">Trailer</target>
        </trans-unit>
        <trans-unit id="2f8c965a489badb0e16d07f424592d1f9df923ab" translate="yes" xml:space="preserve">
          <source>Trailer (RFC 2616)</source>
          <target state="translated">拖车(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="77a56b4b0d25c8ae802cf40ac536850a7797b43e" translate="yes" xml:space="preserve">
          <source>Transfer Codings (RFC 7230)</source>
          <target state="translated">传输编码(RFC 7230)</target>
        </trans-unit>
        <trans-unit id="70841a225420fbcb24be7613367795a906d292c9" translate="yes" xml:space="preserve">
          <source>Transfer coding</source>
          <target state="translated">转移编码</target>
        </trans-unit>
        <trans-unit id="7ebdaa3f3a4520281b97e02b5d2f54005ba580f8" translate="yes" xml:space="preserve">
          <source>Transfer coding names are used to indicate an encoding transformation
   that has been, can be, or might need to be applied to a payload body
   in order to ensure &quot;safe transport&quot; through the network.  This
   differs from a content coding in that the transfer coding is a
   property of the message rather than a property of the representation
   that is being transferred.

     transfer-coding    = &quot;chunked&quot; ; &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;
                        / &quot;compress&quot; ; &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;
                        / &quot;deflate&quot; ; &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;
                        / &quot;gzip&quot; ; &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;
                        / transfer-extension
     transfer-extension = token *( OWS &quot;;&quot; OWS transfer-parameter )

   Parameters are in the form of a name or name=value pair.

     transfer-parameter = token BWS &quot;=&quot; BWS ( token / quoted-string )

   All transfer-coding names are case-insensitive and ought to be
   registered within the HTTP Transfer Coding registry, as defined in
   &lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;.  They are used in the TE (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and
   Transfer-Encoding (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;) header fields.</source>
          <target state="translated">传输编码名称用于指示已经，可能或需要应用于有效载荷主体的编码转换，以确保通过网络的&amp;ldquo;安全传输&amp;rdquo;。这与内容编码的不同之处在于，传输编码是消息的属性，而不是正在传输的表示的属性。 transfer-coding =&amp;ldquo;块&amp;rdquo;; &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; /&amp;ldquo;压缩&amp;rdquo;；&lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; /&amp;ldquo;放气&amp;rdquo;；&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt; /&amp;ldquo; gzip&amp;rdquo;；&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; / transfer-extension transfer-extension =标记*（OWS&amp;ldquo;;&amp;rdquo; OWS transfer-parameter）参数采用名称或名称=值对的形式。 transfer-parameter = token BWS&amp;ldquo; =&amp;rdquo; BWS（token / quoted-string）所有传输编码名称均不区分大小写，并应在&lt;a href=&quot;#section-8.4&quot;&gt;8.4节中&lt;/a&gt;定义的HTTP Transfer Coding注册表中进行注册 。它们在TE（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）和Transfer-Encoding（&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节&lt;/a&gt;）头字段中使用。</target>
        </trans-unit>
        <trans-unit id="4d8b97a685db2fa279df1bb0d54e0fdc0c9f8bb5" translate="yes" xml:space="preserve">
          <source>Transfer-Encoding</source>
          <target state="translated">Transfer-Encoding</target>
        </trans-unit>
        <trans-unit id="4626d4537fdc031b31ab03445f507eb645f0b745" translate="yes" xml:space="preserve">
          <source>Transfer-Encoding (RFC 2616)</source>
          <target state="translated">传输编码(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="af30d73f2f27d92a78211f034fdce80b11f12b01" translate="yes" xml:space="preserve">
          <source>Transfer-coding values are used to indicate an encoding
   transformation that has been, can be, or may need to be applied to an
   entity-body in order to ensure &quot;safe transport&quot; through the network.
   This differs from a content coding in that the transfer-coding is a
   property of the message, not of the original entity.

       transfer-coding         = &quot;chunked&quot; | transfer-extension
       transfer-extension      = token *( &quot;;&quot; parameter )

   Parameters are in  the form of attribute/value pairs.

       parameter               = attribute &quot;=&quot; value
       attribute               = token
       value                   = token | quoted-string

   All transfer-coding values are case-insensitive. HTTP/1.1 uses
   transfer-coding values in the TE header field (&lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;) and in
   the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;).

   Whenever a transfer-coding is applied to a message-body, the set of
   transfer-codings MUST include &quot;chunked&quot;, unless the message is
   terminated by closing the connection. When the &quot;chunked&quot; transfer-
   coding is used, it MUST be the last transfer-coding applied to the
   message-body. The &quot;chunked&quot; transfer-coding MUST NOT be applied more
   than once to a message-body. These rules allow the recipient to
   determine the transfer-length of the message (&lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;).

   Transfer-codings are analogous to the Content-Transfer-Encoding
   values of MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;], which were designed to enable safe transport of
   binary data over a 7-bit transport service. However, safe transport
   has a different focus for an 8bit-clean transfer protocol. In HTTP,
   the only unsafe characteristic of message-bodies is the difficulty in
   determining the exact body length (&lt;a href=&quot;#section-7.2.2&quot;&gt;section 7.2.2&lt;/a&gt;), or the desire to
   encrypt data over a shared transport. 

   The Internet Assigned Numbers Authority (IANA) acts as a registry for
   transfer-coding value tokens. Initially, the registry contains the
   following tokens: &quot;chunked&quot; (&lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;), &quot;identity&quot; (&lt;a href=&quot;#section-3.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6.2&quot;&gt;3.6.2&lt;/a&gt;), &quot;gzip&quot; (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;), &quot;compress&quot; (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;), and &quot;deflate&quot;
   (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;).

   New transfer-coding value tokens SHOULD be registered in the same way
   as new content-coding value tokens (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;).

   A server which receives an entity-body with a transfer-coding it does
   not understand SHOULD return 501 (Unimplemented), and close the
   connection. A server MUST NOT send transfer-codings to an HTTP/1.0
   client.</source>
          <target state="translated">传输编码值用于指示已经，可以或可能需要应用于实体的编码转换，以确保通过网络的&amp;ldquo;安全传输&amp;rdquo;。这与内容编码的不同之处在于，传输编码是消息的属性，而不是原始实体的属性。 transfer-coding =&amp;ldquo;块&amp;rdquo; | transfer-extension transfer-extension =标记*（&amp;ldquo;;&amp;rdquo; parameter）参数采用属性/值对的形式。参数=属性&amp;ldquo; =&amp;rdquo;值属性=令牌值=令牌| quoted-string所有传输编码值都不区分大小写。 HTTP / 1.1在TE标头字段中使用传输编码值（&lt;a href=&quot;#section-14.39&quot;&gt;第14.39节）&lt;/a&gt;）和&amp;ldquo;传输编码标头&amp;rdquo;字段中（&lt;a href=&quot;#section-14.41&quot;&gt;第14.41节&lt;/a&gt;）。每当将传输编码应用于消息主体时，除非通过关闭连接来终止消息，否则传输编码集必须包含&amp;ldquo;块&amp;rdquo;。当使用&amp;ldquo;分块&amp;rdquo;传输编码时，它必须是应用于消息正文的最后一个传输编码。 &amp;ldquo;块&amp;rdquo;传输编码不得应用于消息正文多次。这些规则使收件人可以确定邮件的传输长度（&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）。传输编码类似于MIME的Content-Transfer-Encoding值[ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]，旨在实现通过7位传输服务安全地传输二进制数据。但是，安全传输对8bit-clean传输协议的关注点有所不同。在HTTP中，消息主体的唯一不安全特征是难以确定确切的正文长度（&lt;a href=&quot;#section-7.2.2&quot;&gt;第7.2.2节&lt;/a&gt;），或者希望通过共享传输对数据进行加密。互联网号码分配机构（IANA）充当用于转移编码值令牌的注册表。最初，注册表包含以下标记：&amp;ldquo;块&amp;rdquo;（&lt;a href=&quot;#section-3.6.1&quot;&gt;第3.6.1节&lt;/a&gt;），&amp;ldquo;身份&amp;rdquo;（&lt;a href=&quot;#section-3.6.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-3.6.2&quot;&gt;3.6.2 &lt;/a&gt;节），&amp;ldquo; gzip&amp;rdquo;（&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;），&amp;ldquo;压缩&amp;rdquo;（&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）和&amp;ldquo;放气&amp;rdquo;（ &lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）。应以与新的内容编码值令牌相同的方式注册新的传输编码值令牌（&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）。收到带有传输代码的实体的服务器不理解应该返回501（未实现），并关闭连接。服务器不得将传输代码发送到HTTP / 1.0客户端。</target>
        </trans-unit>
        <trans-unit id="8f06d2432c28b1a1b63093c7243e8fc4296b2052" translate="yes" xml:space="preserve">
          <source>Transformation Applied</source>
          <target state="translated">转化应用</target>
        </trans-unit>
        <trans-unit id="0333efced7aed7a62393f804f6f0a1fac69384cf" translate="yes" xml:space="preserve">
          <source>Transitioning from &lt;code&gt;X-Forwarded-For&lt;/code&gt; to &lt;code&gt;Forwarded&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 过渡到 &lt;code&gt;Forwarded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9dbb92c213907795b866e8682bea20bfe425f28" translate="yes" xml:space="preserve">
          <source>Transparent Content Negotiation in HTTP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d5987738fe39dbda22e95b91e209136e267709" translate="yes" xml:space="preserve">
          <source>Transparent negotiation is a combination of both server-driven and
   agent-driven negotiation. When a cache is supplied with a form of the
   list of available representations of the response (as in agent-driven
   negotiation) and the dimensions of variance are completely understood
   by the cache, then the cache becomes capable of performing server-
   driven negotiation on behalf of the origin server for subsequent
   requests on that resource.

   Transparent negotiation has the advantage of distributing the
   negotiation work that would otherwise be required of the origin
   server and also removing the second request delay of agent-driven
   negotiation when the cache is able to correctly guess the right
   response.

   This specification does not define any mechanism for transparent
   negotiation, though it also does not prevent any such mechanism from
   being developed as an extension that could be used within HTTP/1.1.</source>
          <target state="translated">透明协商是服务器驱动和代理驱动协商的结合。当缓存提供了响应的可用表示列表的形式(如代理驱动协商),并且缓存完全理解了差异的维度,那么缓存就能够代表原服务器对该资源的后续请求进行服务器驱动协商。透明协商的优点是可以将原本需要原服务器进行的协商工作进行分配,同时当缓存能够正确猜测出正确的响应时,也可以消除代理驱动协商的第二次请求延迟。本规范并没有定义任何透明协商的机制,尽管它也不妨碍任何这样的机制被开发成可以在HTTP/1.1中使用的扩展。</target>
        </trans-unit>
        <trans-unit id="78b9ce3dc78962972447ca0b6f58074fd970dfbb" translate="yes" xml:space="preserve">
          <source>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</source>
          <target state="translated">传输层安全(TLS)应用层协议协商扩展功能</target>
        </trans-unit>
        <trans-unit id="dfd6efe315d54c8cdd2adc5afbb8872f6a336102" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in iOS before 13. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b08ea38352dc45d4d989417f6fef8d6f90e693b" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in macOS before 10.15 Catalina. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323f99b9a56b4b45411c566426be7157525a2168" translate="yes" xml:space="preserve">
          <source>Trident</source>
          <target state="translated">Trident</target>
        </trans-unit>
        <trans-unit id="ca3606ead865c2815a13e76d1b25c992f4f3c6f9" translate="yes" xml:space="preserve">
          <source>Trident/7.0; .*rv:xyz &lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c266c97b59663994c186c4ed953693b711755a83" translate="yes" xml:space="preserve">
          <source>Trident/xyz</source>
          <target state="translated">Trident/xyz</target>
        </trans-unit>
        <trans-unit id="ea2c9903532f8ca9b9bfd8b8e86bf77e287eda98" translate="yes" xml:space="preserve">
          <source>Tries to resolve the hostname. Returns true if succeeds.</source>
          <target state="translated">试图解析主机名。如果成功则返回true。</target>
        </trans-unit>
        <trans-unit id="0ad2653fb337835a830a479f5211338052b81788" translate="yes" xml:space="preserve">
          <source>Troubleshooting HTTP 405</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5aeb48bb5b3f47bc91e7f66bbbde649d99b8a5" translate="yes" xml:space="preserve">
          <source>Troubleshooting errors</source>
          <target state="translated">故障排除</target>
        </trans-unit>
        <trans-unit id="6e7d676a3f4acf661dbd32eb846f4d30d45c42b9" translate="yes" xml:space="preserve">
          <source>True if and only if the IP address of the host matches the specified IP address pattern.</source>
          <target state="translated">如果且仅如果主机的IP地址与指定的IP地址模式相匹配,则为真。</target>
        </trans-unit>
        <trans-unit id="853354f33edc8bdc875b21e01f674d1cc985ac56" translate="yes" xml:space="preserve">
          <source>True if and only if there is no domain name in the hostname (no dots).</source>
          <target state="translated">如果且仅如果主机名中没有域名(没有点),则为真。</target>
        </trans-unit>
        <trans-unit id="40b3edf718ee234d3ed60de8590b0eab146b9f6b" translate="yes" xml:space="preserve">
          <source>TrueType Font</source>
          <target state="translated">TrueType字体</target>
        </trans-unit>
        <trans-unit id="bbf3f0cb2c9cd2650c1a090a531af44cd91ba47e" translate="yes" xml:space="preserve">
          <source>Trusted Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c859b305a822310a954cdbf0855833e891bb6bad" translate="yes" xml:space="preserve">
          <source>Trusted Types with &lt;a href=&quot;https://github.com/cure53/DOMPurify#what-about-dompurify-and-trusted-types&quot;&gt;DOMPurify&lt;/a&gt; XSS sanitizer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deed064463d5fe6a9b6de90de79e1d7bc5664ed3" translate="yes" xml:space="preserve">
          <source>Trying to access an &lt;code&gt;http&lt;/code&gt; resource from a page with an &lt;code&gt;https&lt;/code&gt; origin will also cause this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ecb3021f84a92249f81d93e6449bc294633f5a4" translate="yes" xml:space="preserve">
          <source>Trying to access an &lt;code&gt;https&lt;/code&gt; resource that has an invalid certificate will cause this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7dd9fead5f39240201ca09db25e60a206fb473" translate="yes" xml:space="preserve">
          <source>Trying to use a &lt;a href=&quot;../../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request will fail with this error.</source>
          <target state="translated">尝试使用&lt;a href=&quot;../../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;请求将失败，并显示此错误。</target>
        </trans-unit>
        <trans-unit id="91efe823a9a6e3fb633db6d257efcabfa7cfb34a" translate="yes" xml:space="preserve">
          <source>Tunneling transmits private network data and protocol information through public network by encapsulating the data. HTTP tunneling is using a protocol of higher level (HTTP) to transport a lower level protocol (TCP).</source>
          <target state="translated">隧道通过封装数据,通过公网传输私有网络数据和协议信息。HTTP隧道是利用上层协议(HTTP)来传输下层协议(TCP)。</target>
        </trans-unit>
        <trans-unit id="e28a72d2f72f9e470a9c017ef73151d89a57b9b9" translate="yes" xml:space="preserve">
          <source>Turning on and off prefetching</source>
          <target state="translated">打开和关闭预取</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="2b805468035d4d32817647d90742c71d232cc025" translate="yes" xml:space="preserve">
          <source>Two header fields are used for carrying authentication credentials,
   as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;].  Note that various custom mechanisms for
   user authentication use the Cookie header field for this purpose, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;].

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | Authorization       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7235]&lt;/a&gt; |
   | Proxy-Authorization | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7235]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">根据[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]中的定义，两个标头字段用于承载身份验证凭据。请注意，用于用户身份验证的各种自定义机制为此目的使用了Cookie头字段，如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]中所定义。 + --------------------- + -------------------------- + |标头字段名称|定义于... | + --------------------- + -------------------------- + |授权| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235]的4.2节&lt;/a&gt; | |代理授权| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;[RFC7235]的4.4节&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="ce0195a6ae48268edebd5bad672073160522c130" translate="yes" xml:space="preserve">
          <source>Two newer models were created in HTTP/1.1. The persistent-connection model keeps connections opened between successive requests, reducing the time needed to open new connections. The HTTP pipelining model goes one step further, by sending several successive requests without even waiting for an answer, reducing much of the latency in the network.</source>
          <target state="translated">在HTTP/1.1中创建了两个较新的模型。持久连接模型在连续的请求之间保持打开的连接,减少了打开新连接所需的时间。HTTP pipelining模型更进一步,通过发送几个连续的请求,甚至不需要等待应答,减少了很多网络中的延迟。</target>
        </trans-unit>
        <trans-unit id="a6b6a2cb2500b00f4598bac08b45cc08135ddf62" translate="yes" xml:space="preserve">
          <source>Two others content encoding, &lt;code&gt;bzip&lt;/code&gt; and &lt;code&gt;bzip2&lt;/code&gt;, are sometimes used, though not standard. They implement the algorithm used by these two UNIX programs. Note that the first one was discontinued due to patent licensing problems.</source>
          <target state="translated">有时会使用其他两种内容编码， &lt;code&gt;bzip&lt;/code&gt; 和 &lt;code&gt;bzip2&lt;/code&gt; ，尽管不是标准的。它们实现了这两个UNIX程序使用的算法。请注意，由于专利许可问题，第一个已停产。</target>
        </trans-unit>
        <trans-unit id="be051f060f0e48af75e9fbc48e21748ef6b4cb67" translate="yes" xml:space="preserve">
          <source>Two primary MIME types are important for the role of default types:</source>
          <target state="translated">两种主要的MIME类型对默认类型的作用很重要。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="f3b42007b5826f0bf510edecae6f14cfe0fe14b4" translate="yes" xml:space="preserve">
          <source>Type name:  multipart

   Subtype name:  byteranges

   Required parameters:  boundary

   Optional parameters:  N/A

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted

   Security considerations:  see &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).

   Applications that use this media type:  HTTP components supporting
      multiple ranges in a single request.

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:  See
      Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">类型名称：multipart子类型名称：byteranges必需参数：boundary可选参数：N / A编码注意事项：仅允许使用&amp;ldquo; 7bit&amp;rdquo;，&amp;ldquo; 8bit&amp;rdquo;或&amp;ldquo; binary&amp;rdquo;安全注意事项：请参阅&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt; 互操作性注意事项：N / A已发布规范：本规范（请参阅&lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;）。使用此媒体类型的应用程序：在单个请求中支持多个范围的HTTP组件。片段标识符注意事项：N / A附加信息：此类型已弃用的别名：N / A幻数：N / A文件扩展名：N / A Macintosh文件类型代码：N / A人员以及要联系以获取更多信息的电子邮件地址：请参见作者地址部分。预期用途：COMMON使用限制：不适用作者：请参阅作者地址。变更负责人：IESG</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="1cdbcf1104e531ebfadc11eeae080e4dae018fc1" translate="yes" xml:space="preserve">
          <source>Types of policy-controlled features</source>
          <target state="translated">政策控制功能的类型</target>
        </trans-unit>
        <trans-unit id="7e09f83609dd0c3d502c7f963c9a6cb433242aef" translate="yes" xml:space="preserve">
          <source>Typescript file</source>
          <target state="translated">排版文件</target>
        </trans-unit>
        <trans-unit id="bcdcdf22eca538d6ec2cf257367ae227cf6af679" translate="yes" xml:space="preserve">
          <source>Typical use case</source>
          <target state="translated">典型应用案例</target>
        </trans-unit>
        <trans-unit id="9d181320d36d0df488b3ffb530573b04214390c3" translate="yes" xml:space="preserve">
          <source>Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like these:</source>
          <target state="translated">通常，服务器响应包含一个如下所示的 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 标头：</target>
        </trans-unit>
        <trans-unit id="5c770b12d663e3645cbb00a17170089090ea1bce" translate="yes" xml:space="preserve">
          <source>Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7575b8da7bfc80688b2b000e08fcdc14b5cd506" translate="yes" xml:space="preserve">
          <source>Typically, this means that a required precondition header, such as &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt;, &lt;strong&gt;is missing&lt;/strong&gt;.</source>
          <target state="translated">典型地，这意味着所需的先决条件头，如&lt;a href=&quot;../headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;，&lt;strong&gt;缺少&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="037314288a9afb85b05677ae9ceceff454cbc8e0" translate="yes" xml:space="preserve">
          <source>Typically, you don't want your users to resend &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests. If you serve the response as the result of this request, a simple press of the reload button will resend the request (possibly after a confirmation message).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="cb371c93c5aa0e62198efd303ae2c17474416d1a" translate="yes" xml:space="preserve">
          <source>URI</source>
          <target state="translated">URI</target>
        </trans-unit>
        <trans-unit id="f70305059f0d6ca694366421ab9addbc18e37b87" translate="yes" xml:space="preserve">
          <source>URI/URL - A Uniform Resource Identifier and Uniform Resource Locator,
   respectively.  These terms (and the distinction between them) are
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].

   URI/URL Mapping - A relation between an absolute URI and a resource.
   Since a resource can represent items that are not network
   retrievable, as well as those that are, it is possible for a resource
   to have zero, one, or many URI mappings.  Mapping a resource to an
   &quot;http&quot; scheme URI makes it possible to submit HTTP protocol requests
   to the resource using the URI. 

   Path Segment - Informally, the characters found between slashes (&quot;/&quot;)
   in a URI.  Formally, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;.

   Collection - Informally, a resource that also acts as a container of
   references to child resources.  Formally, a resource that contains a
   set of mappings between path segments and resources and meets the
   requirements defined in &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;.

   Internal Member (of a Collection) - Informally, a child resource of a
   collection.  Formally, a resource referenced by a path segment
   mapping contained in the collection.

   Internal Member URL (of a Collection) - A URL of an internal member,
   consisting of the URL of the collection (including trailing slash)
   plus the path segment identifying the internal member.

   Member (of a Collection) - Informally, a &quot;descendant&quot; of a
   collection.  Formally, an internal member of the collection, or,
   recursively, a member of an internal member.

   Member URL (of a Collection) - A URL that is either an internal
   member URL of the collection itself, or is an internal member URL of
   a member of that collection.

   Property - A name/value pair that contains descriptive information
   about a resource.

   Live Property - A property whose semantics and syntax are enforced by
   the server.  For example, the live property DAV:getcontentlength has
   its value, the length of the entity returned by a GET request,
   automatically calculated by the server.

   Dead Property - A property whose semantics and syntax are not
   enforced by the server.  The server only records the value of a dead
   property; the client is responsible for maintaining the consistency
   of the syntax and semantics of a dead property.

   Principal - A distinct human or computational actor that initiates
   access to network resources.

   State Token - A URI that represents a state of a resource.  Lock
   tokens are the only state tokens defined in this specification.</source>
          <target state="translated">URI / URL-分别是统一资源标识符和统一资源定位符。这些术语（以及它们之间的区别）在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ] 中定义。 URI / URL映射-绝对URI与资源之间的关系。由于资源可以表示不可通过网络检索的项目以及可以通过网络检索的项目，因此资源可能具有零个，一个或多个URI映射。通过将资源映射到&amp;ldquo; http&amp;rdquo;方案URI，可以使用URI向资源提交HTTP协议请求。路径段-非正式地，在URI中的斜杠（&amp;ldquo; /&amp;rdquo;）之间找到的字符。正式而言，如&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]第3.3节中&lt;/a&gt;所定义。集合-非正式地，一种资源，还充当对子资源的引用的容器。形式上，资源包含路径段和资源之间的一组映射并满足&lt;a href=&quot;#section-5&quot;&gt;第5节中&lt;/a&gt;定义的要求。 （集合的）内部成员-非正式地，集合的子资源。形式上，集合中包含的路径段映射引用的资源。 （集合的）内部成员URL-内部成员的URL，由集合的URL（包括斜杠）加上标识内部成员的路径段组成。 （集合的成员）-非正式地，集合的&amp;ldquo;后代&amp;rdquo;。形式上，集合的内部成员，或者递归地，内部成员的成员。 （集合的）成员URL-URL可以是集合本身的内部成员URL，也可以是该集合成员的内部成员URL。属性-包含有关资源的描述性信息的名称/值对。实时属性-一种属性，其语义和语法由服务器强制执行。例如，活动属性DAV：getcontentlength具有其值，即由GET请求返回的实体的长度，该值由服务器自动计算。 Dead属性-服务器未强制使用其语义和语法的属性。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。getcontentlength具有其值，即由服务器自动计算的GET请求返回的实体的长度。 Dead属性-服务器未强制使用其语义和语法的属性。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。getcontentlength具有其值，即由服务器自动计算的GET请求返回的实体的长度。 Dead属性-服务器未强制使用其语义和语法的属性。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。</target>
        </trans-unit>
        <trans-unit id="1b1db348af514b6bea21a18f53ca916d54264149" translate="yes" xml:space="preserve">
          <source>URIs and how to access resources on the Web.</source>
          <target state="translated">URI以及如何访问网络上的资源。</target>
        </trans-unit>
        <trans-unit id="6d39406666e0fced7b5feeca9564a556a649dc18" translate="yes" xml:space="preserve">
          <source>URIs are intended to be shared, not secured, even when they identify
   secure resources.  URIs are often shown on displays, added to
   templates when a page is printed, and stored in a variety of
   unprotected bookmark lists.  It is therefore unwise to include
   information within a URI that is sensitive, personally identifiable,
   or a risk to disclose.

   Authors of services ought to avoid GET-based forms for the submission
   of sensitive data because that data will be placed in the
   request-target.  Many existing servers, proxies, and user agents log
   or display the request-target in places where it might be visible to
   third parties.  Such services ought to use POST-based form submission
   instead.

   Since the Referer header field tells a target site about the context
   that resulted in a request, it has the potential to reveal
   information about the user's immediate browsing history and any
   personal information that might be found in the referring resource's
   URI.  Limitations on the Referer header field are described in
   &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; to address some of its security considerations.</source>
          <target state="translated">URI旨在即使不标识安全资源也要共享而不是安全的。 URI通常显示在显示器上，在打印页面时将其添加到模板中，并存储在各种未受保护的书签列表中。因此，在URI中包含敏感，个人可识别或存在泄露风险的信息是不明智的。服务的作者应避免基于GET的表单提交敏感数据，因为这些数据将被放置在请求目标中。许多现有的服务器，代理和用户代理会在第三方可能可见的地方记录或显示请求目标。此类服务应改用基于POST的表单提交。由于Referer标头字段告知目标网站有关导致请求的上下文，它有可能泄露有关用户的即时浏览历史的信息以及在引用资源的URI中可能找到的任何个人信息。有关Referer标头字段的限制，请参见 &lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt;解决了一些安全性考虑。</target>
        </trans-unit>
        <trans-unit id="3cce85850c1e42a1666b59eb99149f8792f48d3c" translate="yes" xml:space="preserve">
          <source>URIs have been known by many names: WWW addresses, Universal Document
   Identifiers, Universal Resource Identifiers [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], and finally the
   combination of Uniform Resource Locators (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] and Names (URN)
   [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;]. As far as HTTP is concerned, Uniform Resource Identifiers are
   simply formatted strings which identify--via name, location, or any
   other characteristic--a resource.</source>
          <target state="translated">URI的名称很多：WWW地址，通用文档标识符，通用资源标识符[ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ]，最后是统一资源定位符（URL）[ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]和名称（URN）[ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ]的组合。就HTTP而言，统一资源标识符是简单格式化的字符串，它们通过名称，位置或任何其他特征来标识资源。</target>
        </trans-unit>
        <trans-unit id="498e7643a14364976970437ebe13915fd4a1000a" translate="yes" xml:space="preserve">
          <source>URIs in HTTP can be represented in absolute form or relative to some
   known base URI [&lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;], depending upon the context of their use. The two
   forms are differentiated by the fact that absolute URIs always begin
   with a scheme name followed by a colon. For definitive information on
   URL syntax and semantics, see &quot;Uniform Resource Identifiers (URI):
   Generic Syntax and Semantics,&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;] (which replaces RFCs
   1738 [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] and &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; [&lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;]). This specification adopts the
   definitions of &quot;URI-reference&quot;, &quot;absoluteURI&quot;, &quot;relativeURI&quot;, &quot;port&quot;,
   &quot;host&quot;,&quot;abs_path&quot;, &quot;rel_path&quot;, and &quot;authority&quot; from that
   specification.

   The HTTP protocol does not place any a priori limit on the length of
   a URI. Servers MUST be able to handle the URI of any resource they
   serve, and SHOULD be able to handle URIs of unbounded length if they
   provide GET-based forms that could generate such URIs. A server
   SHOULD return 414 (Request-URI Too Long) status if a URI is longer
   than the server can handle (see &lt;a href=&quot;#section-10.4.15&quot;&gt;section 10.4.15&lt;/a&gt;).

      Note: Servers ought to be cautious about depending on URI lengths
      above 255 bytes, because some older client or proxy
      implementations might not properly support these lengths.</source>
          <target state="translated">HTTP中的URI可以以绝对形式表示，也可以相对于某些已知的基本URI [ &lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt; ]表示，具体取决于它们的使用上下文。两种形式的区别在于，绝对URI总是以方案名称开头，后跟冒号。有关URL语法和语义的权威信息，请参阅&amp;ldquo;统一资源标识符（URI）：通用语法和语义&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt; ]（代替RFC 1738 [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]和&lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; [ &lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;]）。该规范采用该规范中的&amp;ldquo; URI引用&amp;rdquo;，&amp;ldquo; absoluteURI&amp;rdquo;，&amp;ldquo; relativeURI&amp;rdquo;，&amp;ldquo;端口&amp;rdquo;，&amp;ldquo;主机&amp;rdquo;，&amp;ldquo; abs_path&amp;rdquo;，&amp;ldquo; rel_path&amp;rdquo;和&amp;ldquo; authority&amp;rdquo;的定义。 HTTP协议对URI的长度没有任何先验限制。服务器必须能够处理它们所服务的任何资源的URI，并且如果它们提供可以生成此类URI的基于GET的形式，则应当能够处理无限长度的URI。如果URI的长度超过服务器的处理能力，则服务器应返回414（请求URI太长）状态（请参见&lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15节&lt;/a&gt;）。注意：服务器应该谨慎，具体取决于255个字节以上的URI长度，因为某些较旧的客户端或代理实现可能无法正确支持这些长度。</target>
        </trans-unit>
        <trans-unit id="cfef62af9614810559e1e5b81b8c27fecbab7b5c" translate="yes" xml:space="preserve">
          <source>URL redirection, also known as URL forwarding, is a technique to give a page, a form or a whole Web application, more than one URL address. HTTP provides a special kind of responses, &lt;em&gt;&lt;strong&gt;HTTP redirects&lt;/strong&gt;&lt;/em&gt;, to perform this operation used for numerous goals: temporary redirection while site maintenance is ongoing, permanent redirection to keep external links working after a change of the site's architecture, progress pages when uploading a file, and so on.</source>
          <target state="translated">URL重定向（也称为URL转发）是一种为页面，表单或整个Web应用程序提供多个URL地址的技术。HTTP提供了一种特殊的响应，即&lt;em&gt;&lt;strong&gt;HTTP重定向&lt;/strong&gt;&lt;/em&gt;，用于执行用于许多目标的此操作：在进行站点维护时进行临时重定向，在站点结构更改后使外部链接保持正常工作的永久重定向，在上传文件时显示进度页，等等。</target>
        </trans-unit>
        <trans-unit id="11053b0e7813cb1ccd4cf628421c47a3253d39a1" translate="yes" xml:space="preserve">
          <source>URL-embedded JavaScript code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621894213e70d0f25d538e3e503f261cb1c92c16" translate="yes" xml:space="preserve">
          <source>URL/hostname based conditions</source>
          <target state="translated">基于URL/主机名的条件</target>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="b9011f5a3d0a8fd5aa8be41c9a2ba56d323a6e48" translate="yes" xml:space="preserve">
          <source>URLs and URNs</source>
          <target state="translated">URLs和URNs</target>
        </trans-unit>
        <trans-unit id="0d68396d9a72290240763f5089d4a58c9fd02660" translate="yes" xml:space="preserve">
          <source>URLs appear in many places in requests and responses.
   Interoperability experience with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] showed that many clients
   parsing Multi-Status responses did not fully implement the full
   Reference Resolution defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC3986]&lt;/a&gt;.  Thus,
   servers in particular need to be careful in handling URLs in
   responses, to ensure that clients have enough context to be able to
   interpret all the URLs.  The rules in this section apply not only to
   resource URLs in the 'href' element in Multi-Status responses, but
   also to the Destination and If header resource URLs.

   The sender has a choice between two approaches: using a relative
   reference, which is resolved against the Request-URI, or a full URI.
   A server MUST ensure that every 'href' value within a Multi-Status
   response uses the same format.

   WebDAV only uses one form of relative reference in its extensions,
   the absolute path.

      Simple-ref = absolute-URI | ( path-absolute [ &quot;?&quot; query ] )

   The absolute-URI, path-absolute and query productions are defined in
   Sections &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;, &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;, and &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].

   Within Simple-ref productions, senders MUST NOT:

   o  use dot-segments (&quot;.&quot; or &quot;..&quot;), or

   o  have prefixes that do not match the Request-URI (using the
      comparison rules defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.2.3&quot;&gt;Section&amp;nbsp;3.2.3 of [RFC2616]&lt;/a&gt;).

   Identifiers for collections SHOULD end in a '/' character.</source>
          <target state="translated">URL出现在请求和响应中的许多位置。[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ]的互操作性经验表明，许多解析多状态响应的客户端没有完全实现&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986]第5节中&lt;/a&gt;定义的完整参考分辨率。。因此，服务器尤其需要谨慎处理响应中的URL，以确保客户端具有足够的上下文以能够解释所有URL。本节中的规则不仅适用于多状态响应中'href'元素中的资源URL，而且还适用于Destination和If标头资源URL。发送者可以在两种方法之间选择：使用相对引用（针对Request-URI解析）或完整URI。服务器必须确保多状态响应中的每个&amp;ldquo; href&amp;rdquo;值都使用相同的格式。 WebDAV在其扩展中仅使用一种形式的相对引用，即绝对路径。简单引用=绝对URI | （path-absolute [&amp;ldquo;？&amp;rdquo; query]）在节中定义了绝对URI，绝对路径和查询生成&lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;，&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;，以及&lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; [的&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]。在Simple-ref产生中，发送者不得：o使用点段（&amp;ldquo;。&amp;rdquo;或&amp;ldquo; ..&amp;rdquo;），或o与Request-URI不匹配的前缀（使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.2.3&quot;&gt;第3.2.3节中&lt;/a&gt;定义的比较规则）[RFC2616]）。集合的标识符应以&amp;ldquo; /&amp;rdquo;字符结尾。</target>
        </trans-unit>
        <trans-unit id="2c75d09b30def3f5acce02670c0f8d304787deb1" translate="yes" xml:space="preserve">
          <source>URNs</source>
          <target state="translated">URNs</target>
        </trans-unit>
        <trans-unit id="09716c44992b8bceefcd6d77921ff9ec06e2764d" translate="yes" xml:space="preserve">
          <source>USB</source>
          <target state="translated">USB</target>
        </trans-unit>
        <trans-unit id="463d4baccb11d04bd39b50170d5669b1473a3d3e" translate="yes" xml:space="preserve">
          <source>UTF-8 is now well-supported and the overwhelmingly preferred character encoding. To &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;guarantee better privacy through less configuration-based entropy&lt;/a&gt;, all browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8+, Safari 5+, Opera 11+, Firefox 10+ and Chrome 27+ no longer send it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3395f08e982fbccb7c267f1152a8f77ff4f3d2ba" translate="yes" xml:space="preserve">
          <source>Unconstrained multiple range requests are susceptible to denial-of-
   service attacks because the effort required to request many
   overlapping ranges of the same data is tiny compared to the time,
   memory, and bandwidth consumed by attempting to serve the requested
   data in many parts.  Servers ought to ignore, coalesce, or reject
   egregious range requests, such as requests for more than two
   overlapping ranges or for many small ranges in a single set,
   particularly when the ranges are requested out of order for no
   apparent reason.  Multipart range requests are not designed to
   support random access.</source>
          <target state="translated">不受限制的多范围请求很容易受到拒绝服务攻击,因为请求同一数据的许多重叠范围所需的努力与试图服务于所请求的数据的许多部分所消耗的时间、内存和带宽相比是微不足道的。服务器应该忽略、合并或拒绝恶劣的范围请求,例如请求两个以上的重叠范围或在一个集合中请求许多小范围,特别是当请求的范围没有明显的原因而顺序混乱时。多部分范围请求不是为了支持随机访问而设计的。</target>
        </trans-unit>
        <trans-unit id="87b5a91171602746648bcc818bbb122d7646769d" translate="yes" xml:space="preserve">
          <source>Undeprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">不推荐使用 &lt;code&gt;frame-src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f3058bceb865d591bd6a47330d0826684d098a7" translate="yes" xml:space="preserve">
          <source>Under construction. The origin server is currently testing its communication of tracking status.</source>
          <target state="translated">正在建设中。源服务器目前正在测试其跟踪状态的通信。</target>
        </trans-unit>
        <trans-unit id="93bb4b1c6ee8c5d136c3ae4245fe9019094c3bdf" translate="yes" xml:space="preserve">
          <source>Understanding The Vary Header - Smashing Magazine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4821ae5432f25746ffce2357d74178373c8cf2dd" translate="yes" xml:space="preserve">
          <source>Understanding XSS Auditor &amp;ndash; Virtue Security</source>
          <target state="translated">了解XSS Auditor &amp;ndash;美德安全性</target>
        </trans-unit>
        <trans-unit id="b2f6280ce256054e508e4d6c0d2aed7f16b9ceb5" translate="yes" xml:space="preserve">
          <source>Unfortunately, the HTTP standard does not specify the format of the page allowing to choose between the available resource, which prevents to easily automatize the process. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</source>
          <target state="translated">不幸的是，HTTP标准没有指定允许在可用资源之间进行选择的页面格式，这会阻止轻松地自动执行该过程。除了依靠&lt;em&gt;服务器驱动的协商之外&lt;/em&gt;，该方法几乎总是与脚本结合使用，尤其是与JavaScript重定向结合使用：在检查了协商条件之后，脚本将执行重定向。第二个问题是，需要另外一个请求才能获取实际资源，从而减慢了用户对资源的可用性。</target>
        </trans-unit>
        <trans-unit id="590261af46ebe2219ba617fed793de6d03379f66" translate="yes" xml:space="preserve">
          <source>Unfortunately, the HTTP standard does not specify the format of the page for choosing between the available resource, which prevents the process being automated. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba4dbb75ad90a20a4a3d20676386c7ac0143689" translate="yes" xml:space="preserve">
          <source>Unfortunately, things get a little inaccurate as soon as we take into account concurrency. While a client is locally modifying its new copy of the resource, a second client can fetch the same resource and do the same on its copy. What happens next is very unfortunate: when they commit back to the server, the modifications from the first client are discarded by the next client push, as this second client is unaware of the first client's changes to the resource. The decision on who wins, is not communicated to the other party. Which client's changes are to be kept, will vary with the speed they commit; this depends on the performance of the clients, of the server, and even of the human editing the document at the client. The winner will change from one time to the next. This is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/race_condition&quot;&gt;race condition&lt;/a&gt; and leads to problematic behaviors, which are difficult to detect and to debug:</source>
          <target state="translated">不幸的是，一旦考虑到并发性，事情就会变得有点不准确。当客户端在本地修改其新的资源副本时，第二个客户端可以获取相同的资源并对其副本执行相同的操作。接下来发生的事情非常不幸：当它们提交回服务器时，来自第一个客户端的修改将被下一次客户端推送丢弃，因为此第二个客户端不知道第一个客户端对资源的更改。谁获胜的决定不会传达给另一方。要保留哪个客户的更改，将随着他们提交的速度而变化；这取决于客户端，服务器的性能，甚至还取决于人工在客户端编辑文档的性能。获胜者将一次改变一次。这是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/race_condition&quot;&gt;比赛条件&lt;/a&gt;并导致有问题的行为，这些行为很难检测和调试：</target>
        </trans-unit>
        <trans-unit id="9d6157fa48e6c6221f34d6df81ed35de4c9f2058" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifier (URI): Generic Syntax</source>
          <target state="translated">统一资源标识符 (URI)。通用语法</target>
        </trans-unit>
        <trans-unit id="5331c3d8fb4de87de8b7a5cbf7bd8ea20f192adf" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URIs) [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] are used throughout
   HTTP as the means for identifying resources (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-2&quot;&gt;Section&amp;nbsp;2 of [RFC7231]&lt;/a&gt;).
   URI references are used to target requests, indicate redirects, and
   define relationships.

   The definitions of &quot;URI-reference&quot;, &quot;absolute-URI&quot;, &quot;relative-part&quot;,
   &quot;scheme&quot;, &quot;authority&quot;, &quot;port&quot;, &quot;host&quot;, &quot;path-abempty&quot;, &quot;segment&quot;,
   &quot;query&quot;, and &quot;fragment&quot; are adopted from the URI generic syntax.  An
   &quot;absolute-path&quot; rule is defined for protocol elements that can
   contain a non-empty path component.  (This rule differs slightly from
   the path-abempty rule of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, which allows for an empty path to
   be used in references, and path-absolute rule, which does not allow
   paths that begin with &quot;//&quot;.)  A &quot;partial-URI&quot; rule is defined for
   protocol elements that can contain a relative URI but not a fragment
   component.

     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], Section&amp;nbsp;4.1&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], Section&amp;nbsp;4.3&lt;/a&gt;&amp;gt;
     relative-part = &amp;lt;relative-part, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;&amp;gt;
     scheme        = &amp;lt;scheme, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;&amp;gt;
     authority     = &amp;lt;authority, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;&amp;gt;
     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     path-abempty  = &amp;lt;path-abempty, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
     segment       = &amp;lt;segment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
     query         = &amp;lt;query, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
     fragment      = &amp;lt;fragment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;&amp;gt;

     absolute-path = 1*( &quot;/&quot; segment )
     partial-URI   = relative-part [ &quot;?&quot; query ]

   Each protocol element in HTTP that allows a URI reference will
   indicate in its ABNF production whether the element allows any form
   of reference (URI-reference), only a URI in absolute form
   (absolute-URI), only the path and optional query components, or some
   combination of the above.  Unless otherwise indicated, URI references
   are parsed relative to the effective request URI (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;).</source>
          <target state="translated">整个HTTP使用统一资源标识符（URI）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]作为标识资源的方法（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-2&quot;&gt;[RFC7231]的第2节&lt;/a&gt;）。 URI引用用于定位请求，指示重定向和定义关系。 &amp;ldquo; URI引用&amp;rdquo;，&amp;ldquo;绝对URI&amp;rdquo;，&amp;ldquo;相对部分&amp;rdquo;，&amp;ldquo;方案&amp;rdquo;，&amp;ldquo;权限&amp;rdquo;，&amp;ldquo;端口&amp;rdquo;，&amp;ldquo;主机&amp;rdquo;，&amp;ldquo;路径豁免&amp;rdquo;，&amp;ldquo;段&amp;rdquo;，&amp;ldquo;查询&amp;rdquo;的定义和&amp;ldquo;片段&amp;rdquo;是从URI通用语法中采用的。为可以包含非空路径组件的协议元素定义了&amp;ldquo;绝对路径&amp;rdquo;规则。 （此规则与&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;的路径豁免规则略有不同，它允许在引用中使用空路径，而路径绝对规则则不允许以&amp;ldquo; //&amp;rdquo;开头的路径。）为可以包含相对地址的协议元素定义了&amp;ldquo; partial-URI&amp;rdquo;规则URI，但不是片段组件。 URI引用= &amp;lt;URI引用，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986]，第4.1节&lt;/a&gt; &amp;gt; absolute-URI = &amp;lt;绝对URI，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]，第4.3节&lt;/a&gt; &amp;gt; relative-part = &amp;lt;相对部分，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986]，第4.2节&lt;/a&gt; &amp;gt;方案= &amp;lt;方案，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986]，第3.1节&lt;/a&gt; &amp;gt;权限= &amp;lt;权限，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986]，第3.2节&lt;/a&gt; &amp;gt; uri-host = &amp;lt;主机，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986]，第3.2.2节&lt;/a&gt; &amp;gt; port = &amp;lt;港口，看&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986，第3.2.3节&lt;/a&gt; &amp;gt;路径豁免= &amp;lt;路径-豁免，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]，第3.3节&lt;/a&gt; &amp;gt;段= &amp;lt;段，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]，第3.3节&lt;/a&gt; &amp;gt; query = &amp;lt;查询，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986]，第3节3.4&lt;/a&gt; &amp;gt;片段= &amp;lt;片段，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986]，第3.5节&lt;/a&gt;&amp;gt;绝对路径= 1 *（&amp;ldquo; /&amp;rdquo; segment）部分URI =相对部分[&amp;ldquo;？&amp;rdquo; HTTP中允许URI引用的每个协议元素都将在其ABNF产生中指示该元素是否允许任何形式的引用（URI-reference），仅允许绝对形式的URI（absolute-URI），仅路径和可选查询组件或以上的某种组合。除非另有说明，否则将相对于有效请求URI解析URI引用（&lt;a href=&quot;#section-5.5&quot;&gt;第5.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="326e61a6296432fcad1af300f3c896bd0e9d0435" translate="yes" xml:space="preserve">
          <source>Uniform Resource Names</source>
          <target state="translated">统一资源名称</target>
        </trans-unit>
        <trans-unit id="0f25e6e17d90b442b15b6c3491b583d0eb8a4b09" translate="yes" xml:space="preserve">
          <source>Unless dealing with a very old system, which doesn't support a persistent connection, there is no compelling reason to use this model.</source>
          <target state="translated">除非处理的是一个非常古老的系统,不支持持久连接,否则没有令人信服的理由使用这个模型。</target>
        </trans-unit>
        <trans-unit id="7df067eefe56c18b36ec5afe619983a9a5702d6c" translate="yes" xml:space="preserve">
          <source>Unless specifically constrained by a cache-control (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;)
   directive, a caching system MAY always store a successful response
   (see &lt;a href=&quot;#section-13.8&quot;&gt;section 13.8&lt;/a&gt;) as a cache entry, MAY return it without validation
   if it is fresh, and MAY return it after successful validation. If
   there is neither a cache validator nor an explicit expiration time
   associated with a response, we do not expect it to be cached, but
   certain caches MAY violate this expectation (for example, when little
   or no network connectivity is available). A client can usually detect
   that such a response was taken from a cache by comparing the Date
   header to the current time.

      Note: some HTTP/1.0 caches are known to violate this expectation
      without providing any Warning.

   However, in some cases it might be inappropriate for a cache to
   retain an entity, or to return it in response to a subsequent
   request. This might be because absolute semantic transparency is
   deemed necessary by the service author, or because of security or
   privacy considerations. Certain cache-control directives are
   therefore provided so that the server can indicate that certain
   resource entities, or portions thereof, are not to be cached
   regardless of other considerations.

   Note that &lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt; normally prevents a shared cache from saving
   and returning a response to a previous request if that request
   included an Authorization header.

   A response received with a status code of 200, 203, 206, 300, 301 or
   410 MAY be stored by a cache and used in reply to a subsequent
   request, subject to the expiration mechanism, unless a cache-control
   directive prohibits caching. However, a cache that does not support
   the Range and Content-Range headers MUST NOT cache 206 (Partial
   Content) responses.

   A response received with any other status code (e.g. status codes 302
   and 307) MUST NOT be returned in a reply to a subsequent request
   unless there are cache-control directives or another header(s) that
   explicitly allow it. For example, these include the following: an
   Expires header (&lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;); a &quot;max-age&quot;, &quot;s-maxage&quot;,  &quot;must-
   revalidate&quot;, &quot;proxy-revalidate&quot;, &quot;public&quot; or &quot;private&quot; cache-control
   directive (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">除非特别受cache-control（&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt;）指令约束，否则缓存系统可以始终存储成功的响应（请参见&lt;a href=&quot;#section-13.8&quot;&gt;第13.8节）。&lt;/a&gt;）作为缓存条目，如果它是新鲜的，则可以不经验证返回它，并且在成功验证后可以返回它。如果既没有缓存验证器，也没有明确的到期时间与响应相关联，则我们不希望缓存该缓存，但是某些缓存可能会违反此期望（例如，当很少或没有网络连接可用时）。客户端通常可以通过将Date标头与当前时间进行比较，来检测到这种响应是从缓存中获取的。注意：某些HTTP / 1.0缓存已知违反了此期望，而没有提供任何警告。但是，在某些情况下，缓存保留实体或响应后续请求返回实体可能是不合适的。这可能是因为服务作者认为绝对语义透明是必要的，或出于安全或隐私考虑。因此，提供了某些高速缓存控制指令，以便服务器可以指示某些资源实体或其一部分不考虑其他考虑因素而不会被高速缓存。注意&lt;a href=&quot;#section-14.8&quot;&gt;第14.8节&lt;/a&gt;通常会阻止共享缓存保存并返回对先前请求的响应（如果该请求包含Authorization标头）。状态码为200、203、206、300、301或410的响应可以由缓存存储，并用于响应后续请求（取决于到期机制），除非缓存控制指令禁止缓存。但是，不支持Range和Content-Range头的缓存必须不缓存206（部分内容）响应。除非有缓存控制指令或明确允许该请求的其他头，否则不得在对后续请求的答复中返回使用任何其他状态代码（例如状态代码302和307）接收到的响应。例如，这些内容包括：Expires标头（&lt;a href=&quot;#section-14.21&quot;&gt;第14.21条&lt;/a&gt;）; &amp;ldquo; max-age&amp;rdquo;，&amp;ldquo; s-maxage&amp;rdquo;，&amp;ldquo; must-revalidate&amp;rdquo;，&amp;ldquo; proxy-revalidate&amp;rdquo;，&amp;ldquo; public&amp;rdquo;或&amp;ldquo; private&amp;rdquo;缓存控制指令（&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6575621a518b7b48c43d42321f561d5d0b99d27e" translate="yes" xml:space="preserve">
          <source>Unless the origin server explicitly prohibits the caching of their
   responses, the application of GET and HEAD methods to any resources
   SHOULD NOT have side effects that would lead to erroneous behavior if
   these responses are taken from a cache. They MAY still have side
   effects, but a cache is not required to consider such side effects in
   its caching decisions. Caches are always expected to observe an
   origin server's explicit restrictions on caching.

   We note one exception to this rule: since some applications have
   traditionally used GETs and HEADs with query URLs (those containing a
   &quot;?&quot; in the rel_path part) to perform operations with significant side
   effects, caches MUST NOT treat responses to such URIs as fresh unless
   the server provides an explicit expiration time. This specifically
   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT
   be taken from a cache. See &lt;a href=&quot;#section-9.1.1&quot;&gt;section 9.1.1&lt;/a&gt; for related information.</source>
          <target state="translated">除非原始服务器明确禁止缓存其响应，否则将GET和HEAD方法应用于任何资源都不应产生副作用，如果这些响应是从缓存中获取的，则会导致错误的行为。它们可能仍然有副作用，但是不需要缓存来考虑其缓存决策中的此类副作用。总是希望缓存遵守源服务器对缓存的明确限制。我们注意到该规则的一个例外：由于某些应用程序传统上使用带有查询URL的GET和HEAD（在rel_path部分中包含&amp;ldquo;？&amp;rdquo;的URL）来执行具有明显副作用的操作，因此缓存不得将对此类URI的响应视为新鲜除非服务器提供明确的到期时间。这特别意味着，不应从缓存中获取来自HTTP / 1.0服务器对此类URI的响应。看到&lt;a href=&quot;#section-9.1.1&quot;&gt;&lt;/a&gt;有关相关信息，请参见第9.1.1节。</target>
        </trans-unit>
        <trans-unit id="a882eb5ce8619bac0f4ca38a47d118a374f590ac" translate="yes" xml:space="preserve">
          <source>Unless you have a very specific immediate need, don't use this deprecated technique; switch to HTTP/2 instead. In HTTP/2, domain sharding is no longer useful: the HTTP/2 connection is able to handle parallel unprioritized requests very well. Domain sharding is even detrimental to performance. Most HTTP/2 implementations use a technique called &lt;a href=&quot;https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/&quot;&gt;connection coalescing&lt;/a&gt; to revert eventual domain sharding.</source>
          <target state="translated">除非您有非常具体的即时需求，否则不要使用此不推荐使用的技术；改用HTTP / 2。在HTTP / 2中，域分片不再有用：HTTP / 2连接能够很好地处理并行的非优先级请求。域分片甚至会损害性能。大多数HTTP / 2实现使用一种称为&lt;a href=&quot;https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/&quot;&gt;连接合并&lt;/a&gt;的技术来还原最终的域分片。</target>
        </trans-unit>
        <trans-unit id="955f79db78c5cf8385c47043fef1a0ffa744352f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, &quot;preflighted&quot; requests first send an HTTP request by the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method to the resource on the other domain, in order to determine whether the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</source>
          <target state="translated">与&lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;简单请求&amp;rdquo;（如上所述）不同&lt;/a&gt;，&amp;ldquo;预检&amp;rdquo;请求首先通过&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;方法向另一个域上的资源发送HTTP请求，以确定实际请求是否可以安全发送。跨站点请求这样被预检，因为它们可能会影响用户数据。</target>
        </trans-unit>
        <trans-unit id="d273c3c1c262b7b14dbca55da7ae721b5a1b7cec" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, for &quot;preflighted&quot; requests the browser first sends an HTTP request using the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method to the resource on the other origin, in order to determine if the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e7352000385c24773b5c3b97548547d27dfcec" translate="yes" xml:space="preserve">
          <source>Unlike subsequent evolutions, there were no HTTP headers, meaning that only HTML files could be transmitted, but no other type of documents. There were no status or error codes: in case of a problem, a specific HTML file was send back with the description of the problem contained in it, for human consumption.</source>
          <target state="translated">与后来的演变不同,当时没有HTTP头,这意味着只能传输HTML文件,而不能传输其他类型的文件。当时没有状态或错误代码:如果出现问题,会发回一个特定的HTML文件,其中包含问题的描述,供人使用。</target>
        </trans-unit>
        <trans-unit id="dcc5e76d5034fe1dc84b95117a89364e895b52d1" translate="yes" xml:space="preserve">
          <source>Unlike the previous case, browser history will consider non-www and www URLs as independent entries.</source>
          <target state="translated">与前一种情况不同的是,浏览器的历史记录会将非www和www网址视为独立的条目。</target>
        </trans-unit>
        <trans-unit id="7607e9b76ed3569248e88c3e032d8ff230e82e7b" translate="yes" xml:space="preserve">
          <source>Unoptimized (poorly compressed) images</source>
          <target state="translated">未优化(压缩得不好)的图像。</target>
        </trans-unit>
        <trans-unit id="b89f58bc5f8bec30721ee6218fbce69f661ae508" translate="yes" xml:space="preserve">
          <source>Unoptimized images</source>
          <target state="translated">未优化的图像</target>
        </trans-unit>
        <trans-unit id="245e0bd02f62833b644643c9a2e8742e64c2dd7a" translate="yes" xml:space="preserve">
          <source>Unrecognized markup in an Atom Publishing Protocol document is
   considered &quot;foreign markup&quot; as defined in &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; of the Atom
   Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  Foreign markup can be used anywhere
   within a Category or Service Document unless it is explicitly
   forbidden.  Processors that encounter foreign markup MUST NOT stop
   processing and MUST NOT signal an error.  Clients SHOULD preserve
   foreign markup when transmitting such documents.

   The namespace name &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; is reserved for
   forward-compatible revisions of the Category and Service Document
   types.  This does not exclude the addition of elements and attributes
   that might not be recognized by processors conformant to this
   specification.  Such unrecognized markup from the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace MUST be treated as foreign
   markup.</source>
          <target state="translated">Atom发布协议文档中无法识别的标记被视为&amp;ldquo;外国标记&amp;rdquo;，如Atom联合格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]的&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;所定义。除非明确禁止，否则外部标记可以在类别或服务文档中的任何位置使用。遇到外来标记的处理器不得停止处理，也不得发出错误信号。客户在发送此类文件时应保留外国标记。命名空间名称&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&amp;ldquo;是为类别和服务文档类型的前向兼容修订版本保留的。这并不排除添加符合本规范的处理器可能无法识别的元素和属性&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;。&amp;rdquo; w3.org/2007/app&lt;/a&gt; &amp;ldquo;命名空间必须视为外部标记。</target>
        </trans-unit>
        <trans-unit id="de81198fe40f54ca54fd480498f47c5bd2c4979b" translate="yes" xml:space="preserve">
          <source>Unsafe eval expressions</source>
          <target state="translated">不安全的评价表达式</target>
        </trans-unit>
        <trans-unit id="83339b270595929064cc25f1d47c8f0230812a35" translate="yes" xml:space="preserve">
          <source>Unsafe inline script</source>
          <target state="translated">不安全的内联脚本</target>
        </trans-unit>
        <trans-unit id="a3661e5b83227307acd4850c07a9aaa4a3205ae7" translate="yes" xml:space="preserve">
          <source>Unsafe inline styles</source>
          <target state="translated">不安全的内联样式</target>
        </trans-unit>
        <trans-unit id="b9c54338e2e3842fa7755217571c1728460781da" translate="yes" xml:space="preserve">
          <source>Unsafe style expressions</source>
          <target state="translated">不安全的风格表达</target>
        </trans-unit>
        <trans-unit id="51e569288fd4c9764275c80909467d65bb077394" translate="yes" xml:space="preserve">
          <source>Unsized media</source>
          <target state="translated">无尺寸媒体</target>
        </trans-unit>
        <trans-unit id="5428a4130e5ace79ec66056cc912fe9f4aab15ba" translate="yes" xml:space="preserve">
          <source>Unsupported digests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d0f6e963af156d3bbc20c425d63949186d2932" translate="yes" xml:space="preserve">
          <source>Until browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c20faccf27f6079a0458f999820126675b4735" translate="yes" xml:space="preserve">
          <source>Until version 75, downloads for files with this header would fail in Chrome. See &lt;a href=&quot;https://crbug.com/952834&quot;&gt;bug 952834&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb9592768ded8c17e4696edcc1f40830d0ef453" translate="yes" xml:space="preserve">
          <source>Until version 75, downloads for files with this header would fail in WebView. See &lt;a href=&quot;https://crbug.com/952834&quot;&gt;bug 952834&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a7c8e0f8f826b048cc60b6edd36eb21796fb60" translate="yes" xml:space="preserve">
          <source>Updated. The request resulted in a potential change to the tracking status applicable to this user, user agent, or device.</source>
          <target state="translated">已更新。该请求导致适用于该用户、用户代理或设备的跟踪状态可能发生变化。</target>
        </trans-unit>
        <trans-unit id="a6f47e00e036c5589eb12e237894b37fb015d365" translate="yes" xml:space="preserve">
          <source>Upgrade</source>
          <target state="translated">Upgrade</target>
        </trans-unit>
        <trans-unit id="ac2a73c827836daeaf2402394c054c2277994448" translate="yes" xml:space="preserve">
          <source>Upgrade (RFC 2616)</source>
          <target state="translated">升级(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="541adf48138ad8391190feed85e1730b3e897f18" translate="yes" xml:space="preserve">
          <source>Upgrade Insecure Requests</source>
          <target state="translated">升级不安全的请求</target>
        </trans-unit>
        <trans-unit id="03453046fa615930ff26806bfd5e6e667dba241d" translate="yes" xml:space="preserve">
          <source>Upgrade Insecure Requests&lt;br/&gt;&lt;small&gt;The definition of 'upgrade-insecure-requests' in that specification.&lt;/small&gt;</source>
          <target state="translated">升级不安全请求&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;升级不安全请求&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="61c6967492e019e22cb265be59268846e0812c5e" translate="yes" xml:space="preserve">
          <source>Upgrade-Insecure-Requests</source>
          <target state="translated">Upgrade-Insecure-Requests</target>
        </trans-unit>
        <trans-unit id="3b1e9dd129f9691779584493ef0cbd2760709427" translate="yes" xml:space="preserve">
          <source>Upgrading HTTP/1.1 Connections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373052ca50b595448fddb3ae3555f3abe2335a7b" translate="yes" xml:space="preserve">
          <source>Upgrading an HTTP connection to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with the token &lt;code&gt;&quot;TLS/1.0&quot;&lt;/code&gt;. If the switch is made successfully, the original request (which included &lt;code&gt;Upgrade&lt;/code&gt;) is completed as normal, but on the TLS connection.</source>
          <target state="translated">升级HTTP连接以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS会&lt;/a&gt;使用带有令牌 &lt;code&gt;&quot;TLS/1.0&quot;&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头。如果切换成功，则原始请求（包括 &lt;code&gt;Upgrade&lt;/code&gt; ）将正常完成，但通过TLS连接完成。</target>
        </trans-unit>
        <trans-unit id="ab6bbb4d08469c650377ccf5de1a9d9d4253b906" translate="yes" xml:space="preserve">
          <source>Upgrading to TLS Within HTTP/1.1</source>
          <target state="translated">在HTTP/1.1中升级到TLS。</target>
        </trans-unit>
        <trans-unit id="4a01efdfa6f7b943dbd14d96f1bbda14ed6ca745" translate="yes" xml:space="preserve">
          <source>Upgrading to a WebSocket connection</source>
          <target state="translated">升级到WebSocket连接</target>
        </trans-unit>
        <trans-unit id="0df7fec503cc297ba369a863eb42d823f8a3ecf0" translate="yes" xml:space="preserve">
          <source>Upgrading to an HTTP/2 connection</source>
          <target state="translated">升级到HTTP/2连接</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="92d99b032888bf69448943e3813f272f0f43c556" translate="yes" xml:space="preserve">
          <source>Usage notes</source>
          <target state="translated">使用说明</target>
        </trans-unit>
        <trans-unit id="206d556a43a2ee8de81319e120005dc792bee741" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;isInNet()&lt;/code&gt;, &lt;code&gt;isResolvable()&lt;/code&gt; and &lt;code&gt;dnsResolve()&lt;/code&gt; functions should be carefully considered, as they require the DNS server to be consulted. All the other autoconfig-related functions are mere string-matching functions that don't require the use of a DNS server. If a proxy is used, the proxy will perform its DNS lookup which would double the impact on the DNS server. Most of the time these functions are not necessary to achieve the desired result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609254f79607923f3629c1a1e3f48cf232c1eba4" translate="yes" xml:space="preserve">
          <source>Use SOCKS if the primary proxy goes down.</source>
          <target state="translated">如果主代理发生故障,请使用SOCKS。</target>
        </trans-unit>
        <trans-unit id="8b4ff35cb43293441d2110cc488f4176d62f368d" translate="yes" xml:space="preserve">
          <source>Use and Interpretation of HTTP Version Numbers</source>
          <target state="translated">HTTP版本号的使用和解释</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
