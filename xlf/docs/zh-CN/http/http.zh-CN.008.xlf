<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="973c4945198f89ca852f9330ea8ecbaa87253ef7" translate="yes" xml:space="preserve">
          <source>There is effort from browsers in moving to a stricter default value, namely &lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; (see &lt;a href=&quot;https://github.com/whatwg/fetch/pull/952&quot;&gt;https://github.com/whatwg/fetch/pull/952&lt;/a&gt;), consider using this value (or a stricter one), if possible, when changing the Referrer-Policy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357745e961c49e7808944a7f96ad3fca2b616dd4" translate="yes" xml:space="preserve">
          <source>There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.</source>
          <target state="translated">这个请求没有内容要发送,但头文件可能有用。用户代理可能会用新的头文件来更新这个资源的缓存头文件。</target>
        </trans-unit>
        <trans-unit id="2f5a6e5a3d7f30adf4bc4c7e14047c3ad52fec62" translate="yes" xml:space="preserve">
          <source>There is no way to deal with this problem without annoying one of the two clients. However, lost updates and race conditions are to be avoided. We want predictable results, and expect that the clients are notified when their changes are rejected.</source>
          <target state="translated">在不烦扰两个客户端中的一个客户端的情况下,没有办法处理这个问题。但是,要避免丢失更新和比赛条件。我们希望得到可预测的结果,并希望客户的更改被拒绝时能得到通知。</target>
        </trans-unit>
        <trans-unit id="5746b1d21828f38918b30138869ef276f2228158" translate="yes" xml:space="preserve">
          <source>There is one associative array already defined (because a JavaScript currently cannot define them on its own):</source>
          <target state="translated">已经定义了一个关联数组(因为目前JavaScript无法自行定义它们)。</target>
        </trans-unit>
        <trans-unit id="d277b5fa967b80dbc6939e7b654fcee1641c47de" translate="yes" xml:space="preserve">
          <source>There may be cases where a client wishes to submit state tokens, but
   doesn't want the request to fail just because the state token isn't
   current anymore.  One simple way to do this is to include a Condition
   that is known to always evaluate to true, such as in:

     If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;)
       (Not &amp;lt;DAV:no-lock&amp;gt;)

   &quot;DAV:no-lock&quot; is known to never represent a current lock token.  Lock
   tokens are assigned by the server, following the uniqueness
   requirements described in &lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;, therefore cannot use the
   &quot;DAV:&quot; scheme.  Thus, by applying &quot;Not&quot; to a state token that is 

   known not to be current, the Condition always evaluates to true.
   Consequently, the whole If header will always evaluate to true, and
   the lock token urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 will be
   submitted in any case.</source>
          <target state="translated">在某些情况下，客户希望提交状态令牌，但不希望仅因为状态令牌不再有效而导致请求失败。一种简单的方法是包含一个条件，该条件始终被评估为true，例如：If：（&amp;lt;urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;）（Not &amp;lt;DAV：no- lock&amp;gt;）已知&amp;ldquo; DAV：no-lock&amp;rdquo;从不代表当前的锁定令牌。锁定令牌由服务器分配，遵循&lt;a href=&quot;#section-6.5&quot;&gt;第6.5节中&lt;/a&gt;描述的唯一性要求，因此不能使用&amp;ldquo; DAV：&amp;rdquo;方案。因此，通过对已知不是当前状态的状态令牌应用&amp;ldquo;非&amp;rdquo;，条件始终评估为true。因此，整个If标头将始终为true，并且无论如何都将提交锁定令牌urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2。</target>
        </trans-unit>
        <trans-unit id="ea32afad30d9372a076356ddcbf2224780548842" translate="yes" xml:space="preserve">
          <source>There may be other regulations governing the use of cookies in your locality. The burden is on you to know and comply with these regulations. There are companies that offer &quot;cookie banner&quot; code that helps you comply with these regulations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2490d9396fd52fc708c5e36b206a6d2e488dee63" translate="yes" xml:space="preserve">
          <source>There should always be a confirmation required for any sensitive action.</source>
          <target state="translated">任何敏感的行动都应该有一个确认的要求。</target>
        </trans-unit>
        <trans-unit id="291573b8b0016bfdbfee8add5e78d0c5e2c87fdd" translate="yes" xml:space="preserve">
          <source>There was one associative array (object) already defined, because at the time JavaScript code was unable to define it by itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8936e6969eea24b3ea42fd8769c85fdddd316b" translate="yes" xml:space="preserve">
          <source>These HTTP codes are not redefined, but their use is somewhat
   extended by WebDAV methods and requirements.  In general, many HTTP
   status codes can be used in response to any request, not just in
   cases described in this document.  Note also that WebDAV servers are
   known to use 300-level redirect responses (and early interoperability
   tests found clients unprepared to see those responses).  A 300-level
   response MUST NOT be used when the server has created a new resource
   in response to the request.</source>
          <target state="translated">这些HTTP代码并没有被重新定义,但它们的使用在一定程度上被WebDAV方法和要求所扩展。一般来说,许多HTTP状态码可以用于响应任何请求,而不仅仅是本文档中描述的情况。还请注意,WebDAV服务器已知使用300级重定向响应(早期的互操作性测试发现客户端没有准备好看到这些响应)。当服务器为响应请求而创建了新的资源时,决不能使用300级响应。</target>
        </trans-unit>
        <trans-unit id="d2011ed2f18ef5bdd96144452aa6435ca84d3624" translate="yes" xml:space="preserve">
          <source>These URLs are examples &amp;mdash; the site could serve the different filetypes with any URL patterns it wishes, such as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;query string parameter&lt;/a&gt;: &lt;code&gt;/documents/foo?format=json&lt;/code&gt;, &lt;code&gt;/documents/foo?format=xml&lt;/code&gt;, and so on.</source>
          <target state="translated">这些URL是示例-网站可以使用其希望的任何URL模式提供不同的文件类型，例如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;查询字符串参数&lt;/a&gt;： &lt;code&gt;/documents/foo?format=json&lt;/code&gt; ， &lt;code&gt;/documents/foo?format=xml&lt;/code&gt; 等等。</target>
        </trans-unit>
        <trans-unit id="19ac2e7adff1466c1a8f79fcbd5235600c8aac56" translate="yes" xml:space="preserve">
          <source>These URLs will be rewritten before the request is made, meaning that no insecure requests will hit the network. Note that, if the requested resource is not actually available via HTTPS, the request will fail without any fallback to HTTP.</source>
          <target state="translated">这些URL将在请求之前被重写,这意味着不会有不安全的请求冲击网络。请注意,如果请求的资源实际上无法通过HTTPS获得,则请求将失败,而不会回退到HTTP。</target>
        </trans-unit>
        <trans-unit id="14aea1eca27b905f4bb97521d425369003cb4f07" translate="yes" xml:space="preserve">
          <source>These are some sample UA strings from other Gecko-based browsers on various platforms. Note that many of these have not yet been released on Gecko 2.0!</source>
          <target state="translated">这是一些来自不同平台上其他基于Gecko的浏览器的UA字符串示例。请注意,其中许多还没有在Gecko 2.0上发布。</target>
        </trans-unit>
        <trans-unit id="f6caceedce573b19f722b4be7d0ac77739c262ca" translate="yes" xml:space="preserve">
          <source>These are the values sent when the context doesn't give better information. Note that all browsers add the &lt;code&gt;*/*&lt;/code&gt; MIME Type to cover all cases. This is typically used for requests initiated via the address bar of a browser, or via an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">这些是在上下文无法提供更好信息时发送的值。请注意，所有浏览器都会添加 &lt;code&gt;*/*&lt;/code&gt; MIME类型以涵盖所有情况。通常用于通过浏览器的地址栏或HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt;元素发起的请求。</target>
        </trans-unit>
        <trans-unit id="63ded4498d8ac164d315a41831a90dda911d2194" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="translated">这四个构建基块已在1990年底完成，并且第一批服务器已在1991年初在CERN外部运行。1991年8月6 &lt;sup&gt;日&lt;/sup&gt;，蒂姆&amp;middot;伯纳斯&amp;middot;李（Tim Berners-Lee）在公共&lt;em&gt;alt.post&lt;/em&gt;上的&lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;帖子&lt;/a&gt;现在被认为是官方的互联网作为公共项目的开始。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0baa00267d012f566fcf313a5a48be2638b11dd3" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe283302753b3d4f0050a7e568fff6e5641e1e65" translate="yes" xml:space="preserve">
          <source>These functions can be used in building the PAC file:</source>
          <target state="translated">这些功能可以用于建立PAC文件。</target>
        </trans-unit>
        <trans-unit id="1a84013246b548f38ea0c6cbcd4306fd09b1fd50" translate="yes" xml:space="preserve">
          <source>These headers &lt;em&gt;must&lt;/em&gt; be transmitted to the final recipient of the message: the server for a request, or the client for a response. Intermediate proxies must retransmit these headers unmodified and caches must store them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adec7a72aca0f353da15e6ce23d6fb621cfcba41" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection and must not be retransmitted by proxies or cached. Such headers are: &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="translated">这些标头仅对单个传输级连接有意义，并且不得由代理重新传输或缓存。这样的标头是：&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;。请注意，只能使用&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;常规标头设置逐跳标头。</target>
        </trans-unit>
        <trans-unit id="c6d30d003653ac1d60828803e6858dd6022c5e88" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection, and &lt;em&gt;must not&lt;/em&gt; be retransmitted by proxies or cached. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed24fa2e76be943bae964dfeca098c8b6b9d0285" translate="yes" xml:space="preserve">
          <source>These headers must be transmitted to the final recipient of the message; that is, the server for a request or the client for a response. Intermediate proxies must retransmit end-to-end headers unmodified and caches must store them.</source>
          <target state="translated">这些报头必须传送给消息的最终接收者,即请求的服务器或响应的客户端。中间代理必须不加修改地重传端到端报头,缓存必须存储这些报头。</target>
        </trans-unit>
        <trans-unit id="49c4698bda080192aa7cae79c66f0082e395ce72" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it get traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="translated">引入这些新颖性并不是为了共同努力，而是作为1991-1995年间的一种试用方法：服务器和浏览器添加了一个功能，并观察了它是否吸引了人们。许多互操作性问题很常见。为了解决这些烦恼，1996年11月，发布了描述通用做法的信息文档&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;。这是HTTP / 1.0的定义，值得注意的是，它不是官方标准。</target>
        </trans-unit>
        <trans-unit id="970955263d6d4ddd63f73c663170a288a2997da3" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it got traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3e47aa5ab3cee6753961966b6b7cea5b1c2b29" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should no longer be used, and replaced with the new one.Search engine robots, RSS readers, and other crawlers will update the original URL for the resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c006f1681899103b8b2e153338a77be2fac29883" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should not be used anymore and that the new one is preferred. Search engine robots trigger an update of the associated URL for the resource in their indexes.</source>
          <target state="translated">这些重定向的目的是为了永久保存。它们意味着原来的URL不应再被使用,新的URL是首选。搜索引擎机器人会触发其索引中资源的相关URL的更新。</target>
        </trans-unit>
        <trans-unit id="a400740c640b1a2456fc464d677ae89fe9a9ea33" translate="yes" xml:space="preserve">
          <source>These regulations have global reach, because they apply to any site on the &lt;em&gt;World Wide&lt;/em&gt; Web that is accessed by users from these jurisdictions (the EU and California, with the caveat that California's law applies only to entities with gross revenue over 25 million USD, among other things.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d896ad159048e4b552eaa0836d02af56e04f2aad" translate="yes" xml:space="preserve">
          <source>These regulations include requirements such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3faadcdd29a9a6bfd08a2c7df57422c7e3b140f" translate="yes" xml:space="preserve">
          <source>These types of manipulations can be prevented by disallowing Javascript via the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; CSP directive.</source>
          <target state="translated">可以通过使用&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; CSP指令禁止Javascript来阻止这些类型的操作。</target>
        </trans-unit>
        <trans-unit id="b94cf424727db244876c5a0b8a36ae1be82af513" translate="yes" xml:space="preserve">
          <source>They exist. They are hard to defend against. Research continues.
   Beware.</source>
          <target state="translated">它们是存在的。它们很难抵御。研究还在继续。小心。</target>
        </trans-unit>
        <trans-unit id="2b2bbfc5127ae16613bef18603ec77b3984aa83a" translate="yes" xml:space="preserve">
          <source>They should always provide a way to overcome the server-chosen language, e.g., by providing a language menu on the site. Most user-agents provide a default value for the &lt;code&gt;Accept-Language&lt;/code&gt; header, adapted to the user interface language and end users often do not modify it, either by not knowing how, or by not being able to do it, as in an Internet caf&amp;eacute; for instance.</source>
          <target state="translated">他们应该始终提供一种克服服务器选择的语言的方法，例如，通过在站点上提供语言菜单。大多数用户代理会为 &lt;code&gt;Accept-Language&lt;/code&gt; 标头提供默认值，以适应用户界面语言，并且最终用户通常不了解它，或者因为不知道如何或无法做到而不能修改它，例如在网吧中例如。</target>
        </trans-unit>
        <trans-unit id="d3bab67bcd21378560c58ae4bc5a035031a2e0e6" translate="yes" xml:space="preserve">
          <source>Third-party cookies</source>
          <target state="translated">第三方饼干</target>
        </trans-unit>
        <trans-unit id="78174180aec78d0cf1800defae73ef9440efe127" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; and worker are blocked and won't load:</source>
          <target state="translated">此&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;和worker被阻止，无法加载：</target>
        </trans-unit>
        <trans-unit id="f02d516991c23089fc7ef470b5b1f7122a1b1ddc" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; can enable cross-site HTTP requests for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd32e06ea9f72392b7e2d0f29fca1199727c26bb" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; is used to enable cross-site HTTP requests for:</source>
          <target state="translated">此&lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;跨域共享标准&lt;/a&gt;用于为以下站点启用跨站点HTTP请求：</target>
        </trans-unit>
        <trans-unit id="451546fb091c1c1b7ec24fc3cf824086880d3078" translate="yes" xml:space="preserve">
          <source>This Warning code MUST be added by a proxy if it applies any
   transformation to the representation, such as changing the
   content-coding, media-type, or modifying the representation data,
   unless this Warning code already appears in the response.</source>
          <target state="translated">如果代理对表示进行任何转换,例如改变内容编码、媒体类型或修改表示数据,则必须添加此Warning代码,除非此Warning代码已经出现在响应中。</target>
        </trans-unit>
        <trans-unit id="8c5ceee1b632af499883fff54e65911348e83c82" translate="yes" xml:space="preserve">
          <source>This Webpage has a redirect loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ecbc255cf2ecd1c85dbf2f6ac85289ceb68820" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;X-My-Custom-Header&lt;/code&gt; and &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; headers to be exposed to the browser.</source>
          <target state="translated">这允许 &lt;code&gt;X-My-Custom-Header&lt;/code&gt; 和 &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; 标题公开给浏览器。</target>
        </trans-unit>
        <trans-unit id="d793e4bdbd751c7b733ab0e15d263a1a9069b84e" translate="yes" xml:space="preserve">
          <source>This appendix is informative.

   The Relax NG schema explicitly excludes elements in the Atom Protocol
   namespace that are not defined in this revision of the specification.
   Requirements for Atom Protocol processors encountering such markup
   are given in Sections &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   The Schema for Service Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace xhtml = &quot;&lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appService

   # common:attrs

   atomURI = text

   appCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag  }?,
      attribute xml:space {&quot;default&quot;|&quot;preserved&quot;}?,
      undefinedAttribute*

   atomCommonAttributes = appCommonAttributes

   undefinedAttribute = attribute * - (xml:base | xml:space  | xml:lang
     | local:*) { text }

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   } 

   atomDateConstruct =
       appCommonAttributes,
       xsd:dateTime

   # app:service
   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }

   # app:workspace

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }

   # app:collection

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }

   # app:categories

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # app:accept

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }

   # Simple Extension

   simpleSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         text
      }

   simpleExtensionElement =
      element * - (app:*) {
         text
      }

   # Structured Extension

   structuredSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      } 

   structuredExtensionElement =
      element * - (app:*) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      }

   # Other Extensibility

   extensionSansTitleElement =
    simpleSansTitleExtensionElement|structuredSansTitleExtensionElement

   extensionElement = simpleExtensionElement |
      structuredExtensionElement

   undefinedContent = (text|anyForeignElement)*

   # Extensions

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - app:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   atomPlainTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;text&quot; | &quot;html&quot; }?,
       text

   atomXHTMLTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;xhtml&quot; },
       xhtmlDiv

   atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct 

   anyXHTML = element xhtml:* {
       (attribute * { text }
        | text
        | anyXHTML)*
   }

   xhtmlDiv = element xhtml:div {
     (attribute * { text }
      | text
      | anyXHTML)*
   }

   # EOF

   The Schema for Category Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appCategories

   atomCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag }?,
      undefinedAttribute*

   undefinedAttribute = attribute * - (xml:base | xml:lang | local:*) {
     text }

   atomURI = text

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   }

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           (empty)
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # Extensibility

   undefinedContent = (text|anyForeignElement)*

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - atom:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   # EOF 

Authors' Addresses

   Joe Gregorio (editor)
   Google

   EMail: joe@bitworking.org
   URI:   &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt;


   Bill de hOra (editor)
   NewBay Software

   EMail: bill@dehora.net
   URI:   &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Gregorio &amp;amp; de hOra          Standards Track                    [Page 53]</source>
          <target state="translated">本附录内容丰富。 Relax NG模式明确排除了Atom协议名称空间中在此规范修订版中未定义的元素。遇到这种标记的Atom协议处理器的要求在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]的&lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;和&lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;节中给出。服务文档的架构：＃-*-rnc-*-＃Atom协议名称空间的RELAX NG紧凑语法语法=&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;rdquo;名称空间atom =&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http：// www.w3.org/2005/Atom&lt;/a&gt; &amp;ldquo;名称空间xsd =&amp;rdquo; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt; &amp;ldquo;名称空间xhtml =&amp;rdquo; &lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&amp;ldquo;名称空间local =&amp;rdquo;&amp;ldquo;开始= appService＃common：attrs atomURI =文本appCommonAttributes =属性xml：base {atomURI} ?，属性xml：lang {atomLanguageTag} ?，属性xml：space {&amp;rdquo; default&amp;ldquo; |&amp;rdquo;保存&amp;ldquo;}？ ，undefinedAttribute * atomCommonAttributes = appCommonAttributes undefinedAttribute =属性*-（xml：base | xml：space | xml：lang | local：*）{text} atomLanguageTag = xsd：string {pattern =&amp;ldquo;（[[A-Za-z] {1 ，8}（-[A-Za-z0-9] {1,8}）*）？&amp;ldquo;}} atomDateConstruct = appCommonAttributes，xsd：dateTime＃app：service appService =元素app：service {appCommonAttributes，（appWorkspace +＆extensionElement * }}＃app：workspace appWorkspace =元素app：工作区{appCommonAttributes，（atomTitle＆appCollection *＆extensionSansTitleElement *）} atomTitle =元素atom：title {atomTextConstruct}＃app：collection appCollection =元素app：collection {appCommonAttributes，属性href {atomURI}，（atomTitle＆appAccept *＆appCategories * ＆extensionSansTitleElement *）}＃app：categories atomCategory =元素atom：category {atomCommonAttributes，属性项{text}，属性方案{atomURI} ?，属性标签{text} ？， undefinedContent} appInlineCategories =元素app：categories {属性已固定{ &amp;ldquo;是&amp;rdquo; | &amp;ldquo; no&amp;rdquo;} ?,属性方案{atomURI} ?,（atomCategory *，undefinedContent）} appOutOfLineCategories =元素app：categories {attribute href {atomURI}，undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories＃app：accept appAccept =元素app：accept {appCommonAttributes，（text？）}＃简单扩展simpleSansTitleExtensionElement = element *-（app：* | atom：title）{text} simpleExtensionElement = element *-（app：*）{文本}＃结构化扩展结构化SansTitleExtensionElement =元素*-（app：* | atom：title）{（属性* {文本} +，（text | anyElement）*）| （属性* {文本} *，（文本？，anyElement +，（text | anyElement）*））} StructuralExtensionElement =元素*-（app：*）{（attribute * {text} +，（text | anyElement）*）| （attribute * {text} *，（text ?, anyElement +，（text | anyElement）*））}＃其他可扩展性extensionSansTitleElement = simpleSansTitleExtensionElement | structuredSansTitleExtensionElement extensionElement = simpleExtensionElement | StructuralExtensionElement undefinedContent =（text | anyForeignElement）*＃扩展anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-app：* {（attribute {{text} | text | anyElement）* } atomPlainTextConstruct = atomCommonAttributes，属性类型{&amp;ldquo; text&amp;rdquo; | &amp;ldquo; html&amp;rdquo;} ?，文本atomXHTMLTextConstruct = atomCommonAttributes，属性类型{&amp;ldquo; xhtml&amp;rdquo;}，xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML =元素xhtml：* {（属性* {文本} |文本| anyXHTML）*} xhtmlDiv =元素xhtml：div {（属性* {文本} |文本| anyXHTML）*}＃EOF类别文档的架构：＃ -*-rnc-*-＃Atom协议名称空间应用的RELAX NG精简语法=xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML =元素xhtml：* {（属性* {文本} |文本| anyXHTML）*} xhtmlDiv =元素xhtml：div {（属性* {文本} |文本| anyXHTML）*}＃EOF类别文档的架构：＃ -*-rnc-*-＃Atom协议名称空间app的RELAX NG紧凑语法语法=&amp;ldquo;xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML =元素xhtml：* {（属性* {文本} |文本| anyXHTML）*} xhtmlDiv =元素xhtml：div {（属性* {文本} |文本| anyXHTML）*}＃EOF类别文档的架构：＃ -*-rnc-*-＃Atom协议名称空间应用的RELAX NG精简语法=&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;ldquo;命名空间atom =&amp;rdquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &amp;ldquo;命名空间xsd =&amp;rdquo; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&amp;ldquo;名称空间local =&amp;rdquo;&amp;ldquo;开始= appCategories atomCommonAttributes =属性xml：base {atomURI} ?，属性xml：lang {atomLanguageTag} ?， undefinedAttribute * undefinedAttribute =属性*-（xml：base | xml：lang | local：*）{文字} atomURI =文字atomLanguageTag = xsd：string {模式=&amp;ldquo;（[[A-Za-z] {1,8}（-[A-Za-z0-9] {1,8}）*）？&amp;rdquo;}} atomCategory =元素atom：category {atomCommonAttributes，属性术语{text}，属性方案{atomURI} ？，属性标签{text} ？， undefinedContent} appInlineCategories =元素app：categories {属性固定{&amp;ldquo; yes&amp;rdquo; |&amp;ldquo; no&amp;rdquo;} ？，属性方案{atomURI} ?,（atomCategory *，undefinedContent）} appOutOfLineCategories =元素app：categories {attribute href {atomURI}，（empty）} appCategories = appInlineCategories | appOutOfLineCategories＃可扩展性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（{attribute * {text} | text | anyElement）* }＃EOF作者的地址Joe Gregorio（编辑）Google电子邮件：joe@bitworking.org URI：（空）} appCategories = appInlineCategories | appOutOfLineCategories＃可扩展性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（attribute {{text} | text | anyElement）* }＃EOF作者的地址Joe Gregorio（编辑）Google电子邮件：joe@bitworking.org URI：（空）} appCategories = appInlineCategories | appOutOfLineCategories＃可扩展性undefinedContent =（text | anyForeignElement）* anyElement = element * {（attribute * {text} | text | anyElement）*} anyForeignElement = element *-atom：* {（attribute {{text} | text | anyElement）* }＃EOF作者的地址Joe Gregorio（编辑）Google电子邮件：joe@bitworking.org URI：* {（属性* {文本} |文本| anyElement）*}＃EOF作者的地址Joe Gregorio（编辑）Google EMail：joe@bitworking.org URI：* {（属性* {文本} |文本| anyElement）*}＃EOF作者的地址Joe Gregorio（编辑）Google EMail：joe@bitworking.org URI： &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt; Bill de hOra（编辑）NewBay Software电子邮件：bill@dehora.net URI：&lt;a href=&quot;http://dehora.net/&quot;&gt;http&lt;/a&gt; ://dehora.net/ 完整的版权声明版权所有（C）IETF Trust（2007年）。本文档受&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78中&lt;/a&gt;包含的权利，许可和限制的约束，除非另有说明，否则作者保留所有权利。本文档及其中包含的信息均按&amp;ldquo;原样&amp;rdquo;提供，并且贡献者，他/她代表的组织或赞助者（如果有），互联网社会，IETF信托和互联网工程任务强制免责声明明示或暗示的担保，包括但不限于任何担保，即使用此处的信息不会侵犯任何权利或对特定用途的适销性或适用性的任何默示担保。知识产权IETF对于可能声称与实施或使用本文档中描述的技术有关的任何知识产权或其他权利的有效性或范围，或根据此类权利获得的任何许可可能或不具有的范围，不采取任何立场。可能不可用；它也不表示它已做出任何独立的努力来确定任何此类权利。可以在以下位置找到有关RFC文档中有关权利的程序的信息：&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;。可以获取向IETF秘书处披露的IPR的副本，以及可以提供的任何许可保证，或者本规范的实施者或用户尝试获得一般许可或使用此类所有权的许可的结果。从&lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;的IETF在线IPR存储库中获得 。 IETF邀请任何感兴趣的一方提请其注意任何版权，专利或专利申请，或可能涵盖实施该标准所需技术的其他所有权。请通过ietf-ipr@ietf.org将信息发送给IETF。 Gregorio＆de hOra标准跟踪[页53]</target>
        </trans-unit>
        <trans-unit id="2da261bce7b3f1d3df96b4c74a292834af8e4041" translate="yes" xml:space="preserve">
          <source>This article documents the default values for the HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; header for specific inputs and browser versions.</source>
          <target state="translated">本文记录了特定输入和浏览器版本的HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; 标头的默认值。</target>
        </trans-unit>
        <trans-unit id="76ccc899841c5ef0fd03f785dbd8994ed74b0227" translate="yes" xml:space="preserve">
          <source>This article is a general discussion of Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.</source>
          <target state="translated">本文是对跨源资源共享的一般性讨论,包括对必要的HTTP头文件的讨论。</target>
        </trans-unit>
        <trans-unit id="f43366408332e68939fb55f17a9ba0a7c3e2020f" translate="yes" xml:space="preserve">
          <source>This article provides guidance on how to choose whether to use a www-prefixed domain or not, along with the consequences of that choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ec7728272d28393919275489b46845b2a0bf81" translate="yes" xml:space="preserve">
          <source>This can be done easily using the command-line &lt;code&gt;uuencode&lt;/code&gt; utility on Linux and Mac OS X systems:</source>
          <target state="translated">使用Linux和Mac OS X系统上的命令行 &lt;code&gt;uuencode&lt;/code&gt; 实用程序可以轻松完成此操作：</target>
        </trans-unit>
        <trans-unit id="11f06821ff38b68a8a006d81f07fe9d41afdd57e" translate="yes" xml:space="preserve">
          <source>This can be useful for serving content dynamically, for example. When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. If you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. In addition, it can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">例如，这对于动态提供内容很有用。使用 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 标头时，缓存服务器在决定是否从缓存中提供页面时应考虑用户代理。如果您要向移动用户提供不同的内容，则可以帮助您避免缓存可能会错误地为移动用户提供网站的桌面版本。此外，它还可以帮助Google和其他搜索引擎发现网页的移动版本，并且还可以告诉他们没有&lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;隐瞒&lt;/a&gt;的意图。</target>
        </trans-unit>
        <trans-unit id="18b253862e749024a5a8be5438a282e1f0a396b5" translate="yes" xml:space="preserve">
          <source>This can happen if the JavaScript code is running with enhanced privileges allowing it access to multiple domains' content, for example.</source>
          <target state="translated">例如,如果JavaScript代码运行时具有增强的权限,允许它访问多个域的内容,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d58af569eba5200f4747d5689b8ff7e7d1d52941" translate="yes" xml:space="preserve">
          <source>This class of status code indicates a provisional response,
   consisting only of the Status-Line and optional headers, and is
   terminated by an empty line. There are no required headers for this
   class of status code. Since HTTP/1.0 did not define any 1xx status
   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client
   except under experimental conditions.

   A client MUST be prepared to accept one or more 1xx status responses
   prior to a regular response, even if the client does not expect a 100
   (Continue) status message. Unexpected 1xx status responses MAY be
   ignored by a user agent.

   Proxies MUST forward 1xx responses, unless the connection between the
   proxy and its client has been closed, or unless the proxy itself
   requested the generation of the 1xx response. (For example, if a 

   proxy adds a &quot;Expect: 100-continue&quot; field when it forwards a request,
   then it need not forward the corresponding 100 (Continue)
   response(s).)</source>
          <target state="translated">这类状态码表示临时响应,仅由状态行和可选的头信息组成,并以空行结束。这类状态码没有必要的头信息。由于HTTP/1.0没有定义任何1xx状态码,服务器必须不向HTTP/1.0客户端发送1xx响应,除非在实验条件下。客户端必须准备好在常规响应之前接受一个或多个1xx状态响应,即使客户端不期望100(Continue)状态消息。意外的1xx状态响应可以被用户代理忽略。代理必须转发1xx响应,除非代理和它的客户端之间的连接已经关闭,或者除非代理自己要求生成1xx响应。(例如,如果代理在转发请求时添加了 &quot;期待:100-continue &quot;字段,那么它就不需要转发相应的100(Continue)响应。)</target>
        </trans-unit>
        <trans-unit id="6b9a408e9c3b7b54fbf759cb196264221abed170" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that further action needs to be
   taken by the user agent in order to fulfill the request.  The action
   required MAY be carried out by the user agent without interaction
   with the user if and only if the method used in the second request is
   GET or HEAD. A client SHOULD detect infinite redirection loops, since
   such loops generate network traffic for each redirection.

      Note: previous versions of this specification recommended a
      maximum of five redirections. Content developers should be aware
      that there might be clients that implement such a fixed
      limitation.</source>
          <target state="translated">这一类状态码表示需要用户代理采取进一步的行动才能完成请求。如果且仅当第二个请求中使用的方法是GET或HEAD时,所需的操作可以由用户代理在不与用户交互的情况下进行。客户端应该检测到无限重定向环路,因为这种环路会为每次重定向产生网络流量。注意:本规范以前的版本建议最多使用五个重定向。内容开发者应该意识到,可能有一些客户端实现了这样的固定限制。</target>
        </trans-unit>
        <trans-unit id="dbcc4967400bddc90f0377f2e1ba98fce661236c" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that the client's request was
   successfully received, understood, and accepted.</source>
          <target state="translated">这一类状态码表示客户端的请求已成功接收、理解和接受。</target>
        </trans-unit>
        <trans-unit id="aa0eac6f65fb6440a25f249695197fc412fc43a4" translate="yes" xml:space="preserve">
          <source>This code indicates that the server has received and is processing the request, but no response is available yet.</source>
          <target state="translated">该代码表示服务器已经收到并正在处理该请求,但还没有响应。</target>
        </trans-unit>
        <trans-unit id="3a6a8f72886b84a7449d24f613f3e53c70e794a8" translate="yes" xml:space="preserve">
          <source>This code is reserved for future use.</source>
          <target state="translated">此代码保留给将来使用。</target>
        </trans-unit>
        <trans-unit id="ffadfb15e2eb2fc2bbccd496410791acc5ffa9e9" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header by the client, and indicates the protocol the server is switching to.</source>
          <target state="translated">客户端发送此代码以响应&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;请求标头，并指示服务器要切换到的协议。</target>
        </trans-unit>
        <trans-unit id="aa1e5327237aabe301b48a95db0d8c6c85cc5f0b" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header from the client, and indicates the protocol the server is switching to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0827e7feb1318caf938fa97aff681eecc88f25e" translate="yes" xml:space="preserve">
          <source>This code is similar to 401 (Unauthorized), but indicates that the
   client must first authenticate itself with the proxy. The proxy MUST
   return a Proxy-Authenticate header field (&lt;a href=&quot;#section-14.33&quot;&gt;section 14.33&lt;/a&gt;) containing a
   challenge applicable to the proxy for the requested resource. The
   client MAY repeat the request with a suitable Proxy-Authorization
   header field (&lt;a href=&quot;#section-14.34&quot;&gt;section 14.34&lt;/a&gt;). HTTP access authentication is explained
   in &quot;HTTP Authentication: Basic and Digest Access Authentication&quot;
   [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">此代码类似于401（未经授权），但表示客户端必须首先使用代理对其进行身份验证。代理务必返回一个Proxy-Authenticate头域（&lt;a href=&quot;#section-14.33&quot;&gt;第14.33节&lt;/a&gt;），其中包含适用于所请求资源的代理的质询。客户可以用合适的代理授权头域（&lt;a href=&quot;#section-14.34&quot;&gt;第14.34节&lt;/a&gt;）重复请求。HTTP访问身份验证在&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]中进行了说明。</target>
        </trans-unit>
        <trans-unit id="a79aa67f6b67e62ec228c4830d6fa231aff1cf84" translate="yes" xml:space="preserve">
          <source>This design technique involves developing your Web site in 'layers', using a bottom-up approach, starting with a simpler layer and improving the capabilities of the site in successive layers, each using more features.</source>
          <target state="translated">这种设计技术涉及到在 &quot;层 &quot;中开发你的网站,使用自下而上的方法,从一个较简单的层开始,在连续的层中提高网站的功能,每个层使用更多的功能。</target>
        </trans-unit>
        <trans-unit id="c4f2bfc459cbc9d47da09ed899ca07996d8c748f" translate="yes" xml:space="preserve">
          <source>This directive is meaningless for the Public-Key-Pins-Report-Only header, it will be ignored by user agents and the header will not be cached.</source>
          <target state="translated">这个指令对于Public-Key-Pins-Report-Only头是没有意义的,它将被用户代理忽略,头也不会被缓存。</target>
        </trans-unit>
        <trans-unit id="f32511f74b3172e453c0eb1a2d75c8552c9a2edb" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element or by the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素或&lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt; &lt;/a&gt;标头字段不支持此伪指令。</target>
        </trans-unit>
        <trans-unit id="9d0590723290af17baff140ec8796150f9341847" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中不支持此指令。</target>
        </trans-unit>
        <trans-unit id="9b819d9b6f80f6df35168312b4868b28bd76e9d1" translate="yes" xml:space="preserve">
          <source>This document describes an extension to the HTTP/1.1 protocol that
   allows clients to perform remote Web content authoring operations.
   This extension provides a coherent set of methods, headers, request
   entity body formats, and response entity body formats that provide
   operations for:

   Properties: The ability to create, remove, and query information
   about Web pages, such as their authors, creation dates, etc.

   Collections: The ability to create sets of documents and to retrieve
   a hierarchical membership listing (like a directory listing in a file
   system).

   Locking: The ability to keep more than one person from working on a
   document at the same time.  This prevents the &quot;lost update problem&quot;,
   in which modifications are lost as first one author, then another,
   writes changes without merging the other author's changes.

   Namespace Operations: The ability to instruct the server to copy and
   move Web resources, operations that change the mapping from URLs to
   resources.

   Requirements and rationale for these operations are described in a
   companion document, &quot;Requirements for a Distributed Authoring and
   Versioning Protocol for the World Wide Web&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].

   This document does not specify the versioning operations suggested by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].  That work was done in a separate document, &quot;Versioning
   Extensions to WebDAV&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;].

   The sections below provide a detailed introduction to various WebDAV
   abstractions: resource properties (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), collections of
   resources (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), locks (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) in general, and write locks
   (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) specifically.

   These abstractions are manipulated by the WebDAV-specific HTTP
   methods (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;) and the extra HTTP headers (&lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;) used with
   WebDAV methods.  General considerations for handling HTTP requests
   and responses in WebDAV are found in &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   While the status codes provided by HTTP/1.1 are sufficient to
   describe most error conditions encountered by WebDAV methods, there
   are some errors that do not fall neatly into the existing categories.
   This specification defines extra status codes developed for WebDAV
   methods (&lt;a href=&quot;#section-11&quot;&gt;Section 11&lt;/a&gt;) and describes existing HTTP status codes
   (&lt;a href=&quot;#section-12&quot;&gt;Section 12&lt;/a&gt;) as used in WebDAV.  Since some WebDAV methods may 

   operate over many resources, the Multi-Status response (&lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt;)
   has been introduced to return status information for multiple
   resources.  Finally, this version of WebDAV introduces precondition
   and postcondition (&lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) XML elements in error response bodies.

   WebDAV uses XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) for property names and some values, and
   also uses XML to marshal complicated requests and responses.  This
   specification contains DTD and text definitions of all properties
   (&lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;) and all other XML elements (&lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) used in
   marshalling.  WebDAV includes a few special rules on extending WebDAV
   XML marshalling in backwards-compatible ways (&lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;).

   Finishing off the specification are sections on what it means for a
   resource to be compliant with this specification (&lt;a href=&quot;#section-18&quot;&gt;Section 18&lt;/a&gt;), on
   internationalization support (&lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;), and on security
   (&lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).</source>
          <target state="translated">本文档介绍了对HTTP / 1.1协议的扩展，该扩展允许客户端执行远程Web内容创作操作。此扩展程序提供了一组连贯的方法，标头，请求实体正文格式和响应实体正文格式，这些格式提供以下操作：属性：具有创建，删除和查询有关网页信息（例如其作者，创建日期，集合：创建文档集并检索层次结构成员资格列表（如文件系统中的目录列表）的能力。锁定：可以防止多个人同时处理文档的能力。这样可以避免出现&amp;ldquo;丢失更新问题&amp;rdquo;，在丢失问题中，修改是作为第一位作者然后是另一位作者丢失的，在不合并其他作者的更改的情况下编写更改。命名空间操作：指示服务器复制和移动Web资源的功能，这种操作将URL映射更改为资源。这些操作的要求和原理在随附的文档&amp;ldquo;万维网的分布式创作和版本控制协议的要求&amp;rdquo;中进行了描述[&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]。本文档未指定[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ] 建议的版本控制操作。这项工作是在单独的文档&amp;ldquo; WebDAV的版本扩展&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]中完成的。以下各节详细介绍了各种WebDAV抽象：资源属性（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;），资源集合（&lt;a href=&quot;#section-5&quot;&gt;第5 &lt;/a&gt;&lt;a href=&quot;#section-6&quot;&gt;节&lt;/a&gt;），一般的锁（第6节），以及专门的写锁（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）。这些抽象由特定于WebDAV的HTTP方法（&lt;a href=&quot;#section-9&quot;&gt;第9节&lt;/a&gt;）和额外的HTTP标头（&lt;a href=&quot;#section-10&quot;&gt;第10节）处理。&lt;/a&gt;）与WebDAV方法一起使用。在&lt;a href=&quot;#section-8&quot;&gt;第8节中&lt;/a&gt;可以找到在WebDAV中处理HTTP请求和响应的一般注意事项。虽然HTTP / 1.1提供的状态代码足以描述WebDAV方法遇到的大多数错误情况，但有些错误并没有很好地归类到现有类别中。该规范定义了为WebDAV方法开发的额外状态代码（&lt;a href=&quot;#section-11&quot;&gt;第11节&lt;/a&gt;），并描述了WebDAV中使用的现有HTTP状态代码（&lt;a href=&quot;#section-12&quot;&gt;第12节&lt;/a&gt;）。由于某些WebDAV方法可能会在许多资源上运行，因此多状态响应（&lt;a href=&quot;#section-13&quot;&gt;第13节&lt;/a&gt;已引入）以返回多个资源的状态信息。最后，此版本的WebDAV 在错误响应主体中引入了前置条件和后置条件（&lt;a href=&quot;#section-16&quot;&gt;第16节&lt;/a&gt;）XML元素。 WebDAV使用XML（[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]）作为属性名称和某些值，并且还使用XML封送复杂的请求和响应。该规范包含DTD和编组中使用的所有属性（&lt;a href=&quot;#section-15&quot;&gt;第15节&lt;/a&gt;）和所有其他XML元素（&lt;a href=&quot;#section-14&quot;&gt;第14 &lt;/a&gt;节）的文本定义。 WebDAV包含一些以向后兼容的方式扩展WebDAV XML编组的特殊规则（&lt;a href=&quot;#section-17&quot;&gt;第17节）&lt;/a&gt;）。规范的最后部分是关于资源符合该规范的含义（&lt;a href=&quot;#section-18&quot;&gt;第18节&lt;/a&gt;），国际化支持（&lt;a href=&quot;#section-19&quot;&gt;第19节&lt;/a&gt;）和安全性（&lt;a href=&quot;#section-20&quot;&gt;第20节&lt;/a&gt;）的部分。</target>
        </trans-unit>
        <trans-unit id="d12cc0f3aacd5b3de7f5ba6d1f64c9e830a68a99" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了Firefox 4和更高版本以及基于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0和更高版本的应用程序中使用的用户代理字符串。有关Gecko 2.0中字符串更改的详细信息，请参阅&lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Firefox 4的最终用户代理字符串&lt;/a&gt;（博客文章）。另请参阅有关&lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;用户代理嗅探的&lt;/a&gt;本文档和此&lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77d126757eafa5a2c1ec7b146581b7a094dfa302" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了Firefox 4和更高版本以及基于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0和更高版本的应用程序中使用的用户代理字符串。有关Gecko 2.0中字符串更改的详细信息，请参阅&lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Firefox 4的最终用户代理字符串&lt;/a&gt;（博客文章）。另请参阅有关&lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;用户代理嗅探的&lt;/a&gt;本文档和此&lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e83d25b1239accfb20c5eb5ac032a6055e8ac00e" translate="yes" xml:space="preserve">
          <source>This edition of HTTP/1.1 builds on the many contributions that went
   into &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, including
   substantial contributions made by the previous authors, editors, and
   Working Group Chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   and Paul J. Leach.  Mark Nottingham oversaw this effort as Working
   Group Chair.

   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:

   Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole,
   Adrien W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek
   Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha
   Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier,
   Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,
   Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander
   Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin
   Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern
   Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, Brian Kell,
   Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens,
   Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann,
   Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus
   Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg,
   Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave
   Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty,
   Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan
   Adler, Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D.
   Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla, Erik
   Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian
   Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser,
   Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham,
   Gili Tzabari, Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz
   Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik
   Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel,
   Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson, Ido
   Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll,
   James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie 

   Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges (who came up with
   the term 'effective Request-URI'), Jeff Pinner, Jeff Walden, Jim
   Luther, Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel
   Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp,
   John Panzer, John Schneider, John Stracke, John Sullivan, Jonas
   Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore,
   Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien
   Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin
   James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith
   Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin
   Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault,
   Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark
   Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler,
   Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin Thomson,
   Matt Lynch, Matthew Cox, Matthew Kerwin, Max Clark, Menachem Dodge,
   Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael
   Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen,
   Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin,
   Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, Nicholas
   Shanks, Nico Williams, Nicolas Alvarez, Nicolas Mailhot, Noah Slater,
   Osama Mazahir, Pablo Castro, Pat Hayes, Patrick R. McManus, Paul E.
   Jones, Paul Hoffman, Paul Marquess, Pete Resnick, Peter Lepeska,
   Peter Occil, Peter Saint-Andre, Peter Watkins, Phil Archer, Phil
   Hunt, Philippe Mougin, Phillip Hallam-Baker, Piotr Dobrogost, Poul-
   Henning Kamp, Preethi Natarajan, Rajeev Bector, Ray Polk, Reto
   Bachmann-Gmuer, Richard Barnes, Richard Cyganiak, Rob Trace, Robby
   Simpson, Robert Brewer, Robert Collins, Robert Mattson, Robert
   O'Callahan, Robert Olofsson, Robert Sayre, Robert Siemer, Robert de
   Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny
   Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam
   Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence
   (who maintained the original issues list), Sean B. Palmer, Sean
   Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon
   Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane
   Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin, Stuart
   Williams, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares,
   Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya
   Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas
   Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim Bray, Tim
   Morgan, Tim Olsen, Tom Zhou, Travis Snoozy, Tyler Close, Vincent
   Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez
   Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang,
   Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang,
   Yuchung Cheng, Yutaka Oiwa, Yves Lafon (long-time member of the
   editor team), Zed A. Shaw, and Zhong Yu.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;Section&amp;nbsp;16 of [RFC2616]&lt;/a&gt; for additional acknowledgements from
   prior revisions.</source>
          <target state="translated">此版本的HTTP / 1.1建立在&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;的许多贡献的基础上包括以前的作者，编辑和工作组主席做出的重大贡献：蒂姆&amp;middot;伯纳斯&amp;middot;李，阿里&amp;middot;洛顿宁，罗伊&amp;middot;菲尔丁，亨里克&amp;middot;弗里斯蒂克&amp;middot;尼尔森，吉姆&amp;middot;盖蒂斯，杰弗里&amp;middot;C&amp;middot;莫古尔，拉里&amp;middot;马森特和保罗&amp;middot;J&amp;middot;里奇。马克&amp;middot;诺丁汉（Mark Nottingham）担任工作组主席期间监督了这项工作。自1999年以来，以下贡献者通过报告错误，提出聪明的问题，起草或审阅文本以及评估未解决的问题，帮助改进了HTTP规范：Adam Barth，Adam Roach，Addison Phillips，Adrian Chadd，Adrian Cole，Adrien W. de Croy ，艾伦&amp;middot;福特（Alan Ford），艾伦&amp;middot;鲁滕伯格（Alan Ruttenberg），艾伯特&amp;middot;伦德，阿勒克&amp;middot;暴风雨，亚历克斯&amp;middot;鲁斯科夫，亚历山大&amp;middot;莫高特，阿列克谢&amp;middot;梅尔尼科夫，艾丽莎&amp;middot;史密斯，阿米猜&amp;middot;罗斯曼，阿米特&amp;middot;克莱因，阿莫斯&amp;middot;杰弗里斯，安德里亚斯&amp;middot;迈耶，安德里亚斯&amp;middot;彼得森，安德烈&amp;middot;波波夫，阿尼尔&amp;middot;夏尔马，安妮&amp;middot;范&amp;middot;凯森安东尼&amp;middot;布莱恩（Anthony Bryan），阿斯比约恩&amp;middot;乌尔斯堡（Abjorn Ulsberg），阿肖克&amp;middot;库马尔（Ashok Kumar），巴拉切德&amp;middot;克里希那穆尔西（Balachander Krishnamurthy），巴里&amp;middot;雷巴（Barry Leiba），本&amp;middot;劳里（Ben Laurie），本杰明&amp;middot;卡莱尔（Benjamin Carlyle），本杰明&amp;middot;尼文&amp;middot;詹金斯（Benjait Claise），比尔&amp;middot;科里（Bill Corry），比尔&amp;middot;伯克（Ber Burke），比约恩&amp;middot;霍尔曼（Bjoern Hoehrmann），鲍勃&amp;middot;谢弗勒（Bob Scheifler），鲍里斯&amp;middot;扎伯斯基（Boris Zbarsky），布雷特&amp;middot;斯拉特金（Brett Slatkin） Brian McBarron，Brian Pane，Brian Raymor，Brian Smith，Bruce Perens，Bryce Nesbitt，Cameron Heavon-Jones，Carl Kugler，Carsten Bormann，Charles Fry，Chris Burdess，Chris Newman，Christian Huitema，Cyrus Daboo，Dale Robert Anderson和Dan Wing ，Dan Winship，Daniel Stenberg，Darrel Miller，Dave Cridland，Dave Crocker，Dave Kristol，Dave Thaler，David Booth，David Singer，David W.Morris，Diwakar Shetty，Dmitry Kurochkin，Drummond Reed，Duane Wessels，Edward Lee，Eitan Adler ，艾略特&amp;middot;李尔，埃米尔&amp;middot;斯蒂芬，伊兰&amp;middot;哈默-拉哈夫，埃里克&amp;middot;威廉姆斯，埃里克&amp;middot;鲍曼，埃里克&amp;middot;劳伦斯（Eric Lawrence），埃里克&amp;middot;雷斯科拉（Eric Rescorla），埃里克&amp;middot;阿隆斯蒂（Erik Aronesty），翁俊义，埃文&amp;middot;普罗德鲁穆，费利克斯&amp;middot;盖森多尔弗（Felix Geisendoerfer），弗洛里安&amp;middot;韦默（Florian Weimer），弗兰克&amp;middot;埃勒曼（Fred Ellermann），弗雷德&amp;middot;阿卡林（Fred Akalin），弗雷德&amp;middot;博勒（Fred Bohle），弗雷德里克&amp;middot;凯泽（Gabor Molnar），加布里埃尔&amp;middot;黑山（Gabriel Montenegro），杰弗里&amp;middot;斯内登（Geborrey Shamdon） ，格雷格&amp;middot;斯莱帕克（Greg Slepak），格雷格&amp;middot;威尔金斯（Greg Wilkins），格热戈兹&amp;middot;科尔科夫斯基（Grzegorz Calkowski），哈拉德&amp;middot;特维特&amp;middot;阿尔维斯特朗德（Harald Tveit Alvestrand），哈里&amp;middot;哈尔平（Hal Halpin），海尔格&amp;middot;赫斯（Herge Hess），亨里克&amp;middot;诺德斯特罗姆（Henrik Nordstrom），亨利&amp;middot;汤普森（Henry S. ，Ido Safruti，Ilari Liusvaara，Ilya Grigorik，Ingo Struck，J.Ross Nicoll，James Cloos，James H.Manger，James Lacey，James M.Snell，Jamie Lokier，Jan Algermissen，Jari Arkko，Jeff Hodges（谁提出了术语&amp;ldquo;有效的请求URI&amp;rdquo;），杰夫&amp;middot;平纳，杰夫&amp;middot;沃尔登，吉姆&amp;middot;路德，吉图&amp;middot;帕德希，乔&amp;middot;威廉姆斯，Joe Gregorio，Joe Orton，Joel Jaeggli，John C.Klensin，John C.Mallery，John Cowan，John Kemp，John Panzer，John Schneider，John Stracke，John Sullivan，Jonas Sicking，Jonathan A.Rees，Jonathan Billington，Jonathan Moore ，乔纳森&amp;middot;西尔维拉（Jonathan Silvera），乔迪&amp;middot;罗斯（Jordi Ros），尤里斯&amp;middot;多贝尔斯汀（Joris Dobbelsteen），乔什&amp;middot;科恩（Josh Cohen），朱利安&amp;middot;皮埃尔（Jenshi Pierre），申希克&amp;middot;辛（Justshik Shin），贾斯汀&amp;middot;查普韦斯凯（Justin Chapweske），贾斯汀&amp;middot;埃伦克兰兹（Justin Erenkrantz），贾斯汀&amp;middot;詹姆斯（James James），卡尔文德&amp;middot;辛格（Karlvinder Singh），卡尔&amp;middot;杜伯斯特（Kathleen Moriarty），基思&amp;middot;霍夫曼，基思&amp;middot;霍夫曼，基思&amp;middot;摩尔，肯&amp;middot;默奇森&amp;middot;科斯坦，科恩&amp;middot;霍尔特曼沃龙科夫（Voronkov），克里斯&amp;middot;齐普（Kris Zyp），莱夫&amp;middot;赫德斯特罗姆（Leif Hedstrom），莱昂内尔&amp;middot;莫兰德（Lionel Morand），丽莎&amp;middot;杜塞特（Lisa Dusseault），马克西&amp;middot;斯塔乔维克（Maciej Stachowiak），马努&amp;middot;斯波尼（Manu Sporny），马克&amp;middot;施耐德（Marc Sl​​emko），马克&amp;middot;贝克（Mark Ba​​ker），马克&amp;middot;保利（Mark Pauley），马克&amp;middot;沃森（Mark Watson），马库斯&amp;middot;伊索马克（Markus Isomaki），马库斯&amp;middot;兰萨勒（Markus Lanthaler），马丁&amp;middot;杜尔斯特（Martin J. Nilsson，Martin Thomson，Matt Lynch，Matthew Cox，Matthew Kerwin，Max Clark，Menachem Dodge，Meral Shirazipour，Michael Burrows，Michael Hausenblas，Michael Scharf，Michael Sweet，Michael Tuexen，Michael Welzl，Mike Amundsen，Mike Belshe，Mike Bishop，Mike Kelly，Mike Schinkel，Miles Sabin，Murray S.Kucherawy，Mykyta Yevstifeyev，Nathan Rixham，尼古拉斯&amp;middot;香克斯（Nicholas Shanks），尼科&amp;middot;威廉姆斯（Nico Williams），尼古拉斯&amp;middot;阿尔瓦雷斯（Nicolas Alvarez），尼古拉斯&amp;middot;梅霍特（Nicolas Mailhot），诺亚&amp;middot;斯莱特（Noah Slater），乌萨马&amp;middot;马扎希尔（Osama Mazahir），帕勃罗&amp;middot;卡斯特罗（Pablo Castro），帕特&amp;middot;海斯（Pat Hayes），帕特里克&amp;middot;麦克马纳斯（Patrick R.McManus），保罗&amp;middot;E&amp;middot;琼斯（Paul E.圣安德烈，彼得&amp;middot;沃特金斯，菲尔&amp;middot;阿彻，菲尔&amp;middot;亨特，菲利普&amp;middot;穆金，菲利普&amp;middot;哈兰&amp;middot;贝克，皮奥特&amp;middot;多布罗格斯特，波尔&amp;middot;亨宁&amp;middot;坎普，普雷特西&amp;middot;纳塔拉扬，拉杰夫&amp;middot;贝克特，雷&amp;middot;波克，雷托&amp;middot;巴赫曼&amp;middot;格默尔，理查德&amp;middot;巴恩斯，理查德&amp;middot;加尼亚克，罗布跟踪，罗比&amp;middot;辛普森，罗伯特&amp;middot;布鲁尔，罗伯特&amp;middot;柯林斯，罗伯特&amp;middot;马特森，罗伯特&amp;middot;奥卡拉汉，Robert Olofsson，Robert Sayre，Robert Siemer，Robert de Wilde，Roberto Javier Godoy，Roberto Peon，Roland Zink，Ronny Widjaja，Ryan Hamilton，S.Mike Dierken，Salvatore Loreto，Sam Johnston，Sam Pullara，Sam Ruby，Saurabh Kulkarni，Scott劳伦斯（保留原始问题清单），肖恩&amp;middot;B&amp;middot;帕尔默，肖恩&amp;middot;特纳，塞巴斯蒂安&amp;middot;巴努德，沙恩&amp;middot;麦卡伦，大木重树，西蒙&amp;middot;雅德，斯特凡&amp;middot;埃辛，斯特凡&amp;middot;蒂尔科夫，斯特凡诺斯&amp;middot;哈拉拉基斯，斯蒂芬&amp;middot;博茨迈尔，斯蒂芬&amp;middot;法雷尔，斯蒂芬&amp;middot;肯特，斯蒂芬&amp;middot;鲁丁，斯图尔特&amp;middot;威廉姆斯，Subbu Allamaraju，Subramanian Moonesamy，Susan Hares，Sylvain Hellegouarch，Tapan Divekar，Tatsuhiro Tsujikawa，Tatsuya Hayashi，Ted Hardie，Ted Lemon，Thomas Broyer，Thomas Fossati，Thomas Maslen，Thomas Nadeau，Thomas Nordin，Thomas Roessler，Tim布雷，蒂姆&amp;middot;摩根，蒂姆&amp;middot;奥尔森，汤姆&amp;middot;周，特拉维斯&amp;middot;斯努兹，泰勒&amp;middot;罗斯特（Tyler Close），文森特&amp;middot;墨菲（Vincent Murphy），朱文波，韦纳&amp;middot;鲍曼，维尔伯&amp;middot;斯特雷特，威尔弗雷多&amp;middot;桑切斯&amp;middot;维加，威廉&amp;middot;A&amp;middot;罗维&amp;middot;小威廉姆&amp;middot;陈，威利&amp;middot;塔罗，王小书，亚伦&amp;middot;戈兰德，伊格薇&amp;middot;尼瑟特&amp;middot;佩特森，约夫&amp;middot;尼尔，约格&amp;middot;邦，尤忠，Yutaka Oiwa，Yves Lafon（编辑团队的长期成员），Zed A. Shaw和Zhong Yu。看到&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;[RFC2616]的第16节&lt;/a&gt;提供了来自先前修订版的其他确认。</target>
        </trans-unit>
        <trans-unit id="ee24423cc6a36dea3e2a80b1cc45bcc1e29b0c7b" translate="yes" xml:space="preserve">
          <source>This error can also occur if the response includes more than one &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header.</source>
          <target state="translated">如果响应包含多个 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头，也会发生此错误。</target>
        </trans-unit>
        <trans-unit id="0e1d7d044ce568115a051e7914a52c456d823802" translate="yes" xml:space="preserve">
          <source>This error means that the document was not loaded at the top level of an user-opened or noopener-opened tab or window. It can occur in these situations:</source>
          <target state="translated">该错误意味着该文档未在用户打开或未打开的标签页或窗口的顶部加载。在这些情况下可能会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="852ff1bb35f3874b9a14a70ab4ee1ec671ff8707" translate="yes" xml:space="preserve">
          <source>This error occurs when attempting to preflight a header that is not expressly allowed (that is, it's not included in the list specified by the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header sent by the server). To fix this, the server needs to be updated so that it allows the indicated header, or you need to avoid using that header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1884120a66eaf56447e8f0aecbc8de6969d27e9d" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="translated">这个错误响应是一个通用的 &quot;万能 &quot;响应。有时,服务器管理员会将类似500状态码的错误响应记录下来,并附上更多关于请求的细节,以防止将来再次发生错误。</target>
        </trans-unit>
        <trans-unit id="bf47d90cae9806b4c78cd4a0f7b36fa115bda893" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Usually, this indicates the server cannot find a better 5xx error code to response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9439e46ba591022a7d8217b7752ce9ccbf400eb2" translate="yes" xml:space="preserve">
          <source>This error response is given when the server is acting as a gateway and cannot get a response in time.</source>
          <target state="translated">当服务器作为网关,不能及时得到响应时,会给出这个错误响应。</target>
        </trans-unit>
        <trans-unit id="eab61895b7f6d33786618e886763053a4551a6b6" translate="yes" xml:space="preserve">
          <source>This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.</source>
          <target state="translated">这个错误响应意味着服务器在作为网关获取处理请求所需的响应时,得到了一个无效的响应。</target>
        </trans-unit>
        <trans-unit id="f68650d4dca44929b9f30e96e89144cfc0f2f700" translate="yes" xml:space="preserve">
          <source>This error shouldn't happen on well-tested production systems, but can be found more often while testing a new system.</source>
          <target state="translated">这个错误不应该发生在经过良好测试的生产系统上,但在测试一个新系统时可能会经常发现。</target>
        </trans-unit>
        <trans-unit id="483909e9171e2699ed78d6021cf1843f1935c891" translate="yes" xml:space="preserve">
          <source>This evolution of HTTP proves its extensibility and simplicity, liberating creation of many applications and compelling the adoption of the protocol. The environment in which HTTP is used today is quite different from that seen in the early 1990s. HTTP's original design proved to be a masterpiece, allowing the Web to evolve over a quarter of a century, without the need of a mutiny. By healing flaws, yet retaining the flexibility and extensibility which made HTTP such a success, the adoption of HTTP/2 hints at a bright future for the protocol.</source>
          <target state="translated">HTTP的这种演变证明了它的可扩展性和简单性,解放了许多应用的创建,迫使人们采用该协议。今天HTTP的使用环境与20世纪90年代初看到的环境完全不同。事实证明,HTTP最初的设计是一个杰作,使Web在四分之一个世纪的时间里得以发展,而不需要叛变。通过弥补缺陷,同时又保留了使HTTP如此成功的灵活性和可扩展性,HTTP/2的采用预示着该协议的光明前景。</target>
        </trans-unit>
        <trans-unit id="781912733ac5a2c031d25e3e8b5988cba0dcdce0" translate="yes" xml:space="preserve">
          <source>This example allows &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; content on a particular origin to access the user's location:</source>
          <target state="translated">此示例允许特定来源上的 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 内容访问用户的位置：</target>
        </trans-unit>
        <trans-unit id="ca8e2b99c120ccf6c9a6bffe95a381cde5380542" translate="yes" xml:space="preserve">
          <source>This example creates a collection called /webdisc/xfiles/ on the
   server www.example.com. 

   &amp;gt;&amp;gt;Request

     MKCOL /webdisc/xfiles/ HTTP/1.1
     Host: www.example.com


   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created</source>
          <target state="translated">本示例在服务器www.example.com上创建一个名为/ webdisc / xfiles /的集合。&amp;gt;&amp;gt;请求MKCOL / webdisc / xfiles / HTTP / 1.1主机：www.example.com &amp;gt;&amp;gt;响应HTTP / 1.1 201已创建</target>
        </trans-unit>
        <trans-unit id="a0811554d7dd6c0c801a3a83158f7a56615c10fc" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers - as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2ce892d1c3a6298b72aa271eaca87af850694a" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers -- as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="translated">这个例子比较复杂。有四(4)个代理服务器;其中一个是其他所有代理服务器的热备份,所以如果其余三个中的任何一个瘫痪,第四个将接管。此外,剩下的三个代理服务器根据URL模式分担负载,这使得他们的缓存更加有效(任何文档在三个服务器上只有一个副本--而不是每个服务器上都有一个副本)。负载是这样分配的。</target>
        </trans-unit>
        <trans-unit id="f8d7c446d07bc06ec9ae31c4aecccef522ea44ec" translate="yes" xml:space="preserve">
          <source>This example response is taken from the IETF RFC (see below) and contains a reference to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python's Life of Brian&lt;/a&gt;.</source>
          <target state="translated">此示例响应取自IETF RFC（请参见下文），其中包含对&lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python的Brian生平的&lt;/a&gt;引用。</target>
        </trans-unit>
        <trans-unit id="999b4d428320409a219f5dc5012ceca8d2b38d22" translate="yes" xml:space="preserve">
          <source>This example shows &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; when it specifies support for multiple headers.</source>
          <target state="translated">此示例在指定支持多个标 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 时显示Access-Control-Allow-Headers。</target>
        </trans-unit>
        <trans-unit id="0b1f58893a7cb8a1c12815693f3befaeab5b7414" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being copied to the
   location http://www.example.com/users/f/fielding/index.html.  The 204
   (No Content) status code indicates that the existing resource at the
   destination was overwritten.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 204 No Content</source>
          <target state="translated">本示例显示资源http://www.example.com/~fielding/index.html复制到位置http://www.example.com/users/f/fielding/index.html。状态码为204（无内容）指示目标处的现有资源已被覆盖。&amp;gt;&amp;gt;请求COPY /~fielding/index.html HTTP / 1.1主机：www.example.com目的地：http://www.example.com/users/f/fielding/index.html &amp;gt;&amp;gt;响应HTTP / 1.1 204否内容</target>
        </trans-unit>
        <trans-unit id="fa023a88dd9876a6752395fc5752087af07a81f6" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being moved to the
   location http://www.example.com/users/f/fielding/index.html.  The
   contents of the destination resource would have been overwritten if
   the destination URL was already mapped to a resource.  In this case,
   since there was nothing at the destination resource, the response
   code is 201 (Created).

   &amp;gt;&amp;gt;Request

     MOVE /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created
     Location: http://www.example.com/users/f/fielding/index.html</source>
          <target state="translated">此示例显示资源http://www.example.com/~fielding/index.html被移到位置http://www.example.com/users/f/fielding/index.html。如果目标URL已映射到资源，则目标资源的内容将被覆盖。在这种情况下，由于目标资源上没有任何内容，因此响应代码为201（已创建）。 &amp;gt;&amp;gt;请求MOVE /~fielding/index.html HTTP / 1.1主机：www.example.com目的地：http：//www.example/users/f/fielding/index.html &amp;gt;&amp;gt;响应HTTP / 1.1 201创建位置： http://www.example.com/users/f/fielding/index.html</target>
        </trans-unit>
        <trans-unit id="e00417a4554c87f42e03a721ef55ecfe0950a2cf" translate="yes" xml:space="preserve">
          <source>This example will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">这个例子将适用于这样的环境,即内部DNS服务器被设置为只能解析内部主机名,而目标是只对不可解析的主机使用代理。</target>
        </trans-unit>
        <trans-unit id="a76e357a372c477fb919b2dd879c8bc24b00a2e5" translate="yes" xml:space="preserve">
          <source>This extensible nature of HTTP has, over time, allowed for more control and functionality of the Web. Cache or authentication methods were functions handled early in HTTP history. The ability to relax the &lt;em&gt;origin constraint&lt;/em&gt;, by contrast, has only been added in the 2010s.</source>
          <target state="translated">随着时间的流逝，HTTP的这种可扩展性质允许对Web进行更多控制和功能。缓存或身份验证方法是HTTP历史记录中早期处理的函数。相比之下，放宽&lt;em&gt;原点约束的功能&lt;/em&gt;仅在2010年代才添加。</target>
        </trans-unit>
        <trans-unit id="60964c2acb63a5e80056aab53d36efc81e0dae97" translate="yes" xml:space="preserve">
          <source>This feature has been removed from the Web standards. Though some browsers may still support it, it is in the process of being dropped. Avoid using it and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="translated">此功能已从Web标准中删除。尽管某些浏览器可能仍支持它，但是它正在被删除。避免使用它，并尽可能更新现有代码；请参阅此页面底部的&lt;a href=&quot;#Browser_compatibility&quot;&gt;兼容性表&lt;/a&gt;以指导您做出决定。请注意，此功能可能随时停止起作用。</target>
        </trans-unit>
        <trans-unit id="5f97d5c5e8a61c76b7ca883b249f65188e1add95" translate="yes" xml:space="preserve">
          <source>This feature is commonly used to allow a resource to be cached in uncompressed and (various) compressed forms, and served appropriately to user agents based on the encodings that they support. For example, a server can set &lt;code&gt;Vary: Accept-Encoding&lt;/code&gt; to ensure that a separate version of a resource is cached for all requests that specify support for a particular set of encodings, e.g. &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fdac85d6009334c365dfdd6eb6bef5e4374b26" translate="yes" xml:space="preserve">
          <source>This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad63cac1625affd2a84d66756a720def351fb2b3" translate="yes" xml:space="preserve">
          <source>This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.</source>
          <target state="translated">这个功能是非标准的,不在标准轨道上。不要在面向Web的生产站点上使用它:它不会对每个用户都有效。不同的实现之间也可能存在很大的不兼容性,而且未来的行为可能会改变。</target>
        </trans-unit>
        <trans-unit id="59314e7aec66910164f6914bdc2ab1c6bad7e1f6" translate="yes" xml:space="preserve">
          <source>This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.</source>
          <target state="translated">这个功能已经过时了。虽然它可能在某些浏览器中仍然有效,但不鼓励使用它,因为它可能随时被删除。尽量避免使用它。</target>
        </trans-unit>
        <trans-unit id="44d6d26ec2012e7ff67a4bdfd287c446e6ad0a4f" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: What happens under the hood when you click on a link in your browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc17d0049c62a76188340a479b6da749df640b09" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: what happens under the hood when you click on a link in your browser&amp;hellip;</source>
          <target state="translated">这篇基础文章描述了一个典型的HTTP会话：单击浏览器中的链接时幕后发生的事情&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9f93380bea42618419d88a1e2ec92eb06b4070a2" translate="yes" xml:space="preserve">
          <source>This header can be used either with a &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">此标头可以与&lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;验证器一起使用，也可以与&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;一起使用，但不能同时使用。</target>
        </trans-unit>
        <trans-unit id="e2108a313bc4bb54663d17af6f772b5774776cf7" translate="yes" xml:space="preserve">
          <source>This header from the server tells the client to store a cookie.</source>
          <target state="translated">这个来自服务器的头告诉客户端存储一个cookie。</target>
        </trans-unit>
        <trans-unit id="9f3041471fef5fbbbbc5c294aaefd72cf8e4b8e6" translate="yes" xml:space="preserve">
          <source>This header is a hint to be used when the server has no way of determining the language via another way, like a specific URL, that is controlled by an explicit user decision. It is recommended that the server never overrides an explicit decision. The content of the &lt;code&gt;Accept-Language&lt;/code&gt; is often out of the control of the user (like when traveling and using an Internet Cafe in a different country); the user may also want to visit a page in another language than the locale of their user interface.</source>
          <target state="translated">当服务器无法通过另一种方式（例如，由明确的用户决定控制的特定URL）来确定语言时，将使用此头提示。建议服务器不要覆盖明确的决定。在内容 &lt;code&gt;Accept-Language&lt;/code&gt; 往往是出于用户（旅行，在不同的国家使用网吧时等）的控制; 用户可能还希望以其用户界面的语言环境以外的其他语言访问页面。</target>
        </trans-unit>
        <trans-unit id="0e9bd72b00debb383ca11d6751998799ac99152f" translate="yes" xml:space="preserve">
          <source>This header is automatically added by clients that choose to use it; it cannot be added using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt;&lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">此标头由选择使用它的客户端自动添加；不能使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt; &lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt; &lt;/a&gt;方法添加它。</target>
        </trans-unit>
        <trans-unit id="4737f0640e2626ce2c86bf3453432d3e8fdff2b5" translate="yes" xml:space="preserve">
          <source>This header is not supported inside a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素内部不支持此标头。</target>
        </trans-unit>
        <trans-unit id="4ac57abc80887b57bdf2fcf4f45fa8fc42191101" translate="yes" xml:space="preserve">
          <source>This header is required if the request has an &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">如果请求具有&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;标头，则此标头是必需的。</target>
        </trans-unit>
        <trans-unit id="737f8eaab76cbd788575174bfce1b83385303b75" translate="yes" xml:space="preserve">
          <source>This header is still in an experimental state, and is subject to change at any time. Be wary of this when implementing it on your website. The header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae9e9e16dbee7cb2e940a19073f03abae67dabc" translate="yes" xml:space="preserve">
          <source>This header is used for debugging, statistics, and generating location-dependent content and by design it exposes privacy sensitive information, such as the IP address of the client. Therefore the user's privacy must be kept in mind when deploying this header.</source>
          <target state="translated">这个头用于调试、统计和生成与位置相关的内容,通过设计,它暴露了隐私敏感信息,如客户端的IP地址。因此,在部署这个头时,必须牢记用户的隐私。</target>
        </trans-unit>
        <trans-unit id="e339b1a060076bad3fa562c3df51670b4975b5b9" translate="yes" xml:space="preserve">
          <source>This header must be sent if the server responds with a &lt;a href=&quot;../status/405&quot;&gt;&lt;code&gt;405&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Method Not Allowed&lt;/code&gt; status code to indicate which request methods can be used. An empty &lt;code&gt;Allow&lt;/code&gt; header indicates that the resource allows no request methods, which might occur temporarily for a given resource, for example.</source>
          <target state="translated">如果服务器响应&lt;a href=&quot;../status/405&quot;&gt; &lt;code&gt;405&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Method Not Allowed&lt;/code&gt; 状态码以指示可以使用哪些请求方法，则必须发送此标头。空的 &lt;code&gt;Allow&lt;/code&gt; 标头表示该资源不允许使用任何请求方法，例如，对于给定资源而言，这可能会暂时发生。</target>
        </trans-unit>
        <trans-unit id="d038bd6662fb532b2ff18177eb47f5f8cd56f9cb" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, or &lt;a href=&quot;https://secure.wphackedhelp.com/blog/wordpress-malware-redirect-hack-cleanup/&quot;&gt;malware redirects&lt;/a&gt;, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cd8f4bdbc85c57584352cda936cbf16cec5740" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">此标头报告可能发生的违规情况。您可以使用它来迭代处理内容安全策略。您观察站点的行为，观察违规报告，然后选择由&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;标头实施的所需策略。</target>
        </trans-unit>
        <trans-unit id="6406ecfb1884f34413b4947c4224d8b102734485" translate="yes" xml:space="preserve">
          <source>This header was introduced by Microsoft in IE 8 as a way for webmasters to block content sniffing that was happening and could transform non-executable MIME types into executable MIME types. Since then, other browsers have introduced it, even if their MIME sniffing algorithms were less aggressive.</source>
          <target state="translated">这个头是微软在IE 8中引入的,作为网站管理员阻止正在发生的内容嗅探的一种方式,可以将不可执行的MIME类型转化为可执行的MIME类型。从那时起,其他浏览器也引入了它,即使他们的MIME嗅探算法不那么激进。</target>
        </trans-unit>
        <trans-unit id="7910eee90b814ebcea921d5e05f3e798655b01a9" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue the request, or ignore the response if the request is already finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77a8aadedd58ca97eb678dcd40675e7891feafc" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">这个临时响应表明到目前为止一切正常,客户机应该继续请求,如果已经完成,则忽略它。</target>
        </trans-unit>
        <trans-unit id="97f1b290f6e916924cd7cb715ba859fdd697edc8" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown header name with the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">通过修改服务器的配置，不再通过 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 标头发送无效或未知的标头名称，此问题很可能只能在服务器端解决。还可能需要检查以确保您在客户端上使用的用户代理或HTTP库是最新的。</target>
        </trans-unit>
        <trans-unit id="5ca266f84de58335a9fa22c96177ea4b42712957" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown method name with the &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">通过修改服务器配置，不再通过 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 标头发送无效或未知的方法名称，很可能只能在服务器端解决此问题。还可能需要检查以确保您在客户端上使用的用户代理或HTTP库是最新的。</target>
        </trans-unit>
        <trans-unit id="68654c9820232d31d9835d660a42416043e4d6e6" translate="yes" xml:space="preserve">
          <source>This is a top-down approach in which you build the best possible site using all the features you want, then tweak it to make it work on older browsers. This can be harder to do, and less effective, than progressive enhancement, but may be useful in some cases.</source>
          <target state="translated">这是一种自上而下的方法,在这种方法中,你使用所有你想要的功能建立一个最好的网站,然后调整它,使其在旧的浏览器上工作。与渐进式增强相比,这可能更难做到,也更不有效,但在某些情况下可能是有用的。</target>
        </trans-unit>
        <trans-unit id="ddb9ae3d96d8b78e1be6c37fe9e53f2fec150502" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="translated">这是一个非常主观的话题，可以看作是一个&lt;a href=&quot;http://bikeshed.com/&quot;&gt;骑自行车的&lt;/a&gt;问题。如果您想深入阅读，请参阅有关该主题的&lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;许多&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="641095a78e4ebe2abe2b4166aac4c4584c32cfcf" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;https://www.netlify.com/blog/2017/02/28/to-www-or-not-www/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80608a6f9119cc7c4582aee9309cf18792c53923" translate="yes" xml:space="preserve">
          <source>This is an improvement over earlier &lt;code&gt;Accept&lt;/code&gt; headers as it no longer ranks &lt;code&gt;image/png&lt;/code&gt; above &lt;code&gt;text/html&lt;/code&gt;</source>
          <target state="translated">这是对早期的 &lt;code&gt;Accept&lt;/code&gt; 标头的改进，因为它不再将 &lt;code&gt;image/png&lt;/code&gt; 置于 &lt;code&gt;text/html&lt;/code&gt; 之上</target>
        </trans-unit>
        <trans-unit id="b2128edd161faa94a80e6eb961a49e5e2001c4b7" translate="yes" xml:space="preserve">
          <source>This is an obsolete directive that no longer works in modern browsers. Don't use it. In supporting legacy browsers, a page can be displayed in a frame only on the specified origin &lt;em&gt;uri&lt;/em&gt;. Note that in the legacy Firefox implementation this still suffered from the same problem as &lt;code&gt;SAMEORIGIN&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin. The &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header has a &lt;a href=&quot;content-security-policy/frame-ancestors&quot;&gt;&lt;code&gt;frame-ancestors&lt;/code&gt;&lt;/a&gt; directive which you can use instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">这相当于:</target>
        </trans-unit>
        <trans-unit id="f3c017ea67402b333e111c91d0d8c835c18ed46a" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers. If the etag doesn't match the original file, or if the file has been modified since it has been obtained, the change is simply rejected with a &lt;a href=&quot;status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error. It is then up to the client to deal with the error: either by notifying the user to start again (this time on the newest version), or by showing the user a &lt;em&gt;diff &lt;/em&gt;of both versions, helping them decide which changes they wish to keep.</source>
          <target state="translated">这是使用&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;标头实现的。如果etag与原始文件不匹配，或者自获取以来已对文件进行了修改，则更改将被简单拒绝，并显示&lt;a href=&quot;status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 错误。然后由客户端来处理错误：通过通知用户重新启动（这次是最新版本），或者向用户显示两个版本的&lt;em&gt;差异&lt;/em&gt;，以帮助他们确定希望保留哪些更改。 。</target>
        </trans-unit>
        <trans-unit id="124f23444ec9f501d1f80c6afe1cad1494209a7a" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints &lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="translated">这是称为&amp;ldquo; &lt;em&gt;客户端提示&lt;/em&gt; &amp;rdquo;的&lt;strong&gt;实验&lt;/strong&gt;技术的一部分，仅在Chrome 61或更高版本中可用。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8cd6fbb7a4f7885010a0bffbaf4241fed054fc3" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cd90cf410e959cd661c8e83d47ed919723c7b5" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt;. Initial support is in Chrome 46 or later. The Device-Memory value is in Chrome 61 or later.</source>
          <target state="translated">这是称为&amp;ldquo; &lt;em&gt;客户提示&lt;/em&gt; &amp;rdquo;的&lt;strong&gt;实验&lt;/strong&gt;技术的一部分。最初的支持在Chrome 46或更高版本中。设备内存值在Chrome 61或更高版本中。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c9b9f265a030439ad0eded89740990c1cd0e705" translate="yes" xml:space="preserve">
          <source>This is similar to 401 but authentication is needed to be done by a proxy.</source>
          <target state="translated">这与401类似,但需要通过代理进行认证。</target>
        </trans-unit>
        <trans-unit id="eeed176b4c6d9e486d6e3b46cc4c1482f2ae547b" translate="yes" xml:space="preserve">
          <source>This is the default behavior if no policy is specified, or if the provided value is invalid. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/path&quot;&gt;path&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/querystring&quot;&gt;querystring&lt;/a&gt; of the URL are sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS) or improves (HTTP&amp;rarr;HTTPS), but isn't sent to less secure destinations (HTTPS&amp;rarr;HTTP).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1bfe2beacf7098474167acd9a0dc8c20186348" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary &lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="translated">这是二进制文件的默认设置。因为它意味着&lt;em&gt;未知的二进制&lt;/em&gt;文件，所以浏览器通常不执行它，甚至询问是否应该执行它。他们就像将&lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt;标头设置为 &lt;code&gt;attachment&lt;/code&gt; ，并提出&amp;ldquo;另存为&amp;rdquo;对话框。</target>
        </trans-unit>
        <trans-unit id="763b865e8143c4b06adf307c51b45264f147e5ff" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary&lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1fbd395e24ae5276bcd50aae6f6286330fa789" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &quot;unknown textual file,&quot; browsers assume they can display it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9273da9e8fd5fcf9c3bde1b24ef99c570ddd6fd7" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &lt;em&gt;unknown textual&lt;/em&gt; file, browsers assume they can display it.</source>
          <target state="translated">这是文本文件的默认设置。即使确实意味着&lt;em&gt;未知的文本&lt;/em&gt;文件，浏览器也会假定他们可以显示该文件。</target>
        </trans-unit>
        <trans-unit id="e89b69639ed3c3449649e0ef238ba09b307791ec" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The URL is sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS), but isn't sent to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">如果未指定策略，这是用户代理的默认行为。当协议安全级别保持不变（HTTP&amp;rarr;HTTP，HTTPS&amp;rarr;HTTPS）但未发送到安全性较低的目的地（HTTPS&amp;rarr;HTTP）时，URL将作为引荐来源发送。</target>
        </trans-unit>
        <trans-unit id="aec6ea7897565c6f7f8de375d3405f1846b40c5a" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The origin is sent as referrer to a-priori as-much-secure destination (HTTPS-&amp;gt;HTTPS), but isn't sent to a less secure destination (HTTPS-&amp;gt;HTTP).</source>
          <target state="translated">如果未指定策略，这是用户代理的默认行为。原始服务器将作为引荐来源发送到非常安全的先验目标（HTTPS-&amp;gt; HTTPS），但不会发送到安全性较低的目标（HTTPS-&amp;gt; HTTP）。</target>
        </trans-unit>
        <trans-unit id="176fe26e859db9d8a79b1329a0c4c540c8bdb602" translate="yes" xml:space="preserve">
          <source>This is used for caching purposes. It tells the client that the response has not been modified, so the client can continue to use the same cached version of the response.</source>
          <target state="translated">这是为缓存目的而使用的,它告诉客户机响应没有被修改,所以客户机可以继续使用响应的缓存版本。它告诉客户端响应没有被修改,所以客户端可以继续使用相同的缓存版本的响应。</target>
        </trans-unit>
        <trans-unit id="db5ca9d8b582bb760db634b162cc4217b98dc46c" translate="yes" xml:space="preserve">
          <source>This is usually a bad practice, but there are some cases in which this is necessary. In these cases, you should first analyze your situation to be sure it's really necessary. Can you prevent it by adding some non-semantic &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; elements? The difficulty of successfully using user agent detection is worth a few disruptions to the purity of your HTML. Also, rethink your design: can you use progressive enhancement or fluid layouts to help remove the need to do this?</source>
          <target state="translated">这通常是一种不好的做法，但是在某些情况下有必要这样做。在这种情况下，您应该首先分析您的情况以确保确实有必要。您可以通过添加一些非语义性的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; &lt;/a&gt;元素来防止这种情况吗？成功使用用户代理检测的困难值得您为HTML的纯净度做一些破坏。另外，请重新考虑您的设计：您可以使用渐进式增强或流畅布局来帮助消除这样做的需要吗？</target>
        </trans-unit>
        <trans-unit id="0d42afd2b8cd7621e5970bc258f4d2e2f724c681" translate="yes" xml:space="preserve">
          <source>This means that if you do not need to support legacy browsers, it is recommended that you use &lt;code&gt;&lt;a href=&quot;content-security-policy&quot;&gt;Content-Security-Policy&lt;/a&gt;&lt;/code&gt; without allowing &lt;code&gt;unsafe-inline&lt;/code&gt; scripts instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17702de3201465eb14c00b1b36262a93968df79b" translate="yes" xml:space="preserve">
          <source>This means that the resource is now permanently located at another URI, specified by the &lt;code&gt;Location:&lt;/code&gt; HTTP Response header. This has the same semantics as the &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">这意味着资源现在永久位于&amp;ldquo; &lt;code&gt;Location:&lt;/code&gt; HTTP响应&amp;rdquo;标头指定的另一个URI 。这具有相同的语义 &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP响应代码，不同之处在于用户代理&lt;em&gt;必须不&lt;/em&gt;改变使用的HTTP方法：如果 &lt;code&gt;POST&lt;/code&gt; 是在第一请求中所使用的， &lt;code&gt;POST&lt;/code&gt; 必须在第二请求被使用。</target>
        </trans-unit>
        <trans-unit id="37f8e68ab017e83ab3d110757c8a5ccd4bf55d28" translate="yes" xml:space="preserve">
          <source>This mechanism is always client initiated (with one exception: it's possible for the server to &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;require an upgrade to TLS&lt;/a&gt;), and the server may accept or refuse the switch to the new protocol. This makes it possible to start a connection using a commonly-used protocol, such as HTTP/1.1, then request that the connection switch to HTTP/2 or even to WebSockets.</source>
          <target state="translated">这种机制总是由客户端启动的（一个例外：服务器可能&lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;需要升级到TLS&lt;/a&gt;），并且服务器可以接受或拒绝切换到新协议。这样就可以使用常用协议（例如HTTP / 1.1）启动连接，然后请求将连接切换到HTTP / 2或WebSockets。</target>
        </trans-unit>
        <trans-unit id="6fd8e35050a88061004785e66da5be5ef6c4558f" translate="yes" xml:space="preserve">
          <source>This mechanism is optional; it cannot be used to insist on a protocol change. Implementations can choose not to take advantage of an upgrade even if they support the new protocol, and in practice, this mechanism is used mostly to bootstrap a WebSockets connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930c017a0341cb94a246a09014c32e54c099c6b0" translate="yes" xml:space="preserve">
          <source>This message means that the browser saw the &lt;code&gt;Large-Allocation&lt;/code&gt; header, and was able to reload the page into a new process which should have more available contiguous memory.</source>
          <target state="translated">该消息表示浏览器看到了 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头，并且能够将页面重新加载到应该具有更多可用连续内存的新进程中。</target>
        </trans-unit>
        <trans-unit id="7884c1f5aebded20cacbf12f85bb3629712f95c4" translate="yes" xml:space="preserve">
          <source>This model is the default model used in HTTP/1.0 (if there is no &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header, or if its value is set to &lt;code&gt;close&lt;/code&gt;). In HTTP/1.1, this model is only used when the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header is sent with a value of &lt;code&gt;close&lt;/code&gt;.</source>
          <target state="translated">该模型是HTTP / 1.0中使用的默认模型（如果没有&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头，或者其值设置为 &lt;code&gt;close&lt;/code&gt; ）。在HTTP / 1.1中，仅当发送&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;头的值为 &lt;code&gt;close&lt;/code&gt; 时才使用此模型。</target>
        </trans-unit>
        <trans-unit id="4f8dd381093e02d3c56d8bf2d6a1a2b6d6c9bc23" translate="yes" xml:space="preserve">
          <source>This page is not complete.</source>
          <target state="translated">本页不完整。</target>
        </trans-unit>
        <trans-unit id="2700ae9496ac92696a2d7d32affc7822518ebd17" translate="yes" xml:space="preserve">
          <source>This page was loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">由于&amp;ldquo; &lt;code&gt;Large-Allocation&lt;/code&gt; 标头，此页面已在新流程中加载。</target>
        </trans-unit>
        <trans-unit id="0cac347b43837064b316648d4989da0372112872" translate="yes" xml:space="preserve">
          <source>This page would be loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header, however &lt;code&gt;Large-Allocation&lt;/code&gt; process creation is disabled on non-Win32 platforms.</source>
          <target state="translated">由于&amp;ldquo; &lt;code&gt;Large-Allocation&lt;/code&gt; 标头，此页面将被加载到新进程中，但是在非Win32平台上禁用了&amp;ldquo; &lt;code&gt;Large-Allocation&lt;/code&gt; 进程的创建。</target>
        </trans-unit>
        <trans-unit id="24edd3164f6204b4aeaaef84edccb45a164270bb" translate="yes" xml:space="preserve">
          <source>This pattern of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; headers is the simplest use of the access control protocol. If the resource owners at &lt;code&gt;https://bar.other&lt;/code&gt; wished to restrict access to the resource to requests &lt;em&gt;only&lt;/em&gt; from &lt;code&gt;https://foo.example&lt;/code&gt;, (i.e no domain other than &lt;code&gt;https://foo.example&lt;/code&gt; can access the resource in a cross-site manner) they would send:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bca8347d8092d11755f1e4e5691c56881328bb" translate="yes" xml:space="preserve">
          <source>This performs a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012dc0221186c93aa5f93e94a45c4ed8bd7f1e8a" translate="yes" xml:space="preserve">
          <source>This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">这个策略会将TLS保护的资源的起源和路径泄露给不安全的起源。请仔细考虑此设置的影响。</target>
        </trans-unit>
        <trans-unit id="e32c67984e9c6672ef8d338fdf20280130724f78" translate="yes" xml:space="preserve">
          <source>This policy will leak potentially-private information from HTTPS resource URLs to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777df6e36502c801cccff6604d845d23f1626c6e" translate="yes" xml:space="preserve">
          <source>This prefetching is performed in the background, so that the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; is likely to have been resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.</source>
          <target state="translated">该预取是在后台执行的，因此在需要引用的项目之前，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt;可能已经解析。这样可以减少用户单击链接时的延迟。</target>
        </trans-unit>
        <trans-unit id="322ff44ffffc8c1929757a32b5dd54ce49618142" translate="yes" xml:space="preserve">
          <source>This rapid adoption rate was likely as HTTP/2 does not require adaptation of Web sites and applications: using HTTP/1.1 or HTTP/2 is transparent for them. Having an up-to-date server communicating with a recent browser is enough to enable its use: only a limited set of groups were needed to trigger adoption, and as legacy browser and server versions are renewed, usage has naturally increased, without further Web developer efforts.</source>
          <target state="translated">这种快速的采用率很可能是因为HTTP/2不需要对网站和应用程序进行调整:使用HTTP/1.1或HTTP/2对它们来说是透明的。拥有一个与最新浏览器通信的最新服务器就足以使其使用:只需要一组有限的群体就可以触发采用,而且随着传统的浏览器和服务器版本的更新,使用量自然而然地增加了,而不需要网络开发人员进一步努力。</target>
        </trans-unit>
        <trans-unit id="9bd4e192aba5cf8728bcb7d85247e143a7a701f5" translate="yes" xml:space="preserve">
          <source>This represents an HTML resource whose contents are:</source>
          <target state="translated">这表示一个HTML资源,其内容是:</target>
        </trans-unit>
        <trans-unit id="9e1a08d4ddad6242047c3f07fe630aad370f9ebd" translate="yes" xml:space="preserve">
          <source>This response code is no longer used, it is just reserved currently. It was used in a previous version of the HTTP 1.1 specification.</source>
          <target state="translated">这个响应代码已经不再使用,只是目前保留了。它在以前的HTTP 1.1规范版本中使用过。</target>
        </trans-unit>
        <trans-unit id="8d9b5cfc9ffb70c58676155836edb7100932e47c" translate="yes" xml:space="preserve">
          <source>This response code is no longer used; it is just reserved. It was used in a previous version of the HTTP/1.1 specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196c5e3984dee3a01e3d4870bc32fe1976f373ee" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.</source>
          <target state="translated">这个响应代码是为将来使用而保留的。创建此代码的最初目的是将其用于数字支付系统,但目前尚未使用。</target>
        </trans-unit>
        <trans-unit id="2dd19a171f836779710936f505245545bdd2344b" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. The initial aim for creating this code was using it for digital payment systems, however this status code is used very rarely and no standard convention exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17caf511cbbea70b5e359bd60edd742730612bb2" translate="yes" xml:space="preserve">
          <source>This response code is sent after accomplishing request to tell user agent reset document view which sent this request.</source>
          <target state="translated">该响应代码是在完成请求后发送的,用于告诉发送该请求的用户代理重置文档视图。</target>
        </trans-unit>
        <trans-unit id="a6e3073e4af982c8216898b651b8900b118d9707" translate="yes" xml:space="preserve">
          <source>This response code is used because of range header sent by the client to separate download into multiple streams.</source>
          <target state="translated">这个响应代码是由于客户端发送的范围头将下载分成多个流而使用的。</target>
        </trans-unit>
        <trans-unit id="b0b3091267e6eb1f6619e52e3332c6b0eef55bd5" translate="yes" xml:space="preserve">
          <source>This response code is used when the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header is sent from the client to request only part of a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54001a8a74f4230a78d081c9dd427598feb0b64e" translate="yes" xml:space="preserve">
          <source>This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.</source>
          <target state="translated">这个响应代码意味着返回的元信息集与源服务器上的不完全相同,而是从本地或第三方副本中收集的。除此条件外,应首选200 OK响应,而不是此响应。</target>
        </trans-unit>
        <trans-unit id="adaff7b5972a65eef381227188ec9967318ffddd" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. Further changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48afdbe246b4285c52a497fa58e9555d4417761" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="translated">此响应代码表示所请求资源的URI已&lt;em&gt;临时&lt;/em&gt;更改。将来可能会在URI中进行新的更改。因此，客户端应在以后的请求中使用相同的URI。</target>
        </trans-unit>
        <trans-unit id="796776b8f699ee7445564de16ff0f1e7a6734445" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of the requested resource has been changed. Probably, the new URI would be given in the response.</source>
          <target state="translated">这个响应代码意味着请求的资源的URI已经被改变。可能在响应中会给出新的URI。</target>
        </trans-unit>
        <trans-unit id="d31becaff4260704a27003cc76245a28d6fbfe6e" translate="yes" xml:space="preserve">
          <source>This response code means the expectation indicated by the &lt;code&gt;Expect&lt;/code&gt; request header field can't be met by the server.</source>
          <target state="translated">此响应代码表示服务器无法满足&amp;ldquo; &lt;code&gt;Expect&lt;/code&gt; 请求标头&amp;rdquo;字段指示的期望。</target>
        </trans-unit>
        <trans-unit id="f85333520aaa3b92348b920c927ea684bb37f464" translate="yes" xml:space="preserve">
          <source>This response code means the returned meta-information is not exactly the same as is available from the origin server, but is collected from a local or a third-party copy. This is mostly used for mirrors or backups of another resource. Except for that specific case, the &quot;200 OK&quot; response is preferred to this status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276e87f04788008ea8cf8cd65690a3af4d8541d7" translate="yes" xml:space="preserve">
          <source>This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.</source>
          <target state="translated">这个响应是由一些服务器在一个空闲的连接上发送的,甚至在客户端没有任何先前的请求的情况下。这意味着服务器想关闭这个未使用的连接。由于一些浏览器,如Chrome、Firefox 27+或IE9,使用HTTP预连接机制来加快冲浪速度,所以这个响应使用得更多。另外要注意的是,有些服务器只是关闭了连接,而没有发送这个消息。</target>
        </trans-unit>
        <trans-unit id="2c19fa8f26e55768b081e1362d43a2a5e678955c" translate="yes" xml:space="preserve">
          <source>This response is sent when a request conflicts with the current state of the server.</source>
          <target state="translated">当一个请求与服务器的当前状态发生冲突时,就会发送这个响应。</target>
        </trans-unit>
        <trans-unit id="e9b8041c4bfcb3ea983601ee1d46fb89425a8ff6" translate="yes" xml:space="preserve">
          <source>This response is sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c23f72de698fc46f7f3192934a03283e62349b8" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content following the criteria given by the user agent.</source>
          <target state="translated">当Web服务器在执行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;服务器驱动的内容协商后&lt;/a&gt;，没有找到符合用户代理给出的条件的任何内容时，将发送此响应。</target>
        </trans-unit>
        <trans-unit id="f98b7a29dead3c53a44ae4ec7ab268f3fe1c0fc6" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content that conforms to the criteria given by the user agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20edf11481196ba8cc7fb946fd061c712997616b" translate="yes" xml:space="preserve">
          <source>This response is used much more since some browsers, like Chrome, Firefox 27+, and IE9, use HTTP pre-connection mechanisms to speed up surfing.</source>
          <target state="translated">由于一些浏览器,如Chrome、Firefox 27+和IE9,使用HTTP预连接机制来加快冲浪速度,所以这个响应使用得更多。</target>
        </trans-unit>
        <trans-unit id="efe292862f7c79acb9c2cf06d20c3228017f8092" translate="yes" xml:space="preserve">
          <source>This response means that server could not understand the request due to invalid syntax.</source>
          <target state="translated">这个响应意味着服务器由于语法无效而无法理解该请求。</target>
        </trans-unit>
        <trans-unit id="b752e6a7b8c6d84ac6a300b6dfb2535f1b47b8ae" translate="yes" xml:space="preserve">
          <source>This response would be sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="translated">当请求的内容已从服务器上永久删除,且没有转发地址时,将发送此响应。客户端应该删除他们的缓存和资源链接。HTTP规范打算将此状态码用于 &quot;限时、促销服务&quot;。API不应该觉得必须用这个状态码来表示已经删除的资源。</target>
        </trans-unit>
        <trans-unit id="eb0cde7eef9a19e7d58639cfa5c60f6f2574ad52" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields for applying preconditions on requests.  &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt; defines
   when the preconditions are applied.  &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; defines the order of
   evaluation when more than one precondition is present.</source>
          <target state="translated">本节定义了HTTP / 1.1标头字段的语法和语义，用于在请求上应用前提条件。 &lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;定义了何时应用前提条件。 &lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;定义了存在多个前提条件时的评估顺序。</target>
        </trans-unit>
        <trans-unit id="84857579e8f4c4b00cf5ec7e227da62c2cbe3299" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields related to caching.</source>
          <target state="translated">本节定义了与缓存相关的HTTP/1.1头域的语法和语义。</target>
        </trans-unit>
        <trans-unit id="0e8dc398bfb18bf438574e9ca86e1a588f2447e3" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of all standard
   HTTP/1.1 header fields. For entity-header fields, both sender and
   recipient refer to either the client or the server, depending on who
   sends and who receives the entity.</source>
          <target state="translated">本节定义了所有标准 HTTP/1.1 头字段的语法和语义。对于实体头字段,发送者和接收者都指客户端或服务器,这取决于谁发送和谁接收实体。</target>
        </trans-unit>
        <trans-unit id="96ccae596f81c60b228fa76095eeb49aec1c38ba" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of header fields
   related to the HTTP authentication framework.</source>
          <target state="translated">本节定义了与HTTP认证框架相关的头字段的语法和语义。</target>
        </trans-unit>
        <trans-unit id="b059e4393c3ed5f02e30040602db1e13b843ebfb" translate="yes" xml:space="preserve">
          <source>This section describes problems that commonly occur when creating and using &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">本节描述了在创建和使用 &lt;code&gt;data&lt;/code&gt; URL 时常见的问题。</target>
        </trans-unit>
        <trans-unit id="509645587a49cf601fb027d0d0b3f365b9c1a570" translate="yes" xml:space="preserve">
          <source>This section describes the semantics specific to the write lock type.
   The write lock is a specific instance of a lock type, and is the only
   lock type described in this specification.

   An exclusive write lock protects a resource: it prevents changes by
   any principal other than the lock creator and in any case where the
   lock token is not submitted (e.g., by a client process other than the
   one holding the lock).

   Clients MUST submit a lock-token they are authorized to use in any
   request that modifies a write-locked resource.  The list of
   modifications covered by a write-lock include:

   1.  A change to any of the following aspects of any write-locked
       resource:

       *  any variant,

       *  any dead property,

       *  any live property that is lockable (a live property is
          lockable unless otherwise defined.)

   2.  For collections, any modification of an internal member URI.  An
       internal member URI of a collection is considered to be modified
       if it is added, removed, or identifies a different resource.
       More discussion on write locks and collections is found in
       &lt;a href=&quot;#section-7.4&quot;&gt;Section 7.4&lt;/a&gt;.

   3.  A modification of the mapping of the root of the write lock,
       either to another resource or to no resource (e.g., DELETE).

   Of the methods defined in HTTP and WebDAV, PUT, POST, PROPPATCH,
   LOCK, UNLOCK, MOVE, COPY (for the destination resource), DELETE, and
   MKCOL are affected by write locks.  All other HTTP/WebDAV methods
   defined so far -- GET in particular -- function independently of a
   write lock.

   The next few sections describe in more specific terms how write locks
   interact with various operations.</source>
          <target state="translated">本节描述了特定于写锁定类型的语义。写锁是锁类型的特定实例，并且是本规范中描述的唯一锁类型。排他式写锁可以保护资源：它可以防止除锁创建者以外的任何主体进行更改，并且在任何情况下（例如，由持有锁的客户端进程以外的其他客户端进程）不提交锁令牌时，都可以防止更改。客户必须提交他们有权在修改写锁资源的任何请求中使用的锁令牌。写锁涵盖的修改列表包括：1.对任何写锁资源的以下任何方面进行更改：*任何变体，*任何无效属性，*任何可锁定的活动属性（除非另行定义，否则活动属性是可锁定的。）2.对于集合，内部成员URI的任何修改。如果集合的内部成员URI被添加，删除或标识其他资源，则认为该集合的内部成员URI被修改。有关写锁和集合的更多讨论，请参见 &lt;a href=&quot;#section-7.4&quot;&gt;7.4节&lt;/a&gt;。 3.修改写锁定的根到另一个资源或没有资源的映射（例如DELETE）。在HTTP和WebDAV中定义的方法中，PUT，POST，PROPPATCH，LOCK，UNLOCK，MOVE，COPY（用于目标资源），DELETE和MKCOL受写锁定的影响。到目前为止定义的所有其他HTTP / WebDAV方法（特别是GET）的功能独立于写锁。接下来的几节将更具体地描述写锁如何与各种操作交互。</target>
        </trans-unit>
        <trans-unit id="1b8caae975a03a8390b52fa0ed5d2957f9b87b19" translate="yes" xml:space="preserve">
          <source>This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.</source>
          <target state="translated">本节旨在告知应用开发者、信息提供者和用户本文档所描述的HTTP/1.1的安全限制。本节的讨论并不包括对所揭示问题的明确解决方案,尽管它确实提出了一些降低安全风险的建议。</target>
        </trans-unit>
        <trans-unit id="e14dd174357a0e5e555989561acf1df199436583" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns relevant to HTTP semantics and
   its use for transferring information over the Internet.
   Considerations related to message syntax, parsing, and routing are
   discussed in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;Section&amp;nbsp;9 of [RFC7230]&lt;/a&gt;.

   The list of considerations below is not exhaustive.  Most security
   concerns related to HTTP semantics are about securing server-side
   applications (code behind the HTTP interface), securing user agent 

   processing of payloads received via HTTP, or secure use of the
   Internet in general, rather than security of the protocol.  Various
   organizations maintain topical information and links to current
   research on Web application security (e.g., [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]).</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户与HTTP语义有关的已知安全问题及其在Internet上传输信息的用途。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;[RFC7230]的第9节&lt;/a&gt;讨论了与消息语法，解析和路由相关的注意事项。以下注意事项列表并不详尽。与HTTP语义相关的大多数安全问题都与保护服务器端应用程序（HTTP接口后面的代码），保护通过HTTP接收的有效负载的用户代理处理或总体上安全使用Internet而不是协议的安全性有关。各种组织维护主题信息并链接到有关Web应用程序安全性的最新研究（例如[ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ]）。</target>
        </trans-unit>
        <trans-unit id="cc5ec5ca15ce6b7e4d99013caa23973be65f1836" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP authentication.
   More general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Everything about the topic of HTTP authentication is a security
   consideration, so the list of considerations below is not exhaustive.
   Furthermore, it is limited to security considerations regarding the
   authentication framework, in general, rather than discussing all of
   the potential considerations for specific authentication schemes
   (which ought to be documented in the specifications that define those
   schemes).  Various organizations maintain topical information and
   links to current research on Web application security (e.g.,
   [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]), including common pitfalls for implementing and using the
   authentication schemes found in practice.</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户有关HTTP身份验证的已知安全问题。在HTTP消息传递[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]和语义[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 中解决了更一般的安全注意事项。]。关于HTTP身份验证主题的所有内容都是出于安全考虑，因此下面的注意事项列表并不详尽。此外，一般来说，它仅限于关于认证框架的安全性考虑，而不是讨论特定认证方案的所有潜在考虑因素（应在定义那些方案的规范中进行记录）。各种组织维护主题信息并链接到有关Web应用程序安全性的最新研究（例如&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;），包括实施和使用实践中发现的身份验证方案的常见陷阱。</target>
        </trans-unit>
        <trans-unit id="d7b61cbd1c222657e3948d017b4f1b45bdc23901" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP caching.  More
   general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Caches expose additional potential vulnerabilities, since the
   contents of the cache represent an attractive target for malicious
   exploitation.  Because cache contents persist after an HTTP request
   is complete, an attack on the cache can reveal information long after
   a user believes that the information has been removed from the
   network.  Therefore, cache contents need to be protected as sensitive
   information.

   In particular, various attacks might be amplified by being stored in
   a shared cache; such &quot;cache poisoning&quot; attacks use the cache to
   distribute a malicious payload to many clients, and are especially
   effective when an attacker can use implementation flaws, elevated
   privileges, or other techniques to insert such a response into a
   cache.  One common attack vector for cache poisoning is to exploit
   differences in message parsing on proxies and in user agents; see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;Section&amp;nbsp;3.3.3 of [RFC7230]&lt;/a&gt; for the relevant requirements.

   Likewise, implementation flaws (as well as misunderstanding of cache
   operation) might lead to caching of sensitive information (e.g.,
   authentication credentials) that is thought to be private, exposing
   it to unauthorized parties. 

   Furthermore, the very use of a cache can bring about privacy
   concerns.  For example, if two users share a cache, and the first one
   browses to a site, the second may be able to detect that the other
   has been to that site, because the resources from it load more
   quickly, thanks to the cache.

   Note that the Set-Cookie response header field [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] does not
   inhibit caching; a cacheable response with a Set-Cookie header field
   can be (and often is) used to satisfy subsequent requests to caches.
   Servers who wish to control caching of these responses are encouraged
   to emit appropriate Cache-Control response header fields.</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户有关HTTP缓存的已知安全问题。在HTTP消息传递[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]和语义[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 中解决了更一般的安全注意事项。]。缓存会暴露出其他潜在的漏洞，因为缓存的内容代表了诱人的恶意利用目标。由于高速缓存的内容在HTTP请求完成后仍然存在，因此在用户认为信息已从网络中删除之后很长时间，对高速缓存的攻击就会泄露信息。因此，需要将缓存内容作为敏感信息进行保护。特别是，各种攻击可能会通过存储在共享缓存中而被放大。此类&amp;ldquo;缓存中毒&amp;rdquo;攻击使用缓存将恶意有效负载分发给许多客户端，当攻击者可以使用实现缺陷，提升的特权或其他技术将此类响应插入缓存时，这种攻击尤其有效。缓存中毒的一种常见攻击媒介是利用代理和用户代理中的消息解析差异。看到 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;[RFC7230]的3.3.3节介绍&lt;/a&gt;了相关要求。同样，实现缺陷（以及对缓存操作的误解）可能会导致缓存敏感信息（例如，身份验证凭据）被认为是私有的，从而将其暴露给未授权方。此外，仅使用高速缓存会带来隐私问题。例如，如果两个用户共享一个缓存，而第一个用户浏览到一个站点，则第二个用户可能能够检测到另一个用户已经访问了该站点，因为有了该缓存，来自该站点的资源可以更快地加载。请注意，Set-Cookie响应标头字段[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]不禁止缓存；具有Set-Cookie标头字段的可缓存响应可以（并且经常）用于满足对缓存的后续请求。鼓励希望控制这些响应的缓存的服务器发出适当的Cache-Control响应标头字段。</target>
        </trans-unit>
        <trans-unit id="0e335c0656016c7e9ffd0c440c556a3faf33fe1d" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP conditional
   request mechanisms.  More general security considerations are
   addressed in HTTP &quot;Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and
   &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. 

   The validators defined by this specification are not intended to
   ensure the validity of a representation, guard against malicious
   changes, or detect man-in-the-middle attacks.  At best, they enable
   more efficient cache updates and optimistic concurrent writes when
   all participants are behaving nicely.  At worst, the conditions will
   fail and the client will receive a response that is no more harmful
   than an HTTP exchange without conditional requests.

   An entity-tag can be abused in ways that create privacy risks.  For
   example, a site might deliberately construct a semantically invalid
   entity-tag that is unique to the user or user agent, send it in a
   cacheable response with a long freshness time, and then read that
   entity-tag in later conditional requests as a means of re-identifying
   that user or user agent.  Such an identifying tag would become a
   persistent identifier for as long as the user agent retained the
   original cache entry.  User agents that cache representations ought
   to ensure that the cache is cleared or replaced whenever the user
   performs privacy-maintaining actions, such as clearing stored cookies
   or changing to a private browsing mode.</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户特定于HTTP条件请求机制的已知安全问题。HTTP&amp;ldquo;消息语法和路由&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]和&amp;ldquo;语义和内容&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 解决了更多常规安全注意事项。]。本规范定义的验证器并非旨在确保表示的有效性，防止恶意更改或检测中间人攻击。最好的情况是，当所有参与者都表现良好时，它们可以实现更有效的缓存更新和乐观的并发写入。最坏的情况是，条件将失败，并且客户端将收到比没有条件请求的HTTP交换有害的响应。实体标签可能会以造成隐私风险的方式被滥用。例如，某个网站可能故意构造一个用户或用户代理特有的在语义上无效的实体标签，以较长的刷新时间在可缓存的响应中发送该标签，然后在以后的条件请求中读取该实体标签，以重新标识该用户或用户代理。只要用户代理保留了原始缓存条目，这种识别标签就将成为永久性标识符。缓存表示形式的用户代理应确保每当用户执行隐私维护操作（例如清除存储的Cookie或更改为私有浏览模式）时，便清除或替换缓存。</target>
        </trans-unit>
        <trans-unit id="a8b6ada4af46edbc538acb5ee5cd9d1e819c9d08" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP range
   request mechanisms.  More general security considerations are
   addressed in HTTP messaging [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">本部分旨在通知开发人员，信息提供者和用户有关HTTP范围请求机制的已知安全问题。在HTTP消息传递[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]和语义[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 中解决了更一般的安全注意事项。</target>
        </trans-unit>
        <trans-unit id="20f34b6144b38a6c6e8c314d3b99c718e19c16cf" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security considerations relevant to HTTP message
   syntax, parsing, and routing.  Security considerations about HTTP
   semantics and payloads are addressed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">本部分旨在向开发人员，信息提供者和用户通知与HTTP消息语法，解析和路由相关的已知安全注意事项。有关HTTP语义和有效负载的安全性注意事项，请参见[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="6807589d15db566935fa0b36f3c986f0dcb8f1e1" translate="yes" xml:space="preserve">
          <source>This section is provided to detail issues concerning security
   implications of which WebDAV applications need to be aware.

   All of the security considerations of HTTP/1.1 (discussed in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]) and XML (discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]) also apply to WebDAV.  In
   addition, the security risks inherent in remote authoring require
   stronger authentication technology, introduce several new privacy
   concerns, and may increase the hazards from poor server design.
   These issues are detailed below.</source>
          <target state="translated">提供本节的内容是为了详细说明有关WebDAV应用程序需要注意的安全隐患的问题。 HTTP / 1.1（在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中讨论）和XML（在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]中讨论）的所有安全考虑因素也适用于WebDAV。此外，远程创作固有的安全风险需要更强大的身份验证技术，引入了一些新的隐私问题，并可能增加不良的服务器设计带来的危害。这些问题在下面详细介绍。</target>
        </trans-unit>
        <trans-unit id="b6f1686ad83954bc21d87d0b2feab0950aa7dc14" translate="yes" xml:space="preserve">
          <source>This section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers using cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; capability do not have to set any cross-origin sharing request headers programmatically.</source>
          <target state="translated">本节列出了客户端在发出HTTP请求时可以使用的标头，以利用跨域共享功能。请注意，在调用服务器时会为您设置这些标头。使用跨站点&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;功能的开发人员不必以编程方式设置任何跨域共享请求标头。</target>
        </trans-unit>
        <trans-unit id="2596221fd857bbcaea04d0cd1a4ea6fd1d357430" translate="yes" xml:space="preserve">
          <source>This section lists major changes between this document and &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;,
   starting with those that are likely to result in implementation
   changes.  Servers will advertise support for all changes in this
   specification by returning the compliance class &quot;3&quot; in the DAV
   response header (see Sections &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; and &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;).</source>
          <target state="translated">本节列出了本文档与&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;之间的主要更改，从可能导致实现更改的内容开始。服务器将通过在DAV响应标头中返回符合性类&amp;ldquo; 3&amp;rdquo;来公布对本规范中所有更改的支持（请参见&lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;和&lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="fd619925c99ba3f120ebdc079103c35edf44f771" translate="yes" xml:space="preserve">
          <source>This section lists the HTTP response headers that servers send back for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.</source>
          <target state="translated">本节列出了跨源资源共享规范所定义的服务器为访问控制请求发回的HTTP响应头。上一节概述了这些内容的作用。</target>
        </trans-unit>
        <trans-unit id="256b3572a114f6830fdfb27c4527ad2a42aa41b3" translate="yes" xml:space="preserve">
          <source>This section provides a concise model for how locking behaves.  Later
   sections will provide more detail on some of the concepts and refer
   back to these model statements.  Normative statements related to LOCK
   and UNLOCK method handling can be found in the sections on those
   methods, whereas normative statements that cover any method are
   gathered here.

   1.  A lock either directly or indirectly locks a resource.

   2.  A resource becomes directly locked when a LOCK request to a URL
       of that resource creates a new lock.  The &quot;lock-root&quot; of the new
       lock is that URL.  If at the time of the request, the URL is not
       mapped to a resource, a new empty resource is created and
       directly locked.

   3.  An exclusive lock (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;) conflicts with any other kind of
       lock on the same resource, whether either lock is direct or
       indirect.  A server MUST NOT create conflicting locks on a
       resource.

   4.  For a collection that is locked with a depth-infinity lock L, all
       member resources are indirectly locked.  Changes in membership of
       such a collection affect the set of indirectly locked resources:

       *  If a member resource is added to the collection, the new
          member resource MUST NOT already have a conflicting lock,
          because the new resource MUST become indirectly locked by L.

       *  If a member resource stops being a member of the collection,
          then the resource MUST no longer be indirectly locked by L.

   5.  Each lock is identified by a single globally unique lock token
       (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;).

   6.  An UNLOCK request deletes the lock with the specified lock token.
       After a lock is deleted, no resource is locked by that lock.

   7.  A lock token is &quot;submitted&quot; in a request when it appears in an
       &quot;If&quot; header (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;, &quot;Write Lock&quot;, discusses when token
       submission is required for write locks).

   8.  If a request causes the lock-root of any lock to become an
       unmapped URL, then the lock MUST also be deleted by that request.</source>
          <target state="translated">本节提供了有关锁定行为的简洁模型。后面的部分将提供有关某些概念的更多详细信息，并返回参考这些模型语句。与LOCK和UNLOCK方法处理相关的规范性语句可以在关于这些方法的部分中找到，而涵盖所有方法的规范性语句均在此处收集。 1.锁直接或间接锁定资源。 2.当对资源的URL的LOCK请求创建新的锁定时，资源将直接锁定。新锁的&amp;ldquo;锁根&amp;rdquo;是该URL。如果在请求时URL没有映射到资源，则创建一个新的空资源并将其直接锁定。 3.排他锁（&lt;a href=&quot;#section-6.2&quot;&gt;第6.2节&lt;/a&gt;）与同一资源上的任何其他类型的锁（无论是直接锁还是间接锁）冲突。服务器不得在资源上创建冲突的锁。 4.对于使用深度无限锁L锁定的集合，所有成员资源都被间接锁定。此类集合的成员资格更改会影响间接锁定资源的集合：*如果将成员资源添加到集合中，则新成员资源不得已经具有冲突的锁，因为新资源必须被L间接锁定。如果成员资源不再是集合的成员，则该资源必须不再被L间接锁定。5.每个锁定都由单个全局唯一的锁定令牌（&lt;a href=&quot;#section-6.5&quot;&gt;6.5节&lt;/a&gt;）。 6. UNLOCK请求删除具有指定锁令牌的锁。删除锁后，该锁不会锁定任何资源。 7.当请求中出现&amp;ldquo;如果&amp;rdquo;标头时，请求中将&amp;ldquo;提交&amp;rdquo;锁令牌（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt; &amp;ldquo;写锁&amp;rdquo;讨论写锁何时需要提交令牌）。 8.如果一个请求导致任何锁的锁根变成未映射的URL，则该锁也必须被该请求删除。</target>
        </trans-unit>
        <trans-unit id="b4b255e71c5acf2b758f6ac1313183b4a6e6c569" translate="yes" xml:space="preserve">
          <source>This section provides a description of a type of Web resource, the
   collection, and discusses its interactions with the HTTP URL
   namespace and with HTTP methods.  The purpose of a collection
   resource is to model collection-like objects (e.g., file system
   directories) within a server's namespace. 

   All DAV-compliant resources MUST support the HTTP URL namespace model
   specified herein.</source>
          <target state="translated">本节提供了对Web资源的一种类型--集合的描述,并讨论了它与HTTP URL命名空间和与HTTP方法的交互。集合资源的目的是在服务器的命名空间中模拟类似集合的对象(例如,文件系统目录)。所有符合DAV的资源都必须支持这里指定的HTTP URL命名空间模型。</target>
        </trans-unit>
        <trans-unit id="41f24be581ad6f64eda1b3a4bd3c9c3eed891392" translate="yes" xml:space="preserve">
          <source>This section provides examples of some common security policy scenarios.</source>
          <target state="translated">本节提供了一些常见的安全策略场景的例子。</target>
        </trans-unit>
        <trans-unit id="ffdc290f371b09817d92044b4802c7dcaa78a48b" translate="yes" xml:space="preserve">
          <source>This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.</source>
          <target state="translated">本节总结了HTTP/1.0和HTTP/1.1版本之间的主要区别。</target>
        </trans-unit>
        <trans-unit id="ff966b2d60be3de0767cef83a4ad73d50f777ddf" translate="yes" xml:space="preserve">
          <source>This section, as with similar sections for other methods, provides
   some guidance on error codes and preconditions or postconditions
   (defined in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) that might be particularly useful with
   PROPFIND.

   403 Forbidden - A server MAY reject PROPFIND requests on collections
   with depth header of &quot;Infinity&quot;, in which case it SHOULD use this
   error with the precondition code 'propfind-finite-depth' inside the
   error body.</source>
          <target state="translated">本节与其他方法的类似部分一样，提供了有关错误代码以及前置条件或后置条件（在&lt;a href=&quot;#section-16&quot;&gt;第16节中&lt;/a&gt;定义）的一些指导，这些指导可能对PROPFIND尤其有用。403禁止-服务器可以拒绝深度标头为&amp;ldquo; Infinity&amp;rdquo;的集合上的PROPFIND请求，在这种情况下，服务器应在错误体内使用带有前提条件代码&amp;ldquo; propfind-depth-depth&amp;rdquo;的错误。</target>
        </trans-unit>
        <trans-unit id="ee00e4e33c5031393996d9cbbb32237668a87ffc" translate="yes" xml:space="preserve">
          <source>This shows the server sending headers to tell the client to store a pair of cookies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639667e8ad5d2c48599430916aed509755cbbadd" translate="yes" xml:space="preserve">
          <source>This simple HTML file will be saved as a regular download rather than displayed in the browser. Most browsers will propose to save it under the &lt;code&gt;cool.html&lt;/code&gt; filename (by default).</source>
          <target state="translated">这个简单的HTML文件将被保存为常规下载文件，而不是显示在浏览器中。大多数浏览器建议将其保存在 &lt;code&gt;cool.html&lt;/code&gt; 文件名下（默认情况下）。</target>
        </trans-unit>
        <trans-unit id="1c7309d7bb5ffc950761c7540724deee943ec907" translate="yes" xml:space="preserve">
          <source>This simple model held an innate limitation on performance: opening each TCP connection is a resource-consuming operation. Several messages must be exchanged between the client and the server. Network latency and bandwidth affect performance when a request needs sending. Modern Web pages require many requests (a dozen or more) to serve the amount of information needed, proving this earlier model inefficient.</source>
          <target state="translated">这个简单的模型对性能有一个先天的限制:打开每个TCP连接都是一个耗费资源的操作。客户端和服务器之间必须交换几个消息。当一个请求需要发送时,网络延迟和带宽会影响性能。现代网页需要许多请求(十几个或更多)才能提供所需的信息量,证明这种早期的模型效率低下。</target>
        </trans-unit>
        <trans-unit id="484f69d86199a4745f12e506b1b55024069115fc" translate="yes" xml:space="preserve">
          <source>This solution is more efficient, but slightly less flexible, as only one etag can be used in the condition. Rarely is such additional flexibility needed.</source>
          <target state="translated">这种解决方案效率较高,但灵活性稍差,因为条件中只能使用一个etag。很少需要这种额外的灵活性。</target>
        </trans-unit>
        <trans-unit id="01774d0c8108df34d3eb470ca203ddd51442235b" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit&quot; to the Atom Registry of Link
   Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  The value of &quot;edit&quot;
   specifies that the value of the href attribute is the IRI of an
   editable Member Entry.  When appearing within an atom:entry, the href
   IRI can be used to retrieve, update, and delete the Resource
   represented by that Entry.  An atom:entry MUST NOT contain more than
   one &quot;edit&quot; link relation.</source>
          <target state="translated">该规范在链接关系的Atom注册中心添加值&amp;ldquo; edit&amp;rdquo;（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287]的7.1节&lt;/a&gt;）。&amp;ldquo; edit&amp;rdquo;的值指定href属性的值是可编辑成员条目的IRI。当出现在atom：entry中时，href IRI可用于检索，更新和删除该Entry表示的资源。一个atom：entry不得包含多个&amp;ldquo; edit&amp;rdquo;链接关系。</target>
        </trans-unit>
        <trans-unit id="87fe0975464508a17f30a33c7f745b43a75fae60" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit-media&quot; to the Atom Registry
   of Link Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  When appearing
   within an atom:entry, the value of the href attribute is an IRI that
   can be used to modify a Media Resource associated with that Entry.

   An atom:entry element MAY contain zero or more &quot;edit-media&quot; link
   relations.  An atom:entry MUST NOT contain more than one atom:link
   element with a &quot;rel&quot; attribute value of &quot;edit-media&quot; that has the
   same &quot;type&quot; and &quot;hreflang&quot; attribute values.  All &quot;edit-media&quot; link
   relations in the same Entry reference the same Resource.  If a client
   encounters multiple &quot;edit-media&quot; link relations in an Entry then it
   SHOULD choose a link based on the client preferences for &quot;type&quot; and
   &quot;hreflang&quot;.  If a client encounters multiple &quot;edit-media&quot; link
   relations in an Entry and has no preference based on the &quot;type&quot; and
   &quot;hreflang&quot; attributes then the client SHOULD pick the first &quot;edit-
   media&quot; link relation in document order.</source>
          <target state="translated">该规范将值&amp;ldquo; edit-media&amp;rdquo;添加到链接关系的Atom注册中心（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287]的7.1节）&lt;/a&gt;）。当出现在atom：entry中时，href属性的值是一个IRI，可用于修改与该Entry关联的媒体资源。一个atom：entry元素可以包含零个或多个&amp;ldquo; edit-media&amp;rdquo;链接关系。一个atom：entry不得包含一个以上的atom：link元素，这些元素的&amp;ldquo; rel&amp;rdquo;属性值为&amp;ldquo; edit-media&amp;rdquo;，具有相同的&amp;ldquo; type&amp;rdquo;和&amp;ldquo; hreflang&amp;rdquo;属性。同一条目中的所有&amp;ldquo;编辑媒体&amp;rdquo;链接关系都引用相同的资源。如果一个客户在一个条目中遇到多个&amp;ldquo;编辑媒体&amp;rdquo;链接关系，那么它应该根据客户对&amp;ldquo;类型&amp;rdquo;和&amp;ldquo; hreflang&amp;rdquo;的偏好选择一个链接。如果客户遇到多个&amp;ldquo;编辑媒体&amp;rdquo;条目中的链接关系，并且没有基于&amp;ldquo;类型&amp;rdquo;和&amp;ldquo; hreflang&amp;rdquo;属性的首选项，则客户端应按文档顺序选择第一个&amp;ldquo;编辑媒体&amp;rdquo;链接关系。</target>
        </trans-unit>
        <trans-unit id="b2a53f987b042cdfef40437d4b21f1000736b54d" translate="yes" xml:space="preserve">
          <source>This specification defines a new &quot;type&quot; parameter for use with the
   &quot;application/atom+xml&quot; media type.  The &quot;type&quot; parameter has a value
   of &quot;entry&quot; or &quot;feed&quot;.

   Neither the parameter name nor its value are case sensitive. 

   The value &quot;entry&quot; indicates that the media type identifies an Atom
   Entry Document.  The root element of the document MUST be atom:entry.

   The value &quot;feed&quot; indicates that the media type identifies an Atom
   Feed Document.  The root element of the document MUST be atom:feed.

   If not specified, the type is assumed to be unspecified, requiring
   Atom processors to examine the root element to determine the type of
   Atom document.</source>
          <target state="translated">本规范定义了一个新的 &quot;类型 &quot;参数,用于 &quot;application/atom+xml &quot;媒体类型。类型 &quot;参数的值为 &quot;entry &quot;或 &quot;feed&quot;。参数名和其值都不区分大小写。值 &quot;entry &quot;表示该媒体类型标识一个Atom条目文档。文档的根元素必须是atom:entry。值 &quot;feed &quot;表示该媒体类型标识一个 Atom Feed Document。文档的根元素必须是 atom:feed。如果没有指定,则假定类型是未指定的,需要Atom处理器检查根元素以确定Atom文档的类型。</target>
        </trans-unit>
        <trans-unit id="978449461dd375d2f22dc902ad77e42eee391e36" translate="yes" xml:space="preserve">
          <source>This specification defines an Atom Format Structured Extension, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;, for publishing control within the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace.</source>
          <target state="translated">该规范定义了&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]第6节中&lt;/a&gt;定义的Atom格式结构化扩展，用于在&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;rdquo;命名空间内发布控件。</target>
        </trans-unit>
        <trans-unit id="91a1e7bdc7ea038fc4979f4ad8ada34b2e46af01" translate="yes" xml:space="preserve">
          <source>This specification defines the HTTP status codes

   o  207 Multi-Status (&lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;)

   o  422 Unprocessable Entity (&lt;a href=&quot;#section-11.2&quot;&gt;Section 11.2&lt;/a&gt;),

   o  423 Locked (&lt;a href=&quot;#section-11.3&quot;&gt;Section 11.3&lt;/a&gt;),

   o  424 Failed Dependency (&lt;a href=&quot;#section-11.4&quot;&gt;Section 11.4&lt;/a&gt;) and

   o  507 Insufficient Storage (&lt;a href=&quot;#section-11.5&quot;&gt;Section 11.5&lt;/a&gt;),

   to be updated in the registry at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   Note: the HTTP status code 102 (Processing) has been removed in this
   specification; its IANA registration should continue to reference &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;.</source>
          <target state="translated">该规范定义了HTTP状态代码o 207多状态（&lt;a href=&quot;#section-11.1&quot;&gt;第11.1节&lt;/a&gt;）o 422不可处理实体（&lt;a href=&quot;#section-11.2&quot;&gt;第11.2节&lt;/a&gt;），o 423锁定（&lt;a href=&quot;#section-11.3&quot;&gt;第11.3节&lt;/a&gt;），o 424依赖关系失败（&lt;a href=&quot;#section-11.4&quot;&gt;第11.4节&lt;/a&gt;）和o 507存储不足（&lt;a href=&quot;#section-11.5&quot;&gt;第11.5节&lt;/a&gt;） ，可在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 的注册表中进行更新。注意：在此规范中，HTTP状态代码102（正在处理）已被删除；其IANA注册应继续参考&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e1fe7c5f8c6eb66628d934996aa12f9c804ee43" translate="yes" xml:space="preserve">
          <source>This specification defines two URI schemes:

   1.  the &quot;opaquelocktoken&quot; scheme defined in &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;, and

   2.  the &quot;DAV&quot; URI scheme, which historically was used in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] to
       disambiguate WebDAV property and XML element names and which
       continues to be used for that purpose in this specification and
       others extending WebDAV.  Creation of identifiers in the &quot;DAV:&quot;
       namespace is controlled by the IETF.

   Note that defining new URI schemes for XML namespaces is now
   discouraged.  &quot;DAV:&quot; was defined before standard best practices
   emerged.</source>
          <target state="translated">该规范定义了两个URI方案：1. &lt;a href=&quot;#appendix-C&quot;&gt;附录C中&lt;/a&gt;定义的&amp;ldquo; opaquelocktoken&amp;rdquo;方案，以及2.&amp;ldquo; DAV&amp;rdquo; URI方案，该方案在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ]中曾用于消除WebDAV属性和XML元素名称的歧义，并且继续使用在本规范和其他扩展WebDAV中用于该目的。在&amp;ldquo; DAV：&amp;rdquo;命名空间中标识符的创建由IETF控制。请注意，现在不建议为XML名称空间定义新的URI方案。在标准最佳实践出现之前就定义了&amp;ldquo; DAV：&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="21623dc11b6c2f043255281513da10df5c7cbec3" translate="yes" xml:space="preserve">
          <source>This specification defines two forms of metadata that are commonly
   used to observe resource state and test for preconditions:
   modification dates (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;) and opaque entity tags
   (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;).  Additional metadata that reflects resource state has
   been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning (WebDAV, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt;]), that are beyond the
   scope of this specification.  A resource metadata value is referred
   to as a &quot;validator&quot; when it is used within a precondition.</source>
          <target state="translated">本规范定义了两种常用于观察资源状态和测试前提条件的元数据形式：修改日期（&lt;a href=&quot;#section-2.2&quot;&gt;第2.2节&lt;/a&gt;）和不透明的实体标签（&lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt;）。 HTTP的各种扩展定义了反映资源状态的其他元数据，例如Web分布式创作和版本控制（WebDAV，[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt; ]），这些扩展超出了本规范的范围。当在前提条件中使用资源元数据值时，将其称为&amp;ldquo;验证器&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="187fe63d0c83c4fa38b37175ce98332747f01af0" translate="yes" xml:space="preserve">
          <source>This specification defines two kinds of documents -- Category
   Documents and Service Documents.

   A Category Document (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) contains lists of categories
   specified using the &quot;atom:category&quot; element from the Atom Syndication
   Format (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC4287]&lt;/a&gt;).

   A Service Document (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) groups available Collections into
   Workspaces.

   The namespace name [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;] for either kind of document is:

       &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;

   Atom Publishing Protocol XML Documents MUST be &quot;namespace-well-
   formed&quot; as specified in Section 7 of [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;].

   This specification uses the prefix &quot;app:&quot; for the namespace name.
   The prefix &quot;atom:&quot; is used for &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;, the
   namespace name of the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  These
   namespace prefixes are not semantically significant.

   This specification does not define any DTDs for Atom Protocol
   formats, and hence does not require them to be &quot;valid&quot; in the sense
   used by [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">本规范定义了两种文档-类别文档和服务文档。类别文档（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）包含使用Atom联合组织格式中的&amp;ldquo; atom：category&amp;rdquo;元素指定的类别列表（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;[RFC4287]的第4.2.2节&lt;/a&gt;）。服务文档（&lt;a href=&quot;#section-8&quot;&gt;第8节&lt;/a&gt;）将可用的集合归为工作区。任一种文档&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;的名称&lt;/a&gt;空间名称[ REC-xml-names ]都是：&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http&lt;/a&gt; : //www.w3.org/2007/app Atom发布协议XML文档必须按照第7章第7节的规定进行&amp;ldquo;命名空间格式&amp;rdquo;的定义。 [ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-名称&lt;/a&gt;]。本规范使用前缀&amp;ldquo; app：&amp;rdquo;作为名称空间名称。前缀&amp;ldquo; atom：&amp;rdquo;用于&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &amp;rdquo;，这是Atom联合组织格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 的名称空间名称。这些名称空间前缀在语义上并不重要。该规范没有为Atom协议格式定义任何DTD，因此从[ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] 使用的意义上讲，它们并不要求它们&amp;ldquo;有效&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="6f49469a7f998d6aa7fb1c171080afd01320be81" translate="yes" xml:space="preserve">
          <source>This specification does not define the behavior of the PUT method for
   existing collections.  A PUT request to an existing collection MAY be
   treated as an error (405 Method Not Allowed).

   The MKCOL method is defined to create collections.</source>
          <target state="translated">本规范没有定义现有集合的PUT方法的行为。对现有集合的PUT请求可能会被视为错误(405 Method Not Allowed)。MKCOL方法被定义为创建集合。</target>
        </trans-unit>
        <trans-unit id="d7d3f4f1fc7a5db64d2f982f26f4448b11b753a7" translate="yes" xml:space="preserve">
          <source>This specification encourages the use of &quot;A Universally Unique
   Identifier (UUID) URN Namespace&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]) for lock tokens
   (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), in order to guarantee their uniqueness across space
   and time.  Version 1 UUIDs (defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) MAY contain a
   &quot;node&quot; field that &quot;consists of an IEEE 802 MAC address, usually the
   host address.  For systems with multiple IEEE addresses, any
   available one can be used&quot;.  Since a WebDAV server will issue many
   locks over its lifetime, the implication is that it may also be
   publicly exposing its IEEE 802 address.

   There are several risks associated with exposure of IEEE 802
   addresses.  Using the IEEE 802 address:

   o  It is possible to track the movement of hardware from subnet to
      subnet.

   o  It may be possible to identify the manufacturer of the hardware
      running a WebDAV server.

   o  It may be possible to determine the number of each type of
      computer running WebDAV.

   This risk only applies to host-address-based UUID versions.  &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;4 of [RFC4122]&lt;/a&gt; describes several other mechanisms for generating
   UUIDs that do not involve the host address and therefore do not
   suffer from this risk.</source>
          <target state="translated">本规范鼓励对锁令牌（&lt;a href=&quot;#section-6.5&quot;&gt;第6.5节&lt;/a&gt;）使用&amp;ldquo;通用唯一标识符（UUID）URN命名空间&amp;rdquo;（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt; ]），以确保其在空间和时间上的唯一性。版本1 UUID（在&lt;a href=&quot;#section-4&quot;&gt;第4节中&lt;/a&gt;定义））可以包含一个&amp;ldquo;节点&amp;rdquo;字段，该字段&amp;ldquo;由IEEE 802 MAC地址（通常是主机地址）组成。对于具有多个IEEE地址的系统，可以使用任何可用的地址&amp;rdquo;。由于WebDAV服务器将在其整个生命周期内发出许多锁，因此，这意味着它也可能公开公开其IEEE 802地址。与IEEE 802地址的公开存在若干风险。使用IEEE 802地址：o可以跟踪硬件在子网之间的移动。 o可以确定运行WebDAV服务器的硬件的制造商。 o可以确定运行WebDAV的每种计算机的数量。此风险仅适用于基于主机地址的UUID版本。 &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;[RFC4122]的&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;第&lt;/a&gt;4 节描述了其他几种生成UUID的机制，这些机制不涉及主机地址，因此不会遭受这种风险。</target>
        </trans-unit>
        <trans-unit id="37eee64d4bf2bb8f0591eb5fc58512e72f0c0858" translate="yes" xml:space="preserve">
          <source>This specification has been carefully audited to correct and
   disambiguate key word usage; &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; had many problems in respect to
   the conventions laid out in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   Clarified which error code should be used for inbound server failures
   (e.g. DNS failures). (&lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;). 

   CREATE had a race that required an Etag be sent when a resource is
   first created. (&lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;).

   Content-Base was deleted from the specification: it was not
   implemented widely, and there is no simple, safe way to introduce it
   without a robust extension mechanism. In addition, it is used in a
   similar, but not identical fashion in MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;].

   Transfer-coding and message lengths all interact in ways that
   required fixing exactly when chunked encoding is used (to allow for
   transfer encoding that may not be self delimiting); it was important
   to straighten out exactly how message lengths are computed. (Sections
   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)

   A content-coding of &quot;identity&quot; was introduced, to solve problems
   discovered in caching. (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;)

   Quality Values of zero should indicate that &quot;I don't want something&quot;
   to allow clients to refuse a representation. (&lt;a href=&quot;#section-3.9&quot;&gt;Section 3.9&lt;/a&gt;)

   The use and interpretation of HTTP version numbers has been clarified
   by &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;. Require proxies to upgrade requests to highest protocol
   version they support to deal with problems discovered in HTTP/1.0
   implementations (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   Charset wildcarding is introduced to avoid explosion of character set
   names in accept headers. (&lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;)

   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage
   was introduced to add this missing case. (Sections &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;, &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;, &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;,
   14.9.3)

   The Cache-Control: max-age directive was not properly defined for
   responses. (&lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;)

   There are situations where a server (especially a proxy) does not
   know the full length of a response but is capable of serving a
   byterange request. We therefore need a mechanism to allow byteranges
   with a content-range not indicating the full length of the message.
   (&lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;)

   Range request responses would become very verbose if all meta-data
   were always returned; by allowing the server to only send needed
   headers in a 206 response, this problem can be avoided. (&lt;a href=&quot;#section-10.2.7&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3, and 14.27) 

   Fix problem with unsatisfiable range requests; there are two cases:
   syntactic problems, and range doesn't exist in the document. The 416
   status code was needed to resolve this ambiguity needed to indicate
   an error for a byte range request that falls outside of the actual
   contents of a document. (&lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;, 14.16)

   Rewrite of message transmission requirements to make it much harder
   for implementors to get it wrong, as the consequences of errors here
   can have significant impact on the Internet, and to deal with the
   following problems:

      1. Changing &quot;HTTP/1.1 or later&quot; to &quot;HTTP/1.1&quot;, in contexts where
         this was incorrectly placing a requirement on the behavior of
         an implementation of a future version of HTTP/1.x

      2. Made it clear that user-agents should retry requests, not
         &quot;clients&quot; in general.

      3. Converted requirements for clients to ignore unexpected 100
         (Continue) responses, and for proxies to forward 100 responses,
         into a general requirement for 1xx responses.

      4. Modified some TCP-specific language, to make it clearer that
         non-TCP transports are possible for HTTP.

      5. Require that the origin server MUST NOT wait for the request
         body before it sends a required 100 (Continue) response.

      6. Allow, rather than require, a server to omit 100 (Continue) if
         it has already seen some of the request body.

      7. Allow servers to defend against denial-of-service attacks and
         broken clients.

   This change adds the Expect header and 417 status code. The message
   transmission requirements fixes are in sections &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;,
   8.1.2.2, 13.11, and 14.20.

   Proxies should be able to add Content-Length when appropriate.
   (&lt;a href=&quot;#section-13.5.2&quot;&gt;Section 13.5.2&lt;/a&gt;)

   Clean up confusion between 403 and 404 responses. (&lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;,
   10.4.5, and 10.4.11)

   Warnings could be cached incorrectly, or not updated appropriately.
   (&lt;a href=&quot;#section-13.1.2&quot;&gt;Section 13.1.2&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning
   also needed to be a general header, as PUT or other methods may have
   need for it in requests. 

   Transfer-coding had significant problems, particularly with
   interactions with chunked encoding. The solution is that transfer-
   codings become as full fledged as content-codings. This involves
   adding an IANA registry for transfer-codings (separate from content
   codings), a new header field (TE) and enabling trailer headers in the
   future. Transfer encoding is a major performance benefit, so it was
   worth fixing [&lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt;]. TE also solves another, obscure, downward
   interoperability problem that could have occurred due to interactions
   between authentication trailers, chunked encoding and HTTP/1.0
   clients.(&lt;a href=&quot;#section-3.6&quot;&gt;Section 3.6&lt;/a&gt;, 3.6.1, and 14.39)

   The PATCH, LINK, UNLINK methods were defined but not commonly
   implemented in previous versions of this specification. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;
   [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].

   The Alternates, Content-Version, Derived-From, Link, URI, Public and
   Content-Base header fields were defined in previous versions of this
   specification, but not commonly implemented. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">该规范已经过仔细审核，以纠正和消除关键字的使用；&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;在&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]中列出的约定方面存在许多问题。阐明了应将哪些错误代码用于入站服务器故障（例如DNS故障）。 （&lt;a href=&quot;#section-10.5.5&quot;&gt;第10.5.5节&lt;/a&gt;）。 CREATE的比赛要求在首次创建资源时发送Etag。 （&lt;a href=&quot;#section-10.2.2&quot;&gt;第10.2.2节&lt;/a&gt;）。 Content-Base已从规范中删除：它并未得到广泛实施，并且没有简单，安全的方法来引入它，而没有强大的扩展机制。此外，它在MHTML中以相似但不完全相同的方式使用[ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;]。当使用分块编码时，传输编码和消息长度都以需要精确解决的方式进行交互（以允许传输编码可能不是自定界的）；弄清楚准确计算消息长度的方式非常重要。 （第3.6、4.4、7.2.2、13.5.2、14.13、14.16节）引入了&amp;ldquo;身份&amp;rdquo;的内容编码，以解决在缓存中发现的问题。 （&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）质量值零应表示&amp;ldquo;我不要&amp;rdquo;，以允许客户拒绝表示。 （&lt;a href=&quot;#section-3.9&quot;&gt;第3.9节&lt;/a&gt;）&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;阐明了HTTP版本号的使用和解释。要求代理将请求升级到它们支持的最高协议版本，以处理HTTP / 1.0实现中发现的问题（&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;）引入了字符集通配符，以避免在接受标头中字符集名称激增。 （&lt;a href=&quot;#section-14.2&quot;&gt;第14.2节&lt;/a&gt;）HTTP / 1.1的Cache-Control模型中缺少一个案例；引入了s-maxage来添加这种丢失的情况。 （第&lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;，&lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;，&lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;，14.9.3）将Cache-Control：max-age的指令是不正确的响应定义。 （&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt;）在某些情况下，服务器（尤其是代理服务器）不知道响应的完整长度，但能够处理字节范围请求。因此，我们需要一种机制，以允许具有内容范围的字节范围不指示消息的全长。 （&lt;a href=&quot;#section-14.16&quot;&gt;第14.16节&lt;/a&gt;）如果始终返回所有元数据，则范围请求响应将变得非常冗长。通过允许服务器仅在206响应中发送所需的标头，可以避免此问题。 （&lt;a href=&quot;#section-10.2.7&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7 &lt;/a&gt;节，13.5.3和14.27）解决了范围请求无法满足的问题；有两种情况：语法问题，并且文档中不存在范围。需要使用416状态代码来解决这种歧义，该歧义需要为超出文档实际内容的字节范围请求指示错误。 （&lt;a href=&quot;#section-10.4.17&quot;&gt;第10.4.17节&lt;/a&gt;，14.16）重写消息传输要求，以使实现者更容易出错，因为此处的错误后果可能会对Internet产生重大影响，并处理以下问题：1.更改&amp;ldquo; HTTP / 1.1或稍后&amp;rdquo;到&amp;ldquo; HTTP / 1.1&amp;rdquo;，在这种情况下错误地对将来的HTTP / 1.x 2版本的实现行为提出了要求。请明确指出用户代理应重试请求，而不是&amp;ldquo;客户端&amp;ldquo; 一般来说。 3.将客户忽略无意的100（继续）响应以及代理转发100响应的要求转换为1xx响应的一般要求。 4.修改了一些特定于TCP的语言，明确指出HTTP可以使用非TCP传输。 5.要求原始服务器在发送必需的100（继续）响应之前，不得等待请求正文。 6.如果服务器已经看到一些请求正文，则允许而不是要求服务器省略100（继续）。 7.允许服务器防御拒绝服务攻击和损坏的客户端。此更改将添加Expect标头和417状态代码。消息传输要求修复的内容在部分中如果服务器已经看到一些请求正文，则省略100（继续）。 7.允许服务器防御拒绝服务攻击和损坏的客户端。此更改将添加Expect标头和417状态代码。消息传输要求修复的内容在部分中如果服务器已经看到一些请求正文，则省略100（继续）。 7.允许服务器防御拒绝服务攻击和损坏的客户端。此更改将添加Expect标头和417状态代码。消息传输要求修复的内容在部分中&lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;，&lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;，8.1.2.2，13.11，14.20和。代理应能够在适当的时候添加Content-Length。 （&lt;a href=&quot;#section-13.5.2&quot;&gt;第13.5.2节&lt;/a&gt;）清理403和404响应之间的混淆。 （&lt;a href=&quot;#section-10.4.4&quot;&gt;第10.4.4、10.4.5&lt;/a&gt;和10.4.11节）警告可能被错误地缓存或未适当更新。 （&lt;a href=&quot;#section-13.1.2&quot;&gt;第13.1.2节&lt;/a&gt;，13.2.4、13.5.2、13.5.3、14.9.3和14.46）警告也必须是通用标头，因为在请求中PUT或其他方法可能需要它。传输编码存在重大问题，尤其是与分块编码的交互时。解决方案是，传输编码与内容编码一样成熟。这涉及添加用于传输编码（与内容编码分开）的IANA注册中心，新的标头字段（TE），并在将来启用尾标头。传输编码是主要的性能优势，因此值得修复[ &lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt; ]。 TE还解决了另一个由于身份验证尾部，分块编码和HTTP / 1.0客户端之间的交互而可能发生的，晦涩的，向下的互操作性问题。（&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节）&lt;/a&gt;，3.6.1和14.39）定义了PATCH，LINK和UNLINK方法，但在本规范的先前版本中并不常用。参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]。Alternates，Content-Version，Derived-From，Link，URI，Public和Content-Base标头字段在本规范的先前版本中定义，但并不常用。参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="5c3aed10c6ed1ff4c98e713111fede52cc2146bd" translate="yes" xml:space="preserve">
          <source>This specification makes heavy use of the augmented BNF and generic
   constructs defined by David H. Crocker for &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Similarly, it
   reuses many of the definitions provided by Nathaniel Borenstein and
   Ned Freed for MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. We hope that their inclusion in this
   specification will help reduce past confusion over the relationship
   between HTTP and Internet mail message formats.

   The HTTP protocol has evolved considerably over the years. It has
   benefited from a large and active developer community--the many
   people who have participated on the www-talk mailing list--and it is
   that community which has been most responsible for the success of
   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert
   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois
   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob
   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc
   VanHeyningen deserve special recognition for their efforts in
   defining early aspects of the protocol.

   This document has benefited greatly from the comments of all those
   participating in the HTTP-WG. In addition to those already mentioned,
   the following individuals have contributed to this specification: 

       Gary Adams                  Ross Patterson
       Harald Tveit Alvestrand     Albert Lunde
       Keith Ball                  John C. Mallery
       Brian Behlendorf            Jean-Philippe Martin-Flatin
       Paul Burchard               Mitra
       Maurizio Codogno            David Morris
       Mike Cowlishaw              Gavin Nicol
       Roman Czyborra              Bill Perry
       Michael A. Dolan            Jeffrey Perry
       David J. Fiander            Scott Powers
       Alan Freier                 Owen Rees
       Marc Hedlund                Luigi Rizzo
       Greg Herlihy                David Robinson
       Koen Holtman                Marc Salomon
       Alex Hopmann                Rich Salz
       Bob Jernigan                Allan M. Schiffman
       Shel Kaphan                 Jim Seidman
       Rohit Khare                 Chuck Shotton
       John Klensin                Eric W. Sink
       Martijn Koster              Simon E. Spero
       Alexei Kosut                Richard N. Taylor
       David M. Kristol            Robert S. Thau
       Daniel LaLiberte            Bill (BearHeart) Weinman
       Ben Laurie                  Francois Yergeau
       Paul J. Leach               Mary Ellen Zurko
       Daniel DuBois               Josh Cohen


   Much of the content and presentation of the caching design is due to
   suggestions and comments from individuals including: Shel Kaphan,
   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.

   Most of the specification of ranges is based on work originally done
   by Ari Luotonen and John Franks, with additional input from Steve
   Zilles.

   Thanks to the &quot;cave men&quot; of Palo Alto. You know who you are.

   Jim Gettys (the current editor of this document) wishes particularly
   to thank Roy Fielding, the previous editor of this document, along
   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen
   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and
   Larry Masinter for their help. And thanks go particularly to Jeff
   Mogul and Scott Lawrence for performing the &quot;MUST/MAY/SHOULD&quot; audit. 

   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik
   Frystyk implemented &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; early, and we wish to thank them for the
   discovery of many of the problems that this document attempts to
   rectify.</source>
          <target state="translated">该规范大量使用了David H. Crocker为&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] 定义的增强BNF和通用结构。同样，它重用了Nathaniel Borenstein和Ned Freed为MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;提供的许多定义。]。我们希望将它们包含在本规范中将有助于减少过去对HTTP和Internet邮件格式之间关系的混淆。多年来，HTTP协议已经有了很大的发展。它受益于庞大而活跃的开发人员社区-许多人都参加了www-talk邮件列表-正是该社区对HTTP和Internet的成功与否负有最大责任。一般。 Marc Andreessen，Robert Cailliau，Daniel W.Connolly，Bob Denny，John Franks，Jean-Francois Groff，Phillip M.Hallam-Baker，Hakon W.Lie，Ari Luotonen，Rob McCool，Lou Montulli，Dave Raggett，Tony Sanders和马克&amp;middot;范海宁根（Marc VanHeyningen）在定义协议的早期方面所做的努力值得特别认可。所有参与HTTP-WG的人员的评论都使该文档受益匪浅。除已提及的人员外，以下人员还对此规范做出了贡献：加里&amp;middot;亚当斯&amp;middot;罗斯&amp;middot;帕特森&amp;middot;哈拉德&amp;middot;特维特&amp;middot;阿尔维斯特朗德&amp;middot;阿尔伯特&amp;middot;伦德&amp;middot;基思&amp;middot;鲍尔罗马Czyborra Bill Perry Michael A.Dolan Jeffrey Perry David J.Fiander Scott Powers Alan Freier Owen Rees Marc Hedlund Luigi Rizzo Greg Herlihy David Robinson Koen Holtman Marc Salomon Alex Hopmann Rich Salz Bob Jernigan Allan M.Schiffman Shel Kaphan Jim Seidman Rohit Khare Chuck Shotton John Klensin Eric W.Sink Martijn Koster Simon E.科索特&amp;middot;理查德&amp;middot;N&amp;middot;泰勒&amp;middot;大卫&amp;middot;克里斯托尔&amp;middot;罗伯特&amp;middot;S&amp;middot;休&amp;middot;丹尼尔&amp;middot;拉伯特&amp;middot;比尔（BearHeart）温曼&amp;middot;本&amp;middot;劳里&amp;middot;弗朗索瓦&amp;middot;叶尔盖&amp;middot;保罗&amp;middot;J。玛丽&amp;middot;艾伦&amp;middot;祖尔科（Mary Ellen Zurko）丹尼尔&amp;middot;杜波依斯（Joseph Cohen）缓存设计的大部分内容和演示都来自以下个人的建议和评论：谢尔&amp;middot;卡潘，保罗&amp;middot;利奇，科恩&amp;middot;霍尔特曼，戴维&amp;middot;莫里斯和拉里&amp;middot;马辛特。范围的大多数规范是基于Ari Luotonen和John Franks最初完成的工作，再加上Steve Zilles的投入。感谢帕洛阿尔托的&amp;ldquo;洞穴人&amp;rdquo;。你知道你是谁。 Jim Gettys（本文档的当前编辑）尤其要感谢本文档的前编辑Roy Fielding，以及John Klensin，Jeff Mogul，Paul Leach，Dave Kristol，Koen Holtman，John Franks，Josh Cohen，Alex Hopmann， Scott Lawrence和Larry Masinter的帮助。尤其要感谢Jeff Mogul和Scott Lawrence进行了&amp;ldquo;必须/要/应该&amp;rdquo;的审核。阿帕奇（Apache）小组的作者，拼图（Jigsaw）的作者安瑟姆&amp;middot;贝尔德&amp;middot;史密斯（Anselm Baird-Smith）和亨里克&amp;middot;弗里斯蒂克（Henrik Frystyk）&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;早期，我们希望感谢他们发现了本文档尝试纠正的许多问题。</target>
        </trans-unit>
        <trans-unit id="3fad4602c9c700895f3ed6117008bdc18c9fc181" translate="yes" xml:space="preserve">
          <source>This specification reserves the method name CONNECT for use with a
   proxy that can dynamically switch to being a tunnel (e.g. SSL
   tunneling [&lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt;]).</source>
          <target state="translated">该规范保留了方法名称CONNECT以便与可以动态切换为隧道（例如SSL隧道[ &lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt; ]）的代理一起使用。</target>
        </trans-unit>
        <trans-unit id="672729314726c61a4c205fd539620a1ce076c9fe" translate="yes" xml:space="preserve">
          <source>This specification takes over the definition of the HTTP
   Authentication Framework, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.  We thank
   John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D.
   Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for
   their work on that specification.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC2617]&lt;/a&gt; for
   further acknowledgements.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt; for the Acknowledgments related to this
   document revision.</source>
          <target state="translated">该规范接管了先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617中&lt;/a&gt;定义的HTTP身份验证框架的定义。感谢John Franks，Phillip M.Hallam-Baker，Jeffery L.Hostetler，Scott D.Lawrence，Paul J.Leach，Ari Luotonen和Lawrence C.Stewart在该规范上的工作。进一步的确认，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;[RFC2617]的第6节&lt;/a&gt;。有关与本文档修订版有关的确认，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;[RFC7230]的第10节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="199a33e3a0bbdd6ce39373b856043ea2c7f5f848" translate="yes" xml:space="preserve">
          <source>This specification targets conformance criteria according to the role
   of a participant in HTTP communication.  Hence, HTTP requirements are
   placed on senders, recipients, clients, servers, user agents,
   intermediaries, origin servers, proxies, gateways, or caches,
   depending on what behavior is being constrained by the requirement.
   Additional (social) requirements are placed on implementations,
   resource owners, and protocol element registrations when they apply
   beyond the scope of a single communication.

   The verb &quot;generate&quot; is used instead of &quot;send&quot; where a requirement
   differentiates between creating a protocol element and merely
   forwarding a received element downstream.

   An implementation is considered conformant if it complies with all of
   the requirements associated with the roles it partakes in HTTP.

   Conformance includes both the syntax and semantics of protocol
   elements.  A sender MUST NOT generate protocol elements that convey a
   meaning that is known by that sender to be false.  A sender MUST NOT
   generate protocol elements that do not match the grammar defined by
   the corresponding ABNF rules.  Within a given message, a sender MUST
   NOT generate protocol elements or syntax alternatives that are only
   allowed to be generated by participants in other roles (i.e., a role
   that the sender does not have for that message).

   When a received protocol element is parsed, the recipient MUST be
   able to parse any value of reasonable length that is applicable to
   the recipient's role and that matches the grammar defined by the
   corresponding ABNF rules.  Note, however, that some received protocol
   elements might not be parsed.  For example, an intermediary 

   forwarding a message might parse a header-field into generic
   field-name and field-value components, but then forward the header
   field without further parsing inside the field-value.

   HTTP does not have specific length limitations for many of its
   protocol elements because the lengths that might be appropriate will
   vary widely, depending on the deployment context and purpose of the
   implementation.  Hence, interoperability between senders and
   recipients depends on shared expectations regarding what is a
   reasonable length for each protocol element.  Furthermore, what is
   commonly understood to be a reasonable length for some protocol
   elements has changed over the course of the past two decades of HTTP
   use and is expected to continue changing in the future.

   At a minimum, a recipient MUST be able to parse and process protocol
   element lengths that are at least as long as the values that it
   generates for those same protocol elements in other messages.  For
   example, an origin server that publishes very long URI references to
   its own resources needs to be able to parse and process those same
   references when received as a request target.

   A recipient MUST interpret a received protocol element according to
   the semantics defined for it by this specification, including
   extensions to this specification, unless the recipient has determined
   (through experience or configuration) that the sender incorrectly
   implements what is implied by those semantics.  For example, an
   origin server might disregard the contents of a received
   Accept-Encoding header field if inspection of the User-Agent header
   field indicates a specific implementation version that is known to
   fail on receipt of certain content codings.

   Unless noted otherwise, a recipient MAY attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct
   impact on security, since different applications of the protocol
   require different error handling strategies.  For example, a Web
   browser might wish to transparently recover from a response where the
   Location header field doesn't parse according to the ABNF, whereas a
   systems control client might consider any form of error recovery to
   be dangerous.</source>
          <target state="translated">本规范根据HTTP通信中参与者的角色来确定一致性标准。因此,HTTP要求被放置在发送者、接收者、客户端、服务器、用户代理、中间人、源服务器、代理、网关或缓存上,这取决于要求所限制的行为。当额外的(社会)需求的适用范围超出单一通信的范围时,就会对实现、资源所有者和协议元素注册提出额外的要求。在需求区分创建协议元素和仅仅是将接收到的元素转发到下游时,用动词 &quot;生成 &quot;代替 &quot;发送&quot;。如果一个实现符合与它在HTTP中的角色相关的所有要求,那么它就被认为是符合性的。符合性包括协议元素的语法和语义。一个发送者决不能生成传达一个由发送者已知为假的意义的协议元素。发送者必须不产生不符合相应的ABNF规则所定义的语法的协议元素。在一个给定的消息中,发送者不得生成只允许由其他角色的参与者生成的协议元素或语法选择(即发送者对该消息不具有的角色)。当解析接收到的协议元素时,接收者必须能够解析任何合理长度的值,该值适用于接收者的角色,并与相应的ABNF规则定义的语法相匹配。但是,请注意,一些接收的协议元素可能不会被解析。例如,转发消息的中间人可能会将一个头字段解析成通用的字段名和字段值组件,但是在转发头字段时,不会在字段值内部进行进一步的解析。HTTP对许多协议元素没有特定的长度限制,因为根据部署环境和实现的目的,可能合适的长度会有很大的不同。因此,发送者和接收者之间的互操作性取决于对每个协议元素的合理长度的共同期望。此外,在过去20年的HTTP使用过程中,人们通常理解的一些协议元素的合理长度已经发生了变化,并且预计在未来会继续变化。至少,接收者必须能够解析和处理协议元素的长度,这些长度至少与它在其他消息中为这些相同的协议元素生成的值一样长。例如,一个发布了很长的URI引用到它自己的资源的源服务器需要能够在作为请求目标接收时解析和处理这些相同的引用。接收者必须根据本规范为其定义的语义来解释接收到的协议元素,包括本规范的扩展,除非接收者(通过经验或配置)确定发送者不正确地实现了这些语义所暗示的内容。例如,如果对User-Agent头域的检查表明了特定的实现版本,已知该版本在接收某些内容编码时失败,则源服务器可能会忽略接收到的Accept-Encoding头域的内容。除非另有说明,接收者可以尝试从无效的构造中恢复一个可用的协议元素。HTTP没有定义特定的错误处理机制,除非它们对安全有直接影响,因为协议的不同应用需要不同的错误处理策略。例如,Web浏览器可能希望透明地从一个Location头字段没有根据ABNF解析的响应中恢复,而系统控制客户端可能认为任何形式的错误恢复都是危险的。</target>
        </trans-unit>
        <trans-unit id="facba0308af11f7848962366e11eb270544c791e" translate="yes" xml:space="preserve">
          <source>This specification uses a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.

   connection
      A transport layer virtual circuit established between two programs
      for the purpose of communication.

   message
      The basic unit of HTTP communication, consisting of a structured
      sequence of octets matching the syntax defined in &lt;a href=&quot;#section-4&quot;&gt;section 4&lt;/a&gt; and
      transmitted via the connection.

   request
      An HTTP request message, as defined in &lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;.

   response
      An HTTP response message, as defined in &lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;. 

   resource
      A network data object or service that can be identified by a URI,
      as defined in &lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;. Resources may be available in multiple
      representations (e.g. multiple languages, data formats, size, and
      resolutions) or vary in other ways.

   entity
      The information transferred as the payload of a request or
      response. An entity consists of metainformation in the form of
      entity-header fields and content in the form of an entity-body, as
      described in &lt;a href=&quot;#section-7&quot;&gt;section 7&lt;/a&gt;.

   representation
      An entity included with a response that is subject to content
      negotiation, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. There may exist multiple
      representations associated with a particular response status.

   content negotiation
      The mechanism for selecting the appropriate representation when
      servicing a request, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. The
      representation of entities in any response can be negotiated
      (including error responses).

   variant
      A resource may have one, or more than one, representation(s)
      associated with it at any given instant. Each of these
      representations is termed a `varriant'.  Use of the term `variant'
      does not necessarily imply that the resource is subject to content
      negotiation.

   client
      A program that establishes connections for the purpose of sending
      requests.

   user agent
      The client which initiates a request. These are often browsers,
      editors, spiders (web-traversing robots), or other end user tools.

   server
      An application program that accepts connections in order to
      service requests by sending back responses. Any given program may
      be capable of being both a client and a server; our use of these
      terms refers only to the role being performed by the program for a
      particular connection, rather than to the program's capabilities
      in general. Likewise, any server may act as an origin server,
      proxy, gateway, or tunnel, switching behavior based on the nature
      of each request. 

   origin server
      The server on which a given resource resides or is to be created.

   proxy
      An intermediary program which acts as both a server and a client
      for the purpose of making requests on behalf of other clients.
      Requests are serviced internally or by passing them on, with
      possible translation, to other servers. A proxy MUST implement
      both the client and server requirements of this specification. A
      &quot;transparent proxy&quot; is a proxy that does not modify the request or
      response beyond what is required for proxy authentication and
      identification. A &quot;non-transparent proxy&quot; is a proxy that modifies
      the request or response in order to provide some added service to
      the user agent, such as group annotation services, media type
      transformation, protocol reduction, or anonymity filtering. Except
      where either transparent or non-transparent behavior is explicitly
      stated, the HTTP proxy requirements apply to both types of
      proxies.

   gateway
      A server which acts as an intermediary for some other server.
      Unlike a proxy, a gateway receives requests as if it were the
      origin server for the requested resource; the requesting client
      may not be aware that it is communicating with a gateway.

   tunnel
      An intermediary program which is acting as a blind relay between
      two connections. Once active, a tunnel is not considered a party
      to the HTTP communication, though the tunnel may have been
      initiated by an HTTP request. The tunnel ceases to exist when both
      ends of the relayed connections are closed.

   cache
      A program's local store of response messages and the subsystem
      that controls its message storage, retrieval, and deletion. A
      cache stores cacheable responses in order to reduce the response
      time and network bandwidth consumption on future, equivalent
      requests. Any client or server may include a cache, though a cache
      cannot be used by a server that is acting as a tunnel.

   cacheable
      A response is cacheable if a cache is allowed to store a copy of
      the response message for use in answering subsequent requests. The
      rules for determining the cacheability of HTTP responses are
      defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;. Even if a resource is cacheable, there may
      be additional constraints on whether a cache can use the cached
      copy for a particular request. 

   first-hand
      A response is first-hand if it comes directly and without
      unnecessary delay from the origin server, perhaps via one or more
      proxies. A response is also first-hand if its validity has just
      been checked directly with the origin server.

   explicit expiration time
      The time at which the origin server intends that an entity should
      no longer be returned by a cache without further validation.

   heuristic expiration time
      An expiration time assigned by a cache when no explicit expiration
      time is available.

   age
      The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.

   freshness lifetime
      The length of time between the generation of a response and its
      expiration time.

   fresh
      A response is fresh if its age has not yet exceeded its freshness
      lifetime.

   stale
      A response is stale if its age has passed its freshness lifetime.

   semantically transparent
      A cache behaves in a &quot;semantically transparent&quot; manner, with
      respect to a particular response, when its use affects neither the
      requesting client nor the origin server, except to improve
      performance. When a cache is semantically transparent, the client
      receives exactly the same response (except for hop-by-hop headers)
      that it would have received had its request been handled directly
      by the origin server.

   validator
      A protocol element (e.g., an entity tag or a Last-Modified time)
      that is used to find out whether a cache entry is an equivalent
      copy of an entity.

   upstream/downstream
      Upstream and downstream describe the flow of a message: all
      messages flow from upstream to downstream. 

   inbound/outbound
      Inbound and outbound refer to the request and response paths for
      messages: &quot;inbound&quot; means &quot;traveling toward the origin server&quot;,
      and &quot;outbound&quot; means &quot;traveling toward the user agent&quot;</source>
          <target state="translated">本规范使用许多术语来指代参与者在HTTP通信中扮演的角色和对象。连接在两个程序之间建立的传输层虚拟电路，用于通信。消息HTTP通信的基本单元，由与&lt;a href=&quot;#section-4&quot;&gt;第4节中&lt;/a&gt;定义的语法相匹配的结构化字节序列组成，并通过连接进行传输。 request HTTP请求消息，如&lt;a href=&quot;#section-5&quot;&gt;第5节中&lt;/a&gt;所定义。 response HTTP响应消息，如&lt;a href=&quot;#section-6&quot;&gt;第6节中&lt;/a&gt;所定义。资源（resource）可以由URI标识的网络数据对象或服务，如&lt;a href=&quot;#section-3.2&quot;&gt;3.2节中&lt;/a&gt;所定义。资源可能以多种表示形式（例如，多种语言，数据格式，大小和分辨率）可用或以其他方式变化。实体作为请求或响应的有效负载传输的信息。实体由实体标题字段形式的元信息和实体实体形式的内容组成，如&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;所述。表示（representation），包含在响应中的实体，要进行内容协商，如&lt;a href=&quot;#section-12&quot;&gt;第12节&lt;/a&gt;所述。可能存在与特定响应状态关联的多种表示形式。内容协商内容处理机制，用于在处理请求时选择适当的表示形式，如&lt;a href=&quot;#section-12&quot;&gt;第12节&lt;/a&gt;所述。实体在任何响应中的表示形式都可以协商（包括错误响应）。变体在任何给定瞬间，资源可能具有一个或多个与之关联的表示形式。这些表示中的每一个都称为&amp;ldquo; varriant&amp;rdquo;。使用术语&amp;ldquo;变体&amp;rdquo;并不一定意味着该资源需要进行内容协商。客户端（client）为发送请求而建立连接的程序。用户代理发起请求的客户端。这些通常是浏览器，编辑器，爬虫（网络遍历机器人）或其他最终用户工具。服务器（server）接受连接以便通过发送回响应来处理请求的应用程序。任何给定的程序都可能既是客户端又是服务器。我们对这些术语的使用仅指程序为特定连接执行的角色，而不是指程序的一般功能。同样，任何服务器都可以充当源服务器，代理，网关或隧道，并根据每个请求的性质进行切换。源服务器（origin server）特定资源所在或将要在其上创建的服务器。代理（proxy）一个中介程序，既充当服务器又充当客户端，以便代表其他客户端发出请求。请求可以在内部进行服务，也可以通过可能的转换将其传递给其他服务器。代理必须同时实现本规范的客户端和服务器要求。&amp;ldquo;透明代理&amp;rdquo;是不会修改请求或响应超出代理身份验证和标识所需的内容的代理。 &amp;ldquo;非透明代理&amp;rdquo;是一种修改请求或响应以便向用户代理提供一些附加服务的代理，例如组批注服务，媒体类型转换，协议减少或匿名过滤。除非明确声明透明或非透明行为，否则HTTP代理要求适用于两种类型的代理。网关充当其他服务器中介的服务器。与代理不同，网关接收请求时就好像它是所请求资源的原始服务器一样。请求客户端可能不知道它正在与网关通信。隧道（tunnel）一种中间程序，充当两个连接之间的盲中继。一旦激活，隧道就不会被认为是HTTP通信的一方，尽管该隧道可能是由HTTP请求发起的。当中继连接的两端都关闭时，隧道将不复存在。缓存（cache）程序在本地的响应消息存储，以及控制其消息存储，检索和删除的子系统。缓存存储可缓存的响应，以减少响应时间和未来等效请求的网络带宽消耗。任何客户端或服务器都可以包括缓存，尽管充当隧道的服务器无法使用缓存。可缓存的如果响应允许缓存存储响应消息的副本以用于响应后续请求，则响应是可缓存的。确定HTTP响应的可缓存性的规则在&lt;a href=&quot;#section-13&quot;&gt;第13条&lt;/a&gt;。即使资源是可缓存的，对于缓存是否可以针对特定请求使用缓存的副本，也可能存在其他限制。第一手响应如果响应是直接发生的，则可能是通过一个或多个代理从源服务器发出的，而没有不必要的延迟，则是第一手的。如果直接通过原始服务器检查了响应的有效性，则该响应也是第一手的。显式到期时间（explicit Expiration time）在没有进一步验证的情况下，原始服务器打算不再由缓存返回实体的时间。启发式到期时间当没有明确的到期时间可用时，由高速缓存分配的到期时间。年龄响应的年龄是指源服务器发送或成功验证其以来的时间。新鲜度有效期（freshiness life）响应的生成与其到期时间之间的时间长度。新鲜如果响应的年龄尚未超过其新鲜寿命，则它是新鲜的。如果响应的年龄已经过了新鲜度，那么响应就是陈旧的。语义透明高速缓存的使用既不影响请求的客户端也不影响原始服务器，除了提高性能外，对于特定的响应，它以&amp;ldquo;语义透明&amp;rdquo;的方式运行。如果缓存在语义上是透明的，则客户端将收到与原始服务器直接处理其请求时完全相同的响应（逐跳头除外）。验证器协议元素（例如，实体标签或上次修改时间），用于查找缓存条目是否是实体的等效副本。上游/下游上游和下游描述消息的流：所有消息从上游流向下游。入站/出站入站和出站是指消息的请求和响应路径：&amp;ldquo;入站&amp;rdquo;是指&amp;ldquo;向原始服务器移动&amp;rdquo;，&amp;ldquo;出站&amp;rdquo;是指&amp;ldquo;向用户代理移动&amp;rdquo;入站/出站入站和出站是指消息的请求和响应路径：&amp;ldquo;入站&amp;rdquo;是指&amp;ldquo;向原始服务器移动&amp;rdquo;，&amp;ldquo;出站&amp;rdquo;是指&amp;ldquo;向用户代理移动&amp;rdquo;入站/出站入站和出站是指消息的请求和响应路径：&amp;ldquo;入站&amp;rdquo;是指&amp;ldquo;向原始服务器移动&amp;rdquo;，&amp;ldquo;出站&amp;rdquo;是指&amp;ldquo;向用户代理移动&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="5366fbe830e07db7f7079781b54e53bea8e2feb6" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;,
   that allows for compact definition of comma-separated lists using a
   '#' operator (similar to how the '*' operator indicates repetition).
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; shows the collected grammar with all list operators
   expanded to standard ABNF notation.

   The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234], Appendix&amp;nbsp;B.1&lt;/a&gt;: ALPHA (letters), CR (carriage return), CRLF
   (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line
   feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any
   visible [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;] character).

   As a convention, ABNF rule names prefixed with &quot;obs-&quot; denote
   &quot;obsolete&quot; grammar rules that appear for historical reasons.</source>
          <target state="translated">本规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 的增强Backus-Naur格式（ABNF）表示法，具有在&lt;a href=&quot;#section-7&quot;&gt;第7节中&lt;/a&gt;定义的列表扩展名，该列表扩展名允许使用'＃'运算符来紧凑定义逗号分隔的列表（类似于'* '运算符表示重复）。 &lt;a href=&quot;#appendix-B&quot;&gt;附录B&lt;/a&gt;显示了收集的语法，所有列表运算符均扩展为标准ABNF表示法。以下核心规则作为参考包含在内，如&lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234]附录B.1中&lt;/a&gt;所定义。 ：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（控件），DIGIT（十进制0-9），DQUOTE（双引号），HEXDIG（十六进制0-9 / AF / af），HTAB （水平标签），LF（换行），OCTET（任何8位数据序列），SP（空格）和VCHAR（任何可见的[ &lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ]字符）。按照惯例，以&amp;ldquo; obs-&amp;rdquo;为前缀的ABNF规则名称表示出于历史原因而出现的&amp;ldquo;过时&amp;rdquo;语法规则。</target>
        </trans-unit>
        <trans-unit id="3f746953f3428a5eccba921f06abcdb82aa34c60" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">该规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 的增强Backus-Naur格式（ABNF）表示法和具有列表扩展名的扩展名，该扩展名在&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]的第7节中&lt;/a&gt;定义，允许使用'＃'运算符来紧凑定义逗号分隔的列表（类似于&amp;ldquo; *&amp;rdquo;运算符如何表示重复）。 &lt;a href=&quot;#appendix-B&quot;&gt;附录B&lt;/a&gt;描述了从其他文档导入的规则。 &lt;a href=&quot;#appendix-C&quot;&gt;附录C&lt;/a&gt;显示了收集的语法，所有列表运算符均扩展为标准ABNF表示法。</target>
        </trans-unit>
        <trans-unit id="faf3c32d78c2b6483745156433268b97ba91a18a" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">该规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 的增强Backus-Naur格式（ABNF）表示法和具有列表扩展名的扩展名，该扩展名在&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]的第7节中&lt;/a&gt;定义，允许使用'＃'运算符来紧凑定义逗号分隔的列表（类似于&amp;ldquo; *&amp;rdquo;运算符如何表示重复）。 &lt;a href=&quot;#appendix-C&quot;&gt;附录C&lt;/a&gt;描述了从其他文档导入的规则。 &lt;a href=&quot;#appendix-D&quot;&gt;附录D&lt;/a&gt;显示了收集的语法，所有列表运算符均扩展为标准ABNF表示法。</target>
        </trans-unit>
        <trans-unit id="ee23ef0e85f4f9cd9d0acebbd9b86ac08e046506" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation. 

   This specification uses the terms &quot;character&quot;, &quot;character encoding
   scheme&quot;, &quot;charset&quot;, and &quot;protocol element&quot; as they are defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].</source>
          <target state="translated">该规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 的增强Backus-Naur格式（ABNF）表示法和具有列表扩展名的扩展名，该扩展名在&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]的第7节中&lt;/a&gt;定义，允许使用'＃'运算符来紧凑定义逗号分隔的列表（类似于&amp;ldquo; *&amp;rdquo;运算符如何表示重复）。 &lt;a href=&quot;#appendix-C&quot;&gt;附录C&lt;/a&gt;描述了从其他文档导入的规则。 &lt;a href=&quot;#appendix-D&quot;&gt;附录D&lt;/a&gt;显示了收集的语法，所有列表运算符均扩展为标准ABNF表示法。本规范使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ] 中定义的术语&amp;ldquo;字符&amp;rdquo;，&amp;ldquo;字符编码方案&amp;rdquo;，&amp;ldquo;字符集&amp;rdquo;和&amp;ldquo;协议元素&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="98343664a6355afcb4ca38df251b44b6714d8a1e" translate="yes" xml:space="preserve">
          <source>This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS (&quot;bad&quot; whitespace).

   The OWS rule is used where zero or more linear whitespace octets
   might appear.  For protocol elements where optional whitespace is
   preferred to improve readability, a sender SHOULD generate the
   optional whitespace as a single SP; otherwise, a sender SHOULD NOT
   generate optional whitespace except as needed to white out invalid or
   unwanted protocol elements during in-place message filtering.

   The RWS rule is used when at least one linear whitespace octet is
   required to separate field tokens.  A sender SHOULD generate RWS as a
   single SP.

   The BWS rule is used where the grammar allows optional whitespace
   only for historical reasons.  A sender MUST NOT generate BWS in
   messages.  A recipient MUST parse for such bad whitespace and remove
   it before interpreting the protocol element. 

     OWS            = *( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; &quot;bad&quot; whitespace</source>
          <target state="translated">本规范使用三种规则来表示线性空白的使用。OWS(可选空白)、RWS(必需空白)和BWS(&quot;坏 &quot;空白)。OWS规则用于零或多个线性空白八位数可能出现的地方。对于为了提高可读性而选择可选的whitespace的协议元素,发送者应该将可选的whitespace作为一个SP生成;否则,发送者不应该生成可选的whitespace,除非在原地消息过滤过程中需要将无效的或不需要的协议元素删除。当至少需要一个线性whitespace八位组来分隔字段标记时,会使用RWS规则。发送者应该将RWS作为一个SP生成。BWS规则用于语法只允许出于历史原因而使用可选的空白的情况。发送者必须不在消息中生成BWS。接收者必须在解释协议元素之前,解析这种坏的whitespace并删除它。OWS=*(SP/HTAB );可选的whitespace RWS=1*(SP/HTAB );需要的whitespace BWS=OWS;&quot;坏 &quot;whitespace。</target>
        </trans-unit>
        <trans-unit id="aff04232d95d6c1171cd6ab1415e3e08026d9557" translate="yes" xml:space="preserve">
          <source>This specification uses two new media types that conform to the
   registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt;], a new message header that
   conforms to the registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;], and two
   new link relations that conform to the registry mechanism described
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].</source>
          <target state="translated">本说明书中使用了符合注册机制两个新的媒体类型中[描述&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt; ]，一个新的消息报头符合所述注册机制在[描述&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;符合注册表机构]，和两个新的链接关系，在[描述&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="230704ae6595086f8b4b75eab8034387112b13dd" translate="yes" xml:space="preserve">
          <source>This status can also send a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header, telling the requester when to check back to see if the functionality is supported by then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755885b5d7d7ceb53dac1ececfff6ea91ddc944f" translate="yes" xml:space="preserve">
          <source>This status code is primarily intended to be used with the &lt;a href=&quot;headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header, letting the user agent start &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content&quot;&gt;preloading&lt;/a&gt; resources while the server prepares a response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168a50454b53ca416e50a221ecab212a73004d2b" translate="yes" xml:space="preserve">
          <source>This status code is used in HTTP 1.1 only for Request-URIs, not URIs
   in other locations.</source>
          <target state="translated">这个状态码在HTTP 1.1中只用于Request-URI,不用于其他位置的URI。</target>
        </trans-unit>
        <trans-unit id="e6542819db91e2214f7b4c25edf572e8a36dacaa" translate="yes" xml:space="preserve">
          <source>This status is not generated by origin servers, but by intercepting proxies that control access to the network.</source>
          <target state="translated">这个状态不是由起源服务器产生的,而是由控制网络访问的拦截代理产生的。</target>
        </trans-unit>
        <trans-unit id="372dd7c8c17bd1505f433437b7bcad8e716c04b8" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">该状态与&lt;a href=&quot;../headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;标头一起发送，该标头包含有关如何正确授权的信息。</target>
        </trans-unit>
        <trans-unit id="a3cd34d9e9d7109fa13e3c0395c58eb46cc7b8a7" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">该状态与&lt;a href=&quot;../headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;标头一起发送，该标头包含有关如何正确授权的信息。</target>
        </trans-unit>
        <trans-unit id="8a9d71b9023a06f11edab66435c308dc6a0ee383" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;, but in this case, re-authenticating will make no difference. The access is permanently forbidden and tied to the application logic, such as insufficient rights to a resource.</source>
          <target state="translated">此状态类似于&lt;a href=&quot;401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt;，但是在这种情况下，重新认证不会有任何区别。永久禁止访问并将访问与应用程序逻辑绑定在一起，例如对资源的权限不足。</target>
        </trans-unit>
        <trans-unit id="a37c225e3a7cdee05e8c812d332fa6e17571a6c3" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;, but in this case, authentication is possible.</source>
          <target state="translated">此状态类似于&lt;a href=&quot;403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt;，但是在这种情况下，可以进行身份​​验证。</target>
        </trans-unit>
        <trans-unit id="d740e14cfb624c7102c236e54e55ea5db95b95e3" translate="yes" xml:space="preserve">
          <source>This technique does work for internal links, but try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request occurs). If you can avoid it by correcting internal links, you should fix those links instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be28e288a13627a68b1784eb600b0e65cfd5a0de" translate="yes" xml:space="preserve">
          <source>This technique has an additional benefit: updating two cached resources at the same time will not lead to the situation where the out-dated version of one resource is used in combination with the new version of the other one. This is very important when web sites have CSS stylesheets or JS scripts that have mutual dependencies, i.e., they depend on each other because they refer to the same HTML elements.</source>
          <target state="translated">这种技术还有一个好处:同时更新两个缓存资源,不会导致一个资源的过时版本与另一个资源的新版本结合使用的情况。当网站的CSS样式表或JS脚本具有相互依赖性时,这一点非常重要,即它们相互依赖,因为它们引用了相同的HTML元素。</target>
        </trans-unit>
        <trans-unit id="3aeab72cfc99a5f7f9ea4900285e4bd674414a02" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt;&lt;code&gt;network.http.accept.default&lt;/code&gt;&lt;/a&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">可以使用&lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt; &lt;code&gt;network.http.accept.default&lt;/code&gt; &lt;/a&gt;参数修改此值。&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;资源&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a0945e40dcef867b66faa0e27a1bd4227d6481c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l3779&quot;&gt;source&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7de26255283cc9167d1e4ab5cca6cdf380b11c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">可以使用 &lt;code&gt;image.http.accept&lt;/code&gt; 参数修改此值。&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;资源&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b50b2cc5848103a486b6389534eb105140db6ea" translate="yes" xml:space="preserve">
          <source>This will lead to a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="translated">这将导致客户端和服务器之间的简单交换,使用CORS头来处理权限。</target>
        </trans-unit>
        <trans-unit id="81a97739f75df445cadaa8f98d4fa5c5bdf3f859" translate="yes" xml:space="preserve">
          <source>This works roughly the same way as a client-initiated upgrade; an optional upgrade is requested by adding the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header to any message. A mandatory upgrade, though, works slightly differently, in that it requests the upgrade by replying to a message it receives with the &lt;a href=&quot;status/426&quot;&gt;&lt;code&gt;426&lt;/code&gt;&lt;/a&gt; status code, like this:</source>
          <target state="translated">这与客户端启动的升级大致相同。通过将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头添加到任何消息来请求可选升级。但是，强制升级的工作方式略有不同，因为它通过回复收到的带有&lt;a href=&quot;status/426&quot;&gt; &lt;code&gt;426&lt;/code&gt; &lt;/a&gt;状态代码的消息来请求升级，如下所示：</target>
        </trans-unit>
        <trans-unit id="fa3701a77f1cf83ff8e3fe524326c23f848bc1ab" translate="yes" xml:space="preserve">
          <source>This would allow CORS requests from Mozilla, Google, Microsoft, and Apple's domains.</source>
          <target state="translated">这将允许来自Mozilla、谷歌、微软和苹果的域名的CORS请求。</target>
        </trans-unit>
        <trans-unit id="a59129b8ca208dcde27e54fb7891ca5c8b965bb9" translate="yes" xml:space="preserve">
          <source>Though Feature Policy provides control of multiple features using a consistent syntax, the behavior of policy controlled features varies and depends on several factors.</source>
          <target state="translated">虽然特征策略使用一致的语法提供了对多个特征的控制,但策略控制的特征的行为是不同的,并取决于几个因素。</target>
        </trans-unit>
        <trans-unit id="35b0c32c11633fd5293f1721594a37c0441531d3" translate="yes" xml:space="preserve">
          <source>Though HTTP/2 adds some complexity, by embedding HTTP messages in frames to improve performance, the basic structure of messages has stayed the same since HTTP/1.0. Session flow remains simple, allowing it to be investigated, and debugged with a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP message monitor&lt;/a&gt;.</source>
          <target state="translated">尽管HTTP / 2增加了一些复杂性，但通过将HTTP消息嵌入帧中以提高性能，消息的基本结构自HTTP / 1.0起一直保持不变。会话流保持简单，可以对其进行调查，并使用简单的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP消息监视器进行&lt;/a&gt;调试。</target>
        </trans-unit>
        <trans-unit id="9a15157e510ae4fb6f9c552a8502c5d3c090f5d9" translate="yes" xml:space="preserve">
          <source>Though fixed in Firefox 69, previous 32-bit versions of Firefox running on 64-bit processors would report that the system is using a 32-bit CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1440c92eaa6c1b3552c42a43600691971d67871" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; is not supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6645a896cbe79649d39568f2032a9ab20c38bc" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">尽管&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;指令旨在替换不推荐使用的 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令，但大多数浏览器尚不支持&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;。因此，为了与当前浏览器兼容，同时在浏览器获得&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;支持时增加前向兼容性，可以同时指定 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 和&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="2d2996b4c0f8fba5d4ab332690b5f78e0e30f92d" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">尽管&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;指令旨在替换不推荐使用的 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令，但大多数浏览器尚不支持&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;。因此，为了与当前浏览器兼容，同时在浏览器获得&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;支持时增加前向兼容性，可以同时指定 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 和&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0c3769f4cf6b7264f228cc766b7de9065e61137e" translate="yes" xml:space="preserve">
          <source>Though there are legitimate uses of this header for selecting content, &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;it is considered bad practice&lt;/a&gt; to rely on it to define what features are supported by the user agent.</source>
          <target state="translated">尽管此标头用于选择内容有合法用途，&lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;但&lt;/a&gt;依靠它定义用户代理支持哪些功能被认为是一种不好的做法。</target>
        </trans-unit>
        <trans-unit id="b228606ae426f931604823fecbe96f6aa2850ab0" translate="yes" xml:space="preserve">
          <source>Threats</source>
          <target state="translated">Threats</target>
        </trans-unit>
        <trans-unit id="02283ca03b246291fac06381aab094d267592b90" translate="yes" xml:space="preserve">
          <source>Tighter Control Over Your Referrers &amp;ndash; Mozilla Security Blog</source>
          <target state="translated">严格控制引荐来源&amp;ndash; Mozilla安全博客</target>
        </trans-unit>
        <trans-unit id="7197d879754a435ef6abdac823a28530b7748197" translate="yes" xml:space="preserve">
          <source>Time based conditions</source>
          <target state="translated">基于时间的条件</target>
        </trans-unit>
        <trans-unit id="d21434199b502487596cffe0f83fce73f8fae46d" translate="yes" xml:space="preserve">
          <source>TimeOut = &quot;Timeout&quot; &quot;:&quot; 1#TimeType
      TimeType = (&quot;Second-&quot; DAVTimeOutVal | &quot;Infinite&quot;)
                 ; No LWS allowed within TimeType
      DAVTimeOutVal = 1*DIGIT

   Clients MAY include Timeout request headers in their LOCK requests.
   However, the server is not required to honor or even consider these
   requests.  Clients MUST NOT submit a Timeout request header with any
   method other than a LOCK method.

   The &quot;Second&quot; TimeType specifies the number of seconds that will
   elapse between granting of the lock at the server, and the automatic
   removal of the lock.  The timeout value for TimeType &quot;Second&quot; MUST
   NOT be greater than 2^32-1.

   See &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt; for a description of lock timeout behavior.</source>
          <target state="translated">TimeOut =&amp;ldquo; Timeout&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃TimeType TimeType =（&amp;ldquo; Second-&amp;rdquo; DAVTimeOutVal |&amp;ldquo; Infinite&amp;rdquo;）; TimeType DAVTimeOutVal = 1 * DIGIT内不允许的LWS客户端可以在其LOCK请求中包括超时请求标头。但是，不需要服务器满足或什至考虑这些请求。客户端不得使用LOCK方法以外的任何方法提交超时请求标头。 &amp;ldquo;第二&amp;rdquo; TimeType指定在服务器上授予锁与自动删除锁之间经过的秒数。 TimeType&amp;ldquo; Second&amp;rdquo;的超时值一定不能大于2 ^ 32-1。有关锁定超时行为的说明，请参见&lt;a href=&quot;#section-6.6&quot;&gt;第6.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bbd92323b129c3217bf6942ecefc96c45003532" translate="yes" xml:space="preserve">
          <source>Timing-Allow-Origin</source>
          <target state="translated">Timing-Allow-Origin</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="6916244a87f04cf740dd467f9478fda4624dfa30" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI
   of the Collection.

   Successful member creation is indicated with a 201 (&quot;Created&quot;)
   response code.  When the Collection responds with a status code of
   201, it SHOULD also return a response body, which MUST be an Atom
   Entry Document representing the newly created Resource.  Since the
   server is free to alter the POSTed Entry, for example, by changing
   the content of the atom:id element, returning the Entry can be useful
   to the client, enabling it to correlate the client and server views
   of the new Entry.

   When a Member Resource is created, its Member Entry URI MUST be
   returned in a Location header in the Collection's response. 

   If the creation request contained an Atom Entry Document, and the
   subsequent response from the server contains a Content-Location
   header that matches the Location header character-for-character, then
   the client is authorized to interpret the response entity as being a
   complete representation of the newly created Entry.  Without a
   matching Content-Location header, the client MUST NOT assume the
   returned entity is a complete representation of the created Resource.

   The request body sent with the POST need not be an Atom Entry.  For
   example, it might be a picture or a movie.  Collections MAY return a
   response with a status code of 415 (&quot;Unsupported Media Type&quot;) to
   indicate that the media type of the POSTed entity is not allowed or
   supported by the Collection.  For a discussion of the issues in
   creating such content, see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.</source>
          <target state="translated">要将成员添加到集合，客户端将POST请求发送到集合的URI。成功创建成员时将显示201（&amp;ldquo;已创建&amp;rdquo;）响应代码。当集合以状态码201响应时，它还应该返回一个响应主体，该主体必须是代表新创建的资源的Atom Entry文档。由于服务器可以自由地更改POSTed条目，例如，通过更改atom：id元素的内容，因此返回条目对客户端可能是有用的，从而使其能够关联新条目的客户端和服务器视图。创建成员资源后，其成员条目URI必须在集合响应的Location标头中返回。如果创建请求包含Atom进入文档，并且服务器的后续响应中包含一个Content-Location标头，该Content-Location标头与字符的Location标头匹配，然后授权客户端将响应实体解释为新创建的Entry的完整表示。如果没有匹配的Content-Location标头，则客户端不得假定返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见看到看到然后授权客户将响应实体解释为新创建条目的完整表示。如果没有匹配的Content-Location标头，则客户端不得假定返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见然后授权客户将响应实体解释为新创建条目的完整表示。如果没有匹配的Content-Location标头，则客户端不得假定返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见客户端不得假设返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见客户端不得假定返回的实体是所创建资源的完整表示。与POST一起发送的请求正文不必是Atom条目。例如，它可能是图片或电影。集合可以返回状态代码为415（&amp;ldquo;不支持的媒体类型&amp;rdquo;）的响应，以指示集合不允许或不支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见），以指示Collection不允许或支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见），以指示Collection不允许或支持POSTed实体的媒体类型。有关创建此类内容的问题的讨论，请参见&lt;a href=&quot;#section-9.6&quot;&gt;9.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="386b4890041dd717ecf8b7b91609bc0b0530ef7e" translate="yes" xml:space="preserve">
          <source>To additionally expose a custom header, like &lt;code&gt;X-Kuma-Revision&lt;/code&gt;, you can specify multiple headers separated by a comma:</source>
          <target state="translated">要另外公开自定义标头（如 &lt;code&gt;X-Kuma-Revision&lt;/code&gt; )，可以指定多个标头，并用逗号分隔：</target>
        </trans-unit>
        <trans-unit id="a180bdbe7008f814531ba52754a31bdde24cb15f" translate="yes" xml:space="preserve">
          <source>To allow &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; to see timing resources, you can specify:</source>
          <target state="translated">要允许 &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; 查看计时资源，可以指定：</target>
        </trans-unit>
        <trans-unit id="ac82a05a9215546227ac811284787b043b688757" translate="yes" xml:space="preserve">
          <source>To allow any resource to see timing resources:</source>
          <target state="translated">要允许任何资源看到定时资源。</target>
        </trans-unit>
        <trans-unit id="de9aa903d9e34061f0b89ba2ccd4efede6a71126" translate="yes" xml:space="preserve">
          <source>To allow any site to make CORS requests &lt;em&gt;without&lt;/em&gt; using the &lt;code&gt;*&lt;/code&gt; wildcard (for example, to enable credentials), your server must read the value of the request's &lt;code&gt;Origin&lt;/code&gt; header and use that value to set &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, and must also set a &lt;code&gt;Vary: Origin&lt;/code&gt; header to indicate that some headers are being set dynamically depending on the origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed12e1286c2fe40563eb11b075acdb101da5456e" translate="yes" xml:space="preserve">
          <source>To allow inline scripts and inline event handlers, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">为了允许内联脚本和内联事件处理程序，可以指定 &lt;code&gt;'unsafe-inline'&lt;/code&gt; ，与内联块匹配的nonce-source或hash-source。</target>
        </trans-unit>
        <trans-unit id="f0269ea1c1b256b968def48a5f2f52309ec5262a" translate="yes" xml:space="preserve">
          <source>To allow inline styles, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">要允许内联样式，可以指定 &lt;code&gt;'unsafe-inline'&lt;/code&gt; ，与内联块匹配的nonce-source或hash-source。</target>
        </trans-unit>
        <trans-unit id="13976356a231a259baf5887e2defcf39ece5cf88" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a directory or only certain pages, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf2613fc6493f70145cca53cbfd72435e9e8e80" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a folder or a subset of the pages only, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="translated">要将重定向仅应用于文件夹或页面的子集，请使用 &lt;code&gt;rewrite&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="bb7179c9bb0b7e4c55288f5bc188620cf66f5d11" translate="yes" xml:space="preserve">
          <source>To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. That is, the default allowlist is &lt;code&gt;'*'&lt;/code&gt; for each feature. Preventing the use of the sub-optimal functionality requires explicitly specifying a policy that disables the features.</source>
          <target state="translated">为避免破坏现有的Web内容，此类策略控制功能的默认设置是允许所有来源使用该功能。也就是说，每个功能的默认允许列表为 &lt;code&gt;'*'&lt;/code&gt; 。禁止使用次优功能需要明确指定禁用功能的策略。</target>
        </trans-unit>
        <trans-unit id="4241af7f93eeeca05ab65287e814f22f52b1e121" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary requests and duplicated cache entries, caching servers should use &lt;strong&gt;normalization &lt;/strong&gt;to pre-process the request and cache only files that are needed. For example, in the case of &lt;code&gt;Accept-Encoding&lt;/code&gt; you could check for &lt;code&gt;gzip&lt;/code&gt; and other compression types in the header before doing further processing, and otherwise unset the header. In &quot;pseudo code&quot; this might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa4823e36d63b17b94087b674887608e0551a24" translate="yes" xml:space="preserve">
          <source>To configure Apache to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header for all pages, add this to your site's configuration:</source>
          <target state="translated">要将Apache配置为发送所有页面的 &lt;code&gt;X-Frame-Options&lt;/code&gt; 标头，请将其添加到站点的配置中：</target>
        </trans-unit>
        <trans-unit id="ed88de8ec706b4b0a28b855a26786e3ee2a0c543" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; DENY, add this to your site's configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80d381b0c7feec0a158d29c3338a640577b5bd0" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; deny , add this to your site's configuration:</source>
          <target state="translated">要将Apache配置为设置 &lt;code&gt;X-Frame-Options&lt;/code&gt; deny，请将其添加到站点的配置中：</target>
        </trans-unit>
        <trans-unit id="b534ad3f3a442c64de937628acf24797af926fef" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; to &lt;code&gt;allow-from&lt;/code&gt; a specific Host , add this to your site's configuration:</source>
          <target state="translated">要将Apache配置 &lt;code&gt;allow-from&lt;/code&gt; 特定主机将 &lt;code&gt;X-Frame-Options&lt;/code&gt; 设置为allow，请将其添加到站点的配置中：</target>
        </trans-unit>
        <trans-unit id="c6efccd4af9ebeaf527c38eab55daa0481a50728" translate="yes" xml:space="preserve">
          <source>To configure Express to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, you can use &lt;a href=&quot;https://helmetjs.github.io/&quot;&gt;helmet&lt;/a&gt; which uses &lt;a href=&quot;https://helmetjs.github.io/docs/frameguard/&quot;&gt;frameguard&lt;/a&gt; to set the header. Add this to your server configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845c7d45d2e5670380ce094b42f8d93ca377f4d0" translate="yes" xml:space="preserve">
          <source>To configure HAProxy to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your front-end, listen, or backend configuration:</source>
          <target state="translated">要将HAProxy配置为发送 &lt;code&gt;X-Frame-Options&lt;/code&gt; 标头，请将其添加到前端，侦听或后端配置中：</target>
        </trans-unit>
        <trans-unit id="d8ead758c64a8732b962f9c079ccbcb8977cec05" translate="yes" xml:space="preserve">
          <source>To configure IIS to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your site's &lt;code&gt;Web.config&lt;/code&gt; file:</source>
          <target state="translated">要将IIS配置为发送 &lt;code&gt;X-Frame-Options&lt;/code&gt; 标头，请将其添加到站点的 &lt;code&gt;Web.config&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="40d91183fa2ac507cab6f74e7d193a9cc7597506" translate="yes" xml:space="preserve">
          <source>To configure nginx to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this either to your http, server or location configuration:</source>
          <target state="translated">要将nginx配置为发送 &lt;code&gt;X-Frame-Options&lt;/code&gt; 标头，请将其添加到http，服务器或位置配置中：</target>
        </trans-unit>
        <trans-unit id="f87ea35dcc44f41e60725e0641384c547d99d798" translate="yes" xml:space="preserve">
          <source>To correct this problem on the client side, simply ensure that the credentials flag's value is &lt;code&gt;false&lt;/code&gt; when issuing your CORS request.</source>
          <target state="translated">要在客户端纠正此问题，只需在发出CORS请求时确保凭据标志的值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d348d55722c44b500e4b7059e9ff9d2fa1dddb00" translate="yes" xml:space="preserve">
          <source>To delete a Member Resource, a client sends a DELETE request to its
   Member URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The deletion of a Media Link
   Entry SHOULD result in the deletion of the corresponding Media
   Resource.</source>
          <target state="translated">要删除成员资源，客户端将向其成员URI发送DELETE请求，如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中所指定。媒体链接条目的删除应该导致相应媒体资源的删除。</target>
        </trans-unit>
        <trans-unit id="72f4f993e89f8fbf65e0d29a84346e687a67b7ba" translate="yes" xml:space="preserve">
          <source>To disable caching of a resource, you can send the following response header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d139058a76ad3d2cff70e2b313580511ed4b4b" translate="yes" xml:space="preserve">
          <source>To disallow all plugins, the &lt;a href=&quot;object-src&quot;&gt;&lt;code&gt;object-src&lt;/code&gt;&lt;/a&gt; directive should be set to &lt;code&gt;'none'&lt;/code&gt; which will disallow plugins. The &lt;code&gt;plugin-types&lt;/code&gt; directive is only used if you are allowing plugins with &lt;code&gt;object-src&lt;/code&gt; at all.</source>
          <target state="translated">要禁止所有插件，应将&lt;a href=&quot;object-src&quot;&gt; &lt;code&gt;object-src&lt;/code&gt; &lt;/a&gt;指令设置为 &lt;code&gt;'none'&lt;/code&gt; ，这将禁止插件。该 &lt;code&gt;plugin-types&lt;/code&gt; ，如果您允许使用插件指令仅用于 &lt;code&gt;object-src&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="92b682f994622384b1029f2cc2b8c3099145173c" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &quot;https:&quot;. For example, to disallow insecure http images:</source>
          <target state="translated">要在更细的层面上禁止http资产,你也可以将单个指令设置为 &quot;https:&quot;。例如,要禁止不安全的http图片。</target>
        </trans-unit>
        <trans-unit id="a213397329a4dbbb753416e90e80c6286443a758" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &lt;code&gt;https:&lt;/code&gt;. For example, to disallow nonsecure HTTP images:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76414f91106f2a76e27289d53511ec4aff7ac9a8" translate="yes" xml:space="preserve">
          <source>To do this, HTTP uses a mechanism similar to the content negotiation for end-to-end compression: the node transmitting the request advertizes its will using the &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; header and the other node chooses the adequate method, applies it, and indicates its choice with the &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">为此，HTTP使用类似于内容协商的机制进行端到端压缩：传输请求的节点使用&lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;头广告其意愿，另一个节点选择适当的方法，应用该方法，并用的&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;报头。</target>
        </trans-unit>
        <trans-unit id="2695ec4a2bbfc44084d656ae8935110af8816675" translate="yes" xml:space="preserve">
          <source>To ease deployment, CSP can be deployed in report-only mode. The policy is not enforced, but any violations are reported to a provided URI. Additionally, a report-only header can be used to test a future revision to a policy without actually deploying it.</source>
          <target state="translated">为了便于部署,CSP可以在仅报告模式下部署。策略不会被强制执行,但任何违规行为都会被报告到提供的URI中。此外,只报告头可以用来测试未来对策略的修订,而无需实际部署。</target>
        </trans-unit>
        <trans-unit id="75b596875abd418e26e2741605ac5a556d421f5c" translate="yes" xml:space="preserve">
          <source>To edit a Member Resource, a client sends a PUT request to its Member
   URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   To avoid unintentional loss of data when editing Member Entries or
   Media Link Entries, an Atom Protocol client SHOULD preserve all
   metadata that has not been intentionally modified, including unknown
   foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">要编辑成员资源，客户端将PUT请求发送到其成员URI，如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中所指定。为了避免在编辑成员条目或媒体链接条目时意外丢失数据，Atom协议客户端应保留所有未经有意修改的元数据，包括&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]第6节中&lt;/a&gt;定义的未知外部标记。</target>
        </trans-unit>
        <trans-unit id="65a702b04aa6a54fd3c8430997ab1bc38d37ad8c" translate="yes" xml:space="preserve">
          <source>To eliminate this error by changing the server's configuration, adjust the server's configuration to set the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header's value to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">要通过更改服务器的配置来消除此错误，请调整服务器的配置以将 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 标头的值设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfa8844d0259c7d70df5b60e696f31e2bbcd03c1" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header (sometimes you will see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore).</source>
          <target state="translated">要启用CSP，您需要配置Web服务器以返回&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP标头（有时您会看到 &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; 标头的提法，但这是一个较旧的版本，不需要再指定一次）。</target>
        </trans-unit>
        <trans-unit id="19b1b9201d67c0e13d81834b3ed7b51ae71bba12" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header. (Sometimes you may see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9df87dcc5fcb972c46f913809c87fec6f3d341b" translate="yes" xml:space="preserve">
          <source>To enable this feature for your site, you need to return the &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; HTTP header when your site is accessed over HTTPS:</source>
          <target state="translated">要为您的站点启用此功能，当通过HTTPS访问站点时，您需要返回&lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; HTTP标头：</target>
        </trans-unit>
        <trans-unit id="d7620e1e33a6d347685e1ebb3aa8b33714970a09" translate="yes" xml:space="preserve">
          <source>To ensure the authenticity of a server's public key used in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; sessions, this public key is wrapped into a X.509 certificate which is usually signed by a certificate authority (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;). Web clients such as browsers trust a lot of these CAs, which can all create certificates for arbitrary domain names. If an attacker is able to compromise a single CA, they can perform MITM attacks on various TLS connections. HPKP can circumvent this threat for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; protocol by telling the client which public key belongs to a certain web server.</source>
          <target state="translated">为了确保&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;会话中使用的服务器公钥的真实性，此公钥被包装到X.509证书中，该证书通常由证书颁发机构（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;）签名。浏览器之类的Web客户端信任许多这样的CA，它们都可以为任意域名创建证书。如果攻击者能够入侵单个CA，则他们可以对各种TLS连接执行MITM攻击。 HPKP可以通过告诉客户端哪个公钥属于某个Web服务器来规避&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;协议的这种威胁。</target>
        </trans-unit>
        <trans-unit id="bb1ec08765a8cde8081dbd27d2c650bba3f705fa" translate="yes" xml:space="preserve">
          <source>To expose a non-CORS-safelisted request header, you can specify:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9c68887239fed95f26110a7e627ff78bd12cc1" translate="yes" xml:space="preserve">
          <source>To expose a non-simple response header, you can specify:</source>
          <target state="translated">要暴露一个非简单的响应头,你可以指定。</target>
        </trans-unit>
        <trans-unit id="c49b225b0a37fb347c33ef070bf2b8ce3177f370" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;) response headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0114a346ce11f11d1f933758ffbbdf2f5442cd43" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for CORS) response headers.</source>
          <target state="translated">要确定服务器是否支持 &lt;code&gt;PATCH&lt;/code&gt; ，服务器可以通过将其添加到&lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;（对于CORS）响应标头中的列表中来通告其支持。</target>
        </trans-unit>
        <trans-unit id="f3e43c65e3e2914cd34ba18edec78bc17058b478" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use curl and issue an OPTIONS request:</source>
          <target state="translated">要想知道服务器支持哪些请求方式,可以使用curl并发出options请求。</target>
        </trans-unit>
        <trans-unit id="94a06678a04eb20207fc7bb6378a7dadaf3ba84d" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use the &lt;code&gt;curl&lt;/code&gt; command-line program to issue an &lt;code&gt;OPTIONS&lt;/code&gt; request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e18f6487121f857662c6a85c3a47051c59f1876" translate="yes" xml:space="preserve">
          <source>To fix the problem, update your code to use the new URL as reported by the redirect, thereby avoiding the redirect.</source>
          <target state="translated">要解决这个问题,请更新您的代码,使用重定向报告的新URL,从而避免重定向。</target>
        </trans-unit>
        <trans-unit id="32dbd3b679bd14efe132327b76684a2c87a18ba4" translate="yes" xml:space="preserve">
          <source>To fix this problem on the client side, revise the code to not request the use of credentials.</source>
          <target state="translated">为了解决客户端的这个问题,修改代码,不要求使用凭证。</target>
        </trans-unit>
        <trans-unit id="35039835a23cd330912a1e328fb92250be4508c7" translate="yes" xml:space="preserve">
          <source>To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIs, Web Fonts (&lt;code&gt;@font-face&lt;/code&gt;), and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL&quot;&gt;WebGL textures&lt;/a&gt;, and XSL stylesheets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2617321bfe1280098dd397ad19ede4778814a0fc" translate="yes" xml:space="preserve">
          <source>To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS.</source>
          <target state="translated">要解决这个问题,只需确保在发出涉及CORS的请求时使用HTTPS URL即可。</target>
        </trans-unit>
        <trans-unit id="15680ede5ec99b5956f1bf553d855c87853f86ba" translate="yes" xml:space="preserve">
          <source>To have a server check the request's headers, a client must send &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: 100-continue&lt;/code&gt; as a header in its initial request and receive a &lt;code&gt;100 Continue&lt;/code&gt; status code in response before sending the body.</source>
          <target state="translated">要让服务器检查请求的标头，客户端必须在其初始请求中发送&lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: 100-continue&lt;/code&gt; 作为标头，并在发送正文之前收到 &lt;code&gt;100 Continue&lt;/code&gt; 状态码作为响应。</target>
        </trans-unit>
        <trans-unit id="a8e97e24a55d2464483db3779fca7d3ac69353bb" translate="yes" xml:space="preserve">
          <source>To list the Members of a Collection, the client sends a GET request
   to the URI of a Collection.  An Atom Feed Document is returned whose
   Entries contain the IRIs of Member Resources.  The returned Feed may
   describe all, or only a partial list, of the Members in a Collection
   (see &lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;).

   Client                          Server
     |                                |
     |  1.) GET to Collection URI     |
     |-------------------------------&amp;gt;|
     |                                |
     |  2.) 200 Ok                    |
     |      Atom Feed Document        |
     |&amp;lt;-------------------------------|
     |                                |

   1.  The client sends a GET request to the URI of the Collection.

   2.  The server responds with an Atom Feed Document containing the
       IRIs of the Collection Members.</source>
          <target state="translated">要列出集合的成员，客户端将GET请求发送到集合的URI。返回一个Atom Feed文档，其条目包含成员资源的IRI。返回的Feed可能会描述集合中所有或部分成员列表（请参阅&lt;a href=&quot;#section-10&quot;&gt;第10节）&lt;/a&gt;）。客户端服务器| | | 1.）GET to Collection URI | | -------------------------------&amp;gt; | | | | 2.）200好| | Atom Feed文档| | &amp;lt;------------------------------- | | | 1.客户端将GET请求发送到集合的URI。2.服务器以Atom Feed文档作为响应，其中包含Collection成员的IRI。</target>
        </trans-unit>
        <trans-unit id="40d4be7657f2f51d2de5be0cbaac7191b3c8a653" translate="yes" xml:space="preserve">
          <source>To load an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; you must specify &lt;code&gt;application/x-java-applet&lt;/code&gt;:</source>
          <target state="translated">要加载&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;，必须指定 &lt;code&gt;application/x-java-applet&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8d201d9342cffef73d7a41bc9cba81a23914667e" translate="yes" xml:space="preserve">
          <source>To password-protect a directory on an Apache server, you will need a &lt;code&gt;.htaccess&lt;/code&gt; and a &lt;code&gt;.htpasswd&lt;/code&gt; file.</source>
          <target state="translated">要用密码保护Apache服务器上的目录，您将需要一个 &lt;code&gt;.htaccess&lt;/code&gt; 文件和一个 &lt;code&gt;.htpasswd&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="2b1b9e12e5ed28875fdd87d9931a916a268928e4" translate="yes" xml:space="preserve">
          <source>To present a Web page, the browser sends an original request to fetch the HTML document from the page. It then parses this file, fetching additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</source>
          <target state="translated">为了呈现一个网页,浏览器会发送一个原始请求,从网页中获取HTML文件。然后,它对这个文件进行解析,获取与执行脚本、要显示的布局信息(CSS)以及页面中包含的子资源(通常是图片和视频)相对应的附加请求。然后,Web浏览器将这些资源混合在一起,向用户呈现一个完整的文档,即网页。浏览器执行的脚本可以在后期获取更多的资源,浏览器也会相应地更新网页。</target>
        </trans-unit>
        <trans-unit id="9e60dfe4ac6141599165a832cd24e1d13bc8342c" translate="yes" xml:space="preserve">
          <source>To present a Web page, the browser sends an original request to fetch the HTML document that represents the page. It then parses this file, making additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc3791377cf289d3e10d82216c0c34f70d22305" translate="yes" xml:space="preserve">
          <source>To prevent cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks, &lt;code&gt;HttpOnly&lt;/code&gt; cookies are inaccessible to JavaScript's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; API; they are only sent to the server. For example, cookies that persist server-side sessions don't need to be available to JavaScript, and the &lt;code&gt;HttpOnly&lt;/code&gt; flag should be set.</source>
          <target state="translated">为了防止跨站点脚本（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）攻击，JavaScript的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; API 无法访问 &lt;code&gt;HttpOnly&lt;/code&gt; cookie ；它们仅发送到服务器。例如，持久化服务器端会话的cookie不需要对JavaScript可用，并且应该设置 &lt;code&gt;HttpOnly&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="72ede2114830d9b5c365d2af6457cc4237ba98cd" translate="yes" xml:space="preserve">
          <source>To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation on the server side, allowing a document to become a patchwork of information sourced from different domains; there could even be security-related reasons to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da58d84bcbf609daa347015eaf4c1596d9aec024" translate="yes" xml:space="preserve">
          <source>To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation server-side, allowing a document to become a patchwork of information sourced from different domains (there could even be security-related reasons to do so).</source>
          <target state="translated">为了防止监听和其他隐私入侵，Web浏览器在网站之间强制严格隔离。只有具有&lt;strong&gt;相同来源的&lt;/strong&gt;页面才能访问网页的所有信息。尽管这种约束是服务器的负担，但是HTTP标头可以放松服务器端的严格分隔，使文档成为来自不同域的信息的拼凑而成（这样做甚至可能与安全性相关）。</target>
        </trans-unit>
        <trans-unit id="6fdb9fa15e3fd167189ceff75fae693acf53ca4b" translate="yes" xml:space="preserve">
          <source>To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</source>
          <target state="translated">为防止这种情况，将使用条件请求。对于范围，有两种方法可以执行此操作。一种更灵活的方法是使用&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;，如果前提条件失败，服务器将返回错误；否则，服务器将返回错误。然后客户端从头开始重新下载：</target>
        </trans-unit>
        <trans-unit id="51d6446ef1d59700324bbaf38bfb84d4a066a702" translate="yes" xml:space="preserve">
          <source>To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae0931ca2f4a9bdada593d70fdcc9e0e5795272" translate="yes" xml:space="preserve">
          <source>To provide information about the proxy itself (not about the client connecting to it), the &lt;code&gt;Via&lt;/code&gt; header can be used.</source>
          <target state="translated">要提供有关代理本身的信息（而不是有关连接到它的客户端的信息），可以使用 &lt;code&gt;Via&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="39f35e596ed723bf2514b5c1b49a714286137491" translate="yes" xml:space="preserve">
          <source>To request a mandatory upgrade to TLS&amp;mdash;that is, to upgrade and fail the connection if the upgrade is not successful&amp;mdash;your first request must be an &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request, like this:</source>
          <target state="translated">要请求强制升级到TLS（即，如果升级不成功，则升级并导致连接失败），您的第一个请求必须是&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;请求，例如：</target>
        </trans-unit>
        <trans-unit id="0ac4a6a255bea42439869af2e4020d47f12f5638" translate="yes" xml:space="preserve">
          <source>To see stored cookies (and other storage that a web page can use), you can enable the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&quot;&gt;Storage Inspector&lt;/a&gt; in Developer Tools and select Cookies from the storage tree.</source>
          <target state="translated">要查看存储的cookie（以及网页可以使用的其他存储），可以在Developer Tools中启用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&quot;&gt;Storage Inspector&lt;/a&gt;，然后从存储树中选择Cookies。</target>
        </trans-unit>
        <trans-unit id="bc330ab165d9d2700ffdde233d29f19baad1a79d" translate="yes" xml:space="preserve">
          <source>To select the algorithm to use, browsers and servers use &lt;a href=&quot;content_negotiation&quot;&gt;proactive content negotiation&lt;/a&gt;. The browser sends an &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header with the algorithm it supports and its order of precedence, the server picks one, uses it to compress the body of the response and uses the &lt;a href=&quot;headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; header to tell the browser the algorithm it has chosen. As content negotiation has been used to choose a representation based on its encoding, the server must send a &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header containing at least &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; alongside this header in the response; that way, caches will be able to cache the different representations of the resource.</source>
          <target state="translated">为了选择要使用的算法，浏览器和服务器使用&lt;a href=&quot;content_negotiation&quot;&gt;主动内容协商&lt;/a&gt;。浏览器发送带有其支持的算法及其优先级顺序的&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;标头，服务器选择一个，使用它压缩响应的正文，并使用&lt;a href=&quot;headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;标头将其选择的算法告诉浏览器。由于已经使用内容协商来选择基于其编码的表示形式，因此服务器必须在响应中在该标头旁边发送至少包含&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;标头；这样，缓存将能够缓存资源的不同表示形式。</target>
        </trans-unit>
        <trans-unit id="634a9fb6a29c3c70ac67df06d1d205bf0ae96039" translate="yes" xml:space="preserve">
          <source>To set allowed types for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, use the &lt;a href=&quot;plugin-types&quot;&gt;&lt;code&gt;plugin-types&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">要为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素设置允许的类型，请使用&lt;a href=&quot;plugin-types&quot;&gt; &lt;code&gt;plugin-types&lt;/code&gt; &lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="1df8505922402bf519c64877c4fe5b468a0d15a0" translate="yes" xml:space="preserve">
          <source>To turn off caching, you can send the following response header. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Pragma&lt;/code&gt; headers.</source>
          <target state="translated">要关闭缓存，您可以发送以下响应头。此外，另请参见 &lt;code&gt;Expires&lt;/code&gt; 和 &lt;code&gt;Pragma&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="dd73224596457324eeb7f6a3787968a990efcb06" translate="yes" xml:space="preserve">
          <source>To turn on the enforcement of all the best practices, specify the policy as below.</source>
          <target state="translated">要开启所有最佳做法的执行,请指定以下政策。</target>
        </trans-unit>
        <trans-unit id="e986abf32e5ea3dcadc05857dd5f7dc3d3e31912" translate="yes" xml:space="preserve">
          <source>To understand the underlying issue with the CORS configuration, you need to find out which request is at fault and why. These steps may help you do so:</source>
          <target state="translated">要了解CORS配置的根本问题,您需要找出哪个请求出了问题以及原因。这些步骤可能会帮助你做到这一点。</target>
        </trans-unit>
        <trans-unit id="a5de27ea55a3c3a2648dd523ae819b4dad29f351" translate="yes" xml:space="preserve">
          <source>To upgrade to TLS optionally (that is, allowing the connection to continue in cleartext if the upgrade to TLS fails), you simply use the &lt;code&gt;Upgrade&lt;/code&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers as expected. For example, given the original request:</source>
          <target state="translated">要可选地升级到TLS（即，如果升级到TLS失败，则允许连接以明文形式继续），您只需按预期使用 &lt;code&gt;Upgrade&lt;/code&gt; 和&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头。例如，给定原始请求：</target>
        </trans-unit>
        <trans-unit id="044deb9959ba1185df13d8adce29060324260efa" translate="yes" xml:space="preserve">
          <source>Today, every HTTP/1.1-compliant proxy and server should support pipelining, though many have limitations in practice: a significant reason no modern browser activates this feature by default.</source>
          <target state="translated">今天,每个符合HTTP/1.1标准的代理和服务器都应该支持管道化,尽管许多代理和服务器在实践中都有局限性:一个重要的原因是没有现代浏览器默认激活这个功能。</target>
        </trans-unit>
        <trans-unit id="33aad73dfe686c313271fd5a3616235aaa85ae94" translate="yes" xml:space="preserve">
          <source>Together with the resource, the validators are sent in the headers. In this example, both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; are sent, but it could equally have been only one of them. These validators are cached with the resource (like all headers) and will be used to craft conditional requests, once the cache becomes stale.</source>
          <target state="translated">验证器与资源一起在标头中发送。在此示例中，&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;均被发送，但同样可能只是其中之一。这些验证器与资源一起缓存（就像所有标头一样），并且一旦缓存失效，就将用于生成条件请求。</target>
        </trans-unit>
        <trans-unit id="0525ab49d332c5db40375b0a9f6ea89615d60e2c" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; resources</source>
          <target state="translated">工具与资源</target>
        </trans-unit>
        <trans-unit id="b9ddad26522153eb9872297e87c93c799247f043" translate="yes" xml:space="preserve">
          <source>Tools to check your cache-related headers</source>
          <target state="translated">检查缓存相关头文件的工具</target>
        </trans-unit>
        <trans-unit id="7b5272923a452bc32a23884c3fe28dc343ef4efe" translate="yes" xml:space="preserve">
          <source>Top-level navigation blocked to data:// URIs</source>
          <target state="translated">顶层导航被屏蔽为data://URIs。</target>
        </trans-unit>
        <trans-unit id="e81a151bd05091f9935dc3aba219eed346e7bb4f" translate="yes" xml:space="preserve">
          <source>Tracking</source>
          <target state="translated">Tracking</target>
        </trans-unit>
        <trans-unit id="5dcb619778c5a48fbe9ce0ea8e4e07da0e9aea7d" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression</source>
          <target state="translated">追踪偏好表达</target>
        </trans-unit>
        <trans-unit id="2af5d6ecb9eb76a6bccbc8c68b541e6b6b396809" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression (DNT)&lt;br/&gt;&lt;small&gt;The definition of 'DNT Header Field for HTTP Requests' in that specification.&lt;/small&gt;</source>
          <target state="translated">跟踪首选项表达式（DNT）&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo; HTTP请求的DNT标头字段&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="84aa830d1d5897f6ae5f7fca1156da8d8706f8cb" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression (DNT)&lt;br/&gt;&lt;small&gt;The definition of 'Tk header field' in that specification.&lt;/small&gt;</source>
          <target state="translated">跟踪首选项表达式（DNT）&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo; Tk标头字段&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d37a3197e485b933cb995fe9c9d3f25f9de908c0" translate="yes" xml:space="preserve">
          <source>Tracking and privacy</source>
          <target state="translated">追踪和隐私</target>
        </trans-unit>
        <trans-unit id="8e5bd5bfa384bf004de3147d61aadd3993d2c684" translate="yes" xml:space="preserve">
          <source>Tracking with consent. The origin server believes it has received prior consent for tracking this user, user agent, or device.</source>
          <target state="translated">经同意的跟踪。源服务器认为它已经收到了跟踪该用户、用户代理或设备的事先同意。</target>
        </trans-unit>
        <trans-unit id="a58efd8405db46a290d75d073d8104640ac8bf79" translate="yes" xml:space="preserve">
          <source>Tracking.</source>
          <target state="translated">Tracking.</target>
        </trans-unit>
        <trans-unit id="26013bccba39d56f3505ecd08b5aabdc74ef7701" translate="yes" xml:space="preserve">
          <source>Trailer</source>
          <target state="translated">Trailer</target>
        </trans-unit>
        <trans-unit id="2f8c965a489badb0e16d07f424592d1f9df923ab" translate="yes" xml:space="preserve">
          <source>Trailer (RFC 2616)</source>
          <target state="translated">拖车(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="77a56b4b0d25c8ae802cf40ac536850a7797b43e" translate="yes" xml:space="preserve">
          <source>Transfer Codings (RFC 7230)</source>
          <target state="translated">传输编码(RFC 7230)</target>
        </trans-unit>
        <trans-unit id="70841a225420fbcb24be7613367795a906d292c9" translate="yes" xml:space="preserve">
          <source>Transfer coding</source>
          <target state="translated">转移编码</target>
        </trans-unit>
        <trans-unit id="7ebdaa3f3a4520281b97e02b5d2f54005ba580f8" translate="yes" xml:space="preserve">
          <source>Transfer coding names are used to indicate an encoding transformation
   that has been, can be, or might need to be applied to a payload body
   in order to ensure &quot;safe transport&quot; through the network.  This
   differs from a content coding in that the transfer coding is a
   property of the message rather than a property of the representation
   that is being transferred.

     transfer-coding    = &quot;chunked&quot; ; &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;
                        / &quot;compress&quot; ; &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;
                        / &quot;deflate&quot; ; &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;
                        / &quot;gzip&quot; ; &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;
                        / transfer-extension
     transfer-extension = token *( OWS &quot;;&quot; OWS transfer-parameter )

   Parameters are in the form of a name or name=value pair.

     transfer-parameter = token BWS &quot;=&quot; BWS ( token / quoted-string )

   All transfer-coding names are case-insensitive and ought to be
   registered within the HTTP Transfer Coding registry, as defined in
   &lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;.  They are used in the TE (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and
   Transfer-Encoding (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;) header fields.</source>
          <target state="translated">传输编码名称用于指示已经，可能或需要应用于有效载荷主体的编码转换，以确保通过网络的&amp;ldquo;安全传输&amp;rdquo;。这与内容编码的不同之处在于，传输编码是消息的属性，而不是正在传输的表示的属性。 transfer-coding =&amp;ldquo;块&amp;rdquo;; &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; /&amp;ldquo;压缩&amp;rdquo;；&lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; /&amp;ldquo;放气&amp;rdquo;；&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt; /&amp;ldquo; gzip&amp;rdquo;；&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; / transfer-extension transfer-extension =标记*（OWS&amp;ldquo;;&amp;rdquo; OWS transfer-parameter）参数采用名称或名称=值对的形式。 transfer-parameter = token BWS&amp;ldquo; =&amp;rdquo; BWS（token / quoted-string）所有传输编码名称均不区分大小写，并应在&lt;a href=&quot;#section-8.4&quot;&gt;8.4节中&lt;/a&gt;定义的HTTP Transfer Coding注册表中进行注册 。它们在TE（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）和Transfer-Encoding（&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节&lt;/a&gt;）头字段中使用。</target>
        </trans-unit>
        <trans-unit id="4d8b97a685db2fa279df1bb0d54e0fdc0c9f8bb5" translate="yes" xml:space="preserve">
          <source>Transfer-Encoding</source>
          <target state="translated">Transfer-Encoding</target>
        </trans-unit>
        <trans-unit id="4626d4537fdc031b31ab03445f507eb645f0b745" translate="yes" xml:space="preserve">
          <source>Transfer-Encoding (RFC 2616)</source>
          <target state="translated">传输编码(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="af30d73f2f27d92a78211f034fdce80b11f12b01" translate="yes" xml:space="preserve">
          <source>Transfer-coding values are used to indicate an encoding
   transformation that has been, can be, or may need to be applied to an
   entity-body in order to ensure &quot;safe transport&quot; through the network.
   This differs from a content coding in that the transfer-coding is a
   property of the message, not of the original entity.

       transfer-coding         = &quot;chunked&quot; | transfer-extension
       transfer-extension      = token *( &quot;;&quot; parameter )

   Parameters are in  the form of attribute/value pairs.

       parameter               = attribute &quot;=&quot; value
       attribute               = token
       value                   = token | quoted-string

   All transfer-coding values are case-insensitive. HTTP/1.1 uses
   transfer-coding values in the TE header field (&lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;) and in
   the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;).

   Whenever a transfer-coding is applied to a message-body, the set of
   transfer-codings MUST include &quot;chunked&quot;, unless the message is
   terminated by closing the connection. When the &quot;chunked&quot; transfer-
   coding is used, it MUST be the last transfer-coding applied to the
   message-body. The &quot;chunked&quot; transfer-coding MUST NOT be applied more
   than once to a message-body. These rules allow the recipient to
   determine the transfer-length of the message (&lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;).

   Transfer-codings are analogous to the Content-Transfer-Encoding
   values of MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;], which were designed to enable safe transport of
   binary data over a 7-bit transport service. However, safe transport
   has a different focus for an 8bit-clean transfer protocol. In HTTP,
   the only unsafe characteristic of message-bodies is the difficulty in
   determining the exact body length (&lt;a href=&quot;#section-7.2.2&quot;&gt;section 7.2.2&lt;/a&gt;), or the desire to
   encrypt data over a shared transport. 

   The Internet Assigned Numbers Authority (IANA) acts as a registry for
   transfer-coding value tokens. Initially, the registry contains the
   following tokens: &quot;chunked&quot; (&lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;), &quot;identity&quot; (&lt;a href=&quot;#section-3.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6.2&quot;&gt;3.6.2&lt;/a&gt;), &quot;gzip&quot; (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;), &quot;compress&quot; (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;), and &quot;deflate&quot;
   (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;).

   New transfer-coding value tokens SHOULD be registered in the same way
   as new content-coding value tokens (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;).

   A server which receives an entity-body with a transfer-coding it does
   not understand SHOULD return 501 (Unimplemented), and close the
   connection. A server MUST NOT send transfer-codings to an HTTP/1.0
   client.</source>
          <target state="translated">传输编码值用于指示已经，可以或可能需要应用于实体的编码转换，以确保通过网络的&amp;ldquo;安全传输&amp;rdquo;。这与内容编码的不同之处在于，传输编码是消息的属性，而不是原始实体的属性。 transfer-coding =&amp;ldquo;块&amp;rdquo; | transfer-extension transfer-extension =标记*（&amp;ldquo;;&amp;rdquo; parameter）参数采用属性/值对的形式。参数=属性&amp;ldquo; =&amp;rdquo;值属性=令牌值=令牌| quoted-string所有传输编码值都不区分大小写。 HTTP / 1.1在TE标头字段中使用传输编码值（&lt;a href=&quot;#section-14.39&quot;&gt;第14.39节）&lt;/a&gt;）和&amp;ldquo;传输编码标头&amp;rdquo;字段中（&lt;a href=&quot;#section-14.41&quot;&gt;第14.41节&lt;/a&gt;）。每当将传输编码应用于消息主体时，除非通过关闭连接来终止消息，否则传输编码集必须包含&amp;ldquo;块&amp;rdquo;。当使用&amp;ldquo;分块&amp;rdquo;传输编码时，它必须是应用于消息正文的最后一个传输编码。 &amp;ldquo;块&amp;rdquo;传输编码不得应用于消息正文多次。这些规则使收件人可以确定邮件的传输长度（&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）。传输编码类似于MIME的Content-Transfer-Encoding值[ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]，旨在实现通过7位传输服务安全地传输二进制数据。但是，安全传输对8bit-clean传输协议的关注点有所不同。在HTTP中，消息主体的唯一不安全特征是难以确定确切的正文长度（&lt;a href=&quot;#section-7.2.2&quot;&gt;第7.2.2节&lt;/a&gt;），或者希望通过共享传输对数据进行加密。互联网号码分配机构（IANA）充当用于转移编码值令牌的注册表。最初，注册表包含以下标记：&amp;ldquo;块&amp;rdquo;（&lt;a href=&quot;#section-3.6.1&quot;&gt;第3.6.1节&lt;/a&gt;），&amp;ldquo;身份&amp;rdquo;（&lt;a href=&quot;#section-3.6.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-3.6.2&quot;&gt;3.6.2 &lt;/a&gt;节），&amp;ldquo; gzip&amp;rdquo;（&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;），&amp;ldquo;压缩&amp;rdquo;（&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）和&amp;ldquo;放气&amp;rdquo;（ &lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）。应以与新的内容编码值令牌相同的方式注册新的传输编码值令牌（&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）。收到带有传输代码的实体的服务器不理解应该返回501（未实现），并关闭连接。服务器不得将传输代码发送到HTTP / 1.0客户端。</target>
        </trans-unit>
        <trans-unit id="8f06d2432c28b1a1b63093c7243e8fc4296b2052" translate="yes" xml:space="preserve">
          <source>Transformation Applied</source>
          <target state="translated">转化应用</target>
        </trans-unit>
        <trans-unit id="0333efced7aed7a62393f804f6f0a1fac69384cf" translate="yes" xml:space="preserve">
          <source>Transitioning from &lt;code&gt;X-Forwarded-For&lt;/code&gt; to &lt;code&gt;Forwarded&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 过渡到 &lt;code&gt;Forwarded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01d5987738fe39dbda22e95b91e209136e267709" translate="yes" xml:space="preserve">
          <source>Transparent negotiation is a combination of both server-driven and
   agent-driven negotiation. When a cache is supplied with a form of the
   list of available representations of the response (as in agent-driven
   negotiation) and the dimensions of variance are completely understood
   by the cache, then the cache becomes capable of performing server-
   driven negotiation on behalf of the origin server for subsequent
   requests on that resource.

   Transparent negotiation has the advantage of distributing the
   negotiation work that would otherwise be required of the origin
   server and also removing the second request delay of agent-driven
   negotiation when the cache is able to correctly guess the right
   response.

   This specification does not define any mechanism for transparent
   negotiation, though it also does not prevent any such mechanism from
   being developed as an extension that could be used within HTTP/1.1.</source>
          <target state="translated">透明协商是服务器驱动和代理驱动协商的结合。当缓存提供了响应的可用表示列表的形式(如代理驱动协商),并且缓存完全理解了差异的维度,那么缓存就能够代表原服务器对该资源的后续请求进行服务器驱动协商。透明协商的优点是可以将原本需要原服务器进行的协商工作进行分配,同时当缓存能够正确猜测出正确的响应时,也可以消除代理驱动协商的第二次请求延迟。本规范并没有定义任何透明协商的机制,尽管它也不妨碍任何这样的机制被开发成可以在HTTP/1.1中使用的扩展。</target>
        </trans-unit>
        <trans-unit id="78b9ce3dc78962972447ca0b6f58074fd970dfbb" translate="yes" xml:space="preserve">
          <source>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</source>
          <target state="translated">传输层安全(TLS)应用层协议协商扩展功能</target>
        </trans-unit>
        <trans-unit id="dfd6efe315d54c8cdd2adc5afbb8872f6a336102" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in iOS before 13. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b08ea38352dc45d4d989417f6fef8d6f90e693b" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in macOS before 10.15 Catalina. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323f99b9a56b4b45411c566426be7157525a2168" translate="yes" xml:space="preserve">
          <source>Trident</source>
          <target state="translated">Trident</target>
        </trans-unit>
        <trans-unit id="ca3606ead865c2815a13e76d1b25c992f4f3c6f9" translate="yes" xml:space="preserve">
          <source>Trident/7.0; .*rv:xyz &lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c266c97b59663994c186c4ed953693b711755a83" translate="yes" xml:space="preserve">
          <source>Trident/xyz</source>
          <target state="translated">Trident/xyz</target>
        </trans-unit>
        <trans-unit id="ea2c9903532f8ca9b9bfd8b8e86bf77e287eda98" translate="yes" xml:space="preserve">
          <source>Tries to resolve the hostname. Returns true if succeeds.</source>
          <target state="translated">试图解析主机名。如果成功则返回true。</target>
        </trans-unit>
        <trans-unit id="0ad2653fb337835a830a479f5211338052b81788" translate="yes" xml:space="preserve">
          <source>Troubleshooting HTTP 405</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5aeb48bb5b3f47bc91e7f66bbbde649d99b8a5" translate="yes" xml:space="preserve">
          <source>Troubleshooting errors</source>
          <target state="translated">故障排除</target>
        </trans-unit>
        <trans-unit id="6e7d676a3f4acf661dbd32eb846f4d30d45c42b9" translate="yes" xml:space="preserve">
          <source>True if and only if the IP address of the host matches the specified IP address pattern.</source>
          <target state="translated">如果且仅如果主机的IP地址与指定的IP地址模式相匹配,则为真。</target>
        </trans-unit>
        <trans-unit id="853354f33edc8bdc875b21e01f674d1cc985ac56" translate="yes" xml:space="preserve">
          <source>True if and only if there is no domain name in the hostname (no dots).</source>
          <target state="translated">如果且仅如果主机名中没有域名(没有点),则为真。</target>
        </trans-unit>
        <trans-unit id="40b3edf718ee234d3ed60de8590b0eab146b9f6b" translate="yes" xml:space="preserve">
          <source>TrueType Font</source>
          <target state="translated">TrueType字体</target>
        </trans-unit>
        <trans-unit id="deed064463d5fe6a9b6de90de79e1d7bc5664ed3" translate="yes" xml:space="preserve">
          <source>Trying to access an &lt;code&gt;http&lt;/code&gt; resource from a page with an &lt;code&gt;https&lt;/code&gt; origin will also cause this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ecb3021f84a92249f81d93e6449bc294633f5a4" translate="yes" xml:space="preserve">
          <source>Trying to access an &lt;code&gt;https&lt;/code&gt; resource that has an invalid certificate will cause this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7dd9fead5f39240201ca09db25e60a206fb473" translate="yes" xml:space="preserve">
          <source>Trying to use a &lt;a href=&quot;../../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request will fail with this error.</source>
          <target state="translated">尝试使用&lt;a href=&quot;../../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;请求将失败，并显示此错误。</target>
        </trans-unit>
        <trans-unit id="91efe823a9a6e3fb633db6d257efcabfa7cfb34a" translate="yes" xml:space="preserve">
          <source>Tunneling transmits private network data and protocol information through public network by encapsulating the data. HTTP tunneling is using a protocol of higher level (HTTP) to transport a lower level protocol (TCP).</source>
          <target state="translated">隧道通过封装数据,通过公网传输私有网络数据和协议信息。HTTP隧道是利用上层协议(HTTP)来传输下层协议(TCP)。</target>
        </trans-unit>
        <trans-unit id="e28a72d2f72f9e470a9c017ef73151d89a57b9b9" translate="yes" xml:space="preserve">
          <source>Turning on and off prefetching</source>
          <target state="translated">打开和关闭预取</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="2b805468035d4d32817647d90742c71d232cc025" translate="yes" xml:space="preserve">
          <source>Two header fields are used for carrying authentication credentials,
   as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;].  Note that various custom mechanisms for
   user authentication use the Cookie header field for this purpose, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;].

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | Authorization       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7235]&lt;/a&gt; |
   | Proxy-Authorization | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7235]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">根据[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]中的定义，两个标头字段用于承载身份验证凭据。请注意，用于用户身份验证的各种自定义机制为此目的使用了Cookie头字段，如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]中所定义。 + --------------------- + -------------------------- + |标头字段名称|定义于... | + --------------------- + -------------------------- + |授权| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235]的4.2节&lt;/a&gt; | |代理授权| &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;[RFC7235]的4.4节&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="ce0195a6ae48268edebd5bad672073160522c130" translate="yes" xml:space="preserve">
          <source>Two newer models were created in HTTP/1.1. The persistent-connection model keeps connections opened between successive requests, reducing the time needed to open new connections. The HTTP pipelining model goes one step further, by sending several successive requests without even waiting for an answer, reducing much of the latency in the network.</source>
          <target state="translated">在HTTP/1.1中创建了两个较新的模型。持久连接模型在连续的请求之间保持打开的连接,减少了打开新连接所需的时间。HTTP pipelining模型更进一步,通过发送几个连续的请求,甚至不需要等待应答,减少了很多网络中的延迟。</target>
        </trans-unit>
        <trans-unit id="a6b6a2cb2500b00f4598bac08b45cc08135ddf62" translate="yes" xml:space="preserve">
          <source>Two others content encoding, &lt;code&gt;bzip&lt;/code&gt; and &lt;code&gt;bzip2&lt;/code&gt;, are sometimes used, though not standard. They implement the algorithm used by these two UNIX programs. Note that the first one was discontinued due to patent licensing problems.</source>
          <target state="translated">有时会使用其他两种内容编码， &lt;code&gt;bzip&lt;/code&gt; 和 &lt;code&gt;bzip2&lt;/code&gt; ，尽管不是标准的。它们实现了这两个UNIX程序使用的算法。请注意，由于专利许可问题，第一个已停产。</target>
        </trans-unit>
        <trans-unit id="be051f060f0e48af75e9fbc48e21748ef6b4cb67" translate="yes" xml:space="preserve">
          <source>Two primary MIME types are important for the role of default types:</source>
          <target state="translated">两种主要的MIME类型对默认类型的作用很重要。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="f3b42007b5826f0bf510edecae6f14cfe0fe14b4" translate="yes" xml:space="preserve">
          <source>Type name:  multipart

   Subtype name:  byteranges

   Required parameters:  boundary

   Optional parameters:  N/A

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted

   Security considerations:  see &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).

   Applications that use this media type:  HTTP components supporting
      multiple ranges in a single request.

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:  See
      Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">类型名称：multipart子类型名称：byteranges必需参数：boundary可选参数：N / A编码注意事项：仅允许使用&amp;ldquo; 7bit&amp;rdquo;，&amp;ldquo; 8bit&amp;rdquo;或&amp;ldquo; binary&amp;rdquo;安全注意事项：请参阅&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt; 互操作性注意事项：N / A已发布规范：本规范（请参阅&lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;）。使用此媒体类型的应用程序：在单个请求中支持多个范围的HTTP组件。片段标识符注意事项：N / A附加信息：此类型已弃用的别名：N / A幻数：N / A文件扩展名：N / A Macintosh文件类型代码：N / A人员以及要联系以获取更多信息的电子邮件地址：请参见作者地址部分。预期用途：COMMON使用限制：不适用作者：请参阅作者地址。变更负责人：IESG</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="1cdbcf1104e531ebfadc11eeae080e4dae018fc1" translate="yes" xml:space="preserve">
          <source>Types of policy-controlled features</source>
          <target state="translated">政策控制功能的类型</target>
        </trans-unit>
        <trans-unit id="7e09f83609dd0c3d502c7f963c9a6cb433242aef" translate="yes" xml:space="preserve">
          <source>Typescript file</source>
          <target state="translated">排版文件</target>
        </trans-unit>
        <trans-unit id="bcdcdf22eca538d6ec2cf257367ae227cf6af679" translate="yes" xml:space="preserve">
          <source>Typical use case</source>
          <target state="translated">典型应用案例</target>
        </trans-unit>
        <trans-unit id="9d181320d36d0df488b3ffb530573b04214390c3" translate="yes" xml:space="preserve">
          <source>Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like these:</source>
          <target state="translated">通常，服务器响应包含一个如下所示的 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 标头：</target>
        </trans-unit>
        <trans-unit id="5c770b12d663e3645cbb00a17170089090ea1bce" translate="yes" xml:space="preserve">
          <source>Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7575b8da7bfc80688b2b000e08fcdc14b5cd506" translate="yes" xml:space="preserve">
          <source>Typically, this means that a required precondition header, such as &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt;, &lt;strong&gt;is missing&lt;/strong&gt;.</source>
          <target state="translated">典型地，这意味着所需的先决条件头，如&lt;a href=&quot;../headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;，&lt;strong&gt;缺少&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="037314288a9afb85b05677ae9ceceff454cbc8e0" translate="yes" xml:space="preserve">
          <source>Typically, you don't want your users to resend &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests. If you serve the response as the result of this request, a simple press of the reload button will resend the request (possibly after a confirmation message).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="cb371c93c5aa0e62198efd303ae2c17474416d1a" translate="yes" xml:space="preserve">
          <source>URI</source>
          <target state="translated">URI</target>
        </trans-unit>
        <trans-unit id="f70305059f0d6ca694366421ab9addbc18e37b87" translate="yes" xml:space="preserve">
          <source>URI/URL - A Uniform Resource Identifier and Uniform Resource Locator,
   respectively.  These terms (and the distinction between them) are
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].

   URI/URL Mapping - A relation between an absolute URI and a resource.
   Since a resource can represent items that are not network
   retrievable, as well as those that are, it is possible for a resource
   to have zero, one, or many URI mappings.  Mapping a resource to an
   &quot;http&quot; scheme URI makes it possible to submit HTTP protocol requests
   to the resource using the URI. 

   Path Segment - Informally, the characters found between slashes (&quot;/&quot;)
   in a URI.  Formally, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;.

   Collection - Informally, a resource that also acts as a container of
   references to child resources.  Formally, a resource that contains a
   set of mappings between path segments and resources and meets the
   requirements defined in &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;.

   Internal Member (of a Collection) - Informally, a child resource of a
   collection.  Formally, a resource referenced by a path segment
   mapping contained in the collection.

   Internal Member URL (of a Collection) - A URL of an internal member,
   consisting of the URL of the collection (including trailing slash)
   plus the path segment identifying the internal member.

   Member (of a Collection) - Informally, a &quot;descendant&quot; of a
   collection.  Formally, an internal member of the collection, or,
   recursively, a member of an internal member.

   Member URL (of a Collection) - A URL that is either an internal
   member URL of the collection itself, or is an internal member URL of
   a member of that collection.

   Property - A name/value pair that contains descriptive information
   about a resource.

   Live Property - A property whose semantics and syntax are enforced by
   the server.  For example, the live property DAV:getcontentlength has
   its value, the length of the entity returned by a GET request,
   automatically calculated by the server.

   Dead Property - A property whose semantics and syntax are not
   enforced by the server.  The server only records the value of a dead
   property; the client is responsible for maintaining the consistency
   of the syntax and semantics of a dead property.

   Principal - A distinct human or computational actor that initiates
   access to network resources.

   State Token - A URI that represents a state of a resource.  Lock
   tokens are the only state tokens defined in this specification.</source>
          <target state="translated">URI / URL-分别是统一资源标识符和统一资源定位符。这些术语（以及它们之间的区别）在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ] 中定义。 URI / URL映射-绝对URI与资源之间的关系。由于资源可以表示不可通过网络检索的项目以及可以通过网络检索的项目，因此资源可能具有零个，一个或多个URI映射。通过将资源映射到&amp;ldquo; http&amp;rdquo;方案URI，可以使用URI向资源提交HTTP协议请求。路径段-非正式地，在URI中的斜杠（&amp;ldquo; /&amp;rdquo;）之间找到的字符。正式而言，如&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]第3.3节中&lt;/a&gt;所定义。集合-非正式地，一种资源，还充当对子资源的引用的容器。形式上，资源包含路径段和资源之间的一组映射并满足&lt;a href=&quot;#section-5&quot;&gt;第5节中&lt;/a&gt;定义的要求。 （集合的）内部成员-非正式地，集合的子资源。形式上，集合中包含的路径段映射引用的资源。 （集合的）内部成员URL-内部成员的URL，由集合的URL（包括斜杠）加上标识内部成员的路径段组成。 （集合的成员）-非正式地，集合的&amp;ldquo;后代&amp;rdquo;。形式上，集合的内部成员，或者递归地，内部成员的成员。 （集合的）成员URL-URL可以是集合本身的内部成员URL，也可以是该集合成员的内部成员URL。属性-包含有关资源的描述性信息的名称/值对。实时属性-一种属性，其语义和语法由服务器强制执行。例如，活动属性DAV：getcontentlength具有其值，即由GET请求返回的实体的长度，该值由服务器自动计算。 Dead属性-服务器未强制使用其语义和语法的属性。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。getcontentlength具有其值，即由服务器自动计算的GET请求返回的实体的长度。 Dead属性-服务器未强制使用其语义和语法的属性。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。getcontentlength具有其值，即由服务器自动计算的GET请求返回的实体的长度。 Dead属性-服务器未强制使用其语义和语法的属性。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。服务器仅记录失效属性的值；客户负责维护已失效属性的语法和语义的一致性。委托人-发起访问网络资源的独立人员或计算人员。状态令牌-表示资源状态的URI。锁定令牌是此规范中定义的唯一状态令牌。</target>
        </trans-unit>
        <trans-unit id="1b1db348af514b6bea21a18f53ca916d54264149" translate="yes" xml:space="preserve">
          <source>URIs and how to access resources on the Web.</source>
          <target state="translated">URI以及如何访问网络上的资源。</target>
        </trans-unit>
        <trans-unit id="6d39406666e0fced7b5feeca9564a556a649dc18" translate="yes" xml:space="preserve">
          <source>URIs are intended to be shared, not secured, even when they identify
   secure resources.  URIs are often shown on displays, added to
   templates when a page is printed, and stored in a variety of
   unprotected bookmark lists.  It is therefore unwise to include
   information within a URI that is sensitive, personally identifiable,
   or a risk to disclose.

   Authors of services ought to avoid GET-based forms for the submission
   of sensitive data because that data will be placed in the
   request-target.  Many existing servers, proxies, and user agents log
   or display the request-target in places where it might be visible to
   third parties.  Such services ought to use POST-based form submission
   instead.

   Since the Referer header field tells a target site about the context
   that resulted in a request, it has the potential to reveal
   information about the user's immediate browsing history and any
   personal information that might be found in the referring resource's
   URI.  Limitations on the Referer header field are described in
   &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; to address some of its security considerations.</source>
          <target state="translated">URI旨在即使不标识安全资源也要共享而不是安全的。 URI通常显示在显示器上，在打印页面时将其添加到模板中，并存储在各种未受保护的书签列表中。因此，在URI中包含敏感，个人可识别或存在泄露风险的信息是不明智的。服务的作者应避免基于GET的表单提交敏感数据，因为这些数据将被放置在请求目标中。许多现有的服务器，代理和用户代理会在第三方可能可见的地方记录或显示请求目标。此类服务应改用基于POST的表单提交。由于Referer标头字段告知目标网站有关导致请求的上下文，它有可能泄露有关用户的即时浏览历史的信息以及在引用资源的URI中可能找到的任何个人信息。有关Referer标头字段的限制，请参见 &lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt;解决了一些安全性考虑。</target>
        </trans-unit>
        <trans-unit id="3cce85850c1e42a1666b59eb99149f8792f48d3c" translate="yes" xml:space="preserve">
          <source>URIs have been known by many names: WWW addresses, Universal Document
   Identifiers, Universal Resource Identifiers [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], and finally the
   combination of Uniform Resource Locators (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] and Names (URN)
   [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;]. As far as HTTP is concerned, Uniform Resource Identifiers are
   simply formatted strings which identify--via name, location, or any
   other characteristic--a resource.</source>
          <target state="translated">URI的名称很多：WWW地址，通用文档标识符，通用资源标识符[ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ]，最后是统一资源定位符（URL）[ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]和名称（URN）[ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ]的组合。就HTTP而言，统一资源标识符是简单格式化的字符串，它们通过名称，位置或任何其他特征来标识资源。</target>
        </trans-unit>
        <trans-unit id="498e7643a14364976970437ebe13915fd4a1000a" translate="yes" xml:space="preserve">
          <source>URIs in HTTP can be represented in absolute form or relative to some
   known base URI [&lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;], depending upon the context of their use. The two
   forms are differentiated by the fact that absolute URIs always begin
   with a scheme name followed by a colon. For definitive information on
   URL syntax and semantics, see &quot;Uniform Resource Identifiers (URI):
   Generic Syntax and Semantics,&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;] (which replaces RFCs
   1738 [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] and &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; [&lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;]). This specification adopts the
   definitions of &quot;URI-reference&quot;, &quot;absoluteURI&quot;, &quot;relativeURI&quot;, &quot;port&quot;,
   &quot;host&quot;,&quot;abs_path&quot;, &quot;rel_path&quot;, and &quot;authority&quot; from that
   specification.

   The HTTP protocol does not place any a priori limit on the length of
   a URI. Servers MUST be able to handle the URI of any resource they
   serve, and SHOULD be able to handle URIs of unbounded length if they
   provide GET-based forms that could generate such URIs. A server
   SHOULD return 414 (Request-URI Too Long) status if a URI is longer
   than the server can handle (see &lt;a href=&quot;#section-10.4.15&quot;&gt;section 10.4.15&lt;/a&gt;).

      Note: Servers ought to be cautious about depending on URI lengths
      above 255 bytes, because some older client or proxy
      implementations might not properly support these lengths.</source>
          <target state="translated">HTTP中的URI可以以绝对形式表示，也可以相对于某些已知的基本URI [ &lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt; ]表示，具体取决于它们的使用上下文。两种形式的区别在于，绝对URI总是以方案名称开头，后跟冒号。有关URL语法和语义的权威信息，请参阅&amp;ldquo;统一资源标识符（URI）：通用语法和语义&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt; ]（代替RFC 1738 [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]和&lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; [ &lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;]）。该规范采用该规范中的&amp;ldquo; URI引用&amp;rdquo;，&amp;ldquo; absoluteURI&amp;rdquo;，&amp;ldquo; relativeURI&amp;rdquo;，&amp;ldquo;端口&amp;rdquo;，&amp;ldquo;主机&amp;rdquo;，&amp;ldquo; abs_path&amp;rdquo;，&amp;ldquo; rel_path&amp;rdquo;和&amp;ldquo; authority&amp;rdquo;的定义。 HTTP协议对URI的长度没有任何先验限制。服务器必须能够处理它们所服务的任何资源的URI，并且如果它们提供可以生成此类URI的基于GET的形式，则应当能够处理无限长度的URI。如果URI的长度超过服务器的处理能力，则服务器应返回414（请求URI太长）状态（请参见&lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15节&lt;/a&gt;）。注意：服务器应该谨慎，具体取决于255个字节以上的URI长度，因为某些较旧的客户端或代理实现可能无法正确支持这些长度。</target>
        </trans-unit>
        <trans-unit id="cfef62af9614810559e1e5b81b8c27fecbab7b5c" translate="yes" xml:space="preserve">
          <source>URL redirection, also known as URL forwarding, is a technique to give a page, a form or a whole Web application, more than one URL address. HTTP provides a special kind of responses, &lt;em&gt;&lt;strong&gt;HTTP redirects&lt;/strong&gt;&lt;/em&gt;, to perform this operation used for numerous goals: temporary redirection while site maintenance is ongoing, permanent redirection to keep external links working after a change of the site's architecture, progress pages when uploading a file, and so on.</source>
          <target state="translated">URL重定向（也称为URL转发）是一种为页面，表单或整个Web应用程序提供多个URL地址的技术。HTTP提供了一种特殊的响应，即&lt;em&gt;&lt;strong&gt;HTTP重定向&lt;/strong&gt;&lt;/em&gt;，用于执行用于许多目标的此操作：在进行站点维护时进行临时重定向，在站点结构更改后使外部链接保持正常工作的永久重定向，在上传文件时显示进度页，等等。</target>
        </trans-unit>
        <trans-unit id="11053b0e7813cb1ccd4cf628421c47a3253d39a1" translate="yes" xml:space="preserve">
          <source>URL-embedded JavaScript code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621894213e70d0f25d538e3e503f261cb1c92c16" translate="yes" xml:space="preserve">
          <source>URL/hostname based conditions</source>
          <target state="translated">基于URL/主机名的条件</target>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="b9011f5a3d0a8fd5aa8be41c9a2ba56d323a6e48" translate="yes" xml:space="preserve">
          <source>URLs and URNs</source>
          <target state="translated">URLs和URNs</target>
        </trans-unit>
        <trans-unit id="0d68396d9a72290240763f5089d4a58c9fd02660" translate="yes" xml:space="preserve">
          <source>URLs appear in many places in requests and responses.
   Interoperability experience with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] showed that many clients
   parsing Multi-Status responses did not fully implement the full
   Reference Resolution defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC3986]&lt;/a&gt;.  Thus,
   servers in particular need to be careful in handling URLs in
   responses, to ensure that clients have enough context to be able to
   interpret all the URLs.  The rules in this section apply not only to
   resource URLs in the 'href' element in Multi-Status responses, but
   also to the Destination and If header resource URLs.

   The sender has a choice between two approaches: using a relative
   reference, which is resolved against the Request-URI, or a full URI.
   A server MUST ensure that every 'href' value within a Multi-Status
   response uses the same format.

   WebDAV only uses one form of relative reference in its extensions,
   the absolute path.

      Simple-ref = absolute-URI | ( path-absolute [ &quot;?&quot; query ] )

   The absolute-URI, path-absolute and query productions are defined in
   Sections &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;, &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;, and &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].

   Within Simple-ref productions, senders MUST NOT:

   o  use dot-segments (&quot;.&quot; or &quot;..&quot;), or

   o  have prefixes that do not match the Request-URI (using the
      comparison rules defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.2.3&quot;&gt;Section&amp;nbsp;3.2.3 of [RFC2616]&lt;/a&gt;).

   Identifiers for collections SHOULD end in a '/' character.</source>
          <target state="translated">URL出现在请求和响应中的许多位置。[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ]的互操作性经验表明，许多解析多状态响应的客户端没有完全实现&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986]第5节中&lt;/a&gt;定义的完整参考分辨率。。因此，服务器尤其需要谨慎处理响应中的URL，以确保客户端具有足够的上下文以能够解释所有URL。本节中的规则不仅适用于多状态响应中'href'元素中的资源URL，而且还适用于Destination和If标头资源URL。发送者可以在两种方法之间选择：使用相对引用（针对Request-URI解析）或完整URI。服务器必须确保多状态响应中的每个&amp;ldquo; href&amp;rdquo;值都使用相同的格式。 WebDAV在其扩展中仅使用一种形式的相对引用，即绝对路径。简单引用=绝对URI | （path-absolute [&amp;ldquo;？&amp;rdquo; query]）在节中定义了绝对URI，绝对路径和查询生成&lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;，&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;，以及&lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; [的&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]。在Simple-ref产生中，发送者不得：o使用点段（&amp;ldquo;。&amp;rdquo;或&amp;ldquo; ..&amp;rdquo;），或o与Request-URI不匹配的前缀（使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.2.3&quot;&gt;第3.2.3节中&lt;/a&gt;定义的比较规则）[RFC2616]）。集合的标识符应以&amp;ldquo; /&amp;rdquo;字符结尾。</target>
        </trans-unit>
        <trans-unit id="2c75d09b30def3f5acce02670c0f8d304787deb1" translate="yes" xml:space="preserve">
          <source>URNs</source>
          <target state="translated">URNs</target>
        </trans-unit>
        <trans-unit id="09716c44992b8bceefcd6d77921ff9ec06e2764d" translate="yes" xml:space="preserve">
          <source>USB</source>
          <target state="translated">USB</target>
        </trans-unit>
        <trans-unit id="463d4baccb11d04bd39b50170d5669b1473a3d3e" translate="yes" xml:space="preserve">
          <source>UTF-8 is now well-supported and the overwhelmingly preferred character encoding. To &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;guarantee better privacy through less configuration-based entropy&lt;/a&gt;, all browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8+, Safari 5+, Opera 11+, Firefox 10+ and Chrome 27+ no longer send it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3395f08e982fbccb7c267f1152a8f77ff4f3d2ba" translate="yes" xml:space="preserve">
          <source>Unconstrained multiple range requests are susceptible to denial-of-
   service attacks because the effort required to request many
   overlapping ranges of the same data is tiny compared to the time,
   memory, and bandwidth consumed by attempting to serve the requested
   data in many parts.  Servers ought to ignore, coalesce, or reject
   egregious range requests, such as requests for more than two
   overlapping ranges or for many small ranges in a single set,
   particularly when the ranges are requested out of order for no
   apparent reason.  Multipart range requests are not designed to
   support random access.</source>
          <target state="translated">不受限制的多范围请求很容易受到拒绝服务攻击,因为请求同一数据的许多重叠范围所需的努力与试图服务于所请求的数据的许多部分所消耗的时间、内存和带宽相比是微不足道的。服务器应该忽略、合并或拒绝恶劣的范围请求,例如请求两个以上的重叠范围或在一个集合中请求许多小范围,特别是当请求的范围没有明显的原因而顺序混乱时。多部分范围请求不是为了支持随机访问而设计的。</target>
        </trans-unit>
        <trans-unit id="87b5a91171602746648bcc818bbb122d7646769d" translate="yes" xml:space="preserve">
          <source>Undeprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">不推荐使用 &lt;code&gt;frame-src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f3058bceb865d591bd6a47330d0826684d098a7" translate="yes" xml:space="preserve">
          <source>Under construction. The origin server is currently testing its communication of tracking status.</source>
          <target state="translated">正在建设中。源服务器目前正在测试其跟踪状态的通信。</target>
        </trans-unit>
        <trans-unit id="93bb4b1c6ee8c5d136c3ae4245fe9019094c3bdf" translate="yes" xml:space="preserve">
          <source>Understanding The Vary Header - Smashing Magazine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4821ae5432f25746ffce2357d74178373c8cf2dd" translate="yes" xml:space="preserve">
          <source>Understanding XSS Auditor &amp;ndash; Virtue Security</source>
          <target state="translated">了解XSS Auditor &amp;ndash;美德安全性</target>
        </trans-unit>
        <trans-unit id="b2f6280ce256054e508e4d6c0d2aed7f16b9ceb5" translate="yes" xml:space="preserve">
          <source>Unfortunately, the HTTP standard does not specify the format of the page allowing to choose between the available resource, which prevents to easily automatize the process. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</source>
          <target state="translated">不幸的是，HTTP标准没有指定允许在可用资源之间进行选择的页面格式，这会阻止轻松地自动执行该过程。除了依靠&lt;em&gt;服务器驱动的协商之外&lt;/em&gt;，该方法几乎总是与脚本结合使用，尤其是与JavaScript重定向结合使用：在检查了协商条件之后，脚本将执行重定向。第二个问题是，需要另外一个请求才能获取实际资源，从而减慢了用户对资源的可用性。</target>
        </trans-unit>
        <trans-unit id="590261af46ebe2219ba617fed793de6d03379f66" translate="yes" xml:space="preserve">
          <source>Unfortunately, the HTTP standard does not specify the format of the page for choosing between the available resource, which prevents the process being automated. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba4dbb75ad90a20a4a3d20676386c7ac0143689" translate="yes" xml:space="preserve">
          <source>Unfortunately, things get a little inaccurate as soon as we take into account concurrency. While a client is locally modifying its new copy of the resource, a second client can fetch the same resource and do the same on its copy. What happens next is very unfortunate: when they commit back to the server, the modifications from the first client are discarded by the next client push, as this second client is unaware of the first client's changes to the resource. The decision on who wins, is not communicated to the other party. Which client's changes are to be kept, will vary with the speed they commit; this depends on the performance of the clients, of the server, and even of the human editing the document at the client. The winner will change from one time to the next. This is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/race_condition&quot;&gt;race condition&lt;/a&gt; and leads to problematic behaviors, which are difficult to detect and to debug:</source>
          <target state="translated">不幸的是，一旦考虑到并发性，事情就会变得有点不准确。当客户端在本地修改其新的资源副本时，第二个客户端可以获取相同的资源并对其副本执行相同的操作。接下来发生的事情非常不幸：当它们提交回服务器时，来自第一个客户端的修改将被下一次客户端推送丢弃，因为此第二个客户端不知道第一个客户端对资源的更改。谁获胜的决定不会传达给另一方。要保留哪个客户的更改，将随着他们提交的速度而变化；这取决于客户端，服务器的性能，甚至还取决于人工在客户端编辑文档的性能。获胜者将一次改变一次。这是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/race_condition&quot;&gt;比赛条件&lt;/a&gt;并导致有问题的行为，这些行为很难检测和调试：</target>
        </trans-unit>
        <trans-unit id="9d6157fa48e6c6221f34d6df81ed35de4c9f2058" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifier (URI): Generic Syntax</source>
          <target state="translated">统一资源标识符 (URI)。通用语法</target>
        </trans-unit>
        <trans-unit id="5331c3d8fb4de87de8b7a5cbf7bd8ea20f192adf" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URIs) [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] are used throughout
   HTTP as the means for identifying resources (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-2&quot;&gt;Section&amp;nbsp;2 of [RFC7231]&lt;/a&gt;).
   URI references are used to target requests, indicate redirects, and
   define relationships.

   The definitions of &quot;URI-reference&quot;, &quot;absolute-URI&quot;, &quot;relative-part&quot;,
   &quot;scheme&quot;, &quot;authority&quot;, &quot;port&quot;, &quot;host&quot;, &quot;path-abempty&quot;, &quot;segment&quot;,
   &quot;query&quot;, and &quot;fragment&quot; are adopted from the URI generic syntax.  An
   &quot;absolute-path&quot; rule is defined for protocol elements that can
   contain a non-empty path component.  (This rule differs slightly from
   the path-abempty rule of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, which allows for an empty path to
   be used in references, and path-absolute rule, which does not allow
   paths that begin with &quot;//&quot;.)  A &quot;partial-URI&quot; rule is defined for
   protocol elements that can contain a relative URI but not a fragment
   component.

     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], Section&amp;nbsp;4.1&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], Section&amp;nbsp;4.3&lt;/a&gt;&amp;gt;
     relative-part = &amp;lt;relative-part, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;&amp;gt;
     scheme        = &amp;lt;scheme, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;&amp;gt;
     authority     = &amp;lt;authority, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;&amp;gt;
     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     path-abempty  = &amp;lt;path-abempty, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
     segment       = &amp;lt;segment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
     query         = &amp;lt;query, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
     fragment      = &amp;lt;fragment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;&amp;gt;

     absolute-path = 1*( &quot;/&quot; segment )
     partial-URI   = relative-part [ &quot;?&quot; query ]

   Each protocol element in HTTP that allows a URI reference will
   indicate in its ABNF production whether the element allows any form
   of reference (URI-reference), only a URI in absolute form
   (absolute-URI), only the path and optional query components, or some
   combination of the above.  Unless otherwise indicated, URI references
   are parsed relative to the effective request URI (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;).</source>
          <target state="translated">整个HTTP使用统一资源标识符（URI）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]作为标识资源的方法（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-2&quot;&gt;[RFC7231]的第2节&lt;/a&gt;）。 URI引用用于定位请求，指示重定向和定义关系。 &amp;ldquo; URI引用&amp;rdquo;，&amp;ldquo;绝对URI&amp;rdquo;，&amp;ldquo;相对部分&amp;rdquo;，&amp;ldquo;方案&amp;rdquo;，&amp;ldquo;权限&amp;rdquo;，&amp;ldquo;端口&amp;rdquo;，&amp;ldquo;主机&amp;rdquo;，&amp;ldquo;路径豁免&amp;rdquo;，&amp;ldquo;段&amp;rdquo;，&amp;ldquo;查询&amp;rdquo;的定义和&amp;ldquo;片段&amp;rdquo;是从URI通用语法中采用的。为可以包含非空路径组件的协议元素定义了&amp;ldquo;绝对路径&amp;rdquo;规则。 （此规则与&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;的路径豁免规则略有不同，它允许在引用中使用空路径，而路径绝对规则则不允许以&amp;ldquo; //&amp;rdquo;开头的路径。）为可以包含相对地址的协议元素定义了&amp;ldquo; partial-URI&amp;rdquo;规则URI，但不是片段组件。 URI引用= &amp;lt;URI引用，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986]，第4.1节&lt;/a&gt; &amp;gt; absolute-URI = &amp;lt;绝对URI，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]，第4.3节&lt;/a&gt; &amp;gt; relative-part = &amp;lt;相对部分，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986]，第4.2节&lt;/a&gt; &amp;gt;方案= &amp;lt;方案，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986]，第3.1节&lt;/a&gt; &amp;gt;权限= &amp;lt;权限，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986]，第3.2节&lt;/a&gt; &amp;gt; uri-host = &amp;lt;主机，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986]，第3.2.2节&lt;/a&gt; &amp;gt; port = &amp;lt;港口，看&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986，第3.2.3节&lt;/a&gt; &amp;gt;路径豁免= &amp;lt;路径-豁免，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]，第3.3节&lt;/a&gt; &amp;gt;段= &amp;lt;段，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]，第3.3节&lt;/a&gt; &amp;gt; query = &amp;lt;查询，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986]，第3节3.4&lt;/a&gt; &amp;gt;片段= &amp;lt;片段，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986]，第3.5节&lt;/a&gt;&amp;gt;绝对路径= 1 *（&amp;ldquo; /&amp;rdquo; segment）部分URI =相对部分[&amp;ldquo;？&amp;rdquo; HTTP中允许URI引用的每个协议元素都将在其ABNF产生中指示该元素是否允许任何形式的引用（URI-reference），仅允许绝对形式的URI（absolute-URI），仅路径和可选查询组件或以上的某种组合。除非另有说明，否则将相对于有效请求URI解析URI引用（&lt;a href=&quot;#section-5.5&quot;&gt;第5.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="326e61a6296432fcad1af300f3c896bd0e9d0435" translate="yes" xml:space="preserve">
          <source>Uniform Resource Names</source>
          <target state="translated">统一资源名称</target>
        </trans-unit>
        <trans-unit id="0f25e6e17d90b442b15b6c3491b583d0eb8a4b09" translate="yes" xml:space="preserve">
          <source>Unless dealing with a very old system, which doesn't support a persistent connection, there is no compelling reason to use this model.</source>
          <target state="translated">除非处理的是一个非常古老的系统,不支持持久连接,否则没有令人信服的理由使用这个模型。</target>
        </trans-unit>
        <trans-unit id="7df067eefe56c18b36ec5afe619983a9a5702d6c" translate="yes" xml:space="preserve">
          <source>Unless specifically constrained by a cache-control (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;)
   directive, a caching system MAY always store a successful response
   (see &lt;a href=&quot;#section-13.8&quot;&gt;section 13.8&lt;/a&gt;) as a cache entry, MAY return it without validation
   if it is fresh, and MAY return it after successful validation. If
   there is neither a cache validator nor an explicit expiration time
   associated with a response, we do not expect it to be cached, but
   certain caches MAY violate this expectation (for example, when little
   or no network connectivity is available). A client can usually detect
   that such a response was taken from a cache by comparing the Date
   header to the current time.

      Note: some HTTP/1.0 caches are known to violate this expectation
      without providing any Warning.

   However, in some cases it might be inappropriate for a cache to
   retain an entity, or to return it in response to a subsequent
   request. This might be because absolute semantic transparency is
   deemed necessary by the service author, or because of security or
   privacy considerations. Certain cache-control directives are
   therefore provided so that the server can indicate that certain
   resource entities, or portions thereof, are not to be cached
   regardless of other considerations.

   Note that &lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt; normally prevents a shared cache from saving
   and returning a response to a previous request if that request
   included an Authorization header.

   A response received with a status code of 200, 203, 206, 300, 301 or
   410 MAY be stored by a cache and used in reply to a subsequent
   request, subject to the expiration mechanism, unless a cache-control
   directive prohibits caching. However, a cache that does not support
   the Range and Content-Range headers MUST NOT cache 206 (Partial
   Content) responses.

   A response received with any other status code (e.g. status codes 302
   and 307) MUST NOT be returned in a reply to a subsequent request
   unless there are cache-control directives or another header(s) that
   explicitly allow it. For example, these include the following: an
   Expires header (&lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;); a &quot;max-age&quot;, &quot;s-maxage&quot;,  &quot;must-
   revalidate&quot;, &quot;proxy-revalidate&quot;, &quot;public&quot; or &quot;private&quot; cache-control
   directive (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">除非特别受cache-control（&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt;）指令约束，否则缓存系统可以始终存储成功的响应（请参见&lt;a href=&quot;#section-13.8&quot;&gt;第13.8节）。&lt;/a&gt;）作为缓存条目，如果它是新鲜的，则可以不经验证返回它，并且在成功验证后可以返回它。如果既没有缓存验证器，也没有明确的到期时间与响应相关联，则我们不希望缓存该缓存，但是某些缓存可能会违反此期望（例如，当很少或没有网络连接可用时）。客户端通常可以通过将Date标头与当前时间进行比较，来检测到这种响应是从缓存中获取的。注意：某些HTTP / 1.0缓存已知违反了此期望，而没有提供任何警告。但是，在某些情况下，缓存保留实体或响应后续请求返回实体可能是不合适的。这可能是因为服务作者认为绝对语义透明是必要的，或出于安全或隐私考虑。因此，提供了某些高速缓存控制指令，以便服务器可以指示某些资源实体或其一部分不考虑其他考虑因素而不会被高速缓存。注意&lt;a href=&quot;#section-14.8&quot;&gt;第14.8节&lt;/a&gt;通常会阻止共享缓存保存并返回对先前请求的响应（如果该请求包含Authorization标头）。状态码为200、203、206、300、301或410的响应可以由缓存存储，并用于响应后续请求（取决于到期机制），除非缓存控制指令禁止缓存。但是，不支持Range和Content-Range头的缓存必须不缓存206（部分内容）响应。除非有缓存控制指令或明确允许该请求的其他头，否则不得在对后续请求的答复中返回使用任何其他状态代码（例如状态代码302和307）接收到的响应。例如，这些内容包括：Expires标头（&lt;a href=&quot;#section-14.21&quot;&gt;第14.21条&lt;/a&gt;）; &amp;ldquo; max-age&amp;rdquo;，&amp;ldquo; s-maxage&amp;rdquo;，&amp;ldquo; must-revalidate&amp;rdquo;，&amp;ldquo; proxy-revalidate&amp;rdquo;，&amp;ldquo; public&amp;rdquo;或&amp;ldquo; private&amp;rdquo;缓存控制指令（&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6575621a518b7b48c43d42321f561d5d0b99d27e" translate="yes" xml:space="preserve">
          <source>Unless the origin server explicitly prohibits the caching of their
   responses, the application of GET and HEAD methods to any resources
   SHOULD NOT have side effects that would lead to erroneous behavior if
   these responses are taken from a cache. They MAY still have side
   effects, but a cache is not required to consider such side effects in
   its caching decisions. Caches are always expected to observe an
   origin server's explicit restrictions on caching.

   We note one exception to this rule: since some applications have
   traditionally used GETs and HEADs with query URLs (those containing a
   &quot;?&quot; in the rel_path part) to perform operations with significant side
   effects, caches MUST NOT treat responses to such URIs as fresh unless
   the server provides an explicit expiration time. This specifically
   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT
   be taken from a cache. See &lt;a href=&quot;#section-9.1.1&quot;&gt;section 9.1.1&lt;/a&gt; for related information.</source>
          <target state="translated">除非原始服务器明确禁止缓存其响应，否则将GET和HEAD方法应用于任何资源都不应产生副作用，如果这些响应是从缓存中获取的，则会导致错误的行为。它们可能仍然有副作用，但是不需要缓存来考虑其缓存决策中的此类副作用。总是希望缓存遵守源服务器对缓存的明确限制。我们注意到该规则的一个例外：由于某些应用程序传统上使用带有查询URL的GET和HEAD（在rel_path部分中包含&amp;ldquo;？&amp;rdquo;的URL）来执行具有明显副作用的操作，因此缓存不得将对此类URI的响应视为新鲜除非服务器提供明确的到期时间。这特别意味着，不应从缓存中获取来自HTTP / 1.0服务器对此类URI的响应。看到&lt;a href=&quot;#section-9.1.1&quot;&gt;&lt;/a&gt;有关相关信息，请参见第9.1.1节。</target>
        </trans-unit>
        <trans-unit id="a882eb5ce8619bac0f4ca38a47d118a374f590ac" translate="yes" xml:space="preserve">
          <source>Unless you have a very specific immediate need, don't use this deprecated technique; switch to HTTP/2 instead. In HTTP/2, domain sharding is no longer useful: the HTTP/2 connection is able to handle parallel unprioritized requests very well. Domain sharding is even detrimental to performance. Most HTTP/2 implementations use a technique called &lt;a href=&quot;https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/&quot;&gt;connection coalescing&lt;/a&gt; to revert eventual domain sharding.</source>
          <target state="translated">除非您有非常具体的即时需求，否则不要使用此不推荐使用的技术；改用HTTP / 2。在HTTP / 2中，域分片不再有用：HTTP / 2连接能够很好地处理并行的非优先级请求。域分片甚至会损害性能。大多数HTTP / 2实现使用一种称为&lt;a href=&quot;https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/&quot;&gt;连接合并&lt;/a&gt;的技术来还原最终的域分片。</target>
        </trans-unit>
        <trans-unit id="955f79db78c5cf8385c47043fef1a0ffa744352f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, &quot;preflighted&quot; requests first send an HTTP request by the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method to the resource on the other domain, in order to determine whether the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</source>
          <target state="translated">与&lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;简单请求&amp;rdquo;（如上所述）不同&lt;/a&gt;，&amp;ldquo;预检&amp;rdquo;请求首先通过&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;方法向另一个域上的资源发送HTTP请求，以确定实际请求是否可以安全发送。跨站点请求这样被预检，因为它们可能会影响用户数据。</target>
        </trans-unit>
        <trans-unit id="d273c3c1c262b7b14dbca55da7ae721b5a1b7cec" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, for &quot;preflighted&quot; requests the browser first sends an HTTP request using the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method to the resource on the other origin, in order to determine if the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e7352000385c24773b5c3b97548547d27dfcec" translate="yes" xml:space="preserve">
          <source>Unlike subsequent evolutions, there were no HTTP headers, meaning that only HTML files could be transmitted, but no other type of documents. There were no status or error codes: in case of a problem, a specific HTML file was send back with the description of the problem contained in it, for human consumption.</source>
          <target state="translated">与后来的演变不同,当时没有HTTP头,这意味着只能传输HTML文件,而不能传输其他类型的文件。当时没有状态或错误代码:如果出现问题,会发回一个特定的HTML文件,其中包含问题的描述,供人使用。</target>
        </trans-unit>
        <trans-unit id="dcc5e76d5034fe1dc84b95117a89364e895b52d1" translate="yes" xml:space="preserve">
          <source>Unlike the previous case, browser history will consider non-www and www URLs as independent entries.</source>
          <target state="translated">与前一种情况不同的是,浏览器的历史记录会将非www和www网址视为独立的条目。</target>
        </trans-unit>
        <trans-unit id="7607e9b76ed3569248e88c3e032d8ff230e82e7b" translate="yes" xml:space="preserve">
          <source>Unoptimized (poorly compressed) images</source>
          <target state="translated">未优化(压缩得不好)的图像。</target>
        </trans-unit>
        <trans-unit id="b89f58bc5f8bec30721ee6218fbce69f661ae508" translate="yes" xml:space="preserve">
          <source>Unoptimized images</source>
          <target state="translated">未优化的图像</target>
        </trans-unit>
        <trans-unit id="245e0bd02f62833b644643c9a2e8742e64c2dd7a" translate="yes" xml:space="preserve">
          <source>Unrecognized markup in an Atom Publishing Protocol document is
   considered &quot;foreign markup&quot; as defined in &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; of the Atom
   Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  Foreign markup can be used anywhere
   within a Category or Service Document unless it is explicitly
   forbidden.  Processors that encounter foreign markup MUST NOT stop
   processing and MUST NOT signal an error.  Clients SHOULD preserve
   foreign markup when transmitting such documents.

   The namespace name &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; is reserved for
   forward-compatible revisions of the Category and Service Document
   types.  This does not exclude the addition of elements and attributes
   that might not be recognized by processors conformant to this
   specification.  Such unrecognized markup from the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace MUST be treated as foreign
   markup.</source>
          <target state="translated">Atom发布协议文档中无法识别的标记被视为&amp;ldquo;外国标记&amp;rdquo;，如Atom联合格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]的&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;所定义。除非明确禁止，否则外部标记可以在类别或服务文档中的任何位置使用。遇到外来标记的处理器不得停止处理，也不得发出错误信号。客户在发送此类文件时应保留外国标记。命名空间名称&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&amp;ldquo;是为类别和服务文档类型的前向兼容修订版本保留的。这并不排除添加符合本规范的处理器可能无法识别的元素和属性&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;。&amp;rdquo; w3.org/2007/app&lt;/a&gt; &amp;ldquo;命名空间必须视为外部标记。</target>
        </trans-unit>
        <trans-unit id="de81198fe40f54ca54fd480498f47c5bd2c4979b" translate="yes" xml:space="preserve">
          <source>Unsafe eval expressions</source>
          <target state="translated">不安全的评价表达式</target>
        </trans-unit>
        <trans-unit id="83339b270595929064cc25f1d47c8f0230812a35" translate="yes" xml:space="preserve">
          <source>Unsafe inline script</source>
          <target state="translated">不安全的内联脚本</target>
        </trans-unit>
        <trans-unit id="a3661e5b83227307acd4850c07a9aaa4a3205ae7" translate="yes" xml:space="preserve">
          <source>Unsafe inline styles</source>
          <target state="translated">不安全的内联样式</target>
        </trans-unit>
        <trans-unit id="b9c54338e2e3842fa7755217571c1728460781da" translate="yes" xml:space="preserve">
          <source>Unsafe style expressions</source>
          <target state="translated">不安全的风格表达</target>
        </trans-unit>
        <trans-unit id="51e569288fd4c9764275c80909467d65bb077394" translate="yes" xml:space="preserve">
          <source>Unsized media</source>
          <target state="translated">无尺寸媒体</target>
        </trans-unit>
        <trans-unit id="03d0f6e963af156d3bbc20c425d63949186d2932" translate="yes" xml:space="preserve">
          <source>Until browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a7c8e0f8f826b048cc60b6edd36eb21796fb60" translate="yes" xml:space="preserve">
          <source>Updated. The request resulted in a potential change to the tracking status applicable to this user, user agent, or device.</source>
          <target state="translated">已更新。该请求导致适用于该用户、用户代理或设备的跟踪状态可能发生变化。</target>
        </trans-unit>
        <trans-unit id="ac2a73c827836daeaf2402394c054c2277994448" translate="yes" xml:space="preserve">
          <source>Upgrade (RFC 2616)</source>
          <target state="translated">升级(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="541adf48138ad8391190feed85e1730b3e897f18" translate="yes" xml:space="preserve">
          <source>Upgrade Insecure Requests</source>
          <target state="translated">升级不安全的请求</target>
        </trans-unit>
        <trans-unit id="03453046fa615930ff26806bfd5e6e667dba241d" translate="yes" xml:space="preserve">
          <source>Upgrade Insecure Requests&lt;br/&gt;&lt;small&gt;The definition of 'upgrade-insecure-requests' in that specification.&lt;/small&gt;</source>
          <target state="translated">升级不安全请求&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;升级不安全请求&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="61c6967492e019e22cb265be59268846e0812c5e" translate="yes" xml:space="preserve">
          <source>Upgrade-Insecure-Requests</source>
          <target state="translated">Upgrade-Insecure-Requests</target>
        </trans-unit>
        <trans-unit id="3b1e9dd129f9691779584493ef0cbd2760709427" translate="yes" xml:space="preserve">
          <source>Upgrading HTTP/1.1 Connections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373052ca50b595448fddb3ae3555f3abe2335a7b" translate="yes" xml:space="preserve">
          <source>Upgrading an HTTP connection to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with the token &lt;code&gt;&quot;TLS/1.0&quot;&lt;/code&gt;. If the switch is made successfully, the original request (which included &lt;code&gt;Upgrade&lt;/code&gt;) is completed as normal, but on the TLS connection.</source>
          <target state="translated">升级HTTP连接以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS会&lt;/a&gt;使用带有令牌 &lt;code&gt;&quot;TLS/1.0&quot;&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头。如果切换成功，则原始请求（包括 &lt;code&gt;Upgrade&lt;/code&gt; ）将正常完成，但通过TLS连接完成。</target>
        </trans-unit>
        <trans-unit id="ab6bbb4d08469c650377ccf5de1a9d9d4253b906" translate="yes" xml:space="preserve">
          <source>Upgrading to TLS Within HTTP/1.1</source>
          <target state="translated">在HTTP/1.1中升级到TLS。</target>
        </trans-unit>
        <trans-unit id="4a01efdfa6f7b943dbd14d96f1bbda14ed6ca745" translate="yes" xml:space="preserve">
          <source>Upgrading to a WebSocket connection</source>
          <target state="translated">升级到WebSocket连接</target>
        </trans-unit>
        <trans-unit id="0df7fec503cc297ba369a863eb42d823f8a3ecf0" translate="yes" xml:space="preserve">
          <source>Upgrading to an HTTP/2 connection</source>
          <target state="translated">升级到HTTP/2连接</target>
        </trans-unit>
        <trans-unit id="92d99b032888bf69448943e3813f272f0f43c556" translate="yes" xml:space="preserve">
          <source>Usage notes</source>
          <target state="translated">使用说明</target>
        </trans-unit>
        <trans-unit id="206d556a43a2ee8de81319e120005dc792bee741" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;isInNet()&lt;/code&gt;, &lt;code&gt;isResolvable()&lt;/code&gt; and &lt;code&gt;dnsResolve()&lt;/code&gt; functions should be carefully considered, as they require the DNS server to be consulted. All the other autoconfig-related functions are mere string-matching functions that don't require the use of a DNS server. If a proxy is used, the proxy will perform its DNS lookup which would double the impact on the DNS server. Most of the time these functions are not necessary to achieve the desired result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609254f79607923f3629c1a1e3f48cf232c1eba4" translate="yes" xml:space="preserve">
          <source>Use SOCKS if the primary proxy goes down.</source>
          <target state="translated">如果主代理发生故障,请使用SOCKS。</target>
        </trans-unit>
        <trans-unit id="8b4ff35cb43293441d2110cc488f4176d62f368d" translate="yes" xml:space="preserve">
          <source>Use and Interpretation of HTTP Version Numbers</source>
          <target state="translated">HTTP版本号的使用和解释</target>
        </trans-unit>
        <trans-unit id="14a29ba383c84d15925a42f871530f52904ae908" translate="yes" xml:space="preserve">
          <source>Use cases</source>
          <target state="translated">使用案例</target>
        </trans-unit>
        <trans-unit id="f86adfd6db8707c78a8855719e5ab5617c841214" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;isInNet()&lt;/code&gt;, &lt;code&gt;isResolvable()&lt;/code&gt; and &lt;code&gt;dnsResolve()&lt;/code&gt; functions should be carefully considered, as they require the DNS server to be consulted. All the other autoconfig-related functions are mere string-matching functions that don't require the use of a DNS server. If a proxy is used, the proxy will perform its DNS lookup which would double the impact on the DNS server. Most of the time these functions are not necessary to achieve the desired result.</source>
          <target state="translated">应该仔细考虑使用 &lt;code&gt;isInNet()&lt;/code&gt; ， &lt;code&gt;isResolvable()&lt;/code&gt; 和 &lt;code&gt;dnsResolve()&lt;/code&gt; 函数，因为它们要求查询DNS服务器。其他所有与autoconfig相关的功能都只是字符串匹配功能，不需要使用DNS服务器。如果使用代理，则代理将执行其DNS查找，这对DNS服务器的影响将增加一倍。在大多数情况下，这些功能对于获得期望的结果不是必需的。</target>
        </trans-unit>
        <trans-unit id="541cad19bcced32598517d8ec84381ca4110eb7d" translate="yes" xml:space="preserve">
          <source>Use of server-driven content negotiation (&lt;a href=&quot;#section-12.1&quot;&gt;section 12.1&lt;/a&gt;), as indicated
   by the presence of a Vary header field in a response, alters the
   conditions and procedure by which a cache can use the response for
   subsequent requests. See &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header
   field by servers.

   A server SHOULD use the Vary header field to inform a cache of what
   request-header fields were used to select among multiple
   representations of a cacheable response subject to server-driven
   negotiation. The set of header fields named by the Vary field value
   is known as the &quot;selecting&quot; request-headers.

   When the cache receives a subsequent request whose Request-URI
   specifies one or more cache entries including a Vary header field,
   the cache MUST NOT use such a cache entry to construct a response to
   the new request unless all of the selecting request-headers present
   in the new request match the corresponding stored request-headers in
   the original request.

   The selecting request-headers from two requests are defined to match
   if and only if the selecting request-headers in the first request can
   be transformed to the selecting request-headers in the second request 

   by adding or removing linear white space (LWS) at places where this
   is allowed by the corresponding BNF, and/or combining multiple
   message-header fields with the same field name following the rules
   about message headers in &lt;a href=&quot;#section-4.2&quot;&gt;section 4.2&lt;/a&gt;.

   A Vary header field-value of &quot;*&quot; always fails to match and subsequent
   requests on that resource can only be properly interpreted by the
   origin server.

   If the selecting request header fields for the cached entry do not
   match the selecting request header fields of the new request, then
   the cache MUST NOT use a cached entry to satisfy the request unless
   it first relays the new request to the origin server in a conditional
   request and the server responds with 304 (Not Modified), including an
   entity tag or Content-Location that indicates the entity to be used.

   If an entity tag was assigned to a cached representation, the
   forwarded request SHOULD be conditional and include the entity tags
   in an If-None-Match header field from all its cache entries for the
   resource. This conveys to the server the set of entities currently
   held by the cache, so that if any one of these entities matches the
   requested entity, the server can use the ETag header field in its 304
   (Not Modified) response to tell the cache which entry is appropriate.
   If the entity-tag of the new response matches that of an existing
   entry, the new response SHOULD be used to update the header fields of
   the existing entry, and the result MUST be returned to the client.

   If any of the existing cache entries contains only partial content
   for the associated entity, its entity-tag SHOULD NOT be included in
   the If-None-Match header field unless the request is for a range that
   would be fully satisfied by that entry.

   If a cache receives a successful response whose Content-Location
   field matches that of an existing cache entry for the same Request-
   ]URI, whose entity-tag differs from that of the existing entry, and
   whose Date is more recent than that of the existing entry, the
   existing entry SHOULD NOT be returned in response to future requests
   and SHOULD be deleted from the cache.</source>
          <target state="translated">如响应中存在Vary标头字段所示，使用服务器驱动的内容协商（&lt;a href=&quot;#section-12.1&quot;&gt;第12.1节&lt;/a&gt;）会更改条件和过程，缓存可以通过该条件和过程将响应用于后续请求。参见&lt;a href=&quot;#section-14.44&quot;&gt;第14.44节&lt;/a&gt;供服务器使用Vary标头字段。服务器应该使用Vary标头字段来通知高速缓存哪些请求标头字段用于在受服务器驱动的协商的可缓存响应的多个表示中进行选择。由Vary字段值命名的头字段集称为&amp;ldquo;选择&amp;rdquo;请求头。当缓存接收到一个后续请求，该请求的Request-URI指定了一个或多个包括Vary标头字段的缓存条目时，除非在其中存在所有选择请求标头，否则缓存不得使用此类缓存条目来构造对新请求的响应。新请求与原始请求中相应的存储的请求标头匹配。当且仅当通过在位置添加或删除线性空白（LWS）可以将第一个请求中的选择请求标头转换为第二个请求中的选择请求标头时，才定义两个请求中的选择请求标头在相应的BNF允许的情况下，和/或按照以下有关消息头的规则将多个具有相同字段名的消息头字段组合在一起&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt;。 Vary标头字段值&amp;ldquo; *&amp;rdquo;始终不匹配，并且该资源上的后续请求只能由原始服务器正确解释。如果缓存条目的选择请求标头字段与新请求的选择请求标头字段不匹配，则缓存必须禁止使用缓存条目满足请求，除非它先在条件条件下将新请求中继到原始服务器请求，服务器将以304（未修改）响应，其中包括指示要使用的实体的实体标签或Content-Location。如果一个实体标签被分配给一个缓存的表示，则转发的请求应该是有条件的，并且将实体标签从资源的所有缓存条目的If-None-Match标头字段中包括在内。这会将服务器当前由缓存保存的实体集传达给服务器，因此，如果这些实体中的任何一个与请求的实体匹配，则服务器可以使用其304（未修改）响应中的ETag标头字段来告诉缓存哪个条目是适当的。如果新响应的实体标签与现有条目的实体标签匹配，则应使用新响应来更新现有条目的报头字段，并且结果必须返回给客户端。如果任何现有缓存条目仅包含关联实体的部分内容，则其实体标签不应包含在If-None-Match标头字段中，除非请求是针对该条目将完全满足的范围。如果缓存收到成功的响应，且该响应的Content-Location字段与同一Request-] URI的现有缓存条目的响应匹配，则其实体标签不同于现有条目的实体标签，并且其Date比现有条目的日期新条目，不应响应将来的请求而返回现有条目，而应从缓存中删除该条目。</target>
        </trans-unit>
        <trans-unit id="e77c9c913df2233d025f025eb22c3c9e62e56fdc" translate="yes" xml:space="preserve">
          <source>Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP)</source>
          <target state="translated">在超文本传输协议(HTTP)中使用内容-位置标头字段。</target>
        </trans-unit>
        <trans-unit id="eb01880ea7e6c648b8ded6a971ea49e97cecb27b" translate="yes" xml:space="preserve">
          <source>Use proxy for everything except local hosts</source>
          <target state="translated">除了本地主机外,其他都使用代理</target>
        </trans-unit>
        <trans-unit id="0107748696d0540526cac08ee4cbc145c8a991e8" translate="yes" xml:space="preserve">
          <source>Use proxy only if cannot resolve host</source>
          <target state="translated">只有在无法解析主机时才使用代理</target>
        </trans-unit>
        <trans-unit id="c7ed5020d95df63e9bfb909b2b5b6c058bbb92a7" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">请改用&lt;a href=&quot;../referrer-policy&quot;&gt; &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="374f23714fac239889ce0a35686349d0fd2fc8cd" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;HttpOnly&lt;/code&gt; attribute to prevent access to cookie values via JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ac4246f627ce26f7ce64dc4d28d75832652c40" translate="yes" xml:space="preserve">
          <source>Used by Internet Explorer to signal which document mode to use.</source>
          <target state="translated">由Internet Explorer用于指示使用哪种文档模式。</target>
        </trans-unit>
        <trans-unit id="3e069a42a09f6b8db75113499e4519c2f9266038" translate="yes" xml:space="preserve">
          <source>Used for expressing the user's tracking preference.</source>
          <target state="translated">用于表达用户的跟踪偏好。</target>
        </trans-unit>
        <trans-unit id="83b3f402f1178112d86419eb8f13870a53b15a0a" translate="yes" xml:space="preserve">
          <source>Used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254d1c745ac787d4b79a0930aea72d4ebc02b51f" translate="yes" xml:space="preserve">
          <source>Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">用于响应飞行前的请求,以指示实际请求时可以使用哪些HTTP头信息。</target>
        </trans-unit>
        <trans-unit id="dd444ebe633050849c3b22b62bbb0225010af96b" translate="yes" xml:space="preserve">
          <source>Used inside a &lt;code&gt;&amp;lt;dav:propstat&amp;gt;&lt;/code&gt; response element to avoid repeatedly enumerating the internal members of multiple bindings to the same collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3851eaed9a9d01e9b233c8f2d77fe0a55f087096" translate="yes" xml:space="preserve">
          <source>Used inside a DAV: propstat response element to avoid enumerating the internal members of multiple bindings to the same collection repeatedly.</source>
          <target state="translated">在DAV:propstat响应元素内使用,以避免重复枚举同一个集合的多个绑定的内部成员。</target>
        </trans-unit>
        <trans-unit id="44451c54c4073c5b244dfc14ec1273b05fc53e0e" translate="yes" xml:space="preserve">
          <source>Used to contain an HTTP cookie, previously sent by the server with the &lt;a href=&quot;headers/set-cookie2&quot;&gt;&lt;code&gt;Set-Cookie2&lt;/code&gt;&lt;/a&gt; header, but has been obsoleted by the specification. Use &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">用于包含HTTP cookie，该cookie以前由服务器使用&lt;a href=&quot;headers/set-cookie2&quot;&gt; &lt;code&gt;Set-Cookie2&lt;/code&gt; &lt;/a&gt;标头发送，但在规范中已作废。改用&lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b20d6e9692539ff76f2c433622b085813c4ed010" translate="yes" xml:space="preserve">
          <source>Used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">用于指示如何在公共搜索引擎结果中为网页建立索引。标题实际上等效于 &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9405a74f4eda686904f91b373876d189023d5ec" translate="yes" xml:space="preserve">
          <source>Used to list alternate ways to reach this service.</source>
          <target state="translated">用来列出联系该服务的其他方式。</target>
        </trans-unit>
        <trans-unit id="903aa38e08f404e0fe6134066bb4603722c02c8d" translate="yes" xml:space="preserve">
          <source>Used to redirect after a &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; to prevent a refresh of the page that would re-trigger the operation.</source>
          <target state="translated">用于在&lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;之后重定向，以防止刷新页面以重新触发该操作。</target>
        </trans-unit>
        <trans-unit id="02f36883721bfa91f003c55fe923c34d8b1123a0" translate="yes" xml:space="preserve">
          <source>Used to redirect after a &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, so that refreshing the result page doesn't re-trigger the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d08aee2da19cf95ec2fb45d662ac243b00d47d" translate="yes" xml:space="preserve">
          <source>Used to remove the &lt;a href=&quot;https://w3c.github.io/ServiceWorker/#path-restriction&quot;&gt;path restriction&lt;/a&gt; by including this header &lt;a href=&quot;https://w3c.github.io/ServiceWorker/#service-worker-script-response&quot;&gt;in the response of the Service Worker script&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fdc6d67d4d52e242748c4720010a7d9fc0ab0ad" translate="yes" xml:space="preserve">
          <source>Used to send cookies from the server to the user agent, but has been obsoleted by the specification. Use &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">用于将cookie从服务器发送到用户代理，但已被规范淘汰。请改用&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b62be9bca2e56c611a10053517163712a9e03fe9" translate="yes" xml:space="preserve">
          <source>Used to specify a server endpoint for the browser to send warning and error reports to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0095a76b4707f02952bc67d941d3c22eb71071f" translate="yes" xml:space="preserve">
          <source>Used to specify an allow-list of &lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;Trusted Types&lt;/a&gt; policies. Trusted Types allows applications to lock down DOM XSS injection sinks to only accept non-spoofable, typed values in place of strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac194550e6aaaaf4fc9e84fd643b08330514f82" translate="yes" xml:space="preserve">
          <source>Used to specify information in the &lt;a href=&quot;referer&quot;&gt;Referer&lt;/a&gt; (sic) header for links away from a page. Use the &lt;a href=&quot;referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f557f31b265b32e0da41b9f05f518d64277e5f0" translate="yes" xml:space="preserve">
          <source>Used to specify information in the referer (sic) header for links away from a page. Use the &lt;a href=&quot;referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">用于在引荐来源（sic）标头中为远离页面的链接指定信息。请改用&lt;a href=&quot;referrer-policy&quot;&gt; &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="f531ff014faf3edcc5032454c287c495bd6b92dc" translate="yes" xml:space="preserve">
          <source>Used to specify the compression algorithm.</source>
          <target state="translated">用于指定压缩算法。</target>
        </trans-unit>
        <trans-unit id="13fba396aeb16216bd521f7aa66eb44c4da1577d" translate="yes" xml:space="preserve">
          <source>Used when issuing a preflight request to let the server know which &lt;a href=&quot;methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">在发出预检请求时使用，以使服务器知道在发出实际请求时将使用哪种&lt;a href=&quot;methods&quot;&gt;HTTP方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2bd516d36772bd5ea2d67bbc4165b0dbce033d9a" translate="yes" xml:space="preserve">
          <source>Used when issuing a preflight request to let the server know which HTTP headers will be used when the actual request is made.</source>
          <target state="translated">在发出预检请求时使用,让服务器知道实际请求时将使用哪些HTTP头信息。</target>
        </trans-unit>
        <trans-unit id="8f9f2317df27b96fec34402a882717f5741a2312" translate="yes" xml:space="preserve">
          <source>User Agent</source>
          <target state="translated">用户代理</target>
        </trans-unit>
        <trans-unit id="96196c87ac2ee878b4abd2f4685a989aa9780951" translate="yes" xml:space="preserve">
          <source>User Agent string</source>
          <target state="translated">用户代理字符串</target>
        </trans-unit>
        <trans-unit id="f1851715072ef49470d2dfd3811ec1d1bac97021" translate="yes" xml:space="preserve">
          <source>User agents often have history mechanisms, such as &quot;Back&quot; buttons and
   history lists, that can be used to redisplay a representation
   retrieved earlier in a session.

   The freshness model (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;) does not necessarily apply to
   history mechanisms.  That is, a history mechanism can display a
   previous representation even if it has expired.

   This does not prohibit the history mechanism from telling the user
   that a view might be stale or from honoring cache directives (e.g.,
   Cache-Control: no-store).</source>
          <target state="translated">用户代理通常具有历史记录机制，例如&amp;ldquo;后退&amp;rdquo;按钮和历史记录列表，可用于重新显示会话中较早获取的表示形式。新鲜度模型（&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt;）不一定适用于历史记录机制。也就是说，历史记录机制即使已过期也可以显示先前的表示。这不会阻止历史记录机制告诉用户视图可能已过时或遵守缓存指令（例如，Cache-Control：无存储）。</target>
        </trans-unit>
        <trans-unit id="d4415ef6828595c5d51a025c59cf8000e72dad23" translate="yes" xml:space="preserve">
          <source>User agents often have history mechanisms, such as &quot;Back&quot; buttons and
   history lists, which can be used to redisplay an entity retrieved
   earlier in a session.

   History mechanisms and caches are different. In particular history
   mechanisms SHOULD NOT try to show a semantically transparent view of
   the current state of a resource. Rather, a history mechanism is meant
   to show exactly what the user saw at the time when the resource was
   retrieved.

   By default, an expiration time does not apply to history mechanisms.
   If the entity is still in storage, a history mechanism SHOULD display
   it even if the entity has expired, unless the user has specifically
   configured the agent to refresh expired history documents.

   This is not to be construed to prohibit the history mechanism from
   telling the user that a view might be stale.

      Note: if history list mechanisms unnecessarily prevent users from
      viewing stale resources, this will tend to force service authors
      to avoid using HTTP expiration controls and cache controls when
      they would otherwise like to. Service authors may consider it
      important that users not be presented with error messages or
      warning messages when they use navigation controls (such as BACK)
      to view previously fetched resources. Even though sometimes such
      resources ought not to cached, or ought to expire quickly, user
      interface considerations may force service authors to resort to
      other means of preventing caching (e.g. &quot;once-only&quot; URLs) in order
      not to suffer the effects of improperly functioning history
      mechanisms.</source>
          <target state="translated">用户代理通常具有历史机制,如 &quot;返回 &quot;按钮和历史列表,可用于重新显示会话中早期检索的实体。历史机制和缓存是不同的。特别是历史机制不应该试图显示资源当前状态的语义透明视图。相反,历史机制的目的是为了显示用户在检索资源时看到的确切内容。默认情况下,过期时间不适用于历史机制。如果实体仍在存储中,即使实体已经过期,历史机制也应该显示它,除非用户特别配置代理来刷新过期的历史文档。这不能解释为禁止历史机制告诉用户某个视图可能已经过期。注意:如果历史列表机制不必要地阻止用户查看陈旧的资源,这将倾向于迫使服务作者在本来想使用HTTP过期控制和缓存控制时避免使用。服务作者可能会认为,当用户使用导航控件(如BACK)来查看以前获取的资源时,不出现错误信息或警告信息是很重要的。尽管有时这类资源不应该被缓存,或者应该很快过期,但出于用户界面的考虑,服务作者可能会被迫采用其他手段来防止缓存(例如 &quot;只用一次 &quot;的URL),以避免受到不正常运行的历史机制的影响。</target>
        </trans-unit>
        <trans-unit id="ef8a5045e61510a061d2ed7f1794e270afbdc266" translate="yes" xml:space="preserve">
          <source>User preferences, themes, and other settings</source>
          <target state="translated">用户偏好、主题和其他设置</target>
        </trans-unit>
        <trans-unit id="170c6d2e56e8b4e9ec094b58afe212ec6e8296a6" translate="yes" xml:space="preserve">
          <source>User-Agent</source>
          <target state="translated">User-Agent</target>
        </trans-unit>
        <trans-unit id="1af81e21640faada944a6a51c7427107b23862dd" translate="yes" xml:space="preserve">
          <source>User-Agent (RFC 2616)</source>
          <target state="translated">用户代理(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9e418a2de2016f5489f400bdd59f7d98983152ae" translate="yes" xml:space="preserve">
          <source>User-Agent (RFC 7231)</source>
          <target state="translated">用户代理(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="e9f2acd9319796127c26633394cadcb61c4e6cb6" translate="yes" xml:space="preserve">
          <source>User-Agent detection, history and checklist</source>
          <target state="translated">用户-代理检测、历史和检查清单。</target>
        </trans-unit>
        <trans-unit id="25fb3b0fb82d92b257f4abf9c12069ad6ce3a8ba" translate="yes" xml:space="preserve">
          <source>User-Agent: Firefox</source>
          <target state="translated">用户代理:Firefox</target>
        </trans-unit>
        <trans-unit id="461246704acac5c978b021dbe1bb6946d4fb06af" translate="yes" xml:space="preserve">
          <source>Uses the non-standard name: &lt;code&gt;X-Content-Security-Policy&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b767622d82ebb5ed86e7d98876ac2c600c5e6b41" translate="yes" xml:space="preserve">
          <source>Uses the non-standard name: &lt;code&gt;X-Webkit-CSP&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc53525239d5487c05ac1087f6ca7d5f2f779901" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; with credentials:</source>
          <target state="translated">结合使用凭据&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;获取&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="775b0a348ff6d7feb24560ac7ae004af821cabfb" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XHR&lt;/a&gt; with credentials:</source>
          <target state="translated">结合使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XHR&lt;/a&gt;和凭据：</target>
        </trans-unit>
        <trans-unit id="50b3d158a5243f6906bff7679a67e75c48e89bc6" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;&lt;code&gt;&amp;lt;link rel=&quot;canonical&quot;&amp;gt;&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">使用&lt;em&gt; &lt;code&gt;&amp;lt;link rel=&quot;canonical&quot;&amp;gt;&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d058ec1d546ffd4724c08314ef307b7b9d7d0cf8" translate="yes" xml:space="preserve">
          <source>Using CORS - HTML5 Rocks</source>
          <target state="translated">使用 CORS-HTML5 Rocks</target>
        </trans-unit>
        <trans-unit id="d5b6aeeea8a183eae1980c322cfe2088cc4d812f" translate="yes" xml:space="preserve">
          <source>Using CORS with All (Modern) Browsers</source>
          <target state="translated">在所有(现代)浏览器中使用CORS。</target>
        </trans-unit>
        <trans-unit id="2b0657cfc18741e8d87d0fb3eecf2f7e48f046bf" translate="yes" xml:space="preserve">
          <source>Using CSP</source>
          <target state="translated">使用CSP</target>
        </trans-unit>
        <trans-unit id="2a075c7f234b30ed09767571bf0ceed43702253f" translate="yes" xml:space="preserve">
          <source>Using Early Data in HTTP</source>
          <target state="translated">在HTTP中使用早期数据</target>
        </trans-unit>
        <trans-unit id="95cb8ad5ba97958bfc77f7e47510a519e5b56075" translate="yes" xml:space="preserve">
          <source>Using Feature Policy</source>
          <target state="translated">使用特性策略</target>
        </trans-unit>
        <trans-unit id="faf834f6793fc3f5f4b06268382d98fe70168835" translate="yes" xml:space="preserve">
          <source>Using HTTP 301 redirects</source>
          <target state="translated">使用HTTP 301重定向</target>
        </trans-unit>
        <trans-unit id="d727a2f1b0f1ead6a5afe7b4b3b79b5d88a9496a" translate="yes" xml:space="preserve">
          <source>Using HTTP cookies allows you to link requests with the state of the server. This creates sessions, despite basic HTTP being a state-less protocol. This is useful not only for e-commerce shopping baskets, but also for any site allowing user configuration of the output.</source>
          <target state="translated">使用HTTP cookies可以让你将请求与服务器的状态联系起来。尽管基本的HTTP是一个无状态的协议,但这可以创建会话。这不仅对电子商务购物篮有用,而且对任何允许用户配置输出的网站也有用。</target>
        </trans-unit>
        <trans-unit id="65356d107d722c421bdf9afae2752bb3644268e5" translate="yes" xml:space="preserve">
          <source>Using HTTP for complex applications</source>
          <target state="translated">在复杂的应用中使用HTTP</target>
        </trans-unit>
        <trans-unit id="bdebe583c1966f4eb802f9db212ff788822f1b79" translate="yes" xml:space="preserve">
          <source>Using HTTP for secure transmissions</source>
          <target state="translated">使用HTTP进行安全传输</target>
        </trans-unit>
        <trans-unit id="d91da6c75dbce03772ce3e47bbb5354fb14b4b03" translate="yes" xml:space="preserve">
          <source>Using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element with an action set to inline JavaScript will result in a CSP violation.</source>
          <target state="translated">将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt;元素与设置为内联JavaScript的操作一起使用将导致CSP违规。</target>
        </trans-unit>
        <trans-unit id="4922a67e365ea567205aca17260f78c85648a98b" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;) with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f135cd288cff1c792d31f6c40167df8a81653f9" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;) with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="translated">使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt;结构（在&lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950中&lt;/a&gt;定义）和&lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt;压缩算法（在&lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951中&lt;/a&gt;定义）。</target>
        </trans-unit>
        <trans-unit id="f6d2f72f11bac70f52a4d8c1aa837dc886d98d35" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;), with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="translated">使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt;结构（在&lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950中&lt;/a&gt;定义）和&lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;放气&lt;/em&gt;&lt;/a&gt;压缩算法（在&lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951中&lt;/a&gt;定义）。</target>
        </trans-unit>
        <trans-unit id="381f4958cb832cb4d7530e7e9118ab47b34808f2" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure is accepted as a transfer coding name.</source>
          <target state="translated">接受使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt;结构作为传输编码名称。</target>
        </trans-unit>
        <trans-unit id="c06631425c8e2a5c38beb712ece2894d30377b7f" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;code&gt;allow&lt;/code&gt; attribute:</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;code&gt;allow&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="331593d404c541921d5682ea4724593568cd2784" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;Forwarded&lt;/code&gt; header</source>
          <target state="translated">使用 &lt;code&gt;Forwarded&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="9c88668cce11f173b8e79266db94e16cf90dd514" translate="yes" xml:space="preserve">
          <source>Using the Resource Timing API</source>
          <target state="translated">使用资源定时API</target>
        </trans-unit>
        <trans-unit id="fe1f968e579f2259eb8e8e4a023219aab908c00a" translate="yes" xml:space="preserve">
          <source>Usually a client will present a password prompt to the user and will then issue the request including the correct &lt;code&gt;Authorization&lt;/code&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d9d10dc421dffc12418b1ffd0ee9ed4d6c1255" translate="yes" xml:space="preserve">
          <source>Usually cached alternative service entries are cleared on network configuration changes. Use of the persist=1 parameter ensures that the entry is not deleted through such changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d9a9c22782754834063c5c87e532b570115167" translate="yes" xml:space="preserve">
          <source>VR / XR</source>
          <target state="translated">VR/XR</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="6ed0f1de5e048f3ac28333d0cfff3151dbc16735" translate="yes" xml:space="preserve">
          <source>Validation (RFC 7234)</source>
          <target state="translated">验证(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="712c6ea96c055017cf46eeff45a8bf53cd962f56" translate="yes" xml:space="preserve">
          <source>Validator header fields convey metadata about the selected
   representation (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).  In responses to safe requests, validator
   fields describe the selected representation chosen by the origin
   server while handling the response.  Note that, depending on the
   status code semantics, the selected representation for a given
   response is not necessarily the same as the representation enclosed
   as response payload.

   In a successful response to a state-changing request, validator
   fields describe the new representation that has replaced the prior
   selected representation as a result of processing the request.

   For example, an ETag header field in a 201 (Created) response
   communicates the entity-tag of the newly created resource's
   representation, so that it can be used in later conditional requests
   to prevent the &quot;lost update&quot; problem [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;].

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | ETag              | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7232]&lt;/a&gt; |
   | Last-Modified     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC7232]&lt;/a&gt; |
   +-------------------+--------------------------+</source>
          <target state="translated">验证程序标题字段传达有关所选表示形式的元数据（&lt;a href=&quot;#section-3&quot;&gt;第3节&lt;/a&gt;）。在对安全请求的响应中，验证器字段描述了原始服务器在处理响应时选择的所选表示形式。请注意，根据状态码的语义，给定响应的所选表示形式不一定与作为响应有效载荷包含的表示形式相同。在成功响应状态更改请求时，验证器字段将描述新的表示形式，该新表示形式已作为处理请求的结果替换了先前选择的表示形式。例如，201（已创建）响应中的ETag头字段传达新创建资源的表示形式的实体标签，以便可以在以后的条件请求中使用它来防止&amp;ldquo;丢失更新&amp;rdquo;问题[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]。+ ------------------- + -------------------------- + | 标头字段名称| 定义于... | + ------------------- + -------------------------- + | ETag | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]的2.3节&lt;/a&gt; | | 最后修改| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232]的2.2节&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="762f13c2259b5fbab6d8f1bdbab081fc48bc558f" translate="yes" xml:space="preserve">
          <source>Validators</source>
          <target state="translated">Validators</target>
        </trans-unit>
        <trans-unit id="dccad7c8797a5d7efc3bc914b1c32ba185470954" translate="yes" xml:space="preserve">
          <source>Validators come in two flavors: strong or weak.  Weak validators are
   easy to generate but are far less useful for comparisons.  Strong
   validators are ideal for comparisons but can be very difficult (and
   occasionally impossible) to generate efficiently.  Rather than impose
   that all forms of resource adhere to the same strength of validator,
   HTTP exposes the type of validator in use and imposes restrictions on
   when weak validators can be used as preconditions.

   A &quot;strong validator&quot; is representation metadata that changes value
   whenever a change occurs to the representation data that would be
   observable in the payload body of a 200 (OK) response to GET.

   A strong validator might change for reasons other than a change to
   the representation data, such as when a semantically significant part
   of the representation metadata is changed (e.g., Content-Type), but
   it is in the best interests of the origin server to only change the
   value when it is necessary to invalidate the stored responses held by
   remote caches and authoring tools.

   Cache entries might persist for arbitrarily long periods, regardless
   of expiration times.  Thus, a cache might attempt to validate an
   entry using a validator that it obtained in the distant past.  A
   strong validator is unique across all versions of all representations
   associated with a particular resource over time.  However, there is
   no implication of uniqueness across representations of different
   resources (i.e., the same strong validator might be in use for
   representations of multiple resources at the same time and does not
   imply that those representations are equivalent). 

   There are a variety of strong validators used in practice.  The best
   are based on strict revision control, wherein each change to a
   representation always results in a unique node name and revision
   identifier being assigned before the representation is made
   accessible to GET.  A collision-resistant hash function applied to
   the representation data is also sufficient if the data is available
   prior to the response header fields being sent and the digest does
   not need to be recalculated every time a validation request is
   received.  However, if a resource has distinct representations that
   differ only in their metadata, such as might occur with content
   negotiation over media types that happen to share the same data
   format, then the origin server needs to incorporate additional
   information in the validator to distinguish those representations.

   In contrast, a &quot;weak validator&quot; is representation metadata that might
   not change for every change to the representation data.  This
   weakness might be due to limitations in how the value is calculated,
   such as clock resolution, an inability to ensure uniqueness for all
   possible representations of the resource, or a desire of the resource
   owner to group representations by some self-determined set of
   equivalency rather than unique sequences of data.  An origin server
   SHOULD change a weak entity-tag whenever it considers prior
   representations to be unacceptable as a substitute for the current
   representation.  In other words, a weak entity-tag ought to change
   whenever the origin server wants caches to invalidate old responses.

   For example, the representation of a weather report that changes in
   content every second, based on dynamic measurements, might be grouped
   into sets of equivalent representations (from the origin server's
   perspective) with the same weak validator in order to allow cached
   representations to be valid for a reasonable period of time (perhaps
   adjusted dynamically based on server load or weather quality).
   Likewise, a representation's modification time, if defined with only
   one-second resolution, might be a weak validator if it is possible
   for the representation to be modified twice during a single second
   and retrieved between those modifications.

   Likewise, a validator is weak if it is shared by two or more
   representations of a given resource at the same time, unless those
   representations have identical representation data.  For example, if
   the origin server sends the same validator for a representation with
   a gzip content coding applied as it does for a representation with no
   content coding, then that validator is weak.  However, two
   simultaneous representations might share the same strong validator if
   they differ only in the representation metadata, such as when two
   different media types are available for the same representation data. 

   Strong validators are usable for all conditional requests, including
   cache validation, partial content ranges, and &quot;lost update&quot;
   avoidance.  Weak validators are only usable when the client does not
   require exact equality with previously obtained representation data,
   such as when validating a cache entry or limiting a web traversal to
   recent changes.</source>
          <target state="translated">验证器有两种口味:强验证器和弱验证器。弱验证器很容易生成,但对比较的作用就小得多。强验证器是比较的理想选择,但很难(有时甚至不可能)有效地生成。HTTP并没有强制要求所有形式的资源都遵守相同的验证器强度,而是公开了使用中的验证器类型,并对弱验证器何时可以作为前提条件使用进行了限制。一个 &quot;强验证器 &quot;是表示元数据,只要表示数据发生变化,它就会改变值,这些变化在GET的200(OK)响应的有效载荷体中是可以观察到的。强验证器可能会因为表征数据变化以外的原因而改变,例如当表征元数据中语义上重要的部分发生变化时(例如,Content-Type),但只有在有必要使远程缓存和编写工具所持有的存储响应无效时才改变该值,这符合源服务器的最佳利益。缓存条目可能会持续任意长的时间,而不考虑到期时间。因此,缓存可能会尝试使用它在遥远的过去获得的验证器来验证一个条目。一个强大的验证器在与某一特定资源相关联的所有表示的所有版本中,随着时间的推移是唯一的。但是,并不意味着不同资源的表征之间具有唯一性(即同一强验证器可能同时用于多个资源的表征,并不意味着这些表征是等价的)。实践中使用的强验证器有很多种。最好的是基于严格的修订控制,其中对一个表示的每次更改总是导致在表示被GET访问之前分配一个唯一的节点名称和修订标识符。如果数据在发送响应头字段之前就可以获得,并且不需要每次收到验证请求时都重新计算摘要,那么应用于表示数据的抗碰撞哈希函数也是足够的。然而,如果一个资源有不同的表示,只是在它们的元数据上有所不同,例如可能发生在内容协商上的媒体类型,而这些媒体类型恰好共享相同的数据格式,那么源服务器需要在验证器中加入额外的信息来区分这些表示。与此相反,&quot;弱验证器 &quot;是表示元数据可能不会因为表示数据的每次变化而改变。这种弱点可能是由于值的计算方式的限制,例如时钟分辨率,无法确保资源的所有可能的表示的唯一性,或者资源所有者希望通过一些自定的等价集合而不是唯一的数据序列来分组表示。每当原点服务器认为先前的表示不能作为当前表示的替代物时,它就应该改变弱实体标记。换句话说,每当起源服务器希望缓存使旧的响应无效时,弱实体标记就应该改变。例如,基于动态测量,每秒钟都会改变内容的天气报告的表示,可能会被分组为具有相同弱验证器的等价表示的集合(从起源服务器的角度来看),以允许缓存的表示在合理的时间内有效(也许会根据服务器负载或天气质量动态调整)。同样,一个表征的修改时间,如果只用一秒的分辨率来定义,如果表征有可能在一秒内被修改两次,并且在这两次修改之间被检索,那么这个表征可能就是一个弱验证器。同样,如果一个验证器被一个给定资源的两个或多个表示同时共享,那么这个验证器就是弱的,除非这些表示具有相同的表示数据。例如,如果源服务器为一个应用了 gzip 内容编码的表示发送的验证器与为一个没有内容编码的表示发送的验证器相同,那么这个验证器就是弱的。然而,如果两个同时进行的表征仅在表征元数据上有不同,那么它们可能共享同一个强验证器,例如当同一表征数据有两种不同的媒体类型时。强验证器可用于所有条件请求,包括缓存验证、部分内容范围和 &quot;丢失更新 &quot;避免。弱验证器只有在客户端不要求与先前获得的表示数据完全相同时才可用,例如验证缓存条目或将网络遍历限制为最近的变化时。</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="95995420eab6703ad8a4f2ba7da6319b9b43e40d" translate="yes" xml:space="preserve">
          <source>Values for a CSS stylesheet</source>
          <target state="translated">CSS样式表的值</target>
        </trans-unit>
        <trans-unit id="a5ef8687b052a94f11db08f4f679818138d67288" translate="yes" xml:space="preserve">
          <source>Values for a video</source>
          <target state="translated">视频的数值</target>
        </trans-unit>
        <trans-unit id="4d9dcfc6daf7e146bae84e76afccb728e632f028" translate="yes" xml:space="preserve">
          <source>Values for an image</source>
          <target state="translated">图像的数值</target>
        </trans-unit>
        <trans-unit id="0022bf43f5fac9f98b34676d218d78927c174e9e" translate="yes" xml:space="preserve">
          <source>Values for audio resources</source>
          <target state="translated">音频资源的价值</target>
        </trans-unit>
        <trans-unit id="d5707d69daa9b8c62fb80486ceff04ff21fd84f0" translate="yes" xml:space="preserve">
          <source>Values for scripts</source>
          <target state="translated">脚本的数值</target>
        </trans-unit>
        <trans-unit id="2b24d45fc35a156981b37ec34e29d99633f90ceb" translate="yes" xml:space="preserve">
          <source>Vary</source>
          <target state="translated">Vary</target>
        </trans-unit>
        <trans-unit id="9b2e108b3f882316723628f809864b1feb7974b4" translate="yes" xml:space="preserve">
          <source>Vary (RFC 2616)</source>
          <target state="translated">变化(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="e40dcd8515c2cf843fee10b24ff8980777ae7ffa" translate="yes" xml:space="preserve">
          <source>Vary (RFC 7231)</source>
          <target state="translated">变化(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="7b2b0d3e57119ab5faa1b67d5efd6c7de0e7f709" translate="yes" xml:space="preserve">
          <source>Vary with care &amp;ndash; Vary header problems in IE6-9</source>
          <target state="translated">小心更改&amp;ndash; IE6-9中的标题问题</target>
        </trans-unit>
        <trans-unit id="19eb9e0947788d5d1d26e214c7f03629eeb827cb" translate="yes" xml:space="preserve">
          <source>Varying responses</source>
          <target state="translated">变化的反应</target>
        </trans-unit>
        <trans-unit id="cd93e3881536fce26e72a7e663780b36bdbdb4a8" translate="yes" xml:space="preserve">
          <source>Version 3 (and probably earlier) of Firefox for Fire TV use a user agent string with the following format:</source>
          <target state="translated">第3版(可能是更早的版本)的Firefox for Fire TV使用了一个格式如下的用户代理字符串。</target>
        </trans-unit>
        <trans-unit id="a69e9865ae8f4c198fd5ee0e05c338894a1f0bbb" translate="yes" xml:space="preserve">
          <source>Version 7 of Focus for iOS uses a user agent string with the following format:</source>
          <target state="translated">iOS版Focus使用的用户代理字符串格式如下。</target>
        </trans-unit>
        <trans-unit id="38993cc538cc5926945d26ae695bf9289c5f5b16" translate="yes" xml:space="preserve">
          <source>Version number of the product.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297d1a34c5a91c3face08ee659f305e1a1a91054" translate="yes" xml:space="preserve">
          <source>Versioning information is now sent within each request (&lt;code&gt;HTTP/1.0&lt;/code&gt; is appended to the &lt;code&gt;GET&lt;/code&gt; line)</source>
          <target state="translated">现在在每个请求中发送版本信息（ &lt;code&gt;HTTP/1.0&lt;/code&gt; 附加到 &lt;code&gt;GET&lt;/code&gt; 行）</target>
        </trans-unit>
        <trans-unit id="69a7be7d74e8b54ef69683eb73c3addbe24661a5" translate="yes" xml:space="preserve">
          <source>Via</source>
          <target state="translated">Via</target>
        </trans-unit>
        <trans-unit id="5efffb1f13385b4c17fcaf2a54ce6c61c3ffee1f" translate="yes" xml:space="preserve">
          <source>Via (RFC 2616)</source>
          <target state="translated">通过(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="600beac1ac4f104310961c0df27d3fda7e13e76a" translate="yes" xml:space="preserve">
          <source>Video data or files, such as MP4 movies (&lt;code&gt;video/mp4&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876d409a2453771f3498295f0ec1ad8b311c1abe" translate="yes" xml:space="preserve">
          <source>Video formats on the Web are lossy and for images, &lt;code&gt;jpeg&lt;/code&gt; is.</source>
          <target state="translated">网络上的视频格式是有损的，对于图像， &lt;code&gt;jpeg&lt;/code&gt; 是有损的。</target>
        </trans-unit>
        <trans-unit id="b8e388ceed1411c403014aaf99cf7852f8214b26" translate="yes" xml:space="preserve">
          <source>Video formats on the Web are lossy; the &lt;code&gt;jpeg&lt;/code&gt; image format is also lossy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa07f2310615edb1b8aea001b9424df7324bc70" translate="yes" xml:space="preserve">
          <source>Violation case</source>
          <target state="translated">违规案件</target>
        </trans-unit>
        <trans-unit id="e27cced9fe19bc714fee1a81671a7f569628e245" translate="yes" xml:space="preserve">
          <source>Violation cases</source>
          <target state="translated">违规案件</target>
        </trans-unit>
        <trans-unit id="c496e3c34f0eba7e144fe804c7ad8671f57cafe2" translate="yes" xml:space="preserve">
          <source>Violation report syntax</source>
          <target state="translated">违章报告的语法</target>
        </trans-unit>
        <trans-unit id="d5008ff9b05d4e106caa52d46336fe823818f4b8" translate="yes" xml:space="preserve">
          <source>W3C Note: Editing the Web &amp;ndash; Detecting the Lost Update Problem Using Unreserved Checkout</source>
          <target state="translated">W3C注意：编辑Web &amp;ndash;使用未保留的签出检测丢失的更新问题</target>
        </trans-unit>
        <trans-unit id="884f3317cb1124a8431120b58009200dca7a4d67" translate="yes" xml:space="preserve">
          <source>WEBM audio</source>
          <target state="translated">WEBM音频</target>
        </trans-unit>
        <trans-unit id="a9048e6f38bd6def914e8bc02c0c815e74aa6b31" translate="yes" xml:space="preserve">
          <source>WEBM video</source>
          <target state="translated">WEBM视频</target>
        </trans-unit>
        <trans-unit id="10d4da79ed320e304a4183b2724689aacff736ee" translate="yes" xml:space="preserve">
          <source>WEBP image</source>
          <target state="translated">WEBP图片</target>
        </trans-unit>
        <trans-unit id="91e15dfd33a8977326ec3048fffcf2851f9ab5d0" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate</source>
          <target state="translated">WWW-Authenticate</target>
        </trans-unit>
        <trans-unit id="66096447ca6339831faa35cab2472b54e0d02b68" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate (RFC 2616)</source>
          <target state="translated">WWW-Authenticate (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="10ca8f25b6696fb63530265acb249b906a791bb0" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate (RFC 7235)</source>
          <target state="translated">WWW-Authenticate (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="f6d051699bd0f43788b5be58a23eb21f84335023" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate and Proxy-Authenticate headers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="be4d2f140ad1f885bd4fd65204345d7cda73e466" translate="yes" xml:space="preserve">
          <source>Warning (RFC 2616)</source>
          <target state="translated">警告(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="84bedb41c866653578afdf5c8ba922625099fff2" translate="yes" xml:space="preserve">
          <source>Warning (RFC 7234)</source>
          <target state="translated">警告(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="a947928bc7f59190ce4b3eb8f6b60da4b597dfb2" translate="yes" xml:space="preserve">
          <source>Warning codes</source>
          <target state="translated">警告代码</target>
        </trans-unit>
        <trans-unit id="98d22e2da9720c80cb3f1a3c48430a5ba47ef6df" translate="yes" xml:space="preserve">
          <source>Was defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.</source>
          <target state="translated">在以前的HTTP规范版本中被定义为表示请求的响应必须由代理访问。由于对代理的带内配置的安全考虑,它已被废弃。</target>
        </trans-unit>
        <trans-unit id="b65b1ec95e015e3a3a9a72a92184b75a39063c7e" translate="yes" xml:space="preserve">
          <source>Waveform Audio Format</source>
          <target state="translated">波形音频格式</target>
        </trans-unit>
        <trans-unit id="3614aa76f325a8581f86ebecc652236220abab3a" translate="yes" xml:space="preserve">
          <source>Ways to mitigate attacks involving cookies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ed8d07477aa173249b6733f07e79520338b110" translate="yes" xml:space="preserve">
          <source>We adopt a set of rules and recommendations for origin servers,
   clients, and caches regarding when various validator types ought to
   be used, and for what purposes.

   HTTP/1.1 origin servers:

      - SHOULD send an entity tag validator unless it is not feasible to
        generate one.

      - MAY send a weak entity tag instead of a strong entity tag, if
        performance considerations support the use of weak entity tags,
        or if it is unfeasible to send a strong entity tag.

      - SHOULD send a Last-Modified value if it is feasible to send one,
        unless the risk of a breakdown in semantic transparency that
        could result from using this date in an If-Modified-Since header
        would lead to serious problems.

   In other words, the preferred behavior for an HTTP/1.1 origin server
   is to send both a strong entity tag and a Last-Modified value.

   In order to be legal, a strong entity tag MUST change whenever the
   associated entity value changes in any way. A weak entity tag SHOULD
   change whenever the associated entity changes in a semantically
   significant way.

      Note: in order to provide semantically transparent caching, an
      origin server must avoid reusing a specific strong entity tag
      value for two different entities, or reusing a specific weak
      entity tag value for two semantically different entities. Cache
      entries might persist for arbitrarily long periods, regardless of
      expiration times, so it might be inappropriate to expect that a
      cache will never again attempt to validate an entry using a
      validator that it obtained at some point in the past.

   HTTP/1.1 clients:

      - If an entity tag has been provided by the origin server, MUST
        use that entity tag in any cache-conditional request (using If-
        Match or If-None-Match).

      - If only a Last-Modified value has been provided by the origin
        server, SHOULD use that value in non-subrange cache-conditional
        requests (using If-Modified-Since). 

      - If only a Last-Modified value has been provided by an HTTP/1.0
        origin server, MAY use that value in subrange cache-conditional
        requests (using If-Unmodified-Since:). The user agent SHOULD
        provide a way to disable this, in case of difficulty.

      - If both an entity tag and a Last-Modified value have been
        provided by the origin server, SHOULD use both validators in
        cache-conditional requests. This allows both HTTP/1.0 and
        HTTP/1.1 caches to respond appropriately.

   An HTTP/1.1 origin server, upon receiving a conditional request that
   includes both a Last-Modified date (e.g., in an If-Modified-Since or
   If-Unmodified-Since header field) and one or more entity tags (e.g.,
   in an If-Match, If-None-Match, or If-Range header field) as cache
   validators, MUST NOT return a response status of 304 (Not Modified)
   unless doing so is consistent with all of the conditional header
   fields in the request.

   An HTTP/1.1 caching proxy, upon receiving a conditional request that
   includes both a Last-Modified date and one or more entity tags as
   cache validators, MUST NOT return a locally cached response to the
   client unless that cached response is consistent with all of the
   conditional header fields in the request.

      Note: The general principle behind these rules is that HTTP/1.1
      servers and clients should transmit as much non-redundant
      information as is available in their responses and requests.
      HTTP/1.1 systems receiving this information will make the most
      conservative assumptions about the validators they receive.

      HTTP/1.0 clients and caches will ignore entity tags. Generally,
      last-modified values received or used by these systems will
      support transparent and efficient caching, and so HTTP/1.1 origin
      servers should provide Last-Modified values. In those rare cases
      where the use of a Last-Modified value as a validator by an
      HTTP/1.0 system could result in a serious problem, then HTTP/1.1
      origin servers should not provide one.</source>
          <target state="translated">我们为源服务器、客户端和缓存采用了一套规则和建议,涉及到什么时候应该使用各种验证器类型,以及用于什么目的。HTTP/1.1起源服务器。-应该发送一个实体标签验证器,除非无法生成。-如果性能方面的考虑支持使用弱实体标签,或者发送强实体标签不可行,可以发送弱实体标签而不是强实体标签。-如果可以发送Last-Modified值,那么应该发送Last-Modified值,除非在If-Modified-Since头中使用这个日期会导致语义透明度崩溃的风险,从而导致严重的问题。换句话说,HTTP/1.1 源服务器的首选行为是同时发送一个强实体标签和一个 Last-Modified 值。为了合法,一个强实体标签必须在相关实体值以任何方式改变时改变。每当相关实体以语义上重要的方式改变时,弱实体标签必须改变。注意:为了提供语义透明的缓存,源服务器必须避免对两个不同的实体重复使用特定的强实体标签值,或者对两个语义不同的实体重复使用特定的弱实体标签值。缓存条目可能会持续任意长的时间,不管过期时间如何,因此,期望缓存永远不会再尝试使用它在过去某个时刻获得的验证器来验证一个条目可能是不合适的。HTTP/1.1客户端。-如果源服务器提供了一个实体标签,必须在任何缓存条件请求中使用该实体标签(使用If-Match或If-None-Match)。-如果只有一个Last-Modified的值是由源服务器提供的,那么在非子范围的缓存条件请求中必须使用该值(使用If-Modified-Since)。-如果HTTP/1.0源服务器只提供了Last-Modified值,可以在子范围缓存条件请求中使用该值(使用If-Unmodified-Since:)。如果有困难,用户代理应该提供一种方法来禁用这个功能。-如果实体标签和Last-Modified值都是由源服务器提供的,那么在缓存条件请求中应该使用这两个验证器。这样可以让HTTP/1.0和HTTP/1.1缓存都能做出适当的响应。当HTTP/1.1源服务器接收到包含Last-Modified日期(例如,在If-Modified-Since或If-Unmodified-Since头域中)和一个或多个实体标记(例如,在If-匹配、If-None-匹配或If-Range头域中)作为缓存验证器的条件请求时,必须不返回304(未修改)的响应状态,除非这样做与请求中所有的条件头域一致。一个HTTP/1.1缓存代理,在收到一个包含Last-Modified日期和一个或多个实体标签作为缓存验证器的条件请求时,必须不返回一个本地缓存的响应给客户端,除非该缓存响应与请求中所有的条件头字段一致。注意:这些规则背后的一般原则是,HTTP/1.1服务器和客户端应该在其响应和请求中尽可能多地传输非冗余信息。接收这些信息的HTTP/1.1系统将对他们接收的验证器做出最保守的假设。HTTP/1.0客户端和缓存将忽略实体标签。一般来说,这些系统接收或使用的最后修改值将支持透明和高效的缓存,因此HTTP/1.1源服务器应该提供Last-Modified值。在极少数情况下,如果HTTP/1.0系统使用Last-Modified值作为验证器,可能会导致严重的问题,那么HTTP/1.1源服务器就不应该提供Last-Modified值。</target>
        </trans-unit>
        <trans-unit id="cbefa43c4244c9659990b7c712219c66a3ed30c8" translate="yes" xml:space="preserve">
          <source>We can request a single range from a resource. Again, we can test a request by using cURL. The &quot;&lt;code&gt;-H&lt;/code&gt;&quot; option will append a header line to the request, which in this case is the &lt;code&gt;Range&lt;/code&gt; header requesting the first 1024 bytes.</source>
          <target state="translated">我们可以从资源中请求一个范围。同样，我们可以使用cURL测试请求。 &amp;ldquo; &lt;code&gt;-H&lt;/code&gt; &amp;rdquo;选项将在请求后添加标题行，在这种情况下，该行是请求前1024个字节的 &lt;code&gt;Range&lt;/code&gt; 标题。</target>
        </trans-unit>
        <trans-unit id="b6a9bbf12e8ee0277600f2ecdeea60a7f6ed55e7" translate="yes" xml:space="preserve">
          <source>We present three scenarios that demonstrate how Cross-Origin Resource Sharing works. All these examples use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, which can make cross-site requests in any supporting browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36fd34ea11996b6fcd900ac461a83c9aca72d5f" translate="yes" xml:space="preserve">
          <source>Weak validation</source>
          <target state="translated">验证不力</target>
        </trans-unit>
        <trans-unit id="1bbd54b41e2dcd60140061474c56461a3b1017b8" translate="yes" xml:space="preserve">
          <source>Weak validation differs from strong validation, as it considers two versions of the document as identical if the content is equivalent. For example, a page that would differ from another only by a different date in its footer, or different advertising, would be considered &lt;em&gt;identical&lt;/em&gt; to the other with weak validation. These same two versions are considered &lt;em&gt;different&lt;/em&gt; when using strong validation. Building a system of etags that creates weak validation may be complex, as it involves knowing the importance of the different elements of a page, but is very useful towards optimizing cache performance.</source>
          <target state="translated">弱验证与强验证不同，因为如果内容相同，它将认为文档的两个版本相同。例如，一个页面与另一个页面的差异仅在于页脚的日期不同或广告不同，这将被视为&lt;em&gt;与&lt;/em&gt;验证效果较弱的另一个页面&lt;em&gt;相同&lt;/em&gt;。使用强验证时，这两个相同的版本被认为是&lt;em&gt;不同的&lt;/em&gt;。构建一个创建弱验证的etags系统可能很复杂，因为它涉及了解页面不同元素的重要性，但是对于优化缓存性能非常有用。</target>
        </trans-unit>
        <trans-unit id="81b0091d349f7e8dabfa6f00aa81829d266ffe7f" translate="yes" xml:space="preserve">
          <source>Weak versus Strong (RFC 7232)</source>
          <target state="translated">弱与强(RFC 7232)</target>
        </trans-unit>
        <trans-unit id="846bec671d05b4a9c57d268a32b9ca23d81cc1ef" translate="yes" xml:space="preserve">
          <source>Web Fonts (for cross-domain font usage in &lt;code&gt;@font-face&lt;/code&gt; within CSS), &lt;a href=&quot;https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements&quot;&gt;so that servers can deploy TrueType fonts that can only be cross-site loaded and used by web sites that are permitted to do so.&lt;/a&gt;</source>
          <target state="translated">Web字体（用于CSS 中 &lt;code&gt;@font-face&lt;/code&gt; 的跨域字体使用），&lt;a href=&quot;https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements&quot;&gt;以便服务器可以部署TrueType字体，这些字体只能跨站点加载并允许被允许的网站使用。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="176255fee5b73645d93cc65c9bf7cc53c9096411" translate="yes" xml:space="preserve">
          <source>Web Linking</source>
          <target state="translated">网站链接</target>
        </trans-unit>
        <trans-unit id="7fde211ec2ffa63e011d15d658c6456ee3361232" translate="yes" xml:space="preserve">
          <source>Web Open Font Format (WOFF)</source>
          <target state="translated">网络开放字体格式(WOFF)</target>
        </trans-unit>
        <trans-unit id="5f3f450e346fdae22197c1f6b75eaf5e058000c1" translate="yes" xml:space="preserve">
          <source>Web Picture format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d14f7b44c057d129ff61e05ff9ce4d6f2fc29a" translate="yes" xml:space="preserve">
          <source>Web Share API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd59440b016b6287e24e59a96a86e62ba9ba00ba" translate="yes" xml:space="preserve">
          <source>Web app manifest</source>
          <target state="translated">网络应用清单</target>
        </trans-unit>
        <trans-unit id="bda95fb3fa91f3d265697fb24bb06ea2572d20c9" translate="yes" xml:space="preserve">
          <source>Web developers invented a technique that Steve Souders called &lt;em&gt;revving&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Infrequently updated files are named in a specific way: in their URL, usually in the filename, a revision (or version) number is added. That way each new revision of this resource is considered as a resource on its own that &lt;em&gt;never&lt;/em&gt; changes and that can have an expiration time very far in the future, usually one year or even more. In order to have the new versions, all the links to them must be changed, that is the drawback of this method: additional complexity that is usually taken care of by the tool chain used by Web developers. When the infrequently variable resources change they induce an additional change to often variable resources. When these are read, the new versions of the others are also read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aae5e4ef23e3484617aad036f6f0942d85a4a3d" translate="yes" xml:space="preserve">
          <source>Web developers invented a technique that Steve Souders called &lt;em&gt;revving&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Infrequently updated files are named in specific way: in their URL, usually in the filename, a revision (or version) number is added. That way each new revision of this resource is considered as a resource on its own that &lt;em&gt;never&lt;/em&gt; changes and that can have an expiration time very far in the future, usually one year or even more. In order to have the new versions, all the links to them must be changed, that is the drawback of this method: additional complexity that is usually taken care of by the tool chain used by Web developers. When the infrequently variable resources change they induce an additional change to often variable resources. When these are read, the new versions of the others are also read.</source>
          <target state="translated">Web开发人员发明了Steve Souders称之为&lt;em&gt;revving&lt;/em&gt;的技术&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;。很少更新的文件以特定的方式命名：在它们的URL中（通常在文件名中）添加修订（或版本）号。这样，此资源的每个新修订版都被视为独立的资源，&lt;em&gt;永远不会&lt;/em&gt;更改，并且可能会在很远的将来到期，通常是一年或更长时间。为了拥有新版本，必须更改指向它们的所有链接，这是此方法的缺点：额外的复杂性通常由Web开发人员使用的工具链来解决。当不经常变化的资源发生变化时，它们会引起对经常变化的资源的附加变化。读取这些文件时，还将读取其他文件的新版本。</target>
        </trans-unit>
        <trans-unit id="c70b0ff6920fb5d4f64386ac826550f70e1ff8e1" translate="yes" xml:space="preserve">
          <source>Web developers, or webmasters, rarely craft these textual HTTP messages themselves: software, a Web browser, proxy, or Web server, perform this action. They provide HTTP messages through config files (for proxies or servers), APIs (for browsers), or other interfaces.</source>
          <target state="translated">网络开发者,或者说网络管理员,很少自己制作这些文本HTTP消息:软件,网络浏览器,代理服务器,或者网络服务器,执行这个动作。它们通过配置文件(对于代理或服务器)、API(对于浏览器)或其他接口提供HTTP消息。</target>
        </trans-unit>
        <trans-unit id="8d4119ff2982c9f860674f920c336448cc016413" translate="yes" xml:space="preserve">
          <source>Web media technologies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83eb70bb9b9c1cc810a2c336b4e785e9b89447dd" translate="yes" xml:space="preserve">
          <source>Web sites can easily collect Firefox default preferences by overriding this &lt;code&gt;pref()&lt;/code&gt; function and using the script &lt;code&gt;resource:///defaults/preferences/firefox.js&lt;/code&gt;.</source>
          <target state="translated">通过覆盖此 &lt;code&gt;pref()&lt;/code&gt; 函数并使用脚本 &lt;code&gt;resource:///defaults/preferences/firefox.js&lt;/code&gt; ,网站可以轻松地收集Firefox默认首选项。</target>
        </trans-unit>
        <trans-unit id="051061c35dede06e751f127657cfd8dabc9b47ce" translate="yes" xml:space="preserve">
          <source>WebAssembly</source>
          <target state="translated">WebAssembly</target>
        </trans-unit>
        <trans-unit id="e993b7a84cae2379869728d12f4d33cde0391ee7" translate="yes" xml:space="preserve">
          <source>WebDAV provides the ability to send a LOCK request to an unmapped URL
   in order to reserve the name for use.  This is a simple way to avoid
   the lost-update problem on the creation of a new resource (another
   way is to use If-None-Match header specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.26&quot;&gt;Section&amp;nbsp;14.26 of
   [RFC2616]&lt;/a&gt;).  It has the side benefit of locking the new resource
   immediately for use of the creator.

   Note that the lost-update problem is not an issue for collections
   because MKCOL can only be used to create a collection, not to
   overwrite an existing collection.  When trying to lock a collection
   upon creation, clients can attempt to increase the likelihood of
   getting the lock by pipelining the MKCOL and LOCK requests together
   (but because this doesn't convert two separate operations into one
   atomic operation, there's no guarantee this will work).

   A successful lock request to an unmapped URL MUST result in the
   creation of a locked (non-collection) resource with empty content.
   Subsequently, a successful PUT request (with the correct lock token)
   provides the content for the resource.  Note that the LOCK request
   has no mechanism for the client to provide Content-Type or Content-
   Language, thus the server will use defaults or empty values and rely
   on the subsequent PUT request for correct values.

   A resource created with a LOCK is empty but otherwise behaves in
   every way as a normal resource.  It behaves the same way as a
   resource created by a PUT request with an empty body (and where a
   Content-Type and Content-Language was not specified), followed by a
   LOCK request to the same resource.  Following from this model, a
   locked empty resource:

   o  Can be read, deleted, moved, and copied, and in all ways behaves
      as a regular non-collection resource.

   o  Appears as a member of its parent collection.

   o  SHOULD NOT disappear when its lock goes away (clients must
      therefore be responsible for cleaning up their own mess, as with
      any other operation or any non-empty resource). 

   o  MAY NOT have values for properties like DAV:getcontentlanguage
      that haven't been specified yet by the client.

   o  Can be updated (have content added) with a PUT request.

   o  MUST NOT be converted into a collection.  The server MUST fail a
      MKCOL request (as it would with a MKCOL request to any existing
      non-collection resource).

   o  MUST have defined values for DAV:lockdiscovery and DAV:
      supportedlock properties.

   o  The response MUST indicate that a resource was created, by use of
      the &quot;201 Created&quot; response code (a LOCK request to an existing
      resource instead will result in 200 OK).  The body must still
      include the DAV:lockdiscovery property, as with a LOCK request to
      an existing resource.

   The client is expected to update the locked empty resource shortly
   after locking it, using PUT and possibly PROPPATCH.

   Alternatively and for backwards compatibility to [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;], servers
   MAY implement Lock-Null Resources (LNRs) instead (see definition in
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;).  Clients can easily interoperate both with servers that
   support the old model LNRs and the recommended model of &quot;locked empty
   resources&quot; by only attempting PUT after a LOCK to an unmapped URL,
   not MKCOL or GET, and by not relying on specific properties of LNRs.</source>
          <target state="translated">WebDAV提供了将LOCK请求发送到未映射的URL的功能，以保留该名称以供使用。这是避免在创建新资源时丢失更新问题的简单方法（另一种方法是使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.26&quot;&gt;[RFC2616]第14.26节中&lt;/a&gt;指定的If-None-Match标头。）。它具有立即锁定新资源以供创建者使用的附带好处。请注意，丢失更新问题对于集合而言不是问题，因为MKCOL仅可用于创建集合，而不能覆盖现有集合。尝试在创建时锁定集合时，客户端可以尝试通过将MKCOL和LOCK请求一起流水线化来增加获得锁定的可能性（但是由于这不会将两个单独的操作转换为一个原子操作，因此无法保证这将起作用）。对未映射URL的成功锁定请求必须导致创建内容为空的锁定（非集合）资源。随后，成功的PUT请求（带有正确的锁定令牌）将提供资源的内容。请注意，LOCK请求没有机制让客户端提供Content-Type或Content-Language，因此服务器将使用默认值或空值，并依赖后续的PUT请求获得正确的值。用LOCK创建的资源为空，但在其他方面都表现为普通资源。它的行为与由空主体（未指定Content-Type和Content-Language的PUT请求）创建的资源相同，然后对同一资源进行LOCK请求。根据此模型，锁定了一个空资源：o可以读取，删除，移动和复制，并且在所有方面均表现为常规的非集合资源。 o出现为其父集合的成员。o锁消失后不应消失（因此，客户端必须负责清理自己的混乱，就像其他任何操作或任何非空资源一样）。 o可能没有客户端尚未指定的属性值，例如DAV：getcontentlanguage。 o可以通过PUT请求进行更新（添加了内容）。 o不得转换为集合。服务器必须使MKCOL请求失败（就像对任何现有非收集资源的MKCOL请求一样）。 o必须为DAV：lockdiscovery和DAV：supportedlock属性定义值。 o响应务必指示使用&amp;ldquo; 201 Created&amp;rdquo;响应代码创建了资源（对现有资源的LOCK请求将导致200 OK）。该主体仍必须包括DAV：lockdiscovery属性，就像对现有资源的LOCK请求一样。期望客户端在锁定后使用PUT和可能的PROPPATCH更新锁定的空资源后不久。另外，为了向后兼容[&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;），服务器可以改为实现锁空资源（LNR）（参见&lt;a href=&quot;#appendix-D&quot;&gt;附录D中的&lt;/a&gt;定义 ）。通过仅在锁定到未映射的URL（而不是MKCOL或GET）之后尝试PUT，并且不依赖LNR的特定属性，客户端可以轻松地与支持旧模型LNR的服务器和建议的&amp;ldquo;锁定空资源&amp;rdquo;模型进行互操作。</target>
        </trans-unit>
        <trans-unit id="a23e5cc615236bc8c759c172e1a9673963c88638" translate="yes" xml:space="preserve">
          <source>WebDAV provides, through the PROPFIND method, a mechanism for listing
   the member resources of a collection.  This greatly diminishes the
   effectiveness of security or privacy techniques that rely only on the
   difficulty of discovering the names of network resources.  Users of
   WebDAV servers are encouraged to use access control techniques to
   prevent unwanted access to resources, rather than depending on the
   relative obscurity of their resource names.</source>
          <target state="translated">WebDAV通过PROPFIND方法提供了一个列出集合成员资源的机制。这大大降低了仅依靠难以发现网络资源名称的安全或隐私技术的有效性。我们鼓励WebDAV服务器的用户使用访问控制技术来防止对资源的意外访问,而不是依赖资源名称的相对模糊性。</target>
        </trans-unit>
        <trans-unit id="f85551b99b1731274ca28a740445b7fb39846ad8" translate="yes" xml:space="preserve">
          <source>WebDAV was designed to be, and has been found to be, backward-
   compatible with HTTP 1.1.  The PUT and DELETE methods are defined in
   HTTP and thus may be used by HTTP clients as well as WebDAV-aware
   clients, but the responses to PUT and DELETE have been extended in
   this specification in ways that only a WebDAV client would be
   entirely prepared for.  Some theoretical concerns were raised about
   whether those responses would cause interoperability problems with
   HTTP-only clients, and this section addresses those concerns.

   Since any HTTP client ought to handle unrecognized 400-level and 500-
   level status codes as errors, the following new status codes should
   not present any issues: 422, 423, and 507 (424 is also a new status
   code but it appears only in the body of a Multistatus response.)  So,
   for example, if an HTTP client attempted to PUT or DELETE a locked
   resource, the 423 Locked response ought to result in a generic error
   presented to the user.

   The 207 Multistatus response is interesting because an HTTP client
   issuing a DELETE request to a collection might interpret a 207
   response as a success, even though it does not realize the resource
   is a collection and cannot understand that the DELETE operation might
   have been a complete or partial failure.  That interpretation isn't
   entirely justified, because a 200-level response indicates that the
   server &quot;received, understood, and accepted&quot; the request, not that the
   request resulted in complete success.

   One option is that a server could treat a DELETE of a collection as
   an atomic operation, and use either 204 No Content in case of
   success, or some appropriate error response (400 or 500 level) for an
   error.  This approach would indeed maximize backward compatibility.
   However, since interoperability tests and working group discussions
   have not turned up any instances of HTTP clients issuing a DELETE
   request against a WebDAV collection, this concern is more theoretical
   than practical.  Thus, servers are likely to be completely successful
   at interoperating with HTTP clients even if they treat any collection
   DELETE request as a WebDAV request and send a 207 Multi-Status
   response.

   In general, server implementations are encouraged to use the detailed
   responses and other mechanisms defined in this document rather than
   make changes for theoretical interoperability concerns.</source>
          <target state="translated">WebDAV被设计为,并且已经被发现是向后兼容HTTP 1.1的。PUT和DELETE方法是在HTTP中定义的,因此HTTP客户机和WebDAV感知客户机都可以使用,但是本规范中对PUT和DELETE的响应进行了扩展,只有WebDAV客户机才会完全准备好。有人提出了一些理论上的担忧,担心这些响应是否会导致与纯HTTP客户端的互操作性问题,本节将解决这些担忧。由于任何HTTP客户端都应该将未识别的400级和500级状态码作为错误处理,因此以下新的状态码应该不会带来任何问题。422、423和507(424也是一个新的状态码,但它只出现在Multistatus响应的主体中)。因此,举例来说,如果一个HTTP客户端试图PUT或DELETE一个锁定的资源,423 Locked响应应该会导致一个通用的错误呈现给用户。207 Multistatus响应很有意思,因为一个HTTP客户端向一个集合发出DELETE请求时,可能会把207响应解释为成功,即使它没有意识到这个资源是一个集合,也不能理解DELETE操作可能是完全或部分失败。这种解释并不完全合理,因为200级响应表明服务器 &quot;收到、理解并接受 &quot;了请求,而不是请求的结果是完全成功。一种选择是,服务器可以把一个集合的DELETE当作一个原子操作,在成功的情况下使用204 No Content,或者对错误使用一些适当的错误响应(400或500级)。这种方法确实可以最大限度地实现向后兼容。然而,由于互操作性测试和工作组的讨论还没有发现任何HTTP客户端对WebDAV集合发出DELETE请求的实例,这种担心更多的是理论上的,而不是实际的。因此,即使服务器将任何集合DELETE请求视为WebDAV请求并发送207多状态响应,服务器也有可能完全成功地与HTTP客户端进行互操作。一般来说,我们鼓励服务器实现使用本文档中定义的详细响应和其他机制,而不是为了理论上的互操作性问题而做出改变。</target>
        </trans-unit>
        <trans-unit id="3eebce6ea96f9e6c03e9252a4f8ef2ea9fe141c2" translate="yes" xml:space="preserve">
          <source>WebKit</source>
          <target state="translated">WebKit</target>
        </trans-unit>
        <trans-unit id="3cc12f1bec20e52cab0b97341d3c02b8d6b5a8e7" translate="yes" xml:space="preserve">
          <source>WebKit-based (Android, Safari)</source>
          <target state="translated">基于WebKit的(Android,Safari)</target>
        </trans-unit>
        <trans-unit id="6cd48f2561ad5a0df1f54b2512998a473f410b84" translate="yes" xml:space="preserve">
          <source>WebKit: &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=165508&quot;&gt;Issue 165508&lt;/a&gt;</source>
          <target state="translated">WebKit：&lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=165508&quot;&gt;问题165508&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fa39ac0c7eff59abc27629413eef3a672293245" translate="yes" xml:space="preserve">
          <source>WebP</source>
          <target state="translated">WebP</target>
        </trans-unit>
        <trans-unit id="e5b42921cd81579fb4373d4c9301a0b48c00c221" translate="yes" xml:space="preserve">
          <source>WebSQL databases,</source>
          <target state="translated">WebSQL数据库。</target>
        </trans-unit>
        <trans-unit id="02a11319d4ec575e7c0cfcc8b345785648d8021d" translate="yes" xml:space="preserve">
          <source>WebSocket API</source>
          <target state="translated">WebSocket API</target>
        </trans-unit>
        <trans-unit id="135a771b27602deda1493cda4d44fa69a76c0314" translate="yes" xml:space="preserve">
          <source>WebSocket connections (Secure)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ca95fd7fee5486bad6b0d54e93172855ee31dd" translate="yes" xml:space="preserve">
          <source>WebSocket-specific headers</source>
          <target state="translated">WebSocket特定头文件</target>
        </trans-unit>
        <trans-unit id="56d0e53e6a7114caaeb10b3ceba94b42ba2520e2" translate="yes" xml:space="preserve">
          <source>WebSockets</source>
          <target state="translated">WebSockets</target>
        </trans-unit>
        <trans-unit id="d5b3205d2f50f8459df98f434927a9961edb8576" translate="yes" xml:space="preserve">
          <source>WebVR 1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494fbe1ebcf39962e071a464fdd0df350d08593e" translate="yes" xml:space="preserve">
          <source>WebVR API was never enabled by default in any production builds and was replaced by WebXR Device API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e76aac4eddc8812e45c58b46f8b12f9b9860da" translate="yes" xml:space="preserve">
          <source>What Does the &quot;Track&quot; in &quot;Do Not Track&quot; Mean? &amp;ndash; EFF</source>
          <target state="translated">&amp;ldquo;不跟踪&amp;rdquo;中的&amp;ldquo;跟踪&amp;rdquo;是什么意思？&amp;ndash; EFF</target>
        </trans-unit>
        <trans-unit id="6a8f52f9ef8f506e4398a41c7de6a771321653bb" translate="yes" xml:space="preserve">
          <source>What are domain names?</source>
          <target state="translated">什么是域名?</target>
        </trans-unit>
        <trans-unit id="268a9a597e83ba75272d9a4ac9bca257bf6b5aed" translate="yes" xml:space="preserve">
          <source>What can be controlled by HTTP</source>
          <target state="translated">HTTP可以控制什么</target>
        </trans-unit>
        <trans-unit id="713c03e5f5976173474700739054677d438ef529" translate="yes" xml:space="preserve">
          <source>What is a URL?</source>
          <target state="translated">什么是URL?</target>
        </trans-unit>
        <trans-unit id="cb40fda7700c4353a89ae159720212fe772dbbc9" translate="yes" xml:space="preserve">
          <source>What requests use CORS?</source>
          <target state="translated">哪些请求使用CORS?</target>
        </trans-unit>
        <trans-unit id="71c8a4a23b0dea390d9c49b1b0992f6d919a9595" translate="yes" xml:space="preserve">
          <source>What went wrong?</source>
          <target state="translated">出了什么问题?</target>
        </trans-unit>
        <trans-unit id="cf7174ba77cb305a51d991cf76d59eab20483bc3" translate="yes" xml:space="preserve">
          <source>When a 206 (Partial Content) response message includes the content of
   multiple ranges, they are transmitted as body parts in a multipart
   message body (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1&quot;&gt;[RFC2046], Section&amp;nbsp;5.1&lt;/a&gt;) with the media type of
   &quot;multipart/byteranges&quot;.

   The multipart/byteranges media type includes one or more body parts,
   each with its own Content-Type and Content-Range fields.  The
   required boundary parameter specifies the boundary string used to
   separate each body part.

   Implementation Notes:

   1.  Additional CRLFs might precede the first boundary string in the
       body.

   2.  Although [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] permits the boundary string to be quoted, some
       existing implementations handle a quoted boundary string
       incorrectly.

   3.  A number of clients and servers were coded to an early draft of
       the byteranges specification that used a media type of multipart/
       x-byteranges, which is almost (but not quite) compatible with
       this type.

   Despite the name, the &quot;multipart/byteranges&quot; media type is not
   limited to byte ranges.  The following example uses an &quot;exampleunit&quot;
   range unit:

     HTTP/1.1 206 Partial Content
     Date: Tue, 14 Nov 1995 06:25:24 GMT
     Last-Modified: Tue, 14 July 04:58:08 GMT
     Content-Length: 2331785
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: video/example
     Content-Range: exampleunit 1.2-4.3/25

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: video/example
     Content-Range: exampleunit 11.2-14.3/25

     ...the second range
     --THIS_STRING_SEPARATES--</source>
          <target state="translated">当206（部分内容）响应消息包含多个范围的内容时，它们将作为媒体部分中的主体部分以&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1&quot;&gt;[&lt;/a&gt; multipart / byteranges ]媒体类型作为主体部分发送（[RFC2046]，第5.1节）。multipart / byteranges媒体类型包括一个或多个主体部分，每个主体部分都有其自己的Content-Type和Content-Range字段。必需的boundary参数指定用于分隔每个身体部位的边界字符串。实施注意事项：1.其他CRLF可能在主体中的第一个边界字符串之前。2.尽管[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;]允许用引号引起来的边界字符串，某些现有的实现错误地处理了用引号引起来的边界字符串。 3.许多客户端和服务器被编码为使用multipart / x-byteranges媒体类型的byteranges规范的早期草案，该媒体类型几乎（但不太兼容）与该类型兼容。尽管有名称，&amp;ldquo; multipart / byteranges&amp;rdquo;媒体类型并不限于字节范围。下面的示例使用&amp;ldquo; exampleunit&amp;rdquo;范围单位：HTTP / 1.1 206部分内容日期：1995年11月14日，星期二，格林尼治标准时间上次修改时间：7月14日，星期二，04：58：08 GMT内容长度：2331785内容-类型：multipart / byteranges； boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES内容类型：视频/示例内容范围：exampleunit 1。2-4.3 / 25 ...第一个范围--THIS_STRING_SEPARATES内容类型：视频/示例内容范围：exampleunit 11.2-14.3 / 25 ...第二个范围--THIS_STRING_SEPARATES--</target>
        </trans-unit>
        <trans-unit id="6c808413e1f3c35593db90aed6fc9dab2aba5b1a" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request is used to load a document, that load cannot currently be redirected into a new process. This error is displayed when loading a document with a &lt;code&gt;Large-Allocation&lt;/code&gt; header with a non-GET HTTP method. This could be caused due to the document being loaded by a form submission, for example.</source>
          <target state="translated">当使用&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求加载文档时，当前无法将该加载重定向到新进程中。使用非GET HTTP方法加载带有 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头的文档时，将显示此错误。例如，这可能是由于文档是通过表单提交加载的。</target>
        </trans-unit>
        <trans-unit id="56b0204156f1f5be7ef0d0a67cbf3c8e482f8b85" translate="yes" xml:space="preserve">
          <source>When a CSS stylesheet is requested, via the &lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot;&amp;gt;&lt;/code&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">当请求CSS样式表时，通过 &lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot;&amp;gt;&lt;/code&gt; HTML元素，大多数浏览器使用特定的值。</target>
        </trans-unit>
        <trans-unit id="6496002e1314faa2d54160cca1e538793173aa5c" translate="yes" xml:space="preserve">
          <source>When a cache has a stale entry that it would like to use as a
   response to a client's request, it first has to check with the origin
   server (or possibly an intermediate cache with a fresh response) to
   see if its cached entry is still usable. We call this &quot;validating&quot;
   the cache entry. Since we do not want to have to pay the overhead of
   retransmitting the full response if the cached entry is good, and we
   do not want to pay the overhead of an extra round trip if the cached
   entry is invalid, the HTTP/1.1 protocol supports the use of
   conditional methods.

   The key protocol features for supporting conditional methods are
   those concerned with &quot;cache validators.&quot; When an origin server
   generates a full response, it attaches some sort of validator to it,
   which is kept with the cache entry. When a client (user agent or
   proxy cache) makes a conditional request for a resource for which it
   has a cache entry, it includes the associated validator in the
   request.

   The server then checks that validator against the current validator
   for the entity, and, if they match (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), it responds
   with a special status code (usually, 304 (Not Modified)) and no
   entity-body. Otherwise, it returns a full response (including
   entity-body). Thus, we avoid transmitting the full response if the
   validator matches, and we avoid an extra round trip if it does not
   match.

   In HTTP/1.1, a conditional request looks exactly the same as a normal
   request for the same resource, except that it carries a special
   header (which includes the validator) that implicitly turns the
   method (usually, GET) into a conditional.

   The protocol includes both positive and negative senses of cache-
   validating conditions. That is, it is possible to request either that
   a method be performed if and only if a validator matches or if and
   only if no validators match. 

      Note: a response that lacks a validator may still be cached, and
      served from cache until it expires, unless this is explicitly
      prohibited by a cache-control directive. However, a cache cannot
      do a conditional retrieval if it does not have a validator for the
      entity, which means it will not be refreshable after it expires.</source>
          <target state="translated">当缓存中有一个过时的条目要用作对客户端请求的响应时，它首先必须与原始服务器（或可能是具有新响应的中间缓存）进行检查，以查看其缓存条目是否仍然可用。我们称此为&amp;ldquo;验证&amp;rdquo;缓存条目。由于如果缓存的条目是好的，我们不需要支付重新传输完整响应的开销，并且如果缓存的条目无效，我们也不想支付额外的往返开销，因此HTTP / 1.1协议支持使用条件方法。支持条件方法的关键协议功能是那些与&amp;ldquo;缓存验证器&amp;rdquo;有关的功能。当原始服务器生成完整响应时，它会向其附加某种验证器，该验证器与高速缓存条目一起保存。当客户端（用户代理或代理缓存）对有缓存条目的资源进行条件请求时，它将在请求中包含关联的验证器。然后，服务器对照实体的当前验证器检查该验证器，以及是否匹配（请参见&lt;a href=&quot;#section-13.3.3&quot;&gt;第13.3.3节&lt;/a&gt;），它将以特殊的状态码（通常为304（未修改））响应，并且没有实体。否则，它将返回完整的响应（包括实体）。因此，如果验证器匹配，我们将避免发送完整的响应，如果匹配器不匹配，则将避免额外的往返。在HTTP / 1.1中，条件请求看起来与对相同资源的普通请求完全相同，不同之处在于它带有一个特殊的标头（包括验证器），该标头将方法（通常是GET）隐式地转换为条件。该协议包括对缓存验证条件的正面和负面感觉。即，有可能请求一种方法，当且仅当验证者匹配时才执行，或者仅当没有验证者匹配时才执行。注意：缺少验证器的响应可能仍会被高速缓存，并从高速缓存提供直到其到期，除非高速缓存控制指令明确禁止这样做。但是，如果高速缓存没有实体的验证器，则它无法进行条件检索，这意味着过期后将无法刷新。</target>
        </trans-unit>
        <trans-unit id="2a313afb539045fee37b52ddc2442118f434a073" translate="yes" xml:space="preserve">
          <source>When a cache has one or more stored responses for a requested URI,
   but cannot serve any of them (e.g., because they are not fresh, or
   one cannot be selected; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;), it can use the conditional
   request mechanism [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] in the forwarded request to give the next
   inbound server an opportunity to select a valid stored response to
   use, updating the stored metadata in the process, or to replace the
   stored response(s) with a new response.  This process is known as
   &quot;validating&quot; or &quot;revalidating&quot; the stored response.</source>
          <target state="translated">当缓存中有一个或多个针对请求的URI的已存储响应，但不能为其中任何一个提供服务时（例如，因为它们不新鲜或无法选择一个响应，请参见&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;），它可以使用条件请求机制[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]在转发的请求中，给下一个入站服务器一个机会来选择要使用的有效存储响应，在过程中更新存储的元数据或用新响应替换存储的响应。此过程称为&amp;ldquo;验证&amp;rdquo;或&amp;ldquo;重新验证&amp;rdquo;存储的响应。</target>
        </trans-unit>
        <trans-unit id="e7c36b18a75fcc748e38b4b4ab8d6dd1ec4fac99" translate="yes" xml:space="preserve">
          <source>When a cache makes a validating request to a server, and the server
   provides a 304 (Not Modified) response or a 206 (Partial Content)
   response, the cache then constructs a response to send to the
   requesting client.

   If the status code is 304 (Not Modified), the cache uses the entity-
   body stored in the cache entry as the entity-body of this outgoing
   response. If the status code is 206 (Partial Content) and the ETag or
   Last-Modified headers match exactly, the cache MAY combine the
   contents stored in the cache entry with the new contents received in
   the response and use the result as the entity-body of this outgoing
   response, (see 13.5.4).

   The end-to-end headers stored in the cache entry are used for the
   constructed response, except that

      - any stored Warning headers with warn-code 1xx (see &lt;a href=&quot;#section-14.46&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;) MUST be deleted from the cache entry and the forwarded
        response.

      - any stored Warning headers with warn-code 2xx MUST be retained
        in the cache entry and the forwarded response.

      - any end-to-end headers provided in the 304 or 206 response MUST
        replace the corresponding headers from the cache entry.

   Unless the cache decides to remove the cache entry, it MUST also
   replace the end-to-end headers stored with the cache entry with
   corresponding headers received in the incoming response, except for
   Warning headers as described immediately above. If a header field-
   name in the incoming response matches more than one header in the
   cache entry, all such old headers MUST be replaced.

   In other words, the set of end-to-end headers received in the
   incoming response overrides all corresponding end-to-end headers
   stored with the cache entry (except for stored Warning headers with
   warn-code 1xx, which are deleted even if not overridden).

      Note: this rule allows an origin server to use a 304 (Not
      Modified) or a 206 (Partial Content) response to update any header
      associated with a previous response for the same entity or sub-
      ranges thereof, although it might not always be meaningful or
      correct to do so. This rule does not allow an origin server to use
      a 304 (Not Modified) or a 206 (Partial Content) response to
      entirely delete a header that it had provided with a previous
      response.</source>
          <target state="translated">当缓存向服务器发出验证请求，并且服务器提供304（未修改）响应或206（部分内容）响应时，缓存将构造一个响应以发送到发出请求的客户端。如果状态码为304（未修改），则高速缓存将存储在高速缓存条目中的实体作为该传出响应的实体。如果状态码是206（部分内容）并且ETag或Last-Modified头完全匹配，则缓存可以将缓存条目中存储的内容与响应中接收到的新内容进行组合，并将结果用作的实体此外发响应（请参阅13.5.4）。存储在缓存条目中的端到端标头用于构造的响应，但以下情况除外-任何存储的警告代码为1xx的警告标头（请参见&lt;a href=&quot;#section-14.46&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.46&quot;&gt;14.46条&lt;/a&gt;）必须从缓存条目和转发的响应中删除。 -任何存储的警告代码为2xx的警告标头必须保留在缓存条目和转发的响应中。 &amp;mdash; 30​​4或206响应中提供的任何端到端头都必须替换缓存条目中的相应头。除非缓存决定删除缓存条目，否则它还必须用传入响应中接收到的相应报头替换缓存条目存储的端到端报头，除了上面刚刚描述的Warning报头。如果传入响应中的头字段名与缓存条目中的多个头匹配，则必须替换所有这些旧的头。换一种说法，在传入响应中接收到的一组端到端标头会覆盖与缓存条目一起存储的所有相应的端到端标头（存储的警告代码为1xx的警告标头除外，即使未被覆盖也将被删除）。注意：此规则允许原始服务器使用304（未修改）或206（部分内容）响应来更新与同一实体或其子范围的先前响应关联的任何标头，尽管它可能并不总是有意义的或正确地这样做。此规则不允许源服务器使用304（未修改）或206（部分内容）响应来完全删除其先前响应提供的标头。即使未被覆盖也将被删除）。注意：此规则允许原始服务器使用304（未修改）或206（部分内容）响应来更新与同一实体或其子范围的先前响应关联的任何标头，尽管它可能并不总是有意义的或正确地这样做。此规则不允许源服务器使用304（未修改）或206（部分内容）响应来完全删除其先前响应提供的标头。即使未被覆盖也将被删除）。注意：此规则允许原始服务器使用304（未修改）或206（部分内容）响应来更新与同一实体或其子范围的先前响应关联的任何标头，尽管它可能并不总是有意义的或正确地这样做。此规则不允许源服务器使用304（未修改）或206（部分内容）响应来完全删除其先前响应提供的标头。尽管这样做可能并不总是有意义或正确的。此规则不允许源服务器使用304（未修改）或206（部分内容）响应来完全删除其先前响应提供的标头。尽管这样做可能并不总是有意义或正确的。此规则不允许源服务器使用304（未修改）或206（部分内容）响应来完全删除其先前响应提供的标头。</target>
        </trans-unit>
        <trans-unit id="3d406717c4c6e5b1008e22170bfa6487a4fa871a" translate="yes" xml:space="preserve">
          <source>When a cache receives a 304 (Not Modified) response and already has
   one or more stored 200 (OK) responses for the same cache key, the
   cache needs to identify which of the stored responses are updated by
   this new response and then update the stored response(s) with the new
   information provided in the 304 response.

   The stored response to update is identified by using the first match
   (if any) of the following:

   o  If the new response contains a strong validator (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;Section&amp;nbsp;2.1
      of [RFC7232]&lt;/a&gt;), then that strong validator identifies the selected
      representation for update.  All of the stored responses with the
      same strong validator are selected.  If none of the stored
      responses contain the same strong validator, then the cache MUST
      NOT use the new response to update any stored responses. 

   o  If the new response contains a weak validator and that validator
      corresponds to one of the cache's stored responses, then the most
      recent of those matching stored responses is selected for update.

   o  If the new response does not include any form of validator (such
      as in the case where a client generates an If-Modified-Since
      request from a source other than the Last-Modified response header
      field), and there is only one stored response, and that stored
      response also lacks a validator, then that stored response is
      selected for update.

   If a stored response is selected for update, the cache MUST:

   o  delete any Warning header fields in the stored response with
      warn-code 1xx (see &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;);

   o  retain any Warning header fields in the stored response with
      warn-code 2xx; and,

   o  use other header fields provided in the 304 (Not Modified)
      response to replace all instances of the corresponding header
      fields in the stored response.</source>
          <target state="translated">当高速缓存接收到304（未修改）响应并且已经为同一高速缓存密钥存储了一个或多个200（确定）响应时，高速缓存需要标识该新响应更新了哪些存储的响应，然后更新了存储的响应以及304响应中提供的新信息。使用以下条件的第一个匹配项（如果有的话）来标识存储的更新响应：o如果新响应包含强验证器（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;[RFC7232]第2.1节）&lt;/a&gt;），则该强验证器将标识所选的表示形式以进行更新。选择所有具有相同强验证器的已存储响应。如果所有存储的响应均不包含相同的强验证器，则缓存不得使用新的响应来更新任何存储的响应。 o如果新响应包含一个弱验证器，并且该验证器与缓存的存储响应之一相对应，则选择那些匹配的存储响应中的最新响应进行更新。 o如果新响应不包括任何形式的验证器（例如，在客户端从&amp;ldquo;最后修改的响应&amp;rdquo;头字段以外的源生成&amp;ldquo; If-Modified-Since&amp;rdquo;请求的情况下），则仅存储一个响应，并且该存储的响应也缺少验证器，则选择该存储的响应进行更新。如果选择了存储的响应进行更新，则缓存必须：o删除警告代码为1xx的存储的响应中的所有Warning标头字段（请参见&lt;a href=&quot;#section-5.5&quot;&gt;5.5节&lt;/a&gt;）；o在警告代码为2xx的存储响应中保留所有警告标头字段；o使用304（未修改）响应中提供的其他标头字段替换存储的响应中相应标头字段的所有实例。</target>
        </trans-unit>
        <trans-unit id="e27f8aec5a4d9dfc930b9dd75d95d7e0c67f7b5f" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that can be satisfied by a cached response that has a &lt;code&gt;Vary&lt;/code&gt; header field, it must not use that cached response unless all header fields as nominated by the &lt;code&gt;Vary&lt;/code&gt; header match in both the original (cached) request and the new request.</source>
          <target state="translated">当缓存收到具有 &lt;code&gt;Vary&lt;/code&gt; 标头字段的缓存响应可以满足的请求时，除非原始（缓存）请求和新请求中的所有 &lt;code&gt;Vary&lt;/code&gt; 标头指定的所有标头字段都匹配，否则缓存不得使用该缓存响应请求。</target>
        </trans-unit>
        <trans-unit id="259d9c0cc1a97e83d0591dcfa329388834b800bc" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that can be satisfied by a stored
   response that has a Vary header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.4&quot;&gt;Section&amp;nbsp;7.1.4 of [RFC7231]&lt;/a&gt;),
   it MUST NOT use that response unless all of the selecting header 

   fields nominated by the Vary header field match in both the original
   request (i.e., that associated with the stored response), and the
   presented request.

   The selecting header fields from two requests are defined to match if
   and only if those in the first request can be transformed to those in
   the second request by applying any of the following:

   o  adding or removing whitespace, where allowed in the header field's
      syntax

   o  combining multiple header fields with the same field name (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;)

   o  normalizing both header field values in a way that is known to
      have identical semantics, according to the header field's
      specification (e.g., reordering field values when order is not
      significant; case-normalization, where values are defined to be
      case-insensitive)

   If (after any normalization that might take place) a header field is
   absent from a request, it can only match another request if it is
   also absent there.

   A Vary header field-value of &quot;*&quot; always fails to match.

   The stored response with matching selecting header fields is known as
   the selected response.

   If multiple selected responses are available (potentially including
   responses without a Vary header field), the cache will need to choose
   one to use.  When a selecting header field has a known mechanism for
   doing so (e.g., qvalues on Accept and similar request header fields),
   that mechanism MAY be used to select preferred responses; of the
   remainder, the most recent response (as determined by the Date header
   field) is used, as per &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If no selected response is available, the cache cannot satisfy the
   presented request.  Typically, it is forwarded to the origin server
   in a (possibly conditional; see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) request.</source>
          <target state="translated">当缓存接收到的请求可以被具有Vary头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.4&quot;&gt;[RFC7231]的7.1.4节）&lt;/a&gt;的存储响应所满足时，除非由Vary头字段指定的所有选择头字段都不得使用该响应匹配原始请求（即与存储的响应相关联的请求）和显示的请求。当且仅当通过应用以下任一操作可以将第一个请求中的选择标头字段转换为第二个请求中的标头字段时，才定义为匹配：o添加或删除空格，在标头字段的语法中允许合并具有相同字段名称的多个头字段（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]的3.2节&lt;/a&gt;）o根据头字段的规范，以已知具有相同语义的方式对两个头字段值进行规范化（例如，在顺序不重要时重新排序字段值；大小写规范化，其中值定义为不区分大小写）如果（可能发生的任何规范化之后）请求中不存在标头字段，则该标头字段只能与另一个请求相匹配（如果那里也不存在）。 Vary标头字段值&amp;ldquo; *&amp;rdquo;始终不匹配。具有匹配的选择标题字段的已存储响应称为所选响应。如果有多个选定的响应可用（可能包括没有Vary标头字段的响应），则缓存将需要选择一个以使用。当选择标头字段具有已知的机制（例如，Accept上的qvalue和类似的请求标头字段）时，可以使用该机制来选择首选响应；其余的，使用最新的响应（由Date标头字段确定）&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;。如果没有选定的响应可用，则高速缓存不能满足提出的请求。通常，它在（可能是有条件的；请参阅&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）请求中转发到原始服务器。</target>
        </trans-unit>
        <trans-unit id="2efb3fde6a483d198481c23c5cdc77de55b29f46" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that has a &lt;code&gt;Vary&lt;/code&gt; header field, it must not use a cached response by default unless all header fields specified in the &lt;code&gt;Vary&lt;/code&gt; header match in both the original (cached) request and the new request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287b2fc4e92e6cc3cafe98a92f86bd5cdf146df5" translate="yes" xml:space="preserve">
          <source>When a cached document's expiration time has been reached, it is either validated or fetched again. Validation can only occur if the server provided either a &lt;em&gt;strong validator&lt;/em&gt; or a &lt;em&gt;weak validator&lt;/em&gt;.</source>
          <target state="translated">当达到缓存文档的到期时间时，将对其进行验证或再次获取。仅当服务器提供了&lt;em&gt;强验证器&lt;/em&gt;或&lt;em&gt;弱验证&lt;/em&gt;&lt;em&gt;器时，才&lt;/em&gt;可以进行&lt;em&gt;验证&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="975b61b5ac16b78cc262727df4d4fcf1f3fc063c" translate="yes" xml:space="preserve">
          <source>When a client wants to communicate with a server, either the final server or an intermediate proxy, it performs the following steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e879fd0d6d83356c23a21725294c0955f7c7cc" translate="yes" xml:space="preserve">
          <source>When a complete or partial representation is transferred in a message
   payload, it is often desirable for the sender to supply, or the
   recipient to determine, an identifier for a resource corresponding to
   that representation.

   For a request message:

   o  If the request has a Content-Location header field, then the
      sender asserts that the payload is a representation of the
      resource identified by the Content-Location field-value.  However,
      such an assertion cannot be trusted unless it can be verified by
      other means (not defined by this specification).  The information
      might still be useful for revision history links. 

   o  Otherwise, the payload is unidentified.

   For a response message, the following rules are applied in order
   until a match is found:

   1.  If the request method is GET or HEAD and the response status code
       is 200 (OK), 204 (No Content), 206 (Partial Content), or 304 (Not
       Modified), the payload is a representation of the resource
       identified by the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
       [RFC7230]&lt;/a&gt;).

   2.  If the request method is GET or HEAD and the response status code
       is 203 (Non-Authoritative Information), the payload is a
       potentially modified or enhanced representation of the target
       resource as provided by an intermediary.

   3.  If the response has a Content-Location header field and its
       field-value is a reference to the same URI as the effective
       request URI, the payload is a representation of the resource
       identified by the effective request URI.

   4.  If the response has a Content-Location header field and its
       field-value is a reference to a URI different from the effective
       request URI, then the sender asserts that the payload is a
       representation of the resource identified by the Content-Location
       field-value.  However, such an assertion cannot be trusted unless
       it can be verified by other means (not defined by this
       specification).

   5.  Otherwise, the payload is unidentified.</source>
          <target state="translated">当在消息有效负载中传送完整或部分表示形式时，通常希望发送者提供或由接收者确定对应于该表示形式的资源的标识符。对于请求消息：o如果请求具有Content-Location标头字段，则发送者断言有效负载是Content-Location字段值标识的资源的表示。但是，除非可以通过其他方式（本规范未定义）验证该断言，否则无法信任该断言。该信息对于修订历史记录链接可能仍然有用。 o否则，有效载荷将无法识别。对于响应消息，将依次应用以下规则，直到找到匹配项为止：1。如果请求方法是GET或HEAD，并且响应状态代码是200（确定），204（无内容），206（部分内容）或304（未修改），则有效负载表示有效资源所标识的资源请求URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]的5.5节&lt;/a&gt;）。 2.如果请求方法是GET或HEAD，并且响应状态代码是203（非权威信息），则有效负载可能是中介提供的目标资源的潜在修改或增强表示。 3.如果响应具有Content-Location标头字段，并且其字段值是对与有效请求URI相同的URI的引用，则有效负载表示由有效请求URI标识的资源。 4.如果响应具有Content-Location标头字段，并且其字段值是对与有效请求URI不同的URI的引用，则发送方断言有效负载是Content-Location字段标识的资源的表示-值。然而，除非可以通过其他方式（本规范未定义）对其进行验证，否则此类声明不可信任。 5.否则，有效载荷无法识别。</target>
        </trans-unit>
        <trans-unit id="e81a1900fdbf11113476103eae02d72c7f77097d" translate="yes" xml:space="preserve">
          <source>When a message does not have a Transfer-Encoding header field, a
   Content-Length header field can provide the anticipated size, as a
   decimal number of octets, for a potential payload body.  For messages
   that do include a payload body, the Content-Length field-value
   provides the framing information necessary for determining where the
   body (and message) ends.  For messages that do not include a payload
   body, the Content-Length indicates the size of the selected
   representation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;).

     Content-Length = 1*DIGIT

   An example is

     Content-Length: 3495

   A sender MUST NOT send a Content-Length header field in any message
   that contains a Transfer-Encoding header field.

   A user agent SHOULD send a Content-Length in a request message when
   no Transfer-Encoding is sent and the request method defines a meaning
   for an enclosed payload body.  For example, a Content-Length header
   field is normally sent in a POST request even when the value is 0
   (indicating an empty payload body).  A user agent SHOULD NOT send a
   Content-Length header field when the request message does not contain
   a payload body and the method semantics do not anticipate such a
   body.

   A server MAY send a Content-Length header field in a response to a
   HEAD request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7231]&lt;/a&gt;); a server MUST NOT send
   Content-Length in such a response unless its field-value equals the
   decimal number of octets that would have been sent in the payload
   body of a response if the same request had used the GET method.

   A server MAY send a Content-Length header field in a 304 (Not
   Modified) response to a conditional GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of
   [RFC7232]&lt;/a&gt;); a server MUST NOT send Content-Length in such a response 

   unless its field-value equals the decimal number of octets that would
   have been sent in the payload body of a 200 (OK) response to the same
   request.

   A server MUST NOT send a Content-Length header field in any response
   with a status code of 1xx (Informational) or 204 (No Content).  A
   server MUST NOT send a Content-Length header field in any 2xx
   (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Aside from the cases defined above, in the absence of
   Transfer-Encoding, an origin server SHOULD send a Content-Length
   header field when the payload body size is known prior to sending the
   complete header section.  This will allow downstream recipients to
   measure transfer progress, know when a received message is complete,
   and potentially reuse the connection for additional requests.

   Any Content-Length field value greater than or equal to zero is
   valid.  Since there is no predefined limit to the length of a
   payload, a recipient MUST anticipate potentially large decimal
   numerals and prevent parsing errors due to integer conversion
   overflows (&lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;).

   If a message is received that has multiple Content-Length header
   fields with field-values consisting of the same decimal value, or a
   single Content-Length header field with a field value containing a
   list of identical decimal values (e.g., &quot;Content-Length: 42, 42&quot;),
   indicating that duplicate Content-Length header fields have been
   generated or combined by an upstream message processor, then the
   recipient MUST either reject the message as invalid or replace the
   duplicated field-values with a single valid Content-Length field
   containing that decimal value prior to determining the message body
   length or forwarding the message.

      Note: HTTP's use of Content-Length for message framing differs
      significantly from the same field's use in MIME, where it is an
      optional field used only within the &quot;message/external-body&quot;
      media-type.</source>
          <target state="translated">当消息没有Transfer-Encoding头字段时，Content-Length头字段可以为潜在的有效负载主体提供预期的大小（八位组的十进制数）。对于确实包含有效载荷主体的消息，Content-Length字段值提供确定主体（和消息）在何处结束所必需的成帧信息。对于不包含有效载荷主体的消息，内容长度指示所选表示的大小（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;[RFC7231]的第3节&lt;/a&gt;）。 Content-Length = 1 * DIGIT例如：Content-Length：3495发送方不得在任何包含Transfer-Encoding标头字段的消息中发送Content-Length标头字段。当没有发送Transfer-Encoding并且请求方法定义了封闭的有效载荷主体的含义时，用户代理应该在请求消息中发送Content-Length。例如，即使值为0（表示空的有效负载主体），通常也会在POST请求中发送Content-Length头字段。当请求消息不包含有效载荷主体，并且方法语义不期望这种主体时，用户代理不应发送Content-Length头字段。服务器可以响应HEAD请求而发送Content-Length头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;[RFC7231]第4.3.2节）&lt;/a&gt;）;服务器不得在此类响应中发送Content-Length，除非其字段值等于响应的有效内容正文中发送的八位字节的十进制数（如果同一请求使用了GET方法）。服务器可以在对条件GET请求的304（未修改）响应中发送Content-Length头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]的4.1节）&lt;/a&gt;）;服务器不得在此类响应中发送Content-Length，除非其字段值等于在200（OK）响应的有效载荷主体中已发送的八位字节的十进制数，该请求的响应是相同的。服务器不得在状态码为1xx（信息性）或204（无内容）的任何响应中发送Content-Length头字段。服务器不得在对CONNECT请求的任何2xx（成功）响应中发送Content-Length头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]的第4.3.6节）&lt;/a&gt;）。除了上面定义的情况外，在没有Transfer-Encoding的情况下，如果在发送完整的头节之前已知有效负载主体的大小，则源服务器应该发送Content-Length头字段。这将使下游收件人可以测量传输进度，知道收到的消息何时完成，并有可能将连接重用于其他请求。任何大于或等于零的Content-Length字段值都是有效的。由于有效载荷的长度没有预定义的限制，因此接收者必须预见潜在的大十进制数字，并防止由于整数转换溢出而引起的解析错误（&lt;a href=&quot;#section-9.3&quot;&gt;第9.3节）&lt;/a&gt;）。如果收到的消息具有多个Content-Length标头字段，且字段值由相同的十进制值组成，或者单个Content-Length标头字段的字段值包含相同的十进制值列表（例如，&amp;ldquo; Content-Length ：42、42&amp;ldquo;），指示上游消息处理器已生成或合并了重复的Content-Length头字段，则接收者必须拒绝该消息为无效消息，或将重复的字段值替换为单个有效的Content-Length确定邮件正文长度或转发邮件之前，该字段包含该十进制值。注意：HTTP对消息框架使用Content-Length的方式与MIME中相同字段的使用有很大不同，其中是一个可选字段，仅在&amp;ldquo; message / external-body&amp;rdquo;媒体类型内使用。</target>
        </trans-unit>
        <trans-unit id="8a3283af6dcc2661109dbb11d4827ac5e1d71582" translate="yes" xml:space="preserve">
          <source>When a message includes a message body encoded with the chunked
   transfer coding and the sender desires to send metadata in the form
   of trailer fields at the end of the message, the sender SHOULD
   generate a Trailer header field before the message body to indicate
   which fields will be present in the trailers.  This allows the
   recipient to prepare for receipt of that metadata before it starts
   processing the body, which is useful if the message is being streamed
   and the recipient wishes to confirm an integrity check on the fly.

     Trailer = 1#field-name</source>
          <target state="translated">当电文包括一个用分块传输编码编码的电文主体,并且发送方希望在电文末尾以拖车字段的形式发送元数据时,发送方应该在电文主体之前生成一个拖车头字段,以表明哪些字段将出现在拖车中。这允许收件人在开始处理正文之前为接收该元数据做准备,如果消息是流式的,收件人希望在飞行中确认完整性检查,这很有用。预告片=1#字段名</target>
        </trans-unit>
        <trans-unit id="b235fc2e260e87a056455dbda3fa587e723e993d" translate="yes" xml:space="preserve">
          <source>When a precondition header is &lt;strong&gt;not matching&lt;/strong&gt; the server side state, the response should be &lt;a href=&quot;412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt;.</source>
          <target state="translated">当前提条件标头与服务器端状态&lt;strong&gt;不匹配时&lt;/strong&gt;，响应应为&lt;a href=&quot;412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="186bf5363add379b2ba012f5766a038907e51aa8" translate="yes" xml:space="preserve">
          <source>When a request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;, browsers will only expose the response to frontend JavaScript code if the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当请求的凭据模式（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt;）为&amp;ldquo; &lt;code&gt;include&lt;/code&gt; &amp;rdquo;时，如果 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 值为 &lt;code&gt;true&lt;/code&gt; ，浏览器将仅对前端JavaScript代码公开响应。</target>
        </trans-unit>
        <trans-unit id="7333e1d0d6993ac9df1cdfe6fae92b4f7648978f" translate="yes" xml:space="preserve">
          <source>When a request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;include&lt;/code&gt;, browsers will only expose the response to frontend JavaScript code if the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dac549244c018dee53a4d208ca6b3e0f5dca724" translate="yes" xml:space="preserve">
          <source>When a script is requested, like via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, some browsers use specific values.</source>
          <target state="translated">当请求脚本时（例如通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML元素），某些浏览器使用特定的值。</target>
        </trans-unit>
        <trans-unit id="f12d11c8f8587f228e72fd8c89532b1324f82f4a" translate="yes" xml:space="preserve">
          <source>When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in &lt;strong&gt;&lt;a href=&quot;https://www.certificate-transparency.org/known-logs&quot;&gt;public CT logs&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">当站点启用 &lt;code&gt;Expect-CT&lt;/code&gt; 标头时，他们要求浏览器检查该站点的任何证书是否出现在&lt;strong&gt;&lt;a href=&quot;https://www.certificate-transparency.org/known-logs&quot;&gt;公共CT日志中&lt;/a&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="fa74c170f2d19667b559eacecf88a8660b338292" translate="yes" xml:space="preserve">
          <source>When a user opened a page using a &lt;code&gt;file:///&lt;/code&gt; URI in Firefox 67 and earlier, the origin of the page was defined as the directory from which the page was opened. Resources in the same directory and its subdirectories were treated as having the same origin for purposes of the CORS same-origin rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ab7ed245bcd63c35d075bb14e0ef75e55e069" translate="yes" xml:space="preserve">
          <source>When a validation request is made, the server can either ignore the validation request and response with a normal &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;, or it can return &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; (with an empty body) to instruct the browser to use its cached copy. The latter response can also include headers that update the expiration time of the cached document.</source>
          <target state="translated">发出验证请求后，服务器可以忽略验证请求并以正常&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 响应，也可以返回&lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; （主体为空），以指示浏览器使用其缓存副本。后者的响应还可以包括用于更新缓存文档的过期时间的标头。</target>
        </trans-unit>
        <trans-unit id="47e19190be60527564cf5d0364edee22a0103f29" translate="yes" xml:space="preserve">
          <source>When a video is requested, via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">当请求视频时，通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML元素，大多数浏览器使用特定的值。</target>
        </trans-unit>
        <trans-unit id="63eed939b8f0aa6e66825ee3882a3480a6666111" translate="yes" xml:space="preserve">
          <source>When adding such a tag, you serve the same content for both domains, telling search engines which URL is canonical. In the previous example, &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; would serve the same content as &lt;code&gt;http://example.org/whaddup&lt;/code&gt;, but with an additional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element in the head:</source>
          <target state="translated">添加此类标记时，您将为两个域提供相同的内容，并告诉搜索引擎哪个URL是规范的URL。在上一个示例中， &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; 将提供与 &lt;code&gt;http://example.org/whaddup&lt;/code&gt; 相同的内容，但头部带有一个附加的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;元素：</target>
        </trans-unit>
        <trans-unit id="59d5afaa19c72d09eeef4b2419754f02979a4b23" translate="yes" xml:space="preserve">
          <source>When an Expires date is set, the deadline is relative to the &lt;em&gt;client&lt;/em&gt; the cookie is being set on, not the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4bb5659f583a468f69b6efcf9b5dc0370b8db9" translate="yes" xml:space="preserve">
          <source>When an HTTP 206 (Partial Content) response message includes the
   content of multiple ranges (a response to a request for multiple
   non-overlapping ranges), these are transmitted as a multipart
   message-body. The media type for this purpose is called
   &quot;multipart/byteranges&quot;.

   The multipart/byteranges media type includes two or more parts, each
   with its own Content-Type and Content-Range fields. The required
   boundary parameter specifies the boundary string used to separate
   each body-part.

       Media Type name:         multipart
       Media subtype name:      byteranges
       Required parameters:     boundary
       Optional parameters:     none
       Encoding considerations: only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
                                permitted
       Security considerations: none


   For example:

   HTTP/1.1 206 Partial Content
   Date: Wed, 15 Nov 1995 06:25:24 GMT
   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 500-999/8000

   ...the first range
   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 7000-7999/8000

   ...the second range
   --THIS_STRING_SEPARATES--

      Notes:

      1) Additional CRLFs may precede the first boundary string in the
         entity. 

      2) Although &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; [&lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt;] permits the boundary string to be
         quoted, some existing implementations handle a quoted boundary
         string incorrectly.

      3) A number of browsers and servers were coded to an early draft
         of the byteranges specification to use a media type of
         multipart/x-byteranges, which is almost, but not quite
         compatible with the version documented in HTTP/1.1.</source>
          <target state="translated">当HTTP 206（部分内容）响应消息包括多个范围的内容（对多个不重叠范围的请求的响应）时，这些内容将作为多部分消息正文进行传输。为此目的的媒体类型称为&amp;ldquo; multipart / byteranges&amp;rdquo;。 multipart / byteranges媒体类型包括两个或多个部分，每个部分都有自己的Content-Type和Content-Range字段。必需的boundary参数指定用于分隔每个身体部位的边界字符串。媒体类型名称：multipart媒体子类型名称：byteranges必需参数：boundary可选参数：none编码注意事项：仅允许使用&amp;ldquo; 7bit&amp;rdquo;，&amp;ldquo; 8bit&amp;rdquo;或&amp;ldquo; binary&amp;rdquo;安全注意事项：无例如：HTTP / 1.1 206部分内容日期：1995年11月15日星期三GMT上次修改时间：1995年11月15日星期三04:58:08 GMT内容类型：multipart / byteranges； boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节500-999 / 8000 ...第一个范围--THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节7000-7999 / 8000。 ..第二个范围--THIS_STRING_SEPARATES--注意：1）其他CRLF可能在实体的第一个边界字符串之前。 2）虽然boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节500-999 / 8000 ...第一个范围--THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节7000-7999 / 8000。 ..第二个范围--THIS_STRING_SEPARATES--注意：1）其他CRLF可能在实体的第一个边界字符串之前。 2）虽然boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节500-999 / 8000 ...第一个范围--THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节7000-7999 / 8000。 ..第二个范围--THIS_STRING_SEPARATES--注意：1）其他CRLF可能在实体的第一个边界字符串之前。 2）虽然&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; [ &lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt; ]允许用引号引起来的边界字符串，某些现有的实现错误地处理了用引号引起的边界字符串。3）许多浏览器和服务器都被编码为byteranges规范的早期草案，以使用multipart / x-byteranges的媒体类型，该媒体类型几乎但不完全兼容HTTP / 1.1中记录的版本。</target>
        </trans-unit>
        <trans-unit id="ed84582108607d5a8e0796d0b676929516566c33" translate="yes" xml:space="preserve">
          <source>When an audio file is requested, like via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">当请求音频文件时，例如通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML元素，大多数浏览器使用特定的值。</target>
        </trans-unit>
        <trans-unit id="9efbf183df3ebd070a5d9eb93570e9456b19792e" translate="yes" xml:space="preserve">
          <source>When an entity-body is included with a message, the data type of that
   body is determined via the header fields Content-Type and Content-
   Encoding. These define a two-layer, ordered encoding model:

       entity-body := Content-Encoding( Content-Type( data ) )

   Content-Type specifies the media type of the underlying data.
   Content-Encoding may be used to indicate any additional content
   codings applied to the data, usually for the purpose of data
   compression, that are a property of the requested resource. There is
   no default encoding.

   Any HTTP/1.1 message containing an entity-body SHOULD include a
   Content-Type header field defining the media type of that body. If
   and only if the media type is not given by a Content-Type field, the
   recipient MAY attempt to guess the media type via inspection of its
   content and/or the name extension(s) of the URI used to identify the
   resource. If the media type remains unknown, the recipient SHOULD
   treat it as type &quot;application/octet-stream&quot;.</source>
          <target state="translated">当一个实体主体被包含在消息中时,该主体的数据类型是通过头字段Content-Type和Content-Encoding决定的。这两个字段定义了一个两层的、有序的编码模型:entity-body :=Content-Encoding(Content-Type(data))。Content-Type指定基础数据的媒体类型。Content-Encoding可用于指示应用于数据的任何附加内容编码,通常是为了数据压缩的目的,是请求资源的一个属性。没有默认的编码。任何包含实体主体的HTTP/1.1消息都应该包含一个Content-Type头域,定义该主体的媒体类型。如果且仅如果媒体类型不是由Content-Type字段给出的,收件人可以尝试通过检查其内容和/或用于识别资源的URI的名称扩展来猜测媒体类型。如果媒体类型仍然未知,接收者应将其视为 &quot;应用程序/octet-stream &quot;类型。</target>
        </trans-unit>
        <trans-unit id="514b34eaec23c4a82ae216c4952b1601e369040b" translate="yes" xml:space="preserve">
          <source>When an expiry date is set, the time and date set is relative to the client the cookie is being set on, not the server.</source>
          <target state="translated">当设置到期日期时,所设置的时间和日期是相对于设置cookie的客户端而言的,而不是服务器。</target>
        </trans-unit>
        <trans-unit id="689ec0aa3c371c99a1bb0c520e872fada7093b46" translate="yes" xml:space="preserve">
          <source>When arrows are found in the resource URL's ('-&amp;gt;'), it means that the first file loaded the next one:</source>
          <target state="translated">当在资源URL的（'-&amp;gt;'）中找到箭头时，表示第一个文件加载了下一个文件：</target>
        </trans-unit>
        <trans-unit id="537cfbce765877e75dc4ddb75367470d9c1d0f61" translate="yes" xml:space="preserve">
          <source>When both the &lt;code&gt;enforce&lt;/code&gt; directive and the &lt;code&gt;report-uri&lt;/code&gt; directive are present, the configuration is referred to as an &quot;enforce-and-report&quot; configuration, signalling to the user agent both that compliance to the Certificate Transparency policy should be enforced and that violations should be reported.</source>
          <target state="translated">当同时存在 &lt;code&gt;enforce&lt;/code&gt; 指令和 &lt;code&gt;report-uri&lt;/code&gt; 指令时，该配置称为&amp;ldquo;强制和报告&amp;rdquo;配置，向用户代理发送信号，即应强制执行对证书透明性策略的遵从性，并应违反要求被报告。</target>
        </trans-unit>
        <trans-unit id="c72d9da42d5a452306e589dd697e9bc2459db237" translate="yes" xml:space="preserve">
          <source>When browsers receive a redirect, they immediately load the new URL provided in the &lt;code&gt;Location&lt;/code&gt; header. Besides the small performance hit of an additional round-trip, users rarely notice the redirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405dbcb99df2fc12205b914cd73322e548995294" translate="yes" xml:space="preserve">
          <source>When comparing two URIs to decide if they match or not, a client
   SHOULD use a case-sensitive octet-by-octet comparison of the entire
   URIs, with these exceptions:

      - A port that is empty or not given is equivalent to the default
        port for that URI-reference;

        - Comparisons of host names MUST be case-insensitive;

        - Comparisons of scheme names MUST be case-insensitive;

        - An empty abs_path is equivalent to an abs_path of &quot;/&quot;.

   Characters other than those in the &quot;reserved&quot; and &quot;unsafe&quot; sets (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;]) are equivalent to their &quot;&quot;%&quot; HEX HEX&quot; encoding.

   For example, the following three URIs are equivalent:

      &lt;a href=&quot;http://abc.com:80/~smith/home.html&quot;&gt;http://abc.com:80/~smith/home.html&lt;/a&gt;&lt;a href=&quot;http://ABC.com/%7Esmith/home.html&quot;&gt;http://ABC.com/%7Esmith/home.html&lt;/a&gt;&lt;a href=&quot;http://ABC.com/%7esmith/home.html&quot;&gt;http://ABC.com:/%7esmith/home.html&lt;/a&gt;</source>
          <target state="translated">比较两个URI以确定它们是否匹配时，客户端应使用整个URI的区分大小写的八位字节比较，但以下情况除外：-空端口或未给出端口等同于默认端口对于该URI引用； -主机名的比较必须不区分大小写； -方案名称的比较必须不区分大小写； -空的abs_path等效于abs_path为&amp;ldquo; /&amp;rdquo;。除&amp;ldquo;保留&amp;rdquo;和&amp;ldquo;不安全&amp;rdquo;集中的字符以外的其他字符（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt; ]）等效于其&amp;ldquo; %% HEX HEX&amp;rdquo;编码。例如，以下三个URI是等效的：&lt;a href=&quot;http://ABC.com/%7Esmith/home.html&quot;&gt;http://abc.com&lt;/a&gt; : &lt;a href=&quot;http://abc.com:80/~smith/home.html&quot;&gt;80/~ &lt;/a&gt;smith/ home.html http：// ABC。com /％7Esmith / home.html&lt;a href=&quot;http://ABC.com/%7esmith/home.html&quot;&gt;http://ABC.com:/%7esmith/home.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17c62a909cae76968be588e261c2cc6fcbe524c4" translate="yes" xml:space="preserve">
          <source>When considering the design of HTTP, it is easy to fall into a trap
   of thinking that all user agents are general-purpose browsers and all
   origin servers are large public websites.  That is not the case in
   practice.  Common HTTP user agents include household appliances,
   stereos, scales, firmware update scripts, command-line programs,
   mobile apps, and communication devices in a multitude of shapes and
   sizes.  Likewise, common HTTP origin servers include home automation 

   units, configurable networking components, office machines,
   autonomous robots, news feeds, traffic cameras, ad selectors, and
   video-delivery platforms.

   The term &quot;user agent&quot; does not imply that there is a human user
   directly interacting with the software agent at the time of a
   request.  In many cases, a user agent is installed or configured to
   run in the background and save its results for later inspection (or
   save only a subset of those results that might be interesting or
   erroneous).  Spiders, for example, are typically given a start URI
   and configured to follow certain behavior while crawling the Web as a
   hypertext graph.

   The implementation diversity of HTTP means that not all user agents
   can make interactive suggestions to their user or provide adequate
   warning for security or privacy concerns.  In the few cases where
   this specification requires reporting of errors to the user, it is
   acceptable for such reporting to only be observable in an error
   console or log file.  Likewise, requirements that an automated action
   be confirmed by the user before proceeding might be met via advance
   configuration choices, run-time options, or simple avoidance of the
   unsafe action; confirmation does not imply any specific user
   interface or interruption of normal processing if the user has
   already made that choice.</source>
          <target state="translated">在考虑HTTP的设计时,人们很容易陷入一个陷阱,认为所有的用户代理都是通用的浏览器,所有的源服务器都是大型的公共网站。实际情况并非如此。常见的HTTP用户代理包括家用电器、音响、衡器、固件更新脚本、命令行程序、移动应用和通信设备等,形状和大小不一。同样,常见的HTTP原点服务器包括家庭自动化装置、可配置的网络组件、办公机、自主机器人、新闻源、交通摄像头、广告选择器和视频发布平台。术语 &quot;用户代理 &quot;并不意味着在请求时有一个人类用户直接与软件代理进行交互。在许多情况下,用户代理被安装或配置为在后台运行,并保存其结果供以后检查(或只保存那些可能有趣或错误的结果的子集)。例如,蜘蛛通常被赋予一个启动URI,并配置为在以超文本图的形式爬行Web时遵循某些行为。HTTP的实现多样性意味着并非所有的用户代理都能向用户提出交互式建议,或者为安全或隐私问题提供足够的警告。在本规范要求向用户报告错误的少数情况下,这种报告只能在错误控制台或日志文件中观察到是可以接受的。同样,要求用户在继续之前确认自动操作的要求,可以通过预先配置选择、运行时选项或简单地避免不安全的操作来满足;如果用户已经做出了选择,确认并不意味着任何特定的用户界面或正常处理的中断。</target>
        </trans-unit>
        <trans-unit id="a827c5b68b1342f6b9dfe8a6f1bbe7a2e6832493" translate="yes" xml:space="preserve">
          <source>When considering using the user agent string to detect which browser is being used, your first step is to try to avoid it if possible. Start by trying to identify &lt;strong&gt;why&lt;/strong&gt; you want to do it.</source>
          <target state="translated">考虑使用用户代理字符串检测正在使用的浏览器时，第一步是尝试避免使用它。首先尝试确定您&lt;strong&gt;为什么&lt;/strong&gt;要这样做。</target>
        </trans-unit>
        <trans-unit id="363ec37ef9e1fc22a7e69c6d6b95891d8282b35a" translate="yes" xml:space="preserve">
          <source>When content negotiation preferences are sent by the user agent in a
   request to encourage an algorithm located at the server to select the
   preferred representation, it is called proactive negotiation (a.k.a.,
   server-driven negotiation).  Selection is based on the available
   representations for a response (the dimensions over which it might
   vary, such as language, content-coding, etc.) compared to various
   information supplied in the request, including both the explicit
   negotiation fields of &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; and implicit characteristics, such
   as the client's network address or parts of the User-Agent field.

   Proactive negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to a user agent, or when the server desires to send its
   &quot;best guess&quot; to the user agent along with the first response (hoping
   to avoid the round trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user).  In order to improve the
   server's guess, a user agent MAY send request header fields that
   describe its preferences.

   Proactive negotiation has serious disadvantages:

   o  It is impossible for the server to accurately determine what might
      be &quot;best&quot; for any given user, since that would require complete
      knowledge of both the capabilities of the user agent and the
      intended use for the response (e.g., does the user want to view it
      on screen or print it on paper?);

   o  Having the user agent describe its capabilities in every request
      can be both very inefficient (given that only a small percentage
      of responses have multiple representations) and a potential risk
      to the user's privacy;

   o  It complicates the implementation of an origin server and the
      algorithms for generating responses to a request; and, 

   o  It limits the reusability of responses for shared caching.

   A user agent cannot rely on proactive negotiation preferences being
   consistently honored, since the origin server might not implement
   proactive negotiation for the requested resource or might decide that
   sending a response that doesn't conform to the user agent's
   preferences is better than sending a 406 (Not Acceptable) response.

   A Vary header field (&lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;) is often sent in a response
   subject to proactive negotiation to indicate what parts of the
   request information were used in the selection algorithm.</source>
          <target state="translated">当用户代理在请求中鼓励内容协商首选项以鼓励位于服务器上的算法选择首选表示形式时，这称为主动协商（也称为服务器驱动的协商）。与请求中提供的各种信息（包括&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节中的&lt;/a&gt;两个显式协商字段）相比，选择是基于响应的可用表示形式（响应可能会变化的维度，例如语言，内容编码等）。以及隐式特征，例如客户端的网络地址或User-Agent字段的一部分。当难以从可用表示中进行选择的算法难以描述给用户代理时，或者当服务器希望将其&amp;ldquo;最佳猜测&amp;rdquo;与第一响应一起发送给用户代理时，主动协商是有利的（希望避免回合如果&amp;ldquo;最佳猜测&amp;rdquo;对用户足够好，则后续请求的跳闸延迟）。为了改善服务器的猜测，用户代理可以发送描述其首选项的请求头字段。主动协商具有严重的缺点：o服务器无法准确确定对于任何给定用户而言&amp;ldquo;最佳&amp;rdquo;的东西，因为这将需要完全了解用户代理的功能以及响应的预期用途（例如，用户是要在屏幕上查看还是在纸上打印？）； o让用户代理在每个请求中描述其功能可能非常低效（假设只有一小部分响应具有多种表示形式），并且可能会对用户的隐私造成潜在威胁； o使源服务器的实现和用于生成对请求的响应的算法变得复杂； o限制了共享缓存响应的可重用性。用户代理不能依赖始终遵循的主动协商偏好，因为原始服务器可能无法为请求的资源实施主动协商，或者可能会决定发送不符合用户代理首选项的响应比发送406（不可接受）响应更好。 Vary标头字段（&lt;a href=&quot;#section-7.1.4&quot;&gt;&lt;/a&gt;通常在响应中发送7.1.4节），该响应需要进行主动协商，以指示选择算法中使用了请求信息的哪些部分。</target>
        </trans-unit>
        <trans-unit id="6e8b863a8325429fa580715d5e011bccf6680ef8" translate="yes" xml:space="preserve">
          <source>When generating the hash, don't include the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace.</source>
          <target state="translated">生成哈希值时，请勿包含&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;标记，并注意大小写和空格很重要，包括前导或尾随空格。</target>
        </trans-unit>
        <trans-unit id="3f48bce4871048870c1db54917c2fa532f74b23b" translate="yes" xml:space="preserve">
          <source>When generating the hash, don't include the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace.</source>
          <target state="translated">生成哈希值时，请勿包含&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;标记，并注意大小写和空格很重要，包括前导或尾随空格。</target>
        </trans-unit>
        <trans-unit id="9503f3849e836b443578c208529989db300450fe" translate="yes" xml:space="preserve">
          <source>When it is necessary to express semantics for a response that are not
   defined by current status codes, a new status code can be registered.
   Status codes are generic; they are potentially applicable to any
   resource, not just one particular media type, kind of resource, or
   application of HTTP.  As such, it is preferred that new status codes
   be registered in a document that isn't specific to a single
   application.

   New status codes are required to fall under one of the categories
   defined in &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;.  To allow existing parsers to process the
   response message, new status codes cannot disallow a payload,
   although they can mandate a zero-length payload body.

   Proposals for new status codes that are not yet widely deployed ought
   to avoid allocating a specific number for the code until there is
   clear consensus that it will be registered; instead, early drafts can
   use a notation such as &quot;4NN&quot;, or &quot;3N0&quot; .. &quot;3N9&quot;, to indicate the
   class of the proposed status code(s) without consuming a number
   prematurely.

   The definition of a new status code ought to explain the request
   conditions that would cause a response containing that status code
   (e.g., combinations of request header fields and/or method(s)) along
   with any dependencies on response header fields (e.g., what fields
   are required, what fields can modify the semantics, and what header
   field semantics are further refined when used with the new status
   code).

   The definition of a new status code ought to specify whether or not
   it is cacheable.  Note that all status codes can be cached if the
   response they occur in has explicit freshness information; however,
   status codes that are defined as being cacheable are allowed to be
   cached without explicit freshness information.  Likewise, the
   definition of a status code can place constraints upon cache
   behavior.  See [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;] for more information.

   Finally, the definition of a new status code ought to indicate
   whether the payload has any implied association with an identified
   resource (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;).</source>
          <target state="translated">当有必要为当前状态代码未定义的响应表达语义时，可以注册新的状态代码。状态码是通用的；它们可能适用于任何资源，而不仅仅是一种特定的媒体类型，资源类型或HTTP应用程序。因此，最好将新的状态代码注册在非特定于单个应用程序的文档中。新状态代码必须属于&lt;a href=&quot;#section-6&quot;&gt;第6节中&lt;/a&gt;定义的类别之一。为了允许现有的解析器处理响应消息，新的状态代码不能禁止有效负载，尽管它们可以强制使用零长度的有效负载主体。对于尚未广泛部署的新状态代码的建议，应避免在为将要注册的明确共识之前为该代码分配一个特定的编号。相反，早期的草稿可以使用诸如&amp;ldquo; 4NN&amp;rdquo;或&amp;ldquo; 3N0&amp;rdquo; ..&amp;ldquo; 3N9&amp;rdquo;之类的符号来表示所提议的状态代码的类别，而不会过早地使用数字。新状态代码的定义应解释将导致包含该状态代码的响应（例如，请求标头字段和/或方法的组合）以及对响应标头字段的任何依赖关系（例如，什么）的请求条件必填字段，与新的状态代码一起使用时，哪些字段可以修改语义，哪些标题字段的语义需要进一步完善。新状态代码的定义应指定是否可缓存。请注意，如果所有状态码的响应都具有明确的新鲜度信息，则可以将其缓存。但是，允许将定义为可缓存的状态代码缓存起来，而无需显式的新鲜度信息。同样，状态码的定义可以对缓存行为施加约束。见[请注意，如果所有状态码的响应都具有明确的新鲜度信息，则可以将其缓存。但是，允许将定义为可缓存的状态代码缓存起来，而无需显式的新鲜度信息。同样，状态码的定义可以对缓存行为施加约束。见[请注意，如果所有状态码的响应都具有明确的新鲜度信息，则可以将其缓存。但是，允许将定义为可缓存的状态代码缓存起来，而无需显式的新鲜度信息。同样，状态码的定义可以对缓存行为施加约束。见[&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]以获取更多信息。最后，新状态代码的定义应指示有效载荷是否与所标识的资源有任何隐式关联（&lt;a href=&quot;#section-3.1.4.1&quot;&gt;第3.1.4.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="992ffeef665788e48dbe3069859c70bc8ca73c53" translate="yes" xml:space="preserve">
          <source>When making a request to a proxy, other than a CONNECT or server-wide
   OPTIONS request (as detailed below), a client MUST send the target
   URI in absolute-form as the request-target.

     absolute-form  = absolute-URI

   The proxy is requested to either service that request from a valid
   cache, if possible, or make the same request on the client's behalf
   to either the next inbound proxy server or directly to the origin
   server indicated by the request-target.  Requirements on such
   &quot;forwarding&quot; of messages are defined in &lt;a href=&quot;#section-5.7&quot;&gt;Section 5.7&lt;/a&gt;.

   An example absolute-form of request-line would be:

     GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1 

   To allow for transition to the absolute-form for all requests in some
   future version of HTTP, a server MUST accept the absolute-form in
   requests, even though HTTP/1.1 clients will only send them in
   requests to proxies.</source>
          <target state="translated">当向代理发出请求时，除了CONNECT或服务器范围内的OPTIONS请求（如下所述）外，客户端务必发送绝对格式的目标URI作为请求目标。absolute-form = absolute-URI（如果可能），请求代理服务器从有效缓存中为该请求提供服务，或者代表客户端向下一个入站代理服务器或直接向请求指示的原始服务器提出相同请求-目标。在&lt;a href=&quot;#section-5.7&quot;&gt;第5.7节&lt;/a&gt;中定义了对此类消息&amp;ldquo;转发&amp;rdquo;的要求。请求行的绝对格式示例为：GET http://www.example.org/pub/WWW/TheProject.html HTTP / 1.1允许在将来的某些版本中将所有请求转换为绝对格式HTTP，即使HTTP / 1.1客户端仅将请求中的绝对形式发送给代理，服务器也必须接受请求中的绝对形式。</target>
        </trans-unit>
        <trans-unit id="5964da98a7563489c792bd7738fa111b60299bfb" translate="yes" xml:space="preserve">
          <source>When more than one conditional request header field is present in a
   request, the order in which the fields are evaluated becomes
   important.  In practice, the fields defined in this document are
   consistently implemented in a single, logical order, since &quot;lost
   update&quot; preconditions have more strict requirements than cache
   validation, a validated cache is more efficient than a partial
   response, and entity tags are presumed to be more accurate than date
   validators.

   A recipient cache or origin server MUST evaluate the request
   preconditions defined by this specification in the following order:

   1.  When recipient is the origin server and If-Match is present,
       evaluate the If-Match precondition:

       *  if true, continue to step 3

       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) 

   2.  When recipient is the origin server, If-Match is not present, and
       If-Unmodified-Since is present, evaluate the If-Unmodified-Since
       precondition:

       *  if true, continue to step 3

       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;)

   3.  When If-None-Match is present, evaluate the If-None-Match
       precondition:

       *  if true, continue to step 5

       *  if false for GET/HEAD, respond 304 (Not Modified)

       *  if false for other methods, respond 412 (Precondition Failed)

   4.  When the method is GET or HEAD, If-None-Match is not present, and
       If-Modified-Since is present, evaluate the If-Modified-Since
       precondition:

       *  if true, continue to step 5

       *  if false, respond 304 (Not Modified)

   5.  When the method is GET and both Range and If-Range are present,
       evaluate the If-Range precondition:

       *  if the validator matches and the Range specification is
          applicable to the selected representation, respond 206
          (Partial Content) [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   6.  Otherwise,

       *  all conditions are met, so perform the requested action and
          respond according to its success or failure.

   Any extension to HTTP/1.1 that defines additional conditional request
   header fields ought to define its own expectations regarding the
   order for evaluating such fields in relation to those defined in this
   document and other conditionals that might be found in practice.</source>
          <target state="translated">当一个请求中存在多个条件请求标头字段时，评估字段的顺序就变得很重要。实际上，本文档中定义的字段以单个逻辑顺序一致地实现，因为&amp;ldquo;丢失更新&amp;rdquo;的先决条件比缓存验证具有更严格的要求，经过验证的缓存比部分响应更有效，并且假定实体标签可以比日期验证器更准确。接收者缓存或原始服务器必须按以下顺序评估此规范定义的请求前提条件：1.当接收者是原始服务器且存在If-Match时，评估If-Match前提条件：*如果为true，则继续执行步骤3 *如果为假，响应412（前提条件失败），除非可以确定状态更改请求已经成功（请参见&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;）2.如果接收方是原始服务器，如果不存在If-Match，并且存在If-Unmodified-Since，则评估If-Unmodified-Since前提：*如果为true，则继续执行步骤3 *如果为false，则响应412（前提条件失败），除非可以确定状态更改请求已经成功（请参阅&lt;a href=&quot;#section-3.4&quot;&gt;第3.4节）&lt;/a&gt;）3.如果存在If-None-Match，则评估If-None-Match前提：*如果为true，则继续执行第5步*如果GET / HEAD为false，则响应304（未修改）*如果对于其他方法为false，响应412（前提条件失败）4.当方法为GET或HEAD，If-None-Match不存在且If-Modified-Since存在时，评估If-Modified-Since前提条件：*如果为true，则继续执行步骤5 *如果为假，则响应304（未修改）5.当方法为GET并且同时存在Range和If-Range时，请评估If-Range前提条件：*如果验证符匹配且Range规范适用于所选表示形式，回应206（部分内容）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;] 6.否则，*满足所有条件，因此请执行请求的操作并根据其成功或失败进行响应。定义其他条件请求标头字段的HTTP / 1.1的任何扩展都应针对与本文档中定义的字段和其他可能在实践中发现的条件相关的字段的评估顺序，定义自己的期望。</target>
        </trans-unit>
        <trans-unit id="012095a2ecfbd653fa333e34acf5cb049a30844a" translate="yes" xml:space="preserve">
          <source>When multiple transfer codings are acceptable, the &lt;code&gt;q&lt;/code&gt; parameter of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; syntax can rank codings by preference.</source>
          <target state="translated">当可接受多个传输编码时，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;质量值&lt;/a&gt;语法的 &lt;code&gt;q&lt;/code&gt; 参数可以按优先级对编码进行排名。</target>
        </trans-unit>
        <trans-unit id="f6fe88ae046c3e416533e0417c1df22db8f56bfa" translate="yes" xml:space="preserve">
          <source>When navigating through different networks of the Internet, proxy servers and HTTP tunnels are facilitating access to content on the World Wide Web. A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet. This page outlines some basics about proxies and introduces a few configuration options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45873daa29905f82c21b98d3ce8067de352cd0b" translate="yes" xml:space="preserve">
          <source>When navigating through different networks of the Internet, proxy servers and HTTP tunnels are facilitating access to content on the World Wide Web. A proxy can be on the user's local computer, or anywhere between the user's computer and an destination server on the Internet. This page outlines some basics about proxies and introduces a few configuration options.</source>
          <target state="translated">当在互联网的不同网络中浏览时,代理服务器和HTTP隧道是方便访问万维网上的内容。代理服务器可以在用户的本地计算机上,也可以在用户的计算机和互联网上的目标服务器之间的任何地方。本页概述了关于代理的一些基本知识,并介绍了一些配置选项。</target>
        </trans-unit>
        <trans-unit id="2cf69f0b62bc3201eb1d5247cb7d21efe9fcd7bc" translate="yes" xml:space="preserve">
          <source>When passing a string literal like to methods like: &lt;code&gt;window.setTimeout(&quot;alert(\&quot;Hello World!\&quot;);&quot;, 500);&lt;/code&gt;</source>
          <target state="translated">将字符串文字传递给类似这样的方法时： &lt;code&gt;window.setTimeout(&quot;alert(\&quot;Hello World!\&quot;);&quot;, 500);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d3e1568b9d8f26b7cf9b41cc05173988e6bafcb" translate="yes" xml:space="preserve">
          <source>When people say they want &quot;browser detection&quot;, often they actually want &quot;rendering engine detection&quot;. Do you actually want to detect Firefox, as opposed to SeaMonkey, or Chrome as opposed to Chromium? Or do you actually simply want to see if the browser is using the Gecko or the WebKit rendering engine? If this is what you need, see further down the page.</source>
          <target state="translated">当人们说要 &quot;浏览器检测 &quot;的时候,往往其实是要 &quot;渲染引擎检测&quot;。其实你是想检测Firefox,而不是SeaMonkey,还是Chrome,而不是Chromium?或者你实际上只是想看看浏览器是否使用Gecko或WebKit渲染引擎?如果这是你所需要的,请继续往下看。</target>
        </trans-unit>
        <trans-unit id="641c314e0a3e7172c6dc4519de6003467c4aa390" translate="yes" xml:space="preserve">
          <source>When performing If header processing, the definition of a matching
   state token or entity tag is as follows:

   Identifying a resource: The resource is identified by the URI along
   with the token, in tagged list production, or by the Request-URI in
   untagged list production.

   Matching entity tag: Where the entity tag matches an entity tag
   associated with the identified resource.  Servers MUST use either the
   weak or the strong comparison function defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Section&amp;nbsp;13.3.3 of
   [RFC2616]&lt;/a&gt;.

   Matching state token: Where there is an exact match between the state
   token in the If header and any state token on the identified
   resource.  A lock state token is considered to match if the resource
   is anywhere in the scope of the lock.

   Handling unmapped URLs: For both ETags and state tokens, treat as if
   the URL identified a resource that exists but does not have the
   specified state.</source>
          <target state="translated">在执行If标头处理时，匹配状态令牌或实体标签的定义如下：标识资源：资源是由URI和令牌一起在标记列表生成中标识的，或者由Request-URI在未标记列表中标识的生产。匹配实体标签：实体标签与与标识的资源关联的实体标签匹配的地方。服务器必须使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;[RFC2616]第13.3.3节中&lt;/a&gt;定义的弱或强比较功能。匹配状态令牌：If头中的状态令牌与所标识资源上的任何状态令牌之间完全匹配的位置。如果资源在锁范围内的任何位置，则认为锁状态令牌是匹配的。处理未映射的URL：对于ETag和状态标记，都应将其视为URL标识了存在但不具有指定状态的资源。</target>
        </trans-unit>
        <trans-unit id="2e596c5772c2e6ae2a45b036f02565ea11dd1152" translate="yes" xml:space="preserve">
          <source>When possible, use HTTP redirects and don't add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element redirects. If someone changes the HTTP redirects but forgets to change the HTML redirects, the redirects will no longer be identical, which could cause an infinite loop or other nightmares.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431409982a981ed89ff2dc5506166f45957e0a11" translate="yes" xml:space="preserve">
          <source>When possible, use HTTP redirects, and don't add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element redirects. If someone changes the HTTP redirects and forgets to change the HTML redirects the redirects will no longer be identical, which could cause an infinite loop or other nightmares.</source>
          <target state="translated">如果可能，请使用HTTP重定向，并且不要添加&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素重定向。如果有人更改了HTTP重定向，却忘记了更改HTML重定向，则重定向将不再相同，这可能导致无限循环或其他噩梦。</target>
        </trans-unit>
        <trans-unit id="5c6db50a4bbf09d3b72d3f46fb9f7f812630cfd6" translate="yes" xml:space="preserve">
          <source>When present on a response to a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request that has no body, it indicates the value that would have applied to the corresponding &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; message.</source>
          <target state="translated">当出现在没有主体的&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;请求的响应中时，它指示将应用于相应的&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;消息的值。</target>
        </trans-unit>
        <trans-unit id="8d602fc4361edf535f13cf0e83c68250a27555fa" translate="yes" xml:space="preserve">
          <source>When present with the &lt;code&gt;enforce&lt;/code&gt; directive, the configuration is referred to as an &quot;enforce-and-report&quot; configuration, signalling to the user agent both that compliance to the Certificate Transparency policy should be enforced &lt;em&gt;and&lt;/em&gt; that violations should be reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2677bfe338fef1db9d7d5bb4695ba60efdfb09e0" translate="yes" xml:space="preserve">
          <source>When presented with a request, a cache MUST NOT reuse a stored
   response, unless:

   o  The presented effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;) and
      that of the stored response match, and

   o  the request method associated with the stored response allows it
      to be used for the presented request, and

   o  selecting header fields nominated by the stored response (if any)
      match those presented (see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;), and 

   o  the presented request does not contain the no-cache pragma
      (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), nor the no-cache cache directive (&lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;),
      unless the stored response is successfully validated
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;), and

   o  the stored response does not contain the no-cache cache directive
      (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;), unless it is successfully validated
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;), and

   o  the stored response is either:

      *  fresh (see &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;), or

      *  allowed to be served stale (see &lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;), or

      *  successfully validated (see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;.

   When a stored response is used to satisfy a request without
   validation, a cache MUST generate an Age header field (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;),
   replacing any present in the response with a value equal to the
   stored response's current_age; see &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

   A cache MUST write through requests with methods that are unsafe
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;) to the origin server; i.e., a cache is
   not allowed to generate a reply to such a request before having
   forwarded the request and having received a corresponding response.

   Also, note that unsafe requests might invalidate already-stored
   responses; see &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;.

   When more than one suitable response is stored, a cache MUST use the
   most recent response (as determined by the Date header field).  It
   can also forward the request with &quot;Cache-Control: max-age=0&quot; or
   &quot;Cache-Control: no-cache&quot; to disambiguate which response to use.

   A cache that does not have a clock available MUST NOT use stored
   responses without revalidating them upon every use.</source>
          <target state="translated">收到请求时，缓存不得重复使用存储的响应，除非：o所显示的有效请求URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]的5.5节&lt;/a&gt;）与存储的响应的URI 匹配，并且o与存储的响应关联的请求方法允许它用于提出的请求，并且o选择由存储的响应指定的头字段（如果有的话）匹配所提出的头字段（请参阅&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;），并且o该提出的请求不包含无缓存编译指示（&lt;a href=&quot;#section-5.4&quot;&gt;第5.4节&lt;/a&gt;），或no-cache cache指令（&lt;a href=&quot;#section-5.2.1&quot;&gt;第5.2.1节&lt;/a&gt;），除非已成功验证存储的响应（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节）&lt;/a&gt;），并且o存储的响应不包含no-cache cache指令（&lt;a href=&quot;#section-5.2.2.2&quot;&gt;第5.2.2.2节&lt;/a&gt;），除非它已成功验证（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;），并且o存储的响应是：*新鲜（请参阅&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt;），或*允许陈旧（请参阅&lt;a href=&quot;#section-4.2.4&quot;&gt;第4.2.4节&lt;/a&gt;），或*已成功验证（请参阅&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）。请注意，上面列出的任何要求都可以由缓存控制扩展覆盖。见&lt;a href=&quot;#section-5.2.3&quot;&gt;5.2.3节&lt;/a&gt;。当使用存储的响应来满足请求而不进行验证时，缓存必须生成Age标头字段（&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节）&lt;/a&gt;），将响应中存在的任何值替换为等于存储的响应的current_age的值；见&lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3节&lt;/a&gt;。高速缓存必须使用不安全的方法（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]的第4.2.1节&lt;/a&gt;）将请求写入原始服务器；也就是说，在转发请求并接收到相应响应之前，不允许缓存生成对此类请求的答复。另外，请注意，不安全的请求可能会使已存储的响应无效。参见&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;。当存储了多个合适的响应时，缓存必须使用最新的响应（由Date标头字段确定）。它还可以使用&amp;ldquo; Cache-Control：max-age = 0&amp;rdquo;或&amp;ldquo; Cache-Control：no-cache&amp;rdquo;转发请求，以消除使用哪个响应的歧义。没有可用时钟的缓存不得使用已存储的响应，而无需在每次使用时对其进行重新验证。</target>
        </trans-unit>
        <trans-unit id="118ca9fdf6295ed6b61ba0d26cdb23fa50df2281" translate="yes" xml:space="preserve">
          <source>When receiving an HTTP request, a server can send a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header with the response. The cookie is usually stored by the browser, and then the cookie is sent with requests made to the same server inside a &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; HTTP header. An expiration date or duration can be specified, after which the cookie is no longer sent. Additionally, restrictions to a specific domain and path can be set, limiting where the cookie is sent.</source>
          <target state="translated">收到HTTP请求时，服务器可以发送带有响应的&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;标头。该cookie通常是由浏览器存储，然后该cookie与一个内部的同一服务器发出的请求发送&lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;的HTTP标头。可以指定到期日期或持续时间，之后将不再发送Cookie。此外，可以设置对特定域和路径的限制，从而限制cookie的发送位置。</target>
        </trans-unit>
        <trans-unit id="2e9b93794ed31355629f157a820821c9c468143b" translate="yes" xml:space="preserve">
          <source>When requesting an image, like through an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; element, user-agent often sets a specific list of media types to be welcomed.</source>
          <target state="translated">当请求图像时，例如通过HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;元素，用户代理通常会设置要欢迎的特定媒体类型列表。</target>
        </trans-unit>
        <trans-unit id="8497a7a0712bffc13bbeb91db7dcfe0053667c2b" translate="yes" xml:space="preserve">
          <source>When responding to a credentialed request, the server &lt;strong&gt;must&lt;/strong&gt; specify an origin in the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, instead of specifying the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard.</source>
          <target state="translated">当响应凭据请求时，服务器&lt;strong&gt;必须&lt;/strong&gt;在 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头的值中指定一个来源，而不是指定&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;通配符。</target>
        </trans-unit>
        <trans-unit id="d1d5e8076fc20454045b01525a599db69f9d0096" translate="yes" xml:space="preserve">
          <source>When responses convey payload information, whether indicating a
   success or an error, the origin server often has different ways of
   representing that information; for example, in different formats,
   languages, or encodings.  Likewise, different users or user agents
   might have differing capabilities, characteristics, or preferences
   that could influence which representation, among those available,
   would be best to deliver.  For this reason, HTTP provides mechanisms
   for content negotiation.

   This specification defines two patterns of content negotiation that
   can be made visible within the protocol: &quot;proactive&quot;, where the
   server selects the representation based upon the user agent's stated
   preferences, and &quot;reactive&quot; negotiation, where the server provides a
   list of representations for the user agent to choose from.  Other
   patterns of content negotiation include &quot;conditional content&quot;, where
   the representation consists of multiple parts that are selectively
   rendered based on user agent parameters, &quot;active content&quot;, where the
   representation contains a script that makes additional (more
   specific) requests based on the user agent characteristics, and
   &quot;Transparent Content Negotiation&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC2295&lt;/a&gt;]), where content 

   selection is performed by an intermediary.  These patterns are not
   mutually exclusive, and each has trade-offs in applicability and
   practicality.

   Note that, in all cases, HTTP is not aware of the resource semantics.
   The consistency with which an origin server responds to requests,
   over time and over the varying dimensions of content negotiation, and
   thus the &quot;sameness&quot; of a resource's observed representations over
   time, is determined entirely by whatever entity or algorithm selects
   or generates those responses.  HTTP pays no attention to the man
   behind the curtain.</source>
          <target state="translated">当响应传达有效载荷信息时，无论是指示成功还是错误，原始服务器通常会以不同的方式表示该信息。例如，以不同的格式，语言或编码。同样，不同的用户或用户代理可能具有不同的功能，特性或偏好，这些能力，特性或偏好可能会影响在可用的那些表示中最好传递的表示。因此，HTTP提供了用于内容协商的机制。该规范定义了两种可以在协议中显示的内容协商模式：&amp;ldquo;主动&amp;rdquo;协商，其中服务器根据用户代理的指定偏好选择表示形式；&amp;ldquo;主动&amp;rdquo;协商，服务器在其中提供表示形式的列表供用户代理选择。内容协商的其他模式包括&amp;ldquo;条件内容&amp;rdquo;和&amp;ldquo;活动内容&amp;rdquo;，其中&amp;ldquo;条件内容&amp;rdquo;表示基于用户代理参数有选择地呈现的多个部分；&amp;ldquo;活动内容&amp;rdquo;中，表示包含基于脚本的其他（更具体）请求的脚本。用户代理特征和&amp;ldquo;透明内容协商&amp;rdquo;（[其中的表示形式包含一个脚本，该脚本根据用户代理的特征和&amp;ldquo;透明内容协商&amp;rdquo;（[[其中的表示形式包含一个脚本，该脚本根据用户代理的特征和&amp;ldquo;透明内容协商&amp;rdquo;（[[&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC2295&lt;/a&gt; ]），其中内容选择由中介执行。这些模式不是互斥的，并且在适用性和实用性方面都有取舍。请注意，在所有情况下，HTTP都不了解资源语义。源服务器随时间推移以及在内容协商的不同维度上响应请求的一致性，以及因此资源随时间观察到的表示的&amp;ldquo;相同性&amp;rdquo;，完全由实体或算法选择或生成那些响应来确定。 HTTP不理会幕后的人。</target>
        </trans-unit>
        <trans-unit id="bb60f936f846aaffe2cddcca884c71458177df7b" translate="yes" xml:space="preserve">
          <source>When resuming to request more parts of a resource, you need to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">当恢复请求资源的更多部分时,你需要保证存储的资源在收到最后一个片段后没有被修改。</target>
        </trans-unit>
        <trans-unit id="112139cb42754557c5251097c3d9d57a0f0f1846" translate="yes" xml:space="preserve">
          <source>When saving changes to a wiki page (posting data), the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request will contain the &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; header containing the &lt;code&gt;ETag&lt;/code&gt; values to check freshness against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9c62d45614a9fc9c768607aa8dd717eb012aae" translate="yes" xml:space="preserve">
          <source>When saving changes to a wiki page (posting data), the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request will contain the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; header containing the &lt;code&gt;ETag&lt;/code&gt; values to check freshness against.</source>
          <target state="translated">将更改保存到Wiki页面（发布数据）时，&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求将包含&lt;a href=&quot;if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;头，其中包含 &lt;code&gt;ETag&lt;/code&gt; 值以检查更新。</target>
        </trans-unit>
        <trans-unit id="3ecf0a10a5d9c4c3b83b0e8a52e69826167aa3c7" translate="yes" xml:space="preserve">
          <source>When sending a conditional request for cache validation, a cache
   sends one or more precondition header fields containing validator
   metadata from its stored response(s), which is then compared by
   recipients to determine whether a stored response is equivalent to a
   current representation of the resource.

   One such validator is the timestamp given in a Last-Modified header
   field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC7232]&lt;/a&gt;), which can be used in an
   If-Modified-Since header field for response validation, or in an
   If-Unmodified-Since or If-Range header field for representation
   selection (i.e., the client is referring specifically to a previously
   obtained representation with that timestamp).

   Another validator is the entity-tag given in an ETag header field
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7232]&lt;/a&gt;).  One or more entity-tags, indicating one
   or more stored responses, can be used in an If-None-Match header
   field for response validation, or in an If-Match or If-Range header
   field for representation selection (i.e., the client is referring
   specifically to one or more previously obtained representations with
   the listed entity-tags).</source>
          <target state="translated">当发送有条件的请求以进行缓存验证时，缓存会从存储的响应中发送一个或多个包含验证者元数据的前置条件标头字段，接收者随后将其进行比较以确定存储的响应是否等效于资源的当前表示形式。一种这样的验证器是Last-Modified头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232]的2.2节）中&lt;/a&gt;给出的时间戳，可以在If-Modified-Since头字段中用于响应验证，或者在If-Unmodified-Since或If中使用。 -用于表示形式选择的范围标头字段（即，客户端专门引用具有该时间戳的先前获得的表示形式）。另一个验证器是ETag标头字段中提供的实体标签（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]第2.3节&lt;/a&gt;）。一个或多个表示一个或多个存储响应的实体标签可以在If-None-Match标头字段中用于响应验证，也可以在If-Match或If-Range标头字段中用于表示选择（即，客户端专门指具有列出的实体标签的一种或多种先前获得的表示形式。</target>
        </trans-unit>
        <trans-unit id="fce832cc958ff4ef014da90639644dd9e45d6938" translate="yes" xml:space="preserve">
          <source>When sent with a &lt;a href=&quot;../status/429&quot;&gt;&lt;code&gt;429&lt;/code&gt;&lt;/a&gt; (Too Many Requests) response, this indicates how long to wait before making a new request.</source>
          <target state="translated">当发送&lt;a href=&quot;../status/429&quot;&gt; &lt;code&gt;429&lt;/code&gt; &lt;/a&gt;（请求过多）响应时，这表明发出新请求之前要等待多长时间。</target>
        </trans-unit>
        <trans-unit id="79ae6cec0f4f3064c8648fb0e2f622088ea4675c" translate="yes" xml:space="preserve">
          <source>When sent with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, this indicates how long the service is expected to be unavailable.</source>
          <target state="translated">当发送&lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt;（服务不可用）响应时，这表明该服务预计将不可用多长时间。</target>
        </trans-unit>
        <trans-unit id="e83d0887ca1d1fc9960fe8e57672e00926af79bd" translate="yes" xml:space="preserve">
          <source>When sent with a redirect response, such as &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; (Moved Permanently), this indicates the minimum time that the user agent is asked to wait before issuing the redirected request.</source>
          <target state="translated">与重定向响应一起发送时，例如&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;（永久移动），这表示在发出重定向请求之前，要求用户代理等待的最短时间。</target>
        </trans-unit>
        <trans-unit id="c92c83a3263a103661248f1683416444f3d70f52" translate="yes" xml:space="preserve">
          <source>When submitting a lock request, a user agent may also submit an
   'owner' XML field giving contact information for the person taking
   out the lock (for those cases where a person, rather than a robot, is
   taking out the lock).  This contact information is stored in a DAV:
   lockdiscovery property on the resource, and can be used by other 

   collaborators to begin negotiation over access to the resource.
   However, in many cases, this contact information can be very private,
   and should not be widely disseminated.  Servers SHOULD limit read
   access to the DAV:lockdiscovery property as appropriate.
   Furthermore, user agents SHOULD provide control over whether contact
   information is sent at all, and if contact information is sent,
   control over exactly what information is sent.</source>
          <target state="translated">当提交一个锁请求时,用户代理也可以提交一个 &quot;所有者 &quot;XML字段,给出取出锁的人的联系信息(对于那些由人而不是机器人取出锁的情况)。这个联系信息被存储在资源上的DAV:lockdiscovery属性中,并可被其他合作者用来开始对资源的访问进行协商。然而,在许多情况下,这个联系信息可能是非常私密的,不应该被广泛传播。服务器应该适当限制对DAV:lockdiscovery属性的读取访问。此外,用户代理应该提供对是否发送联系信息的控制,如果发送了联系信息,还应该提供对具体发送什么信息的控制。</target>
        </trans-unit>
        <trans-unit id="48e2270a1e81d7fd634978728cb4b921d727d1ad" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; status code is sent, this MIME type indicates that the document is composed of several parts, one for each of the requested ranges. Like other multipart types, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; uses a &lt;code&gt;boundary&lt;/code&gt; to separate the pieces. Each piece has a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header with its actual type and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; of the range it represents.</source>
          <target state="translated">当&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Partial Content&lt;/code&gt; 被发送的状态码，此MIME类型指示该文件是由几个部分组成，一个用于每个所请求的范围中的。像其他多部分类型一样，&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;使用 &lt;code&gt;boundary&lt;/code&gt; 来分隔各个部分。每个片段都有一个&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;标头及其实际类型，以及它表示的范围的&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ba16d0b2909ed8c865e2f861632fd65055bfc45" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;POST&lt;/code&gt; request is sent via a method other than an HTML form &amp;mdash; like via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; &amp;mdash; the body can take any type. As described in the HTTP 1.1 specification, &lt;code&gt;POST&lt;/code&gt; is designed to allow a uniform method to cover the following functions:</source>
          <target state="translated">当通过HTML表单以外的方法（例如通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;）发送 &lt;code&gt;POST&lt;/code&gt; 请求时，主体可以采用任何类型。如HTTP 1.1规范中所述， &lt;code&gt;POST&lt;/code&gt; 被设计为允许一种统一的方法来覆盖以下功能：</target>
        </trans-unit>
        <trans-unit id="ee1ae4b4d29880b199bbb96de77973c9bb419343" translate="yes" xml:space="preserve">
          <source>When the client wants to communicate with a server, either being the final server or an intermediate proxy, it performs the following steps:</source>
          <target state="translated">当客户端要与服务器(无论是最终服务器还是中间代理)进行通信时,它将执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="b883869a25a4436318f14eff46717c107adc1c67" translate="yes" xml:space="preserve">
          <source>When the condition fails for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, then the server must return HTTP status code 304 (Not Modified). For methods that apply server-side changes, the status code 412 (Precondition Failed) is used. Note that the server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request: Cache-Control, Content-Location, Date, ETag, Expires, and Vary.</source>
          <target state="translated">当条件对于&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法失败时，服务器必须返回HTTP状态码304（未修改）。对于应用服务器端更改的方法，使用状态码412（前提条件失败）。注意，生成304响应的服务器必须生成以下任何头域，这些头域将在对同一请求的200（OK）响应中发送：Cache-Control，Content-Location，Date，ETag，Expires和Vary。</target>
        </trans-unit>
        <trans-unit id="bb9a689d273317ba5ef7624a99ac855ef096064b" translate="yes" xml:space="preserve">
          <source>When the expiration time specified by the Strict-Transport-Security header elapses, the next attempt to load the site via HTTP will proceed as normal instead of automatically using HTTPS.</source>
          <target state="translated">当Strict-Transport-Security头指定的过期时间过后,下一次通过HTTP加载网站的尝试将正常进行,而不是自动使用HTTPS。</target>
        </trans-unit>
        <trans-unit id="4d04c0cd831cfd20faa7e1fe732a4e0914639cf8" translate="yes" xml:space="preserve">
          <source>When the form is submitted, the site generates a receipt for the transaction. The server could use &lt;code&gt;Content-Location&lt;/code&gt; to indicate that receipt's URL for future access.</source>
          <target state="translated">提交表单后，站点将为交易生成收据。服务器可以使用 &lt;code&gt;Content-Location&lt;/code&gt; 指示收据的URL，以供将来访问。</target>
        </trans-unit>
        <trans-unit id="54bc09488c526dacffc841e2906f0ddbba4554d0" translate="yes" xml:space="preserve">
          <source>When the source resource is not a collection, the result of the COPY
   method is the creation of a new resource at the destination whose
   state and behavior match that of the source resource as closely as
   possible.  Since the environment at the destination may be different
   than at the source due to factors outside the scope of control of the
   server, such as the absence of resources required for correct
   operation, it may not be possible to completely duplicate the
   behavior of the resource at the destination.  Subsequent alterations
   to the destination resource will not modify the source resource.
   Subsequent alterations to the source resource will not modify the
   destination resource.</source>
          <target state="translated">当源资源不是集合时,COPY方法的结果是在目标地创建一个新的资源,其状态和行为尽可能地与源资源的状态和行为相匹配。由于在服务器控制范围之外的因素,如缺乏正确操作所需的资源,目标处的环境可能与源处不同,因此可能无法完全复制目标处资源的行为。随后对目的资源的改变不会修改源资源。随后对源资源的更改不会修改目的资源。</target>
        </trans-unit>
        <trans-unit id="5486bfa60602bb895214d015f37fd5698ae7c49a" translate="yes" xml:space="preserve">
          <source>When to Use Entity-Tags and Last-Modified Dates (RFC 7232)</source>
          <target state="translated">何时使用实体标签和最后修改日期(RFC 7232)</target>
        </trans-unit>
        <trans-unit id="b34a4c2a8d2bd2be505eebfefc7f3521b9c0bbcf" translate="yes" xml:space="preserve">
          <source>When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">当用作对预检请求的响应的一部分时，这表明是否可以使用凭据发出实际请求。请注意，简单的&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;请求不会进行预检，因此，如果对具有凭据的资源进行了请求，并且此标头未随资源一起返回，则浏览器将忽略该响应，并且不会将其返回给Web内容。</target>
        </trans-unit>
        <trans-unit id="f6658a6f8ffe56893681a8ca01fe29c5f148086e" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; has precedence (if the server supports it).</source>
          <target state="translated">与&lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;结合使用时， &lt;code&gt;If-None-Match&lt;/code&gt; 具有优先级（如果服务器支持）。</target>
        </trans-unit>
        <trans-unit id="a59bbd7394bbd946e2f8e6daaaadb0ebcf7845d8" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt;, it is ignored, unless the server doesn't support &lt;code&gt;If-None-Match&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;结合使用时，它将被忽略，除非服务器不支持 &lt;code&gt;If-None-Match&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="940d765e5e6f04c24517cbcdc47ec43569264193" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerPolicy&quot;&gt;&lt;code&gt;Request.referrerPolicy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch时&lt;/a&gt;：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerPolicy&quot;&gt; &lt;code&gt;Request.referrerPolicy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95651ca261ced0fa7d7a802f20f0fac00474ad6e" translate="yes" xml:space="preserve">
          <source>When using URLs in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; content, you should generally only use a few of these URL schemes. When referring to subresources &amp;mdash; that is, files that are being loaded as part of a larger document &amp;mdash; you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.</source>
          <target state="translated">在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt;内容中使用URL时，通常应仅使用其中一些URL方案。引用子资源时（即，作为较大文档的一部分加载的文件），应仅使用HTTP和HTTPS方案。出于安全原因，越来越多的浏览器不再支持使用FTP加载子资源。</target>
        </trans-unit>
        <trans-unit id="9eea4faa25e4e579cef40974188a8f16f3f6d744" translate="yes" xml:space="preserve">
          <source>When using the &quot;&lt;code&gt;must-revalidate&lt;/code&gt;&quot; directive, the cache must verify the status of the stale resources before using it and expired ones should not be used. For more details, see the &lt;a href=&quot;#Cache_validation&quot;&gt;Validation&lt;/a&gt; section below.</source>
          <target state="translated">当使用&amp;ldquo; &lt;code&gt;must-revalidate&lt;/code&gt; &amp;rdquo;指令时，缓存必须在使用之前验证过时资源的状态，并且不应使用过期的资源。有关更多详细信息，请参见下面的&amp;ldquo; &lt;a href=&quot;#Cache_validation&quot;&gt;验证&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="ecdb14111320a66294518a2069105521deccaff6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. For example, if you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. It can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">使用 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 标头时，缓存服务器在决定是否从缓存中提供页面时应考虑用户代理。例如，如果您要为移动用户提供不同的内容，它可以帮助您避免缓存可能会错误地为移动用户提供网站的桌面版本。它可以帮助Google和其他搜索引擎发现网页的移动版本，并且还可以告诉他们没有&lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;隐瞒&lt;/a&gt;的意图。</target>
        </trans-unit>
        <trans-unit id="b3026e4bf68b068a4b6ce5495c541e344d3b11c9" translate="yes" xml:space="preserve">
          <source>When you restructure Web sites, URLs change. Even if you update your site's links to match the new URLs, you have no control over the URLs used by external resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f075b4f1650209d71c1757142531e91ebe323426" translate="yes" xml:space="preserve">
          <source>When you restructure Web sites, URLs of resources change. Even if you can update the internal links of your Web site to match the new naming scheme, you have no control over the URLs used by external resources. You don't want to break these links, as they bring you valuable users (and help your SEO), so you set up redirects from the old URLs to the new ones.</source>
          <target state="translated">当你重组网站时,资源的URL会发生变化。即使你可以更新网站的内部链接以匹配新的命名方案,你也无法控制外部资源使用的URL。你不想破坏这些链接,因为它们为你带来了有价值的用户(并有助于你的SEO),所以你设置了从旧URL到新URL的重定向。</target>
        </trans-unit>
        <trans-unit id="6070588ec0c2a8c5e6cfc541a62c166faa651c18" translate="yes" xml:space="preserve">
          <source>Whenever a cache returns a response that is neither first-hand nor
   &quot;fresh enough&quot; (in the sense of condition 2 in &lt;a href=&quot;#section-13.1.1&quot;&gt;section 13.1.1&lt;/a&gt;), it
   MUST attach a warning to that effect, using a Warning general-header.
   The Warning header and the currently defined warnings are described
   in &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt;. The warning allows clients to take appropriate
   action.

   Warnings MAY be used for other purposes, both cache-related and
   otherwise. The use of a warning, rather than an error status code,
   distinguish these responses from true failures.

   Warnings are assigned three digit warn-codes. The first digit
   indicates whether the Warning MUST or MUST NOT be deleted from a
   stored cache entry after a successful revalidation: 

   1xx  Warnings that describe the freshness or revalidation status of
     the response, and so MUST be deleted after a successful
     revalidation. 1XX warn-codes MAY be generated by a cache only when
     validating a cached entry. It MUST NOT be generated by clients.

   2xx  Warnings that describe some aspect of the entity body or entity
     headers that is not rectified by a revalidation (for example, a
     lossy compression of the entity bodies) and which MUST NOT be
     deleted after a successful revalidation.

   See &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt; for the definitions of the codes themselves.

   HTTP/1.0 caches will cache all Warnings in responses, without
   deleting the ones in the first category. Warnings in responses that
   are passed to HTTP/1.0 caches carry an extra warning-date field,
   which prevents a future HTTP/1.1 recipient from believing an
   erroneously cached Warning.

   Warnings also carry a warning text. The text MAY be in any
   appropriate natural language (perhaps based on the client's Accept
   headers), and include an OPTIONAL indication of what character set is
   used.

   Multiple warnings MAY be attached to a response (either by the origin
   server or by a cache), including multiple warnings with the same code
   number. For example, a server might provide the same warning with
   texts in both English and Basque.

   When multiple warnings are attached to a response, it might not be
   practical or reasonable to display all of them to the user. This
   version of HTTP does not specify strict priority rules for deciding
   which warnings to display and in what order, but does suggest some
   heuristics.</source>
          <target state="translated">每当缓存返回的响应既不是第一手的响应也不是&amp;ldquo;不够新鲜&amp;rdquo;的响应（在&lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1节中&lt;/a&gt;的条件2的意义上），它必须使用警告通用标头将警告附加到该效果上。警告标题和当前定义的警告在&lt;a href=&quot;#section-14.46&quot;&gt;14.46节&lt;/a&gt;中介绍。该警告允许客户采取适当的措施。警告可以用于与缓存相关或其他目的的其他目的。使用警告而不是错误状态代码可以将这些响应与真正的故障区分开。警告被分配了三位数的警告代码。第一位数字表示成功重新验证后是否必须从存储的缓存条目中删除警告：1xx描述响应的新鲜度或重新验证状态的警告，因此必须在成功重新验证后删除。仅当验证缓存的条目时，缓存才可能生成1XX警告代码。它一定不能由客户生成。 2xx警告，描述了未通过重新验证纠正的实体主体或实体标头的某些方面（例如，实体实体的有损压缩），并且在成功重新验证后不得删除。看到&lt;a href=&quot;#section-14.46&quot;&gt;第14.46条&lt;/a&gt;有关代码本身的定义。 HTTP / 1.0缓存将缓存响应中的所有警告，而不会删除第一类中的警告。传递到HTTP / 1.0缓存的响应中的警告带有一个额外的警告日期字段，该字段防止将来的HTTP / 1.1收件人认为错误缓存的警告。警告还带有警告文本。文本可以使用任何适当的自然语言（可能基于客户端的Accept标头），并且可以选择使用哪种字符集。可以将多个警告附加到响应（通过源服务器或缓存），包括具有相同代码号的多个警告。例如，服务器可能同时以英语和巴斯克语提供警告。将多个警告附加到响应时，将所有警告显示给用户可能不现实或不合理。 HTTP的此版本未指定严格的优先级规则来决定显示哪些警告以及以什么顺序显示，但是建议使用一些启发式方法。</target>
        </trans-unit>
        <trans-unit id="b6e3f26fff7f269af5ed05c0a30457f5f9d7d7e2" translate="yes" xml:space="preserve">
          <source>Whenever the Strict-Transport-Security header is delivered to the browser, it will update the expiration time for that site, so sites can refresh this information and prevent the timeout from expiring. Should it be necessary to disable Strict Transport Security, setting the max-age to 0 (over a https connection) will immediately expire the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, allowing access via http.</source>
          <target state="translated">每当将Strict-Transport-Security标头传递到浏览器时，它将更新该站点的到期时间，因此站点可以刷新此信息并防止超时到期。如果需要禁用严格传输安全性，则将max-age设置为0（通过https连接）将立即使 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; 标头过期，从而允许通过http访问。</target>
        </trans-unit>
        <trans-unit id="7f2824d529ed4da83ab98e7c885ddfa6c409076e" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;form-action&lt;/code&gt; should block redirects after a form submission is &lt;a href=&quot;https://github.com/w3c/webappsec-csp/issues/8&quot;&gt;debated&lt;/a&gt; and browser implementations of this aspect are inconsistent (e.g. Firefox 57 doesn't block the redirects whereas Chrome 63 does).</source>
          <target state="translated">在对表单提交进行&lt;a href=&quot;https://github.com/w3c/webappsec-csp/issues/8&quot;&gt;辩论&lt;/a&gt;之后，表单 &lt;code&gt;form-action&lt;/code&gt; 是否应阻止重定向，并且这方面的浏览器实现不一致（例如Firefox 57不会阻止重定向，而Chrome 63会阻止重定向）。</target>
        </trans-unit>
        <trans-unit id="fb6399f7fa65b3b2878d7126ab85f658d02766e0" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encodings&quot;&gt;character encodings&lt;/a&gt; the client understands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e149cf9cb25225d5524e2c0b27df15969b2bc6b" translate="yes" xml:space="preserve">
          <source>Which part of the user agent contains the information you are looking for</source>
          <target state="translated">用户代理的哪一部分包含了您正在寻找的信息?</target>
        </trans-unit>
        <trans-unit id="99fc0a09b56367aa86fac890ff8bff6f93f0262e" translate="yes" xml:space="preserve">
          <source>Which part of the user agent contains the information you are looking for?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e993bfc672f17c43ec7068a082e6c9f72e4fd853" translate="yes" xml:space="preserve">
          <source>While Firefox 3.5 introduced support for cross-site &lt;code&gt;XMLHttpRequests&lt;/code&gt; and Web Fonts, certain requests were limited until later versions. Specifically, Firefox 7 introduced the ability for cross-site HTTP requests for WebGL Textures, and Firefox 9 added support for Images drawn on a canvas using &lt;code&gt;drawImage()&lt;/code&gt;.</source>
          <target state="translated">尽管Firefox 3.5引入了对跨站点 &lt;code&gt;XMLHttpRequests&lt;/code&gt; 和Web字体的支持，但某些请求一直受到限制，直到更高版本。具体地说，Firefox 7引入了对WebGL Textures进行跨站点HTTP请求的功能，而Firefox 9添加了对使用 &lt;code&gt;drawImage()&lt;/code&gt; 在画布上绘制图像的支持。</target>
        </trans-unit>
        <trans-unit id="20d023c8effc05b035da8186b6438727d9b10e7e" translate="yes" xml:space="preserve">
          <source>While specific HTTP status codes are shown in the interaction
   diagrams below, an AtomPub client should be prepared to handle any
   status code.  For example, a PUT to a Member URI could result in the
   return of a &quot;204 No Content&quot; status code, which still indicates
   success.</source>
          <target state="translated">虽然特定的HTTP状态码显示在下面的交互图中,但AtomPub客户端应该准备好处理任何状态码。例如,对一个成员URI的PUT可能会导致返回 &quot;204 No Content &quot;状态码,这仍然表示成功。</target>
        </trans-unit>
        <trans-unit id="338f925525fc3393283ece9c49173250a55b4c67" translate="yes" xml:space="preserve">
          <source>While the origin server (and to a lesser extent, intermediate caches,
   by their contribution to the age of a response) are the primary
   source of expiration information, in some cases the client might need
   to control a cache's decision about whether to return a cached
   response without validating it. Clients do this using several
   directives of the Cache-Control header.

   A client's request MAY specify the maximum age it is willing to
   accept of an unvalidated response; specifying a value of zero forces
   the cache(s) to revalidate all responses. A client MAY also specify
   the minimum time remaining before a response expires. Both of these
   options increase constraints on the behavior of caches, and so cannot
   further relax the cache's approximation of semantic transparency.

   A client MAY also specify that it will accept stale responses, up to
   some maximum amount of staleness. This loosens the constraints on the
   caches, and so might violate the origin server's specified
   constraints on semantic transparency, but might be necessary to
   support disconnected operation, or high availability in the face of
   poor connectivity.</source>
          <target state="translated">虽然源服务器(以及在较小的程度上,中间缓存对响应年龄的贡献)是过期信息的主要来源,但在某些情况下,客户端可能需要控制缓存决定是否在不验证它的情况下返回缓存响应。客户端使用Cache-Control头的几个指令来实现这一点。客户端的请求可以指定它愿意接受未验证的响应的最大年龄;指定一个零的值会强制缓存重新验证所有响应。客户端还可以指定响应过期前的最小剩余时间。这两个选项都增加了对缓存行为的约束,因此不能进一步放松缓存对语义透明度的近似。客户端还可以指定它将接受陈旧的响应,最多是一些最大的陈旧量。这放宽了对缓存的约束,因此可能会违反源服务器对语义透明度的指定约束,但对于支持断开连接的操作,或在连接性差的情况下支持高可用性来说,可能是必要的。</target>
        </trans-unit>
        <trans-unit id="6f8ec3f1f56c6bc412a296279f741f72feec98d6" translate="yes" xml:space="preserve">
          <source>While the version number for Firefox OS is not included in the UA string, it is possible to infer version information from the Gecko version number present in the UA string.</source>
          <target state="translated">虽然UA字符串中不包括Firefox OS的版本号,但可以从UA字符串中的Gecko版本号推断版本信息。</target>
        </trans-unit>
        <trans-unit id="97f6d88cfb1e84306b1da3a5b584e510b6a952d4" translate="yes" xml:space="preserve">
          <source>While this directive uses the same arguments as other CSP directives, some of them don&amp;rsquo;t make sense for `&amp;lt;base&amp;gt;`, such as the keywords &lt;code&gt;'unsafe-inline'&lt;/code&gt; and &lt;code&gt;'strict-dynamic'&lt;/code&gt;</source>
          <target state="translated">尽管此指令使用与其他CSP指令相同的参数，但其中某些参数对&amp;lt;base&amp;gt;没有意义，例如关键字 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 和 &lt;code&gt;'strict-dynamic'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f537be83534f2bb055e551bb0d596ae0047d77e6" translate="yes" xml:space="preserve">
          <source>While those without a write lock may not alter a property on a
   resource it is still possible for the values of live properties to
   change, even while locked, due to the requirements of their schemas.
   Only dead properties and live properties defined as lockable are
   guaranteed not to change while write locked.</source>
          <target state="translated">虽然那些没有写锁的人可能不会改变资源上的属性,但由于其模式的要求,即使在锁定的情况下,活属性的值仍有可能改变。只有死属性和定义为可锁定的活属性才能保证在写锁定时不改变。</target>
        </trans-unit>
        <trans-unit id="eb0451d5b11619c1207cdf6653be0f2c1c7804fc" translate="yes" xml:space="preserve">
          <source>While you can use the protocol upgrade mechanism to upgrade an HTTP/1.1 connection to HTTP/2, you can't go the other way. In fact, the 101 status code is no longer supported at all in HTTP/2, since HTTP/2 doesn't have an upgrade mechanism.</source>
          <target state="translated">虽然你可以使用协议升级机制将HTTP/1.1连接升级到HTTP/2,但你不能走另一条路。事实上,101状态码在HTTP/2中已经完全不支持了,因为HTTP/2没有升级机制。</target>
        </trans-unit>
        <trans-unit id="261605cea16791a4ddb43f7b2749c4b19783648d" translate="yes" xml:space="preserve">
          <source>Who should read this article?</source>
          <target state="translated">谁应该读这篇文章?</target>
        </trans-unit>
        <trans-unit id="665c65a0f74535d4656efd18a227f19541666d9b" translate="yes" xml:space="preserve">
          <source>Wikipedia page on List of HTTP headers</source>
          <target state="translated">维基百科上的HTTP头文件列表</target>
        </trans-unit>
        <trans-unit id="cc6b4a8fc4aeba016589b1291deb108288b680c4" translate="yes" xml:space="preserve">
          <source>Wikipedia: &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP%20Strict%20Transport%20Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</source>
          <target state="translated">维基百科：&lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP%20Strict%20Transport%20Security&quot;&gt;HTTP严格的传输安全性&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed7d5745fff339844aa920c78c4b743eeaaaa20b" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP 404</source>
          <target state="translated">维基百科:HTTP 404</target>
        </trans-unit>
        <trans-unit id="c3fb892e6bb839e40a5aa40ad6213e107182238b" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP 451</source>
          <target state="translated">维基百科:HTTP 451</target>
        </trans-unit>
        <trans-unit id="6fd57bc7d46dd1d7c88fd1f38c6b88d2f037bcae" translate="yes" xml:space="preserve">
          <source>Wikipedia: Hyper Text Coffee Pot Control Protocol</source>
          <target state="translated">维基百科。超文本咖啡壶控制协议</target>
        </trans-unit>
        <trans-unit id="d2a3cafe6626783cff3b940b111bae036a628cbe" translate="yes" xml:space="preserve">
          <source>Wildcard (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8899fd2529c1a2011b26126cae3a5c0a4b0a831" translate="yes" xml:space="preserve">
          <source>Will be implemented, see &lt;a href=&quot;https://crbug.com/1007264&quot;&gt;bug 1007264&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="31c9a3739d5b563171fe69071b7457ba22d94b63" translate="yes" xml:space="preserve">
          <source>Windows NT on x64 CPU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e663f8a9a4dc9bf996e681010668eeffc4658c" translate="yes" xml:space="preserve">
          <source>Windows NT on x86</source>
          <target state="translated">Windows NT on x86</target>
        </trans-unit>
        <trans-unit id="9d75778731ec194b7c3ce2f2a665761a11719f44" translate="yes" xml:space="preserve">
          <source>Windows NT on x86 CPU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91a0206361cb5cdd5d3a572c04ff168eb925f08" translate="yes" xml:space="preserve">
          <source>Windows NT, WOW64</source>
          <target state="translated">Windows NT,WOW64</target>
        </trans-unit>
        <trans-unit id="e8e293f9ba55bd519e617bb25740cd26b038610b" translate="yes" xml:space="preserve">
          <source>Windows NT, Win64 on x64</source>
          <target state="translated">Windows NT,Win64 on x64</target>
        </trans-unit>
        <trans-unit id="1f7d7a7d59bb7043e9140971ef9251fab7982c2e" translate="yes" xml:space="preserve">
          <source>Windows OS/2 Bitmap Graphics</source>
          <target state="translated">Windows OS/2位图图形</target>
        </trans-unit>
        <trans-unit id="300a9414a515ce56cc07b2655723c865442c3bba" translate="yes" xml:space="preserve">
          <source>Windows icons</source>
          <target state="translated">窗口图标</target>
        </trans-unit>
        <trans-unit id="d49fd423350dcd691fcb99fbae2181da74ce3859" translate="yes" xml:space="preserve">
          <source>Windows user agents have the following variations, where &lt;em&gt;x.y&lt;/em&gt; is the Windows NT version (for instance, Windows NT 6.1).</source>
          <target state="translated">Windows用户代理具有以下变体，其中&lt;em&gt;xy&lt;/em&gt;是Windows NT版本（例如Windows NT 6.1）。</target>
        </trans-unit>
        <trans-unit id="8bd46cc0624bcd0f4f4799ef906d98088943324f" translate="yes" xml:space="preserve">
          <source>Windows version</source>
          <target state="translated">Windows版本</target>
        </trans-unit>
        <trans-unit id="989504c4d96b544c144c0d90f1bbe95390e8d564" translate="yes" xml:space="preserve">
          <source>With Feature Policy, you opt-in to a set of &quot;policies&quot; for the browser to enforce on specific features used throughout a website. These policies restrict what APIs the site can access or modify the browser's default behavior for certain features.</source>
          <target state="translated">通过功能策略,您可以选择加入一套 &quot;策略&quot;,让浏览器对整个网站中使用的特定功能进行强制执行。这些策略限制网站可以访问哪些API,或修改浏览器对某些功能的默认行为。</target>
        </trans-unit>
        <trans-unit id="063d698928c501813d56323f470e5ed6d3986fb1" translate="yes" xml:space="preserve">
          <source>With TCP the default port, for an HTTP server on a computer, is port 80. Other ports can also be used, like 8000 or 8080. The URL of a page to fetch contains both the domain name, and the port number, though the latter can be omitted if it is 80. See &lt;a href=&quot;basics_of_http/identifying_resources_on_the_web&quot;&gt;Identifying resources on the Web&lt;/a&gt; for more details.</source>
          <target state="translated">使用TCP，对于计算机上的HTTP服务器，默认端口为端口80。还可以使用其他端口，例如8000或8080。要获取的页面的URL包含域名和端口号，尽管如果为80，则可以省略后者。有关更多详细信息，请参见&lt;a href=&quot;basics_of_http/identifying_resources_on_the_web&quot;&gt;在Web上标识资源&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="287bd90b43fa4667e9fa5d74268b62d6241e8c36" translate="yes" xml:space="preserve">
          <source>With UTF-8 now being well-supported, being the preferred way of encoding characters, &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;and to guarantee better privacy through less configuration-based entropy&lt;/a&gt;, browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8, Safari 5, Opera 11, Firefox 10 and Chrome 27 have abandoned this header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a257ad9324f117394e2b9a6293c343f5ba6993ef" translate="yes" xml:space="preserve">
          <source>With UTF-8 now being well-supported, being the preferred way of encoding characters, &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;and to guarantee better privacy through less configuration-based entropy&lt;/a&gt;, most browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8, Safari 5, Opera 11 and Firefox 10 have abandoned this header.</source>
          <target state="translated">现在，UTF-8得到了很好的支持，是编码字符的首选方法，&lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;并且通过减少基于配置的熵来保证更好的隐私&lt;/a&gt;，大多数浏览器都省略了 &lt;code&gt;Accept-Charset&lt;/code&gt; 标头：Internet Explorer 8，Safari 5，Opera 11和Firefox 10已放弃此标头。</target>
        </trans-unit>
        <trans-unit id="c4aa194cdaea498795c2710e4b593bbb786c966e" translate="yes" xml:space="preserve">
          <source>With agent-driven negotiation, selection of the best representation
   for a response is performed by the user agent after receiving an
   initial response from the origin server. Selection is based on a list
   of the available representations of the response included within the
   header fields or entity-body of the initial response, with each
   representation identified by its own URI. Selection from among the
   representations may be performed automatically (if the user agent is
   capable of doing so) or manually by the user selecting from a
   generated (possibly hypertext) menu.

   Agent-driven negotiation is advantageous when the response would vary
   over commonly-used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.

   Agent-driven negotiation suffers from the disadvantage of needing a
   second request to obtain the best alternate representation. This
   second request is only efficient when caching is used. In addition,
   this specification does not define any mechanism for supporting
   automatic selection, though it also does not prevent any such
   mechanism from being developed as an extension and used within
   HTTP/1.1. 

   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)
   status codes for enabling agent-driven negotiation when the server is
   unwilling or unable to provide a varying response using server-driven
   negotiation.</source>
          <target state="translated">在代理驱动的协商中,用户代理在收到来自源服务器的初始响应后,为响应选择最佳表示。选择是基于包含在初始响应的头字段或实体主体中的响应的可用表示的列表,每个表示由它自己的URI识别。从表征中的选择可以自动执行(如果用户代理能够这样做)或由用户从生成的(可能是超文本)菜单中手动选择。当响应会在常用的维度(如类型、语言或编码)上有所不同时,当源服务器无法通过检查请求来确定用户代理的能力时,以及通常当公共缓存被用来分配服务器负载和减少网络使用时,代理驱动的协商是有利的。代理驱动的协商存在一个缺点,即需要第二次请求才能获得最佳的替代表示。这第二次请求只有在使用缓存时才是有效的。此外,本规范没有定义任何支持自动选择的机制,尽管它也不妨碍任何这样的机制被开发为扩展并在HTTP/1.1中使用。HTTP/1.1定义了300(多选)和406(不可接受)状态码,用于当服务器不愿意或不能使用服务器驱动协商提供不同的响应时,启用代理驱动协商。</target>
        </trans-unit>
        <trans-unit id="7770029630372b0eac11793689759fe0480d9ff8" translate="yes" xml:space="preserve">
          <source>With an &amp;lt;iframe&amp;gt; element</source>
          <target state="translated">带有&amp;lt;iframe&amp;gt;元素</target>
        </trans-unit>
        <trans-unit id="73763e7948769a9fcb45adc2ce4867d6d88c43a7" translate="yes" xml:space="preserve">
          <source>With external scripts</source>
          <target state="translated">有外部脚本</target>
        </trans-unit>
        <trans-unit id="f470ad653a278fddde764ace4f49c6c4d0467b38" translate="yes" xml:space="preserve">
          <source>With reactive negotiation (a.k.a., agent-driven negotiation),
   selection of the best response representation (regardless of the
   status code) is performed by the user agent after receiving an
   initial response from the origin server that contains a list of
   resources for alternative representations.  If the user agent is not
   satisfied by the initial response representation, it can perform a
   GET request on one or more of the alternative resources, selected
   based on metadata included in the list, to obtain a different form of
   representation for that response.  Selection of alternatives might be
   performed automatically by the user agent or manually by the user
   selecting from a generated (possibly hypertext) menu.

   Note that the above refers to representations of the response, in
   general, not representations of the resource.  The alternative
   representations are only considered representations of the target
   resource if the response in which those alternatives are provided has
   the semantics of being a representation of the target resource (e.g.,
   a 200 (OK) response to a GET request) or has the semantics of
   providing links to alternative representations for the target
   resource (e.g., a 300 (Multiple Choices) response to a GET request).

   A server might choose not to send an initial representation, other
   than the list of alternatives, and thereby indicate that reactive
   negotiation by the user agent is preferred.  For example, the
   alternatives listed in responses with the 300 (Multiple Choices) and
   406 (Not Acceptable) status codes include information about the
   available representations so that the user or user agent can react by
   making a selection.

   Reactive negotiation is advantageous when the response would vary
   over commonly used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage. 

   Reactive negotiation suffers from the disadvantages of transmitting a
   list of alternatives to the user agent, which degrades user-perceived
   latency if transmitted in the header section, and needing a second
   request to obtain an alternate representation.  Furthermore, this
   specification does not define a mechanism for supporting automatic
   selection, though it does not prevent such a mechanism from being
   developed as an extension.</source>
          <target state="translated">通过反应式协商(又称代理驱动协商),用户代理在收到来自源服务器的初始响应后,选择最佳的响应表示(无论状态码如何),该响应表示包含一个替代表示的资源列表。如果用户代理对初始响应表示不满意,它可以对根据列表中包含的元数据选择的一个或多个替代资源执行GET请求,以获得该响应的不同表示形式。替代资源的选择可以由用户代理自动执行,也可以由用户从生成的(可能是超文本)菜单中手动选择。请注意,上面提到的是响应的表示,一般来说,不是资源的表示。只有当提供这些备选方案的响应具有作为目标资源的代表的语义时,备选方案才被认为是目标资源的代表(例如,对GET请求的200(OK)响应),或者具有为目标资源的备选方案提供链接的语义(例如,对GET请求的300(多选项)响应)。服务器可以选择不发送初始表示,而不是备选方案列表,从而表明用户代理的反应式协商是首选。例如,在具有300(多选择)和406(不可接受)状态码的响应中列出的备选方案包括关于可用表示的信息,以便用户或用户代理可以通过做出选择来作出反应。当响应会在常用的维度(如类型、语言或编码)上有所不同时,当源服务器无法通过检查请求来确定用户代理的能力时,以及通常当公共缓存被用于分配服务器负载和减少网络使用时,反应式协商是有利的。反应式协商的缺点是向用户代理传送备选列表,如果在头部分传送,会降低用户感知的延迟,而且需要第二次请求才能获得备选表示。此外,本规范没有定义一种支持自动选择的机制,尽管它并不妨碍作为扩展开发这种机制。</target>
        </trans-unit>
        <trans-unit id="f8cb0ac82812058c0694f7c5a07bb9f285a50bcb" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method you are able to implement this. The client first reads the original files, modifies them, and finally pushes them to the server:</source>
          <target state="translated">使用&lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;方法，您可以实现这一点。客户端首先读取原始文件，对其进行修改，最后将它们推送到服务器：</target>
        </trans-unit>
        <trans-unit id="5a4f6110e1e61b04fbe62fb541b4c16a90b6d7dd" translate="yes" xml:space="preserve">
          <source>With the above header set on a domain example.com that wants to migrate from HTTP to HTTPS, non-navigational insecure resource requests are automatically upgraded (first-party as well as third-party requests).</source>
          <target state="translated">在域名example.com上设置了上述头,想要从HTTP迁移到HTTPS,非导航性的不安全资源请求会自动升级(第一方以及第三方请求)。</target>
        </trans-unit>
        <trans-unit id="538d5b744abf2a80cab094727a14a51501db7d8c" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;multipart/form-data&lt;/code&gt;, used in the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;, and &lt;code&gt;multipart/byteranges&lt;/code&gt;, used with &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; to send part of a document, HTTP doesn't handle multipart documents in a special way: the message is transmitted to the browser (which will likely show a &quot;Save As&quot; window if it doesn't know how to display the document).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708d2e1600bcd9604e2edeccc4c3fd62c52a3c1a" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and the &lt;a href=&quot;report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive, you can set-up an enforced policy and a reported policy like this:</source>
          <target state="translated">借助&lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;标头和&lt;a href=&quot;report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;指令，您可以设置强制策略和报告的策略，如下所示：</target>
        </trans-unit>
        <trans-unit id="044b9dbdfbd69bd21aa2b1d882b33557eda54a7b" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you can detect mid-air edit collisions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105d80b763f419ce22176e98ecfdc97c5f8387a4" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you are able to detect mid-air edit collisions.</source>
          <target state="translated">借助 &lt;code&gt;ETag&lt;/code&gt; 和&lt;a href=&quot;if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;标头，您可以检测空中编辑冲突。</target>
        </trans-unit>
        <trans-unit id="5ddd17a77e3eb820e93844f51c9bd5df55066992" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you can detect mid-air edit collisions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512239b40fd41d01554678757db96317e6284079" translate="yes" xml:space="preserve">
          <source>With the help of the new HTTP headers, the ability to transmit other documents than plain HTML files has been added (thanks to the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header).</source>
          <target state="translated">借助于新的HTTP标头，已添加了传输普通HTML文件以外的其他文档的功能（这要归功于&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;标头）。</target>
        </trans-unit>
        <trans-unit id="1a7203df4fb0cc96a3946c892f2dac6dbefbb1dc" translate="yes" xml:space="preserve">
          <source>With these techniques, you can configure your server to respond correctly for both, the www-prefixed and the non-www-prefixed domains. It is good advice to do this since you can't predict which URL users will type in their browser's URL bar. It is a matter of choosing which type you want to use as your canonical location, then redirecting the other type to it.</source>
          <target state="translated">通过这些技术,您可以将您的服务器配置为对www-前缀和非www-前缀的域名做出正确的响应。这是一个很好的建议,因为你无法预测用户会在浏览器的URL栏中输入哪个URL。这是一个问题,选择你想使用哪种类型作为你的规范位置,然后将其他类型重定向到它。</target>
        </trans-unit>
        <trans-unit id="6d1c75c7baf134aba78012137949996ebe9070b0" translate="yes" xml:space="preserve">
          <source>With three possibilities for URL redirections, several methods can be specified at the same time, but which one is applied first? The order of precedence is the following:</source>
          <target state="translated">URL重定向有三种可能,可以同时指定几种方法,但先应用哪一种呢?先后顺序如下。</target>
        </trans-unit>
        <trans-unit id="a418f3a1c01fcbf5c90b703d052201992e5fb874" translate="yes" xml:space="preserve">
          <source>With three ways to trigger redirections, several ways can be used at the same time. But which is applied first?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8be0bede91ceb6ad718250a6be05f374208c9a0" translate="yes" xml:space="preserve">
          <source>Worker support</source>
          <target state="translated">工人支助</target>
        </trans-unit>
        <trans-unit id="dd81953275e4c603fc6e296163f16395c6ee5da7" translate="yes" xml:space="preserve">
          <source>Working Draft</source>
          <target state="translated">工作草案</target>
        </trans-unit>
        <trans-unit id="37c6e1e814485ae2acb0d7377a8e62b4414e27eb" translate="yes" xml:space="preserve">
          <source>Working code samples</source>
          <target state="translated">工作代码样本</target>
        </trans-unit>
        <trans-unit id="eacebc1ffedb674ae5bd64f058688530e875da85" translate="yes" xml:space="preserve">
          <source>Workspaces are server-defined groups of Collections.  The &quot;app:
   workspace&quot; element contains zero or more app:collection elements
   describing the Collections of Resources available for editing.

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }</source>
          <target state="translated">工作区是服务器定义的集合组。 &amp;ldquo; app：工作区&amp;rdquo;元素包含零个或多个描述可用于编辑的资源集合的app：collection元素。 appWorkspace =元素app：workspace {appCommonAttributes，（atomTitle＆appCollection *＆extensionSansTitleElement *）} atomTitle =元素atom：title {atomTextConstruct}</target>
        </trans-unit>
        <trans-unit id="79a153310ffa336984498274d184537ce99e3457" translate="yes" xml:space="preserve">
          <source>Writing a policy</source>
          <target state="translated">撰写政策</target>
        </trans-unit>
        <trans-unit id="b1d3f473c48021046e7ba3468f5cf21e1b0e7ddd" translate="yes" xml:space="preserve">
          <source>X-Content-Type-Options</source>
          <target state="translated">X-Content-Type-Options</target>
        </trans-unit>
        <trans-unit id="25731e7aec64e37cf5913bb14adeca448b936ee9" translate="yes" xml:space="preserve">
          <source>X-DNS-Prefetch-Control</source>
          <target state="translated">X-DNS-Prefetch-Control</target>
        </trans-unit>
        <trans-unit id="08a62266c2fee44d28f2a09bdc63f0cb3203d151" translate="yes" xml:space="preserve">
          <source>X-Forwarded-For</source>
          <target state="translated">X-Forwarded-For</target>
        </trans-unit>
        <trans-unit id="3dfd27b5c348953dd22222a659a5031713ce4ff1" translate="yes" xml:space="preserve">
          <source>X-Forwarded-Host</source>
          <target state="translated">X-Forwarded-Host</target>
        </trans-unit>
        <trans-unit id="5f77b69d4a9a12e6be323362589ebb4520c18095" translate="yes" xml:space="preserve">
          <source>X-Forwarded-Proto</source>
          <target state="translated">X-Forwarded-Proto</target>
        </trans-unit>
        <trans-unit id="06d18ff7a6daa0422e0cad3f72e863617cee9d06" translate="yes" xml:space="preserve">
          <source>X-Frame-Options</source>
          <target state="translated">X-Frame-Options</target>
        </trans-unit>
        <trans-unit id="8c52affc192efbc43d6163a7df7a9d01beb38c0f" translate="yes" xml:space="preserve">
          <source>X-Webkit-CSP</source>
          <target state="translated">X-Webkit-CSP</target>
        </trans-unit>
        <trans-unit id="c7215a317b6dd9b4629392c1b06074727d0d0713" translate="yes" xml:space="preserve">
          <source>X-XSS-Protection</source>
          <target state="translated">X-XSS-Protection</target>
        </trans-unit>
        <trans-unit id="4e111db7771a9e3cb485a634fdca19d4a087bf84" translate="yes" xml:space="preserve">
          <source>X.509v3 certificate extension to allow embedding of signed certificate timestamps issued by individual logs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf9ac265948c22972f4a00525a49dcdca8ded84" translate="yes" xml:space="preserve">
          <source>X.X.X.Y</source>
          <target state="translated">X.X.X.Y</target>
        </trans-unit>
        <trans-unit id="ffa12f27ac48a1ab5dd93d501704d6f43ec578fa" translate="yes" xml:space="preserve">
          <source>XHTML</source>
          <target state="translated">XHTML</target>
        </trans-unit>
        <trans-unit id="02faa7587ad581423c40a3b14ac82860aadd96d3" translate="yes" xml:space="preserve">
          <source>XML elements defined by this specification MAY have an &quot;xml:base&quot;
   attribute [&lt;a href=&quot;#ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt;].  When xml:base is used, it serves the
   function described in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt; of URI Generic Syntax [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;],
   by establishing the base URI (or IRI, Internationalized Resource
   Identifier [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;]) for resolving relative references found within
   the scope of the &quot;xml:base&quot; attribute.

   Any element defined by this specification MAY have an &quot;xml:lang&quot;
   attribute, whose content indicates the natural language for the
   element and its descendants.  Requirements regarding the content and
   interpretation of &quot;xml:lang&quot; are specified in &lt;a href=&quot;#section-2.12&quot;&gt;Section 2.12&lt;/a&gt; of XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">由本规范定义的XML元素可以具有&amp;ldquo; xml：base&amp;rdquo;属性[ &lt;a href=&quot;#ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt; ]。使用xml：base时，它通过建立基本URI（或IRI，国际化资源标识符[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ]）来解决URI通用语法[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ] &lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节中&lt;/a&gt;描述的功能，以解决在&amp;ldquo; xml：base&amp;rdquo;属性。由本规范定义的任何元素都可以具有&amp;ldquo; xml：lang&amp;rdquo;属性，其内容指示该元素及其后代的自然语言。XML 1的&lt;a href=&quot;#section-2.12&quot;&gt;第2.12节&lt;/a&gt;指定了有关&amp;ldquo; xml：lang&amp;rdquo;的内容和解释的要求。0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="118d184a6966521bcc7ff20a77721ff4e779ff1c" translate="yes" xml:space="preserve">
          <source>XML is a flexible data format that makes it easy to submit data that
   appears legal but in fact is not.  The philosophy of &quot;Be flexible in
   what you accept and strict in what you send&quot; still applies, but it
   must not be applied inappropriately.  XML is extremely flexible in
   dealing with issues of whitespace, element ordering, inserting new
   elements, etc.  This flexibility does not require extension,
   especially not in the area of the meaning of elements.

   There is no kindness in accepting illegal combinations of XML
   elements.  At best, it will cause an unwanted result and at worst it
   can cause real damage.</source>
          <target state="translated">XML是一种灵活的数据格式,它可以很容易地提交看似合法、实则不合法的数据。&quot;接受的东西要灵活,发送的东西要严格 &quot;的理念依然适用,但不能应用不当。XML在处理空白、元素排序、插入新元素等问题上非常灵活。这种灵活性不需要扩展,尤其是在元素的含义方面不需要扩展。接受XML元素的非法组合是不仁慈的。最好的情况是会造成不想要的结果,最坏的情况是会造成真正的损害。</target>
        </trans-unit>
        <trans-unit id="9ac1e607d8b04259c13b0dc929c5a55b74dd33cb" translate="yes" xml:space="preserve">
          <source>XML namespaces disambiguate WebDAV property names and XML elements.
   Any WebDAV user or application can define a new namespace in order to
   create custom properties or extend WebDAV XML syntax.  IANA does not
   need to manage such namespaces, property names, or element names.</source>
          <target state="translated">XML 命名空间可消除 WebDAV 属性名称和 XML 元素的歧义。任何WebDAV用户或应用程序都可以定义一个新的命名空间,以创建自定义属性或扩展WebDAV XML语法。IANA不需要管理这些命名空间、属性名称或元素名称。</target>
        </trans-unit>
        <trans-unit id="ec22a72705e20935a57158e733e78bdae4f2f2cd" translate="yes" xml:space="preserve">
          <source>XML supports a facility known as &quot;external entities&quot;, defined in
   Section 4.2.2 of [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;], which instructs an XML processor to
   retrieve and include additional XML.  An external XML entity can be
   used to append or modify the document type declaration (DTD)
   associated with an XML document.  An external XML entity can also be
   used to include XML within the content of an XML document.  For non-
   validating XML, such as the XML used in this specification, including
   an external XML entity is not required by XML.  However, XML does
   state that an XML processor may, at its discretion, include the
   external XML entity.

   External XML entities have no inherent trustworthiness and are
   subject to all the attacks that are endemic to any HTTP GET request.
   Furthermore, it is possible for an external XML entity to modify the
   DTD, and hence affect the final form of an XML document, in the worst
   case, significantly modifying its semantics or exposing the XML
   processor to the security risks discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;].  Therefore,
   implementers must be aware that external XML entities should be
   treated as untrustworthy.  If a server chooses not to handle external
   XML entities, it SHOULD respond to requests containing external
   entities with the 'no-external-entities' condition code.

   There is also the scalability risk that would accompany a widely
   deployed application that made use of external XML entities.  In this
   situation, it is possible that there would be significant numbers of
   requests for one external XML entity, potentially overloading any 

   server that fields requests for the resource containing the external
   XML entity.

   Furthermore, there's also a risk based on the evaluation of &quot;internal
   entities&quot; as defined in Section 4.2.2 of [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  A small,
   carefully crafted request using nested internal entities may require
   enormous amounts of memory and/or processing time to process.  Server
   implementers should be aware of this risk and configure their XML
   parsers so that requests like these can be detected and rejected as
   early as possible.</source>
          <target state="translated">XML支持一种称为&amp;ldquo;外部实体&amp;rdquo;的功能，该功能在[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]，它指示XML处理器检索并包含其他XML。外部XML实体可用于附加或修改与XML文档关联的文档类型声明（DTD）。外部XML实体也可以用于将XML包含在XML文档的内容中。对于非验证XML（例如本规范中使用的XML），XML不需要包含外部XML实体。但是，XML确实声明XML处理器可以自行决定包括外部XML实体。外部XML实体没有固有的可信赖性，并且易受任何HTTP GET请求特有的所有攻击的攻击。此外，在最坏的情况下，外部XML实体可能会修改DTD，从而影响XML文档的最终格式，显着修改其语义或使XML处理器暴露于[&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]。因此，实现者必须意识到外部XML实体应被视为不可信任。如果服务器选择不处理外部XML实体，则服务器应使用&amp;ldquo; no-external-entities&amp;rdquo;条件代码响应包含外部实体的请求。还存在伴随使用外部XML实体的广泛部署的应用程序带来的可伸缩性风险。在这种情况下，可能会对一个外部XML实体有大量请求，从而可能使任何对包含该外部XML实体的资源进行请求的服务器超载。此外，根据[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML]&lt;/a&gt;第4.2.2节中定义的&amp;ldquo;内部实体&amp;rdquo;评估，也存在风险]。使用嵌套的内部实体精心制作的小型请求可能需要大量的内存和/或处理时间才能处理。服务器实现者应意识到这种风险，并配置其XML解析器，以便可以尽早检测到并拒绝此类请求。</target>
        </trans-unit>
        <trans-unit id="b52535bbad4c67580746ea1c2e2d0547fde6a67a" translate="yes" xml:space="preserve">
          <source>XML supports two mechanisms for indicating that an XML element does
   not have any content.  The first is to declare an XML element of the
   form &amp;lt;A&amp;gt;&amp;lt;/A&amp;gt;.  The second is to declare an XML element of the form
   &amp;lt;A/&amp;gt;.  The two XML elements are semantically identical.</source>
          <target state="translated">XML支持两种机制来指示XML元素不包含任何内容。第一种是声明&amp;lt;A&amp;gt; &amp;lt;/A&amp;gt;形式的XML元素。第二个是声明&amp;lt;A/&amp;gt;形式的XML元素。这两个XML元素在语义上是相同的。</target>
        </trans-unit>
        <trans-unit id="b1a146ce24fcf201b49e752836700a2313cfce76" translate="yes" xml:space="preserve">
          <source>XUL</source>
          <target state="translated">XUL</target>
        </trans-unit>
        <trans-unit id="db9a9676b638863e69493a0d059f3d23b2a78eff" translate="yes" xml:space="preserve">
          <source>Y. Y. Goland
   Microsoft Corporation
   One Microsoft Way
   Redmond, WA 98052-6399
   EMail: yarong@microsoft.com


   E. J. Whitehead, Jr.
   Dept. Of Information and Computer Science
   University of California, Irvine
   Irvine, CA 92697-3425
   EMail: ejw@ics.uci.edu


   A. Faizi
   Netscape
   685 East Middlefield Road
   Mountain View, CA 94043
   EMail: asad@netscape.com 

   S. R. Carter
   Novell
   1555 N. Technology Way
   M/S ORM F111
   Orem, UT 84097-2399
   EMail: srcarter@novell.com


   D. Jensen
   Novell
   1555 N. Technology Way
   M/S ORM F111
   Orem, UT 84097-2399
   EMail: dcjensen@novell.com</source>
          <target state="translated">Y.Y.Y.Goland Microsoft Corporation One Microsoft Way Redmond,WA 98052-6399 EMail:yarong@microsoft.com E.J.Whitehead,Jr.Dept.Of Information and Computer Science University of California,Irvine Irvine,CA 92697-3425 EMail:ejw@ics.uci.edu A.Faizi Netscape 685 East Middlefield Road Mountain View,CA 94043 EMail:asad@netscape.com S.R.Carter Novell 1555 N.Technology Way M/S ORM F111 Orem,UT 84097-2399 EMail:srcarter@novell.com D.Jensen Novell 1555 N.Technology Way M/S ORM F111 Orem,UT 84097-2399 EMail:dcjensen@novell.com</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="1a82ce976af425a56eaeeaa127b4f030cbb2bf55" translate="yes" xml:space="preserve">
          <source>Yes. If this directive is absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive.</source>
          <target state="translated">是。如果不存在此指令，则用户代理将查找 &lt;code&gt;default-src&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="a03d0938eab0d6ee22b27cb1b4a301b73e8ef58d" translate="yes" xml:space="preserve">
          <source>You can also configure a site to allow any site to access it by using the &lt;code&gt;&quot;*&quot;&lt;/code&gt; wildcard. You should only use this for public APIs. Private APIs should never use &lt;code&gt;&quot;*&quot;&lt;/code&gt;, and should instead have a specific domain or domains set. In addition, the wildcard only works for requests made with the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;&quot;anonymous&quot;&lt;/code&gt;.</source>
          <target state="translated">您还可以使用 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 通配符将站点配置为允许任何站点访问它。您只能将此用于公共API。专用API绝不应使用 &lt;code&gt;&quot;*&quot;&lt;/code&gt; ，而应设置一个或多个特定域。此外，通配符仅适用于将 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; 属性设置为 &lt;code&gt;&quot;anonymous&quot;&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="75af7d57fd721f02bd6ba3587fe6812772fb7fcf" translate="yes" xml:space="preserve">
          <source>You can also configure a site to allow any site to access it by using the &lt;code&gt;*&lt;/code&gt; wildcard. You should only use this for public APIs. Private APIs should never use &lt;code&gt;*&lt;/code&gt;, and should instead have a specific domain or domains set. In addition, the wildcard only works for requests made with the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;anonymous&lt;/code&gt;, and it prevents sending credentials like cookies in requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c5b12eb050dfd4399098b193f351f4fbac43c5" translate="yes" xml:space="preserve">
          <source>You can also set referrer policies in HTML documents. For example, by using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;name of &lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">您还可以在HTML文档中设置引荐来源网址策略。例如，通过使用带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt; &lt;code&gt;referrer&lt;/code&gt; &lt;/a&gt;名称的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素：</target>
        </trans-unit>
        <trans-unit id="195c470c8c8c727452226fead2121e4e2e15995a" translate="yes" xml:space="preserve">
          <source>You can also set referrer policies inside HTML. For example, you can set the referrer policy for the entire document with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;name&lt;/a&gt; of &lt;code&gt;referrer&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306b4bc212db26d3f47d487dfdbe512922fd95bc" translate="yes" xml:space="preserve">
          <source>You can also upgrade an HTTP/1.1 connection to TLS/1.0. The main advantages to this are that you can avoid using URL redirection from &quot;http://&quot; to &quot;https://&quot; on the server and you can easily use TLS on virtual hosts. This may, however, introduce problems with proxy servers.</source>
          <target state="translated">你也可以将HTTP/1.1连接升级为TLS/1.0。这样做的主要好处是,你可以避免在服务器上使用从 &quot;http://&quot;到 &quot;https://&quot;的URL重定向,而且你可以在虚拟主机上轻松使用TLS。但是,这可能会带来代理服务器的问题。</target>
        </trans-unit>
        <trans-unit id="a8f33154995cf629f0c4dcbdc756b5ef348aae13" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;&quot;wss://&quot;&lt;/code&gt; URL scheme to open a secure WebSocket connection.</source>
          <target state="translated">您也可以使用 &lt;code&gt;&quot;wss://&quot;&lt;/code&gt; URL方案打开安全的WebSocket连接。</target>
        </trans-unit>
        <trans-unit id="bb8c719f47766046067ab4ba3d9d63932f7735fd" translate="yes" xml:space="preserve">
          <source>You can either send the &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; header server-side, or from individual documents, using the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, like this:</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 属性，从服务器端发送 &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; 标头，也可以从各个文档发送X-DNS-Prefetch-Control标头，如下所示：</target>
        </trans-unit>
        <trans-unit id="b9b490f6db58176d0a61ab78a69dbead300c1e16" translate="yes" xml:space="preserve">
          <source>You can force the lookup of specific hostnames without providing specific anchors using that hostname by using the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel&quot;&gt;rel&lt;/a&gt;&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;link type&lt;/a&gt; of &lt;code&gt;dns-prefetch&lt;/code&gt;:</source>
          <target state="translated">您可以通过使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;链接类型&lt;/a&gt;为 &lt;code&gt;dns-prefetch&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel&quot;&gt;rel&lt;/a&gt;&lt;/code&gt; 属性来强制查找特定主机名，而无需使用该主机名提供特定锚：</target>
        </trans-unit>
        <trans-unit id="890b436866aa7fec0eb591186b42b85551101fe8" translate="yes" xml:space="preserve">
          <source>You can help by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/MDN/Contribute/Howto/Document_an_HTTP_header&quot;&gt;writing new entries&lt;/a&gt; or improving the existing ones.</source>
          <target state="translated">您可以通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/MDN/Contribute/Howto/Document_an_HTTP_header&quot;&gt;编写新条目&lt;/a&gt;或改进现有条目来提供帮助。</target>
        </trans-unit>
        <trans-unit id="4b351d15f45462c98aeea68c3d35a05714734814" translate="yes" xml:space="preserve">
          <source>You can reverse this setting by setting &lt;code&gt;content&lt;/code&gt; to &quot;&lt;code&gt;on&lt;/code&gt;&quot;.</source>
          <target state="translated">您可以通过将 &lt;code&gt;content&lt;/code&gt; 设置为&amp;ldquo; &lt;code&gt;on&lt;/code&gt; &amp;rdquo; 来撤消此设置。</target>
        </trans-unit>
        <trans-unit id="48019a7a0d5588a4850584f68a3a5d5553f14588" translate="yes" xml:space="preserve">
          <source>You can send the &lt;code&gt;Feature-Policy&lt;/code&gt; HTTP header with the response of a page. The value of this header is a policy to be enforced by the browser for the given page. It has the following structure.</source>
          <target state="translated">您可以将 &lt;code&gt;Feature-Policy&lt;/code&gt; HTTP标头与页面的响应一起发送。此标头的值是浏览器针对给定页面实施的策略。它具有以下结构。</target>
        </trans-unit>
        <trans-unit id="2bfa7d772cf31ca26fbcc1e9d0f1daf1147032db" translate="yes" xml:space="preserve">
          <source>You can use a hash-source to only allow specific inline style blocks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544765b693d9f6cf73fb8f6dc3d703f7a471c0a9" translate="yes" xml:space="preserve">
          <source>You can use a nonce-source to only allow specific inline script blocks:</source>
          <target state="translated">你可以使用一个nonce-source来只允许特定的内联脚本块。</target>
        </trans-unit>
        <trans-unit id="7e8d2670c21852aa6796fac3bb46c156114c42df" translate="yes" xml:space="preserve">
          <source>You can use a nonce-source to only allow specific inline style blocks:</source>
          <target state="translated">你可以使用一个nonce-source来只允许特定的内联样式块。</target>
        </trans-unit>
        <trans-unit id="a65bfc91cd3f3591eaf8300d226b1df9b91b92b3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header to specify your policy, like this:</source>
          <target state="translated">您可以使用&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP标头指定策略，如下所示：</target>
        </trans-unit>
        <trans-unit id="d6b308802143863f61fdfd923956be0f5c92e18a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; HTTP header to specify your policy, like this:</source>
          <target state="translated">您可以使用&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; HTTP标头指定策略，如下所示：</target>
        </trans-unit>
        <trans-unit id="eb5f5c27a50e86c2cf442e41b9e616e143082854" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header more than once like in the example below. Pay special attention to the &lt;a href=&quot;content-security-policy/connect-src&quot;&gt;&lt;code&gt;connect-src&lt;/code&gt;&lt;/a&gt; directive here. Even though the second policy would allow the connection, the first policy contains &lt;code&gt;connect-src 'none'&lt;/code&gt;. Adding additional policies &lt;em&gt;can only further restrict&lt;/em&gt; the capabilities of the protected resource, which means that there will be no connection allowed and, as the strictest policy, &lt;code&gt;connect-src 'none'&lt;/code&gt; is enforced.</source>
          <target state="translated">您可以多次使用 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 标头，如以下示例所示。在此特别注意&lt;a href=&quot;content-security-policy/connect-src&quot;&gt; &lt;code&gt;connect-src&lt;/code&gt; &lt;/a&gt;指令。即使第二个策略允许连接，第一个策略仍包含 &lt;code&gt;connect-src 'none'&lt;/code&gt; 。添加其他策略&lt;em&gt;只会进一步限制&lt;/em&gt;受保护资源的功能，这意味着将不允许连接，并且作为最严格的策略， &lt;code&gt;connect-src 'none'&lt;/code&gt; 强制执行connect-src'none'。</target>
        </trans-unit>
        <trans-unit id="137bbd4986d24df8c6873572858b3eacd9e0ddc8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header more than once, as in the example below. Pay special attention to the &lt;a href=&quot;content-security-policy/connect-src&quot;&gt;&lt;code&gt;connect-src&lt;/code&gt;&lt;/a&gt; directive here. Even though the second policy would allow the connection, the first policy contains &lt;code&gt;connect-src 'none'&lt;/code&gt;. Adding additional policies &lt;em&gt;can only further restrict&lt;/em&gt; the capabilities of the protected resource, which means that there will be no connection allowed and, as the strictest policy, &lt;code&gt;connect-src 'none'&lt;/code&gt; is enforced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fc382b165c36d3e771f09364d3fcb2bc6049c2" translate="yes" xml:space="preserve">
          <source>You don't want to break these links, as they bring valuable users and help your SEO, so you set up redirects from the old URLs to the new ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34dc813df24a4439aacb95679eee73b4dc499bdd" translate="yes" xml:space="preserve">
          <source>You log into a free WiFi access point at an airport and start surfing the web, visiting your online banking service to check your balance and pay a couple of bills. Unfortunately, the access point you're using is actually a hacker's laptop, and they're intercepting your original HTTP request and redirecting you to a clone of your bank's site instead of the real thing. Now your private data is exposed to the hacker.</source>
          <target state="translated">你在机场登录了一个免费的WiFi接入点,开始上网冲浪,访问你的网上银行服务,查看你的余额和支付一些账单。不幸的是,你使用的接入点实际上是一个黑客的笔记本电脑,他们正在拦截你最初的HTTP请求,并将你重定向到一个克隆的银行网站,而不是真正的东西。现在你的私人数据已经暴露在黑客面前了。</target>
        </trans-unit>
        <trans-unit id="7a5b96310bd1cc34f2c4474ad2f7105660a63d2d" translate="yes" xml:space="preserve">
          <source>You should replace them with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6edcf297ed74116e062437136c2a1939f6a974cf" translate="yes" xml:space="preserve">
          <source>You should replaced them with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">您应该将它们替换为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt;调用：</target>
        </trans-unit>
        <trans-unit id="2dc398a2b8603e27409f8150e3f33028d9184301" translate="yes" xml:space="preserve">
          <source>You shouldn't use the &lt;code&gt;From&lt;/code&gt; header for access control or authentication.</source>
          <target state="translated">您不应将 &lt;code&gt;From&lt;/code&gt; 标头用于访问控制或身份验证。</target>
        </trans-unit>
        <trans-unit id="aeb501a73f497244a1ca4c81bc0f2b75e165449c" translate="yes" xml:space="preserve">
          <source>You will have to set the same nonce on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; element:</source>
          <target state="translated">您将必须在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上设置相同的现时值：</target>
        </trans-unit>
        <trans-unit id="497810d0e0f1d8b5f343ce88e064b208a24ef471" translate="yes" xml:space="preserve">
          <source>You will have to set the same nonce on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element:</source>
          <target state="translated">您将必须在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上设置相同的现时值：</target>
        </trans-unit>
        <trans-unit id="8639bd898d6134e22819658d6593031b9a6e1f29" translate="yes" xml:space="preserve">
          <source>Your site needs to use a specific Web feature that some browsers don't yet support, and you want to send those users to an older Web site with fewer features but that you know will work. This is the worst reason to use user agent detection because odds are eventually all the other browsers will catch up. In addition, it is not practical to test every one of the less popular browsers and test for them. You should &lt;strong&gt;never &lt;/strong&gt;do user agent sniffing. There is &lt;strong&gt;always &lt;/strong&gt;the alternative of doing feature detection instead.</source>
          <target state="translated">您的站点需要使用某些浏览器尚不支持的特定Web功能，并且您希望将这些用户发送到功能较少的旧站点，但您知道可以使用。这是使用用户代理检测的最糟糕的原因，因为最终所有其他浏览器都会赶上来。此外，测试每个较不流行的浏览器并对其进行测试都是不切实际的。您&lt;strong&gt;绝对&lt;/strong&gt;不应进行用户代理嗅探。有&lt;strong&gt;一直&lt;/strong&gt;在做特征检测，而不是替代。</target>
        </trans-unit>
        <trans-unit id="3951b830d04bd983e497b92f61aa57c49fe1e1c8" translate="yes" xml:space="preserve">
          <source>Your site needs to use a specific Web feature that some browsers don't yet support, and you want to send those users to an older Web site with fewer features but that you know will work. This is the worst reason to use user agent detection because odds are eventually all the other browsers will catch up. In addition, it is not practical to test every one of the less popular browsers and test for them. You should &lt;strong&gt;never&lt;/strong&gt; do user agent sniffing. There is &lt;strong&gt;always&lt;/strong&gt; the alternative of doing feature detection instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2430dd6f1577013044f8423647dd090b767a57" translate="yes" xml:space="preserve">
          <source>ZIP archive</source>
          <target state="translated">ZIP档案</target>
        </trans-unit>
        <trans-unit id="7410a2c5889ae46b6ebf4b5278be959009c7bf12" translate="yes" xml:space="preserve">
          <source>Zero or more comments containing more details; sub-product information, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d194154860ee775d5ccbab4aa4357621f57dae0" translate="yes" xml:space="preserve">
          <source>Zero or more comments containing sub product information, for example.</source>
          <target state="translated">零条或多条包含子产品信息的评论,例如。</target>
        </trans-unit>
        <trans-unit id="2284673182cdd127888b6dd7e7eec11544c2f01a" translate="yes" xml:space="preserve">
          <source>Zombie cookies and Evercookies</source>
          <target state="translated">僵尸饼干和Evercookies</target>
        </trans-unit>
        <trans-unit id="1858daecfe7cd2d5ad3fcabc22474135629b2038" translate="yes" xml:space="preserve">
          <source>Zombie cookies on Wikipedia</source>
          <target state="translated">维基百科上的僵尸饼干</target>
        </trans-unit>
        <trans-unit id="faa3018647580610f8ce8b73789a682575c40c26" translate="yes" xml:space="preserve">
          <source>[1] The specification did not intend to allow method changes, but there are existing user agents that do change their method. &lt;a href=&quot;status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; was created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0af4c0811a538531e2dcf92a4868eda57b0def" translate="yes" xml:space="preserve">
          <source>[1] The specification had no intent to allow method changes, but practically there are user agents out there doing this. &lt;code&gt;308&lt;/code&gt; has been created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">[1]规范无意允许更改方法，但实际上有用户代理可以这样做。已创建 &lt;code&gt;308&lt;/code&gt; ,以消除使用非 &lt;code&gt;GET&lt;/code&gt; 方法时行为的歧义。</target>
        </trans-unit>
        <trans-unit id="f59b1ae9fa755e33069cec38aff63589aeb6fd23" translate="yes" xml:space="preserve">
          <source>[2] The specification did not intend to allow method changes, but there are existing user agents that do change their method. &lt;a href=&quot;status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; was created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc921dbce86b3452ecb504ace2a6ebd3695e66a1" translate="yes" xml:space="preserve">
          <source>[2] The specification had no intent to allow method changes, but practically there are user agents out there doing this. &lt;code&gt;307&lt;/code&gt; has been created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">[2]该规范无意允许更改方法，但实际上有用户代理可以这样做。已经创建了 &lt;code&gt;307&lt;/code&gt; ,以消除使用非 &lt;code&gt;GET&lt;/code&gt; 方法时行为的歧义。</target>
        </trans-unit>
        <trans-unit id="6e0756612a3806a698305eb0752124038b7a1541" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-1&quot; name=&quot;ref-1&quot;&gt;1&lt;/a&gt;] Alvestrand, H., &quot;Tags for the Identification of Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;1766&lt;/a&gt;, March 1995.

   [&lt;a id=&quot;ref-2&quot; name=&quot;ref-2&quot;&gt;2&lt;/a&gt;] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,
       D. and B. Alberti, &quot;The Internet Gopher Protocol (a distributed
       document search and retrieval protocol)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1436&quot;&gt;RFC 1436&lt;/a&gt;, March 1993.

   [&lt;a id=&quot;ref-3&quot; name=&quot;ref-3&quot;&gt;3&lt;/a&gt;] Berners-Lee, T., &quot;Universal Resource Identifiers in WWW&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;1630&lt;/a&gt;, June 1994.

   [&lt;a id=&quot;ref-4&quot; name=&quot;ref-4&quot;&gt;4&lt;/a&gt;] Berners-Lee, T., Masinter, L. and M. McCahill, &quot;Uniform Resource
       Locators (URL)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1738&quot;&gt;RFC 1738&lt;/a&gt;, December 1994.

   [&lt;a id=&quot;ref-5&quot; name=&quot;ref-5&quot;&gt;5&lt;/a&gt;] Berners-Lee, T. and D. Connolly, &quot;Hypertext Markup Language -
       2.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1866&quot;&gt;RFC 1866&lt;/a&gt;, November 1995.

   [&lt;a id=&quot;ref-6&quot; name=&quot;ref-6&quot;&gt;6&lt;/a&gt;] Berners-Lee, T., Fielding, R. and H. Frystyk, &quot;Hypertext Transfer
       Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-7&quot; name=&quot;ref-7&quot;&gt;7&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
       Extensions (MIME) Part One: Format of Internet Message Bodies&quot;,
       &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-8&quot; name=&quot;ref-8&quot;&gt;8&lt;/a&gt;] Braden, R., &quot;Requirements for Internet Hosts -- Communication
       Layers&quot;, STD 3, &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;, October 1989.

   [&lt;a id=&quot;ref-9&quot; name=&quot;ref-9&quot;&gt;9&lt;/a&gt;] Crocker, D., &quot;Standard for The Format of ARPA Internet Text
       Messages&quot;, STD 11, &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;, August 1982.

   [&lt;a id=&quot;ref-10&quot; name=&quot;ref-10&quot;&gt;10&lt;/a&gt;] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,
        Sui, J., and M. Grinbaum, &quot;WAIS Interface Protocol Prototype
        Functional Specification,&quot; (v1.5), Thinking Machines
        Corporation, April 1990.

   [&lt;a id=&quot;ref-11&quot; name=&quot;ref-11&quot;&gt;11&lt;/a&gt;] Fielding, R., &quot;Relative Uniform Resource Locators&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;,
        June 1995.

   [&lt;a id=&quot;ref-12&quot; name=&quot;ref-12&quot;&gt;12&lt;/a&gt;] Horton, M. and R. Adams, &quot;Standard for Interchange of USENET
        Messages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;, December 1987. 

   [&lt;a id=&quot;ref-13&quot; name=&quot;ref-13&quot;&gt;13&lt;/a&gt;] Kantor, B. and P. Lapsley, &quot;Network News Transfer Protocol&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;977&lt;/a&gt;, February 1986.

   [&lt;a id=&quot;ref-14&quot; name=&quot;ref-14&quot;&gt;14&lt;/a&gt;] Moore, K., &quot;MIME (Multipurpose Internet Mail Extensions) Part
        Three: Message Header Extensions for Non-ASCII Text&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;,
        November 1996.

   [&lt;a id=&quot;ref-15&quot; name=&quot;ref-15&quot;&gt;15&lt;/a&gt;] Nebel, E. and L. Masinter, &quot;Form-based File Upload in HTML&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;1867&lt;/a&gt;, November 1995.

   [&lt;a id=&quot;ref-16&quot; name=&quot;ref-16&quot;&gt;16&lt;/a&gt;] Postel, J., &quot;Simple Mail Transfer Protocol&quot;, STD 10, &lt;a href=&quot;https://tools.ietf.org/html/rfc821&quot;&gt;RFC 821&lt;/a&gt;,
        August 1982.

   [&lt;a id=&quot;ref-17&quot; name=&quot;ref-17&quot;&gt;17&lt;/a&gt;] Postel, J., &quot;Media Type Registration Procedure&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt;,
        November 1996.

   [&lt;a id=&quot;ref-18&quot; name=&quot;ref-18&quot;&gt;18&lt;/a&gt;] Postel, J. and J. Reynolds, &quot;File Transfer Protocol&quot;, STD 9, &lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;959&lt;/a&gt;, October 1985.

   [&lt;a id=&quot;ref-19&quot; name=&quot;ref-19&quot;&gt;19&lt;/a&gt;] Reynolds, J. and J. Postel, &quot;Assigned Numbers&quot;, STD 2, &lt;a href=&quot;https://tools.ietf.org/html/rfc1700&quot;&gt;RFC 1700&lt;/a&gt;,
        October 1994.

   [&lt;a id=&quot;ref-20&quot; name=&quot;ref-20&quot;&gt;20&lt;/a&gt;] Sollins, K. and L. Masinter, &quot;Functional Requirements for
        Uniform Resource Names&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1737&quot;&gt;RFC 1737&lt;/a&gt;, December 1994.

   [&lt;a id=&quot;ref-21&quot; name=&quot;ref-21&quot;&gt;21&lt;/a&gt;] US-ASCII. Coded Character Set - 7-Bit American Standard Code for
        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.

   [&lt;a id=&quot;ref-22&quot; name=&quot;ref-22&quot;&gt;22&lt;/a&gt;] ISO-8859. International Standard -- Information Processing --
        8-bit Single-Byte Coded Graphic Character Sets --
        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.
        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.
        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.
        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.
        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.
        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.
        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.
        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.
        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.

   [&lt;a id=&quot;ref-23&quot; name=&quot;ref-23&quot;&gt;23&lt;/a&gt;] Meyers, J. and M. Rose, &quot;The Content-MD5 Header Field&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;1864&lt;/a&gt;, October 1995.

   [&lt;a id=&quot;ref-24&quot; name=&quot;ref-24&quot;&gt;24&lt;/a&gt;] Carpenter, B. and Y. Rekhter, &quot;Renumbering Needs Work&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;1900&lt;/a&gt;, February 1996.

   [&lt;a id=&quot;ref-25&quot; name=&quot;ref-25&quot;&gt;25&lt;/a&gt;] Deutsch, P., &quot;GZIP file format specification version 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;1952&lt;/a&gt;, May 1996. 

   [&lt;a id=&quot;ref-26&quot; name=&quot;ref-26&quot;&gt;26&lt;/a&gt;] Venkata N. Padmanabhan, and Jeffrey C. Mogul. &quot;Improving HTTP
        Latency&quot;, Computer Networks and ISDN Systems, v. 28, pp. 25-35,
        Dec. 1995. Slightly revised version of paper in Proc. 2nd
        International WWW Conference '94: Mosaic and the Web, Oct. 1994,
        which is available at
        &lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat&lt;/a&gt;&lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;ency.html&lt;/a&gt;.

   [&lt;a id=&quot;ref-27&quot; name=&quot;ref-27&quot;&gt;27&lt;/a&gt;] Joe Touch, John Heidemann, and Katia Obraczka. &quot;Analysis of HTTP
        Performance&quot;, &amp;lt;URL: &lt;a href=&quot;http://www.isi.edu/touch/pubs/http-perf96/&quot;&gt;http://www.isi.edu/touch/pubs/http-perf96/&lt;/a&gt;&amp;gt;,
        ISI Research Report ISI/RR-98-463, (original report dated Aug.
        1996), USC/Information Sciences Institute, August 1998.

   [&lt;a id=&quot;ref-28&quot; name=&quot;ref-28&quot;&gt;28&lt;/a&gt;] Mills, D., &quot;Network Time Protocol (Version 3) Specification,
        Implementation and Analysis&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1305&quot;&gt;RFC 1305&lt;/a&gt;, March 1992.

   [&lt;a id=&quot;ref-29&quot; name=&quot;ref-29&quot;&gt;29&lt;/a&gt;] Deutsch, P., &quot;DEFLATE Compressed Data Format Specification
        version 1.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-30&quot; name=&quot;ref-30&quot;&gt;30&lt;/a&gt;] S. Spero, &quot;Analysis of HTTP Performance Problems,&quot;
        &lt;a href=&quot;http://sunsite.unc.edu/mdma-release/http-prob.html&quot;&gt;http://sunsite.unc.edu/mdma-release/http-prob.html&lt;/a&gt;.

   [&lt;a id=&quot;ref-31&quot; name=&quot;ref-31&quot;&gt;31&lt;/a&gt;] Deutsch, P. and J. Gailly, &quot;ZLIB Compressed Data Format
        Specification version 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-32&quot; name=&quot;ref-32&quot;&gt;32&lt;/a&gt;] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,
        Luotonen, A., Sink, E. and L. Stewart, &quot;An Extension to HTTP:
        Digest Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2069&quot;&gt;RFC 2069&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-33&quot; name=&quot;ref-33&quot;&gt;33&lt;/a&gt;] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.
        Berners-Lee, &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-34&quot; name=&quot;ref-34&quot;&gt;34&lt;/a&gt;] Bradner, S., &quot;Key words for use in RFCs to Indicate Requirement
        Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-35&quot; name=&quot;ref-35&quot;&gt;35&lt;/a&gt;] Troost, R. and Dorner, S., &quot;Communicating Presentation
        Information in Internet Messages: The Content-Disposition
        Header&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt;, June 1995.

   [&lt;a id=&quot;ref-36&quot; name=&quot;ref-36&quot;&gt;36&lt;/a&gt;] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, &quot;Use and
        Interpretation of HTTP Version Numbers&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, May 1997.
        [jg639]

   [&lt;a id=&quot;ref-37&quot; name=&quot;ref-37&quot;&gt;37&lt;/a&gt;] Palme, J., &quot;Common Internet Message Headers&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2076&quot;&gt;RFC 2076&lt;/a&gt;, February
        1997. [jg640] 

   [&lt;a id=&quot;ref-38&quot; name=&quot;ref-38&quot;&gt;38&lt;/a&gt;] Yergeau, F., &quot;UTF-8, a transformation format of Unicode and
        ISO-10646&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2279&quot;&gt;RFC 2279&lt;/a&gt;, January 1998. [jg641]

   [&lt;a id=&quot;ref-39&quot; name=&quot;ref-39&quot;&gt;39&lt;/a&gt;] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,
        Lie, H., and C. Lilley. &quot;Network Performance Effects of
        HTTP/1.1, CSS1, and PNG,&quot; Proceedings of ACM SIGCOMM '97, Cannes
        France, September 1997.[jg642]

   [&lt;a id=&quot;ref-40&quot; name=&quot;ref-40&quot;&gt;40&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
        Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;, November
        1996. [jg643]

   [&lt;a id=&quot;ref-41&quot; name=&quot;ref-41&quot;&gt;41&lt;/a&gt;] Alvestrand, H., &quot;IETF Policy on Character Sets and Languages&quot;,
        &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt;, January 1998. [jg644]

   [&lt;a id=&quot;ref-42&quot; name=&quot;ref-42&quot;&gt;42&lt;/a&gt;] Berners-Lee, T., Fielding, R. and L. Masinter, &quot;Uniform Resource
        Identifiers (URI): Generic Syntax and Semantics&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt;,
        August 1998. [jg645]

   [&lt;a id=&quot;ref-43&quot; name=&quot;ref-43&quot;&gt;43&lt;/a&gt;] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
        Leach, P., Luotonen, A., Sink, E. and L. Stewart, &quot;HTTP
        Authentication: Basic and Digest Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt;, June 1999. [jg646]

   [&lt;a id=&quot;ref-44&quot; name=&quot;ref-44&quot;&gt;44&lt;/a&gt;] Luotonen, A., &quot;Tunneling TCP based protocols through Web proxy
        servers,&quot; Work in Progress. [jg647]

   [&lt;a id=&quot;ref-45&quot; name=&quot;ref-45&quot;&gt;45&lt;/a&gt;] Palme, J. and A. Hopmann, &quot;MIME E-mail Encapsulation of
        Aggregate Documents, such as HTML (MHTML)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2110&quot;&gt;RFC 2110&lt;/a&gt;, March
        1997.

   [&lt;a id=&quot;ref-46&quot; name=&quot;ref-46&quot;&gt;46&lt;/a&gt;] Bradner, S., &quot;The Internet Standards Process -- Revision 3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;BCP&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;9&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2026&quot;&gt;RFC 2026&lt;/a&gt;, October 1996.

   [&lt;a id=&quot;ref-47&quot; name=&quot;ref-47&quot;&gt;47&lt;/a&gt;] Masinter, L., &quot;Hyper Text Coffee Pot Control Protocol
        (HTCPCP/1.0)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2324&quot;&gt;RFC 2324&lt;/a&gt;, 1 April 1998.

   [&lt;a id=&quot;ref-48&quot; name=&quot;ref-48&quot;&gt;48&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
        Extensions (MIME) Part Five: Conformance Criteria and Examples&quot;,
        &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-49&quot; name=&quot;ref-49&quot;&gt;49&lt;/a&gt;] Troost, R., Dorner, S. and K. Moore, &quot;Communicating Presentation
        Information in Internet Messages: The Content-Disposition Header
        Field&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2183&quot;&gt;RFC 2183&lt;/a&gt;, August 1997.</source>
          <target state="translated">[ &lt;a id=&quot;ref-1&quot; name=&quot;ref-1&quot;&gt;1&lt;/a&gt; ] Alvestrand，H.，&amp;ldquo;用于语言识别的标签&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;1766&lt;/a&gt;，1995 年 3月。[ &lt;a id=&quot;ref-2&quot; name=&quot;ref-2&quot;&gt;2&lt;/a&gt; ] Anklesaria，F.，McCahill，M.，Lindner，P.，Johnson，D.，Torrey，D.和B. Alberti，&amp;ldquo; Internet Gopher协议（分布式文档搜索和检索协议）&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1436&quot;&gt;RFC 1436&lt;/a&gt;，1993 年 3月。[ &lt;a id=&quot;ref-3&quot; name=&quot;ref-3&quot;&gt;3&lt;/a&gt; ] Berners-Lee，T。，&amp;ldquo; WWW中的通用资源标识符&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;1630&lt;/a&gt;，1994 年 6月。 [ &lt;a id=&quot;ref-4&quot; name=&quot;ref-4&quot;&gt;4&lt;/a&gt; ] Berners-Lee，T.，Masinter，L。和M. McCahill，&amp;ldquo;统一资源定位符（URL）&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1738&quot;&gt;RFC 1738&lt;/a&gt;，1994 年 12月。[ &lt;a id=&quot;ref-5&quot; name=&quot;ref-5&quot;&gt;5&lt;/a&gt;] Berners-Lee，T.和D. Connolly，&amp;ldquo;超文本标记语言-2.0&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1866&quot;&gt;RFC 1866&lt;/a&gt;，1995 年 11月。[ &lt;a id=&quot;ref-6&quot; name=&quot;ref-6&quot;&gt;6&lt;/a&gt; ] Berners-Lee，T.，Fielding，R.和H.Frystyk，&amp;ldquo;超文本传输​​协议- -HTTP / 1.0&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-7&quot; name=&quot;ref-7&quot;&gt;7&lt;/a&gt; ] Freed，N。和N. Borenstein，&amp;ldquo;多用途Internet邮件扩展（MIME）第一部分：Internet消息主体的格式&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;，1996年11月。[ &lt;a id=&quot;ref-8&quot; name=&quot;ref-8&quot;&gt;8&lt;/a&gt; ] Braden，R。，&amp;ldquo; Internet主机的要求-通信层&amp;rdquo;，STD 3，&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;，1989年10月。[ &lt;a id=&quot;ref-9&quot; name=&quot;ref-9&quot;&gt;9&lt;/a&gt; ] Crocker，D。，&amp;ldquo; ARPA Internet文本消息格式的标准&amp;rdquo;，STD 11，&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;，1982年8月。[ &lt;a id=&quot;ref-10&quot; name=&quot;ref-10&quot;&gt;10&lt;/a&gt; ]戴维斯&amp;middot;F&amp;middot;卡勒&amp;middot;B&amp;middot;莫里斯&amp;middot;H&amp;middot;塞勒姆&amp;middot;J&amp;middot;沉&amp;middot;T&amp;middot;王&amp;middot;R。Sui J.和M. Grinbaum，&amp;ldquo; WAIS接口协议原型功能规范，&amp;rdquo;（v1.5），Thinking Machines Corporation，1990年4月。[ &lt;a id=&quot;ref-11&quot; name=&quot;ref-11&quot;&gt;11&lt;/a&gt; ] Fielding，R。，&amp;ldquo;相对统一资源定位符&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;，1995 年 6月。[ &lt;a id=&quot;ref-12&quot; name=&quot;ref-12&quot;&gt;12&lt;/a&gt; ] Horton，M。和R。 Adams，&amp;ldquo; USENET消息的交换标准&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;，1987年12月。[ &lt;a id=&quot;ref-13&quot; name=&quot;ref-13&quot;&gt;13&lt;/a&gt; ] Kantor，B.和P. Lapsley，&amp;ldquo;网络新闻传输协议&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;977&lt;/a&gt;，1986年2月。[ &lt;a id=&quot;ref-14&quot; name=&quot;ref-14&quot;&gt;14&lt;/a&gt;] Moore，K。，&amp;ldquo; MIME（多用途Internet邮件扩展）第三部分：非ASCII文本的消息头扩展&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;，1996年11月。[ &lt;a id=&quot;ref-15&quot; name=&quot;ref-15&quot;&gt;15&lt;/a&gt; ] Nebel，E。和L. Masinter，&amp;ldquo;基于表单的文件&amp;ldquo;以HTML格式上传&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;1867&lt;/a&gt;，1995 年 11月。[ &lt;a id=&quot;ref-16&quot; name=&quot;ref-16&quot;&gt;16&lt;/a&gt; ] Postel，J。，&amp;ldquo;简单邮件传输协议&amp;rdquo;，STD 10，&lt;a href=&quot;https://tools.ietf.org/html/rfc821&quot;&gt;RFC 821&lt;/a&gt;，1982年8月。[ &lt;a id=&quot;ref-17&quot; name=&quot;ref-17&quot;&gt;17&lt;/a&gt; ] Postel，J。，&amp;ldquo;媒体类型注册程序&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt;，1996年11月。[ &lt;a id=&quot;ref-18&quot; name=&quot;ref-18&quot;&gt;18&lt;/a&gt; ] Postel，J。和J. Reynolds，&amp;ldquo;文件传输协议&amp;rdquo;，STD 9，&lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;959&lt;/a&gt;，1985 &lt;a id=&quot;ref-19&quot; name=&quot;ref-19&quot;&gt;年&lt;/a&gt; 10月。[ 19] Reynolds，J.和J. Postel，&amp;ldquo;分配的数字&amp;rdquo;，STD 2，&lt;a href=&quot;https://tools.ietf.org/html/rfc1700&quot;&gt;RFC 1700&lt;/a&gt;，1994 年 10月。[ &lt;a id=&quot;ref-20&quot; name=&quot;ref-20&quot;&gt;20&lt;/a&gt; ] Sollins，K.和L. Masinter，&amp;ldquo;统一资源名称的功能要求&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1737&quot;&gt;RFC 1737&lt;/a&gt;，1994 年 12月。 [ &lt;a id=&quot;ref-21&quot; name=&quot;ref-21&quot;&gt;21&lt;/a&gt; ] US-ASCII。编码字符集-信息交换的7位美国标准代码。标准ANSI X3.4-1986，ANSI，1986。[ &lt;a id=&quot;ref-22&quot; name=&quot;ref-22&quot;&gt;22&lt;/a&gt;] ISO-8859。国际标准-信息处理-8位单字节编码图形字符集-第1部分：拉丁字母1，ISO-8859-1：1987。第2部分：ISO 8859-2，1987年第2号拉丁字母。第3部分，ISO-8859-3，1988年，第3号拉丁字母。第4部分：ISO-8859-4，1988年，第4号拉丁字母。 。第5部分：拉丁文/西里尔字母，ISO-8859-5，1988年；第6部分：拉丁文/阿拉伯字母，ISO-8859-6，1987年。第7部分：拉丁文/希腊字母，ISO-8859-7，1987年。 8：拉丁/希伯来字母，ISO-8859-8，1988。第9部分：拉丁字母5，ISO-8859-9，1990。[ &lt;a id=&quot;ref-23&quot; name=&quot;ref-23&quot;&gt;23&lt;/a&gt; ] Meyers，J.和M. Rose，&amp;ldquo; Content-MD5标头Field&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;1864&lt;/a&gt;，1995 年 10月。[ &lt;a id=&quot;ref-24&quot; name=&quot;ref-24&quot;&gt;24&lt;/a&gt;] Carpenter，B.和Y. Rekhter，&amp;ldquo;重新编号需要的工作&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;1900&lt;/a&gt;，1996 年 2月。[ &lt;a id=&quot;ref-25&quot; name=&quot;ref-25&quot;&gt;25&lt;/a&gt; ] Deutsch，P。，&amp;ldquo; GZIP文件格式规范版本4.3&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;1952&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-26&quot; name=&quot;ref-26&quot;&gt;26&lt;/a&gt; ] Venkata N Padmanabhan和Jeffrey C. Mogul &amp;ldquo;改善HTTP延迟&amp;rdquo;，计算机网络和ISDN系统，第28卷，第25-35页，1995年12月。第2届94年国际WWW会议：Mosaic and the Web，1994年10月，可在 &lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat &lt;/a&gt;&lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;ency.html上找到&lt;/a&gt;。 [ &lt;a id=&quot;ref-27&quot; name=&quot;ref-27&quot;&gt;27&lt;/a&gt;] Joe Touch，John Heidemann和Katia Obraczka。 &amp;ldquo; HTTP性能分析&amp;rdquo;，&amp;lt;URL：&lt;a href=&quot;http://www.isi.edu/touch/pubs/http-perf96/&quot;&gt;http&lt;/a&gt;：//www.isi.edu/touch/pubs/http-perf96/&amp;gt;，ISI研究报告ISI / RR-98-463，（原始报告日期为1996年8月）， USC /信息科学研究所，1998 &lt;a id=&quot;ref-28&quot; name=&quot;ref-28&quot;&gt;年&lt;/a&gt; 8月。[ 28 ] Mills，D.，&amp;ldquo;网络时间协议（第3版）规范，实现和分析&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1305&quot;&gt;RFC 1305&lt;/a&gt;，1992 年 3月。[ &lt;a id=&quot;ref-29&quot; name=&quot;ref-29&quot;&gt;29&lt;/a&gt; ] Deutsch，P.，&amp;ldquo;压缩压缩数据&amp;rdquo;格式规范版本1.3&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-30&quot; name=&quot;ref-30&quot;&gt;30&lt;/a&gt; ] S. Spero，&amp;ldquo; HTTP性能问题分析&amp;rdquo;， &lt;a href=&quot;http://sunsite.unc.edu/mdma-release/http-prob.html&quot;&gt;http：//sunsite.unc.edu/mdma-release/http-prob.html&lt;/a&gt;。[ &lt;a id=&quot;ref-31&quot; name=&quot;ref-31&quot;&gt;31&lt;/a&gt;]，Deutsch，P。和J.Gailly，&amp;ldquo; ZLIB压缩数据格式规范版本3.3&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-32&quot; name=&quot;ref-32&quot;&gt;32&lt;/a&gt; ] Franks，J.，Hallam-Baker，P.，Hostetler，J.，Leach，P.。 ，Luotonen，A.，Sink，E。和L. Stewart，&amp;ldquo; HTTP的扩展：摘要访问身份验证&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2069&quot;&gt;RFC 2069&lt;/a&gt;，1997年1月。[ &lt;a id=&quot;ref-33&quot; name=&quot;ref-33&quot;&gt;33&lt;/a&gt; ] Fielding，R.，Gettys，J.，Mogul，J。， Frystyk，H.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt;，1997年1月。[ &lt;a id=&quot;ref-34&quot; name=&quot;ref-34&quot;&gt;34&lt;/a&gt; ] Bradner，S.，&amp;ldquo;在RFC中使用以指示需求级别的关键字&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-35&quot; name=&quot;ref-35&quot;&gt;35&lt;/a&gt;] Troost，R.和Dorner，S.，&amp;ldquo;在Internet消息中通信演示信息：内容处理标题&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt;，1995 年 6月。[ &lt;a id=&quot;ref-36&quot; name=&quot;ref-36&quot;&gt;36&lt;/a&gt; ] Mogul，J.，Fielding，R.，Gettys，J. and H. Frystyk，&amp;ldquo; HTTP版本号的使用和解释&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;，1997年5月。[jg639] [ &lt;a id=&quot;ref-37&quot; name=&quot;ref-37&quot;&gt;37&lt;/a&gt; ] Palme，J。，&amp;ldquo;公共Internet消息头&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2076&quot;&gt;RFC 2076&lt;/a&gt;，1997年2月。[jg640] [ &lt;a id=&quot;ref-38&quot; name=&quot;ref-38&quot;&gt;38&lt;/a&gt; ] Yergeau，F。，&amp;ldquo; UTF-8，Unicode和ISO-10646的转换格式&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2279&quot;&gt;RFC 2279&lt;/a&gt;，1998年1月。[jg641] [ &lt;a id=&quot;ref-39&quot; name=&quot;ref-39&quot;&gt;39&lt;/a&gt;] Nielsen，HF，Gettys，J.，Baird-Smith，A.，Prud'hommeaux，E.，Lie，H.和C. Lilley。 &amp;ldquo; HTTP / 1.1，CSS1和PNG的网络性能影响&amp;rdquo;，ACM SIGCOMM '97的会议记录，法国戛纳，1997年9月。[jg642] [ &lt;a id=&quot;ref-40&quot; name=&quot;ref-40&quot;&gt;40&lt;/a&gt; ] Freed，N。和N. Borenstein，&amp;ldquo;多用途Internet邮件扩展（MIME） ）第二部分：媒体类型&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;，1996年11月。[jg643] [ &lt;a id=&quot;ref-41&quot; name=&quot;ref-41&quot;&gt;41&lt;/a&gt; ] Alvestrand，H。，&amp;ldquo; IETF字符集和语言策略&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt;，1998年1月。[jg644] [ &lt;a id=&quot;ref-42&quot; name=&quot;ref-42&quot;&gt;42&lt;/a&gt; ] Berners-Lee，T.，Fielding，R.和L. Masinter，&amp;ldquo;统一资源标识符（URI）：通用语法和语义&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt;，1998年8月。[jg645] [ &lt;a id=&quot;ref-43&quot; name=&quot;ref-43&quot;&gt;43&lt;/a&gt; ] Franks，J.，Hallam-Baker，P.，Hostetler，J.，Lawrence，S.，Leach，P.，Luotonen，A.，Sink，E.和L. Stewart ，&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt;，1999年6月。[jg646] [ &lt;a id=&quot;ref-44&quot; name=&quot;ref-44&quot;&gt;44&lt;/a&gt; ] Luotonen，A.，&amp;ldquo;通过Web代理服务器隧道化基于TCP的协议&amp;rdquo;，正在进行中。 [jg647] [ &lt;a id=&quot;ref-45&quot; name=&quot;ref-45&quot;&gt;45&lt;/a&gt; ] Palme，J.和A. Hopmann，&amp;ldquo;诸如HTML（MHTML）之类的聚合文档的MIME电子邮件封装&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2110&quot;&gt;RFC 2110&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-46&quot; name=&quot;ref-46&quot;&gt;46&lt;/a&gt; ] Bradner，S.，&amp;ldquo;互联网标准流程-修订版3&amp;ldquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;BCP &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;9&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2026&quot;&gt;RFC 2026&lt;/a&gt;，1996年10月。[ &lt;a id=&quot;ref-47&quot; name=&quot;ref-47&quot;&gt;47&lt;/a&gt; ] Masinter，L.，&amp;ldquo;超文本咖啡壶控制协议（HTCPCP / 1.0）&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2324&quot;&gt;RFC 2324&lt;/a&gt;，1998年4月1日。[ &lt;a id=&quot;ref-48&quot; name=&quot;ref-48&quot;&gt;48&lt;/a&gt; ] Freed，N。和N. Borenstein，&amp;ldquo;多用途Internet邮件扩展（MIME）第五部分：一致性标准和示例&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;，1996年11月。[ &lt;a id=&quot;ref-49&quot; name=&quot;ref-49&quot;&gt;49&lt;/a&gt; ] Troost，R.，Dorner，S.和K. Moore，&amp;ldquo;在Internet消息中通信演示信息：内容配置标头字段&amp;rdquo; ，&lt;a href=&quot;https://tools.ietf.org/html/rfc2183&quot;&gt;RFC 2183&lt;/a&gt;，1997年8月。</target>
        </trans-unit>
        <trans-unit id="dc821d5e8b6f5141610286985b0b686179701b49" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP115&quot; name=&quot;ref-BCP115&quot;&gt;BCP115&lt;/a&gt;]      Hansen, T., Hardie, T., and L. Masinter, &quot;Guidelines
                 and Registration Procedures for New URI Schemes&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/bcp115&quot;&gt;BCP 115&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4395&quot;&gt;RFC 4395&lt;/a&gt;, February 2006.

   [&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]       Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
                 Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]       Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
                 Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;, September 2004.

   [&lt;a id=&quot;ref-Georgiev&quot; name=&quot;ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]    Georgiev, M., Iyengar, S., Jana, S., Anubhai, R.,
                 Boneh, D., and V. Shmatikov, &quot;The Most Dangerous Code
                 in the World: Validating SSL Certificates in Non-
                 browser Software&quot;, In Proceedings of the 2012 ACM
                 Conference on Computer and Communications Security (CCS
                 '12), pp. 38-49, October 2012,
                 &amp;lt;&lt;a href=&quot;http://doi.acm.org/10.1145/2382196.2382204&quot;&gt;http://doi.acm.org/10.1145/2382196.2382204&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-ISO-8859-1&quot; name=&quot;ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt;]  International Organization for Standardization,
                 &quot;Information technology -- 8-bit single-byte coded
                 graphic character sets -- Part 1: Latin alphabet No.
                 1&quot;, ISO/IEC 8859-1:1998, 1998.

   [&lt;a id=&quot;ref-Klein&quot; name=&quot;ref-Klein&quot;&gt;Klein&lt;/a&gt;]       Klein, A., &quot;Divide and Conquer - HTTP Response
                 Splitting, Web Cache Poisoning Attacks, and Related
                 Topics&quot;, March 2004, &amp;lt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;http://packetstormsecurity.com/&lt;/a&gt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;papers/general/whitepaper_httpresponse.pdf&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-Kri2001&quot; name=&quot;ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;]     Kristol, D., &quot;HTTP Cookies: Standards, Privacy, and
                 Politics&quot;, ACM Transactions on Internet
                 Technology 1(2), November 2001,
                 &amp;lt;&lt;a href=&quot;http://arxiv.org/abs/cs.SE/0105018&quot;&gt;http://arxiv.org/abs/cs.SE/0105018&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-Linhart&quot; name=&quot;ref-Linhart&quot;&gt;Linhart&lt;/a&gt;]     Linhart, C., Klein, A., Heled, R., and S. Orrin, &quot;HTTP
                 Request Smuggling&quot;, June 2005,
                 &amp;lt;&lt;a href=&quot;http://www.watchfire.com/news/whitepapers.aspx&quot;&gt;http://www.watchfire.com/news/whitepapers.aspx&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-RFC1919&quot; name=&quot;ref-RFC1919&quot;&gt;RFC1919&lt;/a&gt;]     Chatel, M., &quot;Classical versus Transparent IP Proxies&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC 1919&lt;/a&gt;, March 1996.

   [&lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt;]     Berners-Lee, T., Fielding, R., and H. Nielsen,
                 &quot;Hypertext Transfer Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;,
                 May 1996.

   [&lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt;]     Freed, N. and N. Borenstein, &quot;Multipurpose Internet
                 Mail Extensions (MIME) Part One: Format of Internet
                 Message Bodies&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2047&quot; name=&quot;ref-RFC2047&quot;&gt;RFC2047&lt;/a&gt;]     Moore, K., &quot;MIME (Multipurpose Internet Mail
                 Extensions) Part Three: Message Header Extensions for
                 Non-ASCII Text&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt;]     Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and
                 T. Berners-Lee, &quot;Hypertext Transfer Protocol --
                 HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-RFC2145&quot; name=&quot;ref-RFC2145&quot;&gt;RFC2145&lt;/a&gt;]     Mogul, J., Fielding, R., Gettys, J., and H. Nielsen,
                 &quot;Use and Interpretation of HTTP Version Numbers&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, May 1997.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                 Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
                 Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt;]     Khare, R. and S. Lawrence, &quot;Upgrading to TLS Within
                 HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt;]     Rescorla, E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC3040&quot; name=&quot;ref-RFC3040&quot;&gt;RFC3040&lt;/a&gt;]     Cooper, I., Melve, I., and G. Tomlinson, &quot;Internet Web
                 Replication and Caching Taxonomy&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC 3040&lt;/a&gt;,
                 January 2001.

   [&lt;a id=&quot;ref-RFC4033&quot; name=&quot;ref-RFC4033&quot;&gt;RFC4033&lt;/a&gt;]     Arends, R., Austein, R., Larson, M., Massey, D., and S.
                 Rose, &quot;DNS Security Introduction and Requirements&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC 4033&lt;/a&gt;, March 2005.

   [&lt;a id=&quot;ref-RFC4559&quot; name=&quot;ref-RFC4559&quot;&gt;RFC4559&lt;/a&gt;]     Jaganathan, K., Zhu, L., and J. Brezak, &quot;SPNEGO-based
                 Kerberos and NTLM HTTP Authentication in Microsoft
                 Windows&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC 4559&lt;/a&gt;, June 2006.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]     Narten, T. and H. Alvestrand, &quot;Guidelines for Writing
                 an IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;, May 2008. 

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]     Dierks, T. and E. Rescorla, &quot;The Transport Layer
                 Security (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;,
                 August 2008.

   [&lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt;]     Resnick, P., &quot;Internet Message Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;,
                 October 2008.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]     Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
                 April 2011.

   [&lt;a id=&quot;ref-RFC6585&quot; name=&quot;ref-RFC6585&quot;&gt;RFC6585&lt;/a&gt;]     Nottingham, M. and R. Fielding, &quot;Additional HTTP Status
                 Codes&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585&lt;/a&gt;, April 2012.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP115&quot; name=&quot;ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] Hansen，T.，Hardie，T.和L. Masinter，&amp;ldquo;新URI方案的指南和注册过程&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/bcp115&quot;&gt;BCP 115&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4395&quot;&gt;RFC 4395&lt;/a&gt;，2006年2月。[ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] Freed，N.，克莱森，J。和T. Hansen，&amp;ldquo;媒体类型规范和注册过程&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;， &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;，2013年1月。[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne，G.，Nottingham，M.和J. Mogul，&amp;ldquo;消息头字段的注册过程&amp;rdquo;。 ，&lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;， &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;，2004年9月。[ &lt;a id=&quot;ref-Georgiev&quot; name=&quot;ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;] Georgiev，M.，Iyengar，S.，Jana，S.，Anubhai，R.，Boneh，D.和V. Shmatikov，&amp;ldquo;世界上最危险的代码：在非浏览器软件中验证SSL证书&amp;rdquo;，在2012年ACM计算机和通信安全会议（CCS '12）的会议记录中，第38-49页，2012年10月，&amp;lt; &lt;a href=&quot;http://doi.acm.org/10.1145/2382196.2382204&quot;&gt;http://doi.acm.org/10.1145/2382196.2382204&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-ISO-8859-1&quot; name=&quot;ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt; ]国际标准化组织，&amp;ldquo;信息技术-8位单字节编码图形字符集-第1部分：拉丁字母1&amp;rdquo;，ISO / IEC 8859-1：1998，1998。 [ &lt;a id=&quot;ref-Klein&quot; name=&quot;ref-Klein&quot;&gt;克莱因&lt;/a&gt;]克莱恩，A.， &amp;ldquo;分而治之- HTTP响应拆分，Web缓存中毒攻击，以及相关主题&amp;rdquo;中，2004年3月，&amp;lt; &lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;http://packetstormsecurity.com/ &lt;/a&gt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;纸/普通/ whitepaper_httpresponse.pdf&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-Kri2001&quot; name=&quot;ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt; ] Kristol，D。，&amp;ldquo; HTTP cookie：标准，隐私和政治&amp;rdquo;，ACM Transactions on Internet Technology 1（2），2001年11月，&amp;lt; &lt;a href=&quot;http://arxiv.org/abs/cs.SE/0105018&quot;&gt;http://arxiv.org/abs/cs.SE/0105018&lt;/a&gt; &amp;gt; 。 [ &lt;a id=&quot;ref-Linhart&quot; name=&quot;ref-Linhart&quot;&gt;Linhart&lt;/a&gt; ] Linhart，C.，Klein，A.，Heled，R.和S. Orrin，&amp;ldquo; HTTP请求走私&amp;rdquo;，2005年6月，&amp;lt; &lt;a href=&quot;http://www.watchfire.com/news/whitepapers.aspx&quot;&gt;http://www.watchfire.com/news/whitepapers.aspx&lt;/a&gt; &amp;gt;。[ &lt;a id=&quot;ref-RFC1919&quot; name=&quot;ref-RFC1919&quot;&gt;RFC1919&lt;/a&gt;] Chatel，M.，&amp;ldquo;经典与透明IP代理&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC 1919&lt;/a&gt;，1996 年 3月。[ &lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt; ] Berners-Lee，T.，Fielding，R.和H. Nielsen，&amp;ldquo;超文本传输​​协议-HTTP / 1.0&amp;rdquo; ，&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt; ] Freed，N。和N. Borenstein，&amp;ldquo;多用途Internet邮件扩展（MIME）第一部分：Internet邮件正文的格式&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;，1996年11月。[ &lt;a id=&quot;ref-RFC2047&quot; name=&quot;ref-RFC2047&quot;&gt;RFC2047&lt;/a&gt; ] Moore，K。 ，&amp;ldquo; MIME（多用途Internet邮件扩展）第三部分：非ASCII文本的消息头扩展&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;，1996年11月。[&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt; ] Fielding，R.，Gettys，J.，Mogul，J.，Nielsen，H.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;，1997年1月。[ &lt;a id=&quot;ref-RFC2145&quot; name=&quot;ref-RFC2145&quot;&gt;RFC2145&lt;/a&gt; ] Mogul ，J.，Fielding，R.，Gettys，J。和H. Nielsen，&amp;ldquo; HTTP版本号的使用和解释&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;，1997年5月。[ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding，R.，Gettys，J.，Mogul， J.，Frystyk，H.，Masinter，L.，Leach，P.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;，1999年6月。[ &lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt; ] Khare，R.和S. Lawrence，&amp;ldquo;在HTTP / 1.1内升级到TLS&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;，2000年5月。[ &lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt; ] Rescorla，E。，&amp;ldquo; HTTP over TLS&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;，2000年5月。[ &lt;a id=&quot;ref-RFC3040&quot; name=&quot;ref-RFC3040&quot;&gt;RFC3040&lt;/a&gt; ] Cooper，I.，Melve，I。和G. Tomlinson，&amp;ldquo; Internet Web复制和缓存&amp;rdquo;分类法&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC 3040&lt;/a&gt;，2001年1月。[ &lt;a id=&quot;ref-RFC4033&quot; name=&quot;ref-RFC4033&quot;&gt;RFC4033&lt;/a&gt; ] Arends，R.，Austein，R.，Larson，M.，Massey，D.和S. Rose，&amp;ldquo; DNS安全性介绍和要求&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC 4033&lt;/a&gt;，2005年3月。[ &lt;a id=&quot;ref-RFC4559&quot; name=&quot;ref-RFC4559&quot;&gt;RFC4559&lt;/a&gt; ] Jaganathan，K.，Zhu，L.和J. Brezak，&amp;ldquo; Microsoft Windows中基于SPNEGO的Kerberos和NTLM HTTP身份验证&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC 4559&lt;/a&gt;，2006年6月。[ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten，T.和H. Alvestrand，&amp;ldquo;在RFC中编写IANA考虑部分的指南&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;， &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;，2008年5月。[ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks，T.和E. Rescorla，&amp;ldquo;传输层安全性（TLS）协议版本1.2&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;，2008年8月。[ &lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt; ] Resnick，P。，&amp;ldquo; Internet消息格式&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;，2008年10月。[ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ] Barth，A。，&amp;ldquo; HTTP状态管理机制&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;，2011年4月。[ &lt;a id=&quot;ref-RFC6585&quot; name=&quot;ref-RFC6585&quot;&gt;RFC6585&lt;/a&gt;] Nottingham，M.和R. Fielding，&amp;ldquo;其他HTTP状态代码&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585&lt;/a&gt;，2012年4月。</target>
        </trans-unit>
        <trans-unit id="709bdcb38d1223b2efcf9537053ac448ee82c675" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]    Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
              Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP178&quot; name=&quot;ref-BCP178&quot;&gt;BCP178&lt;/a&gt;]   Saint-Andre, P., Crocker, D., and M. Nottingham,
              &quot;Deprecating the &quot;X-&quot; Prefix and Similar Constructs in
              Application Protocols&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp178&quot;&gt;BCP 178&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6648&quot;&gt;RFC 6648&lt;/a&gt;, June 2012. 

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]    van der Stock, A., Ed., &quot;A Guide to Building Secure Web
              Applications and Web Services&quot;, The Open Web Application
              Security Project (OWASP) 2.0.1, July 2005,
              &amp;lt;&lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REST&quot; name=&quot;ref-REST&quot;&gt;REST&lt;/a&gt;]     Fielding, R., &quot;Architectural Styles and the Design of
              Network-based Software Architectures&quot;,
              Doctoral Dissertation, University of California, Irvine,
              September 2000,
              &amp;lt;&lt;a href=&quot;http://roy.gbiv.com/pubs/dissertation/top.htm&quot;&gt;http://roy.gbiv.com/pubs/dissertation/top.htm&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and H. Nielsen, &quot;Hypertext
              Transfer Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC2049&quot; name=&quot;ref-RFC2049&quot;&gt;RFC2049&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Five: Conformance Criteria and
              Examples&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and T.
              Berners-Lee, &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-RFC2295&quot; name=&quot;ref-RFC2295&quot;&gt;RFC2295&lt;/a&gt;]  Holtman, K. and A. Mutz, &quot;Transparent Content Negotiation
              in HTTP&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;, March 1998.

   [&lt;a id=&quot;ref-RFC2388&quot; name=&quot;ref-RFC2388&quot;&gt;RFC2388&lt;/a&gt;]  Masinter, L., &quot;Returning Values from Forms:  multipart/
              form-data&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC 2388&lt;/a&gt;, August 1998.

   [&lt;a id=&quot;ref-RFC2557&quot; name=&quot;ref-RFC2557&quot;&gt;RFC2557&lt;/a&gt;]  Palme, F., Hopmann, A., Shelness, N., and E. Stefferud,
              &quot;MIME Encapsulation of Aggregate Documents, such as HTML
              (MHTML)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC 2557&lt;/a&gt;, March 1999.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2774&quot; name=&quot;ref-RFC2774&quot;&gt;RFC2774&lt;/a&gt;]  Frystyk, H., Leach, P., and S. Lawrence, &quot;An HTTP
              Extension Framework&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt;, February 2000.

   [&lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt;]  Khare, R. and S. Lawrence, &quot;Upgrading to TLS Within
              HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC2978&quot; name=&quot;ref-RFC2978&quot;&gt;RFC2978&lt;/a&gt;]  Freed, N. and J. Postel, &quot;IANA Charset Registration
              Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp19&quot;&gt;BCP 19&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC 2978&lt;/a&gt;, October 2000. 

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;, August 2008.

   [&lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt;]  Resnick, P., &quot;Internet Message Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;,
              October 2008.

   [&lt;a id=&quot;ref-RFC5789&quot; name=&quot;ref-RFC5789&quot;&gt;RFC5789&lt;/a&gt;]  Dusseault, L. and J. Snell, &quot;PATCH Method for HTTP&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789&lt;/a&gt;, March 2010.

   [&lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt;]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              &quot;Network Time Protocol Version 4: Protocol and Algorithms
              Specification&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt;, June 2010.

   [&lt;a id=&quot;ref-RFC5987&quot; name=&quot;ref-RFC5987&quot;&gt;RFC5987&lt;/a&gt;]  Reschke, J., &quot;Character Set and Language Encoding for
              Hypertext Transfer Protocol (HTTP) Header Field
              Parameters&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;, August 2010.

   [&lt;a id=&quot;ref-RFC5988&quot; name=&quot;ref-RFC5988&quot;&gt;RFC5988&lt;/a&gt;]  Nottingham, M., &quot;Web Linking&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC 5988&lt;/a&gt;, October 2010.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]  Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
              April 2011.

   [&lt;a id=&quot;ref-RFC6266&quot; name=&quot;ref-RFC6266&quot;&gt;RFC6266&lt;/a&gt;]  Reschke, J., &quot;Use of the Content-Disposition Header Field
              in the Hypertext Transfer Protocol (HTTP)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC 6266&lt;/a&gt;,
              June 2011.

   [&lt;a id=&quot;ref-RFC7238&quot; name=&quot;ref-RFC7238&quot;&gt;RFC7238&lt;/a&gt;]  Reschke, J., &quot;The Hypertext Transfer Protocol (HTTP)
              Status Code 308 (Permanent Redirect)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC 7238&lt;/a&gt;,
              June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] N. Freed，J。Klensin和T. Hansen，&amp;ldquo;媒体类型规范和注册程序&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;， &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;，2013年1月。[ &lt;a id=&quot;ref-BCP178&quot; name=&quot;ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ] Saint-Andre，P.，Crocker，D。 ，和M.诺丁汉，&amp;ldquo;弃用应用协议中的&amp;ldquo; X-&amp;rdquo;前缀和类似结构&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp178&quot;&gt;BCP 178&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc6648&quot;&gt;RFC 6648&lt;/a&gt;，2012年6月。[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne，G.，Nottingham，M。和J. Mogul， &amp;ldquo;消息头字段的注册过程&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;，2004年9月。[ &lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;] van der Stock，A。，编辑，&amp;ldquo;构建安全Web应用程序和Web服务的指南&amp;rdquo;，开放Web应用程序安全性项目（OWASP）2.0.1，2005年7月，&amp;lt; &lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org /&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-REST&quot; name=&quot;ref-REST&quot;&gt;REST&lt;/a&gt; ] R. Fielding，&amp;ldquo;建筑风格和基于网络的软件体系结构设计&amp;rdquo;，加州大学欧文分校的博士学位论文，2000年9月，&amp;lt; &lt;a href=&quot;http://roy.gbiv.com/pubs/dissertation/top.htm&quot;&gt;http://roy.gbiv.com/pubs/dissertation/top .htm&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt; ] Berners-Lee，T.，Fielding，R.和H. Nielsen，&amp;ldquo;超文本传输​​协议-HTTP / 1.0&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-RFC2049&quot; name=&quot;ref-RFC2049&quot;&gt;RFC2049&lt;/a&gt;Freed，N.和N. Borenstein，&amp;ldquo;多用途Internet邮件扩展（MIME）第五部分：一致性标准和示例&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;，1996年11月。[ &lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt; ] Fielding，R.，Gettys，J.，Mogul，J. ，Nielsen，H.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;，1997年1月。[ &lt;a id=&quot;ref-RFC2295&quot; name=&quot;ref-RFC2295&quot;&gt;RFC2295&lt;/a&gt; ] Holtman，K.和A. Mutz，&amp;ldquo; HTTP中的透明内容协商&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;，1998年3月。[ &lt;a id=&quot;ref-RFC2388&quot; name=&quot;ref-RFC2388&quot;&gt;RFC2388&lt;/a&gt; ] Masinter，L.，&amp;ldquo;从表单返回值：multipart / form-data&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC 2388&lt;/a&gt;，1998年8月。[ &lt;a id=&quot;ref-RFC2557&quot; name=&quot;ref-RFC2557&quot;&gt;RFC2557&lt;/a&gt;] Palme，F.，Hopmann，A.，Shelness，N.和E. Stefferud，&amp;ldquo;汇总文档的MIME封装，例如HTML（MHTML）&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC 2557&lt;/a&gt;，1999年3月。[ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding，R.， Gettys，J.，Mogul，J.，Frystyk，H.，Masinter，L.，Leach，P.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;，1999年6月。&lt;a id=&quot;ref-RFC2774&quot; name=&quot;ref-RFC2774&quot;&gt;RFC2774&lt;/a&gt; ] Frystyk，H.，Leach，P.和S. Lawrence，&amp;ldquo; HTTP扩展框架&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt;，2000年2月。[ &lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt; ] Khare，R.和S. Lawrence，&amp;ldquo;在HTTP / 1.1内升级到TLS &amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;，2000年5月。[ &lt;a id=&quot;ref-RFC2978&quot; name=&quot;ref-RFC2978&quot;&gt;RFC2978&lt;/a&gt;] Freed，N.和J. Postel，&amp;ldquo; IANA字符集注册程序&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp19&quot;&gt;BCP 19&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC 2978&lt;/a&gt;，2000年10月。[ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten，T.和H. Alvestrand，&amp;ldquo;在RFC中编写IANA考虑部分的指南&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;，2008年5月。[ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks，T.和E. Rescorla，&amp;ldquo;传输层安全性（TLS）协议版本1.2&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;，2008年8月。[ &lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt; ] Resnick，P。，&amp;ldquo;互联网邮件格式&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;，2008年10月。[ &lt;a id=&quot;ref-RFC5789&quot; name=&quot;ref-RFC5789&quot;&gt;RFC5789&lt;/a&gt;] Dusseault，L.和J. Snell，&amp;ldquo; HTTP的PATCH方法&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789&lt;/a&gt;，2010年3月。[ &lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt; ] Mills，D.，Martin，J.，Ed。，Burbank，J.和W. Kasch，&amp;ldquo;网络时间协议版本4：协议和算法规范&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt;，2010年6月。[ &lt;a id=&quot;ref-RFC5987&quot; name=&quot;ref-RFC5987&quot;&gt;RFC5987&lt;/a&gt; ] Reschke，J。，&amp;ldquo;超文本传输​​协议（HTTP）标头字段参数的字符集和语言编码&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;，2010年8月。 [ &lt;a id=&quot;ref-RFC5988&quot; name=&quot;ref-RFC5988&quot;&gt;RFC5988&lt;/a&gt; ] M.诺丁汉，&amp;ldquo; Web链接&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC 5988&lt;/a&gt;，2010年10月。[ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ]巴思，A。，&amp;ldquo; HTTP状态管理机制&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;，2011年4月。[ &lt;a id=&quot;ref-RFC6266&quot; name=&quot;ref-RFC6266&quot;&gt;RFC6266&lt;/a&gt; ] Reschke，J。，&amp;ldquo;在超文本传输​​协议（HTTP）中使用内容处置标头字段&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC 6266&lt;/a&gt;，2011年6月。[ &lt;a id=&quot;ref-RFC7238&quot; name=&quot;ref-RFC7238&quot;&gt;RFC7238&lt;/a&gt; ] Reschke，J。，&amp;ldquo;超文本传输​​协议（HTTP）状态代码308（永久重定向）&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC 7238&lt;/a&gt;，2014年6月。</target>
        </trans-unit>
        <trans-unit id="188dbbf80aeecdc21816591c6751af6f215cfa89" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]    Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
              Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] N. Freed，J。Klensin和T. Hansen，&amp;ldquo;媒体类型规范和注册程序&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;， &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;，2013年1月。[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne，G。，诺丁汉，M。和J. Mogul，&amp;ldquo;消息标头字段的注册过程&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;，2004年9月。[ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding，R.，Gettys，J.，Mogul，J.，Frystyk，H.，Masinter，L.， Leach，P.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;，1999年6月。[ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;] Narten，T.和H. Alvestrand，&amp;ldquo;在RFC中编写IANA考虑部分的指南&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;，2008年5月。</target>
        </trans-unit>
        <trans-unit id="73a151d5cd044c04e47c30098a4884b545c7d743" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]    van der Stock, A., Ed., &quot;A Guide to Building Secure Web
              Applications and Web Services&quot;, The Open Web Application
              Security Project (OWASP) 2.0.1, July 2005,
              &amp;lt;&lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999. 

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, &quot;HTTP
              Authentication: Basic and Digest Access Authentication&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4648&quot; name=&quot;ref-RFC4648&quot;&gt;RFC4648&lt;/a&gt;]  Josefsson, S., &quot;The Base16, Base32, and Base64 Data
              Encodings&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;, October 2006.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;, August 2008.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne，G.，Nottingham，M.和J. Mogul，&amp;ldquo;消息头字段的注册过程&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;，2004年9月。[ &lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ] van der Stock，A.，Ed。构建安全Web应用程序和Web服务指南&amp;rdquo;，开放Web应用程序安全性项目（OWASP）2.0.1，2005年7月，&amp;lt; &lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding，R.，Gettys，J.，Mogul，J.，Frystyk，H.，Masinter，L.，Leach，P.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo; ，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;，1999年6月。[ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;] Franks J.，Hallam-Baker P.，Hostetler J.，Lawrence S.，Leach P.，Luotonen A.和L. Stewart，&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC&lt;/a&gt; 1999年6月2617日。[ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee，T.，Fielding，R.和L. Masinter，&amp;ldquo;统一资源标识符（URI）：通用语法&amp;rdquo;，STD 66， &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;，2005年1月。[ &lt;a id=&quot;ref-RFC4648&quot; name=&quot;ref-RFC4648&quot;&gt;RFC4648&lt;/a&gt; ] Josefsson ，S。，&amp;ldquo; Base16，Base32和Base64数据编码&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;，2006年10月。[ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten，T.和H.Alvestrand，&amp;ldquo;在RFC中编写IANA考虑部分的指南&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;，2008年5月。[ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks，T.和E. Rescorla，&amp;ldquo;传输层安全性（TLS）协议版本1.2&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;，2008年8月。</target>
        </trans-unit>
        <trans-unit id="68349d0417ea59a9fce1a54293548f5d71f13c68" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC4918&quot; name=&quot;ref-RFC4918&quot;&gt;RFC4918&lt;/a&gt;]  Dusseault, L., Ed., &quot;HTTP Extensions for Web Distributed
              Authoring and Versioning (WebDAV)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;, June 2007.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne，G.，Nottingham，M.和J. Mogul，&amp;ldquo;消息头字段的注册过程&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;，2004年9月。[ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding，R.，Gettys，J.，Mogul ，J.，Frystyk H.，Masinter L.，Leach P.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;，1999年6月。[ &lt;a id=&quot;ref-RFC4918&quot; name=&quot;ref-RFC4918&quot;&gt;RFC4918&lt;/a&gt; ] Dusseault，L. ，编辑，&amp;ldquo;用于Web分布式创作和版本控制（WebDAV）的HTTP扩展&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;，2007年6月。</target>
        </trans-unit>
        <trans-unit id="de3ead8edc0a72f563112dfbf128ce107b02bbff" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5861&quot; name=&quot;ref-RFC5861&quot;&gt;RFC5861&lt;/a&gt;]  Nottingham, M., &quot;HTTP Cache-Control Extensions for Stale
              Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5861&quot;&gt;RFC 5861&lt;/a&gt;, April 2010.

   [&lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt;]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              &quot;Network Time Protocol Version 4: Protocol and Algorithms
              Specification&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt;, June 2010.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]  Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
              April 2011.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne，G.，Nottingham，M.和J. Mogul，&amp;ldquo;消息头字段的注册过程&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;，2004年9月。[ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding，R.，Gettys，J.，Mogul ，J.，Frystyk H.，Masinter L.，Leach P.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;，1999年6月。[ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten，T。和H. Alvestrand，&amp;ldquo;在RFC中编写IANA考虑部分的指南&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;，2008年5月。[ &lt;a id=&quot;ref-RFC5861&quot; name=&quot;ref-RFC5861&quot;&gt;RFC5861&lt;/a&gt;]诺丁汉，M。，&amp;ldquo;过时内容的HTTP缓存控制扩展&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5861&quot;&gt;RFC 5861&lt;/a&gt;，2010年4月。[ &lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt; ] Mills，D.，Martin，J.，Ed。，Burbank，J.和W. Kasch，&amp;ldquo;网络时间协议版本4：协议和算法规范&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt;，2010年6月。[ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ] Barth，A。，&amp;ldquo; HTTP状态管理机制&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;，2011年4月。</target>
        </trans-unit>
        <trans-unit id="be465035882a640817e7c019d9758fba1f0298fa" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-NOTE-detect-lost-update&quot; name=&quot;ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt;]
              Nielsen, H. and D. LaLiberte, &quot;Editing the Web: Detecting
              the Lost Update Problem Using Unreserved Checkout&quot;, World
              Wide Web Consortium NOTE NOTE-detect-lost-update, May
              1999, &amp;lt;&lt;a href=&quot;http://www.w3.org/1999/04/Editing/&quot;&gt;http://www.w3.org/1999/04/Editing/&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-REC-webarch&quot; name=&quot;ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt;]
              Walsh, N. and I. Jacobs, &quot;Architecture of the World Wide
              Web, Volume One&quot;, W3C REC REC-webarch-20041215, December
              2004, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-webarch-20041215&quot;&gt;http://www.w3.org/TR/2004/REC-webarch-20041215&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RNC&quot; name=&quot;ref-RNC&quot;&gt;RNC&lt;/a&gt;]      Clark, J., &quot;RELAX NG Compact Syntax&quot;, December 2001,
              &amp;lt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;http://www.oasis-open.org/committees/relax-ng/&lt;/a&gt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;compact-20021121.html&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">[ &lt;a id=&quot;ref-NOTE-detect-lost-update&quot; name=&quot;ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt; ] Nielsen，H.和D. LaLiberte，&amp;ldquo;编辑Web：使用未保留的签出检测丢失的更新问题&amp;rdquo;，万维网联盟。NOTE NOTE-detect-lost-update，1999年5月，&amp;lt; &lt;a href=&quot;http://www.w3.org/1999/04/Editing/&quot;&gt;http://www.w3.org/1999/04/Editing/&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-REC-webarch&quot; name=&quot;ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt; ] N. Walsh和I. Jacobs，&amp;ldquo;万维网体系结构，第一卷&amp;rdquo;，W3C REC REC-webarch-20041215，2004年12月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-webarch-20041215&quot;&gt;http://www.w3.org/TR/ 2004 / REC-webarch-20041215&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-RNC&quot; name=&quot;ref-RNC&quot;&gt;RNC&lt;/a&gt; ] Clark，J。，&amp;ldquo; RELAX NG紧凑语法&amp;rdquo;，2001年12月，&amp;lt; &lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;http://www.oasis-open.org/committees/relax-ng/ &lt;/a&gt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;compact-20021121。html&lt;/a&gt;&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="9b0101cca3163bcad6c18b71db53c2de9c25f26c" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-REC-XML&quot; name=&quot;ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]          Bray, T., Paoli, J., Sperberg-McQueen, C., Maler,
                      E., and F. Yergeau, &quot;Extensible Markup Language
                      (XML) 1.0 (Fourth Edition)&quot;, W3C REC-xml-20060816,
                      August 2006,
                      &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816/&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-XML-INFOSET&quot; name=&quot;ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]  Cowan, J. and R. Tobin, &quot;XML Information Set
                      (Second Edition)&quot;, W3C REC-xml-infoset-20040204,
                      February 2004, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;http://www.w3.org/TR/2004/&lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;REC-xml-infoset-20040204/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-XML-NAMES&quot; name=&quot;ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]    Bray, T., Hollander, D., Layman, A., and R. Tobin,
                      &quot;Namespaces in XML 1.0 (Second Edition)&quot;, W3C REC-
                      xml-names-20060816, August 2006, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;http://&lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;www.w3.org/TR/2006/REC-xml-names-20060816/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]          Bradner, S., &quot;Key words for use in RFCs to
                      Indicate Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;,
                      March 1997.

   [&lt;a id=&quot;ref-RFC2277&quot; name=&quot;ref-RFC2277&quot;&gt;RFC2277&lt;/a&gt;]          Alvestrand, H., &quot;IETF Policy on Character Sets and
                      Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt;, January 1998.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]          Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                      Masinter, L., Leach, P., and T. Berners-Lee,
                      &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999. 

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]          Franks, J., Hallam-Baker, P., Hostetler, J.,
                      Lawrence, S., Leach, P., Luotonen, A., and L.
                      Stewart, &quot;HTTP Authentication: Basic and Digest
                      Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC3339&quot; name=&quot;ref-RFC3339&quot;&gt;RFC3339&lt;/a&gt;]          Klyne, G., Ed. and C. Newman, &quot;Date and Time on
                      the Internet: Timestamps&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC 3339&lt;/a&gt;, July 2002.

   [&lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;]          Yergeau, F., &quot;UTF-8, a transformation format of
                      ISO 10646&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt;, November 2003.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]          Berners-Lee, T., Fielding, R., and L. Masinter,
                      &quot;Uniform Resource Identifier (URI): Generic
                      Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4122&quot; name=&quot;ref-RFC4122&quot;&gt;RFC4122&lt;/a&gt;]          Leach, P., Mealling, M., and R. Salz, &quot;A
                      Universally Unique IDentifier (UUID) URN
                      Namespace&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;, July 2005.</source>
          <target state="translated">[ &lt;a id=&quot;ref-REC-XML&quot; name=&quot;ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ] Bray，T.，Paoli，J.，Sperberg-McQueen，C.，Maler，E.和F. Yergeau，&amp;ldquo;可扩展标记语言（XML）1.0（第四版）&amp;rdquo;，W3C REC-xml -20060816，2006年8月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816/&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816/&lt;/a&gt; &amp;gt;。[ &lt;a id=&quot;ref-REC-XML-INFOSET&quot; name=&quot;ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt; ] Cowan，J.和R. Tobin，&amp;ldquo; XML信息集（第二版）&amp;rdquo;，W3C REC-xml-infoset-20040204，2004年2月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;http://www.w3.org/TR / 2004 / &lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;REC-xml-infoset-20040204 /&lt;/a&gt; &amp;gt;。[ &lt;a id=&quot;ref-REC-XML-NAMES&quot; name=&quot;ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;] Bray，T.，Hollander，D.，Layman，A.和R. Tobin，&amp;ldquo; XML 1.0中的命名空间（第二版）&amp;rdquo;，W3C REC-xml-names-20060816，2006年8月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;http：// &lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;www .w3.org / TR / 2006 / REC-xml-names-20060816 /&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner，S.，&amp;ldquo;用于RFC中以指示要求级别的关键字&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-RFC2277&quot; name=&quot;ref-RFC2277&quot;&gt;RFC2277&lt;/a&gt; ] Alvestrand，H。，&amp;ldquo; IETF字符集和语言策略&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt;，1998年1月。[ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;] Fielding，R.，Gettys，J.，Mogul，J.，Frystyk，H.，Masinter，L.，Leach，P.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC&lt;/a&gt; 1999年6月2616日。[ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt; ] Franks，J.，Hallam-Baker，P.，Hostetler，J.，Lawrence，S.，Leach，P.，Luotonen，A.和L. Stewart，&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;，1999年6月。[ &lt;a id=&quot;ref-RFC3339&quot; name=&quot;ref-RFC3339&quot;&gt;RFC3339&lt;/a&gt; ] Klyne，G。，编辑。和C. Newman，&amp;ldquo; Internet上的日期和时间：时间戳记&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC 3339&lt;/a&gt;，2002年7月。[ &lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;] Yergeau，F。，&amp;ldquo; UTF-8，ISO 10646的转换格式&amp;rdquo;，STD 63，&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt;，2003年11月。[ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee，T.，Fielding，R。和L. Masinter，&amp;ldquo;统一资源标识符（URI）：通用语法&amp;rdquo;，STD 66，&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;，2005年1月。[ &lt;a id=&quot;ref-RFC4122&quot; name=&quot;ref-RFC4122&quot;&gt;RFC4122&lt;/a&gt; ] Leach，P.，Mealling，M.和R. Salz，&amp;ldquo;一个通用唯一标识符（UUID）URN命名空间&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;，2005年7月。</target>
        </trans-unit>
        <trans-unit id="f109ae6f660a3e51addf064374205f31f9fc1367" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-REC-xml&quot; name=&quot;ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]  Yergeau, F., Paoli, J., Bray, T., Sperberg-McQueen, C.,
              and E. Maler, &quot;Extensible Markup Language (XML) 1.0
              (Fourth Edition)&quot;, World Wide Web Consortium
              Recommendation REC-xml-20060816, August 2006,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xml-infoset&quot; name=&quot;ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt;]
              Cowan, J. and R. Tobin, &quot;XML Information Set (Second
              Edition)&quot;, World Wide Web Consortium Recommendation REC-
              xml-infoset-20040204, February 2004,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&quot;&gt;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xml-names&quot; name=&quot;ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;]
              Hollander, D., Bray, T., Tobin, R., and A. Layman,
              &quot;Namespaces in XML 1.0 (Second Edition)&quot;, World Wide Web
              Consortium Recommendation REC-xml-names-20060816, August
              2006, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-names-20060816&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmlbase&quot; name=&quot;ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt;]
              Marsh, J., &quot;XML Base&quot;, W3C REC W3C.REC-xmlbase-20010627,
              June 2001,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlbase-20010627&quot;&gt;http://www.w3.org/TR/2001/REC-xmlbase-20010627&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmldsig-core&quot; name=&quot;ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt;]
              Solo, D., Reagle, J., and D. Eastlake, &quot;XML-Signature
              Syntax and Processing&quot;, World Wide Web Consortium
              Recommendation REC-xmldsig-core-20020212, February 2002,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&quot;&gt;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmlenc-core&quot; name=&quot;ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt;]
              Eastlake, D. and J. Reagle, &quot;XML Encryption Syntax and
              Processing&quot;, World Wide Web Consortium Recommendation REC-
              xmlenc-core-20021210, December 2002,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&quot;&gt;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997. 

   [&lt;a id=&quot;ref-RFC2246&quot; name=&quot;ref-RFC2246&quot;&gt;RFC2246&lt;/a&gt;]  Dierks, T. and C. Allen, &quot;The TLS Protocol Version 1.0&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC 2246&lt;/a&gt;, January 1999.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, &quot;HTTP
              Authentication: Basic and Digest Access Authentication&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt;]  Rescorla, E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;]  Murata, M., St. Laurent, S., and D. Kohn, &quot;XML Media
              Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt;, January 2001.

   [&lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;]  Yergeau, F., &quot;UTF-8, a transformation format of ISO
              10646&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt;, November 2003.

   [&lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt;]  Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC3987&quot; name=&quot;ref-RFC3987&quot;&gt;RFC3987&lt;/a&gt;]  Duerst, M. and M. Suignard, &quot;Internationalized Resource
              Identifiers (IRIs)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC 3987&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4287&quot; name=&quot;ref-RFC4287&quot;&gt;RFC4287&lt;/a&gt;]  Nottingham, M. and R. Sayre, &quot;The Atom Syndication
              Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC 4287&lt;/a&gt;, December 2005.

   [&lt;a id=&quot;ref-RFC4288&quot; name=&quot;ref-RFC4288&quot;&gt;RFC4288&lt;/a&gt;]  Freed, N. and J. Klensin, &quot;Media Type Specifications and
              Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC 4288&lt;/a&gt;, December 2005.

   [&lt;a id=&quot;ref-RFC4346&quot; name=&quot;ref-RFC4346&quot;&gt;RFC4346&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC 4346&lt;/a&gt;, April 2006.</source>
          <target state="translated">[ &lt;a id=&quot;ref-REC-xml&quot; name=&quot;ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] Yergeau，F.，Paoli，J.，Bray，T.，Sperberg-McQueen，C.和E. Maler，&amp;ldquo;可扩展标记语言（XML）1.0（第四版）&amp;rdquo;，万维网联盟建议REC-xml-20060816，2006年8月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-REC-xml-infoset&quot; name=&quot;ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt; ] Cowan，J.和R. Tobin，&amp;ldquo; XML信息集（第二版）&amp;rdquo;，万维网联盟建议REC-xml-infoset-20040204，2004年2月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&quot;&gt;http：//www.w3 .org / TR / 2004 / REC-xml-infoset-20040204&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-REC-xml-names&quot; name=&quot;ref-REC-xml-names&quot;&gt;REC-xml-名称&lt;/a&gt;] Hollander，D.，Bray，T.，Tobin，R.和A. Layman，&amp;ldquo; XML 1.0中的命名空间（第二版）&amp;rdquo;，万维网联盟建议REC-xml-names-20060816，2006年8月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816&quot;&gt;http ：//www.w3.org/TR/2006/REC-xml-names-20060816&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-REC-xmlbase&quot; name=&quot;ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt; ] Marsh，J。，&amp;ldquo; XML Base&amp;rdquo;，W3C REC W3C.REC-xmlbase-20010627，2001年6月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlbase-20010627&quot;&gt;http://www.w3.org/TR/2001/REC-xmlbase-20010627&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-REC-xmldsig-core&quot; name=&quot;ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt; ] Solo，D.，Reagle，J.和D. Eastlake，&amp;ldquo; XML签名语法和处理&amp;rdquo;，万维网联盟建议REC-xmldsig-core-20020212，&amp;lt;2002年2月，&amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&quot;&gt;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-REC-xmlenc-core&quot; name=&quot;ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt; ] Eastlake，D.和J. Reagle，&amp;ldquo; XML加密语法和处理&amp;rdquo;，万维网联盟建议REC-xmlenc-core-20021210，2002年12月，&amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&quot;&gt;http://www.w3.org / TR / 2002 / REC-xmlenc-core-20021210&lt;/a&gt; &amp;gt;。 [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner，S.，&amp;ldquo;用于RFC中以指示需求级别的关键词&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-RFC2246&quot; name=&quot;ref-RFC2246&quot;&gt;RFC2246&lt;/a&gt; ] Dierks，T。和C. Allen，&amp;ldquo; TLS协议版本1.0&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC 2246&lt;/a&gt;，1999年1月。[ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;] Fielding，R.，Gettys，J.，Mogul，J.，Frystyk，H.，Masinter，L.，Leach，P.和T. Berners-Lee，&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC&lt;/a&gt; 1999年6月2616日。[ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt; ] Franks，J.，Hallam-Baker，P.，Hostetler，J.，Lawrence，S.，Leach，P.，Luotonen，A.和L. Stewart，&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;，1999年6月。[ &lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt; ] Rescorla，E。，&amp;ldquo; HTTP over TLS&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;，2000年5月。[ &lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt; ] Murata，M。，圣罗兰，S。和D。 Kohn，&amp;ldquo; XML媒体类型&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt;，2001年1月。[ &lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;] Yergeau，F。，&amp;ldquo; UTF-8，ISO 10646的转换格式&amp;rdquo;，STD 63，&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt;，2003年11月。[ &lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt; ] Klyne，G.，Nottingham，M。和J.Mogul，&amp;ldquo;注册程序消息标头字段&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;，2004年9月。[ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee，T.，Fielding，R.和L. Masinter，&amp;ldquo;统一资源标识符（URI）：通用语法&amp;rdquo;，STD 66，&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;3986&lt;/a&gt;，2005年1月。[ &lt;a id=&quot;ref-RFC3987&quot; name=&quot;ref-RFC3987&quot;&gt;RFC3987&lt;/a&gt; ] Duerst，M.和M. Suignard，&amp;ldquo;国际化资源标识符（IRI）&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC 3987&lt;/a&gt;，2005年1月。[ &lt;a id=&quot;ref-RFC4287&quot; name=&quot;ref-RFC4287&quot;&gt;RFC4287&lt;/a&gt;]诺丁汉，M。和R. Sayre，&amp;ldquo;原子联合格式&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC 4287&lt;/a&gt;，2005年12月。[ &lt;a id=&quot;ref-RFC4288&quot; name=&quot;ref-RFC4288&quot;&gt;RFC4288&lt;/a&gt; ] Freed，N。和J. Klensin，&amp;ldquo;媒体类型规范和注册程序&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC 4288&lt;/a&gt;， 2005年12月。[ &lt;a id=&quot;ref-RFC4346&quot; name=&quot;ref-RFC4346&quot;&gt;RFC4346&lt;/a&gt; ] Dierks，T.和E. Rescorla，&amp;ldquo;传输层安全性（TLS）协议版本1.1&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC 4346&lt;/a&gt;，2006年4月。</target>
        </trans-unit>
        <trans-unit id="aa753c7ca1de65f848d19927144998faa06fdb5d" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC0793&quot; name=&quot;ref-RFC0793&quot;&gt;RFC0793&lt;/a&gt;]     Postel, J., &quot;Transmission Control Protocol&quot;, STD 7,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;RFC 793&lt;/a&gt;, September 1981.

   [&lt;a id=&quot;ref-RFC1950&quot; name=&quot;ref-RFC1950&quot;&gt;RFC1950&lt;/a&gt;]     Deutsch, L. and J-L. Gailly, &quot;ZLIB Compressed Data
                 Format Specification version 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC1951&quot; name=&quot;ref-RFC1951&quot;&gt;RFC1951&lt;/a&gt;]     Deutsch, P., &quot;DEFLATE Compressed Data Format
                 Specification version 1.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC1952&quot; name=&quot;ref-RFC1952&quot;&gt;RFC1952&lt;/a&gt;]     Deutsch, P., Gailly, J-L., Adler, M., Deutsch, L., and
                 G. Randers-Pehrson, &quot;GZIP file format specification
                 version 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1952&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]     Bradner, S., &quot;Key words for use in RFCs to Indicate
                 Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]     Berners-Lee, T., Fielding, R., and L. Masinter,
                 &quot;Uniform Resource Identifier (URI): Generic Syntax&quot;,
                 STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]     Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for
                 Syntax Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;,
                 January 2008.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Semantics and Content&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Conditional Requests&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]     Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
                 &quot;Hypertext Transfer Protocol (HTTP/1.1): Range
                 Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
                 Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Authentication&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014. 

   [&lt;a id=&quot;ref-USASCII&quot; name=&quot;ref-USASCII&quot;&gt;USASCII&lt;/a&gt;]     American National Standards Institute, &quot;Coded Character
                 Set -- 7-bit American Standard Code for Information
                 Interchange&quot;, ANSI X3.4, 1986.

   [&lt;a id=&quot;ref-Welch&quot; name=&quot;ref-Welch&quot;&gt;Welch&lt;/a&gt;]       Welch, T., &quot;A Technique for High-Performance Data
                 Compression&quot;, IEEE Computer 17(6), June 1984.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC0793&quot; name=&quot;ref-RFC0793&quot;&gt;RFC0793&lt;/a&gt; ] Postel，J。，&amp;ldquo;传输控制协议&amp;rdquo;，STD 7， &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;RFC 793&lt;/a&gt;，1981年9月。[ &lt;a id=&quot;ref-RFC1950&quot; name=&quot;ref-RFC1950&quot;&gt;RFC1950&lt;/a&gt; ] Deutsch，L。和JL。 Gailly，&amp;ldquo; ZLIB压缩数据格式规范版本3.3&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-RFC1951&quot; name=&quot;ref-RFC1951&quot;&gt;RFC1951&lt;/a&gt; ] Deutsch，P。，&amp;ldquo; DEFLATE压缩数据格式规范版本1.3&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-RFC1952&quot; name=&quot;ref-RFC1952&quot;&gt;RFC1952&lt;/a&gt; ] Deutsch，P。， Gailly，JL。，Adler，M.，Deutsch，L.和G. Randers-Pehrson，&amp;ldquo; GZIP文件格式规范版本4.3&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1952&lt;/a&gt;，1996 年 5月。[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;] Bradner，S.，&amp;ldquo;在RFC中用于指示需求级别的关键字&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee，T.，Fielding，R.和L. Masinter，&amp;ldquo;统一资源标识符（URI）：通用语法&amp;rdquo;，STD 66，&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;，2005年1月。[ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker，D。，编辑。和P. Overell，&amp;ldquo;语法规范的增强型BNF：ABNF&amp;rdquo;，STD 68，&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;，2008年1月。[ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：语义和内容&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding，R.，Ed。 and J. Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：条件请求&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding，R.，Ed。，Lafon，Y.，Ed。和J. Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：范围请求&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding，R.，Ed。，Nottingham，M.，Ed。和J. Reschke，Ed 。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：缓存&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]菲尔丁，R。，编。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：身份验证&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-USASCII&quot; name=&quot;ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ]美国国家标准协会，&amp;ldquo;编码字符集-信息交换的7位美国标准代码&amp;rdquo; &amp;rdquo;，ANSI X3.4，1986年。[ &lt;a id=&quot;ref-Welch&quot; name=&quot;ref-Welch&quot;&gt;Welch&lt;/a&gt; ] Welch，T。，&amp;ldquo;一种用于高性能数据压缩的技术&amp;rdquo;，IEEE Computer 17（6），1984年6月。</target>
        </trans-unit>
        <trans-unit id="32b5eaf10a6f18bbfaf539b485fd4ae12b86c05e" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;,
              November 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997. 

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4647&quot; name=&quot;ref-RFC4647&quot;&gt;RFC4647&lt;/a&gt;]  Phillips, A., Ed. and M. Davis, Ed., &quot;Matching of Language
              Tags&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647&lt;/a&gt;, September 2006.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC5646&quot; name=&quot;ref-RFC5646&quot;&gt;RFC5646&lt;/a&gt;]  Phillips, A., Ed. and M. Davis, Ed., &quot;Tags for Identifying
              Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646&lt;/a&gt;, September 2009.

   [&lt;a id=&quot;ref-RFC6365&quot; name=&quot;ref-RFC6365&quot;&gt;RFC6365&lt;/a&gt;]  Hoffman, P. and J. Klensin, &quot;Terminology Used in
              Internationalization in the IETF&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp166&quot;&gt;BCP 166&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC 6365&lt;/a&gt;,
              September 2011.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt; ] N.和N. Borenstein，Freed，&amp;ldquo;多用途Internet邮件扩展（MIME）第一部分：Internet消息&lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;主体的&lt;/a&gt;格式&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;，1996年11月。[ RFC2046 ] N.和N. Borenstein，Freed，N。and N. Borenstein，&amp;ldquo;多用途Internet邮件扩展（MIME）第二部分：媒体类型&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;，1996年11月。[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner，S.，&amp;ldquo;在RFC中使用以指示需求级别的关键字&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee，T.，Fielding，R.和L. Masinter，&amp;ldquo;统一资源标识符（URI）：通用语法&amp;rdquo;，STD 66， &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;，2005年1月。[ &lt;a id=&quot;ref-RFC4647&quot; name=&quot;ref-RFC4647&quot;&gt;RFC4647&lt;/a&gt; ] Phillips，A。，编辑。和M. Davis编，&amp;ldquo;语言标签的匹配&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647&lt;/a&gt;，2006年9月。[ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker，D。编。和P.Overell，&amp;ldquo;语法规范的增强BNF：ABNF&amp;rdquo;，STD 68，&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;，2008年1月。[ &lt;a id=&quot;ref-RFC5646&quot; name=&quot;ref-RFC5646&quot;&gt;RFC5646&lt;/a&gt; ] Phillips，A。，编辑。 and M. Davis，Ed。，&amp;ldquo;用于识别语言的标签&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646&lt;/a&gt;，2009年9月。[ &lt;a id=&quot;ref-RFC6365&quot; name=&quot;ref-RFC6365&quot;&gt;RFC6365&lt;/a&gt; ] Hoffman，P。和J. Klensin，&amp;ldquo; IETF国际化中使用的术语&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp166&quot;&gt;BCP 166&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC 6365&lt;/a&gt;，2011年9月。[ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding，R.，Ed。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：消息语法和路由&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding，R。，编辑。 and J. Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：条件请求&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding，R.，Ed。，Lafon，Y.，Ed。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：范围请求&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;] Fielding，R.，Ed。，Nottingham，M.，Ed。和J. Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：缓存&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt; ] Fielding，R 。，Ed。和J. Reschke编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：身份验证&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;，2014年6月。</target>
        </trans-unit>
        <trans-unit id="0f97a814186cc03d6a95b38611cc68d637712dec" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;,
              November 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt; ] N.和N. Borenstein，Freed，&amp;ldquo;多用途Internet邮件扩展（MIME）第二部分：媒体类型&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;，1996年11月。[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner，S。，&amp;ldquo;在RFC中使用以指示的关键字要求级别&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker，D。，编辑。和P.Overell，&amp;ldquo;语法规范的增强BNF：ABNF&amp;rdquo;，STD 68，&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;，2008年1月。[ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：消息语法和路由&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding，R.，Ed。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：语义和内容&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding，R。，编辑。 and J. Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：条件请求&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding，R.，Ed。，Nottingham，M.，Ed。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：缓存&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;，2014年6月。</target>
        </trans-unit>
        <trans-unit id="7e13a726cd253b78f479b6c1518755778145f85b" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner，S.，&amp;ldquo;用于RFC中以指示需求级别的关键词&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker，D.，编辑。和P.Overell，&amp;ldquo;语法规范的增强BNF：ABNF&amp;rdquo;，STD 68，&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;，2008年1月。[ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：消息语法和路由&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：语义和内容&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding，R.，Ed。 and J. Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：条件请求&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding，R.，Ed。，Lafon，Y.，Ed。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：范围请求&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：身份验证&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;，2014年6月。</target>
        </trans-unit>
        <trans-unit id="3e9dfb2b3300e3cee5aa29bf83498176e8412766" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner，S.，&amp;ldquo;用于RFC中以指示需求级别的关键词&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker，D.，编辑。和P.Overell，&amp;ldquo;语法规范的增强BNF：ABNF&amp;rdquo;，STD 68，&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;，2008年1月。[ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：消息语法和路由&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：语义和内容&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding，R.，Ed。，Lafon，Y.，Ed。和J. Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：范围请求&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;，2014年6月[ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding，R.，Ed。，Nottingham，M.，Ed。和J.Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：缓存&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;，2014年6月。</target>
        </trans-unit>
        <trans-unit id="b85249b3b7b5758e2386a2ce786a0724059a28d2" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner，S.，&amp;ldquo;用于RFC中以指示需求级别的关键词&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;，1997年3月。[ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker，D.，编辑。和P.Overell，&amp;ldquo;语法规范的增强BNF：ABNF&amp;rdquo;，STD 68，&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;，2008年1月。[ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke，编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：消息语法和路由&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding，R。，编辑。和J. Reschke编辑，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：语义和内容&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;，2014年6月。[ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding，R.，Ed。，Nottingham，M.，Ed。和J. Reschke，Ed。，&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：缓存&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;，2014年6月。</target>
        </trans-unit>
        <trans-unit id="8a4091e2c539cdc5431420dbeb2649f7bc6c3639" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2291&quot; name=&quot;ref-RFC2291&quot;&gt;RFC2291&lt;/a&gt;]          Slein, J., Vitali, F., Whitehead, E., and D.
                      Durand, &quot;Requirements for a Distributed Authoring
                      and Versioning Protocol for the World Wide Web&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC 2291&lt;/a&gt;, February 1998.

   [&lt;a id=&quot;ref-RFC2518&quot; name=&quot;ref-RFC2518&quot;&gt;RFC2518&lt;/a&gt;]          Goland, Y., Whitehead, E., Faizi, A., Carter, S.,
                      and D. Jensen, &quot;HTTP Extensions for Distributed
                      Authoring -- WEBDAV&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, February 1999.

   [&lt;a id=&quot;ref-RFC2781&quot; name=&quot;ref-RFC2781&quot;&gt;RFC2781&lt;/a&gt;]          Hoffman, P. and F. Yergeau, &quot;UTF-16, an encoding
                      of ISO 10646&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC 2781&lt;/a&gt;, February 2000.

   [&lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;]          Murata, M., St. Laurent, S., and D. Kohn, &quot;XML
                      Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt;, January 2001.

   [&lt;a id=&quot;ref-RFC3253&quot; name=&quot;ref-RFC3253&quot;&gt;RFC3253&lt;/a&gt;]          Clemm, G., Amsden, J., Ellison, T., Kaler, C., and
                      J. Whitehead, &quot;Versioning Extensions to WebDAV
                      (Web Distributed Authoring and Versioning)&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC 3253&lt;/a&gt;, March 2002.

   [&lt;a id=&quot;ref-RFC3648&quot; name=&quot;ref-RFC3648&quot;&gt;RFC3648&lt;/a&gt;]          Whitehead, J. and J. Reschke, Ed., &quot;Web
                      Distributed Authoring and Versioning (WebDAV)
                      Ordered Collections Protocol&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC 3648&lt;/a&gt;,
                      December 2003. 

   [&lt;a id=&quot;ref-RFC3744&quot; name=&quot;ref-RFC3744&quot;&gt;RFC3744&lt;/a&gt;]          Clemm, G., Reschke, J., Sedlar, E., and J.
                      Whitehead, &quot;Web Distributed Authoring and
                      Versioning (WebDAV) Access Control Protocol&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC 3744&lt;/a&gt;, May 2004.

   [&lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt;]          Klyne, G., Nottingham, M., and J. Mogul,
                      &quot;Registration Procedures for Message Header
                      Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;, September 2004.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2291&quot; name=&quot;ref-RFC2291&quot;&gt;RFC2291&lt;/a&gt; ] Slein，J.，Vitali，F.，Whitehead，E.和D. Durand，&amp;ldquo;万维网的分布式创作和版本控制协议的要求&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC 2291&lt;/a&gt;，1998年2月。[ &lt;a id=&quot;ref-RFC2518&quot; name=&quot;ref-RFC2518&quot;&gt;RFC2518&lt;/a&gt; ] Goland， Y.，Whitehead，E.，Faizi，A.，Carter，S.和D. Jensen，&amp;ldquo;分布式创作的HTTP扩展-WEBDAV&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;，1999年2月。[ &lt;a id=&quot;ref-RFC2781&quot; name=&quot;ref-RFC2781&quot;&gt;RFC2781&lt;/a&gt; ] Hoffman，P。和F。 Yergeau，&amp;ldquo; UTF-16，ISO 10646的编码&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC 2781&lt;/a&gt;，2000年2月。[ &lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;] Murata，M.，&lt;a id=&quot;ref-RFC3253&quot; name=&quot;ref-RFC3253&quot;&gt;St。Laurent&lt;/a&gt;，S.和D. Kohn，&amp;ldquo; XML Media Types&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt;，2001年1月。[ RFC3253 ] Clemm，G.，Amsden，J.，Ellison，T.，Kaler， C.和J. Whitehead，&amp;ldquo; WebDAV（Web分布式创作和版本控制）的版本扩展&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC 3253&lt;/a&gt;，2002年3月。[ &lt;a id=&quot;ref-RFC3648&quot; name=&quot;ref-RFC3648&quot;&gt;RFC3648&lt;/a&gt; ] Whitehead，J。和J. Reschke编辑，&amp;ldquo; Web分布式创作和版本控制（ WebDAV）&amp;ldquo;有序集合协议&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC 3648&lt;/a&gt;，2003年12月。[ &lt;a id=&quot;ref-RFC3744&quot; name=&quot;ref-RFC3744&quot;&gt;RFC3744&lt;/a&gt;] Clemm，G.，Reschke，J.，Sedlar，E.和J. Whitehead，&amp;ldquo; Web分布式创作和版本控制（WebDAV）访问控制协议&amp;rdquo;， &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC 3744&lt;/a&gt;，2004年5月。[ &lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt; ] Klyne，G.，诺丁汉，M。和J. Mogul，&amp;ldquo;消息标头字段的注册过程&amp;rdquo;，&lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;，2004年9月。</target>
        </trans-unit>
        <trans-unit id="6572f6bdad9d0df526aa9918bcc18d67193d7284" translate="yes" xml:space="preserve">
          <source>a DNS hostname, or IP address. If a hostname is passed, it will be resolved into an IP address by this function.</source>
          <target state="translated">DNS主机名,或IP地址。如果传递了主机名,它将被此函数解析为IP地址。</target>
        </trans-unit>
        <trans-unit id="48b988db0ee3a42e7679e7b91940653ba256252b" translate="yes" xml:space="preserve">
          <source>all other domains</source>
          <target state="translated">其他所有领域</target>
        </trans-unit>
        <trans-unit id="22e784a22acfd6fde3c7f0d8be9a48223288b9a2" translate="yes" xml:space="preserve">
          <source>allowlist</source>
          <target state="translated">allowlist</target>
        </trans-unit>
        <trans-unit id="68346a9baa8533152e1b7183f99e607aa69f9b2d" translate="yes" xml:space="preserve">
          <source>an IP address (v4 or v6, optionally with a port, and ipv6 quoted and enclosed in square brackets),</source>
          <target state="translated">IP地址(v4或v6,可选择端口,ipv6用方括号括起来)。</target>
        </trans-unit>
        <trans-unit id="5b6e0dfcb0f27620edc54f98b71e760a5ef9f363" translate="yes" xml:space="preserve">
          <source>an IP address pattern in the dot-separated format.</source>
          <target state="translated">点分隔格式的IP地址模式。</target>
        </trans-unit>
        <trans-unit id="57c7b5a27584ee2ff2773d5b245085b264d57843" translate="yes" xml:space="preserve">
          <source>an obfuscated identifier (such as &quot;_hidden&quot; or &quot;_secret&quot;),</source>
          <target state="translated">被混淆的标识符(如&quot;_hidden &quot;或&quot;_secret&quot;)。</target>
        </trans-unit>
        <trans-unit id="4e16b4d174e42a23736982e9f2c23c397c8b3108" translate="yes" xml:space="preserve">
          <source>an opaque string, uniquely identifying each version, called the &lt;em&gt;entity tag&lt;/em&gt;, or the &lt;em&gt;etag&lt;/em&gt;.</source>
          <target state="translated">一个不透明的字符串，唯一地标识每个版本，称为&lt;em&gt;实体标签&lt;/em&gt;或&lt;em&gt;etag&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4d46355f32d92f6c77aef67e98124f7e7eef5210" translate="yes" xml:space="preserve">
          <source>an unsecured HTTP request is used and the referring page was received with a secure protocol (HTTPS).</source>
          <target state="translated">使用了不安全的HTTP请求,而引用页面是通过安全协议(HTTPS)接收的。</target>
        </trans-unit>
        <trans-unit id="d51793deecf3874c1379bd483b7f6e8a8697ba77" translate="yes" xml:space="preserve">
          <source>and finally compression can be defined at the connection level, between two nodes of an HTTP connection.</source>
          <target state="translated">最后可以在连接层定义压缩,在一个HTTP连接的两个节点之间。</target>
        </trans-unit>
        <trans-unit id="21ebe7d97514bbc039dd86f94ac3b48072ba7ec0" translate="yes" xml:space="preserve">
          <source>any comma-separated list of HTTP headers [Usually &lt;code&gt;keep-alive&lt;/code&gt; only]</source>
          <target state="translated">任何以逗号分隔的HTTP标头列表[通常仅 &lt;code&gt;keep-alive&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="cc1567ff89b862169db893152a7611218a8a4089" translate="yes" xml:space="preserve">
          <source>any domain or path</source>
          <target state="translated">任意域</target>
        </trans-unit>
        <trans-unit id="10b12d00a7d3c421266b22114a2233f8f8621481" translate="yes" xml:space="preserve">
          <source>application/octet-stream</source>
          <target state="translated">application/octet-stream</target>
        </trans-unit>
        <trans-unit id="69f62b376116281af7e0a09a35dafd577e34f4d2" translate="yes" xml:space="preserve">
          <source>application/vnd.mozilla.xul+xml</source>
          <target state="translated">application/vnd.mozilla.xul+xml</target>
        </trans-unit>
        <trans-unit id="237541aefdcd5b729ae836344478d37315abf73f" translate="yes" xml:space="preserve">
          <source>as well as styles loaded using the &lt;a href=&quot;../link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bff8fa686f39f07445a2245133d217187258035" translate="yes" xml:space="preserve">
          <source>as well as styles loaded using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="translated">以及使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt;标头加载的样式：</target>
        </trans-unit>
        <trans-unit id="fba31ebe5b81e900968e1a2412e72f955f8c8d98" translate="yes" xml:space="preserve">
          <source>authentication (to control access to different resources)</source>
          <target state="translated">认证</target>
        </trans-unit>
        <trans-unit id="b3c23371b391c5c9a5070c1553a367da511602e0" translate="yes" xml:space="preserve">
          <source>authentication headers (e.g., &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">身份验证标头（例如&lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="a8d227a59c970b0e117bb96f0c53db926fe7e2e8" translate="yes" xml:space="preserve">
          <source>base-uri</source>
          <target state="translated">base-uri</target>
        </trans-unit>
        <trans-unit id="ee7f2acefe0b4b10bcc7d341ee436d1050bbc552" translate="yes" xml:space="preserve">
          <source>base64-encoded version of the above</source>
          <target state="translated">以上的基数64编码版本</target>
        </trans-unit>
        <trans-unit id="ca53353f340229b4d6998a703a022cd1a46f2df7" translate="yes" xml:space="preserve">
          <source>block-all-mixed-content</source>
          <target state="translated">block-all-mixed-content</target>
        </trans-unit>
        <trans-unit id="2db8c22f75474a58cd13fa2d3425017015d392ce" translate="yes" xml:space="preserve">
          <source>boundary</source>
          <target state="translated">boundary</target>
        </trans-unit>
        <trans-unit id="1ffcf1d140fe7ea73a2ca4646ab42ba7ff8d6b38" translate="yes" xml:space="preserve">
          <source>by=&amp;lt;identifier&amp;gt;</source>
          <target state="translated">by=&amp;lt;identifier&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5dc29c0a9fefc5d9085157ab99c1395a78cbea28" translate="yes" xml:space="preserve">
          <source>caching (the cache can be public or private, like the browser cache)</source>
          <target state="translated">缓存(缓存可以是公共的,也可以是私有的,就像浏览器缓存一样)</target>
        </trans-unit>
        <trans-unit id="16d8d6392988323b4370d2c819891302accb8e78" translate="yes" xml:space="preserve">
          <source>can be allowed for the base-uri policy:</source>
          <target state="translated">可以允许使用base-uri策略。</target>
        </trans-unit>
        <trans-unit id="1ef5578db8253e578f4a1ad2a317c4cb55a6cccf" translate="yes" xml:space="preserve">
          <source>change the request such that it is a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; that doesn&amp;rsquo;t cause a preflight</source>
          <target state="translated">更改请求，使其成为一个不会导致预检的&lt;a href=&quot;#Simple_requests&quot;&gt;简单请求&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e82b4f907665849edc640a3a5ed3f96746a22ae2" translate="yes" xml:space="preserve">
          <source>change the server-side behavior to avoid the preflight and/or to avoid the redirect&amp;mdash;if you have control over the server the request is being made to</source>
          <target state="translated">更改服务器端的行为以避免预检和/或避免重定向-如果您可以控制服务器，则将请求发送到</target>
        </trans-unit>
        <trans-unit id="dcb16d9aacb079fe42fbde349c3319de8033ddd1" translate="yes" xml:space="preserve">
          <source>charset</source>
          <target state="translated">charset</target>
        </trans-unit>
        <trans-unit id="542878754cbbf01f4429e5bc9fad7e8ebe07d51e" translate="yes" xml:space="preserve">
          <source>charset=&amp;lt;charset&amp;gt;</source>
          <target state="translated">charset=&amp;lt;charset&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7624bec80c979807575ec0892f7c6ef4c15f3111" translate="yes" xml:space="preserve">
          <source>child-src</source>
          <target state="translated">child-src</target>
        </trans-unit>
        <trans-unit id="92425df92f162ed857653d72abf9032f6f8e9a9c" translate="yes" xml:space="preserve">
          <source>connect-src</source>
          <target state="translated">connect-src</target>
        </trans-unit>
        <trans-unit id="d59c684e865aae3fcb98cb7011c041b7d231fe6b" translate="yes" xml:space="preserve">
          <source>convert_addr()</source>
          <target state="translated">convert_addr()</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="7b1dafbb0ae29e20baea414f4e68f00b46dc7817" translate="yes" xml:space="preserve">
          <source>data URL scheme</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26dd63ae4093a12d5fe3831767a9965a0355f13a" translate="yes" xml:space="preserve">
          <source>dateRange()</source>
          <target state="translated">dateRange()</target>
        </trans-unit>
        <trans-unit id="a2620cbc10f5198dd03e3f5a1569eb5dcf9a6a87" translate="yes" xml:space="preserve">
          <source>day</source>
          <target state="translated">day</target>
        </trans-unit>
        <trans-unit id="b1d2728d4d92be98cbe896a012245baeb3b5eba5" translate="yes" xml:space="preserve">
          <source>default-src</source>
          <target state="translated">default-src</target>
        </trans-unit>
        <trans-unit id="086b515d51ae4e83ef03faf2897557b0b2354560" translate="yes" xml:space="preserve">
          <source>dnsDomainIs()</source>
          <target state="translated">dnsDomainIs()</target>
        </trans-unit>
        <trans-unit id="d991b834071c9fd3f1c23defce92bbd9aff7f292" translate="yes" xml:space="preserve">
          <source>dnsDomainLevels()</source>
          <target state="translated">dnsDomainLevels()</target>
        </trans-unit>
        <trans-unit id="2b1bb3ec04c8f96d11d4fe26e461b302f090b32c" translate="yes" xml:space="preserve">
          <source>dnsResolve()</source>
          <target state="translated">dnsResolve()</target>
        </trans-unit>
        <trans-unit id="7b93f412c5cc61a7c2e57c97d5cfb718feaca8ba" translate="yes" xml:space="preserve">
          <source>document-domain</source>
          <target state="translated">document-domain</target>
        </trans-unit>
        <trans-unit id="9120580e94f134cb7c9f27cd1e43dbc82980e152" translate="yes" xml:space="preserve">
          <source>domain</source>
          <target state="translated">domain</target>
        </trans-unit>
        <trans-unit id="f1a6172df5508823225ab8bb7fe65a2481016827" translate="yes" xml:space="preserve">
          <source>donottrack.us</source>
          <target state="translated">donottrack.us</target>
        </trans-unit>
        <trans-unit id="40472cae6e0922cdfa8a50845b56a80a1aecab0d" translate="yes" xml:space="preserve">
          <source>draft-ietf-httpbis-rfc6265bis-02</source>
          <target state="translated">draft-ietf-httpbis-rfc6265bis-02</target>
        </trans-unit>
        <trans-unit id="696609a189535007707b4c972a02ca3abcc6c153" translate="yes" xml:space="preserve">
          <source>draft-ietf-httpbis-rfc6265bis-05</source>
          <target state="translated">draft-ietf-httpbis-rfc6265bis-05</target>
        </trans-unit>
        <trans-unit id="10ced556502ccd9ea6cab04a4c6c560574f5619b" translate="yes" xml:space="preserve">
          <source>effective-directive</source>
          <target state="translated">effective-directive</target>
        </trans-unit>
        <trans-unit id="8ed7f834df2e6a2e9619cf288468a7001e5e45c1" translate="yes" xml:space="preserve">
          <source>enforce Optional</source>
          <target state="translated">强制执行《任择议定书》</target>
        </trans-unit>
        <trans-unit id="971c419dd609331343dee105fffd0f4608dc0bf2" translate="yes" xml:space="preserve">
          <source>file</source>
          <target state="translated">file</target>
        </trans-unit>
        <trans-unit id="bab8f5421577f88a13806c827f40340044f3f46f" translate="yes" xml:space="preserve">
          <source>filename*</source>
          <target state="translated">filename*</target>
        </trans-unit>
        <trans-unit id="f35c166cd0c65005849ff35d7c0cde54422c0eec" translate="yes" xml:space="preserve">
          <source>filtering (like an antivirus scan or parental controls)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d66faaa0ea10fa0468840dffa09e321853ecb14" translate="yes" xml:space="preserve">
          <source>filtering (like an antivirus scan, parental controls, &amp;hellip;)</source>
          <target state="translated">过滤（例如防病毒扫描，父母控制等等）</target>
        </trans-unit>
        <trans-unit id="77ed03a5bd46ed473f79db47d3471ca6396e13b9" translate="yes" xml:space="preserve">
          <source>first some file formats are compressed with specific optimized methods,</source>
          <target state="translated">首先有些文件格式是用特定的优化方法压缩的。</target>
        </trans-unit>
        <trans-unit id="9b3734e0d856c513f33ee96559374347af0ab6d5" translate="yes" xml:space="preserve">
          <source>font-src</source>
          <target state="translated">font-src</target>
        </trans-unit>
        <trans-unit id="bb84ce39411e03bf6e940d04850c70c9cf4c5af8" translate="yes" xml:space="preserve">
          <source>for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; methods, like &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, which usually tries to fetch a document, the conditional request can be used to send back the document, if relevant only. Therefore, this spares bandwidth.</source>
          <target state="translated">对于通常尝试获取文档的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全&lt;/a&gt;方法（例如&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; )&lt;/a&gt;，可以使用条件请求（仅当相关时）来发回文档。因此，这可以节省带宽。</target>
        </trans-unit>
        <trans-unit id="107d7bfa1273d29412288a73d8e3da9310bf0cc4" translate="yes" xml:space="preserve">
          <source>for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;unsafe&lt;/a&gt; methods, like &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, which usually uploads a document, the conditional request can be used to upload the document, only if the original it is based on is the same as that stored on the server.</source>
          <target state="translated">对于通常上传文档的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;不安全&lt;/a&gt;方法（例如&lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; )&lt;/a&gt;，只有原始文档所基于的条件与服务器上存储的条件相同，才可以使用条件请求来上传文档。</target>
        </trans-unit>
        <trans-unit id="39c530df8a00ccde8bbcb7f14958e0a8b1db8387" translate="yes" xml:space="preserve">
          <source>for=&amp;lt;identifier&amp;gt;</source>
          <target state="translated">for=&amp;lt;identifier&amp;gt;</target>
        </trans-unit>
        <trans-unit id="462d902515185bbf061ed6e7ad4435aad289c286" translate="yes" xml:space="preserve">
          <source>forceEnable&quot; boolean preferece in about:config.</source>
          <target state="translated">forceEnable&quot; boolean preferece in about:config.</target>
        </trans-unit>
        <trans-unit id="f58edcd721fab51d42650b7e6dd010b57980c7f4" translate="yes" xml:space="preserve">
          <source>form-action</source>
          <target state="translated">form-action</target>
        </trans-unit>
        <trans-unit id="ad1ceea2126038a2417f75852c0eaec4fbbe1b44" translate="yes" xml:space="preserve">
          <source>frame-ancestors</source>
          <target state="translated">frame-ancestors</target>
        </trans-unit>
        <trans-unit id="958a17ea17afdc7c73cc1fc1522e81267bf9656e" translate="yes" xml:space="preserve">
          <source>frame-src</source>
          <target state="translated">frame-src</target>
        </trans-unit>
        <trans-unit id="84e21b7649de2b838a3b5ec55c4b65501cf35eed" translate="yes" xml:space="preserve">
          <source>from Firefox 10 on mobile, &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; is the same as &lt;code&gt;&lt;var&gt;firefoxversion&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">从Firefox 10移动版开始， &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;var&gt;firefoxversion&lt;/var&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="7616bb87bd05f6439e3672ba1b2be55d5beb68b3" translate="yes" xml:space="preserve">
          <source>ftp</source>
          <target state="translated">ftp</target>
        </trans-unit>
        <trans-unit id="1f6d1f05bf03ff30afa6123e0bee2caa2da7cff0" translate="yes" xml:space="preserve">
          <source>gmt</source>
          <target state="translated">gmt</target>
        </trans-unit>
        <trans-unit id="86dd1cf45142e904cb2e99c2721fac3ca198c6ca" translate="yes" xml:space="preserve">
          <source>host</source>
          <target state="translated">host</target>
        </trans-unit>
        <trans-unit id="5f9c88b1b1fe6f524893937345305084a9e1041d" translate="yes" xml:space="preserve">
          <source>host=&amp;lt;host&amp;gt;</source>
          <target state="translated">host=&amp;lt;host&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f980c193395f072f33f35ad30af29c86b869a5aa" translate="yes" xml:space="preserve">
          <source>hostdom</source>
          <target state="translated">hostdom</target>
        </trans-unit>
        <trans-unit id="13dda6d8bc46f099d3816621f1bb02058b8d6263" translate="yes" xml:space="preserve">
          <source>hostname to resolve.</source>
          <target state="translated">要解析的主机名。</target>
        </trans-unit>
        <trans-unit id="813070b0844d4518de154f433d86fb302949e0a5" translate="yes" xml:space="preserve">
          <source>hot stand-by</source>
          <target state="translated">热备用</target>
        </trans-unit>
        <trans-unit id="52ab86a87214a453d9f82538264f190854915247" translate="yes" xml:space="preserve">
          <source>hour</source>
          <target state="translated">hour</target>
        </trans-unit>
        <trans-unit id="2c763e6b7d79d93a2a3f3058f224485412fd92cb" translate="yes" xml:space="preserve">
          <source>http/https</source>
          <target state="translated">http/https</target>
        </trans-unit>
        <trans-unit id="cdbe72fa2d6000f2454e1c431b4cd76a6fb92ce1" translate="yes" xml:space="preserve">
          <source>iCalendar format</source>
          <target state="translated">iCalendar格式</target>
        </trans-unit>
        <trans-unit id="285ee276a061f3e61631c19895f00dd8d96a145d" translate="yes" xml:space="preserve">
          <source>iOS Safari</source>
          <target state="translated">iOS Safari</target>
        </trans-unit>
        <trans-unit id="849bb725b8563d0596db868195344c611a893724" translate="yes" xml:space="preserve">
          <source>iPad</source>
          <target state="translated">iPad</target>
        </trans-unit>
        <trans-unit id="97f2142cbb711918707b621ea05cbd1662b714ab" translate="yes" xml:space="preserve">
          <source>iPhone</source>
          <target state="translated">iPhone</target>
        </trans-unit>
        <trans-unit id="31e978dda11713a96454c3a1a463212be069c7d2" translate="yes" xml:space="preserve">
          <source>iPod</source>
          <target state="translated">iPod</target>
        </trans-unit>
        <trans-unit id="b6a64338df2eb5baeb40c41185176db2cb96a5ea" translate="yes" xml:space="preserve">
          <source>identifies the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">识别客户端用于连接到代理或负载平衡器的协议(HTTP或HTTPS)。</target>
        </trans-unit>
        <trans-unit id="20cf626f392079bf9c59553682f4711426d9607e" translate="yes" xml:space="preserve">
          <source>iframe attributes can selectively enable features in certain frames, and not in others, even if those frames contain documents from the same origin.</source>
          <target state="translated">iframe属性可以有选择地在某些框架中启用功能,而在其他框架中不启用,即使这些框架包含来自同一来源的文档。</target>
        </trans-unit>
        <trans-unit id="8ae465c269b02e088bfef75f7203c824c084624e" translate="yes" xml:space="preserve">
          <source>img-src</source>
          <target state="translated">img-src</target>
        </trans-unit>
        <trans-unit id="137adf5541157c6a883d8b1755b3d0a08e52db57" translate="yes" xml:space="preserve">
          <source>indicates the size of the entity-body, in decimal number of octets, sent to the recipient.</source>
          <target state="translated">表示发送至接收方的实体主体的大小,以十进制八位数为单位。</target>
        </trans-unit>
        <trans-unit id="4659c378675fe9020c682803cee1ebb988347f95" translate="yes" xml:space="preserve">
          <source>ipaddr</source>
          <target state="translated">ipaddr</target>
        </trans-unit>
        <trans-unit id="3a8dc0b686296fa059f02e66967fc351233d71ba" translate="yes" xml:space="preserve">
          <source>is a shell expression to compare against.</source>
          <target state="translated">是一个shell表达式,用来比较。</target>
        </trans-unit>
        <trans-unit id="711f0a4bb1c1c9f8a02a7c34c906fd912a25d9d4" translate="yes" xml:space="preserve">
          <source>is any string to compare (e.g. the URL, or the hostname).</source>
          <target state="translated">是任何要比较的字符串(如URL,或主机名)。</target>
        </trans-unit>
        <trans-unit id="35bb75f385320807a1b2ab6899c56afe7b2b3abc" translate="yes" xml:space="preserve">
          <source>is the hostname from the URL.</source>
          <target state="translated">是URL中的主机名。</target>
        </trans-unit>
        <trans-unit id="6628b382993974f4a5cbca2c9b1c1c013ebe9b61" translate="yes" xml:space="preserve">
          <source>is the same as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6de35d4682e9a8b14fba6347dcda04a75b0292" translate="yes" xml:space="preserve">
          <source>isInNet()</source>
          <target state="translated">isInNet()</target>
        </trans-unit>
        <trans-unit id="ee9fbe440c9f9cb0fddd58b1a68cf267199af430" translate="yes" xml:space="preserve">
          <source>isPlainHostName()</source>
          <target state="translated">isPlainHostName()</target>
        </trans-unit>
        <trans-unit id="9fa99c6eb1219edba6fb50a9c8f60e235c2a1b47" translate="yes" xml:space="preserve">
          <source>isResolvable()</source>
          <target state="translated">isResolvable()</target>
        </trans-unit>
        <trans-unit id="b6e13ad53d8ec41b034c49f131c64e99cf25207a" translate="yes" xml:space="preserve">
          <source>javascript</source>
          <target state="translated">javascript</target>
        </trans-unit>
        <trans-unit id="7dc0a5e593f649f492088fe836b1065b44a4d240" translate="yes" xml:space="preserve">
          <source>load balancing (to allow multiple servers to serve the different requests)</source>
          <target state="translated">负载均衡(允许多个服务器服务于不同的请求)</target>
        </trans-unit>
        <trans-unit id="bf90de10d16d33f1ebf146ed81ce2d44a651f670" translate="yes" xml:space="preserve">
          <source>localHostOrDomainIs()</source>
          <target state="translated">localHostOrDomainIs()</target>
        </trans-unit>
        <trans-unit id="f6a2e9d539c4d8c290c040adbe4d56f58a242d54" translate="yes" xml:space="preserve">
          <source>localStorage (executes &lt;code&gt;localStorage.clear&lt;/code&gt;),</source>
          <target state="translated">localStorage（执行 &lt;code&gt;localStorage.clear&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="07b91ff33236baae20bbe53abf2a67f00e3c50fb" translate="yes" xml:space="preserve">
          <source>logging (allowing the storage of historical information)</source>
          <target state="translated">伐木</target>
        </trans-unit>
        <trans-unit id="fe710cd089cb0ba74f588270fe079a392b5e9810" translate="yes" xml:space="preserve">
          <source>mailto</source>
          <target state="translated">mailto</target>
        </trans-unit>
        <trans-unit id="b6b13a0ea86ed568a571ab17aeb46d6c1e820468" translate="yes" xml:space="preserve">
          <source>manifest-src</source>
          <target state="translated">manifest-src</target>
        </trans-unit>
        <trans-unit id="9d4cca1595c30e43d23f14aedf815846f837956a" translate="yes" xml:space="preserve">
          <source>mask</source>
          <target state="translated">mask</target>
        </trans-unit>
        <trans-unit id="10d3ad09751e1c3d8c873feea6420bc613cceed5" translate="yes" xml:space="preserve">
          <source>mask for the IP address pattern informing which parts of the IP address should be matched against. 0 means ignore, 255 means match.</source>
          <target state="translated">IP地址模式的掩码,告知应与IP地址的哪些部分进行匹配。0表示忽略,255表示匹配。</target>
        </trans-unit>
        <trans-unit id="28e1c849b6dc898fca0424e31a6995a480cd4f2d" translate="yes" xml:space="preserve">
          <source>max-age</source>
          <target state="translated">max-age</target>
        </trans-unit>
        <trans-unit id="9ac6a36fa13e10d8a3e0e393b6ca9fd66644c093" translate="yes" xml:space="preserve">
          <source>max-age=&amp;lt;expire-time&amp;gt;</source>
          <target state="translated">max-age=&amp;lt;expire-time&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a29bfccdab1c88eed654fe261827d16fb5b5a4b6" translate="yes" xml:space="preserve">
          <source>media-src</source>
          <target state="translated">media-src</target>
        </trans-unit>
        <trans-unit id="483fccd23acd857fcb20f316a053e85dbb71d17d" translate="yes" xml:space="preserve">
          <source>message framing headers (e.g., &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">消息框架头（例如，&lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="b6c935d4f3c7b220fa038613a1f9c1b56b255a86" translate="yes" xml:space="preserve">
          <source>min</source>
          <target state="translated">min</target>
        </trans-unit>
        <trans-unit id="021710fa7866431c1dacaa6cd31eeeb47dce64b6" translate="yes" xml:space="preserve">
          <source>month</source>
          <target state="translated">month</target>
        </trans-unit>
        <trans-unit id="7bf875f389edb2f955a35fd6a689ecbee26de3a2" translate="yes" xml:space="preserve">
          <source>multipart/byteranges</source>
          <target state="translated">multipart/byteranges</target>
        </trans-unit>
        <trans-unit id="12a22dd81cc700d0a382226b74ce386ec575a16a" translate="yes" xml:space="preserve">
          <source>multipart/form-data</source>
          <target state="translated">multipart/form-data</target>
        </trans-unit>
        <trans-unit id="98cb9df8eaa28e53ece0f85d650859e51d70ed53" translate="yes" xml:space="preserve">
          <source>myIpAddress()</source>
          <target state="translated">myIpAddress()</target>
        </trans-unit>
        <trans-unit id="48b9986d88eb74e0d3a4acb3cdad7ac0e26c3cc7" translate="yes" xml:space="preserve">
          <source>myIpAddress() returns the same IP address as the server address returned by &lt;code&gt;nslookup localhost&lt;/code&gt;on a Linux machine. It does not return the public IP address.</source>
          <target state="translated">myIpAddress（）返回与Linux计算机上 &lt;code&gt;nslookup localhost&lt;/code&gt; 返回的服务器地址相同的IP地址。它不返回公共IP地址。</target>
        </trans-unit>
        <trans-unit id="64bdcd6a063ffe53f20c5fc8a2a977b0e42bfbde" translate="yes" xml:space="preserve">
          <source>namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;

    pubControl =
       element app:control {
       atomCommonAttributes,
       pubDraft?
       &amp;amp; extensionElement
    }

    pubDraft =
      element app:draft { &quot;yes&quot; | &quot;no&quot; } 

   The &quot;app:control&quot; element MAY appear as a child of an atom:entry that
   is being created or updated via the Atom Publishing Protocol.  The
   app:control element MUST appear only once in an Entry.  The app:
   control element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6
   of [RFC4287]&lt;/a&gt;.

   The app:control element and its child elements MAY be included in
   Atom Feed or Entry Documents.

   The app:control element can contain an &quot;app:draft&quot; element as defined
   below, and it can contain extension elements as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6
   of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">名称空间app =&amp;ldquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;rdquo; pubControl =元素app：control {atomCommonAttributes，pubDraft？ ＆extensionElement} pubDraft =元素app：draft {&amp;ldquo;是&amp;rdquo; | &amp;ldquo; app：control&amp;rdquo;元素可以显示为通过Atom发布协议创建或更新的atom：entry的子级。 app：control元素必须在条目中仅出现一次。如&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]的第6节&lt;/a&gt;所定义，app：控件元素被视为外部标记。 app：control元素及其子元素可以包含在Atom Feed或条目文档中。 app：control元素可以包含以下定义的&amp;ldquo; app：draft&amp;rdquo;元素，并且它可以包含扩展元素，如&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]的第6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd1286353570c5703799ba76999323b7c7447b06" translate="yes" xml:space="preserve">
          <source>no</source>
          <target state="translated">no</target>
        </trans-unit>
        <trans-unit id="c93bee6c522b9224a267a0391c4dd9d6634f5e43" translate="yes" xml:space="preserve">
          <source>no referrer</source>
          <target state="translated">无介绍人</target>
        </trans-unit>
        <trans-unit id="73182f77ad56a5ab7236d9553832d35ecf5bbcdd" translate="yes" xml:space="preserve">
          <source>no-cache</source>
          <target state="translated">no-cache</target>
        </trans-unit>
        <trans-unit id="4f70f2f74568eb871171ef25b64e2369fbd0b561" translate="yes" xml:space="preserve">
          <source>no-referrer</source>
          <target state="translated">no-referrer</target>
        </trans-unit>
        <trans-unit id="70ef900efd9d989c7461278efc15fc8b7dd95d38" translate="yes" xml:space="preserve">
          <source>no-referrer-when-downgrade (default)</source>
          <target state="translated">降级时不推荐人(默认)</target>
        </trans-unit>
        <trans-unit id="9fe350a67b2e91ed9cf66de96117752e35a2720e" translate="yes" xml:space="preserve">
          <source>no-store
      The purpose of the no-store directive is to prevent the
      inadvertent release or retention of sensitive information (for
      example, on backup tapes). The no-store directive applies to the
      entire message, and MAY be sent either in a response or in a
      request. If sent in a request, a cache MUST NOT store any part of
      either this request or any response to it. If sent in a response,
      a cache MUST NOT store any part of either this response or the
      request that elicited it. This directive applies to both non-
      shared and shared caches. &quot;MUST NOT store&quot; in this context means
      that the cache MUST NOT intentionally store the information in
      non-volatile storage, and MUST make a best-effort attempt to
      remove the information from volatile storage as promptly as
      possible after forwarding it.

      Even when this directive is associated with a response, users
      might explicitly store such a response outside of the caching
      system (e.g., with a &quot;Save As&quot; dialog). History buffers MAY store
      such responses as part of their normal operation. 

      The purpose of this directive is to meet the stated requirements
      of certain users and service authors who are concerned about
      accidental releases of information via unanticipated accesses to
      cache data structures. While the use of this directive might
      improve privacy in some cases, we caution that it is NOT in any
      way a reliable or sufficient mechanism for ensuring privacy. In
      particular, malicious or compromised caches might not recognize or
      obey this directive, and communications networks might be
      vulnerable to eavesdropping.</source>
          <target state="translated">no-store 不存储指令的目的是为了防止敏感信息被无意中释放或保留(例如,在备份磁带上)。不存储指令适用于整个消息,可以在响应或请求中发送。如果在请求中发送,缓存必须不存储该请求或任何响应的任何部分。如果以响应的方式发送,缓存必须不存储这个响应的任何部分或引起它的请求的任何部分。这条指令适用于非共享和共享缓存。&quot;MUST NOT存储 &quot;在此上下文中意味着缓存MUST NOT有意将信息存储在非易失性存储中,并且在转发信息后必须尽最大努力尽快从易失性存储中删除信息。即使该指令与响应相关联,用户也可能在缓存系统之外明确地存储这样的响应(例如,使用 &quot;另存为 &quot;对话框)。历史缓冲区可以作为其正常操作的一部分来存储这样的响应。此指令的目的是为了满足某些用户和服务作者的要求,他们担心通过对缓存数据结构的意外访问意外发布信息。虽然在某些情况下,使用该指令可能会改善隐私,但我们警告说,它在任何情况下都不是确保隐私的可靠或充分机制。特别是,恶意的或被破坏的缓存可能不承认或不遵守这个指令,通信网络可能容易被窃听。</target>
        </trans-unit>
        <trans-unit id="8dd61e2fa66eb6e428ffe8c41835e97bcabf006f" translate="yes" xml:space="preserve">
          <source>no-transform
      Implementors of intermediate caches (proxies) have found it useful
      to convert the media type of certain entity bodies. A non-
      transparent proxy might, for example, convert between image
      formats in order to save cache space or to reduce the amount of
      traffic on a slow link.

      Serious operational problems occur, however, when these
      transformations are applied to entity bodies intended for certain
      kinds of applications. For example, applications for medical 

      imaging, scientific data analysis and those using end-to-end
      authentication, all depend on receiving an entity body that is bit
      for bit identical to the original entity-body.

      Therefore, if a message includes the no-transform directive, an
      intermediate cache or proxy MUST NOT change those headers that are
      listed in &lt;a href=&quot;#section-13.5.2&quot;&gt;section 13.5.2&lt;/a&gt; as being subject to the no-transform
      directive. This implies that the cache or proxy MUST NOT change
      any aspect of the entity-body that is specified by these headers,
      including the value of the entity-body itself.</source>
          <target state="translated">中间缓存（代理）的无变换实现者发现，转换某些实体主体的媒体类型很有用。例如，非透明代理可能会在图像格式之间进行转换，以节省缓存空间或减少慢速链接上的流量。但是，当将这些转换应用于旨在用于某些类型应用程序的实体时，会出现严重的操作问题。例如，医学成像，科学数据分析的应用程序以及使用端到端身份验证的应用程序都依赖于接收与原始实体主体一点一点相同的实体主体。因此，如果消息中包含no-transform指令，中间缓存或代理不得更改以下列出的标头&lt;a href=&quot;#section-13.5.2&quot;&gt;第13.5.2节&lt;/a&gt;规定必须遵守no-transform指令。这意味着高速缓存或代理不得改变这些标头指定的实体的任何方面，包括实体本身的值。</target>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="fe59c8ff1d1a5825d27abedb911d923c444e21fe" translate="yes" xml:space="preserve">
          <source>object-src</source>
          <target state="translated">object-src</target>
        </trans-unit>
        <trans-unit id="da7a68734367828e30b94927f4c2b43ed2c0f652" translate="yes" xml:space="preserve">
          <source>off</source>
          <target state="translated">off</target>
        </trans-unit>
        <trans-unit id="db3d405b10675998c030223177d42e71b4e7a312" translate="yes" xml:space="preserve">
          <source>on</source>
          <target state="translated">on</target>
        </trans-unit>
        <trans-unit id="aea30f37abb10330bc8c614a352e1b917c6470e6" translate="yes" xml:space="preserve">
          <source>or &quot;unknown&quot; when the preceding entity is not known (and you still want to indicate that forwarding of the request was made).</source>
          <target state="translated">或 &quot;未知&quot;,当前一个实体不知道时(您仍想表明请求已被转发)。</target>
        </trans-unit>
        <trans-unit id="7c3999b951f94fc202bf0c9012a820f7a5eff095" translate="yes" xml:space="preserve">
          <source>or &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Trailer&lt;/code&gt; itself.</source>
          <target state="translated">或&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;Trailer&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="9049ae3b863750d81d00f3a5864d3d31c54d47b5" translate="yes" xml:space="preserve">
          <source>or when the server is under attack by a client attempting to exploit potential security holes.</source>
          <target state="translated">或当服务器受到客户端试图利用潜在安全漏洞的攻击时。</target>
        </trans-unit>
        <trans-unit id="b284f94827db1fa2970d9e2014f080413b547a7e" translate="yes" xml:space="preserve">
          <source>origin</source>
          <target state="translated">origin</target>
        </trans-unit>
        <trans-unit id="f15e7af6aa8bcd559fe830043261245629c7cc18" translate="yes" xml:space="preserve">
          <source>origin-when-cross-origin</source>
          <target state="translated">origin-when-cross-origin</target>
        </trans-unit>
        <trans-unit id="91cc2e927b3bfb1d4477b744f7c70221ddb86ef1" translate="yes" xml:space="preserve">
          <source>pattern</source>
          <target state="translated">pattern</target>
        </trans-unit>
        <trans-unit id="78082cd56114be30da891d5687edab8b3c2d66ba" translate="yes" xml:space="preserve">
          <source>plugin-types</source>
          <target state="translated">plugin-types</target>
        </trans-unit>
        <trans-unit id="5576aae4fb0ff352046d4e1fb53e4531ff81712d" translate="yes" xml:space="preserve">
          <source>proto=&amp;lt;http|https&amp;gt;</source>
          <target state="translated">proto=&amp;lt;http|https&amp;gt;</target>
        </trans-unit>
        <trans-unit id="22ea1c649c82946aa6e479e1ffd321e4a318b1b0" translate="yes" xml:space="preserve">
          <source>q</source>
          <target state="translated">q</target>
        </trans-unit>
        <trans-unit id="02452ff4ff23b459e2e73cedf36140315f00f994" translate="yes" xml:space="preserve">
          <source>realm=&amp;lt;realm&amp;gt;</source>
          <target state="translated">realm=&amp;lt;realm&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ac18ba11d3f1181e7517c3c4f6c8a7eeb0f126a" translate="yes" xml:space="preserve">
          <source>referrer</source>
          <target state="translated">referrer</target>
        </trans-unit>
        <trans-unit id="db8a2cc6922c7b13291841838739062ba64da02f" translate="yes" xml:space="preserve">
          <source>report-to</source>
          <target state="translated">report-to</target>
        </trans-unit>
        <trans-unit id="16e8e5b1a2982629f65e6c928be748b7f6b42e81" translate="yes" xml:space="preserve">
          <source>report-uri</source>
          <target state="translated">report-uri</target>
        </trans-unit>
        <trans-unit id="ed9af1e0f74b3e9a43e1fe4d187f13988917ceb6" translate="yes" xml:space="preserve">
          <source>report-uri=&quot;&amp;lt;uri&amp;gt;&quot; Optional</source>
          <target state="translated">report-uri =&amp;ldquo; &amp;lt;uri&amp;gt;&amp;rdquo;可选</target>
        </trans-unit>
        <trans-unit id="6c9e448138869437822e431ba846f0b6bec8887b" translate="yes" xml:space="preserve">
          <source>request modifiers (e.g., controls and conditionals, like &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">请求修饰符（例如，控件和条件，例如&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="2fd8c6d6d1cdada1adf7fbc60eb9cd537414faf0" translate="yes" xml:space="preserve">
          <source>require-sri-for</source>
          <target state="translated">require-sri-for</target>
        </trans-unit>
        <trans-unit id="3ec5852b014415f50f8994ebc739d27e5be55fc8" translate="yes" xml:space="preserve">
          <source>resource: is Firefox only.</source>
          <target state="translated">资源:仅限火狐浏览器。</target>
        </trans-unit>
        <trans-unit id="904246d4e0ad39b5566db7faad5522ab88629fc8" translate="yes" xml:space="preserve">
          <source>resource: is not defined in any specification.</source>
          <target state="translated">资源:在任何规范中都没有定义。</target>
        </trans-unit>
        <trans-unit id="ee7b24ec063b1d39218a7097c3d66d0c03d45aab" translate="yes" xml:space="preserve">
          <source>routing headers (e.g., &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">路由标头（例如&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="b4e44716dbbf57be3dae2f819d96795a85d06652" translate="yes" xml:space="preserve">
          <source>same-origin</source>
          <target state="translated">same-origin</target>
        </trans-unit>
        <trans-unit id="9ed037b84943c4caa3a520e48a5540181c46c98c" translate="yes" xml:space="preserve">
          <source>sandbox</source>
          <target state="translated">sandbox</target>
        </trans-unit>
        <trans-unit id="3f82a2a461031d4f91afa1274fe48be5b4859c90" translate="yes" xml:space="preserve">
          <source>script-src</source>
          <target state="translated">script-src</target>
        </trans-unit>
        <trans-unit id="920a25ef686c4f7ca6ad23dd109d3ad653161832" translate="yes" xml:space="preserve">
          <source>sec</source>
          <target state="translated">sec</target>
        </trans-unit>
        <trans-unit id="faadae9badfb659aba69d03dbcb89e27a87212ac" translate="yes" xml:space="preserve">
          <source>sessionStorage (executes &lt;code&gt;sessionStorage.clear&lt;/code&gt;),</source>
          <target state="translated">sessionStorage（执行 &lt;code&gt;sessionStorage.clear&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="8110b865d3f7a38f0f0c8d17482913d907e30a41" translate="yes" xml:space="preserve">
          <source>shExpMatch()</source>
          <target state="translated">shExpMatch()</target>
        </trans-unit>
        <trans-unit id="5e301926272bef4fd5df71996b8f60ecc87be92b" translate="yes" xml:space="preserve">
          <source>shexp</source>
          <target state="translated">shexp</target>
        </trans-unit>
        <trans-unit id="828d338a9b04221c9cbe286f50cd389f68de4ecf" translate="yes" xml:space="preserve">
          <source>source</source>
          <target state="translated">source</target>
        </trans-unit>
        <trans-unit id="bce16dd0260827ecf338c787f1206f77860cacc5" translate="yes" xml:space="preserve">
          <source>sources</source>
          <target state="translated">sources</target>
        </trans-unit>
        <trans-unit id="e8b9f665f844bf5da8294a1282fd740a4b17d2a6" translate="yes" xml:space="preserve">
          <source>ssh</source>
          <target state="translated">ssh</target>
        </trans-unit>
        <trans-unit id="3ee173eae5ff5a2d95c7d9eee5a022866ac1d8a0" translate="yes" xml:space="preserve">
          <source>stale-if-error</source>
          <target state="translated">stale-if-error</target>
        </trans-unit>
        <trans-unit id="3442496b96dd01591a8cd44b1eec1368ab728aba" translate="yes" xml:space="preserve">
          <source>str</source>
          <target state="translated">str</target>
        </trans-unit>
        <trans-unit id="39bcb856a1233e31adf544a5830ca93db3b6cd40" translate="yes" xml:space="preserve">
          <source>strict-dynamic</source>
          <target state="translated">strict-dynamic</target>
        </trans-unit>
        <trans-unit id="69c4c5d9ab7b46419b9dd7c14c639c45e5c98fbc" translate="yes" xml:space="preserve">
          <source>strict-origin</source>
          <target state="translated">strict-origin</target>
        </trans-unit>
        <trans-unit id="8a862f20e750cb73a3c4e7d58cca1decb78087b7" translate="yes" xml:space="preserve">
          <source>strict-origin-when-cross-origin</source>
          <target state="translated">strict-origin-when-cross-origin</target>
        </trans-unit>
        <trans-unit id="a69927cfe4b777ac30b5615098bdb59a0ffecb00" translate="yes" xml:space="preserve">
          <source>style-src</source>
          <target state="translated">style-src</target>
        </trans-unit>
        <trans-unit id="cc4c96facde9ef9579c33b6d5473fc4e3feb23bb" translate="yes" xml:space="preserve">
          <source>tel</source>
          <target state="translated">tel</target>
        </trans-unit>
        <trans-unit id="3b01d3ebd10b89a1117c003d909ee9b795730f20" translate="yes" xml:space="preserve">
          <source>telephone</source>
          <target state="translated">telephone</target>
        </trans-unit>
        <trans-unit id="56e2a9f5c50f89339365495e90569bbc839f7473" translate="yes" xml:space="preserve">
          <source>text/css</source>
          <target state="translated">text/css</target>
        </trans-unit>
        <trans-unit id="010acb220a9c2c8c0ee63a1c3a50f915bed739bc" translate="yes" xml:space="preserve">
          <source>text/html</source>
          <target state="translated">text/html</target>
        </trans-unit>
        <trans-unit id="f919d9f152904f6c40db36d416df4901ff69eaa0" translate="yes" xml:space="preserve">
          <source>text/plain</source>
          <target state="translated">text/plain</target>
        </trans-unit>
        <trans-unit id="fcbd9140f62ce9e1bff1b08caa7b6e4989991639" translate="yes" xml:space="preserve">
          <source>the HTTP protocol version</source>
          <target state="translated">HTTP协议版本</target>
        </trans-unit>
        <trans-unit id="834b665c2d26fa1848fa0366da509e1120558403" translate="yes" xml:space="preserve">
          <source>the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.</source>
          <target state="translated">IETF规范7230,超文本传输协议(HTTP/1.1)。消息语法和路由。</target>
        </trans-unit>
        <trans-unit id="ca3648ddbb8ef94ec160c5cf3dadb9f1a7b069a5" translate="yes" xml:space="preserve">
          <source>the book Nineteen Eighty-Four by George Orwell,</source>
          <target state="translated">乔治-奥威尔的《一九八四》一书。</target>
        </trans-unit>
        <trans-unit id="e5577fe93428a6ebf166c59f91b76cdd97f2d947" translate="yes" xml:space="preserve">
          <source>the date of last modification of the document, the &lt;em&gt;last-modified&lt;/em&gt; date.</source>
          <target state="translated">文档的&lt;em&gt;最后修改&lt;/em&gt;日期，即&lt;em&gt;最后修改&lt;/em&gt;日期。</target>
        </trans-unit>
        <trans-unit id="5bdf6c9b9600d50a2caba66d0f436ceb74b141fb" translate="yes" xml:space="preserve">
          <source>the declared type does not match one of specified types in the &lt;code&gt;plugin-types&lt;/code&gt; directive,</source>
          <target state="translated">声明的类型与 &lt;code&gt;plugin-types&lt;/code&gt; 指令中指定的类型之一不匹配，</target>
        </trans-unit>
        <trans-unit id="f5bc1a085176aeaa42eece5f0bc700a3c0ead360" translate="yes" xml:space="preserve">
          <source>the domain name of the server (for virtual hosting).</source>
          <target state="translated">服务器的域名(用于虚拟主机)。</target>
        </trans-unit>
        <trans-unit id="4e45e35d9c495396c0ff91a341f11e6470af2942" translate="yes" xml:space="preserve">
          <source>the element to load does not declare a valid MIME type,</source>
          <target state="translated">要加载的元素没有声明一个有效的MIME类型。</target>
        </trans-unit>
        <trans-unit id="0613e7970e123f067d9fc91be46be68bbebfac43" translate="yes" xml:space="preserve">
          <source>the fetched resource does not match the declared type.</source>
          <target state="translated">获取的资源不符合声明的类型。</target>
        </trans-unit>
        <trans-unit id="35bca49c0b588b270d7870a552e28ce42f495d97" translate="yes" xml:space="preserve">
          <source>the following script is blocked and won't be loaded or executed:</source>
          <target state="translated">以下脚本被屏蔽,无法加载或执行。</target>
        </trans-unit>
        <trans-unit id="46595ae815e949f9ccd5a7a60da356563667824c" translate="yes" xml:space="preserve">
          <source>the following stylesheets are blocked and won't load:</source>
          <target state="translated">以下样式表被屏蔽,无法加载。</target>
        </trans-unit>
        <trans-unit id="cce6b26755360a8f56e660b44564e5d1492e4498" translate="yes" xml:space="preserve">
          <source>the path of the document, i.e. an absolute URL without the protocol or domain name</source>
          <target state="translated">文件的路径,即一个不含协议或域名的绝对URL。</target>
        </trans-unit>
        <trans-unit id="a125642013a78025c6dc1c812d7784ec8c9efd5d" translate="yes" xml:space="preserve">
          <source>the referring resource is a local &quot;file&quot; or &quot;data&quot; URI,</source>
          <target state="translated">引用资源是一个本地的 &quot;文件 &quot;或 &quot;数据 &quot;URI。</target>
        </trans-unit>
        <trans-unit id="565f7f6174bbd09fcb5308490e8e9f6612ca9595" translate="yes" xml:space="preserve">
          <source>then general encryption can happen at the HTTP level (the resource is transmitted compressed from end to end),</source>
          <target state="translated">那么一般的加密可以发生在HTTP层面(资源从端到端压缩传输)。</target>
        </trans-unit>
        <trans-unit id="e8ad0956f6a10cdd51bfe4f85fd25912878e665f" translate="yes" xml:space="preserve">
          <source>timeRange()</source>
          <target state="translated">timeRange()</target>
        </trans-unit>
        <trans-unit id="fdd74bdda1023be7c42ab41eb84f64531d0846b4" translate="yes" xml:space="preserve">
          <source>trailers</source>
          <target state="translated">trailers</target>
        </trans-unit>
        <trans-unit id="5ffe533b830f08a0326348a9160afafc8ada44db" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>
        </trans-unit>
        <trans-unit id="9c0978b58597587aa5b55de75fadb6f9093b3bd4" translate="yes" xml:space="preserve">
          <source>unsafe-url</source>
          <target state="translated">unsafe-url</target>
        </trans-unit>
        <trans-unit id="b33cb04ebd3cdadd1aeb5e81ecaeea899d7a3393" translate="yes" xml:space="preserve">
          <source>upgrade-insecure-requests</source>
          <target state="translated">upgrade-insecure-requests</target>
        </trans-unit>
        <trans-unit id="81736358b1645103ae83247b10c5f82af641ddfc" translate="yes" xml:space="preserve">
          <source>url</source>
          <target state="translated">url</target>
        </trans-unit>
        <trans-unit id="b4fbf013919b2cce60a03d4bbe39f2706dc37e06" translate="yes" xml:space="preserve">
          <source>urn</source>
          <target state="translated">urn</target>
        </trans-unit>
        <trans-unit id="1f5327f2352ef7b1f1b876f346c5bbb680a4c2d5" translate="yes" xml:space="preserve">
          <source>v1.1</source>
          <target state="translated">v1.1</target>
        </trans-unit>
        <trans-unit id="e93161848c09c7aa679a6171da3705db378223e7" translate="yes" xml:space="preserve">
          <source>v3.0</source>
          <target state="translated">v3.0</target>
        </trans-unit>
        <trans-unit id="9c99bc69e3a5c0c3968bad4188f883287fc7ad80" translate="yes" xml:space="preserve">
          <source>view-source</source>
          <target state="translated">view-source</target>
        </trans-unit>
        <trans-unit id="99f011705ed86a683afa79366cf7c5e249099cc6" translate="yes" xml:space="preserve">
          <source>wd1 and wd2</source>
          <target state="translated">wd1和wd2</target>
        </trans-unit>
        <trans-unit id="6c03a1b31371ba66a9b1fe45e5e1d6d826f72412" translate="yes" xml:space="preserve">
          <source>weekdayRange()</source>
          <target state="translated">weekdayRange()</target>
        </trans-unit>
        <trans-unit id="ef398c9cb054596ac18d63a2b4ac04f547c30e83" translate="yes" xml:space="preserve">
          <source>when a client has improperly converted a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request with long query information,</source>
          <target state="translated">当客户端将查询请求信息不正确的&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求转换为&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;请求时，</target>
        </trans-unit>
        <trans-unit id="e78f3c4320c633a180f739e552d98e82d2df26fb" translate="yes" xml:space="preserve">
          <source>when the client has descended into a loop of redirection (for example, a redirected URI prefix that points to a suffix of itself),</source>
          <target state="translated">当客户端进入重定向的循环(例如,重定向的URI前缀指向自己的后缀)。</target>
        </trans-unit>
        <trans-unit id="5b303e5a989fa1e2ccb9a667883bda27da57a397" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;policy-directive&amp;gt;&lt;/code&gt; consists of: &lt;code&gt;&amp;lt;directive&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; with no internal punctuation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773c160f129adf6e625d6ce76db69d1a8471728f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;referrer-policy&amp;gt;&lt;/code&gt; can be one of the following values:</source>
          <target state="translated">其中， &lt;code&gt;&amp;lt;referrer-policy&amp;gt;&lt;/code&gt; 可以是以下值之一：</target>
        </trans-unit>
        <trans-unit id="d488f59d749ba9458ba76f4742f735ac2b6168af" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; can optionally be one of the following values:</source>
          <target state="translated">其中， &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 可以是以下值之一：</target>
        </trans-unit>
        <trans-unit id="a3dd7b31f7bdeaaa2cf5536534301410a606a911" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;responseTime&lt;/code&gt; is the time at which the response was received according to the browser.</source>
          <target state="translated">其中 &lt;code&gt;responseTime&lt;/code&gt; 是根据浏览器收到响应的时间。</target>
        </trans-unit>
        <trans-unit id="aac3546247ce5d86e97752180ca56a5ab36799af" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;responseTime&lt;/code&gt; is the time at which the response was received according to the browser. For more information see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): 4.2.2. Calculating Heuristic Freshness&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590f28ad9bc49430eab2e507419f281ee9795369" translate="yes" xml:space="preserve">
          <source>while Chrome will display:</source>
          <target state="translated">而Chrome浏览器将显示。</target>
        </trans-unit>
        <trans-unit id="d2dd615236b7f4609e0fcaab6fbb72ec0d8c88a9" translate="yes" xml:space="preserve">
          <source>will act like &lt;code&gt;'unsafe-inline' https:&lt;/code&gt; in browsers that support CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; in browsers that support CSP2, and &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; in browsers that support CSP3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec44f50f9e2adfdab15b700641eeb5edc1a3bb9" translate="yes" xml:space="preserve">
          <source>will act like&lt;code&gt;'unsafe-inline' https:&lt;/code&gt; in browsers that support CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; in browsers that support CSP2, and &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; in browsers that support CSP3.</source>
          <target state="translated">在支持CSP1的浏览器中将像 &lt;code&gt;'unsafe-inline' https:&lt;/code&gt; inline'https :，在支持CSP2的浏览器中像 &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; 在支持CSP3的浏览器中是 &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; abcdefg''strict -dynamic'。</target>
        </trans-unit>
        <trans-unit id="359146c2c0b7d880d78f123c47dec4aa164a5ce6" translate="yes" xml:space="preserve">
          <source>will allow to load flash objects:</source>
          <target state="translated">将允许加载flash对象。</target>
        </trans-unit>
        <trans-unit id="5246145bb3df8bcca397eda2448c3a0611835895" translate="yes" xml:space="preserve">
          <source>will be the same as:</source>
          <target state="translated">将与。</target>
        </trans-unit>
        <trans-unit id="561de84cc0d956b931b695e8e2431c1aa23812d2" translate="yes" xml:space="preserve">
          <source>will send this message:</source>
          <target state="translated">将发送此消息。</target>
        </trans-unit>
        <trans-unit id="754446b96fd5ff1ef295c19f7de2c8d1ec26d7f3" translate="yes" xml:space="preserve">
          <source>window.navigator.userAgent</source>
          <target state="translated">window.navigator.userAgent</target>
        </trans-unit>
        <trans-unit id="24c24db3d7a8c4f896163208864ed8cd2a48cf29" translate="yes" xml:space="preserve">
          <source>worker-src</source>
          <target state="translated">worker-src</target>
        </trans-unit>
        <trans-unit id="ce824584424244041990b810ac0e5f0b0dbf2319" translate="yes" xml:space="preserve">
          <source>ws/wss</source>
          <target state="translated">ws/wss</target>
        </trans-unit>
        <trans-unit id="4ff0b1538469338a0073e2cdaab6a517801b6ab4" translate="yes" xml:space="preserve">
          <source>year</source>
          <target state="translated">year</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="2e6411b0e9dcf17f3b4cb3384aeddeb300439036" translate="yes" xml:space="preserve">
          <source>yes, with the additional restriction that values can only be &lt;code&gt;0-9&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, space or &lt;code&gt;*,-.;=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aced22ca673a8fdd9d2db6167a812ccc095c3e8" translate="yes" xml:space="preserve">
          <source>yes, with the additional restriction that values can't contain a &lt;em&gt;CORS-unsafe request header byte&lt;/em&gt;: 0x00-0x1F (except 0x09 (HT)), &lt;code&gt;&quot;():&amp;lt;&amp;gt;?@[\]{}&lt;/code&gt;, and 0x7F (DEL).</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
