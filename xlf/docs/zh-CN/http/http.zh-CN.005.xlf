<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="5cfd05af6cff4f10fa13fcdf1e53531e0f64c32a" translate="yes" xml:space="preserve">
          <source>HTTP request message routing is determined by each client based on
   the target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the
   client.</source>
          <target state="translated">HTTP请求消息路由由每个客户端根据目标资源、客户端的代理配置以及建立或重用入站连接来决定。相应的响应路由按照相同的连接链回到客户端。</target>
        </trans-unit>
        <trans-unit id="2c8a5e9aaefc55ae6f8b58628a6a46daf09140bd" translate="yes" xml:space="preserve">
          <source>HTTP request methods</source>
          <target state="translated">HTTP请求方法</target>
        </trans-unit>
        <trans-unit id="13dd6cb8837a7e513f219955d516b3e87a62005c" translate="yes" xml:space="preserve">
          <source>HTTP requests are messages sent by the client to initiate an action on the server. Their &lt;em&gt;start-line&lt;/em&gt; contain three elements:</source>
          <target state="translated">HTTP请求是客户端发送的消息，用于在服务器上启动操作。它们的&lt;em&gt;起始行&lt;/em&gt;包含三个元素：</target>
        </trans-unit>
        <trans-unit id="914464e25e17836661d23d43c1739c512c319a50" translate="yes" xml:space="preserve">
          <source>HTTP requests, and responses, share similar structure and are composed of:</source>
          <target state="translated">HTTP请求和响应,有着相似的结构,由以下几部分组成。</target>
        </trans-unit>
        <trans-unit id="baed8872df40013bfa5b06f559f07e0a29344282" translate="yes" xml:space="preserve">
          <source>HTTP response codes indicate whether a specific HTTP request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirections, client errors, and servers errors.</source>
          <target state="translated">HTTP响应代码表示特定的HTTP请求是否已经成功完成。响应分为五类:信息响应、成功响应、重定向、客户端错误和服务器错误。</target>
        </trans-unit>
        <trans-unit id="0e68989f0a2de628c6a35155870120ca03c2f18a" translate="yes" xml:space="preserve">
          <source>HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">HTTP响应头字段指示用户代理为一个原点存储报告端点。</target>
        </trans-unit>
        <trans-unit id="9bae5d05ad944fb1e294a99bcffd4e35229e257f" translate="yes" xml:space="preserve">
          <source>HTTP response status codes</source>
          <target state="translated">HTTP响应状态码</target>
        </trans-unit>
        <trans-unit id="b57d1200b41d22a049735dbac8f54f4cf988cf0d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes:</source>
          <target state="translated">HTTP响应状态代码指示特定的&lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt;请求是否已成功完成。响应分为五类：</target>
        </trans-unit>
        <trans-unit id="0c76e508f304e725a4ab9639fbe06b8e54f58b4d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirects, client errors, and servers errors. Status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;.</source>
          <target state="translated">HTTP响应状态代码指示特定的&lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt;请求是否已成功完成。响应分为五类：信息响应，成功响应，重定向，客户端错误和服务器错误。状态代码由&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;RFC 2616的第10节&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="b5a6f42d4f42646541a1cb9ef004b15fc1e9d233" translate="yes" xml:space="preserve">
          <source>HTTP retrieval requests using conditional or unconditional GET
   methods MAY request one or more sub-ranges of the entity, instead of
   the entire entity, using the Range request header, which applies to
   the entity returned as the result of the request:

      Range = &quot;Range&quot; &quot;:&quot; ranges-specifier 

   A server MAY ignore the Range header. However, HTTP/1.1 origin
   servers and intermediate caches ought to support byte ranges when
   possible, since Range supports efficient recovery from partially
   failed transfers, and supports efficient partial retrieval of large
   entities.

   If the server supports the Range header and the specified range or
   ranges are appropriate for the entity:

      - The presence of a Range header in an unconditional GET modifies
        what is returned if the GET is otherwise successful. In other
        words, the response carries a status code of 206 (Partial
        Content) instead of 200 (OK).

      - The presence of a Range header in a conditional GET (a request
        using one or both of If-Modified-Since and If-None-Match, or
        one or both of If-Unmodified-Since and If-Match) modifies what
        is returned if the GET is otherwise successful and the
        condition is true. It does not affect the 304 (Not Modified)
        response returned if the conditional is false.

   In some cases, it might be more appropriate to use the If-Range
   header (see &lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) in addition to the Range header.

   If a proxy that supports ranges receives a Range request, forwards
   the request to an inbound server, and receives an entire entity in
   reply, it SHOULD only return the requested range to its client. It
   SHOULD store the entire received response in its cache if that is
   consistent with its cache allocation policies.</source>
          <target state="translated">使用条件或无条件GET方法的HTTP检索请求可以使用Range请求标头，而不是整个实体，请求实体的一个或多个子范围，该范围适用于作为请求结果返回的实体：Range =&amp;ldquo; Range &amp;ldquo;&amp;rdquo;：&amp;ldquo; ranges-specifier服务器可以忽略Range标头。但是，HTTP / 1.1源服务器和中间缓存应尽可能支持字节范围，因为Range支持从部分失败的传输中进行有效恢复，并支持大型实体的有效部分检索。如果服务器支持Range标头，并且指定的范围适用于该实体：-如果GET成功，则无条件GET中存在Range标头会修改返回的内容。换句话说，响应中携带的状态码为206（部分内容），而不是200（确定）。 -条件GET中存在Range标头（使用If-Modified-Since和If-None-Match中的一个或两个，或者使用If-Unmodified-Since和If-Match中的一个或两个的请求）修改返回的内容如果GET成功，则条件为true。如果条件为假，它不会影响返回的304（未修改）响应。在某些情况下，使用If-Range标头可能更合适（请参见如果GET成功，且条件为true，则If-Unmodified-Since和If-Match中的一个或两个都将修改返回的内容。如果条件为假，它不会影响返回的304（未修改）响应。在某些情况下，使用If-Range标头可能更合适（请参见如果GET成功，且条件为true，则If-Unmodified-Since和If-Match中的一个或两个都将修改返回的内容。如果条件为假，它不会影响返回的304（未修改）响应。在某些情况下，使用If-Range标头可能更合适（请参见&lt;a href=&quot;#section-14.27&quot;&gt;第14.27节&lt;/a&gt;）以及Range标头。如果支持范围的代理接收到一个范围请求，将该请求转发到入站服务器，并收到整个实体作为回应，则它应该只将请求的范围返回给它的客户端。如果应该将整个接收到的响应与其缓存分配策略一致，则应将其存储在其缓存中。</target>
        </trans-unit>
        <trans-unit id="764bdb74b95275c85a8d7aa1fe3fe82d3d5e9d0f" translate="yes" xml:space="preserve">
          <source>HTTP status: &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/202&quot;&gt;&lt;code&gt;202&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">HTTP状态：&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/202&quot;&gt; &lt;code&gt;202&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e2aaa2653ba0ee26b576dfaebf0854b040cb7a" translate="yes" xml:space="preserve">
          <source>HTTP tunneling</source>
          <target state="translated">HTTP隧道</target>
        </trans-unit>
        <trans-unit id="269219e381ce4221eb783ce2498c82ac2c3eba0d" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet Media Types [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;] in the Content-Type (&lt;a href=&quot;#section-14.17&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;) header fields in order to provide
   open and extensible data typing and type negotiation.

       media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
       type           = token
       subtype        = token

   Parameters MAY follow the type/subtype in the form of attribute/value
   pairs (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

   The type, subtype, and parameter attribute names are case-
   insensitive. Parameter values might or might not be case-sensitive,
   depending on the semantics of the parameter name. Linear white space
   (LWS) MUST NOT be used between the type and subtype, nor between an
   attribute and its value. The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry. 

   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations SHOULD only use media type parameters when they are
   required by that type/subtype definition.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). The media type registration process is
   outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]. Use of non-registered media types is
   discouraged.</source>
          <target state="translated">HTTP 在Content-Type（&lt;a href=&quot;#section-14.17&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17 &lt;/a&gt;节）和Accept（&lt;a href=&quot;#section-14.1&quot;&gt;第14.1节&lt;/a&gt;）标头字段中使用Internet媒体类型[ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]，以提供开放的和可扩展的数据类型以及类型协商。 media-type =类型&amp;ldquo; /&amp;rdquo;子类型*（&amp;ldquo;;&amp;rdquo;参数）type =标记子类型=标记参数可以属性/值对的形式遵循类型/子类型（如&lt;a href=&quot;#section-3.6&quot;&gt;3.6节中&lt;/a&gt;所定义））。类型，子类型和参数属性名称不区分大小写。参数值可能区分大小写，也可能不区分大小写，具体取决于参数名称的语义。不能在类型和子类型之间，属性及其值之间使用线性空格（LWS）。参数的存在与否对媒体类型的处理可能很重要，具体取决于媒体类型注册表中的参数定义。请注意，某些较旧的HTTP应用程序无法识别媒体类型参数。在将数据发送到较旧的HTTP应用程序时，实现应仅在该类型/子类型定义要求使用媒体类型参数时使用。媒体类型值已向互联网号码分配机构（IANA [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]）。&lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]中概述了媒体类型注册过程。不鼓励使用未注册的媒体类型。</target>
        </trans-unit>
        <trans-unit id="b80bb07a4e60213a6bb04971b80d505cc84d5109" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet media types [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] in the Content-Type
   (&lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;) header fields in order
   to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.

     media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
     type       = token
     subtype    = token

   The type/subtype MAY be followed by parameters in the form of
   name=value pairs.

     parameter      = token &quot;=&quot; ( token / quoted-string ) 

   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on
   the semantics of the parameter name.  The presence or absence of a
   parameter might be significant to the processing of a media-type,
   depending on its definition within the media type registry.

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string.  The quoted
   and unquoted values are equivalent.  For example, the following
   examples are all equivalent, but the first is preferred for
   consistency:

     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset=&quot;utf-8&quot;
     text/html; charset=&quot;utf-8&quot;

   Internet media types ought to be registered with IANA according to
   the procedures defined in [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;].

      Note: Unlike some similar constructs in other header fields, media
      type parameters do not allow whitespace (even &quot;bad&quot; whitespace)
      around the &quot;=&quot; character.</source>
          <target state="translated">HTTP 在Content-Type（&lt;a href=&quot;#section-3.1.1.5&quot;&gt;第3.1.1.5节&lt;/a&gt;）和Accept（&lt;a href=&quot;#section-5.3.2&quot;&gt;第5.3.2 &lt;/a&gt;节）中使用Internet媒体类型[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]）标头字段，以提供开放且可扩展的数据类型输入和类型协商。媒体类型定义了数据格式和各种处理模型：如何根据接收数据的每个上下文来处理数据。媒体类型=类型&amp;ldquo; /&amp;rdquo;子类型*（OWS&amp;ldquo;;&amp;rdquo; OWS参数）类型=标记子类型=标记类型/子类型后可以跟着名称=值对形式的参数。 parameter =令牌&amp;ldquo; =&amp;rdquo;（token / quoted-string）类型，子类型和参数名称令牌不区分大小写。参数值可能区分大小写，也可能不区分大小写，具体取决于参数名称的语义。参数的存在与否对于媒体类型的处理可能很重要，取决于其在媒体类型注册表中的定义。与令牌产生匹配的参数值可以作为令牌或在带引号的字符串中传输。带引号和不带引号的值是等效的。例如，以下示例都是等效的，但为了保持一致性，首选第一个示例：text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset =&amp;ldquo; utf-8&amp;rdquo; text / html ; charset =&amp;ldquo; utf-8&amp;rdquo; Internet媒体类型应根据[但为了保持一致性，首选第一个：text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset =&amp;ldquo; utf-8&amp;rdquo; text / html; charset =&amp;ldquo; utf-8&amp;rdquo; Internet媒体类型应根据[但为了保持一致性，首选第一个：text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset =&amp;ldquo; utf-8&amp;rdquo; text / html; charset =&amp;ldquo; utf-8&amp;rdquo; Internet媒体类型应根据[&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]。注意：与其他标头字段中的某些类似构造不同，媒体类型参数不允许在&amp;ldquo; =&amp;rdquo;字符周围使用空格（甚至是&amp;ldquo;坏&amp;rdquo;空格）。</target>
        </trans-unit>
        <trans-unit id="aa6f0f90fa306d4b1ed46d12bd83446d94bb910c" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol.  This specification defines version &quot;1.1&quot;.  The
   protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification of HTTP. 

   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message.  HTTP-version is case-sensitive.

     HTTP-version  = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
     HTTP-name     = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive

   The HTTP version number consists of two decimal digits separated by a
   &quot;.&quot; (period or decimal point).  The first digit (&quot;major version&quot;)
   indicates the HTTP messaging syntax, whereas the second digit (&quot;minor
   version&quot;) indicates the highest minor version within that major
   version to which the sender is conformant and able to understand for
   future communication.  The minor version advertises the sender's
   communication capabilities even when the sender is only using a
   backwards-compatible subset of the protocol, thereby letting the
   recipient know that more advanced features can be used in response
   (by servers) or in future requests (by clients).

   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]
   or a recipient whose version is unknown, the HTTP/1.1 message is
   constructed such that it can be interpreted as a valid HTTP/1.0
   message if all of the newer features are ignored.  This specification
   places recipient-version requirements on some new features so that a
   conformant sender will only use compatible features until it has
   determined, through configuration or the receipt of a message, that
   the recipient supports HTTP/1.1.

   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default behavior
   of a recipient in the absence of such a field can change.  Unless
   specified otherwise, header fields defined in HTTP/1.1 are defined
   for all versions of HTTP/1.x.  In particular, the Host and Connection
   header fields ought to be implemented by all HTTP/1.x implementations
   whether or not they advertise conformance with HTTP/1.1.

   New header fields can be introduced without changing the protocol
   version if their defined semantics allow them to be safely ignored by
   recipients that do not recognize them.  Header field extensibility is
   discussed in &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;.

   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) MUST send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to
   blindly forward the first line of an HTTP message without ensuring
   that the protocol version in that message matches a version to which
   that intermediary is conformant for both the receiving and sending of
   messages.  Forwarding an HTTP message without rewriting the 

   HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what
   features are safe to use for later communication with that sender.

   A client SHOULD send a request version equal to the highest version
   to which the client is conformant and whose major version is no
   higher than the highest version supported by the server, if this is
   known.  A client MUST NOT send a version to which it is not
   conformant.

   A client MAY send a lower request version if it is known that the
   server incorrectly implements the HTTP specification, but only after
   the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., Server) that
   the server improperly handles higher request versions.

   A server SHOULD send a response version equal to the highest version
   to which the server is conformant that has a major version less than
   or equal to the one received in the request.  A server MUST NOT send
   a version to which it is not conformant.  A server can send a 505
   (HTTP Version Not Supported) response if it wishes, for any reason,
   to refuse service of the client's major protocol version.

   A server MAY send an HTTP/1.0 response to a request if it is known or
   suspected that the client incorrectly implements the HTTP
   specification and is incapable of correctly processing later version
   responses, such as when a client fails to parse the version number
   correctly or when an intermediary is known to blindly forward the
   HTTP-version even when it doesn't conform to the given minor version
   of the protocol.  Such protocol downgrades SHOULD NOT be performed
   unless triggered by specific client attributes, such as when one or
   more of the request header fields (e.g., User-Agent) uniquely match
   the values sent by a client known to be in error.

   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.
   However, the minor version was not incremented for the changes
   introduced between [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], and this revision has
   specifically avoided any such changes to the protocol.

   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient SHOULD process the message as if
   it were in the highest minor version within that major version to
   which the recipient is conformant.  A recipient can assume that a 

   message with a higher minor version, when sent to a recipient that
   has not yet indicated support for that higher version, is
   sufficiently backwards-compatible to be safely processed by any
   implementation of the same major version.</source>
          <target state="translated">HTTP使用&amp;ldquo; &amp;lt;major&amp;gt;。&amp;lt;minor&amp;gt;&amp;rdquo;编号方案来指示协议的版本。该规范定义了版本&amp;ldquo; 1.1&amp;rdquo;。总体而言，协议版本指示发送方是否符合该版本的相应HTTP规范中列出的一组要求。 HTTP消息的版本由消息第一行中的HTTP版本字段指示。 HTTP版本区分大小写。 HTTP版本= HTTP名称&amp;ldquo; /&amp;rdquo; DIGIT&amp;ldquo;。 DIGIT HTTP名称=％x48.54.54.50; &amp;ldquo; HTTP&amp;rdquo;，区分大小写HTTP版本号由两个小数点组成，中间用&amp;ldquo;。&amp;rdquo;分隔。 （句点或小数点）。第一位数字（&amp;ldquo;主要版本&amp;rdquo;）表示HTTP消息传递语法，而第二个数字（&amp;ldquo;次要版本&amp;rdquo;）表示发件人符合并能够理解以供将来通信的那个主要版本中的最高次要版本。即使发件人仅使用协议的向后兼容子集，次版本也可以通告该发件人的通信功能，从而使收件人知道可以在响应（服务器）或将来的请求（客户端）中使用更多高级功能。 。当HTTP / 1.1消息发送到HTTP / 1.0收件人时[即使发送方仅使用协议的向后兼容子集，也具有通信能力，从而使接收方知道可以在响应（服务器）或将来的请求（客户端）中使用更多高级功能。当HTTP / 1.1消息发送到HTTP / 1.0收件人时[即使发送方仅使用协议的向后兼容子集，也具有通信能力，从而使接收方知道可以在响应（服务器）或将来的请求（客户端）中使用更多高级功能。当HTTP / 1.1消息发送到HTTP / 1.0收件人时[&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]或版本未知的收件人，构造HTTP / 1.1消息，以便在忽略所有较新功能的情况下将其解释为有效的HTTP / 1.0消息。该规范对一些新功能提出了接收者版本的要求，以便一致的发送者将仅使用兼容的功能，直到它通过配置或消息接收确定接收者支持HTTP / 1.1。尽管相同的主要HTTP版本的次要版本之间，标头字段的解释不会更改，但是在没有此类字段的情况下收件人的默认行为可能会更改。除非另有说明，否则将为HTTP / 1.x的所有版本定义HTTP / 1.1中定义的标头字段。特别是，Host和Connection标头字段应该由所有HTTP / 1.x实现实现，无论它们是否宣传与HTTP / 1.1的一致性。如果新标头字段的定义语义允许不识别它们的接收者安全地忽略它们，则可以在不更改协议版本的情况下引入新标头字段。标头字段可扩展性在&lt;a href=&quot;#section-3.2.1&quot;&gt;第3.2.1节&lt;/a&gt;。处理HTTP消息的中介（即，除充当隧道的中介以外的所有中介）必须在转发的消息中发送其自己的HTTP版本。换句话说，不允许他们盲目转发HTTP消息的第一行，而不确保该消息中的协议版本与该中间件在接收和发送消息时都符合的版本相匹配。当下游收件人使用消息发送者的版本来确定哪些功能可安全用于以后与该发送者进行通信时，转发HTTP消息而不重写HTTP版本可能会导致通信错误。客户端应该发送一个请求版本，该版本等于该客户端符合的最高版本，并且其主要版本不高于服务器支持的最高版本（如果已知）。客户不得发送不符合的版本。如果已知服务器错误地实现了HTTP规范，则客户端可以发送较低的请求版本，但是仅在客户端尝试了至少一个正常请求并从响应状态代码或标头字段（例如，服务器）确定该客户端请求之后，客户端才可以发送较低的请求版本。服务器不正确地处理更高的请求版本。服务器应该发送一个响应版本，该响应版本等于该服务器所遵循的最高版本，该版本的主版本小于或等于请求中接收到的主版本。服务器不得发送与其不一致的版本。如果服务器出于任何原因希望拒绝客户的主要协议版本的服务，则可以发送505（不支持HTTP版本）响应。如果已知或怀疑客户端错误地实现了HTTP规范并且不能正确处理更高版本的响应，例如当客户端无法正确解析版本号或何时客户端，服务器可以发送对请求的HTTP / 1.0响应。众所周知，即使中介不符合给定的次要版本，它也会盲目转发HTTP版本。除非由特定的客户端属性触发（例如，当一个或多个请求标头字段（例如，用户代理）唯一匹配已知错误的客户端发送的值。 HTTP的版本设计的目的是，仅当引入了不兼容的消息语法时，才会增加主号码，并且仅当对协议进行的更改具有增加消息语义或暗示其他附加内容的作用时，才会增加次要号码。发送者的功能。但是，次版本并未因[并且仅当对协议所做的更改具有增加消息语义或暗示发送方其他功能的作用时，次要编号才会增加。但是，次版本并未因[并且仅当对协议所做的更改具有增加消息语义或暗示发送方其他功能的作用时，次要编号才会增加。但是，次版本并未因[&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;和[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]，并且此修订特别避免了对协议的任何此类更改。当接收到一条HTTP消息，该消息带有接收者实现的主要版本号，但其次要版本号高于接收者实现的次要版本号时，接收者应像处理该消息的主要版本中的最高次要版本一样处理该消息。收件人是合格的。收件人可以假定具有较高次要版本的消息发送给尚未指示对该较高版本支持的收件人时，具有足够的向后兼容性，可以由同一主要版本的任何实现安全地处理。</target>
        </trans-unit>
        <trans-unit id="d3a5b43c3101b03cd5693da68dc42b80224e0a29" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender to indicate the format of a message and its capacity for
   understanding further HTTP communication, rather than the features
   obtained via that communication. No change is made to the version
   number for the addition of message components which do not affect
   communication behavior or which only add to extensible field values.
   The &amp;lt;minor&amp;gt; number is incremented when the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, but which may add to the message semantics and imply
   additional capabilities of the sender. The &amp;lt;major&amp;gt; number is
   incremented when the format of a message within the protocol is
   changed. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;] for a fuller explanation. 

   The version of an HTTP message is indicated by an HTTP-Version field
   in the first line of the message.

       HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   Note that the major and minor numbers MUST be treated as separate
   integers and that each MAY be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and
   MUST NOT be sent.

   An application that sends a request or response message that includes
   HTTP-Version of &quot;HTTP/1.1&quot; MUST be at least conditionally compliant
   with this specification. Applications that are at least conditionally
   compliant with this specification SHOULD use an HTTP-Version of
   &quot;HTTP/1.1&quot; in their messages, and MUST do so for any message that is
   not compatible with HTTP/1.0. For more details on when to send
   specific HTTP-Version values, see &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;].

   The HTTP version of an application is the highest HTTP version for
   which the application is at least conditionally compliant.

   Proxy and gateway applications need to be careful when forwarding
   messages in protocol versions different from that of the application.
   Since the protocol version indicates the protocol capability of the
   sender, a proxy/gateway MUST NOT send a message with a version
   indicator which is greater than its actual version. If a higher
   version request is received, the proxy/gateway MUST either downgrade
   the request version, or respond with an error, or switch to tunnel
   behavior.

   Due to interoperability problems with HTTP/1.0 proxies discovered
   since the publication of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;[&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], caching proxies MUST, gateways
   MAY, and tunnels MUST NOT upgrade the request to the highest version
   they support. The proxy/gateway's response to that request MUST be in
   the same major version as the request.

      Note: Converting between versions of HTTP may involve modification
      of header fields required or forbidden by the versions involved.</source>
          <target state="translated">HTTP使用&amp;ldquo; &amp;lt;major&amp;gt;。&amp;lt;minor&amp;gt;&amp;rdquo;编号方案来指示协议的版本。协议版本控制策略旨在允许发送方指示消息的格式及其理解进一步HTTP通信的能力，而不是指示通过该通信获得的功能。对于添加消息组件的版本号不会做任何更改，这些消息组件不会影响通信行为或仅添加到可扩展的字段值。当对协议所做的更改添加了不更改常规消息解析算法但可以增加消息语义并暗示发送方其他功能的功能时，&amp;lt;minor&amp;gt;号将增加。 &amp;lt;主要&amp;gt;当协议中消息的格式改变时，数字增加。看到&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;]进行更详细的说明。 HTTP消息的版本由消息第一行中的HTTP-Version字段指示。 HTTP版本=&amp;ldquo; HTTP&amp;rdquo;&amp;ldquo; /&amp;rdquo; 1 * DIGIT&amp;ldquo;。 1 * DIGIT注意，必须将主数字和次数字视为单独的整数，并且每个数字都可以递增到高于一位数字。因此，HTTP / 2.4的版本低于HTTP / 2.13的版本，而HTTP / 2.13的版本又低于HTTP / 12.3。接收者必须忽略前导零，并且不得发送前导零。发送包含&amp;ldquo; HTTP / 1.1&amp;rdquo;的HTTP版本的请求或响应消息的应用程序必须至少有条件地符合此规范。至少有条件地符合此规范的应用程序应使用HTTP版本&amp;ldquo; HTTP / 1.1&amp;rdquo;在他们的消息中，对于与HTTP / 1.0不兼容的任何消息，都必须这样做。有关何时发送特定HTTP版本值的更多详细信息，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt; ]。应用程序的HTTP版本是该应用程序至少有条件兼容的最高HTTP版本。代理和网关应用程序在转发与应用程序协议版本不同的协议版本的消息时需要小心。由于协议版本指示发送者的协议能力，因此代理/网关不得发送消息，该消息的版本指示符应大于其实际版本。如果收到更高版本的请求，则代理/网关必须降级请求的版本，或响应错误，或切换到隧道行为。由于自&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;发布以来发现的HTTP / 1.0代理的互操作性问题[ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]，缓存代理必须，网关可以和隧道不得将请求升级到其支持的最高版本。代理/网关对该请求的响应必须与该请求使用相同的主要版本。注意：在HTTP版本之间进行转换可能涉及修改所涉及版本所需或禁止的标头字段。</target>
        </trans-unit>
        <trans-unit id="de9ea4b9303de1ca70c1a8e05822b3b34b2bc2c1" translate="yes" xml:space="preserve">
          <source>HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA &quot;Character Sets&quot;
   registry (&amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;&amp;gt;) according
   to the procedures defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt;].</source>
          <target state="translated">HTTP使用字符集名称来指示或协商文本表示形式的字符编码方案[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]。字符集由不区分大小写的标记标识。charset =令牌应根据[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt; ]中定义的过程，在IANA&amp;ldquo;字符集&amp;rdquo;注册表（&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt; &amp;gt;）中注册字符集名称。</target>
        </trans-unit>
        <trans-unit id="2330a27b61138a413c157df509aff0321f0a951a" translate="yes" xml:space="preserve">
          <source>HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA &quot;Character Sets&quot;
   registry (&amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;&amp;gt;) according
   to the procedures defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt;].</source>
          <target state="translated">HTTP使用字符集名称来指示或协商文本表示形式的字符编码方案[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]。字符集由不区分大小写的标记标识。 charset =令牌应根据[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt; ]中定义的过程，在IANA&amp;ldquo;字符集&amp;rdquo;注册表（&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt; &amp;gt;）中注册字符集名称。</target>
        </trans-unit>
        <trans-unit id="f64b344cb46f8dc4aefac27a98f9f8e7568e4d7b" translate="yes" xml:space="preserve">
          <source>HTTP uses the same definition of the term &quot;character set&quot; as that
   described for MIME: 

   The term &quot;character set&quot; is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters may
   be available in a given character set and a character set may provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name MUST fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.

      Note: This use of the term &quot;character set&quot; is more commonly
      referred to as a &quot;character encoding.&quot; However, since HTTP and
      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;].

       charset = token

   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;] MUST represent the character set defined
   by that registry. Applications SHOULD limit their use of character
   sets to those defined by the IANA registry.

   Implementors should be aware of IETF character set requirements [&lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt;]
   [&lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt;].</source>
          <target state="translated">HTTP使用与MIME相同的术语&amp;ldquo;字符集&amp;rdquo;定义：本文档中使用的术语&amp;ldquo;字符集&amp;rdquo;是指与一个或多个表一起使用的将八位位组序列转换为八位位组序列的方法。字符。注意，不需要另一个方向的无条件转换，因为在给定的字符集中并非所有字符都可用，并且字符集可以提供一个以上的八位位组序列来表示特定字符​​。此定义旨在允许各种字符编码，从简单的单表映射（例如US-ASCII）到复杂的表切换方法（例如使用ISO-2022的技术）。然而，与MIME字符集名称关联的定义必须完全指定要执行的从八位字节到字符的映射。特别是，不允许使用外部配置文件信息来确定确切的映射。注意：术语&amp;ldquo;字符集&amp;rdquo;的这种用法通常被称为&amp;ldquo;字符编码&amp;rdquo;。但是，由于HTTP和MIME共享同一个注册表，因此也必须共享该术语，这一点很重要。 HTTP字符集由不区分大小写的标记标识。完整的令牌集由IANA字符集注册表[通常被称为&amp;ldquo;字符编码&amp;rdquo;。但是，由于HTTP和MIME共享同一个注册表，因此也必须共享该术语，这一点很重要。 HTTP字符集由不区分大小写的标记标识。完整的令牌集由IANA字符集注册表[通常被称为&amp;ldquo;字符编码&amp;rdquo;。但是，由于HTTP和MIME共享同一个注册表，因此也必须共享该术语，这一点很重要。 HTTP字符集由不区分大小写的标记标识。完整的令牌集由IANA字符集注册表[&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]。 charset =令牌尽管HTTP允许将任意令牌用作字符集值，但IANA字符集注册表[ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ] 中具有预定义值的任何令牌都必须表示该注册表定义的字符集。应用程序应将其字符集的使用限制为IANA注册中心定义的字符集。实施者应了解IETF字符集要求[ &lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt; ] [ &lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="4998cbc56519b60012d9ddef5a93ab40ac390988" translate="yes" xml:space="preserve">
          <source>HTTP was created for the World Wide Web (WWW) architecture and has
   evolved over time to support the scalability needs of a worldwide
   hypertext system.  Much of that architecture is reflected in the
   terminology and syntax productions used to define HTTP.</source>
          <target state="translated">HTTP是为万维网(WWW)架构而创建的,并随着时间的推移不断发展,以支持全球超文本系统的可扩展性需求。这一架构在很大程度上反映在用于定义HTTP的术语和语法产品中。</target>
        </trans-unit>
        <trans-unit id="40aed2983145eadb2c78a80757cda404bbec1b9e" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2 as well as minor novelties introduced over the years.</source>
          <target state="translated">HTTP创建于20世纪90年代初,曾多次扩展。本文介绍了HTTP/0.9、HTTP/1.0、HTTP/1.1和现代HTTP/2的历史,以及多年来引入的一些小的新技术。</target>
        </trans-unit>
        <trans-unit id="6691219872cf8222b135471124cba8cce6315df4" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2, as well as novelties introduced over the years.</source>
          <target state="translated">HTTP诞生于20世纪90年代初,曾多次扩展。本文介绍了它的历史,并介绍了HTTP/0.9、HTTP/1.0、HTTP/1.1和现代的HTTP/2,以及多年来引入的新事物。</target>
        </trans-unit>
        <trans-unit id="8847a48bfa3a8070b11a550d8e6423fe9a938e29" translate="yes" xml:space="preserve">
          <source>HTTP was first specified in the early 1990s. Designed with extensibility in mind, it has seen numerous additions over the years; this lead to its specification being scattered through numerous specification documents (in the midst of experimental abandoned extensions). This page lists relevant resources about HTTP.</source>
          <target state="translated">HTTP在20世纪90年代初首次被指定。在设计时考虑到了可扩展性,多年来,它经历了无数次的添加;这导致它的规范分散在许多规范文档中(在实验性的废弃扩展中)。本页列出了有关HTTP的相关资源。</target>
        </trans-unit>
        <trans-unit id="c36d6fae868bc13b893908c5f64cbe8e452543ec" translate="yes" xml:space="preserve">
          <source>HTTP's approach to error handling has been explained.  (&lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;)

   The HTTP-version ABNF production has been clarified to be case-
   sensitive.  Additionally, version numbers have been restricted to
   single digits, due to the fact that implementations are known to
   handle multi-digit version numbers incorrectly.  (&lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;)

   Userinfo (i.e., username and password) are now disallowed in HTTP and
   HTTPS URIs, because of security issues related to their transmission
   on the wire.  (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;)

   The HTTPS URI scheme is now defined by this specification;
   previously, it was done in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;Section&amp;nbsp;2.4 of [RFC2818]&lt;/a&gt;.  Furthermore, it
   implies end-to-end security.  (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;)

   HTTP messages can be (and often are) buffered by implementations;
   despite it sometimes being available as a stream, HTTP is
   fundamentally a message-oriented protocol.  Minimum supported sizes
   for various protocol elements have been suggested, to improve
   interoperability.  (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;)

   Invalid whitespace around field-names is now required to be rejected,
   because accepting it represents a security vulnerability.  The ABNF
   productions defining header fields now only list the field value.
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   Rules about implicit linear whitespace between certain grammar
   productions have been removed; now whitespace is only allowed where
   specifically defined in the ABNF.  (&lt;a href=&quot;#section-3.2.3&quot;&gt;Section 3.2.3&lt;/a&gt;)

   Header fields that span multiple lines (&quot;line folding&quot;) are
   deprecated.  (&lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;)

   The NUL octet is no longer allowed in comment and quoted-string text,
   and handling of backslash-escaping in them has been clarified.  The
   quoted-pair rule no longer allows escaping control characters other
   than HTAB.  Non-US-ASCII content in header fields and the reason
   phrase has been obsoleted and made opaque (the TEXT rule was
   removed).  (&lt;a href=&quot;#section-3.2.6&quot;&gt;Section 3.2.6&lt;/a&gt;)

   Bogus Content-Length header fields are now required to be handled as
   errors by recipients.  (&lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt;)

   The algorithm for determining the message body length has been
   clarified to indicate all of the special cases (e.g., driven by
   methods or status codes) that affect it, and that new protocol 

   elements cannot define such special cases.  CONNECT is a new, special
   case in determining message body length. &quot;multipart/byteranges&quot; is no
   longer a way of determining message body length detection.
   (&lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;)

   The &quot;identity&quot; transfer coding token has been removed.  (Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
   and 4)

   Chunk length does not include the count of the octets in the chunk
   header and trailer.  Line folding in chunk extensions is disallowed.
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The meaning of the &quot;deflate&quot; content coding has been clarified.
   (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The segment + query components of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; have been used to define
   the request-target, instead of abs_path from &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;.  The
   asterisk-form of the request-target is only allowed with the OPTIONS
   method.  (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The term &quot;Effective Request URI&quot; has been introduced.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   Gateways do not need to generate Via header fields anymore.
   (&lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt;)

   Exactly when &quot;close&quot; connection options have to be sent has been
   clarified.  Also, &quot;hop-by-hop&quot; header fields are required to appear
   in the Connection header field; just because they're defined as hop-
   by-hop in this specification doesn't exempt them.  (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;)

   The limit of two connections per server has been removed.  An
   idempotent sequence of requests is no longer required to be retried.
   The requirement to retry requests under certain circumstances when
   the server prematurely closes the connection has been removed.  Also,
   some extraneous requirements about when servers are allowed to close
   connections prematurely have been removed.  (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;)

   The semantics of the Upgrade header field is now defined in responses
   other than 101 (this was incorporated from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;]).  Furthermore,
   the ordering in the field value is now significant.  (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;)

   Empty list elements in list productions (e.g., a list header field
   containing &quot;, ,&quot;) have been deprecated.  (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;)

   Registration of Transfer Codings now requires IETF Review
   (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;) 

   This specification now defines the Upgrade Token Registry, previously
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.  (&lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;)

   The expectation to support HTTP/0.9 requests has been removed.
   (Appendix A)

   Issues with the Keep-Alive and Proxy-Connection header fields in
   requests are pointed out, with use of the latter being discouraged
   altogether.  (Appendix A.1.2)</source>
          <target state="translated">已经说明了HTTP处理错误的方法。 （&lt;a href=&quot;#section-2.5&quot;&gt;第2.5节&lt;/a&gt;）HTTP版本ABNF生成已被区分大小写。此外，由于已知实现会错误地处理多位数字版本号，因此版本号已被限制为一位数字。 （&lt;a href=&quot;#section-2.6&quot;&gt;第2.6节&lt;/a&gt;）由于与在线传输有关的安全性问题，HTTP和HTTPS URI中现在禁止使用Userinfo（即用户名和密码）。 （&lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节&lt;/a&gt;）HTTPS URI方案现在由该规范定义。之前，它是在&lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;[RFC2818]的2.4节&lt;/a&gt;中完成的。此外，这意味着端到端的安全性。 （&lt;a href=&quot;#section-2.7.2&quot;&gt;第2.7.2节&lt;/a&gt;）HTTP消息可以（并且经常）由实现缓冲；尽管HTTP有时可以作为流使用，但从根本上来说，HTTP是一种面向消息的协议。已经提出了各种协议元素的最小支持大小，以提高互操作性。 （&lt;a href=&quot;#section-3&quot;&gt;第3节&lt;/a&gt;）现在必须拒绝字段名周围的无效空格，因为接受它表示安全漏洞。现在，定义标头字段的ABNF生产仅列出字段值。 （&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;）删除了某些语法生成之间隐式线性空白的规则；现在，仅在ABNF中明确定义的地方才允许使用空格。 （&lt;a href=&quot;#section-3.2.3&quot;&gt;第3.2.3节&lt;/a&gt;）不建议使用跨越多行的标题字段（&amp;ldquo;行折叠&amp;rdquo;）。 （&lt;a href=&quot;#section-3.2.4&quot;&gt;第3.2.4节&lt;/a&gt;）注释和带引号的字符串文本中不再允许使用NUL八位字节，并且已经澄清了其中的反斜杠转义的处理。引号对规则不再允许转义除HTAB以外的控制字符。标头字段和原因短语中的非US-ASCII内容已过时且不透明（已删除TEXT规则）。 （&lt;a href=&quot;#section-3.2.6&quot;&gt;第3.2.6节&lt;/a&gt;）现在，伪造的Content-Length标头字段需要由接收者作为错误处理。 （&lt;a href=&quot;#section-3.3.2&quot;&gt;第3.3.2节&lt;/a&gt;）已经明确了确定消息正文长度的算法，以指示影响消息正文长度的所有特殊情况（例如，由方法或状态代码驱动），并且新协议元素无法定义此类特殊情况。 CONNECT是确定邮件正文长度的一种新的特殊情况。 &amp;ldquo; multipart / byteranges&amp;rdquo;不再是确定邮件正文长度检测的方法。 （&lt;a href=&quot;#section-3.3.3&quot;&gt;第3.3.3节&lt;/a&gt;）&amp;ldquo;身份&amp;rdquo;转移编码令牌已被删除。 （第&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;节 和第4 节）块长度不包括块头和尾中八位字节的计数。块扩展中的行折叠是不允许的。 （&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;）已经阐明了&amp;ldquo;压缩&amp;rdquo;内容编码的含义。 （&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;）&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;的segment + query组件已用于定义请求目标，而不是&lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808中&lt;/a&gt;的abs_path 。仅使用OPTIONS方法允许请求目标的星号形式。 （&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）引入了&amp;ldquo;有效请求URI&amp;rdquo;一词。 （&lt;a href=&quot;#section-5.5&quot;&gt;第5.5节&lt;/a&gt;）网关不再需要生成Via标头字段。 （&lt;a href=&quot;#section-5.7.1&quot;&gt;第5.7.1节&lt;/a&gt;）明确了何时必须发送&amp;ldquo;关闭&amp;rdquo;连接选项。同样，&amp;ldquo;逐跳&amp;rdquo;标头字段必须显示在&amp;ldquo;连接&amp;rdquo;标头字段中。仅仅因为在本规范中将它们定义为逐跳方法并不能免除它们。（ &lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）已删除了每个服务器两个连接的限制。幂等的请求序列不再需要重试。在服务器过早关闭连接的某些情况下，重试请求的要求已删除。此外，还删除了一些有关何时允许服务器过早关闭连接的多余要求。 （&lt;a href=&quot;#section-6.3&quot;&gt;第6.3节&lt;/a&gt;）现在，在101以外的响应中定义了升级标头字段的语义（这是从[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] 合并的）。此外，字段值中的排序现在很重要。 （&lt;a href=&quot;#section-6.7&quot;&gt;第6.7节&lt;/a&gt;）已弃用列表产生中的空列表元素（例如，包含&amp;ldquo;，&amp;rdquo;的列表头字段）。 （&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）现在需要IETF审核（&lt;a href=&quot;#section-8.4&quot;&gt;第8.4 &lt;/a&gt;节）的转移代码注册。此规范现在定义了升级令牌注册中心，该注册中心先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]的第7.2节中&lt;/a&gt;定义。（&lt;a href=&quot;#section-8.6&quot;&gt;第8.6节&lt;/a&gt;）已删除了支持HTTP / 0.9请求的要求。（附录A）指出了请求中的Keep-Alive和Proxy-Connection标头字段的问题，建议不要使用后者。（附录A.1.2）</target>
        </trans-unit>
        <trans-unit id="e75786a71ce66c44187c7d3570685182eb4f5400" translate="yes" xml:space="preserve">
          <source>HTTP-only cookies aren't accessible via JavaScript through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; API to mitigate attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">仅HTTP的cookie无法通过JavaScript通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt;属性，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; API访问，以减轻针对跨站点脚本（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）的攻击。</target>
        </trans-unit>
        <trans-unit id="645478239b71d9e2120cd5c5e2c81c2c7e39f857" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 &amp;ndash; The one-line protocol</source>
          <target state="translated">HTTP / 0.9 &amp;ndash;一线协议</target>
        </trans-unit>
        <trans-unit id="44cba524f054d5d6640a40b11e1c3c0dd2b2e81c" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 was very limited and both browsers and servers quickly extended it to be more versatile:</source>
          <target state="translated">HTTP/0.9的局限性很大,无论是浏览器还是服务器都很快将其扩展到了更多的用途。</target>
        </trans-unit>
        <trans-unit id="17104213d7caf462f808b5202b6b3bf53c6f9e5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 &amp;ndash; Building extensibility</source>
          <target state="translated">HTTP / 1.0 &amp;ndash;建筑扩展性</target>
        </trans-unit>
        <trans-unit id="8cfcb01eada0b8cfd065017e118d423b8f745b23" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 connections are not persistent by default. Setting &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; to anything other than &lt;code&gt;close&lt;/code&gt;, usually &lt;code&gt;retry-after&lt;/code&gt;, will make them persistent.</source>
          <target state="translated">默认情况下，HTTP / 1.0连接不是持久性的。将&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;close&lt;/code&gt; 以外的其他值（通常是 &lt;code&gt;retry-after&lt;/code&gt; ）将使它们持久化。</target>
        </trans-unit>
        <trans-unit id="c0e8fb29ae930b0d157a9f98acea4150c0686f37" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 opened a TCP connection for each request/response exchange, introducing two major flaws: opening a connection needs several round-trips of messages and therefore slow, but becomes more efficient when several messages are sent, and regularly sent: &lt;em&gt;warm&lt;/em&gt; connections are more efficient than &lt;em&gt;cold&lt;/em&gt; ones.</source>
          <target state="translated">HTTP / 1.0打开每个请求/响应交换的TCP连接，引入两个主要缺陷：打开连接需要的消息的几个往返，因此慢，但变得当几个消息发送更有效率，并定期发送：&lt;em&gt;温暖&lt;/em&gt;连接是比&lt;em&gt;冷&lt;/em&gt;的更有效率。</target>
        </trans-unit>
        <trans-unit id="0d0b58bbcdf0ad6dac8b90fb47db84cff63b6a65" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &amp;ndash; The standardized protocol</source>
          <target state="translated">HTTP / 1.1 &amp;ndash;标准化协议</target>
        </trans-unit>
        <trans-unit id="b6ed95efc2e54e41776e64eab2beb02be978d4fe" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 allows a client to request that only part (a range of) the
   response entity be included within the response. HTTP/1.1 uses range
   units in the Range (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;) and Content-Range (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;)
   header fields. An entity can be broken down into subranges according
   to various structural units.

      range-unit       = bytes-unit | other-range-unit
      bytes-unit       = &quot;bytes&quot;
      other-range-unit = token

   The only range unit defined by HTTP/1.1 is &quot;bytes&quot;. HTTP/1.1
   implementations MAY ignore ranges specified using other units. 

   HTTP/1.1 has been designed to allow implementations of applications
   that do not depend on knowledge of ranges.</source>
          <target state="translated">HTTP / 1.1允许客户端请求仅将一部分响应实体（一部分）包含在响应中。 HTTP / 1.1在Range（&lt;a href=&quot;#section-14.35&quot;&gt;第14.35节&lt;/a&gt;）和Content-Range（&lt;a href=&quot;#section-14.16&quot;&gt;第14.16节&lt;/a&gt;）标头字段中使用范围单位。可以根据各种结构单元将实体分解为子范围。范围单位=字节单位| other-range-unit bytes-unit =&amp;ldquo; bytes&amp;rdquo; other-range-unit =令牌HTTP / 1.1定义的唯一范围单位是&amp;ldquo; bytes&amp;rdquo;。 HTTP / 1.1实现可以忽略使用其他单位指定的范围。 HTTP / 1.1被设计为允许实现不依赖范围知识的应用程序。</target>
        </trans-unit>
        <trans-unit id="8cf11b6afbfe5a73402d4b60de58fb9f5e3c6400" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 and earlier HTTP messages are human-readable. In HTTP/2, these messages are embedded into a new binary structure, a frame, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP/1.1和更早的HTTP消息是可以被人类读取的。在HTTP/2中,这些消息被嵌入到一个新的二进制结构中,即一个框架中,允许对报头进行压缩和复用等优化。即使在这个版本的HTTP中只发送了原始HTTP消息的一部分,每个消息的语义是不变的,客户端重构了(实际上)原始的HTTP/1.1请求。因此,用HTTP/1.1格式来理解HTTP/2消息是很有用的。</target>
        </trans-unit>
        <trans-unit id="340b2a6e6c85c293b668779af15231ac0ac5f995" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 clarified ambiguities and introduced numerous improvements:</source>
          <target state="translated">HTTP/1.1 澄清了歧义,并引入了许多改进。</target>
        </trans-unit>
        <trans-unit id="aaede2afb4e2e830b4b4156c5fed71c83597729d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 defaults to the use of &quot;persistent connections&quot;, allowing
   multiple requests and responses to be carried over a single
   connection.  The &quot;close&quot; connection option is used to signal that a
   connection will not persist after the current request/response.  HTTP
   implementations SHOULD support persistent connections. 

   A recipient determines whether a connection is persistent or not
   based on the most recently received message's protocol version and
   Connection header field (if any):

   o  If the &quot;close&quot; connection option is present, the connection will
      not persist after the current response; else,

   o  If the received protocol is HTTP/1.1 (or later), the connection
      will persist after the current response; else,

   o  If the received protocol is HTTP/1.0, the &quot;keep-alive&quot; connection
      option is present, the recipient is not a proxy, and the recipient
      wishes to honor the HTTP/1.0 &quot;keep-alive&quot; mechanism, the
      connection will persist after the current response; otherwise,

   o  The connection will close after the current response.

   A client MAY send additional requests on a persistent connection
   until it sends or receives a &quot;close&quot; connection option or receives an
   HTTP/1.0 response without a &quot;keep-alive&quot; connection option.

   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A server MUST read
   the entire request message body or close the connection after sending
   its response, since otherwise the remaining data on a persistent
   connection would be misinterpreted as the next request.  Likewise, a
   client MUST read the entire response message body if it intends to
   reuse the same connection for a subsequent request.

   A proxy server MUST NOT maintain a persistent connection with an
   HTTP/1.0 client (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&amp;nbsp;19.7.1 of [RFC2068]&lt;/a&gt; for information and
   discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).

   See &lt;a href=&quot;#appendix-A.1.2&quot;&gt;Appendix A.1.2&lt;/a&gt; for more information on backwards compatibility
   with HTTP/1.0 clients.</source>
          <target state="translated">HTTP / 1.1默认使用&amp;ldquo;持久连接&amp;rdquo;，从而允许在单个连接上承载多个请求和响应。 &amp;ldquo;关闭&amp;rdquo;连接选项用于表示当前请求/响应之后连接将不会持久。 HTTP实现应支持持久连接。收件人根据最近接收到的消息的协议版本和连接头字段（如果有）来确定连接是否持久：o如果存在&amp;ldquo;关闭&amp;rdquo;连接选项，则在当前响应之后该连接将不会持久；否则，o如果收到的协议是HTTP / 1.1（或更高版本），则连接将在当前响应之后保持不变；否则，o如果收到的协议是HTTP / 1.0，则&amp;ldquo;存在&amp;ldquo;保持活动&amp;rdquo;连接选项，接收者不是代理，并且接收者希望采用HTTP / 1.0&amp;ldquo;保持活动&amp;rdquo;机制，该连接将在当前响应后保持不变；否则，该连接将在之后响应关闭客户端可以在持久连接上发送其他请求，直到它发送或接收&amp;ldquo;关闭&amp;rdquo;连接选项或接收到不带有&amp;ldquo;保持活动&amp;rdquo;连接选项的HTTP / 1.0响应为止。在连接上需要具有自定义的消息长度（即，不是由连接的关闭定义的），如机制，连接将在当前响应后保持不变；否则，o连接将在当前响应后关闭。客户端可以在持久连接上发送附加请求，直到它发送或接收&amp;ldquo;关闭&amp;rdquo;连接选项或接收不带&amp;ldquo;保持活动&amp;rdquo;连接选项的HTTP / 1.0响应。为了保持持久性，连接上的所有消息都必须具有自己定义的消息长度（即，未由连接的关闭定义的消息长度），如机制，连接将在当前响应后保持不变；否则，o连接将在当前响应后关闭。客户端可以在持久连接上发送附加请求，直到它发送或接收&amp;ldquo;关闭&amp;rdquo;连接选项或接收不带&amp;ldquo;保持活动&amp;rdquo;连接选项的HTTP / 1.0响应。为了保持持久性，连接上的所有消息都必须具有自己定义的消息长度（即，未由连接的关闭定义的消息长度），如没有&amp;ldquo; keep-alive&amp;rdquo;连接选项的0响应。为了保持持久性，连接上的所有消息都必须具有自己定义的消息长度（即，未由连接的关闭定义的消息长度），如没有&amp;ldquo; keep-alive&amp;rdquo;连接选项的0响应。为了保持持久性，连接上的所有消息都必须具有自己定义的消息长度（即，未由连接的关闭定义的消息长度），如&lt;a href=&quot;#section-3.3&quot;&gt;3.3节&lt;/a&gt;。服务器必须在发送其响应后读取整个请求消息主体或关闭连接，因为否则，持久连接上的剩余数据将被误解为下一个请求。同样，如果客户端打算将相同的连接重用于后续请求，则必须读取整个响应消息正文。代理服务器&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;不得&lt;/a&gt;维护与HTTP / 1.0客户端的持久连接（有关许多HTTP / 1.0客户端实现的Keep-Alive标头字段的信息和问题的讨论，请参阅[RFC2068]的19.7.1节）。有关与HTTP / 1.0客户端向后兼容的更多信息，请参见&lt;a href=&quot;#appendix-A.1.2&quot;&gt;附录A.1.2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b235442975ba302869396fe0ff4cdaebf53c2643" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field
   (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;).  Transfer codings need to be decoded prior to
   forwarding an HTTP message over a MIME-compliant protocol.</source>
          <target state="translated">HTTP / 1.1引入了Transfer-Encoding头字段（&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节&lt;/a&gt;）。在通过MIME兼容协议转发HTTP消息之前，需要对传输编码进行解码。</target>
        </trans-unit>
        <trans-unit id="b7bc6b9e5b12ebbdf628d83f676eae2e25277f50" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;). Proxies/gateways MUST remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.

   A process for decoding the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;)
   can be represented in pseudo-code as:

       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size &amp;gt; 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove &quot;chunked&quot; from Transfer-Encoding</source>
          <target state="translated">HTTP / 1.1引入了Transfer-Encoding头字段（&lt;a href=&quot;#section-14.41&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41 &lt;/a&gt;节）。代理/网关在通过MIME兼容协议转发消息之前，必须删除所有传输编码。解码&amp;ldquo;分块&amp;rdquo;传输编码的过程（&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节&lt;/a&gt;）可以用伪代码表示为：length：= 0读取块大小，块扩展（如果有）和CRLF，而（块大小&amp;gt; 0）{读取块数据和CRLF将块数据追加到实体-正文长度：=长度+块大小读取块大小和CRLF}读取实体标头，同时（实体标头不为空）{将实体标头附加到现有标头字段中读取实体标头} Content-Length：= length删除&amp;ldquo;分块&amp;rdquo;（来自传输编码）</target>
        </trans-unit>
        <trans-unit id="55f1d0e9c7b192d39b6bf47cece53fe18cddfa5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's
   flow control mechanisms to resolve temporary overloads, rather than
   terminating connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.</source>
          <target state="translated">HTTP/1.1服务器应该保持持久连接,并使用TCP的流量控制机制来解决暂时的过载问题,而不是终止连接,期望客户端重试。后一种技术会加剧网络拥堵。</target>
        </trans-unit>
        <trans-unit id="5bde47938358e96d6b78dd50b25535a7c82c1d43" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols SHOULD ensure that any Date header field present in a
   message conforms to one of the HTTP/1.1 formats and rewrite the date
   if necessary.</source>
          <target state="translated">HTTP / 1.1使用一组受限制的日期格式（&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节&lt;/a&gt;）来简化日期比较的过程。来自其他协议的代理和网关应确保消息中存在的任何Date头字段均符合HTTP / 1.1格式之一，并在必要时重写日期。</target>
        </trans-unit>
        <trans-unit id="f983729fa70af1e90d7ea6dbb4afb3d7c8f79cd6" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;) to
   simplify the process of date comparison.  Proxies and gateways from
   other protocols ought to ensure that any Date header field present in
   a message conforms to one of the HTTP/1.1 formats and rewrite the
   date if necessary.</source>
          <target state="translated">HTTP / 1.1使用一组受限制的日期格式（&lt;a href=&quot;#section-7.1.1.1&quot;&gt;第7.1.1.1节&lt;/a&gt;）来简化日期比较的过程。来自其他协议的代理和网关应确保消息中存在的任何Date头字段均符合HTTP / 1.1格式之一，并在必要时重写日期。</target>
        </trans-unit>
        <trans-unit id="87f9910f16689f67ad3946ec5476c5e20370823d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for Internet Mail (&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]) and the Multipurpose Internet Mail Extensions (MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechanisms. However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;
   discusses mail, and HTTP has a few features that are different from
   those described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways to strict MIME environments SHOULD be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.</source>
          <target state="translated">HTTP / 1.1使用为Internet邮件（&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]）和多用途Internet邮件扩展（MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]）定义的许多构造，以允许实体以开放的各种表示形式和可扩展的机制进行传输。但是，&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; 讨论了邮件，并且HTTP具有一些与&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045中&lt;/a&gt;描述的功能不同的功能。精心选择了这些差异，以优化二进制连接的性能，从而在使用新的媒体类型时拥有更大的自由度，使日期比较更加容易，并认可了某些早期HTTP服务器和客户端的做法。本附录描述了HTTP与&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;。到严格的MIME环境的代理和网关应了解这些差异，并在必要时提供适当的转换。从MIME环境到HTTP的代理和网关也需要注意这些差异，因为可能需要进行一些转换。</target>
        </trans-unit>
        <trans-unit id="7ba038961de66fab4bc0d4ca5f738bb4971581c5" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for the Internet Message
   Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose Internet Mail Extensions (MIME)
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] to allow a message body to be transmitted in an open
   variety of representations and with extensible header fields.
   However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; is focused only on email; applications of HTTP have
   many characteristics that differ from email; hence, HTTP has features
   that differ from MIME.  These differences were carefully chosen to
   optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.</source>
          <target state="translated">HTTP / 1.1使用为Internet消息格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ]和多用途Internet邮件扩展（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ] 定义的许多构造，以允许以开放的各种表示形式和可扩展的标头字段传输消息正文。但是，&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;仅专注于电子邮件；HTTP的应用程序具有许多不同于电子邮件的特征；因此，HTTP具有与MIME不同的功能。精心选择了这些差异，以优化二进制连接上的性能，从而在使用新媒体类型时拥有更大的自由度，使日期比较更加容易，并认可了某些早期HTTP服务器和客户端的做法。本附录描述了HTTP与MIME不同的特定区域。往返于严格的MIME环境的代理和网关需要了解这些差异，并在必要时提供适当的转换。</target>
        </trans-unit>
        <trans-unit id="26857a3eb014d1c446a022b99900a2e1fa1f388e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was first published as &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; in January 1997.</source>
          <target state="translated">HTTP / 1.1于1997年1月首次发布为&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5072f3723c431d48c51e0f349be99684fbc90ba" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains both concepts.</source>
          <target state="translated">HTTP/1.1是HTTP的第一个支持持久连接和管道化的版本。本文将解释这两个概念。</target>
        </trans-unit>
        <trans-unit id="bd63c4dcb6457bcb6fd3cf072cc949e847bb34c1" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains these two concepts.</source>
          <target state="translated">HTTP/1.1是HTTP的第一个支持持久连接和管道化的版本。这篇文章解释了这两个概念。</target>
        </trans-unit>
        <trans-unit id="1503342ea4d0a3a7deec2528731a5bc064211705" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Authentication</source>
          <target state="translated">HTTP/1.1:认证</target>
        </trans-unit>
        <trans-unit id="0c4a2c0ccd4801b8e3ca9529c7a252503dccdf00" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Semantics and Content</source>
          <target state="translated">HTTP/1.1:语义和内容</target>
        </trans-unit>
        <trans-unit id="c0b298b6e63b8ce602677a51d4f1e6436079232f" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Status Code Definitions</source>
          <target state="translated">HTTP/1.1:状态码定义</target>
        </trans-unit>
        <trans-unit id="21663f5aa54f6135626b598bc6ce1bf03ec7513b" translate="yes" xml:space="preserve">
          <source>HTTP/1.x messages have a few drawbacks for performance:</source>
          <target state="translated">HTTP/1.x消息在性能上有一些缺点。</target>
        </trans-unit>
        <trans-unit id="682ec4f8ae7cf90f4fab0685ba322176bdd4f593" translate="yes" xml:space="preserve">
          <source>HTTP/2 &amp;ndash; A protocol for greater performance</source>
          <target state="translated">HTTP / 2 &amp;ndash;更高性能的协议</target>
        </trans-unit>
        <trans-unit id="a9820b1d6f7a1eb33859fc438f4a30a55193154b" translate="yes" xml:space="preserve">
          <source>HTTP/2 Frames</source>
          <target state="translated">HTTP/2帧</target>
        </trans-unit>
        <trans-unit id="b9a1cc9ca8b3b857841ac45f6cab101cd76b0608" translate="yes" xml:space="preserve">
          <source>HTTP/2 adds additional models for connection management.</source>
          <target state="translated">HTTP/2增加了连接管理的附加模型。</target>
        </trans-unit>
        <trans-unit id="54eb672058f3fe82f9b7ac710f7c24cca641a933" translate="yes" xml:space="preserve">
          <source>HTTP/2 allows a server to pre-emptively send (or &quot;push&quot;) responses
   (along with corresponding &quot;promised&quot; requests) to a client in
   association with a previous client-initiated request.  This can be
   useful when the server knows the client will need to have those
   responses available in order to fully process the response to the
   original request. 

   A client can request that server push be disabled, though this is
   negotiated for each hop independently.  The SETTINGS_ENABLE_PUSH
   setting can be set to 0 to indicate that server push is disabled.

   Promised requests MUST be cacheable (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.3&quot;&gt;[RFC7231], Section&amp;nbsp;4.2.3&lt;/a&gt;),
   MUST be safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231], Section&amp;nbsp;4.2.1&lt;/a&gt;), and MUST NOT include a
   request body.  Clients that receive a promised request that is not
   cacheable, that is not known to be safe, or that indicates the
   presence of a request body MUST reset the promised stream with a
   stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type PROTOCOL_ERROR.  Note this could
   result in the promised stream being reset if the client does not
   recognize a newly defined method as being safe.

   Pushed responses that are cacheable (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3&quot;&gt;[RFC7234], Section&amp;nbsp;3&lt;/a&gt;) can be
   stored by the client, if it implements an HTTP cache.  Pushed
   responses are considered successfully validated on the origin server
   (e.g., if the &quot;no-cache&quot; cache response directive is present
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2&quot;&gt;[RFC7234], Section&amp;nbsp;5.2.2&lt;/a&gt;)) while the stream identified by the
   promised stream ID is still open.

   Pushed responses that are not cacheable MUST NOT be stored by any
   HTTP cache.  They MAY be made available to the application
   separately.

   The server MUST include a value in the &quot;:authority&quot; pseudo-header
   field for which the server is authoritative (see &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).  A
   client MUST treat a PUSH_PROMISE for which the server is not
   authoritative as a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   An intermediary can receive pushes from the server and choose not to
   forward them on to the client.  In other words, how to make use of
   the pushed information is up to that intermediary.  Equally, the
   intermediary might choose to make additional pushes to the client,
   without any action taken by the server.

   A client cannot push.  Thus, servers MUST treat the receipt of a
   PUSH_PROMISE frame as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.  Clients MUST reject any attempt to change the
   SETTINGS_ENABLE_PUSH setting to a value other than 0 by treating the
   message as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.</source>
          <target state="translated">HTTP / 2允许服务器与先前的客户端发起的请求相关联地抢先向客户端发送（或&amp;ldquo;推送&amp;rdquo;）响应（以及相应的&amp;ldquo;承诺&amp;rdquo;请求）。当服务器知道客户端需要使那些响应可用以完全处理对原始请求的响应时，此功能很有用。客户端可以请求禁用服务器推送，尽管这是针对每个跃点单独协商的。可以将SETTINGS_ENABLE_PUSH设置设置为0，以指示禁用服务器推送。承诺的请求必须是可缓存的（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.3&quot;&gt;[RFC7231]，第4.2.3节&lt;/a&gt;），必须是安全的（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]，第4.2.1节）&lt;/a&gt;），并且不得包含请求正文。接收到不可缓存的，不安全的，或指示请求体存在的已承诺请求的客户端必须使用PROTOCOL_ERROR类型的流错误（&lt;a href=&quot;#section-5.4.2&quot;&gt;第5.4.2节&lt;/a&gt;）重置已承诺的流。请注意，如果客户端未将新定义的方法视为安全方法，则可能导致重置承诺的流。如果客户端实现了HTTP缓存，则可以存储可缓存的推送响应（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3&quot;&gt;[RFC7234]，第3节&lt;/a&gt;）。推入的响应被视为在原始服务器上已成功验证（例如，如果存在&amp;ldquo; no-cache&amp;rdquo;高速缓存响应指令（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2&quot;&gt;[RFC7234]，第5.2.2节）&lt;/a&gt;）），但由承诺的流ID标识的流仍处于打开状态。不可缓存的推送响应绝不能由任何HTTP缓存存储。它们可以单独提供给应用程序。服务器必须在服务器授权的&amp;ldquo;：authority&amp;rdquo;伪头字段中包含一个值（请参见&lt;a href=&quot;#section-10.1&quot;&gt;10.1节&lt;/a&gt;）。客户端必须将服务器不具有权威性的PUSH_PROMISE视为流错误（&lt;a href=&quot;#section-5.4.2&quot;&gt;第5.4.2节）&lt;/a&gt;），类型为PROTOCOL_ERROR。中介可以从服务器接收推送，并选择不将其转发到客户端。换句话说，如何利用推送的信息取决于该中介。同样，中介可能会选择对客户端进行其他推送，而服务器不会采取任何措施。客户端无法推送。因此，服务器必须将收到PUSH_PROMISE帧视为PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。客户端必须拒绝通过将消息视为PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）来将SETTINGS_ENABLE_PUSH设置更改为非0的任何尝试。</target>
        </trans-unit>
        <trans-unit id="de5c597058c2601a65efadc88f948c586a1ffe49" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained. This article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP/2彻底重新审视了连接的创建和维护方式。本文解释了HTTP帧如何允许复用,并解决了以前HTTP版本的 &quot;线头 &quot;阻塞问题。</target>
        </trans-unit>
        <trans-unit id="c5d84f8ae615e7ecf29c3c866e9ab8e4f31fe842" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained: this article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP/2完全重新审视了连接的创建和维护方式:本文解释了HTTP帧如何允许复用,并解决了以前HTTP版本的 &quot;线头 &quot;阻塞问题。</target>
        </trans-unit>
        <trans-unit id="2e8a1b1988d920e971547beb51740f33d132de14" translate="yes" xml:space="preserve">
          <source>HTTP/2 connections are persistent.  For best performance, it is
   expected that clients will not close connections until it is
   determined that no further communication with a server is necessary
   (for example, when a user navigates away from a particular web page)
   or until the server closes the connection.

   Clients SHOULD NOT open more than one HTTP/2 connection to a given
   host and port pair, where the host is derived from a URI, a selected
   alternative service [&lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt;], or a configured proxy.

   A client can create additional connections as replacements, either to
   replace connections that are near to exhausting the available stream
   identifier space (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;), to refresh the keying material for
   a TLS connection, or to replace connections that have encountered
   errors (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;).

   A client MAY open multiple connections to the same IP address and TCP
   port using different Server Name Indication [&lt;a href=&quot;#ref-TLS-EXT&quot;&gt;TLS-EXT&lt;/a&gt;] values or to
   provide different TLS client certificates but SHOULD avoid creating
   multiple connections with the same configuration.

   Servers are encouraged to maintain open connections for as long as
   possible but are permitted to terminate idle connections if
   necessary.  When either endpoint chooses to close the transport-layer
   TCP connection, the terminating endpoint SHOULD first send a GOAWAY
   (&lt;a href=&quot;#section-6.8&quot;&gt;Section 6.8&lt;/a&gt;) frame so that both endpoints can reliably determine
   whether previously sent frames have been processed and gracefully
   complete or terminate any necessary remaining tasks.</source>
          <target state="translated">HTTP / 2连接是持久的。为了获得最佳性能，期望客户端在确定没有必要与服务器进行进一步通信之前（例如，当用户离开特定网页时）或在服务器关闭连接之前，不会关闭连接。客户端不应该打开与给定主机和端口对的多个HTTP / 2连接，该主机是从URI，选定的替代服务[ &lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt; ]或配置的代理派生而来的。客户端可以创建其他连接作为替换，以替换即将用尽可用流标识符空间的连接（&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt;），刷新TLS连接的密钥资料或替换遇到错误的连接（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。客户端可以使用不同的服务器名称指示[ &lt;a href=&quot;#ref-TLS-EXT&quot;&gt;TLS-EXT&lt;/a&gt; ]值或提供不同的TLS客户端证书打开到同一IP地址和TCP端口的多个连接，但应避免使用相同的配置创建多个连接。鼓励服务器尽可能长时间地保持打开的连接，但在必要时允许服务器终止空闲连接。当任一端点选择关闭传输层TCP连接时，终止端点应首先发送一个GOAWAY（&lt;a href=&quot;#section-6.8&quot;&gt;第6.8节&lt;/a&gt;）帧，以便两个端点都能可靠地确定先前发送的帧是否已被处理，并能正常完成或终止任何必要的剩余任务。</target>
        </trans-unit>
        <trans-unit id="1efc25584aecfa2add3f9dc3f180c8c930b17062" translate="yes" xml:space="preserve">
          <source>HTTP/2 does not use the Connection header field to indicate
   connection-specific header fields; in this protocol, connection-
   specific metadata is conveyed by other means.  An endpoint MUST NOT
   generate an HTTP/2 message containing connection-specific header
   fields; any message containing connection-specific header fields MUST
   be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).

   The only exception to this is the TE header field, which MAY be
   present in an HTTP/2 request; when it is, it MUST NOT contain any
   value other than &quot;trailers&quot;.

   This means that an intermediary transforming an HTTP/1.x message to
   HTTP/2 will need to remove any header fields nominated by the
   Connection header field, along with the Connection header field
   itself.  Such intermediaries SHOULD also remove other connection-
   specific header fields, such as Keep-Alive, Proxy-Connection,
   Transfer-Encoding, and Upgrade, even if they are not nominated by the
   Connection header field.

      Note: HTTP/2 purposefully does not support upgrade to another
      protocol.  The handshake methods described in &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt; are
      believed sufficient to negotiate the use of alternative protocols.</source>
          <target state="translated">HTTP / 2不使用Connection标头字段来指示特定于连接的标头字段；在该协议中，特定于连接的元数据通过其他方式传达。端点不得生成包含特定于连接的报头字段的HTTP / 2消息；包含特定于连接头域的任何消息都必须被视为格式错误（&lt;a href=&quot;#section-8.1.2.6&quot;&gt;第8.1.2.6节）&lt;/a&gt;）。唯一的例外是TE标头字段，该字段可以出现在HTTP / 2请求中。如果是，则除&amp;ldquo; trailers&amp;rdquo;外，不得包含其他任何值。这意味着将HTTP / 1.x消息转换为HTTP / 2的中介程序将需要删除由Connection标头字段指定的所有标头字段，以及Connection标头字段本身。这样的中介也应该删除其他特定于连接的头字段，例如Keep-Alive，Proxy-Connection，Transfer-Encoding和Upgrade，即使它们不是由Connection头字段指定的。注意：HTTP / 2有意不支持升级到另一个协议。相信&lt;a href=&quot;#section-3&quot;&gt;第3节中&lt;/a&gt;描述的握手方法足以协商使用替代协议。</target>
        </trans-unit>
        <trans-unit id="7f0a10f9ce0b6e8be8176a0d0cf459883c237676" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose and the way it is encoded.</source>
          <target state="translated">HTTP/2将HTTP/1.x消息封装并以二进制框架表示。这篇文章解释了框架结构、其目的和编码方式。</target>
        </trans-unit>
        <trans-unit id="8b89d94c6825e208193b0c3215145db1ad533fe7" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose, and the way it's encoded.</source>
          <target state="translated">HTTP/2将HTTP/1.x消息用二进制框架封装和表示。这篇文章解释了框架结构,它的目的,以及它的编码方式。</target>
        </trans-unit>
        <trans-unit id="ba56fda18c2bd152dfb61f66462a8db0fe469c40" translate="yes" xml:space="preserve">
          <source>HTTP/2 explicitly disallows the use of this mechanism/header; it is specific to HTTP/1.1.</source>
          <target state="translated">HTTP/2明确不允许使用这种机制/头,它是HTTP/1.1所特有的。</target>
        </trans-unit>
        <trans-unit id="0c2199ec4bbb69f26ef0e867c04766b55d384a12" translate="yes" xml:space="preserve">
          <source>HTTP/2 framing permits two classes of error:

   o  An error condition that renders the entire connection unusable is
      a connection error.

   o  An error in an individual stream is a stream error.

   A list of error codes is included in &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2帧允许两种错误类型：o使整个连接不可用的错误条件是连接错误。 o单个流中的错误是流错误。错误代码列表包含在&lt;a href=&quot;#section-7&quot;&gt;第7节中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f6c2df4a46eb441a1cda15f98cf3c5243cca600" translate="yes" xml:space="preserve">
          <source>HTTP/2 introduces an extra step: it divides HTTP/1.x messages into frames which are embedded in a stream. Data and header frames are separated, this allows header compression. Several streams can be combined together, a process called &lt;em&gt;multiplexing&lt;/em&gt;, allowing more efficient underlying TCP connections.</source>
          <target state="translated">HTTP / 2引入了一个额外的步骤：它将HTTP / 1.x消息划分为嵌入在流中的帧。数据和标头帧是分开的，这允许标头压缩。几个流可以组合在一起，这个过程称为&lt;em&gt;多路复用&lt;/em&gt;，可以实现更有效的基础TCP连接。</target>
        </trans-unit>
        <trans-unit id="bc53da359a0e569373e6fa4412bc22e2cf58dd05" translate="yes" xml:space="preserve">
          <source>HTTP/2 is intended to be as compatible as possible with current uses
   of HTTP.  This means that, from the application perspective, the
   features of the protocol are largely unchanged.  To achieve this, all
   request and response semantics are preserved, although the syntax of
   conveying those semantics has changed.

   Thus, the specification and requirements of HTTP/1.1 Semantics and
   Content [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;], Conditional Requests [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;], Range Requests
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;], Caching [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;], and Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] are
   applicable to HTTP/2.  Selected portions of HTTP/1.1 Message Syntax 

   and Routing [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], such as the HTTP and HTTPS URI schemes, are
   also applicable in HTTP/2, but the expression of those semantics for
   this protocol are defined in the sections below.</source>
          <target state="translated">HTTP / 2旨在与HTTP的当前使用尽可能兼容。这意味着，从应用程序的角度来看，该协议的功能在很大程度上没有变化。为此，尽管传达这些语义的语法已更改，但保留了所有请求和响应语义。因此，HTTP / 1.1语义和内容[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]，条件请求[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]，范围请求[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]，缓存[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]和认证[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]的规范和要求适用于HTTP / 2。 HTTP / 1.1消息语法和路由的选定部分[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]（例如HTTP和HTTPS URI方案）也适用于HTTP / 2，但是在以下各节中定义了此协议的那些语义的表达。</target>
        </trans-unit>
        <trans-unit id="e9edb835c33550cd700f0b5e17b2557aefdd2e70" translate="yes" xml:space="preserve">
          <source>HTTP/2 permits extension of the protocol.  Within the limitations
   described in this section, protocol extensions can be used to provide
   additional services or alter any aspect of the protocol.  Extensions
   are effective only within the scope of a single HTTP/2 connection.

   This applies to the protocol elements defined in this document.  This
   does not affect the existing options for extending HTTP, such as
   defining new methods, status codes, or header fields.

   Extensions are permitted to use new frame types (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;), new
   settings (&lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;), or new error codes (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).  Registries
   are established for managing these extension points: frame types
   (&lt;a href=&quot;#section-11.2&quot;&gt;Section 11.2&lt;/a&gt;), settings (&lt;a href=&quot;#section-11.3&quot;&gt;Section 11.3&lt;/a&gt;), and error codes
   (&lt;a href=&quot;#section-11.4&quot;&gt;Section 11.4&lt;/a&gt;).

   Implementations MUST ignore unknown or unsupported values in all
   extensible protocol elements.  Implementations MUST discard frames
   that have unknown or unsupported types.  This means that any of these
   extension points can be safely used by extensions without prior
   arrangement or negotiation.  However, extension frames that appear in
   the middle of a header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) are not permitted; these
   MUST be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   Extensions that could change the semantics of existing protocol
   components MUST be negotiated before being used.  For example, an
   extension that changes the layout of the HEADERS frame cannot be used
   until the peer has given a positive signal that this is acceptable.
   In this case, it could also be necessary to coordinate when the
   revised layout comes into effect.  Note that treating any frames
   other than DATA frames as flow controlled is such a change in
   semantics and can only be done through negotiation.

   This document doesn't mandate a specific method for negotiating the
   use of an extension but notes that a setting (&lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;) could be
   used for that purpose.  If both peers set a value that indicates
   willingness to use the extension, then the extension can be used.  If 

   a setting is used for extension negotiation, the initial value MUST
   be defined in such a fashion that the extension is initially
   disabled.</source>
          <target state="translated">HTTP / 2允许扩展协议。在本节描述的限制范围内，协议扩展可用于提供其他服务或更改协议的任何方面。扩展仅在单个HTTP / 2连接的范围内有效。这适用于本文档中定义的协议元素。这不会影响扩展HTTP的现有选项，例如定义新方法，状态代码或标头字段。扩展名可以使用新的帧类型（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;），新的设置（&lt;a href=&quot;#section-6.5.2&quot;&gt;第6.5.2节&lt;/a&gt;）或新的错误代码（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）。建立用于管理以下扩展点的注册表：帧类型（&lt;a href=&quot;#section-11.2&quot;&gt;第11.2节&lt;/a&gt;），设置（&lt;a href=&quot;#section-11.3&quot;&gt;第11.3节&lt;/a&gt;）和错误代码（&lt;a href=&quot;#section-11.4&quot;&gt;11.4节&lt;/a&gt;）。在所有可扩展协议元素中，实现必须忽略未知或不受支持的值。实现必须丢弃类型未知或不受支持的帧。这意味着这些扩展点中的任何一个都可以被扩展安全地使用，而无需事先安排或协商。但是，不允许出现在标头块（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）中间的扩展框架。这些必须视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节）&lt;/a&gt;），类型为PROTOCOL_ERROR。可能会更改现有协议组件语义的扩展必须在使用前进行协商。例如，在对等端给出肯定的信号之前，不能使用更改HEADERS帧的布局的扩展名。在这种情况下，修改后的布局生效时也可能需要进行协调。请注意，将除DATA帧以外的任何帧视为流控制是这种语义上的更改，并且只能通过协商来完成。本文档未强制规定使用扩展的具体协商方法，但请注意，设置（&lt;a href=&quot;#section-6.5.2&quot;&gt;第6.5.2节&lt;/a&gt;）可用于该目的。如果两个对等方都设置了表示愿意使用该扩展名的值，则可以使用该扩展名。如果设置用于扩展协商，则必须以初始禁用扩展的方式定义初始值。</target>
        </trans-unit>
        <trans-unit id="22c5a1b25e6a4fea1e7bbf65b201a3854ef9fe0d" translate="yes" xml:space="preserve">
          <source>HTTP/2 provides an optimized transport for HTTP semantics.  HTTP/2
   supports all of the core features of HTTP/1.1 but aims to be more
   efficient in several ways.

   The basic protocol unit in HTTP/2 is a frame (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;).  Each
   frame type serves a different purpose.  For example, HEADERS and DATA
   frames form the basis of HTTP requests and responses (&lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;);
   other frame types like SETTINGS, WINDOW_UPDATE, and PUSH_PROMISE are
   used in support of other HTTP/2 features.

   Multiplexing of requests is achieved by having each HTTP request/
   response exchange associated with its own stream (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).
   Streams are largely independent of each other, so a blocked or
   stalled request or response does not prevent progress on other
   streams.

   Flow control and prioritization ensure that it is possible to
   efficiently use multiplexed streams.  Flow control (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;)
   helps to ensure that only data that can be used by a receiver is
   transmitted.  Prioritization (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) ensures that limited
   resources can be directed to the most important streams first.

   HTTP/2 adds a new interaction mode whereby a server can push
   responses to a client (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;).  Server push allows a server to
   speculatively send data to a client that the server anticipates the
   client will need, trading off some network usage against a potential
   latency gain.  The server does this by synthesizing a request, which
   it sends as a PUSH_PROMISE frame.  The server is then able to send a
   response to the synthetic request on a separate stream.

   Because HTTP header fields used in a connection can contain large
   amounts of redundant data, frames that contain them are compressed
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  This has especially advantageous impact upon request
   sizes in the common case, allowing many requests to be compressed
   into one packet.</source>
          <target state="translated">HTTP / 2为HTTP语义提供了优化的传输。 HTTP / 2支持HTTP / 1.1的所有核心功能，但旨在通过多种方式提高效率。 HTTP / 2中的基本协议单元是一个帧（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;）。每种帧类型都有不同的用途。例如，HEADERS和DATA帧构成了HTTP请求和响应的基础（&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;）；其他帧类型（如SETTINGS，WINDOW_UPDATE和PUSH_PROMISE）用于支持其他HTTP / 2功能。通过使每个HTTP请求/响应交换与其自己的流相关联来实现请求的复用（&lt;a href=&quot;#section-5&quot;&gt;第5节）&lt;/a&gt;）。流在很大程度上彼此独立，因此被阻塞或停止的请求或响应不会阻止其他流的进度。流控制和优先级确保可以有效地使用多路复用流。流控制（&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;）有助于确保仅传输可以由接收器使用的数据。优先级划分（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）确保可以将有限的资源首先定向到最重要的流。 HTTP / 2添加了新的交互模式，服务器可以通过该模式将响应推送到客户端（&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节）&lt;/a&gt;）。服务器推送允许服务器推测性地将数据发送到服务器，服务器预期该客户端将需要该客户端，从而权衡了一些网络使用量和潜在的延迟增加。服务器通过合成请求来完成此任务，并以PUSH_PROMISE帧的形式发送。然后，服务器可以在单独的流上发送对合成请求的响应。因为在连接中使用的HTTP标头字段可以包含大量冗余数据，所以包含它们的帧将被压缩（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）。在通常情况下，这对请求大小具有特别有利的影响，允许将许多请求压缩到一个数据包中。</target>
        </trans-unit>
        <trans-unit id="e6d3d6527a518220064866c33fee8ad8d1d0d9e1" translate="yes" xml:space="preserve">
          <source>HTTP/2 relies on the HTTP/1.1 definition of authority for determining
   whether a server is authoritative in providing a given response (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9.1&quot;&gt;[RFC7230], Section&amp;nbsp;9.1&lt;/a&gt;).  This relies on local name resolution for
   the &quot;http&quot; URI scheme and the authenticated server identity for the
   &quot;https&quot; scheme (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-3&quot;&gt;[RFC2818], Section&amp;nbsp;3&lt;/a&gt;).</source>
          <target state="translated">HTTP / 2依靠HTTP / 1.1权限定义来确定服务器在提供给定响应方面是否具有权威性（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9.1&quot;&gt;[RFC7230]，第9.1节&lt;/a&gt;）。这依赖于&amp;ldquo; http&amp;rdquo; URI方案的本地名称解析和&amp;ldquo; https&amp;rdquo;方案的已认证服务器身份（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-3&quot;&gt;[RFC2818]，第3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="09a20a6daa697cc2c8f65f130ec7eeb86fda81cc" translate="yes" xml:space="preserve">
          <source>HTTP/2 removes support for the 101 (Switching Protocols)
   informational status code (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2.2&quot;&gt;[RFC7231], Section&amp;nbsp;6.2.2&lt;/a&gt;).

   The semantics of 101 (Switching Protocols) aren't applicable to a
   multiplexed protocol.  Alternative protocols are able to use the same
   mechanisms that HTTP/2 uses to negotiate their use (see &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).</source>
          <target state="translated">HTTP / 2删除了对101（交换协议）信息状态代码（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2.2&quot;&gt;[RFC7231]，第6.2.2节&lt;/a&gt;）的支持。101（交换协议）的语义不适用于多路复用协议。替代协议能够使用与HTTP / 2协商使用相同的机制（请参阅&lt;a href=&quot;#section-3&quot;&gt;第3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a6307824ad0a5d4b71efa2a434d199cfb09c04ad" translate="yes" xml:space="preserve">
          <source>HTTP/2 stream flow control aims to allow a variety of flow-control
   algorithms to be used without requiring protocol changes.  Flow
   control in HTTP/2 has the following characteristics:

   1.  Flow control is specific to a connection.  Both types of flow
       control are between the endpoints of a single hop and not over
       the entire end-to-end path.

   2.  Flow control is based on WINDOW_UPDATE frames.  Receivers
       advertise how many octets they are prepared to receive on a
       stream and for the entire connection.  This is a credit-based
       scheme.

   3.  Flow control is directional with overall control provided by the
       receiver.  A receiver MAY choose to set any window size that it
       desires for each stream and for the entire connection.  A sender
       MUST respect flow-control limits imposed by a receiver.  Clients,
       servers, and intermediaries all independently advertise their
       flow-control window as a receiver and abide by the flow-control
       limits set by their peer when sending.

   4.  The initial value for the flow-control window is 65,535 octets
       for both new streams and the overall connection.

   5.  The frame type determines whether flow control applies to a
       frame.  Of the frames specified in this document, only DATA
       frames are subject to flow control; all other frame types do not
       consume space in the advertised flow-control window.  This
       ensures that important control frames are not blocked by flow
       control.

   6.  Flow control cannot be disabled.

   7.  HTTP/2 defines only the format and semantics of the WINDOW_UPDATE
       frame (&lt;a href=&quot;#section-6.9&quot;&gt;Section 6.9&lt;/a&gt;).  This document does not stipulate how a
       receiver decides when to send this frame or the value that it
       sends, nor does it specify how a sender chooses to send packets.
       Implementations are able to select any algorithm that suits their
       needs.

   Implementations are also responsible for managing how requests and
   responses are sent based on priority, choosing how to avoid head-of-
   line blocking for requests, and managing the creation of new streams.
   Algorithm choices for these could interact with any flow-control
   algorithm.</source>
          <target state="translated">HTTP / 2流流控制旨在允许使用各种流控制算法，而无需更改协议。 HTTP / 2中的流控制具有以下特征：1.流控制特定于连接。两种类型的流控制都在单个跃点的端点之间，而不是在整个端到端路径上。 2.流控制基于WINDOW_UPDATE帧。接收方通告它们准备在流上以及整个连接中接收多少个八位位组。这是基于信用的方案。 3.流量控制是方向性的，由接收器提供总体控制。接收者可以选择设置每个流和整个连接所需的任何窗口大小。发送方必须遵守接收方施加的流量控制限制。客户端，服务器，并且中介都独立地将其流控制窗口作为接收者进行广告发布，并在发送时遵守其对等方设置的流控制限制。 4.对于新流和整个连接，流控制窗口的初始值为65,535个八位位组。 5.帧类型确定流控制是否适用于帧。在本文档中指定的帧中，仅DATA帧受流控制；仅在DATA帧中受流控制。所有其他帧类型都不会在广告流控制窗口中占用空间。这确保了重要的控制框架不会被流量控制所阻塞。 6.无法禁用流量控制。 7. HTTP / 2仅定义WINDOW_UPDATE框架的格式和语义（新流和整个连接的535个八位位组。 5.帧类型确定流控制是否适用于帧。在本文档中指定的帧中，仅DATA帧受流控制；仅在DATA帧中受流控制。所有其他帧类型都不会在广告流控制窗口中占用空间。这确保了重要的控制框架不会被流量控制所阻塞。 6.无法禁用流量控制。 7. HTTP / 2仅定义WINDOW_UPDATE框架的格式和语义（新流和整个连接的535个八位位组。 5.帧类型确定流控制是否适用于帧。在本文档中指定的帧中，仅DATA帧受流控制；仅在DATA帧中受流控制。所有其他帧类型都不会在广告流控制窗口中占用空间。这确保了重要的控制框架不会被流量控制所阻塞。 6.无法禁用流量控制。 7. HTTP / 2仅定义WINDOW_UPDATE框架的格式和语义（流量控制无法禁用。 7. HTTP / 2仅定义WINDOW_UPDATE框架的格式和语义（流量控制无法禁用。 7. HTTP / 2仅定义WINDOW_UPDATE框架的格式和语义（&lt;a href=&quot;#section-6.9&quot;&gt;6.9节&lt;/a&gt;）。该文件没有规定接收者如何决定何时发送该帧或它发送的值，也没有规定发送者如何选择发送分组。实现者可以选择任何适合其需求的算法。实现还负责管理如何基于优先级发送请求和响应，选择如何避免对请求的行头阻塞以及管理新流的创建。这些算法的选择可以与任何流控制算法交互。</target>
        </trans-unit>
        <trans-unit id="a496c90d2f1f8118ed8e04e7a7acf8027e245b96" translate="yes" xml:space="preserve">
          <source>HTTP/3 - HTTP over QUIC</source>
          <target state="translated">HTTP/3-QUIC上的HTTP</target>
        </trans-unit>
        <trans-unit id="2e6205295940162ec6f356951c335bcb251f4584" translate="yes" xml:space="preserve">
          <source>HTTPS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTPS &lt;em&gt;主机：端口&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b1b03288626a4932189c45619afd52b616640ff" translate="yes" xml:space="preserve">
          <source>Handling CORS on the server (Java example)</source>
          <target state="translated">在服务器上处理CORS(Java示例)</target>
        </trans-unit>
        <trans-unit id="76ccff916d0696e0db6e0e63211aa5d404b177bb" translate="yes" xml:space="preserve">
          <source>Handshake</source>
          <target state="translated">Handshake</target>
        </trans-unit>
        <trans-unit id="ef63c9de46b2633531f80d09b249c8177fb13159" translate="yes" xml:space="preserve">
          <source>Header field name:  SLUG

   Applicable protocol:  http [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]

   Status:  standard.

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force

   Specification document(s):  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Related information:  None.</source>
          <target state="translated">标头字段名称：SLUG适用协议：http [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]状态：标准。作者/变更控制者：IETF（iesg@ietf.org）互联网工程任务组规范文档： &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;。相关信息：无。</target>
        </trans-unit>
        <trans-unit id="16c88366423875ffcd832b0568164659af366f76" translate="yes" xml:space="preserve">
          <source>Header field name: DAV

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：DAV适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.1&quot;&gt;第10.1节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0a425ee275ccc8dc88e573145d9bc8f251db402b" translate="yes" xml:space="preserve">
          <source>Header field name: Depth

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：深度适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.2&quot;&gt;第10.2节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0b05ddbc40717bf61ebce12546f2a61a4a13a71f" translate="yes" xml:space="preserve">
          <source>Header field name: Destination

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.3&quot;&gt;Section 10.3&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：Destination适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.3&quot;&gt;第10.3节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="80f31a912be49327cab8cfb0f3ab988e1efad182" translate="yes" xml:space="preserve">
          <source>Header field name: If

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.4&quot;&gt;Section 10.4&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：如果适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.4&quot;&gt;第10.4节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="405cc2ed9285599fe7b4ed659f2f3efef397c235" translate="yes" xml:space="preserve">
          <source>Header field name: Lock-Token

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：Lock-Token适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.5&quot;&gt;第10.5节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0ef45169928c0bea57455212198061a9ab1aac96" translate="yes" xml:space="preserve">
          <source>Header field name: Overwrite

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.6&quot;&gt;Section 10.6&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：覆盖适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.6&quot;&gt;第10.6节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="ebc42438bb349fc70f9ce54ef8a83a2205114a92" translate="yes" xml:space="preserve">
          <source>Header field name: Timeout

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：超时适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.7&quot;&gt;第10.7节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4ab8eed7600b67916da46088b86ba4f2a325716b" translate="yes" xml:space="preserve">
          <source>Header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new
   semantics, nor on the number of header fields used in a given
   message.  Existing fields are defined in each part of this
   specification and in many other specifications outside this document
   set.

   New header fields can be defined such that, when they are understood
   by a recipient, they might override or enhance the interpretation of
   previously defined header fields, define preconditions on request
   evaluation, or refine the meaning of responses.

   A proxy MUST forward unrecognized header fields unless the field-name
   is listed in the Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) or the proxy
   is specifically configured to block, or otherwise transform, such
   fields.  Other recipients SHOULD ignore unrecognized header fields.
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.

   All defined header fields ought to be registered with IANA in the
   &quot;Message Headers&quot; registry, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;Section&amp;nbsp;8.3 of [RFC7231]&lt;/a&gt;.</source>
          <target state="translated">标头字段是完全可扩展的：对引入新的字段名（每个假定都定义了新的语义）没有限制，也没有对给定消息中使用的标头字段的数量的限制。在本规范的每个部分以及本文档集之外的许多其他规范中定义了现有字段。可以定义新的标头字段，以便当接收者理解它们时，它们可以覆盖或增强对先前定义的标头字段的解释，在请求评估时定义前提条件，或完善响应的含义。代理必须转发无法识别的头字段，除非在连接头字段中列出了字段名称（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节）&lt;/a&gt;）或代理专门配置为阻止或以其他方式转换此类字段。其他接收者应该忽略无法识别的头域。这些要求允许HTTP的功能得到增强，而无需事先更新已部署的中介程序。如&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;[RFC7231]的8.3节中&lt;/a&gt;所述，所有定义的标头字段都应在&amp;ldquo;消息标头&amp;rdquo;注册表中向IANA注册。</target>
        </trans-unit>
        <trans-unit id="a40e00de254d23c5e44ccdfe307162d5d4ecbef3" translate="yes" xml:space="preserve">
          <source>Header fields are key:value pairs that can be used to communicate
   data about the message, its payload, the target resource, or the
   connection (i.e., control data).  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt; for a
   general definition of header field syntax in HTTP messages.

   The requirements for header field names are defined in [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Authors of specifications defining new fields are advised to keep the
   name as short as practical and not to prefix the name with &quot;X-&quot;
   unless the header field will never be used on the Internet.  (The
   &quot;X-&quot; prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions
   inside proprietary software or intranet processing, since the prefix
   would ensure that private names never collide with a newly registered
   Internet name; see [&lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt;] for further information).

   New header field values typically have their syntax defined using
   ABNF ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;]), using the extension defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt; as necessary, and are usually constrained to the range of
   US-ASCII characters.  Header fields needing a greater range of
   characters can use an encoding such as the one defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt;].

   Leading and trailing whitespace in raw field values is removed upon
   field parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;Section&amp;nbsp;3.2.4 of [RFC7230]&lt;/a&gt;).  Field definitions where
   leading or trailing whitespace in values is significant will have to
   use a container syntax such as quoted-string (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;Section&amp;nbsp;3.2.6 of
   [RFC7230]&lt;/a&gt;).

   Because commas (&quot;,&quot;) are used as a generic delimiter between
   field-values, they need to be treated with care if they are allowed
   in the field-value.  Typically, components that might contain a comma
   are protected with double-quotes using the quoted-string ABNF
   production.

   For example, a textual date and a URI (either of which might contain
   a comma) could be safely carried in field-values like these:

     Example-URI-Field: &quot;http://example.com/a.html,foo&quot;,
                        &quot;http://without-a-comma.example.com/&quot;
     Example-Date-Field: &quot;Sat, 04 May 1996&quot;, &quot;Wed, 14 Sep 2005&quot;

   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside
   double-quotes will likely cause unnecessary confusion. 

   Many header fields use a format including (case-insensitively) named
   parameters (for instance, Content-Type, defined in &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;).
   Allowing both unquoted (token) and quoted (quoted-string) syntax for
   the parameter value enables recipients to use existing parser
   components.  When allowing both forms, the meaning of a parameter
   value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;).

   Authors of specifications defining new header fields are advised to
   consider documenting:

   o  Whether the field is a single value or whether it can be a list
      (delimited by commas; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;).

      If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would be
      to ignore the field, but this might not always be the right
      choice).

      Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax.  A robust format
      enables recipients to discover these situations (good example:
      &quot;Content-Type&quot;, as the comma can only appear inside quoted
      strings; bad example: &quot;Location&quot;, as a comma can occur inside a
      URI).

   o  Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.

   o  Whether the field should be stored by origin servers that
      understand it upon a PUT request.

   o  Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.

   o  Whether it is appropriate to list the field-name in the Connection
      header field (i.e., if the header field is to be hop-by-hop; see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;).

   o  Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value. 

   o  Whether it is appropriate to list the field-name in a Vary
      response header field (e.g., when the request header field is used
      by an origin server's content selection algorithm; see
      &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;).

   o  Whether the header field is useful or allowable in trailers (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt;).

   o  Whether the header field ought to be preserved across redirects.

   o  Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.</source>
          <target state="translated">标头字段是key：value对，可用于传达有关消息，其有效负载，目标资源或连接的数据（即控制数据）。有关HTTP消息&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;中标&lt;/a&gt;头字段语法的一般定义，请参见[RFC7230]的3.2节。标头字段名称的要求在[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]。建议定义新字段的规范作者将名称保持尽可能短，并且不要在名称前加上&amp;ldquo; X-&amp;rdquo;，除非标题字段永远不会在Internet上使用。 （&amp;ldquo; X-&amp;rdquo;前缀习语在实践中已被广泛使用；它仅用作避免专有软件或Intranet处理内部名称冲突的机制，因为该前缀将确保私人名称不会与新注册的域名冲突。互联网名称；有关更多信息，请参见[ &lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ]。通常，使用&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]第7节中&lt;/a&gt;定义的扩展名，使用ABNF（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ]）定义新的标头字段值的语法根据需要，通常限制在US-ASCII字符范围内。需要更大范围字符的标头字段可以使用一种编码，例如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt; ]中定义的编码。原始字段值中的前导和尾随空格在字段解析时被删除（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;[RFC7230]的第3.2.4节&lt;/a&gt;）。值的前导或尾随空格很重要的字段定义将必须使用容器语法，例如带引号的字符串（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230的第3.2.6节]&lt;/a&gt;）。由于逗号（&amp;ldquo;，&amp;rdquo;）用作字段值之间的通用定界符，因此，如果在字段值中允许使用逗号，则必须谨慎对待。通常，使用引号字符串ABNF生成用双引号保护可能包含逗号的组件。例如，可以在以下字段值中安全地携带文本日期和URI（两者中都可能包含逗号）：Example-URI-Field：&amp;ldquo; http://example.com/a.html,foo&amp;rdquo; ，&amp;ldquo; http://without-a-comma.example.com/&amp;rdquo; Example-Date-Field：&amp;ldquo; 1996年5月4日星期六&amp;rdquo;，&amp;ldquo; 2005年9月14日星期三&amp;rdquo;。请注意，双引号分隔符几乎总是与引号产生在双引号中使用其他语法可能会引起不必要的混乱。许多标头字段使用的格式包括（不区分大小写）命名参数（例如Content-Type，在&lt;a href=&quot;#section-3.1.1.5&quot;&gt;第3.1.1.5节&lt;/a&gt;）。同时允许参数值使用无引号（令牌）和带引号（字符串）的语法，使收件人可以使用现有的解析器组件。当允许两种形式时，参数值的含义应独立于其所使用的语法（例如，请参阅&lt;a href=&quot;#section-3.1.1.1&quot;&gt;第3.1.1.1节中&lt;/a&gt;有关媒体类型的参数处理的注释 ）。建议定义新标题字段的规范作者考虑编写文档：o该字段是单个值还是它可以是列表（以逗号分隔；请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]的3.2节）&lt;/a&gt;）。如果不使用列表语法，请记录如何处理该字段多次出现的消息（明智的默认选择是忽略该字段，但这并不总是正确的选择）。请注意，尽管字段的定义不允许使用列表语法，但中介程序和软件库可能会将多个标头字段实例组合为一个实例。健壮的格式使收件人能够发现这些情况（很好的例子：&amp;ldquo; Content-Type&amp;rdquo;，因为逗号只能出现在加引号的字符串内；不好的例子：&amp;ldquo; Location&amp;rdquo;，因为逗号可以出现在URI内）。 o在什么条件下可以使用标题字段；例如，仅在响应或请求中，在所有消息中，仅在对特定请求方法的响应中，等等。o是否应由理解PUT请求的原始服务器存储该字段。 o是否通过上下文（例如通过现有的请求方法或状态代码）进一步完善字段语义。 o在&amp;ldquo;连接&amp;rdquo;标题字段中列出字段名称是否合适（即，如果标题字段是逐跳的，请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]的6.1节&lt;/a&gt;）。 o在什么条件下允许中介插入，删除或修改字段的值。 o是否适合在Vary响应头字段中列出字段名称（例如，当源服务器的内容选择算法使用请求头字段时；请参见 &lt;a href=&quot;#section-7.1.4&quot;&gt;第7.1.4节&lt;/a&gt;）。 o标头字段在拖车中是有用的还是允许的（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;[RFC7230]的4.1节&lt;/a&gt;）。 o标头字段是否应在重定向中保留。 o是否引入了任何其他安全方面的考虑，例如与隐私相关的数据的披露。</target>
        </trans-unit>
        <trans-unit id="73ce89b0c8df0a7ed4d98060b2c7c611ac330135" translate="yes" xml:space="preserve">
          <source>Header fields that regulate the use of trailers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; (requests) and &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt; (responses).</source>
          <target state="translated">规范拖车使用的标头字段：&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;（请求）和&lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;（响应）。</target>
        </trans-unit>
        <trans-unit id="e786c2ccea456dd4299b1abe9aaa7e4b2aa14b90" translate="yes" xml:space="preserve">
          <source>Header to indicate that the content served varies by &lt;code&gt;Save-Data&lt;/code&gt;: &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">标头，表明所提供的内容因 &lt;code&gt;Save-Data&lt;/code&gt; 而异：&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf858dd7754f89623471d452d85365f43194c795" translate="yes" xml:space="preserve">
          <source>Header type</source>
          <target state="translated">标题类型</target>
        </trans-unit>
        <trans-unit id="2e31dbd5f484d5c1a3e787a044871e878213d50e" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">内容协商结果的标题：&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e46dedc85812b44c40eda61d963afafe6e17ec8" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">内容协商结果的标题：&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04db11046ac45baaf2858c147c0d0da0d83dfe2b" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">内容协商结果的标题：&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="d43cdd47172ebbec83d46dc0929904cbc0e5ba83" translate="yes" xml:space="preserve">
          <source>Headers are often very similar from one message to the next one, yet still repeated across connections.</source>
          <target state="translated">头部信息往往从一个信息到下一个信息非常相似,但在不同的连接中仍然重复。</target>
        </trans-unit>
        <trans-unit id="b9f5a636b75216c81304804a9a45004630234515" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt; handle them:</source>
          <target state="translated">标头也可以根据&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;代理&lt;/a&gt;处理方式进行分组：</target>
        </trans-unit>
        <trans-unit id="953e087d7da0e93f2114e33931a9fff08ea7dde9" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how proxies handle them:</source>
          <target state="translated">标题也可以根据代理的处理方式进行分组。</target>
        </trans-unit>
        <trans-unit id="7e731d99aaf73e73a84db12018da22acb10f8eaf" translate="yes" xml:space="preserve">
          <source>Headers can be grouped according to their contexts:</source>
          <target state="translated">可以根据上下文对标题进行分组。</target>
        </trans-unit>
        <trans-unit id="62484b23e54725c71a2263f18277c31549662db4" translate="yes" xml:space="preserve">
          <source>Headers, unlike bodies, are uncompressed.</source>
          <target state="translated">头部与主体不同,是没有压缩的。</target>
        </trans-unit>
        <trans-unit id="75afc7047fc121a2847ce8f1120ed041aca66234" translate="yes" xml:space="preserve">
          <source>Help Your Users `Save-Data` - CSS Tricks</source>
          <target state="translated">帮助你的用户 &quot;保存数据&quot;--CSS的技巧</target>
        </trans-unit>
        <trans-unit id="5da9db7ae87281e3e1ab3c768b9be45ae8134d50" translate="yes" xml:space="preserve">
          <source>Helpful tools and resources for understanding and debugging HTTP.</source>
          <target state="translated">有助于理解和调试HTTP的工具和资源。</target>
        </trans-unit>
        <trans-unit id="2ed70bbb1a3a5c498b113f52c1548cee8ea9cc2d" translate="yes" xml:space="preserve">
          <source>Here again, be sure to take the right token for the browser you are looking for, as there is no guarantee that others will contain a valid number.</source>
          <target state="translated">这里再次强调一下,一定要拿对你要找的浏览器的令牌,因为不能保证其他的浏览器会包含一个有效的号码。</target>
        </trans-unit>
        <trans-unit id="d5227ab359118de929fda02e4ed8472790aeba2d" translate="yes" xml:space="preserve">
          <source>Here is a JavaScript regular expression that will detect all mobile devices, including devices with a device id in their UA string:</source>
          <target state="translated">这里是一个JavaScript正则表达式,它将检测所有移动设备,包括UA字符串中带有设备id的设备。</target>
        </trans-unit>
        <trans-unit id="4e3866c880875ee1ff8235362e89c76b5139a9ee" translate="yes" xml:space="preserve">
          <source>Here is a list of MIME types, associated by type of documents, ordered by their common extensions.</source>
          <target state="translated">这里是一个MIME类型的列表,按文档类型相关联,按其常用扩展名排序。</target>
        </trans-unit>
        <trans-unit id="d20b00cd2016c9a232dbd3f29c2f2897e9fcffac" translate="yes" xml:space="preserve">
          <source>Here is a list of common features controllable with HTTP.</source>
          <target state="translated">以下是HTTP可以控制的常见功能列表。</target>
        </trans-unit>
        <trans-unit id="5c9905f596ccef64e1269e49689d1a73c07dd5b6" translate="yes" xml:space="preserve">
          <source>Here is a sample exchange between client and server:</source>
          <target state="translated">下面是一个客户端和服务器之间的交流示例。</target>
        </trans-unit>
        <trans-unit id="9501e397bcbf8b4862fe537468cb6a0753bdae2b" translate="yes" xml:space="preserve">
          <source>Here is an example in PHP of handling a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;preflighted request&lt;/a&gt;:</source>
          <target state="translated">这是PHP中处理&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;预检请求&lt;/a&gt;的示例：</target>
        </trans-unit>
        <trans-unit id="75207f8e8ffefa8d462dd3fb2a1a65ea217d704b" translate="yes" xml:space="preserve">
          <source>Here is an example of the Slug header that uses percent-encoding to
   represent the Unicode character U+00E8 (LATIN SMALL LETTER E WITH
   GRAVE):

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Content-Type: image/png
       Slug: The Beach at S%C3%A8te
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   See &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt; for an example of the Slug header applied to the
   creation of an Entry Resource.</source>
          <target state="translated">以下是Slug标头的示例，该标头使用百分比编码来表示Unicode字符U + 00E8（带有GRAVE的拉丁文小写字母E）：POST / myblog / entries HTTP / 1.1主机：example.org内容类型：image / png Slug：位于S％C3％A8te的海滩授权：Basic ZGFmZnk6c2VjZXJldA == Content-Length：nnn ...二进制数据有关应用于创建条目资源的Slug标头的示例，请参见&lt;a href=&quot;#section-9.2.1&quot;&gt;第9.2.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2797fafb9211cc2c051dcda055704a3e4e30b8b0" translate="yes" xml:space="preserve">
          <source>Here is an example of this process with a shared cache proxy:</source>
          <target state="translated">下面是一个使用共享缓存代理的过程的例子。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="ef5dd834bb2835bdbfb70e682c19ccc9767516af" translate="yes" xml:space="preserve">
          <source>Here is some PHP that handles credentialed requests:</source>
          <target state="translated">下面是一些处理凭证式请求的PHP。</target>
        </trans-unit>
        <trans-unit id="8ef8c73e17b07ff09f65fb9ccc55b532e81935c5" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">在这里，我们介绍了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;标头的最常用用例。</target>
        </trans-unit>
        <trans-unit id="a21888f07518ae7a0759573f20d4642440f36a52" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;code&gt;Upgrade&lt;/code&gt; header.</source>
          <target state="translated">在这里，我们介绍了 &lt;code&gt;Upgrade&lt;/code&gt; 标头的最常用用例。</target>
        </trans-unit>
        <trans-unit id="9ab6627dc7da6cad243b3faca054a977b46dce0f" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server (in addition to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt;).</source>
          <target state="translated">这是一个 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 标头可能看起来的示例。它指示对服务器的CORS请求（除了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS安全列出的请求标头之外&lt;/a&gt;）还支持名为 &lt;code&gt;X-Custom-Header&lt;/code&gt; 的自定义标头。</target>
        </trans-unit>
        <trans-unit id="f377abe687f3f604805ed4c41cf044b1a5eecca7" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that in addition to the &quot;simple&quot; headers, a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server.</source>
          <target state="translated">这是一个 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 标头可能看起来的示例。它指示除了&amp;ldquo;简单&amp;rdquo;标头之外，对服务器的CORS请求还支持名为 &lt;code&gt;X-Custom-Header&lt;/code&gt; 的自定义标头。</target>
        </trans-unit>
        <trans-unit id="29ece426131fe65594c0f74862a88481dffe1b6d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is the authentication scheme (&quot;Basic&quot; is the most common scheme and &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;introduced below&lt;/a&gt;). The &lt;em&gt;realm&lt;/em&gt; is used to describe the protected area or to indicate the scope of protection. This could be a message like &quot;Access to the staging site&quot; or similar, so that the user knows to which space they are trying to get access to.</source>
          <target state="translated">在这里， &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 是身份验证方案（&amp;ldquo; Basic&amp;rdquo;是最常见的方案，&lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;下面介绍&lt;/a&gt;）。该&lt;em&gt;领域&lt;/em&gt;用于描述保护区域或指示保护范围。这可能是一条消息，例如&amp;ldquo;访问登台站点&amp;rdquo;或类似消息，以便用户知道他们试图访问的空间。</target>
        </trans-unit>
        <trans-unit id="eb29f0c2d2f88776ddd04a11566426842fc746ff" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;base64EncodedSettings&lt;/code&gt; is an HTTP/2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; frame's payload which has been base64url encoded and all trailing &lt;code&gt;&quot;=&quot;&lt;/code&gt; (equals) characters removed in order to safely include it in this textual header format.</source>
          <target state="translated">在这里， &lt;code&gt;base64EncodedSettings&lt;/code&gt; 是HTTP / 2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; 帧的有效负载，已经对其进行了base64url编码，并删除了所有尾随的 &lt;code&gt;&quot;=&quot;&lt;/code&gt; （等于）字符，以便将其安全地包含在此文本标头格式中。</target>
        </trans-unit>
        <trans-unit id="a17f358e1ad5338444563c68bbadc2878e955302" translate="yes" xml:space="preserve">
          <source>Here, &lt;em&gt;x.y&lt;/em&gt; is the version of Mac OS X (for instance, Mac OS X 10.6).</source>
          <target state="translated">在此，&lt;em&gt;xy&lt;/em&gt;是Mac OS X的版本（例如，Mac OS X 10.6）。</target>
        </trans-unit>
        <trans-unit id="ef77ad6909e7752d9aa6373842d49849209611c6" translate="yes" xml:space="preserve">
          <source>Here, by default, content is only permitted from the document's origin, with the following exceptions:</source>
          <target state="translated">在这里,默认情况下,只允许来自文档源头的内容,但有以下例外。</target>
        </trans-unit>
        <trans-unit id="fa2977eeb67774d5a0dd09ff4ec5ec0a36ef8155" translate="yes" xml:space="preserve">
          <source>Here, we present three scenarios that illustrate how Cross-Origin Resource Sharing works. All of these examples use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; object, which can be used to make cross-site invocations in any supporting browser.</source>
          <target state="translated">在这里，我们提出了三种方案，说明了跨域资源共享的工作方式。所有这些示例都使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;对象，该对象可用于在任何支持的浏览器中进行跨站点调用。</target>
        </trans-unit>
        <trans-unit id="b282bf1d7028f07f3c3e1a14dbfcb71697111c5d" translate="yes" xml:space="preserve">
          <source>Heroku's proxy library Vegur</source>
          <target state="translated">Heroku的代理库Vegur</target>
        </trans-unit>
        <trans-unit id="ddf9efd09112f93ec00fa54e8c4c84c765c17139" translate="yes" xml:space="preserve">
          <source>Heuristic Expiration</source>
          <target state="translated">启发式到期时间</target>
        </trans-unit>
        <trans-unit id="f2bddb211b435d77bdcd54be12a624bcbd764aed" translate="yes" xml:space="preserve">
          <source>Heuristic freshness checking</source>
          <target state="translated">启发式新鲜度检查</target>
        </trans-unit>
        <trans-unit id="1724e0bfe29683a06f3fb0d140956360664db86b" translate="yes" xml:space="preserve">
          <source>Historic specification of HTTP State Management Mechanism, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;</source>
          <target state="translated">HTTP状态管理机制的历史性规范，&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;已废弃</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="d2fc15fa26334cc66ab95bf51b30e486fe93e127" translate="yes" xml:space="preserve">
          <source>History Lists (RFC 7234)</source>
          <target state="translated">历史列表(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="2b89425faff6de6dc314db782d45b8bad9965067" translate="yes" xml:space="preserve">
          <source>History and implementation</source>
          <target state="translated">历史和实施</target>
        </trans-unit>
        <trans-unit id="8224b406bb9fcf1d12ea7ebecf7258a153c52d79" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression</source>
          <target state="translated">逐跳压缩</target>
        </trans-unit>
        <trans-unit id="77f5c2d41f116e38295977a86465e5e9e801702a" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression, though similar to end-to-end compression, differs by one fundamental element: the compression doesn't happen on the resource in the server, creating a specific representation that is then transmitted, but on the body of the message between any two nodes on the path between the client and the server. Connections between successive intermediate nodes may apply a &lt;em&gt;different&lt;/em&gt; compression.</source>
          <target state="translated">逐跳压缩虽然与端到端压缩相似，但有一个基本元素的不同：压缩不会在服务器中的资源上发生，而是创建一种特定的表示形式，然后在主体上进行传输客户端和服务器之间路径上任何两个节点之间的消息。连续的中间节点之间的连接可以应用&lt;em&gt;不同的&lt;/em&gt;压缩。</target>
        </trans-unit>
        <trans-unit id="78458c6f2f912b6d6875b5a660931222e51353f1" translate="yes" xml:space="preserve">
          <source>Hop-by-hop headers</source>
          <target state="translated">逐跳标题</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="f3680c389a985b1c29ff7e674003c4ba66aee02b" translate="yes" xml:space="preserve">
          <source>Host (RFC 2616)</source>
          <target state="translated">主机(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="5406f06c65b376c58dac6bf71408ae1944750e32" translate="yes" xml:space="preserve">
          <source>Host names and ports of reverse proxies (load balancers, CDNs) may differ from the origin server handling the request, in that case the &lt;code&gt;X-Forwarded-Host&lt;/code&gt; header is useful to determine which Host was originally used.</source>
          <target state="translated">反向代理的主机名和端口（负载平衡器，CDN）可能与处理请求的原始服务器不同，在这种情况下， &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 标头可用于确定最初使用的主机。</target>
        </trans-unit>
        <trans-unit id="f4b4c2643126c467ddef65e6b67d5f8c8b5bdc1a" translate="yes" xml:space="preserve">
          <source>Host to which the cookie will be sent.</source>
          <target state="translated">发送cookie的主机。</target>
        </trans-unit>
        <trans-unit id="34a6082579e4930c27da3887804287a2a53f1624" translate="yes" xml:space="preserve">
          <source>Host-specific file names</source>
          <target state="translated">主机专用文件名</target>
        </trans-unit>
        <trans-unit id="2ec76d41d987ae559f5e3a7f7fd514508f4dcf54" translate="yes" xml:space="preserve">
          <source>Hosted CSP reporting for HTTPS migrations</source>
          <target state="translated">托管的CSP报告,用于HTTPS迁移。</target>
        </trans-unit>
        <trans-unit id="1367a4331a65542cf39c8a9d5b8961997d49502b" translate="yes" xml:space="preserve">
          <source>Hostname based conditions</source>
          <target state="translated">基于主机名的条件</target>
        </trans-unit>
        <trans-unit id="39e32117a3b52cca1d492b875f026756fb25597f" translate="yes" xml:space="preserve">
          <source>How Browsers Work</source>
          <target state="translated">浏览器如何工作</target>
        </trans-unit>
        <trans-unit id="4c91ae122f1612df59f2a23941f9e79f1d970ecc" translate="yes" xml:space="preserve">
          <source>How cookies work is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;. When serving an HTTP request, a server can send a &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP header with the response. The client then returns the cookie's value with every request to the same server in the form of a &lt;code&gt;Cookie&lt;/code&gt; request header. The cookie can also be set to expire on a certain date, or restricted to a specific domain and path.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;定义了cookie的工作方式。在处理HTTP请求时，服务器可以发送带有响应的 &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP标头。然后，客户端将每个请求的Cookie值以 &lt;code&gt;Cookie&lt;/code&gt; 请求标头的形式返回给同一服务器。也可以将Cookie设置为在特定日期过期，或将其限制为特定的域和路径。</target>
        </trans-unit>
        <trans-unit id="326d6840506a3e0e685440ecd35aff457aa45373" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies and clients, about what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">文档的缓存方式可以由HTTP来控制。服务器可以指示代理和客户端,关于要缓存的内容和多长时间。客户端可以指示中间的缓存代理忽略存储的文档。</target>
        </trans-unit>
        <trans-unit id="785a4091642b3107a87eb0510aa18c744ad3bd77" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies, and clients, what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">如何缓存文件可以通过HTTP来控制。服务器可以指示代理和客户端缓存什么以及缓存多长时间。客户端可以指示中间的缓存代理忽略存储的文档。</target>
        </trans-unit>
        <trans-unit id="9a92fcc6dda054aa8ba041f16e995c47ecf3e087" translate="yes" xml:space="preserve">
          <source>How much detail to include is an interesting balance to strike; exposing the OS version is probably a bad idea, as mentioned in the earlier warning about overly-detailed values. However, exposed Apache versions helped browsers work around a bug those versions had with &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; combined with &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要包含多少细节是一个有趣的平衡点。公开操作系统版本可能不是一个好主意，如先前有关过高的值的警告中所述。但是，公开的Apache版本可以帮助浏览器解决&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;结合使用的错误。</target>
        </trans-unit>
        <trans-unit id="f1a6840353bc46a78f9536e0c4ba600c96425f56" translate="yes" xml:space="preserve">
          <source>How the browser handles it</source>
          <target state="translated">浏览器如何处理</target>
        </trans-unit>
        <trans-unit id="68bee7ceae58ef9dd68bebd7e8624e01362fe458" translate="yes" xml:space="preserve">
          <source>How to Fix 405 Method Not Allowed</source>
          <target state="translated">如何解决405方法不允许的问题</target>
        </trans-unit>
        <trans-unit id="d2bbcaa9a058613fa1a50456a0aabfa3b3df0140" translate="yes" xml:space="preserve">
          <source>How to avoid the CORS preflight</source>
          <target state="translated">如何避免CORS预检</target>
        </trans-unit>
        <trans-unit id="778498eaac84dd627c8fe8e2869a7fc961933c44" translate="yes" xml:space="preserve">
          <source>How to fix &lt;em&gt;&amp;ldquo;Access-Control-Allow-Origin header must not be the wildcard&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">如何解决&lt;em&gt;&amp;ldquo; Access-Control-Allow-Origin标头不能为通配符&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc108c55cd0ff984c9ac45ce8cdb74f88f1a0654" translate="yes" xml:space="preserve">
          <source>How to fix CORS issue?</source>
          <target state="translated">如何解决CORS问题?</target>
        </trans-unit>
        <trans-unit id="c305fbaf8d1dd662dd884c22cf15416371345003" translate="yes" xml:space="preserve">
          <source>How to run Chrome browser without CORS</source>
          <target state="translated">如何在没有CORS的情况下运行Chrome浏览器</target>
        </trans-unit>
        <trans-unit id="bd427ecf132d3e2cc23ee42d32690dc605d28a0f" translate="yes" xml:space="preserve">
          <source>How to use a CORS proxy to get around &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">如何使用CORS代理避开&lt;em&gt;&amp;ldquo; No Access-Control-Allow-Origin标头&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f79e53c0a139eb96378c7ba89f9dd8fbfb330c0" translate="yes" xml:space="preserve">
          <source>However, if the request is one that triggers a preflight due to the presence of the &lt;code&gt;Authorization&lt;/code&gt; header in the request, you won&amp;rsquo;t be able to work around the limitation using the steps above. And you won&amp;rsquo;t be able to work around it at all unless you have control over the server the request is being made to.</source>
          <target state="translated">但是，如果请求是由于请求中存在 &lt;code&gt;Authorization&lt;/code&gt; 标头而触发预检的请求，则无法使用上述步骤来解决限制。除非您可以控制请求的服务器，否则您将根本无法解决它。</target>
        </trans-unit>
        <trans-unit id="aa3bacea776742f9f4ee0b04c2738bf1f2acd22e" translate="yes" xml:space="preserve">
          <source>However, scripts without integrity won't load anymore:</source>
          <target state="translated">但是,没有完整性的脚本将无法再加载。</target>
        </trans-unit>
        <trans-unit id="4784e9a56ee26ccc58e9b47e0384d44d80f5b536" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via JavaScript:</source>
          <target state="translated">但是，不会阻止直接在元素的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt;属性上设置的styles属性，从而允许用户通过JavaScript安全地操作样式：</target>
        </trans-unit>
        <trans-unit id="6363c2d9cd37774dbf6ea52a71d3cc4b1d69edf1" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via Javascript:</source>
          <target state="translated">但是，不会阻止直接在元素的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt;属性上设置的styles属性，从而允许用户通过Javascript安全地操作样式：</target>
        </trans-unit>
        <trans-unit id="712efc901d5948d1ddc85420dd7828b2c028e889" translate="yes" xml:space="preserve">
          <source>However, the above code is absolutely terrible and ill-conceived. What if Chrome removes this look behind feature? What if another browser implements look behind regexps? What if another browser uses &lt;em&gt;Chrome &lt;/em&gt;in their user agent string? The list goes on and on of things that could go terribly wrong. Thus, you should instead use feature detection like the following.</source>
          <target state="translated">但是，上面的代码绝对是糟糕透顶的。如果Chrome删除了此后视功能，该怎么办？如果另一个浏览器实现了正则表达式后面的东西怎么办？如果其他浏览&lt;em&gt;器&lt;/em&gt;在其用户代理字符串中使用&lt;em&gt;Chrome&lt;/em&gt;，该怎么办？清单不断地列出可能出错的事情。因此，您应该改为使用如下所示的特征检测。</target>
        </trans-unit>
        <trans-unit id="3e339ee7e7a8e7da017468304e92dc515e180b71" translate="yes" xml:space="preserve">
          <source>However, this won't wildcard the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header, so if you need to expose that, you will need to list it explicitly:</source>
          <target state="translated">但是，这不会通配&lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;标头，因此，如果需要公开它，则需要明确列出它：</target>
        </trans-unit>
        <trans-unit id="343d2ce245a31249b1c892a011a302e47c95d5d0" translate="yes" xml:space="preserve">
          <source>Http method &lt;a href=&quot;../methods/patch&quot;&gt;&lt;code&gt;PATCH&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Http方法&lt;a href=&quot;../methods/patch&quot;&gt; &lt;code&gt;PATCH&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="acb4f9f51d2117c863cd7510741572ef29c65c1c" translate="yes" xml:space="preserve">
          <source>Http method &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Http方法&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="872b5517c0f6559afa3677ba893bb97024b2ecc2" translate="yes" xml:space="preserve">
          <source>HttpOnly Optional</source>
          <target state="translated">HttpOnly 可选</target>
        </trans-unit>
        <trans-unit id="abd954b086bab88cb87ec4cda040e14953ecce8f" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</source>
          <target state="translated">超文本咖啡壶控制协议(HTCPCP/1.0)</target>
        </trans-unit>
        <trans-unit id="9cb22c4629a969af0720c560a54790780d479542" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0): Semantics and Content</source>
          <target state="translated">超文本咖啡壶控制协议(HTCPCP/1.0)。语义和内容</target>
        </trans-unit>
        <trans-unit id="126116b4ff4ad54a45b5f2a945491694cc39450d" translate="yes" xml:space="preserve">
          <source>Hyper text transfer protocol (Secure)</source>
          <target state="translated">超文本传输协议(安全)</target>
        </trans-unit>
        <trans-unit id="a40ca5dd3664e7e5fbc9868906e198fe122b47b2" translate="yes" xml:space="preserve">
          <source>HyperText Markup Language (HTML)</source>
          <target state="translated">超文本标记语言</target>
        </trans-unit>
        <trans-unit id="3aabdc98f3e181618def85f1876081249a0e4138" translate="yes" xml:space="preserve">
          <source>HyperText Transport Protocol Keep-Alive Header</source>
          <target state="translated">超文本传输协议 Keep-Alive Header</target>
        </trans-unit>
        <trans-unit id="caec6dcaeb81aa6d4af95da6ddc9afca1f3451f8" translate="yes" xml:space="preserve">
          <source>Hypertext Preprocessor (&lt;strong&gt;Personal Home Page&lt;/strong&gt;)</source>
          <target state="translated">超文本预处理器（&lt;strong&gt;个人主页&lt;/strong&gt;）</target>
        </trans-unit>
        <trans-unit id="a8bf740d859a72ca5b146b5d3c7c57e9e44dbdab" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) Keep-Alive Header</source>
          <target state="translated">超文本传输协议(HTTP)Keep-Alive标头</target>
        </trans-unit>
        <trans-unit id="18c750541be3062c47621490bab7ee6a43ed0176" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) clients often encounter
   interrupted data transfers as a result of canceled requests or
   dropped connections.  When a client has stored a partial
   representation, it is desirable to request the remainder of that
   representation in a subsequent request rather than transfer the
   entire representation.  Likewise, devices with limited local storage
   might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or
   the dimensions of an embedded image.

   This document defines HTTP/1.1 range requests, partial responses, and
   the multipart/byteranges media type.  Range requests are an OPTIONAL
   feature of HTTP, designed so that recipients not implementing this
   feature (or not supporting it for the target resource) can respond as
   if it is a normal GET request without impacting interoperability.
   Partial responses are indicated by a distinct status code to not be
   mistaken for full responses by caches that might not implement the
   feature.

   Although the range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.</source>
          <target state="translated">超文本传输协议(HTTP)客户端经常会遇到因取消请求或掉线而导致数据传输中断的情况。当客户端存储了部分表示时,最好在后续请求中请求该表示的剩余部分,而不是传输整个表示。同样,本地存储有限的设备可能会受益于能够只请求一个较大的表示的子集,例如一个非常大的文档的单页,或者一个嵌入式图像的尺寸。本文档定义了HTTP/1.1范围请求、部分响应和multipart/byteranges媒体类型。范围请求是HTTP的一个OPTIONAL特性,目的是让没有实现这个特性(或者目标资源不支持这个特性)的接收者可以像正常的GET请求一样响应,而不影响互操作性。部分响应用一个不同的状态码来表示,以免被可能没有实现该功能的缓存误认为是完全响应。虽然范围请求机制被设计为允许可扩展的范围类型,但本规范只定义了字节范围的请求。</target>
        </trans-unit>
        <trans-unit id="eaebf91177666f1aaca9207bce21f241c2d6aa1c" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Authentication</source>
          <target state="translated">超文本传输协议(HTTP/1.1)。认证</target>
        </trans-unit>
        <trans-unit id="cf04e8c69e3ace21820abada8b4f0bf8440a50a6" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">超文本传输协议(HTTP/1.1):高速缓存。</target>
        </trans-unit>
        <trans-unit id="565eb02fb9f4c2b506e298c3e3bd17146e8b9b29" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</source>
          <target state="translated">超文本传输协议(HTTP/1.1)。有条件的请求</target>
        </trans-unit>
        <trans-unit id="5ffac3f427873675e5fda46ed9caffb674838583" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</source>
          <target state="translated">超文本传输协议(HTTP/1.1):消息语法和路由选择</target>
        </trans-unit>
        <trans-unit id="067dc1d00ea2a2c2813ac9db731d6b354882d326" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</source>
          <target state="translated">超文本传输协议(HTTP/1.1):范围请求。</target>
        </trans-unit>
        <trans-unit id="67726549543e0d1b42d751ebf670ca915f452bde" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</source>
          <target state="translated">超文本传输协议(HTTP/1.1)。语义和内容</target>
        </trans-unit>
        <trans-unit id="dadde9e82bc152463510002167edd8589458e39b" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Context</source>
          <target state="translated">超文本传输协议(HTTP/1.1)。语义和上下文</target>
        </trans-unit>
        <trans-unit id="0464d55671763178e4bb9bf689fd75c3b2bf90ee" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol -- HTTP/1.1</source>
          <target state="translated">超文本传输协议-HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="14001adc995acbe66bc7906c7030f074a23e21ec" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol Version 2 (HTTP/2)</source>
          <target state="translated">超文本传输协议第二版(HTTP/2)</target>
        </trans-unit>
        <trans-unit id="e0899b85bb34ecad597f88ef93fbf5180bd78fc6" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7230)</source>
          <target state="translated">IANA的考虑因素(RFC 7230)</target>
        </trans-unit>
        <trans-unit id="fb05bb988d2b3042dacb51c3209a976e89fd65b7" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7231)</source>
          <target state="translated">IANA的考虑因素(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="faddb1a82ba7e7645aff6b957bbe064fd752dd69" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7232)</source>
          <target state="translated">IANA的考虑因素(RFC 7232)</target>
        </trans-unit>
        <trans-unit id="4cbf2a520cf53d1cedf62323be093a069cfdcece" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7233)</source>
          <target state="translated">IANA的考虑因素(RFC 7233)</target>
        </trans-unit>
        <trans-unit id="2ce28868e82be3265aeb20b44d3fbb587c2a23ce" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7234)</source>
          <target state="translated">IANA的考虑因素(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="98a74c9cf29e82d02e581eb12c22dda292d5ee17" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7235)</source>
          <target state="translated">IANA的考虑因素(RFC 7235)</target>
        </trans-unit>
        <trans-unit id="4bb8022eff5067ab10c4c96ad85499b49bef742d" translate="yes" xml:space="preserve">
          <source>IANA HTTP Range Unit Registry</source>
          <target state="translated">IANA HTTP Range Unit Registry</target>
        </trans-unit>
        <trans-unit id="5904c4ee52524bdc80934ad4f9a7950c63e23ee8" translate="yes" xml:space="preserve">
          <source>IANA has added a reference to this specification in the
   'application/atom+xml' media type registration.</source>
          <target state="translated">IANA在'application/atom+xml'媒体类型注册中增加了对该规范的引用。</target>
        </trans-unit>
        <trans-unit id="69ea11543f5de3dd2cb43742c8f141e34bd0847d" translate="yes" xml:space="preserve">
          <source>IANA is the official registry of MIME media types and maintains a &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;list of all the official MIME types&lt;/a&gt;. This table lists some important MIME types for the Web:</source>
          <target state="translated">IANA是MIME媒体类型的正式注册表，并维护&lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;所有正式MIME类型&lt;/a&gt;的列表。下表列出了一些重要的Web MIME类型：</target>
        </trans-unit>
        <trans-unit id="b9dda3057745eb62f8e6e36a979a88f9f81e3906" translate="yes" xml:space="preserve">
          <source>IANA is the official registry of MIME media types and maintains a &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;list of all the official MIME types&lt;/a&gt;. This table lists some important MIME types for the Web:</source>
          <target state="translated">IANA是MIME媒体类型的正式注册表，并维护&lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;所有正式MIME类型&lt;/a&gt;的列表。下表列出了一些重要的Web MIME类型：</target>
        </trans-unit>
        <trans-unit id="89c07cdbd61e19ece57d06075ba79aecfe00c78b" translate="yes" xml:space="preserve">
          <source>IANA list of URI schemes</source>
          <target state="translated">IANA的URI方案清单</target>
        </trans-unit>
        <trans-unit id="78740b079f8a9346faaa07edbf050f52dc47fc13" translate="yes" xml:space="preserve">
          <source>IANA maintains the &quot;HTTP Content Coding Registry&quot; at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.

   The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">IANA在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护&amp;ldquo; HTTP内容编码注册表&amp;rdquo; 。 &amp;ldquo; HTTP内容编码注册表&amp;rdquo;已通过以下注册进行了更新：+ ------------ + --------------------- ----------------- + --------------- + |姓名|描述参考| + ------------ + ------------------------------------ -+ --------------- + |压缩| UNIX&amp;ldquo;压缩&amp;rdquo;数据格式[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; | |放气&amp;ldquo;压缩&amp;rdquo;压缩数据| &lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt; | | | （[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]）内的&amp;ldquo; zlib&amp;rdquo;数据| | | |格式（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]）| | | gzip | GZIP文件格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; | | x压缩| 不推荐使用（压缩别名）| &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; | | x-gzip | 不推荐使用（gzip的别名）| &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="84da78a91edf6572fec7b32c2d1eaff20d705c9b" translate="yes" xml:space="preserve">
          <source>IANA maintains the &quot;HTTP Content Coding Registry&quot; at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.

   The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">IANA在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护&amp;ldquo; HTTP内容编码注册表&amp;rdquo; 。 &amp;ldquo; HTTP内容编码注册表&amp;rdquo;已通过以下注册进行了更新：+ ------------ + --------------------- ----------------- + --------------- + |姓名|描述参考| + ------------ + ------------------------------------ -+ --------------- + |压缩| UNIX&amp;ldquo;压缩&amp;rdquo;数据格式[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] |&lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt;| |放气&amp;ldquo;压缩&amp;rdquo;压缩数据|&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;| | | （zlib）数据中的（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]）| | | |格式（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt; ]）| | | gzip | GZIP文件格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] |&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt;| | x压缩| 不推荐使用（用于压缩的别名）| &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt;| | x-gzip | 不推荐使用（gzip的别名）| &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt;| + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="2f3aef98e61cefd59e70d51a0d54a7f7880c7e4d" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media
   types &quot;message/http&quot; and &quot;application/http&quot;.  The following has been
   registered with IANA.</source>
          <target state="translated">IANA维护Internet媒体类型[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] 的注册表，网址为&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;。本文档用作Internet媒体类型&amp;ldquo; message / http&amp;rdquo;和&amp;ldquo; application / http&amp;rdquo;的规范。以下内容已在IANA上注册。</target>
        </trans-unit>
        <trans-unit id="57560e1f2062a0d9e41b59e9de0cd89dfc775402" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media type
   &quot;multipart/byteranges&quot;.  The following has been registered with IANA.</source>
          <target state="translated">IANA维护Internet媒体类型[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] 的注册表，网址为&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;。本文档用作Internet媒体类型&amp;ldquo; multipart / byteranges&amp;rdquo;的规范。以下内容已在IANA上注册。</target>
        </trans-unit>
        <trans-unit id="ab128dcbdb2ebebc35788dc3821bf42469b226aa" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media
   types &quot;message/http&quot; and &quot;application/http&quot;.  The following has been
   registered with IANA.</source>
          <target state="translated">IANA维护Internet媒体类型[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]的注册表，网址为&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;。本文档用作Internet媒体类型&amp;ldquo; message / http&amp;rdquo;和&amp;ldquo; application / http&amp;rdquo;的规范。以下内容已在IANA上注册。</target>
        </trans-unit>
        <trans-unit id="357bae4af7b5b87d000bfe81726ab37f502a946a" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media type
   &quot;multipart/byteranges&quot;.  The following has been registered with IANA.</source>
          <target state="translated">IANA维护Internet媒体类型[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]的注册表，网址为&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;。本文档用作Internet媒体类型&amp;ldquo; multipart / byteranges&amp;rdquo;的规范。以下内容已在IANA上注册。</target>
        </trans-unit>
        <trans-unit id="2f25bf5a2ef40ce000fcbfb953c618138d7e6d92" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of URI Schemes [&lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt;&amp;gt;.

   This document defines the following URI schemes, so the &quot;Permanent
   URI Schemes&quot; registry has been updated accordingly.

   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt; |
   | https      | Hypertext Transfer Protocol Secure | &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt; |
   +------------+------------------------------------+---------------+</source>
          <target state="translated">IANA 在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt; &amp;gt;上维护URI计划的注册中心[ &lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] 。本文档定义了以下URI方案，因此&amp;ldquo;永久URI方案&amp;rdquo;注册表已相应更新。 + ------------ + ------------------------------------ + --------------- + | URI方案|描述参考| + ------------ + ------------------------------------ + --------------- + | http |超文本传输​​协议| &lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节&lt;/a&gt; | | https |安全超文本传输​​协议| &lt;a href=&quot;#section-2.7.2&quot;&gt;第2.7.2节&lt;/a&gt; | + ------------ + ------------------------------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="e1ea21615883709c31afd1e3ffefa6a9abd86a33" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of URI Schemes [&lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt;&amp;gt;.

   This document defines the following URI schemes, so the &quot;Permanent
   URI Schemes&quot; registry has been updated accordingly.

   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt; |
   | https      | Hypertext Transfer Protocol Secure | &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt; |
   +------------+------------------------------------+---------------+</source>
          <target state="translated">IANA在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt; &amp;gt;上维护URI计划的注册中心[ &lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] 。本文档定义了以下URI方案，因此&amp;ldquo;永久URI方案&amp;rdquo;注册表已相应更新。+ ------------ + ------------------------------------ + --------------- + | URI方案| 描述 参考| + ------------ + ------------------------------------ + --------------- + | http | 超文本传输​​协议| &lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节&lt;/a&gt;| | https | 超文本传输​​协议的安全性| &lt;a href=&quot;#section-2.7.2&quot;&gt;第2.7.2节&lt;/a&gt;| + ------------ + ------------------------------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="70d5ce962c5520d83534599071460204e3f79a4c" translate="yes" xml:space="preserve">
          <source>IANA official registry of HTTP status codes</source>
          <target state="translated">IANA官方注册的HTTP状态码</target>
        </trans-unit>
        <trans-unit id="052ea052e8c19248acaf0e57ba16070d89e5f3f2" translate="yes" xml:space="preserve">
          <source>IANA registry</source>
          <target state="translated">IANA登记处</target>
        </trans-unit>
        <trans-unit id="3ec2a8d54523fcf678717117536e9db1ddb9d0ec" translate="yes" xml:space="preserve">
          <source>IANA registry of Authentication schemes</source>
          <target state="translated">IANA认证方案登记处</target>
        </trans-unit>
        <trans-unit id="433dbaf6332943984d6516e68b5f7fa26960c972" translate="yes" xml:space="preserve">
          <source>ICO</source>
          <target state="translated">ICO</target>
        </trans-unit>
        <trans-unit id="1c424db78d6168d4e4112d7ef44078d6e5cc90ef" translate="yes" xml:space="preserve">
          <source>IETF Draft</source>
          <target state="translated">IETF草案</target>
        </trans-unit>
        <trans-unit id="8017c92650b8189e940d94d4098c59d4b86b1c4b" translate="yes" xml:space="preserve">
          <source>IETF RFC</source>
          <target state="translated">IETF RFC</target>
        </trans-unit>
        <trans-unit id="8571cc2c4258545210a5b00473280039ad4b84d4" translate="yes" xml:space="preserve">
          <source>IIS</source>
          <target state="translated">IIS</target>
        </trans-unit>
        <trans-unit id="863b6ddbf8a4aa095ca888b978a73ba1efc7811f" translate="yes" xml:space="preserve">
          <source>Icon format</source>
          <target state="translated">图标格式</target>
        </trans-unit>
        <trans-unit id="ca9f65841299353702f59413c67b4d41e934a6e4" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for each resource. But there are reasons for alternative names for a resource:</source>
          <target state="translated">理想情况下,每个资源只有一个位置,因此只有一个URL。但也有理由为资源取其他名称。</target>
        </trans-unit>
        <trans-unit id="3dc4507a76928b989abe5a6100c9511b38bd00d7" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for one resource. But there are reasons for wanting to have alternative names for a resource (several domains, like with and without the www prefix or shorter and easy to remember URLs, &amp;hellip;). In these cases, rather than duplicating the resource, it is useful to use a redirect to the one true (canonical) URL.</source>
          <target state="translated">理想情况下，一种资源只有一个位置，因此只有一个URL。但是，出于某些原因，我们希望为资源使用其他名称（多个域，例如带有和不带有www前缀的域名，或者更短且易于记忆的URL，等等）。在这些情况下，与其复制资源，不如使用重定向到一个真实（规范）URL的方法。</target>
        </trans-unit>
        <trans-unit id="f1df7d15a8112ad87203fcb0cb507f4b96b72bbd" translate="yes" xml:space="preserve">
          <source>Idempotent</source>
          <target state="translated">Idempotent</target>
        </trans-unit>
        <trans-unit id="b6a2413ad63489a62e13c1cef9ff703c77e3aa0f" translate="yes" xml:space="preserve">
          <source>Idempotent Methods (RFC 7231)</source>
          <target state="translated">幂等方法(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="526430255f19421715307947f2ff84df60c93896" translate="yes" xml:space="preserve">
          <source>Identifies the original host requested that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">识别客户端用于连接到代理或负载平衡器的原始主机请求。</target>
        </trans-unit>
        <trans-unit id="b108c524c313085aeda694b0f180ecea370efb15" translate="yes" xml:space="preserve">
          <source>Identifies the originating IP addresses of a client connecting to a web server through an HTTP proxy or a load balancer.</source>
          <target state="translated">识别通过HTTP代理或负载平衡器连接到Web服务器的客户端的原始IP地址。</target>
        </trans-unit>
        <trans-unit id="4728d359ae99afe818be6f9dc7667972f09461f4" translate="yes" xml:space="preserve">
          <source>Identifies the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">识别客户端用于连接到代理或负载平衡器的协议(HTTP或HTTPS)。</target>
        </trans-unit>
        <trans-unit id="b059dd235df4bbca4880938a5c1bb58a2acfaacc" translate="yes" xml:space="preserve">
          <source>Identifying allowed request methods</source>
          <target state="translated">识别允许的请求方法</target>
        </trans-unit>
        <trans-unit id="a11a4c57a7f8dccbb14cb41b82dc14540c9e4cbe" translate="yes" xml:space="preserve">
          <source>Identifying resources on the Web</source>
          <target state="translated">识别网络上的资源</target>
        </trans-unit>
        <trans-unit id="2ddba376a063bd16e86e27e7bafe3713c58a5850" translate="yes" xml:space="preserve">
          <source>Identifying the issue</source>
          <target state="translated">查明问题</target>
        </trans-unit>
        <trans-unit id="5411f86a7d04f9bc55dfc770d7c059832dab58c1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Also) responses always lead to the use of a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; (Temporary Redirect) and &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; (Permanent Redirect) don't change the method used in the original request;</source>
          <target state="translated">如果&lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（另请参见）响应始终导致使用&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法，则&lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt;（临时重定向）和&lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt;（永久重定向）不会更改原始请求中使用的方法；</target>
        </trans-unit>
        <trans-unit id="203f83a39c006e96b0372879695a48c384f5a98d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Viewport-Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences.</source>
          <target state="translated">如果在消息中多次出现&amp;ldquo; &lt;code&gt;Viewport-Width&lt;/code&gt; ，则最后一个值将覆盖所有先前出现的值。</target>
        </trans-unit>
        <trans-unit id="d42bc610b058bcee9d44ddc50eaef50c5549ec14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Want-Digest&lt;/code&gt; does not include any digest algorithms that the server supports, the server may respond with:</source>
          <target state="translated">如果 &lt;code&gt;Want-Digest&lt;/code&gt; 不包含服务器支持的任何摘要算法，则服务器可能会响应：</target>
        </trans-unit>
        <trans-unit id="eeff268bfa6cc58c2072be3b70c8ada2ff1e8f56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;display-capture&lt;/code&gt; is disabled in a document, the document will not be able to initiate screen capture via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt;&lt;code&gt;getDisplayMedia()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在文档中禁用了 &lt;code&gt;display-capture&lt;/code&gt; ，则该文档将无法通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt; &lt;code&gt;getDisplayMedia()&lt;/code&gt; &lt;/a&gt;启动屏幕捕获。</target>
        </trans-unit>
        <trans-unit id="f7ade11e64845f3fc5c7bc101765fbb13c18d967" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script-src-attr&lt;/code&gt; is absent, User Agent falls back to the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, and if that is absent as well, to &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果不存在 &lt;code&gt;script-src-attr&lt;/code&gt; ，则用户代理将退回到&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt;指令，如果也不存在，则返回&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63609d6bc405969d35b2060eab7a8fb70825c6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script-src-elem&lt;/code&gt; is absent, User Agent falls back to the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, and if that is absent as well, to &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果不存在 &lt;code&gt;script-src-elem&lt;/code&gt; ，则用户代理将退回到&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt;指令，如果也不存在，则退回到&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67e6f0a239dfb82509e36ca577925e74a83f28f9" translate="yes" xml:space="preserve">
          <source>If = &quot;If&quot; &quot;:&quot; ( 1*No-tag-list | 1*Tagged-list )

     No-tag-list = List
     Tagged-list = Resource-Tag 1*List

     List = &quot;(&quot; 1*Condition &quot;)&quot;
     Condition = [&quot;Not&quot;] (State-token | &quot;[&quot; entity-tag &quot;]&quot;)
     ; entity-tag: see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;
     ; No LWS allowed between &quot;[&quot;, entity-tag and &quot;]&quot; 

     State-token = Coded-URL

     Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;
     ; Simple-ref: see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;
     ; No LWS allowed in Resource-Tag

   The syntax distinguishes between untagged lists (&quot;No-tag-list&quot;) and
   tagged lists (&quot;Tagged-list&quot;).  Untagged lists apply to the resource
   identified by the Request-URI, while tagged lists apply to the
   resource identified by the preceding Resource-Tag.

   A Resource-Tag applies to all subsequent Lists, up to the next
   Resource-Tag.

   Note that the two list types cannot be mixed within an If header.
   This is not a functional restriction because the No-tag-list syntax
   is just a shorthand notation for a Tagged-list production with a
   Resource-Tag referring to the Request-URI.

   Each List consists of one or more Conditions.  Each Condition is
   defined in terms of an entity-tag or state-token, potentially negated
   by the prefix &quot;Not&quot;.

   Note that the If header syntax does not allow multiple instances of
   If headers in a single request.  However, the HTTP header syntax
   allows extending single header values across multiple lines, by
   inserting a line break followed by whitespace (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;).</source>
          <target state="translated">If =&amp;ldquo; If&amp;rdquo;&amp;ldquo;：&amp;rdquo;（1 *无标记列表| 1 *标记列表）无标记列表=列表标记列表=资源标记1 *列表列表=&amp;ldquo;（&amp;rdquo; 1 *条件&amp;ldquo;） &amp;ldquo; Condition = [&amp;rdquo; Not&amp;ldquo;]（状态令牌|&amp;rdquo; [&amp;ldquo;实体标签&amp;rdquo;]&amp;ldquo;））；实体标签：请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]第3.11节&lt;/a&gt; ； &amp;ldquo; [&amp;rdquo;，entity-tag和&amp;ldquo;]&amp;rdquo;之间不允许使用LWS状态令牌=编码URL资源标签=&amp;ldquo; &amp;lt;&amp;rdquo; Simple-ref&amp;ldquo;&amp;gt;&amp;rdquo;;简单引用：请参见&lt;a href=&quot;#section-8.3&quot;&gt;第8.3节&lt;/a&gt; ; Resource-Tag中不允许使用LWS语法区分未标记列表（&amp;ldquo; No-tag-list&amp;rdquo;）和标记列表（&amp;ldquo; Tagged-list&amp;rdquo;）。未标记的列表适用于由Request-URI标识的资源，而标记的列表适用于由先前的Resource-Tag标识的资源。资源标签适用于所有后续列表，直至下一个资源标签。请注意，两种列表类型不能混入If标题中。这不是功能上的限制，因为&amp;ldquo;无标签列表&amp;rdquo;语法只是&amp;ldquo;标签列表&amp;rdquo;产品的缩写符号，其中&amp;ldquo;资源标签&amp;rdquo;引用了&amp;ldquo; Request-URI&amp;rdquo;。每个列表由一个或多个条件组成。每个条件都是根据实体标签或状态令牌定义的，可能会被前缀&amp;ldquo; Not&amp;rdquo;否定。请注意，If标头语法不允许在单个请求中使用If标头的多个实例。但是，HTTP标头语法允许通过在换行符后插入空格来扩展多行中的单个标头值（请参见[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]，&lt;a href=&quot;#section-4.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2 &lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="00bde6a2609129ada06a88cb9a7d89333869670f" translate="yes" xml:space="preserve">
          <source>If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame.</source>
          <target state="translated">如果HTTP管道化被激活,则可以发送多个请求,而无需等待第一个响应被完全接收。事实证明,HTTP管道化在现有的网络中很难实现,因为在现有网络中,旧的软件与现代版本共存。在HTTP/2中,HTTP pipelining已经被更强大的帧内多路复用请求所取代。</target>
        </trans-unit>
        <trans-unit id="748bef436e961cb49a985af369e84e4c57fb5faa" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are inadequate to access a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">如果（代理）服务器收到的有效凭据不足以访问给定资源，则该服务器应使用&lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; 状态代码进行响应。与&lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 或&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; 需要&lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 不同，此用户无法进行身份验证。</target>
        </trans-unit>
        <trans-unit id="2712ef523f505fe38f908ee1d8ecd4882dfa22c9" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are not adequate to gain access for a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">如果（代理）服务器收到的有效凭据不足以获得对给定资源的访问权限，则服务器应使用&lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; 状态代码进行响应。与&lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 或&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; 需要&lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 不同，此用户无法进行身份验证。</target>
        </trans-unit>
        <trans-unit id="9c01487d51a7abfed59147d7589b11bd17b56929" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Key&quot;&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/a&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">如果提供了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Key&quot;&gt; &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; &lt;/a&gt;标头，则通过获取键的值，并将字符串&amp;ldquo; 258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;rdquo;连接到该键上，并采用&lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;哈希值来计算此标头的值串连的字串，产生20个位元组的值。然后对该值进行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt;编码以获得该属性的值。</target>
        </trans-unit>
        <trans-unit id="326ac990ab0dffc2412d939867b01ccdcb920f4c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DELETE&lt;/code&gt; method is successfully applied, there are several response status codes possible:</source>
          <target state="translated">如果成功应用了 &lt;code&gt;DELETE&lt;/code&gt; 方法，则可能有几种响应状态代码：</target>
        </trans-unit>
        <trans-unit id="e0abfc5dd0ca6cc561a0c1e9018bd30b2988a7b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">如果提供了 &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; 标头，则通过获取键的值，并将字符串&amp;ldquo; 258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;rdquo;连接到其上，并采用&lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;哈希值来计算此标头的值串联的字符串，结果为20字节。然后对该值进行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt;编码以获得该属性的值。</target>
        </trans-unit>
        <trans-unit id="34536e055c95da8db601f072a295ac2e4e5c6957" translate="yes" xml:space="preserve">
          <source>If a COPY request has an Overwrite header with a value of &quot;F&quot;, and a
   resource exists at the Destination URL, the server MUST fail the
   request.

   When a server executes a COPY request and overwrites a destination
   resource, the exact behavior MAY depend on many factors, including
   WebDAV extension capabilities (see particularly [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  For 

   example, when an ordinary resource is overwritten, the server could
   delete the target resource before doing the copy, or could do an in-
   place overwrite to preserve live properties.

   When a collection is overwritten, the membership of the destination
   collection after the successful COPY request MUST be the same
   membership as the source collection immediately before the COPY.
   Thus, merging the membership of the source and destination
   collections together in the destination is not a compliant behavior.

   In general, if clients require the state of the destination URL to be
   wiped out prior to a COPY (e.g., to force live properties to be
   reset), then the client could send a DELETE to the destination before
   the COPY request to ensure this reset.</source>
          <target state="translated">如果COPY请求的Overhead标头值为&amp;ldquo; F&amp;rdquo;，并且目标URL上存在资源，则服务器务必使请求失败。当服务器执行COPY请求并覆盖目标资源时，确切的行为可能取决于许多因素，包括WebDAV扩展功能（尤其是[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]）。例如，当普通资源被覆盖时，服务器可以在进行复制之前删除目标资源，或者可以就地覆盖以保留活动属性。当集合被覆盖时，在成功进行COPY请求之后，目标集合的成员身份必须与在COPY之前的源集合的成员身份相同。因此，将源集合和目标集合的成员身份合并到目标中并不是一种合规行为。通常，如果客户端要求在COPY之前清除目标URL的状态（例如，强制重置活动属性），则客户端可以在COPY请求之前将DELETE发送到目标，以确保此重置。</target>
        </trans-unit>
        <trans-unit id="0fb0c405e8ed86db97633eff664cd93d6b990ee4" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.</source>
          <target state="translated">如果一个缓存收到的值大于它能表示的值,或者它的任何后续计算溢出,缓存将认为该值是2147483648(2^31)或它能方便表示的最大正整数。</target>
        </trans-unit>
        <trans-unit id="f48cab758bf32db6fab20e2d919807414feba7e5" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider this value to be either 2,147,483,648 (2&lt;sup&gt;31&lt;/sup&gt;) or the greatest positive integer it can represent.</source>
          <target state="translated">如果缓存收到的值大于它可以表示的值，或者任何后续计算溢出，则该缓存将认为该值是2,147,483,648（2 &lt;sup&gt;31&lt;/sup&gt;）或它可以表示的最大正整数。</target>
        </trans-unit>
        <trans-unit id="45f89453dd62bad0eede5073e7bfa49271c65312" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of a representation and wishes to have
   an up-to-date copy of the entire representation, it could use the
   Range header field with a conditional GET (using either or both of
   If-Unmodified-Since and If-Match.)  However, if the precondition
   fails because the representation has been modified, the client would
   then have to make a second request to obtain the entire current
   representation.

   The &quot;If-Range&quot; header field allows a client to &quot;short-circuit&quot; the
   second request.  Informally, its meaning is as follows: if the
   representation is unchanged, send me the part(s) that I am requesting
   in Range; otherwise, send me the entire representation.

     If-Range = entity-tag / HTTP-date

   A client MUST NOT generate an If-Range header field in a request that
   does not contain a Range header field.  A server MUST ignore an
   If-Range header field received in a request that does not contain a
   Range header field.  An origin server MUST ignore an If-Range header
   field received in a request for a target resource that does not
   support Range requests.

   A client MUST NOT generate an If-Range header field containing an
   entity-tag that is marked as weak.  A client MUST NOT generate an
   If-Range header field containing an HTTP-date unless the client has
   no entity-tag for the corresponding representation and the date is a
   strong validator in the sense defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.

   A server that evaluates an If-Range precondition MUST use the strong
   comparison function when comparing entity-tags (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;Section&amp;nbsp;2.3.2 of
   [RFC7232]&lt;/a&gt;) and MUST evaluate the condition as false if an HTTP-date 

   validator is provided that is not a strong validator in the sense
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.  A valid entity-tag can be
   distinguished from a valid HTTP-date by examining the first two
   characters for a DQUOTE.

   If the validator given in the If-Range header field matches the
   current validator for the selected representation of the target
   resource, then the server SHOULD process the Range header field as
   requested.  If the validator does not match, the server MUST ignore
   the Range header field.  Note that this comparison by exact match,
   including when the validator is an HTTP-date, differs from the
   &quot;earlier than or equal to&quot; comparison used when evaluating an
   If-Unmodified-Since conditional.</source>
          <target state="translated">如果客户端具有表示的部分副本，并希望拥有整个表示的最新副本，则可以将Range标头字段与条件GET一起使用（使用If-Unmodified-Since和If中的一个或两个） -Match。）但是，如果前提条件由于表示已被修改而失败，则客户端将不得不再次请求获取整个当前表示。 &amp;ldquo; If-Range&amp;rdquo;标头字段允许客户端&amp;ldquo;短路&amp;rdquo;第二个请求。非正式地，它的含义如下：如果表示形式不变，请向我发送我在Range中要求的零件；否则，请将整个陈述寄给我。If-Range =实体标签/ HTTP日期客户端不得在不包含Range头字段的请求中生成If-Range头字段。服务器必须忽略在不包含Range头域的请求中接收到的If-Range头域。源服务器必须忽略在对不支持范围请求的目标资源的请求中收到的If-Range头字段。客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强验证器，否则客户端不得生成包含HTTP日期的If-Range头字段。服务器必须忽略在不包含Range头域的请求中接收到的If-Range头域。源服务器必须忽略在对不支持范围请求的目标资源的请求中收到的If-Range头字段。客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强校验器，否则客户端不得生成包含HTTP日期的If-Range头字段。服务器必须忽略在不包含Range头域的请求中接收到的If-Range头域。源服务器必须忽略在对不支持范围请求的目标资源的请求中收到的If-Range头字段。客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强验证器，否则客户端不得生成包含HTTP日期的If-Range头字段客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强验证器，否则客户端不得生成包含HTTP日期的If-Range头字段。客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强验证器，否则客户端不得生成包含HTTP日期的If-Range头字段。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]的2.2.2节&lt;/a&gt;。评估If-Range前提条件的服务器在比较实体标签时必须使用强比较函数（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;[RFC7232]的2.3.2节&lt;/a&gt;），并且如果提供的HTTP日期验证器不强，则必须将条件评估为false。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]第2.2.2节&lt;/a&gt;定义的验证器。通过检查DQUOTE的前两个字符，可以将有效的实体标签与有效的HTTP日期区分开。如果If-Range头字段中给出的验证器与目标资源的所选表示形式的当前验证器匹配，则服务器应按要求处理Range头字段。如果验证者不匹配，则服务器必须忽略Range标头字段。请注意，这种完全匹配的比较（包括验证器为HTTP日期时）与评估If-Unmodified-Since条件时使用的&amp;ldquo;早于或等于&amp;rdquo;比较不同。</target>
        </trans-unit>
        <trans-unit id="9d82e70ce9faffba2758cddebc66060093cca8ab" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of an entity in its cache, and wishes
   to have an up-to-date copy of the entire entity in its cache, it
   could use the Range request-header with a conditional GET (using
   either or both of If-Unmodified-Since and If-Match.) However, if the
   condition fails because the entity has been modified, the client
   would then have to make a second request to obtain the entire current
   entity-body.

   The If-Range header allows a client to &quot;short-circuit&quot; the second
   request. Informally, its meaning is `if the entity is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   entity'.

        If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date ) 

   If the client has no entity tag for an entity, but does have a Last-
   Modified date, it MAY use that date in an If-Range header. (The
   server can distinguish between a valid HTTP-date and any form of
   entity-tag by examining no more than two characters.) The If-Range
   header SHOULD only be used together with a Range header, and MUST be
   ignored if the request does not include a Range header, or if the
   server does not support the sub-range operation.

   If the entity tag given in the If-Range header matches the current
   entity tag for the entity, then the server SHOULD provide the
   specified sub-range of the entity using a 206 (Partial content)
   response. If the entity tag does not match, then the server SHOULD
   return the entire entity using a 200 (OK) response.</source>
          <target state="translated">如果客户端在缓存中拥有一个实体的部分副本,并且希望在缓存中拥有整个实体的最新副本,它可以使用Range请求头来进行有条件的GET(使用If-Unmodified-Since和If-Match中的任何一个或两个)。If-Range头允许客户端 &quot;短路 &quot;第二次请求。非正式地,它的意思是 &quot;如果实体没有变化,就给我发送我丢失的部分;否则,就给我发送整个新实体&quot;。If-Range=&quot;If-Range&quot; &quot;:&quot;(entity-tag | HTTP-date)如果客户端对一个实体没有实体标签,但有最后修改日期,它可以在If-Range头中使用该日期。服务器可以通过检查不超过两个字符来区分有效的HTTP-date和任何形式的实体标签。If-Range头只能和Range头一起使用,如果请求中不包含Range头,或者服务器不支持子范围操作,则必须忽略。如果在If-Range头中给出的实体标签与实体的当前实体标签相匹配,那么服务器应该使用206(部分内容)响应提供实体的指定子范围。如果实体标签不匹配,那么服务器SHOULD使用200(OK)响应返回整个实体。</target>
        </trans-unit>
        <trans-unit id="3088b6387af36bd48fbfec162964786d9f1bdf8a" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is also marked with the &lt;code&gt;Secure&lt;/code&gt; attribute, was sent from a secure origin, does &lt;em&gt;not&lt;/em&gt; include a &lt;code&gt;Domain&lt;/code&gt; attribute, and has the &lt;code&gt;Path&lt;/code&gt; attribute set to &lt;code&gt;/&lt;/code&gt;. In this way, these cookies can be seen as &quot;domain-locked&quot;.</source>
          <target state="translated">如果一个cookie的名字有这个前缀，它接受一个&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;头只有当它是还标有 &lt;code&gt;Secure&lt;/code&gt; 属性，从安全的原点发送，并&lt;em&gt;没有&lt;/em&gt;包括 &lt;code&gt;Domain&lt;/code&gt; 的属性，并具有 &lt;code&gt;Path&lt;/code&gt; 属性设置为 &lt;code&gt;/&lt;/code&gt; 。这样，这些cookie可以被视为&amp;ldquo;域锁定&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c034021e921f0e666de945c6149637ed216dc323" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is marked with the &lt;code&gt;Secure&lt;/code&gt; attribute and was sent from a secure origin. This is weaker than the &lt;code&gt;__Host-&lt;/code&gt; prefix.</source>
          <target state="translated">如果cookie名称具有此前缀，则只有在cookie名称带有 &lt;code&gt;Secure&lt;/code&gt; 属性并且是从安全来源发送的情况下，它才会在&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;标头中被接受。这比 &lt;code&gt;__Host-&lt;/code&gt; 前缀弱。</target>
        </trans-unit>
        <trans-unit id="6b817618a3c57a329ff611f0cc5c3c6f52c5cf77" translate="yes" xml:space="preserve">
          <source>If a cross origin resource supports CORS, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; attribute or the &lt;a href=&quot;cross-origin-resource-policy&quot;&gt;&lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt;&lt;/a&gt; header must be used to load it without being blocked by COEP.</source>
          <target state="translated">如果跨源资源支持CORS，则必须使用 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; 属性或&lt;a href=&quot;cross-origin-resource-policy&quot;&gt; &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; &lt;/a&gt;标头来加载它，而不会被COEP阻止。</target>
        </trans-unit>
        <trans-unit id="07dcaab0a8d92362a3236a9f15a9d5cd4082d7fa" translate="yes" xml:space="preserve">
          <source>If a cross-origin document with COOP is opened in a new window, the opening document will not have a reference to it, and the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/opener&quot;&gt;window.opener&lt;/a&gt;&lt;/code&gt; property of the new window will be &lt;code&gt;null&lt;/code&gt;. This allows you to have more control over references to a window than &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/noopener&quot;&gt;rel=noopener&lt;/a&gt;&lt;/code&gt;, which only affects outgoing navigations.</source>
          <target state="translated">如果在新窗口中打开带有COOP的跨域文档，则打开的文档将没有对其的引用，并且新窗口的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/opener&quot;&gt;window.opener&lt;/a&gt;&lt;/code&gt; 属性将为 &lt;code&gt;null&lt;/code&gt; 。与 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/noopener&quot;&gt;rel=noopener&lt;/a&gt;&lt;/code&gt; 相比，这使您可以更多地控制对窗口的引用，这仅影响传出的导航。</target>
        </trans-unit>
        <trans-unit id="d6c875512b44481b0aec708d6ca539f3bb79d246" translate="yes" xml:space="preserve">
          <source>If a new cacheable (see sections &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;, &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; and &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;)
   response is received from a resource while any existing responses for
   the same resource are cached, the cache SHOULD use the new response
   to reply to the current request. It MAY insert it into cache storage
   and MAY, if it meets all other requirements, use it to respond to any
   future requests that would previously have caused the old response to
   be returned. If it inserts the new response into cache storage  the
   rules in &lt;a href=&quot;#section-13.5.3&quot;&gt;section 13.5.3&lt;/a&gt; apply.

      Note: a new response that has an older Date header value than
      existing cached responses is not cacheable.</source>
          <target state="translated">如果一个新的缓存（见第&lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;，&lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;，&lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;和&lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;）响应从同时对同一资源的任何现有的响应缓存在资源接收，高速缓存应该使用新的响应回复当前请求。它可以将其插入缓存存储，如果满足所有其他要求，则可以使用它来响应将来可能导致旧响应返回的任何将来请求。如果它将新的响应插入缓存存储，则适用&lt;a href=&quot;#section-13.5.3&quot;&gt;第13.5.3节中&lt;/a&gt;的规则。注意：具有比现有缓存响应更早的Date标头值的新响应是不可缓存的。</target>
        </trans-unit>
        <trans-unit id="e58c73fa3ef27580bf7799dda53dd96a70453ff2" translate="yes" xml:space="preserve">
          <source>If a request goes through multiple proxies, the IP addresses of each successive proxy is listed. This means, the right-most IP address is the IP address of the most recent proxy and the left-most IP address is the IP address of the originating client.</source>
          <target state="translated">如果一个请求经过多个代理,则会列出每个连续代理的IP地址。也就是说,最右边的IP地址是最近的代理服务器的IP地址,最左边的IP地址是发起客户端的IP地址。</target>
        </trans-unit>
        <trans-unit id="e2c3c58894ac3aaacdbb37189725a1f26ce869ef" translate="yes" xml:space="preserve">
          <source>If a resource exists at the destination and the Overwrite header is
   &quot;T&quot;, then prior to performing the move, the server MUST perform a
   DELETE with &quot;Depth: infinity&quot; on the destination resource.  If the
   Overwrite header is set to &quot;F&quot;, then the operation will fail.</source>
          <target state="translated">如果在目的地存在资源,并且Overwrite头为 &quot;T&quot;,那么在执行移动之前,服务器必须对目的地资源进行 &quot;Depth:infinity &quot;的DELETE操作。如果将Overwrite头设置为 &quot;F&quot;,则操作会失败。</target>
        </trans-unit>
        <trans-unit id="22db687e87d90b4a5b61ae1c9f192564fbed5581" translate="yes" xml:space="preserve">
          <source>If a same-site cookie has this attribute, the browser will only send cookies if the request originated from the website that set the cookie. If the request originated from a different URL than the URL of the current location, none of the cookies tagged with the &lt;code&gt;strict&lt;/code&gt; attribute will be included.</source>
          <target state="translated">如果同一站点的cookie具有此属性，则仅当请求来自设置cookie的网站时，浏览器才会发送cookie。如果请求源自与当前位置的URL不同的URL，则不会包含标记为 &lt;code&gt;strict&lt;/code&gt; 属性的cookie 。</target>
        </trans-unit>
        <trans-unit id="a78f222e9151b20e3fa58d2b5922efdfbb1c1a0f" translate="yes" xml:space="preserve">
          <source>If a server returns such an error status, the body of the message should contain the list of the available representations of the resources, allowing the user to choose among them.</source>
          <target state="translated">如果服务器返回这样的错误状态,消息的主体应该包含资源的可用表示列表,允许用户在其中进行选择。</target>
        </trans-unit>
        <trans-unit id="acb751d12ffe14eea97f1844541379bb1e82d026" translate="yes" xml:space="preserve">
          <source>If a single server supports multiple organizations that do not trust
   one another, then it MUST check the values of Location and Content-
   Location headers in responses that are generated under control of
   said organizations to make sure that they do not attempt to
   invalidate resources over which they have no authority.</source>
          <target state="translated">如果一台服务器支持多个互不信任的组织,那么它必须检查在上述组织控制下生成的响应中的Location和Content-位置头的值,以确保它们不会试图使它们没有权限的资源无效。</target>
        </trans-unit>
        <trans-unit id="0034277126e29616d67034416858786a6bf01601" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header to the response of https://example.com/logout:</source>
          <target state="translated">如果用户退出您的网站或服务，则可能要删除本地存储的数据。您可以通过在https://example.com/logout的响应中添加 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 标头来实现：</target>
        </trans-unit>
        <trans-unit id="28708bd5ed063a05bc0c1ffae01007cff1ddad84" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header when sending the page confirming that logging out from the site has been accomplished successfully (https://example.com/logout, for example):</source>
          <target state="translated">如果用户退出您的网站或服务，则可能要删除本地存储的数据。您可以通过在发送页面时添加 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 标头来确认已成功完成从站点的注销（例如，https：//example.com/logout）来实现此目的：</target>
        </trans-unit>
        <trans-unit id="8c5c04bfd2a5924b2636ab2156504c08859b88e5" translate="yes" xml:space="preserve">
          <source>If a website accepts a connection through HTTP and redirects to HTTPS, visitors may initially communicate with the non-encrypted version of the site before being redirected, if, for example, the visitor types http://www.foo.com/ or even just foo.com. This creates an opportunity for a man-in-the-middle attack. The redirect could be exploited to direct visitors to a malicious site instead of the secure version of the original site.</source>
          <target state="translated">如果一个网站接受通过HTTP的连接,并重定向到HTTPS,访问者可能在重定向之前最初与非加密版本的网站进行通信,例如,如果访问者键入http://www.foo.com/,甚至只是foo.com。这就为中间人攻击创造了机会。重定向可以被利用,将访问者引导到一个恶意网站,而不是原始网站的安全版本。</target>
        </trans-unit>
        <trans-unit id="c5d743f58d38a06b0efb87624e4399a8e4fa3b88" translate="yes" xml:space="preserve">
          <source>If all proxies are down, and there was no DIRECT option specified, the browser will ask if proxies should be temporarily ignored, and direct connections attempted. After 20 minutes, the browser will ask if proxies should be retried, asking again after an additional 40 minutes. Queries will continue, always adding 20 minutes to the elapsed time between queries.</source>
          <target state="translated">如果所有的代理服务器都瘫痪了,而且没有指定DIRECT选项,浏览器会询问是否应该暂时忽略代理服务器,并尝试直接连接。20分钟后,浏览器会询问是否应该重新尝试代理,再过40分钟后再次询问。查询将继续进行,查询之间的时间总是增加20分钟。</target>
        </trans-unit>
        <trans-unit id="24f0c3aae5a8cb6b90479558f98a655abee38832" translate="yes" xml:space="preserve">
          <source>If an HTTP/1.1 client sends a request which includes a request body,
   but which does not include an Expect request-header field with the
   &quot;100-continue&quot; expectation, and if the client is not directly
   connected to an HTTP/1.1 origin server, and if the client sees the
   connection close before receiving any status from the server, the
   client SHOULD retry the request.  If the client does retry this
   request, it MAY use the following &quot;binary exponential backoff&quot;
   algorithm to be assured of obtaining a reliable response:

      1. Initiate a new connection to the server

      2. Transmit the request-headers

      3. Initialize a variable R to the estimated round-trip time to the
         server (e.g., based on the time it took to establish the
         connection), or to a constant value of 5 seconds if the round-
         trip time is not available.

      4. Compute T = R * (2**N), where N is the number of previous
         retries of this request.

      5. Wait either for an error response from the server, or for T
         seconds (whichever comes first)

      6. If no error response is received, after T seconds transmit the
         body of the request.

      7. If client sees that the connection is closed prematurely,
         repeat from step 1 until the request is accepted, an error
         response is received, or the user becomes impatient and
         terminates the retry process. 

   If at any point an error status is received, the client

      - SHOULD NOT continue and

      - SHOULD close the connection if it has not completed sending the
        request message.</source>
          <target state="translated">如果一个HTTP/1.1客户端发送了一个包含请求体的请求,但该请求不包含带有 &quot;100-continue &quot;期望值的Expect request-header字段,并且如果客户端没有直接连接到HTTP/1.1源服务器,并且如果客户端在收到服务器的任何状态之前看到连接关闭,客户端应该重试该请求。如果客户端确实重试了这个请求,它可以使用以下 &quot;二进制指数回退 &quot;算法来保证获得可靠的响应。1.启动一个新的连接到服务器 2.传送请求头 3.将一个变量R初始化为估计到服务器的往返时间(例如,基于建立连接所花费的时间),如果没有往返时间,则初始化为一个5秒的常量值。4.计算T=R*(2**N),其中N为该请求的前次重试次数。5.等待服务器的错误响应,或者等待T秒(以先到者为准)6.如果没有收到错误响应,在T秒后传输请求的主体。7.如果客户端认为连接过早关闭,则从第1步开始重复,直到请求被接受,收到错误响应,或者用户不耐烦而终止重试过程。如果在任何时候收到错误状态,客户端--不应该继续,--如果没有完成发送请求消息,应该关闭连接。</target>
        </trans-unit>
        <trans-unit id="787c64d4a2d625599ff698430e64f8f08ddeb6a2" translate="yes" xml:space="preserve">
          <source>If an origin server does not explicitly specify freshness (e.g. using &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header) then a heuristic approach may be used.</source>
          <target state="translated">如果原始服务器未明确指定新鲜度（例如，使用&lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;标头），则可以使用启发式方法。</target>
        </trans-unit>
        <trans-unit id="cf50575579d857df6c5f0e97dcbebb456e6ad37f" translate="yes" xml:space="preserve">
          <source>If another principal locks a resource that a principal wishes to
   access, it is useful for the second principal to be able to find out
   who the first principal is.  For this purpose the DAV:lockdiscovery
   property is provided.  This property lists all outstanding locks,
   describes their type, and MAY even provide the lock tokens.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:lockdiscovery property.</source>
          <target state="translated">如果另一个委托人锁定了一个委托人希望访问的资源,那么第二个委托人就可以知道第一个委托人是谁。为此,我们提供了 DAV:lockdiscovery 属性。这个属性列出了所有未完成的锁,描述了它们的类型,甚至可以提供锁的标记。任何支持 LOCK 方法的 DAV 兼容资源都必须支持 DAV:lockdiscovery 属性。</target>
        </trans-unit>
        <trans-unit id="4e1966a722bf8f31efed779517aa3c6a04a51ec9" translate="yes" xml:space="preserve">
          <source>If both &lt;strong&gt;wd1 &lt;/strong&gt;and &lt;strong&gt;wd1 &lt;/strong&gt;are defined, the condition is true if the current weekday is in between those two &lt;em&gt;ordered &lt;/em&gt;weekdays. Bounds are inclusive, &lt;em&gt;but the bounds are ordered&lt;/em&gt;. If the &quot;GMT&quot; parameter is specified, times are taken to be in GMT. Otherwise, the local timezone is used.</source>
          <target state="translated">如果同时定义了&lt;strong&gt;wd1&lt;/strong&gt;和&lt;strong&gt;wd1&lt;/strong&gt;，则当当前工作日在这两个&lt;em&gt;有序&lt;/em&gt;工作日之间时，条件为true 。边界是包容的，&lt;em&gt;但边界是有序的&lt;/em&gt;。如果指定了&amp;ldquo; GMT&amp;rdquo;参数，则时间以GMT为单位。否则，将使用本地时区。</target>
        </trans-unit>
        <trans-unit id="9452662d9180b8ba3efe3a780c450ae27e07209e" translate="yes" xml:space="preserve">
          <source>If both a &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header are present in the same response, both policies are honored. The policy specified in &lt;code&gt;Content-Security-Policy&lt;/code&gt; headers is enforced while the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; policy generates reports but is not enforced.</source>
          <target state="translated">如果在同一响应中同时存在&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;标头和&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;标头，则将遵循这两个策略。 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 标头中指定的策略被强制执行，而 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 策略仅生成报告，但不强制执行。</target>
        </trans-unit>
        <trans-unit id="d126e6f1349def738aa84d3d7ade4189f1674e03" translate="yes" xml:space="preserve">
          <source>If both this directive (i.e. via the &lt;code&gt;allow&lt;/code&gt; attribute) and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence. There was a bug whereby the &lt;code&gt;fullscreen&lt;/code&gt; directive didn't work unless the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute was also present, but this has been fixed as of Firefox 80 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1608358&quot;&gt;bug 1608358&lt;/a&gt;).</source>
          <target state="translated">如果此指令（即通过 &lt;code&gt;allow&lt;/code&gt; 属性）和 &lt;code&gt;allowfullscreen&lt;/code&gt; 属性都出现在 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 元素上，则该指令优先。除非存在 &lt;code&gt;allowfullscreen&lt;/code&gt; 属性，否则存在一个 &lt;code&gt;fullscreen&lt;/code&gt; 指令不起作用的错误，但是该错误已在Firefox 80中&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1608358&quot;&gt;修复&lt;/a&gt;（错误1608358）。</target>
        </trans-unit>
        <trans-unit id="e7feb971c53a1e3363d82fc1ef6da1a87db0cb6b" translate="yes" xml:space="preserve">
          <source>If both this directive and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 元素上同时存在此指令和 &lt;code&gt;allowfullscreen&lt;/code&gt; 属性，则该指令优先。</target>
        </trans-unit>
        <trans-unit id="62b0316637ce393c10dfd9b58aa37bf2f0a42cdc" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Content-Language&lt;/code&gt; is specified, the default is that the content is intended for all language audiences. Multiple language tags are also possible, as well as applying the &lt;code&gt;Content-Language&lt;/code&gt; header to various media types and not only to textual documents.</source>
          <target state="translated">如果未指定 &lt;code&gt;Content-Language&lt;/code&gt; ，则默认值为该内容适用于所有语言的受众。也可以使用多种语言标签，以及将 &lt;code&gt;Content-Language&lt;/code&gt; 标头应用于各种媒体类型，而不仅是文本文档。</target>
        </trans-unit>
        <trans-unit id="5f0faef3900e1d15f4d91c1fcfcd5a68d9578e75" translate="yes" xml:space="preserve">
          <source>If no URL scheme is specified for a &lt;code&gt;host-source&lt;/code&gt; and the iframe is loaded from an &lt;code&gt;https&lt;/code&gt; URL, the URL for the page loading the iframe must also be &lt;code&gt;https&lt;/code&gt;, per the W3C spec on &lt;a href=&quot;https://w3c.github.io/webappsec-csp/2/#match-source-expression&quot;&gt;matching source expressions&lt;/a&gt;.</source>
          <target state="translated">如果未为 &lt;code&gt;host-source&lt;/code&gt; 指定URL方案，并且从 &lt;code&gt;https&lt;/code&gt; URL加载了iframe ，则根据&lt;a href=&quot;https://w3c.github.io/webappsec-csp/2/#match-source-expression&quot;&gt;匹配源表达式&lt;/a&gt;的W3C规范，用于加载iframe的页面的URL也必须为 &lt;code&gt;https&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2432969974e0bf99b152d397b2c719d44cd0439e" translate="yes" xml:space="preserve">
          <source>If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">如果没有给定端口,则意味着请求服务的默认端口(例如,HTTP URL的 &quot;80&quot;)。</target>
        </trans-unit>
        <trans-unit id="9619fd8159a262a6e7f8b156f3e9ea6322194094" translate="yes" xml:space="preserve">
          <source>If no port is included, the default port for the service requested (e.g., &lt;code&gt;443&lt;/code&gt; for an HTTPS URL, and &lt;code&gt;80&lt;/code&gt; for an HTTP URL) is implied.</source>
          <target state="translated">如果不包括任何端口，则隐含所请求服务的默认端口（例如，对于HTTPS URL为 &lt;code&gt;443&lt;/code&gt; ，对于HTTP URL为 &lt;code&gt;80&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e478b06858c696e70a28213656753916abc92ba3" translate="yes" xml:space="preserve">
          <source>If omitted, defaults to the host of the current document URL, not including subdomains.</source>
          <target state="translated">如果省略,默认为当前文档URL的主机,不包括子域。</target>
        </trans-unit>
        <trans-unit id="219c745dfe181251ec5c580abc0c14da79c6b291" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: day, month, year), the function returns a true value only on days that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">如果仅指定一个值（来自每个类别：日，月，年），则该函数仅在与该规范匹配的日期返回真值。如果同时指定了两个值，那么在这些时间（包括界限）之间，结果为true，&lt;em&gt;但是界限是有序的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ebc918364962297bbe2d03e861cdada5a4d5d17c" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: hour, minute, second), the function returns a true value only at times that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">如果仅指定单个值（来自每个类别：小时，分钟，秒），则该函数仅在与该规范匹配的时间返回真值。如果同时指定了两个值，那么在这些时间（包括界限）之间，结果为true，&lt;em&gt;但是界限是有序的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7ad3b8639eddeee4168cd5b47edae6dcb2df2c3c" translate="yes" xml:space="preserve">
          <source>If only one parameter is present, the function returns a value of true on the weekday that the parameter represents. If the string &quot;GMT&quot; is specified as a second parameter, times are taken to be in GMT. Otherwise, they are assumed to be in the local timezone.</source>
          <target state="translated">如果只有一个参数,函数在该参数所代表的工作日返回值为true。如果字符串 &quot;GMT &quot;被指定为第二个参数,时间将被视为GMT。否则,将假定为当地时区。</target>
        </trans-unit>
        <trans-unit id="b64b7edace3c1de8eea4e9f7cb502c7f66cbbfc3" translate="yes" xml:space="preserve">
          <source>If several ranges are sent back, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;multipart/byteranges&lt;/code&gt; and each fragment covers one range, with &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; describing it.</source>
          <target state="translated">如果发回多个范围，则将&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;multipart/byteranges&lt;/code&gt; ，每个片段覆盖一个范围，并用&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 对其进行&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="78a2139f59af3c201e14f90fe9cef770569b0d29" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support for partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">如果网站省略了 &lt;code&gt;Accept-Ranges&lt;/code&gt; 标头，则它们可能不支持部分请求。一些站点还显式发送&amp;ldquo; &lt;code&gt;none&lt;/code&gt; &amp;rdquo;作为值，表示不支持。在某些应用中，下载管理器会在这种情况下禁用其暂停按钮。</target>
        </trans-unit>
        <trans-unit id="c8a2e2bc49a74014d19dc3e20faf6d47f4b2c5fb" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">如果网站省略了 &lt;code&gt;Accept-Ranges&lt;/code&gt; 标头，则它们可能不支持部分请求。一些站点还显式发送&amp;ldquo; &lt;code&gt;none&lt;/code&gt; &amp;rdquo;作为值，表示不支持。在某些应用中，下载管理器会在这种情况下禁用其暂停按钮。</target>
        </trans-unit>
        <trans-unit id="091a0218219abd0cdbbefc8a401d17bce706512c" translate="yes" xml:space="preserve">
          <source>If that's not possible, then another way is to:</source>
          <target state="translated">如果实在不行,那么还有一个办法就是。</target>
        </trans-unit>
        <trans-unit id="7832c9e8ca11a0dc4da645bd06786210e575896b" translate="yes" xml:space="preserve">
          <source>If the &quot;Basic&quot; authentication scheme is used, the credentials are constructed like this:</source>
          <target state="translated">如果使用 &quot;基本 &quot;认证方案,则凭证的构造如下。</target>
        </trans-unit>
        <trans-unit id="f91174398d0cf4de63fc9e0993886a3f7ebd8264" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request and cURL, for example.</source>
          <target state="translated">如果HTTP响应中存在&amp;ldquo; &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt;（且其值不是&amp;ldquo; &lt;code&gt;none&lt;/code&gt; &amp;rdquo;），则服务器支持范围请求。例如，您可以通过发出&lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;请求和cURL进行检查。</target>
        </trans-unit>
        <trans-unit id="1e2bd82bb2d016fc76410dd12a3b0342a93316e7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request with cURL, for example.</source>
          <target state="translated">如果HTTP响应中存在&amp;ldquo;&lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt;（并且其值不是&amp;ldquo; &lt;code&gt;none&lt;/code&gt; &amp;rdquo;），则服务器支持范围请求。例如，您可以通过发出带有cURL的&lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;请求来进行检查。</target>
        </trans-unit>
        <trans-unit id="a0c9cc929b4bd0a174617d37fdb2ef2438aa90fc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; can't detect any value specified for this header&amp;mdash;even though the header is included in the response&amp;mdash;this error occurs.</source>
          <target state="translated">如果&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;无法检测到为此标头指定的任何值（即使标头包含在响应中），也会发生此错误。</target>
        </trans-unit>
        <trans-unit id="37fea5e541c03ceff1dd1b298e2c8a47aff43276" translate="yes" xml:space="preserve">
          <source>If the CORS configuration isn't setup correctly, the browser console will present an error like &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; indicating that the request was blocked due to violating the CORS security rules. This might not necessarily be a set-up mistake, though. It's possible that the request is in fact intentionally being disallowed by the user's web application and remote external service. However, If the endpoint is meant to be available, some debugging is needed to succeed.</source>
          <target state="translated">如果未正确设置CORS配置，则浏览器控制台将显示错误消息，例如 &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; 表明该请求由于违反了CORS安全性而被阻止规则。但是，这不一定是设置错误。实际上，用户的Web应用程序和远程外部服务实际上有意禁止了该请求。但是，如果要使端点可用，则需要进行一些调试才能成功。</target>
        </trans-unit>
        <trans-unit id="dc9c7b7249ed9c2cd26babda62bc7a605dd20286" translate="yes" xml:space="preserve">
          <source>If the CORS request indicated by the preflight request is authorized, the server will respond to the preflight request with a message that indicates the allowed origin, methods and headers. Below we see that &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; includes the headers that were requested.</source>
          <target state="translated">如果预检请求指示的CORS请求被授权，则服务器将使用一条消息来响应预检请求，该消息指示允许的来源，方法和标头。在下面，我们看到&lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;包含所请求的标头。</target>
        </trans-unit>
        <trans-unit id="b3f8c214b695d6473d07dc8643ad150f467962dc" translate="yes" xml:space="preserve">
          <source>If the TCP connection is closed or reset while streams remain in
   &quot;open&quot; or &quot;half-closed&quot; state, then the affected streams cannot be
   automatically retried (see &lt;a href=&quot;#section-8.1.4&quot;&gt;Section 8.1.4&lt;/a&gt; for details).</source>
          <target state="translated">如果在流保持&amp;ldquo;打开&amp;rdquo;或&amp;ldquo;半关闭&amp;rdquo;状态时关闭或重置TCP连接，则无法自动重试受影响的流（有关详细信息，请参见&lt;a href=&quot;#section-8.1.4&quot;&gt;第8.1.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b8ffab7457821dbf47b42281a4936c9c518bf014" translate="yes" xml:space="preserve">
          <source>If the attribute is set to lax, same-site cookies are withheld on cross-domain subrequests, such as calls to load images or frames, but will be sent when a user naviates to the URL from an external site, for example, by following a link.</source>
          <target state="translated">如果该属性被设置为宽松,那么在跨域子请求中,例如调用加载图像或框架时,同站cookie将被扣留,但当用户从外部网站导航到URL时,例如通过跟随一个链接,将被发送。</target>
        </trans-unit>
        <trans-unit id="5d7a35532093cac38ce9488b4579d2ba232c9fa7" translate="yes" xml:space="preserve">
          <source>If the client has performed a conditional GET request and access is
   allowed, but the document has not been modified, the server SHOULD
   respond with this status code. The 304 response MUST NOT contain a
   message-body, and thus is always terminated by the first empty line
   after the header fields.

   The response MUST include the following header fields:

      - Date, unless its omission is required by &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; 

   If a clockless origin server obeys these rules, and proxies and
   clients add their own Date to any response received without one (as
   already specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], section&amp;nbsp;14.19&lt;/a&gt;), caches will operate
   correctly.

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the conditional GET used a strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;), the response SHOULD NOT include other entity-headers.
   Otherwise (i.e., the conditional GET used a weak validator), the
   response MUST NOT include other entity-headers; this prevents
   inconsistencies between cached entity-bodies and updated headers.

   If a 304 response indicates an entity not currently cached, then the
   cache MUST disregard the response and repeat the request without the
   conditional.

   If a cache uses a received 304 response to update a cache entry, the
   cache MUST update the entry to reflect any new field values given in
   the response.</source>
          <target state="translated">如果客户端已经执行了有条件的GET请求，并且允许访问，但是文档没有被修改，则服务器应该以该状态码响应。 304响应必须不包含消息正文，因此始终由标头字段之后的第一个空行终止。响应必须包含以下标头字段：-日期，除非&lt;a href=&quot;#section-14.18.1&quot;&gt;第14.18.1节&lt;/a&gt;要求省略，否则， 如果无时钟源服务器遵守这些规则，并且代理和客户端将自己的日期添加到没有响应的任何响应中（如&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068]，第14.19节&lt;/a&gt;），缓存将正常运行。 -ETag和/或Content-Location（如果标头是在对同一请求的200响应中发送的）-Expires，Cache-Control和/或Vary（如果字段值可能与任何先前响应中发送的字段值不同）对于相同的变量，如果条件GET使用了强缓存验证器（请参见&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3 &lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;节）&lt;/a&gt;），则响应不应包含其他实体标题。否则（即，条件GET使用了弱验证器），响应必须不包括其他实体头；这可以防止缓存的实体与更新的标头之间的不一致。如果304响应指示当前未缓存的实体，则缓存必须忽略响应，并在没有条件的情况下重复请求。如果缓存使用收到的304响应来更新缓存条目，则缓存必须更新该条目以反映响应中给定的任何新字段值。</target>
        </trans-unit>
        <trans-unit id="1b16cb43ac59e1398b6bbb6871dcb2c0b0c8621f" translate="yes" xml:space="preserve">
          <source>If the client receiving the &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; response is willing and able to upgrade to TLS, it should then start the same process covered above under &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;Client-initiated upgrade to TLS&lt;/a&gt;.</source>
          <target state="translated">如果收到 &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; 响应的客户端愿意并且能够升级到TLS，则它应开始与&lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;客户端启动的升级到TLS&lt;/a&gt;所述相同的过程。</target>
        </trans-unit>
        <trans-unit id="280f043319dde7fe251e1850244792cbea213b6e" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data.</source>
          <target state="translated">如果数据是文本数据，则可以简单地嵌入文本（使用适当的实体或根据随附文档的类型进行转义）。否则，您可以指定 &lt;code&gt;base64&lt;/code&gt; 来嵌入base64编码的二进制数据。</target>
        </trans-unit>
        <trans-unit id="32b1f46a0b7b90a86ae9e9f167e9ef7cf8038c9c" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data. You can find more info on MIME types &lt;a href=&quot;mime_types&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;mime_types/complete_list_of_mime_types&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">如果数据是文本数据，则可以简单地嵌入文本（使用适当的实体或根据随附文档的类型进行转义）。否则，您可以指定 &lt;code&gt;base64&lt;/code&gt; 来嵌入base64编码的二进制数据。您可以在&lt;a href=&quot;mime_types&quot;&gt;此处&lt;/a&gt;和&lt;a href=&quot;mime_types/complete_list_of_mime_types&quot;&gt;此处&lt;/a&gt;找到有关MIME类型的更多信息。</target>
        </trans-unit>
        <trans-unit id="b8559d1d219606090271c33a621201ee02497f80" translate="yes" xml:space="preserve">
          <source>If the desired resource width is not known at the time of the request or the resource does not have a display width, the &lt;code&gt;Width&lt;/code&gt; header field can be omitted. If &lt;code&gt;Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences</source>
          <target state="translated">如果在请求时未知所需的资源宽度，或者资源没有显示宽度，则可以省略 &lt;code&gt;Width&lt;/code&gt; 标头字段。如果&amp;ldquo; &lt;code&gt;Width&lt;/code&gt; 在消息中多次出现，则最后一个值将覆盖所有先前出现的值</target>
        </trans-unit>
        <trans-unit id="c18b5decb40c51cfed52abf66cbdc2d7b99ae4e9" translate="yes" xml:space="preserve">
          <source>If the device is large enough that it's not marked with &amp;ldquo;Mobi&amp;rdquo;, you should serve your desktop site (which, as a best practice, should support touch input anyway, as more desktop machines are appearing with touchscreens).</source>
          <target state="translated">如果设备足够大，没有用&amp;ldquo; Mobi&amp;rdquo;标记，则应为台式机站点提供服务（作为最佳实践，无论如何，随着越来越多的台式机与触摸屏一起出现，该站点应始终支持触摸输入）。</target>
        </trans-unit>
        <trans-unit id="0bbaf264d9f0d932c54c0e04e65ebace7f115760" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">如果哈希值不匹配，则表示文档已在中间进行编辑，并引发&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Precondition Failed&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="277939955257bc43f4243fef87536e0654d15a25" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">如果哈希值不匹配，则表示文档已在中间进行了编辑，并引发&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="3fd651b3de41c4c0939b139c2bcd1ec691c3efd5" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">如果哈希值不匹配，则表示文档已在中间进行了编辑，并引发&lt;a href=&quot;412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="3bde6b2f02854c6b43c647e825f2d4a1429eb84b" translate="yes" xml:space="preserve">
          <source>If the request is being issued using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, make sure you're not setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;withCredentials&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;发出请求，请确保未将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;withCredentials&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f1a69e15b2780621067297dd234a0594b2b2ffc" translate="yes" xml:space="preserve">
          <source>If the requested method isn't supported, the server will respond with an error.</source>
          <target state="translated">如果请求的方法不被支持,服务器将以错误的方式响应。</target>
        </trans-unit>
        <trans-unit id="bd63754e6e7fd0ed5e66293b22c5760094fd4fcf" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value &lt;em&gt;must&lt;/em&gt; be generated. A comparison of them can determine whether two representations of a resource are the same. Etags are therefore similar to fingerprints, and might also be used for tracking purposes by some servers. They might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">如果给定URL上的资源发生更改，则&lt;em&gt;必须&lt;/em&gt;生成一个新的 &lt;code&gt;Etag&lt;/code&gt; 值。将它们进行比较可以确定资源的两种表示形式是否相同。因此，Etag与指纹相似，某些服务器也可能将其用于跟踪目的。跟踪服务器还可以将它们设置为无限期持久。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e618a8054c6dfe27daf59e1f19b56a3219ec450e" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">如果给定URL上的资源发生更改，则必须生成一个新的 &lt;code&gt;Etag&lt;/code&gt; 值。因此，Etag与指纹相似，某些服务器也可能将其用于跟踪目的。通过对它们的比较，可以快速确定资源的两种表示形式是否相同，但是也可以将它们设置为由跟踪服务器无限期地保留。</target>
        </trans-unit>
        <trans-unit id="6df0a809ea7c0e16c3b4c1d61decdfe31ac868f4" translate="yes" xml:space="preserve">
          <source>If the resource has changed, the server just sends back a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt; OK&lt;/code&gt; response, with the new version of the resource, like if the request wasn't conditional and the client uses this new resource (and caches it).</source>
          <target state="translated">如果资源已更改，则服务器仅使用新版本的资源发送回&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt; OK&lt;/code&gt; 响应，就像请求不是有条件的，并且客户端使用此新资源（并将其缓存）一样。</target>
        </trans-unit>
        <trans-unit id="28dabd823abd95eebd0c73b38250e390477657ad" translate="yes" xml:space="preserve">
          <source>If the resource has not changed, the server sends back a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response. This makes the cache fresh again, and the client uses the cached resource. Although there is a response/request round-trip that consumes some resources, this is more efficient than to transmit the whole resource over the wire again.</source>
          <target state="translated">如果资源没有更改，则服务器会发回&lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 响应。这将使缓存再次刷新，并且客户端将使用缓存的资源。尽管有一个往返的响应/请求消耗了一些资源，但是这比再次通过有线传输整个资源更有效。</target>
        </trans-unit>
        <trans-unit id="96d3b1fd891c66341051bdd2445935c9e27b47b5" translate="yes" xml:space="preserve">
          <source>If the resource in question is meant to be widely accessed (just like any HTTP resource accessed by GET), then sending back the &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: *&lt;/code&gt; header will be sufficient, &lt;strong&gt;unless&lt;/strong&gt; the resource needs credentials such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication information.</source>
          <target state="translated">如果有问题的资源打算被广泛访问（就像GET访问的任何HTTP资源一样），则发回&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: *&lt;/code&gt; 标头就足够了，&lt;strong&gt;除非&lt;/strong&gt;该资源需要&lt;a href=&quot;cookies&quot;&gt;Cookie&lt;/a&gt;和HTTP之类的凭据认证信息。</target>
        </trans-unit>
        <trans-unit id="5afbe977f3fe9a82606049c55808c60ca15cfb67" translate="yes" xml:space="preserve">
          <source>If the resource should be kept restricted based on requester domain, &lt;strong&gt;OR&lt;/strong&gt; if the resource needs to be accessed with credentials (or sets credentials), then filtering by the request's &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header may be necessary, or at least echoing back the requester's &lt;code&gt;Origin&lt;/code&gt; (e.g. &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;). Additionally, the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header will have to be sent. This is discussed in a &lt;a href=&quot;#Credentialed_Requests&quot;&gt;subsequent section&lt;/a&gt;.</source>
          <target state="translated">如果应该根据请求者的域来限制资源，&lt;strong&gt;或者&lt;/strong&gt;如果需要使用凭据（或设置凭据）来访问资源，则可能有必要通过请求的&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;头进行过滤，或者至少回显请求者的 &lt;code&gt;Origin&lt;/code&gt; （例如&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; : //arunranga.com）。此外，必须发送&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; 标头。这将在&lt;a href=&quot;#Credentialed_Requests&quot;&gt;后续部分中&lt;/a&gt;讨论。</target>
        </trans-unit>
        <trans-unit id="9c8e2ffc70a619ab233773bc1539c19cb10a2bc1" translate="yes" xml:space="preserve">
          <source>If the response to a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached URL response is now outdated, the cached copy is invalidated even if no &lt;code&gt;GET&lt;/code&gt; request was made.</source>
          <target state="translated">如果对 &lt;code&gt;HEAD&lt;/code&gt; 请求的响应显示缓存的URL响应现在已过时，则即使没有发出 &lt;code&gt;GET&lt;/code&gt; 请求，缓存的副本也会无效。</target>
        </trans-unit>
        <trans-unit id="85a622ab8c535a47b0b491a95d39cc072896a324" translate="yes" xml:space="preserve">
          <source>If the result of a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached resource after a &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request is now outdated, the cache is invalidated, even if no &lt;code&gt;GET&lt;/code&gt; request has been made.</source>
          <target state="translated">如果 &lt;code&gt;HEAD&lt;/code&gt; 请求的结果表明&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;请求后的缓存资源现在已过期，则即使没有发出 &lt;code&gt;GET&lt;/code&gt; 请求，该缓存也会无效。</target>
        </trans-unit>
        <trans-unit id="8883378b1d0c73e1288f1ade4a8139bb08b162fd" translate="yes" xml:space="preserve">
          <source>If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g. language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).

   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   &quot;best guess&quot; to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user). In order to improve the server's
   guess, the user agent MAY include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.

   Server-driven negotiation has disadvantages:

      1. It is impossible for the server to accurately determine what
         might be &quot;best&quot; for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).

      2. Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.

      3. It complicates the implementation of an origin server and the
         algorithms for generating responses to a request. 

      4. It may limit a public cache's ability to use the same response
         for multiple user's requests.

   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;), Accept-
   Charset (&lt;a href=&quot;#section-14.2&quot;&gt;section 14.2&lt;/a&gt;), Accept-Encoding (&lt;a href=&quot;#section-14.3&quot;&gt;section 14.3&lt;/a&gt;), Accept-
   Language (&lt;a href=&quot;#section-14.4&quot;&gt;section 14.4&lt;/a&gt;), and User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;). However, an
   origin server is not limited to these dimensions and MAY vary the
   response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.

   The Vary  header field can be used to express the parameters the
   server uses to select a representation that is subject to server-
   driven negotiation. See &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field
   by caches and &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header field by
   servers.</source>
          <target state="translated">如果通过服务器上的算法为响应选择最佳表示形式，则称为服务器驱动的协商。选择是基于响应的可用表示形式（其可以变化的维度；例如语言，内容编码等）以及请求消息中特定标头字段的内容或与请求有关的其他信息（例如作为客户端的网络地址）。当难以从可用表示中进行选择的算法难以描述给用户代理时，或者当服务器希望将其&amp;ldquo;最佳猜测&amp;rdquo;与第一个响应一起发送给客户端时，服务器驱动的协商会非常有利。如果&amp;ldquo;最佳猜测&amp;rdquo;，则后续请求的往返延迟对用户来说足够好）。为了改善服务器的猜测，用户代理可以包括请求报头字段（Accept，Accept-Language，Accept-Encoding等），它们描述了服务器对这种响应的偏好。服务器驱动的协商具有以下缺点：1.服务器无法准确确定对任何给定用户而言&amp;ldquo;最佳&amp;rdquo;的东西，因为这将需要完全了解用户代理的功能以及响应的预期用途（例如，用户是要在屏幕上查看还是在纸上打印？）。 2。让用户代理在每个请求中描述其功能可能会非常低效（假设只有一小部分响应具有多种表示形式），并且可能会侵犯用户的隐私。 3.它使源服务器的实现和用于生成对请求的响应的算法变得复杂。 4.这可能会限制公共缓存对多个用户请求使用相同响应的能力。 HTTP / 1.1包括以下请求标头字段，用于通过描述用户代理功能和用户首选项来启用服务器驱动的协商：接受（4.这可能会限制公共缓存对多个用户请求使用相同响应的能力。 HTTP / 1.1包括以下请求标头字段，用于通过描述用户代理功能和用户首选项来启用服务器驱动的协商：接受（4.这可能会限制公共缓存对多个用户请求使用相同响应的能力。 HTTP / 1.1包含以下请求标头字段，用于通过描述用户代理功能和用户首选项来启用服务器驱动的协商：接受（&lt;a href=&quot;#section-14.1&quot;&gt;第14.1节&lt;/a&gt;），接受字符集（&lt;a href=&quot;#section-14.2&quot;&gt;第14.2节&lt;/a&gt;），接受编码（&lt;a href=&quot;#section-14.3&quot;&gt;第14.3节&lt;/a&gt;），接受语言（&lt;a href=&quot;#section-14.4&quot;&gt;第14.4节&lt;/a&gt;）和用户代理（&lt;a href=&quot;#section-14.43&quot;&gt;第14.43节&lt;/a&gt;）。但是，源服务器不限于这些维度，并且可以基于请求的任何方面改变响应，包括请求标头字段之外或本规范未定义的扩展标头字段内的信息。Vary标头字段可用于表示服务器用来选择要经过服务器驱动的协商的表示形式的参数。有关高速缓存对Vary标头字段的使用，请参见&lt;a href=&quot;#section-13.6&quot;&gt;第13.6节&lt;/a&gt;，以及&lt;a href=&quot;#section-14.44&quot;&gt;第14.44节&lt;/a&gt; 供服务器使用Vary标头字段。</target>
        </trans-unit>
        <trans-unit id="a97009ed5a171d3f2d00627248f02de9b1bd4edb" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does not&lt;/em&gt; support TLS upgrade, or is unable to upgrade to TLS at the time, it responds with a standard HTTP/1.1 response, such as:</source>
          <target state="translated">如果服务器&lt;em&gt;不&lt;/em&gt;支持TLS升级，或者当时无法升级到TLS，则服务器将使用标准HTTP / 1.1响应进行响应，例如：</target>
        </trans-unit>
        <trans-unit id="2c4956e2baa89a364f68e36f2540d46e391032b0" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; recognize the method, but intentionally does not support it, the appropriate response is &lt;a href=&quot;405&quot;&gt;&lt;code&gt;405 Method Not Allowed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果服务器&lt;em&gt;能够&lt;/em&gt;识别该方法，但有意不支持该方法，则相应的响应为&lt;a href=&quot;405&quot;&gt; &lt;code&gt;405 Method Not Allowed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b4ec0bc4d37ddaf3aac7f70b029b83445ca56f2" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; support TLS upgrade and wishes to permit the upgrade, it responds with the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; response code, like this:</source>
          <target state="translated">如果服务器&lt;em&gt;确实&lt;/em&gt;支持TLS升级并希望允许升级，则它将使用 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 响应代码进行响应，如下所示：</target>
        </trans-unit>
        <trans-unit id="a57f9acb3600d5372bf47b96b972a2c0b7a106b1" translate="yes" xml:space="preserve">
          <source>If the server allows CORS requests to use the &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; method, it responds with an &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; response header, which lists &lt;code&gt;DELETE&lt;/code&gt; along with the other methods it supports:</source>
          <target state="translated">如果服务器允许CORS请求使用&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;方法，它将以&lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;响应标头进行响应，该响应标头列出 &lt;code&gt;DELETE&lt;/code&gt; 及其支持的其他方法：</target>
        </trans-unit>
        <trans-unit id="be2369485a151abd59881e4ba1cc5463e20c789a" translate="yes" xml:space="preserve">
          <source>If the server can't communicate using the specified version of the WebSocket protocol, it will respond with an error (such as 426 Upgrade Required) that includes in its headers a &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header with a comma-separated list of the supported protocol versions. If the server does support the requested protocol version, no &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header is included in the response.</source>
          <target state="translated">如果服务器无法使用指定版本的WebSocket协议进行通信，它将以一个错误（例如426 Upgrade）来响应，该错误的标头中包含一个 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 标头，其中包含以逗号分隔的受支持列表。协议版本。如果服务器确实支持请求的协议版本，则响应中不包含 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="8bfc654fb667ab7a47e06dc70b7def2a7620c972" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any character encoding from this request header, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406 Not Acceptable&lt;/code&gt;&lt;/a&gt; error code. But for a better user experience, this is rarely done and the &lt;code&gt;Accept-Charset&lt;/code&gt; header is ignored.</source>
          <target state="translated">如果服务器无法从该请求标头提供任何字符编码，则理论上它可以发送回&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406 Not Acceptable&lt;/code&gt; &lt;/a&gt;错误代码。但是，为了获得更好的用户体验，很少执行此操作，并且会忽略 &lt;code&gt;Accept-Charset&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="ae753ebfa7e739c1ebf4391f5ee391f4e94ee3ce" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching character set, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and the more common way is to ignore the &lt;code&gt;Accept-Charset&lt;/code&gt; header in this case.</source>
          <target state="translated">如果服务器不能提供任何匹配的字符集，则理论上它可以发送回&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受）错误代码。但是，为了获得更好的用户体验，很少这样做，更常见的方法是在这种情况下忽略 &lt;code&gt;Accept-Charset&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="d8ca646db299a164f8eaec324da4187a3dc7c934" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching language, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and more common way is to ignore the &lt;code&gt;Accept-Language&lt;/code&gt; header in this case.</source>
          <target state="translated">如果服务器不能提供任何匹配的语言，则理论上它可以发送回&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受）错误代码。但是，为了获得更好的用户体验，很少这样做，更常见的方法是在这种情况下忽略 &lt;code&gt;Accept-Language&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="6bdcb29bf81310454b85262c7363f76b72c53d49" translate="yes" xml:space="preserve">
          <source>If the server decides to upgrade the connection, it must:</source>
          <target state="translated">如果服务器决定升级连接,必须。</target>
        </trans-unit>
        <trans-unit id="5785d405909bd735e16eff8d00e42ade5e8499d9" translate="yes" xml:space="preserve">
          <source>If the server decides to upgrade the connection, it sends back a &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101 Switching Protocols&lt;/code&gt;&lt;/a&gt; response status with an Upgrade header that specifies the protocol(s) being switched to. If it does not (or cannot) upgrade the connection, it ignores the &lt;code&gt;Upgrade&lt;/code&gt; header and sends back a regular response (for example, a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200 OK&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果服务器决定升级连接，它将发回&lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101 Switching Protocols&lt;/code&gt; &lt;/a&gt;响应状态，并带有指定要切换到的协议的&amp;ldquo;升级&amp;rdquo;标头。如果它不（或不能）升级连接，它将忽略 &lt;code&gt;Upgrade&lt;/code&gt; 标头并发送回常规响应（例如&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200 OK&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4d3214eaff9a427b272921bccd27c1fd179422db" translate="yes" xml:space="preserve">
          <source>If the server has a preferred choice, it should generate a &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">如果服务器有首选选项，则应生成一个&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="e05c84402fda441286aba0b966f3789dbf6191c3" translate="yes" xml:space="preserve">
          <source>If the server is unable to switch to HTTP/2 for any reason, it will reply with a standard HTTP/1 reply after handling the request as normal. So if the request was to fetch a web page which does in fact exist, you would get a standard &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; response with the web page following the remainder of the header. If the server is able to switch to HTTP/2, a &quot;&lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; response is sent, which will look like this:</source>
          <target state="translated">如果服务器由于某种原因无法切换到HTTP / 2，则在正常处理请求后，它将以标准HTTP / 1答复进行答复。因此，如果请求是获取实际上存在的网页，您将在标头的其余部分之后得到标准的 &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; 响应。如果服务器能够切换到HTTP / 2，则将发送&amp;ldquo; &lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; 响应，如下所示：</target>
        </trans-unit>
        <trans-unit id="b5c0cece345dde55b15ad1ad49b64cab5f6ed8d2" translate="yes" xml:space="preserve">
          <source>If the server is under your control, add the origin of the requesting site to the set of domains permitted access by adding it to the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header's value.</source>
          <target state="translated">如果服务器在您的控制之下，则通过将请求站点的源添加到 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头的值中，将其添加到允许访问的域集中。</target>
        </trans-unit>
        <trans-unit id="62963ebedd2ff72d3bb4b415143d2ac0443881d2" translate="yes" xml:space="preserve">
          <source>If the server sends a response with an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value that is an explicit origin (rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard), then the response should also include a &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header with the value &lt;code&gt;Origin&lt;/code&gt; &amp;mdash; to indicate to browsers that server responses can differ based on the value of the &lt;code&gt;Origin&lt;/code&gt; request header.</source>
          <target state="translated">如果服务器发送的响应的 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 值是一个显式的起源（而不是&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;通配符），则该响应还应包括一个带有值 &lt;code&gt;Origin&lt;/code&gt; 的&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;响应头，以向浏览器指示服务器响应可以根据 &lt;code&gt;Origin&lt;/code&gt; 请求标头的值而有所不同。</target>
        </trans-unit>
        <trans-unit id="40ae9d31a1c63c02ebcd60debd2f8b97d5dd7ac9" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin (that may dynamically change based on the requesting origin as part of a white-list) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">如果服务器指定单个来源（可能会根据请求的来源作为白名单的一部分动态更改）而不是&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;通配符，则服务器还应在&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;响应标头中包含 &lt;code&gt;Origin&lt;/code&gt; ，以向客户端指示服务器响应将根据&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;请求标头的值而有所不同。</target>
        </trans-unit>
        <trans-unit id="035b5ed82a9b1755b686239ae88f8e1ef4f77e51" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">如果服务器指定的是单个来源而不是通配符&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;，则服务器还应在&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;响应标头中包含 &lt;code&gt;Origin&lt;/code&gt; ，以向客户端指示服务器响应将基于&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;请求标头的值而有所不同。</target>
        </trans-unit>
        <trans-unit id="bdd4b87fdc6a81c461da6befd7c1928bb2e1a6e5" translate="yes" xml:space="preserve">
          <source>If the server supports range requests, you can issue such a request by using the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header. It indicates the part(s) of a document that the server should return.</source>
          <target state="translated">如果服务器支持范围请求，则可以使用&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;标头发出这样的请求。它指示服务器应返回的文档部分。</target>
        </trans-unit>
        <trans-unit id="6199750daad48ff639691648a086a49c0a3fd0a7" translate="yes" xml:space="preserve">
          <source>If the server wishes a faster Web site or application response, it is possible for the server to force the opening of more connections. For example, Instead of having all resources on the same domain, say &lt;code&gt;www.example.com&lt;/code&gt;, it could split over several domains, &lt;code&gt;www1.example.com&lt;/code&gt;, &lt;code&gt;www2.example.com&lt;/code&gt;, &lt;code&gt;www3.example.com&lt;/code&gt;. Each of these domains resolve to the &lt;em&gt;same&lt;/em&gt; server, and the Web browser will open 6 connections to each (in our example, boosting the connections to 18). This technique is called &lt;em&gt;domain sharding&lt;/em&gt;.</source>
          <target state="translated">如果服务器希望更快的网站或应用程序响应，则服务器可能会强制打开更多连接。例如，不是将所有资源都放在同一个域上，比如说 &lt;code&gt;www.example.com&lt;/code&gt; ，它可以拆分为多个域，分别是 &lt;code&gt;www1.example.com&lt;/code&gt; ， &lt;code&gt;www2.example.com&lt;/code&gt; ， &lt;code&gt;www3.example.com&lt;/code&gt; 。这些域中的每一个都解析到&lt;em&gt;同一台&lt;/em&gt;服务器，并且Web浏览器将打开每个域的6个连接（在我们的示例中，将连接增加到18个）。这种技术称为&lt;em&gt;域分片&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="633be8e65041e6f678ba0a69d47e73981a12258e" translate="yes" xml:space="preserve">
          <source>If the service your code is accessing using a CORS request is under your control, make sure that it's configured to include your origin in its &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, and that only one such header is included in responses. The header itself accepts a comma-delineated list of origins, so adding a new origin is not difficult.</source>
          <target state="translated">如果您的代码正在使用CORS请求访问的服务在您的控制之下，请确保已将其配置为在其 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头中包含您的来源，并且响应中仅包含一个此类标头。标头本身接受逗号分隔的来源列表，因此添加新来源并不困难。</target>
        </trans-unit>
        <trans-unit id="d5f87d2c5913a57c8787a092105a04dbd9842ee7" translate="yes" xml:space="preserve">
          <source>If the string is null, no proxies should be used</source>
          <target state="translated">如果该字符串为空,则不应该使用代理。</target>
        </trans-unit>
        <trans-unit id="ee70fc1642248dcddd5b4e8e2c3aa5e1fa8b3482" translate="yes" xml:space="preserve">
          <source>If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server must send either a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) or a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;No Content&lt;/code&gt;) response to indicate successful completion of the request.</source>
          <target state="translated">如果目标资源确实具有当前表示形式，并且该表示形式已根据所附表示形式的状态成功进行了修改，则原始服务器必须发送&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）或&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;No Content&lt;/code&gt; ）响应以指示成功完成了请求。</target>
        </trans-unit>
        <trans-unit id="2e56a40e542286dd3f5f24ab9d9b357b4b9363fa" translate="yes" xml:space="preserve">
          <source>If the target resource does not have a current representation and the &lt;code&gt;PUT&lt;/code&gt; request successfully creates one, then the origin server must inform the user agent by sending a &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Created&lt;/code&gt;) response.</source>
          <target state="translated">如果目标资源没有当前表示，并且 &lt;code&gt;PUT&lt;/code&gt; 请求成功创建了一个表示，则源服务器必须通过发送&lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;（已 &lt;code&gt;Created&lt;/code&gt; ）响应来通知用户代理。</target>
        </trans-unit>
        <trans-unit id="a21b80ceb96b8a7d43dede98629becf487c2e6a3" translate="yes" xml:space="preserve">
          <source>If the upgrade to TLS succeeds, the server will respond with &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; as described in the previous section. If the upgrade fails, the HTTP/1.1 connection will fail.</source>
          <target state="translated">如果升级到TLS成功，则服务器将按照上一节中的说明响应 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 。如果升级失败，则HTTP / 1.1连接将失败。</target>
        </trans-unit>
        <trans-unit id="27db56e6fbfb8552acb661ab2ec13d5567a5150c" translate="yes" xml:space="preserve">
          <source>If there are hosts (such as the main Web server) that belong to the local domain but are outside the firewall and are only reachable through the proxy server, those exceptions can be handled using the &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; function:</source>
          <target state="translated">如果存在属于本地域但在防火墙之外并且只能通过代理服务器访问的主机（例如主Web服务器），则可以使用 &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; 函数处理这些异常：</target>
        </trans-unit>
        <trans-unit id="d24ef4f84cb249bfa31f9902d7ae003a91952701" translate="yes" xml:space="preserve">
          <source>If there are multiple semicolon-separated settings, the left-most setting will be used, until Firefox fails to establish the connection to the proxy. In that case, the next value will be used, etc.</source>
          <target state="translated">如果有多个分号分隔的设置,将使用最左边的设置,直到 Firefox 无法建立与代理的连接。在这种情况下,将使用下一个值,等等。</target>
        </trans-unit>
        <trans-unit id="d35d9172db4121106bcca6f82d93219ec641178d" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header</source>
          <target state="translated">如果指定了其他指令，则 &lt;code&gt;default-src&lt;/code&gt; 不会影响它们。以下标题</target>
        </trans-unit>
        <trans-unit id="f3a3fb9e88e16c02dae3ebc873862c5294ca1f14" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header:</source>
          <target state="translated">如果指定了其他指令，则 &lt;code&gt;default-src&lt;/code&gt; 不会影响它们。以下标头：</target>
        </trans-unit>
        <trans-unit id="b6ef483d4374adee5323181a48fbe2db2ede05c8" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &quot;max-age&quot; or &quot;s-maxage&quot; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">如果响应中存在带有&amp;ldquo; max-age&amp;rdquo;或&amp;ldquo; s-maxage&amp;rdquo;指令的&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;标头，则 &lt;code&gt;Expires&lt;/code&gt; 标头将被忽略。</target>
        </trans-unit>
        <trans-unit id="3dc7a417b9985cacb686b59815968d89411858de" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &lt;code&gt;max-age&lt;/code&gt; or &lt;code&gt;s-maxage&lt;/code&gt; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">如果响应中存在带有 &lt;code&gt;max-age&lt;/code&gt; 或 &lt;code&gt;s-maxage&lt;/code&gt; 指令的&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;标头，则 &lt;code&gt;Expires&lt;/code&gt; 标头将被忽略。</target>
        </trans-unit>
        <trans-unit id="872be7b4525857f39211419c11efc3edbf6a5a96" translate="yes" xml:space="preserve">
          <source>If there is only one range, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the whole response is set to the type of the document, and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; is provided.</source>
          <target state="translated">如果只有一个范围，则将整个响应的&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;设置为文档的类型，并提供&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b03947840333522631fcad82cab8f29beea0376" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will first look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive, then the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, then finally for the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, when governing worker execution.</source>
          <target state="translated">如果不存在此伪指令，则在管理工作程序执行时，用户代理将首先查找&lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt;伪指令，然后是&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt;伪指令，最后是&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;伪指令。</target>
        </trans-unit>
        <trans-unit id="84255b47da2e8395f8cff0945ef69aa9944b73b4" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive (which falls back to the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive).</source>
          <target state="translated">如果不存在此指令，则用户代理将查找&lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt;指令（回退到&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;指令）。</target>
        </trans-unit>
        <trans-unit id="905e23650e04dd97cd87c8f1b4781aae080cf34e" translate="yes" xml:space="preserve">
          <source>If this header is delivered with the response at https://example.com/clear-cookies, all cookies on the same domain https://example.com and any subdomains (like https://stage.example.com, etc), will be cleared out.</source>
          <target state="translated">如果这个头与响应https://example.com/clear-cookies,同一域名https://example.com 和任何子域名(如https://stage.example.com 等)上的所有 cookie 将被清除。</target>
        </trans-unit>
        <trans-unit id="84639588f8530b0b81f649bf1306849d6885af93" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, pin validation failures are reported to the given URL.</source>
          <target state="translated">如果指定了这个可选参数,引脚验证失败会被报告给给定的URL。</target>
        </trans-unit>
        <trans-unit id="cf9ff6207f9f440fe5c66b863c0c644f87236017" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, this rule applies to all of the site's subdomains as well.</source>
          <target state="translated">如果指定了这个可选参数,这个规则也适用于网站的所有子域。</target>
        </trans-unit>
        <trans-unit id="fb2426a1d151abc1dd5f8cd6ca02a6b7b48d09c2" translate="yes" xml:space="preserve">
          <source>If true, the policy applies to all subdomains under the origin that the policy header is set. The reporting group should also be set to include subdomains, if this option is to be enabled.</source>
          <target state="translated">如果为真,策略适用于策略头所设置的原点下的所有子域。如果要启用该选项,报告组也应该被设置为包括子域。</target>
        </trans-unit>
        <trans-unit id="bbeccd91304096ae1ada0d103a494be1d6ecd504" translate="yes" xml:space="preserve">
          <source>If unspecified, the cookie becomes a &lt;strong&gt;session cookie&lt;/strong&gt;. A session finishes when the client shuts down, and session cookies will be removed.</source>
          <target state="translated">如果未指定，则cookie成为&lt;strong&gt;会话cookie&lt;/strong&gt;。当客户端关闭时，会话结束，会话cookie将被删除。</target>
        </trans-unit>
        <trans-unit id="6baa688a2748366ccc3dde62ab07310d89508f6a" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt;&lt;code&gt;EventSource.withCredentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt; (it's the default value).</source>
          <target state="translated">如果使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;服务器发送的事件&lt;/a&gt;，请确保&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt; &lt;code&gt;EventSource.withCredentials&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;false&lt;/code&gt; （这是默认值）。</target>
        </trans-unit>
        <trans-unit id="bb9e740256ba82627b9a0ee6fa47dc9b15df8b15" translate="yes" xml:space="preserve">
          <source>If using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;omit&quot;&lt;/code&gt;.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;，请确保&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;&quot;omit&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da0002cfebb5073d0fedbf25422e03f2884be38b" translate="yes" xml:space="preserve">
          <source>If you are not disclosing third-party cookies, consumer trust might get harmed if cookie use is discovered. A clear disclosure (such as in a privacy policy) tends to eliminate any negative effects of a cookie discovery. Some countries also have legislation about cookies. See for example Wikimedia Foundation's &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie statement&lt;/a&gt;.</source>
          <target state="translated">如果您不公开第三方cookie，则如果发现使用cookie，可能会损害消费者信任。明确的披露（例如在隐私政策中）倾向于消除cookie发现的任何负面影响。一些国家也有关于cookie的立法。例如，参见Wikimedia Foundation的&lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bfae6e8214b89d3d41028b5ed5468c1096365497" translate="yes" xml:space="preserve">
          <source>If you are running a robotic user agent (e.g. a crawler), the &lt;code&gt;From&lt;/code&gt; header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.</source>
          <target state="translated">如果您正在运行机械手用户代理（例如，爬网程序），则应发送 &lt;code&gt;From&lt;/code&gt; 头，以便在服务器上发生问题（例如，机械手发送过多，不需要或无效的请求）时与您联系。</target>
        </trans-unit>
        <trans-unit id="9a96db39060f5e3f83ad7fb3b0569b07c25f59e0" translate="yes" xml:space="preserve">
          <source>If you don't know whether this condition is temporary or permanent, a &lt;a href=&quot;404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; status code should be used instead.</source>
          <target state="translated">如果您不知道此情况是暂时的还是永久的，则应使用&lt;a href=&quot;404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt;状态代码代替。</target>
        </trans-unit>
        <trans-unit id="b65a6981b33c89d11ed83bceadd2cf2695bfb77d" translate="yes" xml:space="preserve">
          <source>If you don't want a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">如果您不希望进行临时重定向，则可以使用其他参数（要使用的HTTP状态代码或 &lt;code&gt;permanent&lt;/code&gt; 关键字）来设置其他重定向：</target>
        </trans-unit>
        <trans-unit id="104043725295eb7cc9f3df2d7c830d6c1a7855ab" translate="yes" xml:space="preserve">
          <source>If you don't want to set up a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">如果您不想设置临时重定向，则可以使用额外的参数（要使用的HTTP状态代码或 &lt;code&gt;permanent&lt;/code&gt; 关键字）来设置其他重定向：</target>
        </trans-unit>
        <trans-unit id="6c9d45e2f476536f0d331642a282a111a65455ac" translate="yes" xml:space="preserve">
          <source>If you enable COEP using &lt;code&gt;require-corp&lt;/code&gt; and have a cross origin resource that needs to be loaded, it needs to support &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt; and you need to explicitly mark the resource as loadable from another origin to avoid blockage from COEP. For example, you can use the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; attribute for this image from a third-party site:</source>
          <target state="translated">如果使用 &lt;code&gt;require-corp&lt;/code&gt; 启用COEP并具有需要加载的跨源资源，则它需要支持&lt;a href=&quot;../cors&quot;&gt;CORS，&lt;/a&gt;并且您需要将资源明确标记为可从其他源加载，以免被COEP阻塞。例如，您可以使用第三方站点中的此图像的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="bbff3207b07c23fc192059f1baabdc3df63a21a1" translate="yes" xml:space="preserve">
          <source>If you have access to the server you can change your implementation to echo back an origin in the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header. You cannot send back a list of origins, because browsers only accept a value that is either a single origin or null</source>
          <target state="translated">如果您有权访问服务器，则可以更改实现以在 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头中回显原点。您无法发送回原点列表，因为浏览器仅接受一个原点或null值</target>
        </trans-unit>
        <trans-unit id="29e7b5fc4c6d4409c9fc727d5416d3a635b2f290" translate="yes" xml:space="preserve">
          <source>If you need to create a WebSocket connection from scratch, you'll have to handle the handshaking process yourself. After creating the initial HTTP/1.1 session, you need to request the upgrade by adding to a standard request the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, as follows:</source>
          <target state="translated">如果需要从头开始创建WebSocket连接，则必须自己处理握手过程。创建初始HTTP / 1.1会话后，您需要通过向标准请求中添加&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头来请求升级，如下所示：</target>
        </trans-unit>
        <trans-unit id="95ee0117fd829b54190ed2ff0616a236aeb84cf5" translate="yes" xml:space="preserve">
          <source>If you receive a response that is not in this list, it is a non-standard response, possibly custom to the server's software.</source>
          <target state="translated">如果你收到的响应不在这个列表中,那就是一个非标准的响应,可能是服务器软件定制的。</target>
        </trans-unit>
        <trans-unit id="0e8f0fd26b3474ef31bc91624748a9e6528cbeb2" translate="yes" xml:space="preserve">
          <source>If you set your site to require SRI for script and styles using this directive:</source>
          <target state="translated">如果您使用此指令将您的网站设置为需要SRI的脚本和样式。</target>
        </trans-unit>
        <trans-unit id="4990c5b1cf1cb465433d28094a3e92abdf6422d0" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;DENY&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;SAMEORIGIN&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">如果指定 &lt;code&gt;DENY&lt;/code&gt; ，则从其他站点加载时，不仅尝试在框架中加载页面失败，而且从同一站点加载时，尝试失败也会失败。另一方面，如果指定 &lt;code&gt;SAMEORIGIN&lt;/code&gt; ，则仍可以在框架中使用页面，只要框架中包含该页面的站点与服务该页面的站点相同即可。</target>
        </trans-unit>
        <trans-unit id="0907d966acc8c427e8ea343762038d9ac612b1e1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;deny&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;sameorigin&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">如果指定 &lt;code&gt;deny&lt;/code&gt; ，则从其他站点加载时，不仅尝试在框架中加载页面失败，而且从同一站点加载时，尝试也会失败。另一方面，如果指定 &lt;code&gt;sameorigin&lt;/code&gt; ，则只要框架中包含该页面的站点与服务该页面的站点相同，仍可以在框架中使用该页面。</target>
        </trans-unit>
        <trans-unit id="76a40e879843d64bc7dc4946b5e5671cdab0ec07" translate="yes" xml:space="preserve">
          <source>If you still want to receive reporting, but also want to enforce a policy, use the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header with the &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">如果您仍然想接收报告，但又想强制执行策略，请在&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;标头中使用&lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="6fa8f50d92b7325e18f060f06fa0a5d25f9ef058" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header.</source>
          <target state="translated">如果希望客户端能够访问其他标头，则必须使用 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 标头列出它们。</target>
        </trans-unit>
        <trans-unit id="ea06dd402f2e9e7e165d67b2c899ce9957d05866" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header. &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; was not part of the original set safelisted response headers [&lt;a href=&quot;https://github.com/whatwg/fetch/pull/626&quot;&gt;ref&lt;/a&gt;].</source>
          <target state="translated">如果希望客户端能够访问其他标头，则必须使用 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 标头列出它们。&lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;不是原始设置的安全列出的响应标头的一部分[ &lt;a href=&quot;https://github.com/whatwg/fetch/pull/626&quot;&gt;ref&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="29f7d5936f9e8e985a3e0dca82679038018eac65" translate="yes" xml:space="preserve">
          <source>If you want to avoid using user agent detection, you have options!</source>
          <target state="translated">如果你想避免使用用户代理检测,你可以选择!</target>
        </trans-unit>
        <trans-unit id="c4dd6049dead6031953d458d3c0344045b4e4cbe" translate="yes" xml:space="preserve">
          <source>If you want to specify a fallback policy in any case the desired policy hasn't got wide enough browser support, use a comma-separated list with the desired policy specified last:</source>
          <target state="translated">如果您想在所需策略没有得到足够广泛的浏览器支持的情况下指定一个后备策略,请使用逗号分隔的列表,并在最后指定所需策略。</target>
        </trans-unit>
        <trans-unit id="21412475687382be49c1ab666d1bf865da6de6a3" translate="yes" xml:space="preserve">
          <source>If you want to try to avoid using user agent detection, there are options in some cases!</source>
          <target state="translated">如果你想尽量避免使用用户代理检测,在某些情况下是有选择的!</target>
        </trans-unit>
        <trans-unit id="0a038ab727911ca95eaa7cfa94eb4a630d6d412b" translate="yes" xml:space="preserve">
          <source>If your application, server, or proxy supports the standardized &lt;code&gt;Forwarded&lt;/code&gt; header, the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt; header can be replaced. Note that IPv6 address are quoted and enclosed in square brackets in &lt;code&gt;Forwarded&lt;/code&gt;.</source>
          <target state="translated">如果您的应用程序，服务器或代理支持标准的 &lt;code&gt;Forwarded&lt;/code&gt; 标头，则可以替换&lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt;标头。请注意，IPv6地址在 &lt;code&gt;Forwarded&lt;/code&gt; 中用引号引起来并括在方括号中。</target>
        </trans-unit>
        <trans-unit id="90a08b947a2957fe434f390c98a9142e831d9a0f" translate="yes" xml:space="preserve">
          <source>If your site authenticates users, it should regenerate and resend session cookies, even ones that already exist, whenever the user authenticates. This technique helps prevent &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;session fixation attacks&lt;/a&gt;, where a third party can reuse a user's session.</source>
          <target state="translated">如果您的站点对用户进行身份验证，则每当用户进行身份验证时，它都应重新生成并重新发送会话cookie，甚至是已经存在的会话cookie。此技术有助于防止&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;会话固定攻击&lt;/a&gt;，在该攻击中第三方可以重用用户的会话。</target>
        </trans-unit>
        <trans-unit id="49d1c453e83057e2df00a9ddb4d5028bf92c87b6" translate="yes" xml:space="preserve">
          <source>If, instead, you need to adjust the server's behavior, you'll need to change the value of &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to grant access to the origin from which the client is loaded.</source>
          <target state="translated">相反，如果您需要调整服务器的行为，则需要更改 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 的值以授予对客户端加载源的访问权限。</target>
        </trans-unit>
        <trans-unit id="c4eca4702bbd3334f2af696c9113056ad66a8d93" translate="yes" xml:space="preserve">
          <source>If-Match</source>
          <target state="translated">If-Match</target>
        </trans-unit>
        <trans-unit id="347825cb2f6b585363c705da713b0a01a89c0771" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 2616)</source>
          <target state="translated">If-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="258eadb23d36147c17ca65c583464f10d8beefd5" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 7232)</source>
          <target state="translated">If-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="de1338853da05e0b2ef334c6d2a1bd4efd32b464" translate="yes" xml:space="preserve">
          <source>If-Modified-Since</source>
          <target state="translated">If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="434516b07ea046bbb5c4ac151f7538b608531da2" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 2616)</source>
          <target state="translated">If-Modified-Since (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="33cf8486927b13aa3ae6d7b4b5c2ba9856f2354e" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 7232)</source>
          <target state="translated">If-Modified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2c743ca76b5ff26374732b33a172bc6386b3aab3" translate="yes" xml:space="preserve">
          <source>If-None-Match</source>
          <target state="translated">If-None-Match</target>
        </trans-unit>
        <trans-unit id="afb97058113ea8024c2b1e30396497276d9e7529" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 2616)</source>
          <target state="translated">If-None-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9d29af1e2a7a4f8c799fff50073e73e2ee90bbe7" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 7232)</source>
          <target state="translated">If-None-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="3e610a822745a7648a28ddc376bb31e9d961b787" translate="yes" xml:space="preserve">
          <source>If-Range</source>
          <target state="translated">If-Range</target>
        </trans-unit>
        <trans-unit id="0db4229b3fe70c3cd52654ba3a313677c557a2f3" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 2616)</source>
          <target state="translated">If-Range (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="63c9a90407687da95ffa628c724bc3b45d1f6b45" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7232)</source>
          <target state="translated">If-Range (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="d239314fe40c1036bb99b7c1a04ab1559ed5e25b" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7233)</source>
          <target state="translated">If-Range (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="f07ea20e44175d8597a0629b88839dc18660c130" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since</source>
          <target state="translated">If-Unmodified-Since</target>
        </trans-unit>
        <trans-unit id="bd06e3f28f4c3da6f75241cead3ad85962385407" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since (RFC 2616)</source>
          <target state="translated">If-Unmodified-Since (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="dc5f0278046c847aae6cb54bbb6bf9f7d5e45609" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since (RFC 7232)</source>
          <target state="translated">If-Unmodified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="ae9940a55ac6950c887c90446b032a2b825302da" translate="yes" xml:space="preserve">
          <source>If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;
       [&quot;I am an ETag&quot;])
       ([&quot;I am another ETag&quot;])

   The previous header would require that the resource identified in the
   Request-URI be locked with the specified lock token and be in the
   state identified by the &quot;I am an ETag&quot; ETag or in the state
   identified by the second ETag &quot;I am another ETag&quot;.

   To put the matter more plainly one can think of the previous If
   header as expressing the condition below:

     (
       is-locked-with(urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2) AND
       matches-etag(&quot;I am an ETag&quot;)
     )
     OR
     (
       matches-etag(&quot;I am another ETag&quot;)
     )</source>
          <target state="translated">如果：（（&amp;lt;urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt; [&amp;ldquo;我是ETag&amp;rdquo;]）（[&amp;ldquo;我是另一个ETag&amp;rdquo;]）前一个标头将要求在Request- URI被指定的锁定令牌锁定，并且处于&amp;ldquo;我是ETag&amp;rdquo; ETag标识的状态，或者处于第二个ETag&amp;ldquo;我是另一个ETag&amp;rdquo;标识的状态。简而言之，可以想到前面的If头表示以下条件：（is-locked-with（urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2）AND matchs-etag（&amp;ldquo; ETag&amp;ldquo;））或（matches-etag（&amp;rdquo;我是另一个ETag&amp;ldquo;））</target>
        </trans-unit>
        <trans-unit id="e179e2a27f46763d373e2f3b6cb41b4cc29be61b" translate="yes" xml:space="preserve">
          <source>If: (Not &amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;
     &amp;lt;urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092&amp;gt;)

   This If header requires that the resource must not be locked with a
   lock having the lock token
   urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 and must be locked by a
   lock with the lock token
   urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092.</source>
          <target state="translated">如果：（不是&amp;lt;urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt; &amp;lt;urn：uuid：58f202ac-22cf-11d1-b12d-002035b29092&amp;gt;）此If标头要求不得使用具有锁令牌urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2，并且必须由带有锁令牌urn：uuid：58f202ac-22cf-11d1-b12d-002035b29092的锁锁定。</target>
        </trans-unit>
        <trans-unit id="90f12c5f5060f3384dd9dd32310436416b8fcc0b" translate="yes" xml:space="preserve">
          <source>Image or graphical data including both bitmap and vector still images as well as animated versions of still image formats such as animated &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/GIF&quot;&gt;GIF&lt;/a&gt; or APNG. Common examples are &lt;code&gt;image/jpeg&lt;/code&gt;, &lt;code&gt;image/png&lt;/code&gt;, and &lt;code&gt;image/svg+xml&lt;/code&gt;.</source>
          <target state="translated">图像或图形数据，包括位图和矢量静止图像，以及静止图像格式的动画版本，例如动画&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/GIF&quot;&gt;GIF&lt;/a&gt;或APNG。常见的示例是 &lt;code&gt;image/jpeg&lt;/code&gt; ， &lt;code&gt;image/png&lt;/code&gt; 和 &lt;code&gt;image/svg+xml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01602140e2a7c5c326242ee266afd5572f9bb02d" translate="yes" xml:space="preserve">
          <source>Image type</source>
          <target state="translated">图像类型</target>
        </trans-unit>
        <trans-unit id="6ae89c7f31fe68afd0052be4204a1384141e4bde" translate="yes" xml:space="preserve">
          <source>Image types</source>
          <target state="translated">图像类型</target>
        </trans-unit>
        <trans-unit id="7769fde23e24138d1e8d5303368e943a1ccb83f4" translate="yes" xml:space="preserve">
          <source>Images may load from anywhere (note the &quot;*&quot; wildcard).</source>
          <target state="translated">图片可以从任何地方加载(注意 &quot;*&quot;通配符)。</target>
        </trans-unit>
        <trans-unit id="4c18ce69b9abb0f85c6c4dd561b8fa929e369a90" translate="yes" xml:space="preserve">
          <source>Images/video frames drawn to a canvas using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage&quot;&gt;&lt;code&gt;drawImage()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage&quot;&gt; &lt;code&gt;drawImage()&lt;/code&gt; &lt;/a&gt;绘制到画布上的图像/视频帧。</target>
        </trans-unit>
        <trans-unit id="f257a0723093d9a811b4ad768559384cb6bd8ec4" translate="yes" xml:space="preserve">
          <source>Implementation notes for applications, vendors, and extensions</source>
          <target state="translated">应用程序、供应商和扩展的实施说明。</target>
        </trans-unit>
        <trans-unit id="da02a5e4655c1c65c2babb044e19b5d72a9968f1" translate="yes" xml:space="preserve">
          <source>Implementation-specific header that may have various effects anywhere along the request-response chain. Used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; header is not yet present.</source>
          <target state="translated">特定于实现的标头，可能在请求-响应链的任何地方产生各种影响。用于与尚未提供 &lt;code&gt;Cache-Control&lt;/code&gt; 标头的HTTP / 1.0缓存向后兼容。</target>
        </trans-unit>
        <trans-unit id="e1eb8fc6775c68df3e1147c016e8f5a910aa93c4" translate="yes" xml:space="preserve">
          <source>Implementations of HTTP origin servers SHOULD be careful to restrict
   the documents returned by HTTP requests to be only those that were
   intended by the server administrators. If an HTTP server translates
   HTTP URIs directly into file system calls, the server MUST take
   special care not to serve files that were not intended to be
   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and
   other operating systems use &quot;..&quot; as a path component to indicate a
   directory level above the current one. On such a system, an HTTP
   server MUST disallow any such construct in the Request-URI if it
   would otherwise allow access to a resource outside those intended to
   be accessible via the HTTP server. Similarly, files intended for
   reference only internally to the server (such as access control
   files, configuration files, and script code) MUST be protected from
   inappropriate retrieval, since they might contain sensitive
   information. Experience has shown that minor bugs in such HTTP server
   implementations have turned into security risks.</source>
          <target state="translated">HTTP起源服务器的实现必须小心地限制HTTP请求返回的文件只能是服务器管理员打算发送的文件。如果HTTP服务器将HTTP URI直接翻译成文件系统调用,服务器必须特别注意不要服务于那些不打算传递给HTTP客户端的文件。例如,UNIX、Microsoft Windows和其他操作系统使用&quot;.&quot;作为路径组件来表示高于当前目录的目录级别。在这样的系统中,HTTP服务器必须禁止在Request-URI中使用任何这样的结构,否则它将允许访问那些通过HTTP服务器访问的资源之外的资源。同样,那些只用于服务器内部引用的文件(如访问控制文件、配置文件和脚本代码)必须受到保护,以免被不适当的检索,因为它们可能包含敏感信息。经验表明,这种HTTP服务器实现中的小错误已经变成了安全风险。</target>
        </trans-unit>
        <trans-unit id="02431df0d7457d0f94a64ba6def9dc24dd976c81" translate="yes" xml:space="preserve">
          <source>Implementations of HTTP/2 MUST use TLS version 1.2 [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;] or higher
   for HTTP/2 over TLS.  The general TLS usage guidance in [&lt;a href=&quot;#ref-TLSBCP&quot;&gt;TLSBCP&lt;/a&gt;]
   SHOULD be followed, with some additional restrictions that are
   specific to HTTP/2.

   The TLS implementation MUST support the Server Name Indication (SNI)
   [&lt;a href=&quot;#ref-TLS-EXT&quot;&gt;TLS-EXT&lt;/a&gt;] extension to TLS.  HTTP/2 clients MUST indicate the target
   domain name when negotiating TLS.

   Deployments of HTTP/2 that negotiate TLS 1.3 or higher need only
   support and use the SNI extension; deployments of TLS 1.2 are subject
   to the requirements in the following sections.  Implementations are
   encouraged to provide defaults that comply, but it is recognized that
   deployments are ultimately responsible for compliance.</source>
          <target state="translated">对于通过TLS的HTTP / 2，HTTP / 2的实现必须使用TLS版本1.2 [ &lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt; ]或更高版本。应当遵循[ &lt;a href=&quot;#ref-TLSBCP&quot;&gt;TLSBCP&lt;/a&gt; ]中的常规TLS使用指南，并带有一些特定于HTTP / 2的附加限制。 TLS实现必须支持TLS的服务器名称指示（SNI）[ &lt;a href=&quot;#ref-TLS-EXT&quot;&gt;TLS-EXT&lt;/a&gt; ]扩展。协商TLS时，HTTP / 2客户端务必指示目标域名。协商TLS 1.3或更高版本的HTTP / 2部署只需要支持和使用SNI扩展即可； TLS 1.2的部署必须遵守以下各节的要求。鼓励实现提供符合要求的默认值，但应认识到，部署最终要负责遵从性。</target>
        </trans-unit>
        <trans-unit id="14daa0dc1eaa5670a20dd5d15e7e163107880fe7" translate="yes" xml:space="preserve">
          <source>Implemented as X-Content-Security-Policy header in Firefox 4.</source>
          <target state="translated">在Firefox 4中作为X-Content-Security-Policy头实现。</target>
        </trans-unit>
        <trans-unit id="603ce634b762f92f6e05c3f3e6b9b238a85f5318" translate="yes" xml:space="preserve">
          <source>Implemented as X-Content-Security-Policy header, only supporting 'sandbox' directive.</source>
          <target state="translated">作为X-Content-Security-Policy头实现,只支持 &quot;沙箱 &quot;指令。</target>
        </trans-unit>
        <trans-unit id="3b13dd24d3dc6eaf8faafe83a8f22898c5b86d5d" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in Chrome 14.</source>
          <target state="translated">在Chrome 14中作为X-Webkit-CSP头实现。</target>
        </trans-unit>
        <trans-unit id="b0eba0ad36d67027ac7933274e7042a9d3fc6e6f" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in Safari 6.</source>
          <target state="translated">在Safari 6中作为X-Webkit-CSP头实现。</target>
        </trans-unit>
        <trans-unit id="cb60fa324f738059434ec9f563fd92bd6eb364fe" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in iOS 5.1.</source>
          <target state="translated">在iOS 5.1中作为X-Webkit-CSP头实现。</target>
        </trans-unit>
        <trans-unit id="60d472d41f188e74df2d9f7da2711afae460cd86" translate="yes" xml:space="preserve">
          <source>Implementers are advised to pay attention to cache controls and to
   make use of the mechanisms available in HTTP when editing Resources,
   in particular, entity-tags as outlined in [&lt;a href=&quot;#ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt;].
   Clients are not assured to receive the most recent representations of
   Collection Members using GET if the server is authorizing
   intermediaries to cache them.</source>
          <target state="translated">建议实施者在编辑资源时，特别是在[ &lt;a href=&quot;#ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt; ]中概述的实体标签时，请注意缓存控件并使用HTTP中可用的机制。如果服务器授权中介对其进行缓存，则不能保证客户端会使用GET接收Collection成员的最新表示。</target>
        </trans-unit>
        <trans-unit id="e3af5ce8ec47b166e13f8ce8cbe13ad9af1cdf60" translate="yes" xml:space="preserve">
          <source>Implementors should be aware that the software represents the user in
   their interactions over the Internet, and should be careful to allow
   the user to be aware of any actions they might take which may have an
   unexpected significance to themselves or others.

   In particular, the convention has been established that the GET and
   HEAD methods SHOULD NOT have the significance of taking an action
   other than retrieval. These methods ought to be considered &quot;safe&quot;.
   This allows user agents to represent other methods, such as POST, PUT
   and DELETE, in a special way, so that the user is made aware of the
   fact that a possibly unsafe action is being requested.

   Naturally, it is not possible to ensure that the server does not
   generate side-effects as a result of performing a GET request; in
   fact, some dynamic resources consider that a feature. The important
   distinction here is that the user did not request the side-effects,
   so therefore cannot be held accountable for them.</source>
          <target state="translated">实施者应该意识到,软件代表着用户在互联网上的互动,应该小心翼翼地让用户意识到他们可能采取的任何行动,这些行动可能对他们自己或其他人有意想不到的意义。特别是,约定俗成的是,GET和HEAD方法不应该具有采取检索以外的行动的意义。这些方法应该被认为是 &quot;安全的&quot;。这使得用户代理可以用一种特殊的方式来表示其他方法,如POST、PUT和DELETE,从而使用户意识到正在请求一个可能不安全的操作。当然,不可能保证服务器不会因为执行GET请求而产生副作用,事实上,一些动态资源认为这是一个特性。这里重要的区别在于,用户并没有请求产生副作用,因此不能对这些副作用负责。</target>
        </trans-unit>
        <trans-unit id="9f5bcb265afe8c10a0333f200168f39077ccb2a2" translate="yes" xml:space="preserve">
          <source>Importance of setting the correct MIME type</source>
          <target state="translated">设置正确的MIME类型的重要性</target>
        </trans-unit>
        <trans-unit id="50b4adf7a95c03b87b497db3ec73f7756f713782" translate="yes" xml:space="preserve">
          <source>Important MIME types for Web developers</source>
          <target state="translated">对网络开发者来说,重要的MIME类型</target>
        </trans-unit>
        <trans-unit id="a9147f5aaafb06475c8b837fee41cebfad64027d" translate="yes" xml:space="preserve">
          <source>Improved connection management allows considerable boosting of performance in HTTP. With HTTP/1.1 or HTTP/1.0, using a persistent connection &amp;ndash; at least until it becomes idle &amp;ndash; leads to the best performance. However, the failure of pipelining has lead to designing superior connection management models, which have been incorporated into HTTP/2.</source>
          <target state="translated">改进的连接管理可大大提高HTTP的性能。在HTTP / 1.1或HTTP / 1.0中，使用持久连接（至少直到它变为空闲状态）才能获得最佳性能。但是，流水线操作的失败导致设计出了高级的连接管理模型，该模型已合并到HTTP / 2中。</target>
        </trans-unit>
        <trans-unit id="ed3056eb7dfdbbf414ed2c77758a13ddb4dea4dc" translate="yes" xml:space="preserve">
          <source>In 1989, while he was working at CERN, Tim Berners-Lee wrote a proposal to build a hypertext system over the Internet. Initially calling it the &lt;em&gt;Mesh&lt;/em&gt;, it was later renamed to &lt;em&gt;World Wide Web&lt;/em&gt; during its implementation in 1990. Built over the existing TCP and IP protocols, it consisted of 4 building blocks:</source>
          <target state="translated">1989年，当他在欧洲核子研究组织（CERN）工作时，蒂姆&amp;middot;伯纳斯&amp;middot;李（Tim Berners-Lee）提出了一项在互联网上建立超文本系统的建议。最初将其称为&lt;em&gt;Mesh&lt;/em&gt;，后来在1990年实施期间将其重命名为&lt;em&gt;World Wide Web&lt;/em&gt;。它基于现有的TCP和IP协议构建，包括4个构建块：</target>
        </trans-unit>
        <trans-unit id="bc75911a51c61595cb9f9517b6870c9ae4a76b47" translate="yes" xml:space="preserve">
          <source>In 200 (OK) responses to GET or HEAD, an origin server:

   o  SHOULD send an entity-tag validator unless it is not feasible to
      generate one.

   o  MAY send a weak entity-tag instead of a strong entity-tag, if
      performance considerations support the use of weak entity-tags, or
      if it is unfeasible to send a strong entity-tag.

   o  SHOULD send a Last-Modified value if it is feasible to send one.

   In other words, the preferred behavior for an origin server is to
   send both a strong entity-tag and a Last-Modified value in successful
   responses to a retrieval request.

   A client:

   o  MUST send that entity-tag in any cache validation request (using
      If-Match or If-None-Match) if an entity-tag has been provided by
      the origin server. 

   o  SHOULD send the Last-Modified value in non-subrange cache
      validation requests (using If-Modified-Since) if only a
      Last-Modified value has been provided by the origin server.

   o  MAY send the Last-Modified value in subrange cache validation
      requests (using If-Unmodified-Since) if only a Last-Modified value
      has been provided by an HTTP/1.0 origin server.  The user agent
      SHOULD provide a way to disable this, in case of difficulty.

   o  SHOULD send both validators in cache validation requests if both
      an entity-tag and a Last-Modified value have been provided by the
      origin server.  This allows both HTTP/1.0 and HTTP/1.1 caches to
      respond appropriately.</source>
          <target state="translated">在对GET或HEAD的200(OK)响应中,起源服务器:o应该发送实体标记验证器,除非生成实体标记不可行。 o如果性能考虑支持使用弱实体标记,或者发送强实体标记不可行,可以发送弱实体标记而不是强实体标记。换句话说,源服务器的首选行为是在成功响应检索请求时同时发送强实体标记和Last-Modified值。客户端:o 如果起源服务器提供了实体标记,则必须在任何缓存验证请求中(使用If-Match或If-None-Match)发送实体标记。 o 如果起源服务器只提供了Last-Modified值,则应该在非子范围缓存验证请求中(使用If-Modified-Since)发送Last-Modified值。 o 如果HTTP/1.0起源服务器只提供了Last-Modified值,则可以在子范围缓存验证请求中(使用If-Unmodified-Since)发送Last-Modified值。o 如果源服务器提供了实体标签和Last-Modified值,则应在缓存验证请求中同时发送验证器。这允许HTTP/1.0和HTTP/1.1缓存做出适当的响应。</target>
        </trans-unit>
        <trans-unit id="296574e47729d1eae5c728c2cee0ace56802d4ed" translate="yes" xml:space="preserve">
          <source>In 2000, a new pattern for using HTTP was designed: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/REST&quot;&gt;representational state transfer&lt;/a&gt; (or REST). The actions induced by the API were no more conveyed by new HTTP methods, but only by accessing specific URIs with basic HTTP/1.1 methods. This allowed any Web application to provide an API to allow retrieval and modification of its data without having to update the browsers or the servers: all what is needed was embedded in the files served by the Web sites through standard HTTP/1.1. The drawback of the REST model resides in the fact that each website defines its own non-standard RESTful API and has total control on it; unlike the *DAV extensions were clients and servers are interoperable. RESTful APIs became very common in the 2010s.</source>
          <target state="translated">在2000年，设计了一种使用HTTP的新模式：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/REST&quot;&gt;代表性状态传输&lt;/a&gt;（或REST）。由API引发的动作不再通过新的HTTP方法来传达，而仅通过使用基本HTTP / 1.1方法访问特定的URI来传达。这样，任何Web应用程序都可以提供API，从而无需更新浏览器或服务器就可以检索和修改其数据：所需的所有内容都通过标准HTTP / 1.1嵌入到Web站点提供的文件中。 REST模型的缺点在于，每个网站都定义自己的非标准RESTful API并对其进行完全控制。与* DAV扩展不同，客户端和服务器是可互操作的。 RESTful API在2010年代变得非常普遍。</target>
        </trans-unit>
        <trans-unit id="53750ef40f057be1a7ae8ba66d6a43963e269f50" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;, a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;preflight request&lt;/a&gt; is sent with the &lt;code&gt;OPTIONS&lt;/code&gt; method so that the server can respond if it is acceptable to send the request. In this example, we will request permission for these parameters:</source>
          <target state="translated">在&lt;a href=&quot;../cors&quot;&gt;CORS中&lt;/a&gt;，使用 &lt;code&gt;OPTIONS&lt;/code&gt; 方法发送&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;预检请求&lt;/a&gt;，以便服务器可以接受发送请求的响应。在此示例中，我们将请求以下参数的权限：</target>
        </trans-unit>
        <trans-unit id="97be88d1cc954daadbfa1c4539779b9d17810aba" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;, a preflight request with the &lt;code&gt;OPTIONS&lt;/code&gt; method is sent, so that the server can respond whether it is acceptable to send the request with these parameters. The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">在&lt;a href=&quot;../cors&quot;&gt;CORS中&lt;/a&gt;，使用 &lt;code&gt;OPTIONS&lt;/code&gt; 方法发送预检请求，以便服务器可以响应是否可以使用这些参数发送请求。的&lt;a href=&quot;../headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;报头通知的服务器作为预检请求的一部分被发送的实际请求时，它将被与发送 &lt;code&gt;POST&lt;/code&gt; 请求方法。该&lt;a href=&quot;../headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;报头通知服务器，发送的实际请求时，它将被发送的 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 和 &lt;code&gt;Content-Type&lt;/code&gt; 的自定义页眉。服务器现在有机会确定在这种情况下是否希望接受请求。</target>
        </trans-unit>
        <trans-unit id="22094d906cb0cb930d1261041451d23d682d9443" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt;, &lt;em&gt;&lt;strong&gt;content negotiation&lt;/strong&gt;&lt;/em&gt; is the mechanism that is used for serving different representations of a resource at the same URI, so that the user agent can specify which is best suited for the user (for example, which language of a document, which image format, or which content encoding).</source>
          <target state="translated">在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP中&lt;/a&gt;，&lt;em&gt;&lt;strong&gt;内容协商&lt;/strong&gt;&lt;/em&gt;是一种用于在同一URI上提供资源的不同表示的机制，以便用户代理可以指定最适合用户的内容（例如，文档的哪种语言，哪种图像格式） ，或哪种内容编码）。</target>
        </trans-unit>
        <trans-unit id="540a387e018d2b957b00f9cf9c29e94b9b95ff1e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; terms this is the &lt;em&gt;selected representation&lt;/em&gt; of a resource. The selected representation depends on the &lt;code&gt;&lt;a href=&quot;content-type&quot;&gt;Content-Type&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;content-encoding&quot;&gt;Content-Encoding&lt;/a&gt;&lt;/code&gt; header values: so a single resource may have multiple different digest values.</source>
          <target state="translated">用&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;术语来说，这是资源的&lt;em&gt;选定表示形式&lt;/em&gt;。所选表示形式取决于 &lt;code&gt;&lt;a href=&quot;content-type&quot;&gt;Content-Type&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;content-encoding&quot;&gt;Content-Encoding&lt;/a&gt;&lt;/code&gt; 标头值：因此，单个资源可能具有多个不同的摘要值。</target>
        </trans-unit>
        <trans-unit id="14de70e40c9e2cf5302c938ea374541877e07084" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;server-driven content negotiation&lt;/em&gt;, or proactive content negotiation, the browser (or any other kind of user-agent) sends several HTTP headers along with the URL. These headers describe the preferred choice of the user. The server uses them as hints and an internal algorithm chooses the best content to serve to the client. If it cannot provide a suitable resource, as a fallback it might respond with &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) or &lt;a href=&quot;status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt; (Unsupported Media Type) and set headers for the types of media that it does support (e.g. using the &lt;a href=&quot;headers/accept-post&quot;&gt;&lt;code&gt;Accept-Post&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/accept-patch&quot;&gt;&lt;code&gt;Accept-Patch&lt;/code&gt;&lt;/a&gt; for POST and PATCH requests, respectively). The algorithm is server-specific and not defined in the standard. See, for example, the &lt;a href=&quot;http://httpd.apache.org/docs/current/en/content-negotiation.html#algorithm&quot;&gt;Apache negotiation algorithm&lt;/a&gt;.</source>
          <target state="translated">在&lt;em&gt;服务器驱动的内容协商&lt;/em&gt;或主动内容协商中，浏览器（或任何其他类型的用户代理）将随URL发送几个HTTP标头。这些标题描述了用户的首选。服务器将它们用作提示，并且内部算法选择最佳内容来提供给客户端。如果无法提供合适的资源，则作为备用，它可能会响应&lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受）或&lt;a href=&quot;status/415&quot;&gt; &lt;code&gt;415&lt;/code&gt; &lt;/a&gt;（不支持的媒体类型），并为其支持的媒体类型设置标头（例如，使用&lt;a href=&quot;headers/accept-post&quot;&gt; &lt;code&gt;Accept-Post&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;headers/accept-patch&quot;&gt; &lt;code&gt;Accept-Patch&lt;/code&gt; )&lt;/a&gt;分别用于POST和PATCH请求）。该算法是特定于服务器的，未在标准中定义。参见，例如&lt;a href=&quot;http://httpd.apache.org/docs/current/en/content-negotiation.html#algorithm&quot;&gt;Apache协商算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b2cc0cdd9eebe0ffa83a9c0ecef388a60a0a8d4" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;server-driven content negotiation&lt;/em&gt;, or proactive content negotiation, the browser (or any other kind of user-agent) sends several HTTP headers along with the URL. These headers describe the preferred choice of the user. The server uses them as hints and an internal algorithm chooses the best content to serve to the client. If it cannot provide a suitable resource, as a fallback it might respond with &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) or &lt;a href=&quot;status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt; (Unsupported Media Type) and set headers for the types of media that it does support (e.g. using the &lt;a href=&quot;headers/accept-post&quot;&gt;&lt;code&gt;Accept-Post&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/accept-patch&quot;&gt;&lt;code&gt;Accept-Patch&lt;/code&gt;&lt;/a&gt; for POST and PATCH requests, respectively). The algorithm is server-specific and not defined in the standard. See, for example, the &lt;a href=&quot;https://httpd.apache.org/docs/current/en/content-negotiation.html#algorithm&quot;&gt;Apache negotiation algorithm&lt;/a&gt;.</source>
          <target state="translated">在&lt;em&gt;服务器驱动的内容协商&lt;/em&gt;或主动内容协商中，浏览器（或任何其他类型的用户代理）将随URL发送几个HTTP标头。这些标题描述了用户的首选。服务器将它们用作提示，并且内部算法选择最佳内容来提供给客户端。如果无法提供合适的资源，则作为备用，它可能会响应&lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受）或&lt;a href=&quot;status/415&quot;&gt; &lt;code&gt;415&lt;/code&gt; &lt;/a&gt;（不支持的媒体类型），并为其支持的媒体类型设置标头（例如，使用&lt;a href=&quot;headers/accept-post&quot;&gt; &lt;code&gt;Accept-Post&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;headers/accept-patch&quot;&gt; &lt;code&gt;Accept-Patch&lt;/code&gt; )&lt;/a&gt;分别用于POST和PATCH请求）。该算法是特定于服务器的，未在标准中定义。参见，例如&lt;a href=&quot;https://httpd.apache.org/docs/current/en/content-negotiation.html#algorithm&quot;&gt;Apache协商算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6df737fe0a6a8b38fe1752df0541af98393864b5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;server-driven content negotiation&lt;/em&gt;, or proactive content negotiation, the browser (or any other kind of user-agent) sends several HTTP headers along with the URL. These headers describe the preferred choice of the user. The server uses them as hints and an internal algorithm chooses the best content to serve to the client. The algorithm is server-specific and not defined in the standard. See, for example, the &lt;a href=&quot;http://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm&quot;&gt;Apache 2.2 negotiation algorithm&lt;/a&gt;.</source>
          <target state="translated">在&lt;em&gt;服务器驱动的内容协商&lt;/em&gt;或主动内容协商中，浏览器（或任何其他类型的用户代理）将发送几个HTTP标头以及URL。这些标题描述了用户的首选。服务器将它们用作提示，并且内部算法选择最佳内容来提供给客户端。该算法是特定于服务器的，未在标准中定义。参见例如&lt;a href=&quot;http://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm&quot;&gt;Apache 2.2协商算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e9a7352b90de016d5e9b783df62c3686f4fe3ba" translate="yes" xml:space="preserve">
          <source>In Firefox 65 and earlier, this value can be modified using the &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt;&lt;code&gt;network.http.accept.default&lt;/code&gt;&lt;/a&gt; parameter. (&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;source)&lt;/a&gt;</source>
          <target state="translated">在Firefox 65及更早版本中，可以使用&lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt; &lt;code&gt;network.http.accept.default&lt;/code&gt; &lt;/a&gt;参数修改此值。（&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;来源）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36ba735989d6fe47e4bb59a9a9e8824168509fbe" translate="yes" xml:space="preserve">
          <source>In Firefox 66, the default &lt;code&gt;Accept&lt;/code&gt; header value changed to &lt;code&gt;*/*&lt;/code&gt;.</source>
          <target state="translated">在Firefox 66中，默认的 &lt;code&gt;Accept&lt;/code&gt; 标头值更改为 &lt;code&gt;*/*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8513ce94ddf5be70926f38324a0c5067702e67d" translate="yes" xml:space="preserve">
          <source>In Firefox, the preference that disables CORS is &lt;code&gt;content.cors.disable&lt;/code&gt;. Setting this to &lt;code&gt;true&lt;/code&gt; disables CORS, so whenever that's the case, CORS requests will always fail with this error.</source>
          <target state="translated">在Firefox中，禁用CORS的首选项为 &lt;code&gt;content.cors.disable&lt;/code&gt; 。将此设置为 &lt;code&gt;true&lt;/code&gt; 将禁用CORS，因此，在这种情况下，CORS请求将始终因此错误而失败。</target>
        </trans-unit>
        <trans-unit id="77ae93055516fe4030d75a83ef29b37fe614cda5" translate="yes" xml:space="preserve">
          <source>In HTTP, a redirection is triggered by the server by sending special responses to a request: &lt;em&gt;redirects&lt;/em&gt;. HTTP redirects are responses with a status code of &lt;code&gt;3xx&lt;/code&gt;. A browser, when receiving a redirect response, uses the new URL provided and immediately loads it: most of the time, the redirection is transparent to the user, besides a small performance hit.</source>
          <target state="translated">在HTTP中，服务器通过向请求发送特殊响应来触发重定向：&lt;em&gt;redirects&lt;/em&gt;。HTTP重定向是状态码为 &lt;code&gt;3xx&lt;/code&gt; 的响应。浏览器在收到重定向响应时，将使用提供的新URL并立即将其加载：大多数情况下，重定向对用户是透明的，除了对性能的影响不大。</target>
        </trans-unit>
        <trans-unit id="de2ff1ebd7f691f8616060d0addc5c76e9eb2d6a" translate="yes" xml:space="preserve">
          <source>In HTTP, redirection is triggered by a server sending a special &lt;em&gt;redirect&lt;/em&gt; response to a request. Redirect responses have &lt;a href=&quot;status&quot;&gt;status codes&lt;/a&gt; that start with &lt;code&gt;3&lt;/code&gt;, and a &lt;a href=&quot;headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header holding the URL to redirect to.</source>
          <target state="translated">在HTTP中，重定向是由服务器发送对请求的特殊&lt;em&gt;重定向&lt;/em&gt;响应来触发的。重定向响应具有以 &lt;code&gt;3&lt;/code&gt; 开头的&lt;a href=&quot;status&quot;&gt;状态代码&lt;/a&gt;，以及一个包含要重定向到的URL的&lt;a href=&quot;headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="37f3f173cc83c393621e6b6a49dbe5d27a1b2c33" translate="yes" xml:space="preserve">
          <source>In HTTP/1.0, each connection is established by the client prior to
   the request and closed by the server after sending the response.
   However, some implementations implement the explicitly negotiated
   (&quot;Keep-Alive&quot;) version of persistent connections described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;19.7.1 of [RFC2068]&lt;/a&gt;.

   Some clients and servers might wish to be compatible with these
   previous approaches to persistent connections, by explicitly
   negotiating for them with a &quot;Connection: keep-alive&quot; request header
   field.  However, some experimental implementations of HTTP/1.0
   persistent connections are faulty; for example, if an HTTP/1.0 proxy
   server doesn't understand Connection, it will erroneously forward
   that header field to the next inbound server, which would result in a
   hung connection.

   One attempted solution was the introduction of a Proxy-Connection
   header field, targeted specifically at proxies.  In practice, this
   was also unworkable, because proxies are often deployed in multiple
   layers, bringing about the same problem discussed above.

   As a result, clients are encouraged not to send the Proxy-Connection
   header field in any requests.

   Clients are also encouraged to consider the use of Connection:
   keep-alive in requests carefully; while they can enable persistent
   connections with HTTP/1.0 servers, clients using them will need to
   monitor the connection for &quot;hung&quot; requests (which indicate that the
   client ought stop sending the header field), and this mechanism ought
   not be used by clients at all when a proxy is being used.</source>
          <target state="translated">在HTTP / 1.0中，每个连接都是由客户端在请求之前建立的，并在发送响应后由服务器关闭的。但是，某些实现实现了&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;[RFC2068] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;第&lt;/a&gt;19.7.1 节中描述的持久连接的显式协商（&amp;ldquo;保持活动&amp;rdquo;）版本。。某些客户端和服务器可能希望与以前的持久连接方法兼容，方法是与&amp;ldquo;连接：保持活动&amp;rdquo;请求标头字段进行显式协商。但是，HTTP / 1.0持久连接的一些实验性实现存在错误；例如，如果HTTP / 1.0代理服务器不理解Connection，它将错误地将该标头字段转发到下一个入站服务器，这将导致挂起连接。一种尝试的解决方案是引入专门针对代理的Proxy-Connection标头字段。在实践中，这也是不可行的，因为代理通常部署在多个层中，从而导致上面讨论的相同问题。结果是，鼓励客户端不要在任何请求中发送Proxy-Connection标头字段。还鼓励客户考虑使用Connection：仔细保持请求中的活动；虽然它们可以启用与HTTP / 1.0服务器的持久连接，但使用它们的客户端将需要监视连接以获取&amp;ldquo;挂起&amp;rdquo;请求（这表明客户端应停止发送标头字段），并且客户端不应使用此机制所有在使用代理时。请求（表示客户端应停止发送标头字段），并且在使用代理时客户端完全不应使用此机制。请求（表示客户端应停止发送标头字段），并且在使用代理时客户端完全不应使用此机制。</target>
        </trans-unit>
        <trans-unit id="9ffd86097b1c5adb86cfedee2cc99d4dbaaa41d5" translate="yes" xml:space="preserve">
          <source>In HTTP/1.1, an HTTP client is unable to retry a non-idempotent
   request when an error occurs because there is no means to determine
   the nature of the error.  It is possible that some server processing
   occurred prior to the error, which could result in undesirable
   effects if the request were reattempted.

   HTTP/2 provides two mechanisms for providing a guarantee to a client
   that a request has not been processed:

   o  The GOAWAY frame indicates the highest stream number that might
      have been processed.  Requests on streams with higher numbers are
      therefore guaranteed to be safe to retry.

   o  The REFUSED_STREAM error code can be included in a RST_STREAM
      frame to indicate that the stream is being closed prior to any
      processing having occurred.  Any request that was sent on the
      reset stream can be safely retried.

   Requests that have not been processed have not failed; clients MAY
   automatically retry them, even those with non-idempotent methods.

   A server MUST NOT indicate that a stream has not been processed
   unless it can guarantee that fact.  If frames that are on a stream
   are passed to the application layer for any stream, then
   REFUSED_STREAM MUST NOT be used for that stream, and a GOAWAY frame
   MUST include a stream identifier that is greater than or equal to the
   given stream identifier.

   In addition to these mechanisms, the PING frame provides a way for a
   client to easily test a connection.  Connections that remain idle can
   become broken as some middleboxes (for instance, network address
   translators or load balancers) silently discard connection bindings.
   The PING frame allows a client to safely test whether a connection is
   still active without sending a request.</source>
          <target state="translated">在HTTP/1.1中,当发生错误时,HTTP客户端无法重试一个非幂等的请求,因为没有办法确定错误的性质。有可能在错误发生之前,服务器发生了一些处理,如果重新尝试该请求,可能会造成不良影响。HTTP/2提供了两种机制来向客户端提供请求未被处理的保证:o GOAWAY帧表示可能被处理的最高流号。o REFUSED_STREAM错误代码可以包含在RST_STREAM帧中,以表明流在任何处理发生之前被关闭。任何在复位流上发送的请求都可以安全地重试。没有被处理的请求并没有失败;客户端可以自动重试它们,即使是那些使用非幂等方法的请求。除非服务器能保证一个流没有被处理,否则它决不能表明这个事实。如果任何流上的帧被传递给应用层,那么REFUSED_STREAM必须不用于该流,GOAWAY帧必须包含一个大于或等于给定流标识符的流标识符。除了这些机制之外,PING帧还提供了一种方法,让客户机可以轻松测试连接。由于一些中间盒(例如,网络地址翻译器或负载平衡器)会默默地丢弃连接绑定,因此保持空闲的连接可能会变得中断。PING帧允许客户端安全地测试一个连接是否仍然处于活动状态,而无需发送请求。</target>
        </trans-unit>
        <trans-unit id="252a80be2932a5745af0ff3008231856ec0831a7" translate="yes" xml:space="preserve">
          <source>In HTTP/1.1, method parameter information was exclusively encoded in
   HTTP headers.  Unlike HTTP/1.1, WebDAV encodes method parameter
   information either in an XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) request entity body, or in
   an HTTP header.  The use of XML to encode method parameters was
   motivated by the ability to add extra XML elements to existing
   structures, providing extensibility; and by XML's ability to encode
   information in ISO 10646 character sets, providing
   internationalization support.

   In addition to encoding method parameters, XML is used in WebDAV to
   encode the responses from methods, providing the extensibility and
   internationalization advantages of XML for method output, as well as
   input.

   When XML is used for a request or response body, the Content-Type
   type SHOULD be application/xml.  Implementations MUST accept both
   text/xml and application/xml in request and response bodies.  Use of
   text/xml is deprecated.

   All DAV-compliant clients and resources MUST use XML parsers that are
   compliant with [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;] and [&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;].  All XML used in either
   requests or responses MUST be, at minimum, well formed and use
   namespaces correctly.  If a server receives XML that is not well-
   formed, then the server MUST reject the entire request with a 400
   (Bad Request).  If a client receives XML that is not well-formed in a
   response, then the client MUST NOT assume anything about the outcome
   of the executed method and SHOULD treat the server as malfunctioning.

   Note that processing XML submitted by an untrusted source may cause
   risks connected to privacy, security, and service quality (see
   &lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).  Servers MAY reject questionable requests (even though
   they consist of well-formed XML), for instance, with a 400 (Bad
   Request) status code and an optional response body explaining the
   problem.</source>
          <target state="translated">在HTTP / 1.1中，方法参数信息专门编码在HTTP标头中。与HTTP / 1.1不同，WebDAV以XML（[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]）请求实体主体，或在HTTP标头中。使用XML编码方法参数的动机是能够将额外的XML元素添加到现有结构中，从而提供了可扩展性。以及XML能够以ISO 10646字符集编码信息的能力，从而提供国际化支持。除了对方法参数进行编码之外，WebDAV中还使用XML来对方法的响应进行编码，从而为方法输出和输入提供XML的可扩展性和国际化优势。当XML用于请求或响应主体时，Content-Type类型应为application / xml。实现必须在请求和响应主体中接受text / xml和application / xml。不推荐使用text / xml。所有符合DAV的客户端和资源都必须使用与[&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]和[ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt; ]。请求或响应中使用的所有XML至少必须格式正确，并正确使用名称空间。如果服务器收到格式不正确的XML，则该服务器务必以400（错误请求）拒绝整个请求。如果客户端收到的响应格式不正确的XML，则客户端不得对已执行方法的结果承担任何责任，并且应将服务器视为发生故障。请注意，处理不受信任来源提交的XML可能会导致与隐私，安全性和服务质量相关的风险（请参阅 &lt;a href=&quot;#section-20&quot;&gt;第20节）。&lt;/a&gt;）。服务器可以拒绝可疑的请求（即使它们由格式正确的XML组成），例如，带有400（错误请求）状态码和可选的响应正文（说明问题）。</target>
        </trans-unit>
        <trans-unit id="04b117019d6e8bc547e56f34a1e382befb6df3b1" translate="yes" xml:space="preserve">
          <source>In HTTP/1.1, persistence is the default, and the header is no longer needed (but it is often added as a defensive measure against cases requiring a fallback to HTTP/1.0).</source>
          <target state="translated">在HTTP/1.1中,持久性是默认的,不再需要该头(但它通常被添加为防御措施,以应对需要回退到HTTP/1.0的情况)。</target>
        </trans-unit>
        <trans-unit id="d692e156c4939ed8150ce5ebd6b39b65ad2fc836" translate="yes" xml:space="preserve">
          <source>In HTTP/1.x, the pseudo-method CONNECT (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231], Section&amp;nbsp;4.3.6&lt;/a&gt;) is
   used to convert an HTTP connection into a tunnel to a remote host.
   CONNECT is primarily used with HTTP proxies to establish a TLS
   session with an origin server for the purposes of interacting with
   &quot;https&quot; resources.

   In HTTP/2, the CONNECT method is used to establish a tunnel over a
   single HTTP/2 stream to a remote host for similar purposes.  The HTTP
   header field mapping works as defined in &lt;a href=&quot;#section-8.1.2.3&quot;&gt;Section 8.1.2.3&lt;/a&gt; (&quot;Request
   Pseudo-Header Fields&quot;), with a few differences.  Specifically:

   o  The &quot;:method&quot; pseudo-header field is set to &quot;CONNECT&quot;.

   o  The &quot;:scheme&quot; and &quot;:path&quot; pseudo-header fields MUST be omitted.

   o  The &quot;:authority&quot; pseudo-header field contains the host and port to
      connect to (equivalent to the authority-form of the request-target
      of CONNECT requests (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230], Section&amp;nbsp;5.3&lt;/a&gt;)).

   A CONNECT request that does not conform to these restrictions is
   malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).

   A proxy that supports CONNECT establishes a TCP connection [&lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;] to
   the server identified in the &quot;:authority&quot; pseudo-header field.  Once
   this connection is successfully established, the proxy sends a
   HEADERS frame containing a 2xx series status code to the client, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231], Section&amp;nbsp;4.3.6&lt;/a&gt;.

   After the initial HEADERS frame sent by each peer, all subsequent
   DATA frames correspond to data sent on the TCP connection.  The
   payload of any DATA frames sent by the client is transmitted by the
   proxy to the TCP server; data received from the TCP server is
   assembled into DATA frames by the proxy.  Frame types other than DATA
   or stream management frames (RST_STREAM, WINDOW_UPDATE, and PRIORITY)
   MUST NOT be sent on a connected stream and MUST be treated as a
   stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) if received.

   The TCP connection can be closed by either peer.  The END_STREAM flag
   on a DATA frame is treated as being equivalent to the TCP FIN bit.  A
   client is expected to send a DATA frame with the END_STREAM flag set
   after receiving a frame bearing the END_STREAM flag.  A proxy that
   receives a DATA frame with the END_STREAM flag set sends the attached
   data with the FIN bit set on the last TCP segment.  A proxy that
   receives a TCP segment with the FIN bit set sends a DATA frame with
   the END_STREAM flag set.  Note that the final TCP segment or DATA
   frame could be empty. 

   A TCP connection error is signaled with RST_STREAM.  A proxy treats
   any error in the TCP connection, which includes receiving a TCP
   segment with the RST bit set, as a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of
   type CONNECT_ERROR.  Correspondingly, a proxy MUST send a TCP segment
   with the RST bit set if it detects an error with the stream or the
   HTTP/2 connection.</source>
          <target state="translated">在HTTP / 1.x中，伪方法CONNECT（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]，第4.3.6节&lt;/a&gt;）用于将HTTP连接转换为通往远程主机的隧道。 CONNECT主要与HTTP代理一起使用，以与源服务器建立TLS会话，以便与&amp;ldquo; https&amp;rdquo;资源进行交互。在HTTP / 2中，出于类似目的，CONNECT方法用于在单个HTTP / 2流上建立到远程主机的隧道。 HTTP标头字段映射按&lt;a href=&quot;#section-8.1.2.3&quot;&gt;第8.1.2.3节中的&lt;/a&gt;定义工作（&amp;ldquo;请求伪标题字段&amp;rdquo;），但有一些区别。具体来说：o&amp;ldquo;：method&amp;rdquo;伪标题字段设置为&amp;ldquo; CONNECT&amp;rdquo;。 o必须省略&amp;ldquo;：scheme&amp;rdquo;和&amp;ldquo;：path&amp;rdquo;伪标题字段。 o&amp;ldquo;：authority&amp;rdquo;伪标题字段包含要连接的主机和端口（相当于CONNECT请求的请求目标的授权形式（请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]，第5.3节&lt;/a&gt;））。不符合这些限制的CONNECT请求格式错误（&lt;a href=&quot;#section-8.1.2.6&quot;&gt;第8.1.2.6节&lt;/a&gt;）。支持CONNECT的代理建立与&amp;ldquo;：authority&amp;rdquo;伪头字段中标识的服务器的TCP连接[ &lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt; ]。成功建立此连接后，代理将包含2xx系列状态代码的HEADERS帧发送给客户端，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]，第4.3.6节&lt;/a&gt;。在每个对等方发送初始HEADERS帧之后，所有后续DATA帧都对应于在TCP连接上发送的数据。客户端发送的任何DATA帧的有效负载都由代理服务器传输到TCP服务器。从TCP服务器接收的数据由代理组装为DATA帧。除DATA或流管理帧（RST_STREAM，WINDOW_UPDATE和PRIORITY）外的帧类型不得在已连接的流上发送，并且必须视为流错误（&lt;a href=&quot;#section-5.4.2&quot;&gt;第5.4.2节）&lt;/a&gt;）（如果收到）。任一对等方均可关闭TCP连接。 DATA帧上的END_STREAM标志被视为等效于TCP FIN位。希望客户端在接收到带有END_STREAM标志的帧后发送设置了END_STREAM标志的DATA帧。接收到设置了END_STREAM标志的DATA帧的代理，将在最后一个TCP段上将FIN位置1的附件数据发送出去。接收到设置了FIN位的TCP段的代理将发送设置了END_STREAM标志的DATA帧。请注意，最后的TCP段或DATA帧可能为空。 RST_STREAM指示TCP连接错误。代理将TCP连接中的任何错误视为流错误（包括将接收到的RST位置1的TCP段设置为错误）（&lt;a href=&quot;#section-5.4.2&quot;&gt;第5.4.2节）&lt;/a&gt;），类型为CONNECT_ERROR。相应地，如果代理检测到流或HTTP / 2连接有错误，则必须发送设置了RST位的TCP段。</target>
        </trans-unit>
        <trans-unit id="7dad8ae742410e88380cfba396cb4fa1d4e9131d" translate="yes" xml:space="preserve">
          <source>In HTTP/2 - the &lt;code&gt;TE&lt;/code&gt; header field is only accepted if the &lt;code&gt;trailers&lt;/code&gt; value is set.</source>
          <target state="translated">在HTTP / 2中- 仅在设置了 &lt;code&gt;trailers&lt;/code&gt; 值时才接受 &lt;code&gt;TE&lt;/code&gt; 标头字段。</target>
        </trans-unit>
        <trans-unit id="0d7657f51a7437fb2490923cf1c33fdce91a2c29" translate="yes" xml:space="preserve">
          <source>In HTTP/2, each endpoint is required to send a connection preface as
   a final confirmation of the protocol in use and to establish the
   initial settings for the HTTP/2 connection.  The client and server
   each send a different connection preface.

   The client connection preface starts with a sequence of 24 octets,
   which in hex notation is:

     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a

   That is, the connection preface starts with the string &quot;PRI *
   HTTP/2.0\r\n\r\nSM\r\n\r\n&quot;).  This sequence MUST be followed by a
   SETTINGS frame (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), which MAY be empty.  The client sends
   the client connection preface immediately upon receipt of a 101
   (Switching Protocols) response (indicating a successful upgrade) or
   as the first application data octets of a TLS connection.  If
   starting an HTTP/2 connection with prior knowledge of server support
   for the protocol, the client connection preface is sent upon
   connection establishment.

      Note: The client connection preface is selected so that a large
      proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do
      not attempt to process further frames.  Note that this does not
      address the concerns raised in [&lt;a href=&quot;#ref-TALKING&quot;&gt;TALKING&lt;/a&gt;].

   The server connection preface consists of a potentially empty
   SETTINGS frame (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;) that MUST be the first frame the server
   sends in the HTTP/2 connection.

   The SETTINGS frames received from a peer as part of the connection
   preface MUST be acknowledged (see &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;) after sending the
   connection preface. 

   To avoid unnecessary latency, clients are permitted to send
   additional frames to the server immediately after sending the client
   connection preface, without waiting to receive the server connection
   preface.  It is important to note, however, that the server
   connection preface SETTINGS frame might include parameters that
   necessarily alter how a client is expected to communicate with the
   server.  Upon receiving the SETTINGS frame, the client is expected to
   honor any parameters established.  In some configurations, it is
   possible for the server to transmit SETTINGS before the client sends
   additional frames, providing an opportunity to avoid this issue.

   Clients and servers MUST treat an invalid connection preface as a
   connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  A GOAWAY
   frame (&lt;a href=&quot;#section-6.8&quot;&gt;Section 6.8&lt;/a&gt;) MAY be omitted in this case, since an invalid
   preface indicates that the peer is not using HTTP/2.</source>
          <target state="translated">在HTTP / 2中，要求每个端点发送连接序言作为对所使用协议的最终确认，并为HTTP / 2连接建立初始设置。客户端和服务器各自发送不同的连接序言。客户端连接序言以24个八位位组的序列开头，以十六进制表示为：0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a也就是说，连接序言以字符串&amp;ldquo; PRI * HTTP / 2.0 \ r \ n \ r \ nSM \ r \ n \ r \ n&amp;ldquo;）。此序列之后必须跟随一个SETTINGS框架（&lt;a href=&quot;#section-6.5&quot;&gt;第6.5节）&lt;/a&gt;），该字段可以为空。客户端在收到101（交换协议）响应（表示升级成功）后立即发送客户端连接前言，或者将其作为TLS连接的第一个应用程序数据八位字节发送。如果使用服务器对协议的先验知识开始HTTP / 2连接，则在建立连接时发送客户端连接序言。注意：选择客户端连接前言是为了使大部分HTTP / 1.1或HTTP / 1.0服务器和中介都不会尝试处理其他帧。注意，这不能解决在[&lt;a href=&quot;#ref-TALKING&quot;&gt;通话&lt;/a&gt;]中提出的问题。服务器连接前言由可能为空的SETTINGS框架组成（&lt;a href=&quot;#section-6.5&quot;&gt;第6.5节）&lt;/a&gt;）必须是服务器在HTTP / 2连接中发送的第一帧。必须确认从对等端收到的作为连接序言一部分的SETTINGS帧（请参阅&lt;a href=&quot;#section-6.5.3&quot;&gt;第6.5.3节）&lt;/a&gt;）在发送连接序言之后。为避免不必要的延迟，允许客户端在发送客户端连接序言之后立即向服务器发送其他帧，而不必等待接收服务器连接序言。但是，请务必注意，服务器连接前言SETTINGS框架可能包含一些参数，这些参数必定会更改期望客户端与服务器通信的方式。在接收到SETTINGS帧后，预期客户端将遵循已建立的任何参数。在某些配置中，服务器有可能在客户端发送其他帧之前传输设置，从而提供了避免此问题的机会。客户端和服务器必须将无效的连接前言视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节）&lt;/a&gt;），类型为PROTOCOL_ERROR。在这种情况下，可以忽略GOAWAY帧（&lt;a href=&quot;#section-6.8&quot;&gt;第6.8节&lt;/a&gt;），因为无效的前言表示对等方未使用HTTP / 2。</target>
        </trans-unit>
        <trans-unit id="bf70ecd71ae33feef50c75a643497aa1f8c4c6bc" translate="yes" xml:space="preserve">
          <source>In IIS, you use the &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpredirect&quot;&gt;&amp;lt;httpRedirect&amp;gt;&lt;/a&gt;&lt;/code&gt; element to configure redirections.</source>
          <target state="translated">在IIS中，使用 &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpredirect&quot;&gt;&amp;lt;httpRedirect&amp;gt;&lt;/a&gt;&lt;/code&gt; 元素配置重定向。</target>
        </trans-unit>
        <trans-unit id="a73ab14a2ec5bf02be9050f108c718d592c94a24" translate="yes" xml:space="preserve">
          <source>In Nginx, you create a specific server block for the content you want to redirect:</source>
          <target state="translated">在Nginx中,你为你想要重定向的内容创建一个特定的服务器块。</target>
        </trans-unit>
        <trans-unit id="24471cf4aea973802e7f0eb0517d9a17c92a5dcd" translate="yes" xml:space="preserve">
          <source>In PROPFIND responses, information about individual properties is
   returned inside 'propstat' elements (see &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;), each
   containing an individual 'status' element containing information
   about the properties appearing in it.  The list below summarizes the
   most common status codes used inside 'propstat'; however, clients
   should be prepared to handle other 2/3/4/5xx series status codes as
   well.

   200 OK - A property exists and/or its value is successfully returned.

   401 Unauthorized - The property cannot be viewed without appropriate
   authorization.

   403 Forbidden - The property cannot be viewed regardless of
   authentication.

   404 Not Found - The property does not exist.</source>
          <target state="translated">在PROPFIND响应中，有关各个属性的信息会在&amp;ldquo; propstat&amp;rdquo;元素中返回（请参见&lt;a href=&quot;#section-14.22&quot;&gt;第14.22节&lt;/a&gt;），每个元素都包含一个单独的&amp;ldquo; status&amp;rdquo;元素，其中包含有关其中出现的属性的信息。以下列表总结了&amp;ldquo; propstat&amp;rdquo;内部使用的最常见状态代码；但是，客户也应准备好处理其他2/3/4 / 5xx系列状态代码。 200 OK-属性存在和/或已成功返回其值。 401未经授权-未经适当授权无法查看该属性。 403禁止-不管身份验证如何，都无法查看该属性。找不到404-该属性不存在。</target>
        </trans-unit>
        <trans-unit id="86628559f615b8ba5dc79d241d665acce969377c" translate="yes" xml:space="preserve">
          <source>In PROPPATCH responses, information about individual properties is
   returned inside 'propstat' elements (see &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;), each
   containing an individual 'status' element containing information
   about the properties appearing in it.  The list below summarizes the
   most common status codes used inside 'propstat'; however, clients
   should be prepared to handle other 2/3/4/5xx series status codes as
   well. 

   200 (OK) - The property set or change succeeded.  Note that if this
   appears for one property, it appears for every property in the
   response, due to the atomicity of PROPPATCH.

   403 (Forbidden) - The client, for reasons the server chooses not to
   specify, cannot alter one of the properties.

   403 (Forbidden): The client has attempted to set a protected
   property, such as DAV:getetag.  If returning this error, the server
   SHOULD use the precondition code 'cannot-modify-protected-property'
   inside the response body.

   409 (Conflict) - The client has provided a value whose semantics are
   not appropriate for the property.

   424 (Failed Dependency) - The property change could not be made
   because of another property change that failed.

   507 (Insufficient Storage) - The server did not have sufficient space
   to record the property.</source>
          <target state="translated">在PROPPATCH响应中，有关各个属性的信息将在&amp;ldquo; propstat&amp;rdquo;元素内返回（请参见&lt;a href=&quot;#section-14.22&quot;&gt;第14.22节）&lt;/a&gt;），每个都包含一个单独的&amp;ldquo;状态&amp;rdquo;元素，其中包含有关其中显示的属性的信息。以下列表总结了&amp;ldquo; propstat&amp;rdquo;内部使用的最常见状态代码；但是，客户也应该准备好处理其他2/3/4 / 5xx系列状态代码。 200（OK）-属性设置或更改成功。请注意，如果此属性出现在一个属性中，则由于PROPPATCH的原子性，它会出现在响应中的每个属性中。 403（禁止访问）-由于服务器选择不指定的原因，客户端无法更改属性之一。 403（禁止访问）：客户端尝试设置受保护的属性，例如DAV：getetag。如果返回此错误，则服务器应使用前提条件代码&amp;ldquo; cannot-modify-protected-property&amp;rdquo;在响应体内。 409（冲突）-客户端提供了一个值，该值的语义不适用于该属性。 424（依赖失败）-由于另一个失败的属性更改而无法进行属性更改。 507（存储空间不足）-服务器没有足够的空间来记录该属性。</target>
        </trans-unit>
        <trans-unit id="4287fa4592630c32398d87b197eab0ac7661318b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request, resulting from an HTML form submission, the &lt;code&gt;Content-Type&lt;/code&gt; of the request is specified by the &lt;code&gt;enctype&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">在从HTML表单提交产生的&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求中，请求的 &lt;code&gt;Content-Type&lt;/code&gt; 由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上的 &lt;code&gt;enctype&lt;/code&gt; 属性指定。</target>
        </trans-unit>
        <trans-unit id="b96a6a626ade04f611b917e292048082979c2db6" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Request&lt;/a&gt; scenario, the request will be sent with Cookies (e.g. if the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;withCredentials&lt;/a&gt;&lt;/code&gt; flag is set on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;). If the server responds with &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; attached to the credentialed response, then the response is accepted by the client and exposed to web content. In a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Request&lt;/a&gt;, the server can respond with &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; to the &lt;code&gt;OPTIONS&lt;/code&gt; request.</source>
          <target state="translated">在&amp;ldquo; &lt;a href=&quot;cors#Simple_requests&quot;&gt;简单请求&amp;rdquo;&lt;/a&gt;方案中，请求将与Cookie一起发送（例如，如果在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;上设置了 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;withCredentials&lt;/a&gt;&lt;/code&gt; 标志）。如果服务器使用凭证响应中附加的&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; 进行响应，则该响应将被客户端接受并暴露给Web内容。在&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;预检请求中&lt;/a&gt;，服务器可以使用 &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; 响应：对 &lt;code&gt;OPTIONS&lt;/code&gt; 请求为true。</target>
        </trans-unit>
        <trans-unit id="268020b94aef4013d8492a7be59945867c54beea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;multipart/form-data&lt;/code&gt; body, the HTTP &lt;code&gt;Content-Disposition&lt;/code&gt; general header is a header that can be used on the subpart of a multipart body to give information about the field it applies to. The subpart is delimited by the &lt;em&gt;boundary&lt;/em&gt; defined in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header. Used on the body itself, &lt;code&gt;Content-Disposition&lt;/code&gt; has no effect.</source>
          <target state="translated">在 &lt;code&gt;multipart/form-data&lt;/code&gt; 主体中，HTTP &lt;code&gt;Content-Disposition&lt;/code&gt; 常规标头是可以在multipart主体的子部分上使用的标头，以提供有关其适用字段的信息。子部分由&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;标头中定义的&lt;em&gt;边界&lt;/em&gt;定&lt;em&gt;界&lt;/em&gt;。用于身体本身的 &lt;code&gt;Content-Disposition&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="722fd850ce8884571159d774606e9c7c439cbf02" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;multipart/form-data&lt;/code&gt; body, the HTTP &lt;code&gt;Content-Disposition&lt;/code&gt; general header is a header that must be used on each subpart of a multipart body to give information about the field it applies to. The subpart is delimited by the &lt;em&gt;boundary&lt;/em&gt; defined in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header. Used on the body itself, &lt;code&gt;Content-Disposition&lt;/code&gt; has no effect.</source>
          <target state="translated">在 &lt;code&gt;multipart/form-data&lt;/code&gt; 主体中，HTTP &lt;code&gt;Content-Disposition&lt;/code&gt; 常规标头是必须在multipart主体的每个子部分上使用的标头，以提供有关其适用字段的信息。子部分由&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;标头中定义的&lt;em&gt;边界&lt;/em&gt;定&lt;em&gt;界&lt;/em&gt;。用于身体本身的 &lt;code&gt;Content-Disposition&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="205c117fa86b98a94b5278af3d27ff4834e8a8cf" translate="yes" xml:space="preserve">
          <source>In a Web page, using JavaScript</source>
          <target state="translated">在网页中,使用JavaScript</target>
        </trans-unit>
        <trans-unit id="761a2afb550fd29de9f2fe5ccca651beeaf9ee84" translate="yes" xml:space="preserve">
          <source>In a cross-protocol attack, an attacker causes a client to initiate a
   transaction in one protocol toward a server that understands a
   different protocol.  An attacker might be able to cause the
   transaction to appear as a valid transaction in the second protocol.
   In combination with the capabilities of the web context, this can be
   used to interact with poorly protected servers in private networks.

   Completing a TLS handshake with an ALPN identifier for HTTP/2 can be
   considered sufficient protection against cross-protocol attacks.
   ALPN provides a positive indication that a server is willing to
   proceed with HTTP/2, which prevents attacks on other TLS-based
   protocols.

   The encryption in TLS makes it difficult for attackers to control the
   data that could be used in a cross-protocol attack on a cleartext
   protocol.

   The cleartext version of HTTP/2 has minimal protection against cross-
   protocol attacks.  The connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;) contains a
   string that is designed to confuse HTTP/1.1 servers, but no special
   protection is offered for other protocols.  A server that is willing
   to ignore parts of an HTTP/1.1 request containing an Upgrade header
   field in addition to the client connection preface could be exposed
   to a cross-protocol attack.</source>
          <target state="translated">在跨协议攻击中，攻击者使客户端以一种协议向了解不同协议的服务器发起事务。攻击者可能能够使交易在第二协议中显示为有效交易。结合Web上下文的功能，可以将其与专用网络中受保护不佳的服务器进行交互。对于HTTP / 2，使用具有ALPN标识符的TLS握手完成可以被认为是对跨协议攻击的充分保护。 ALPN明确表明服务器愿意继续使用HTTP / 2，从而防止了对其他基于TLS的协议的攻击。 TLS中的加密使攻击者难以控制可在明文协议的跨协议攻击中使用的数据。HTTP / 2的明文版本对跨协议攻击的保护最低。连接前言（&lt;a href=&quot;#section-3.5&quot;&gt;3.5节&lt;/a&gt;）包含一个旨在混淆HTTP / 1.1服务器的字符串，但没有为其他协议提供特殊保护。愿意忽略除客户端连接序言之外还包含Upgrade标头字段的HTTP / 1.1请求的一部分的服务器可能会受到跨协议攻击。</target>
        </trans-unit>
        <trans-unit id="217ea5cca9699504b57fcecb48b0029845d1abba" translate="yes" xml:space="preserve">
          <source>In a nutshell</source>
          <target state="translated">简而言之</target>
        </trans-unit>
        <trans-unit id="2761e7950da20aac090169d0c4a8c94e9c82afce" translate="yes" xml:space="preserve">
          <source>In a regular HTTP response, the &lt;code&gt;&lt;strong&gt;Content-Disposition&lt;/strong&gt;&lt;/code&gt; response header is a header indicating if the content is expected to be displayed &lt;em&gt;inline&lt;/em&gt; in the browser, that is, as a Web page or as part of a Web page, or as an &lt;em&gt;attachment&lt;/em&gt;, that is downloaded and saved locally.</source>
          <target state="translated">在常规HTTP响应中， &lt;code&gt;&lt;strong&gt;Content-Disposition&lt;/strong&gt;&lt;/code&gt; 响应标头是一个标头，指示是否希望在浏览器中&lt;em&gt;以内联&lt;/em&gt;方式显示内容，即作为网页或作为网页的一部分，还是作为&lt;em&gt;附件显示&lt;/em&gt;，已下载并保存在本地。</target>
        </trans-unit>
        <trans-unit id="95ef9f1f98a924832244a2938c1f564593efc504" translate="yes" xml:space="preserve">
          <source>In addition to defining the HTTP/1.1 protocol, this document serves
   as the specification for the Internet media type &quot;message/http&quot; and
   &quot;application/http&quot;. The message/http type can be used to enclose a
   single HTTP request or response message, provided that it obeys the
   MIME restrictions for all &quot;message&quot; types regarding line length and
   encodings. The application/http type can be used to enclose a
   pipeline of one or more HTTP request or response messages (not
   intermixed). The following is to be registered with IANA [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;].

       Media Type name:         message
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed message
                 (e.g., &quot;1.1&quot;). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- &quot;request&quot; or &quot;response&quot;. If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
                                permitted
       Security considerations: none

       Media Type name:         application
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed messages
                 (e.g., &quot;1.1&quot;). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- &quot;request&quot; or &quot;response&quot;. If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: HTTP messages enclosed by this type
                 are in &quot;binary&quot; format; use of an appropriate
                 Content-Transfer-Encoding is required when
                 transmitted via E-mail.
       Security considerations: none</source>
          <target state="translated">除了定义HTTP / 1.1协议之外，本文档还用作Internet媒体类型&amp;ldquo; message / http&amp;rdquo;和&amp;ldquo; application / http&amp;rdquo;的规范。消息/ http类型可用于封装单个HTTP请求或响应消息，只要它遵守所有有关行长和编码的&amp;ldquo;消息&amp;rdquo;类型的MIME限制。 application / http类型可用于封装一个或多个HTTP请求或响应消息（不混合）的管道。以下内容将向IANA注册[ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]。媒体类型名称：message媒体子类型名称：http必需参数：无可选参数：version，msgtype version：随附消息的HTTP版本号（例如&amp;ldquo; 1.1&amp;rdquo;）。如果不存在，则可以从正文的第一行确定版本。 msgtype：消息类型-&amp;ldquo;请求&amp;rdquo;或&amp;ldquo;响应&amp;rdquo;。如果不存在，则可以从主体的第一行确定类型。编码注意事项：仅允许使用&amp;ldquo; 7bit&amp;rdquo;，&amp;ldquo; 8bit&amp;rdquo;或&amp;ldquo; binary&amp;rdquo;安全注意事项：无媒体类型名称：application媒体子类型名称：http必需参数：无可选参数：version，msgtype version：随附消息的HTTP版本号（例如&amp;ldquo; 1.1&amp;rdquo;）。如果不存在，则可以从正文的第一行确定版本。 msgtype：消息类型-&amp;ldquo;请求&amp;rdquo;或&amp;ldquo;响应&amp;rdquo;。如果不存在，则可以从主体的第一行确定类型。编码注意事项：这种类型的HTTP消息采用&amp;ldquo;二进制&amp;rdquo;格式；通过电子邮件传输时，需要使用适当的Content-Transfer-Encoding。安全注意事项：无随附消息的HTTP版本号（例如&amp;ldquo; 1.1&amp;rdquo;）。如果不存在，则可以从正文的第一行确定版本。 msgtype：消息类型-&amp;ldquo;请求&amp;rdquo;或&amp;ldquo;响应&amp;rdquo;。如果不存在，则可以从主体的第一行确定类型。编码注意事项：这种类型的HTTP消息采用&amp;ldquo;二进制&amp;rdquo;格式；通过电子邮件传输时，需要使用适当的Content-Transfer-Encoding。安全注意事项：无随附消息的HTTP版本号（例如&amp;ldquo; 1.1&amp;rdquo;）。如果不存在，则可以从正文的第一行确定版本。 msgtype：消息类型-&amp;ldquo;请求&amp;rdquo;或&amp;ldquo;响应&amp;rdquo;。如果不存在，则可以从主体的第一行确定类型。编码注意事项：这种类型的HTTP消息采用&amp;ldquo;二进制&amp;rdquo;格式；通过电子邮件传输时，需要使用适当的Content-Transfer-Encoding。安全注意事项：无如果不存在，则可以从正文的第一行确定类型。编码注意事项：这种类型包含的HTTP消息采用&amp;ldquo;二进制&amp;rdquo;格式；通过进行传输时，需要使用适当的Content-Transfer-Encoding电子邮件。安全考虑：无如果不存在，则可以从正文的第一行确定类型。编码注意事项：这种类型包含的HTTP消息采用&amp;ldquo;二进制&amp;rdquo;格式；通过进行传输时，需要使用适当的Content-Transfer-Encoding电子邮件。安全考虑：无</target>
        </trans-unit>
        <trans-unit id="ba23aa0ff8e4e6c04210bb32cbc84ce861b595e8" translate="yes" xml:space="preserve">
          <source>In addition to having &lt;code&gt;Server-Timing&lt;/code&gt; header metrics appear in the developer tools of the browser, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface enables tools to automatically collect and process metrics from JavaScript. This interface is restricted to the same origin, but you can use the &lt;a href=&quot;timing-allow-origin&quot;&gt;&lt;code&gt;Timing-Allow-Origin&lt;/code&gt;&lt;/a&gt; header to specify the domains that are allowed to access the server metrics. The interface is only available in secure contexts (HTTPS) in some browsers.</source>
          <target state="translated">除了将 &lt;code&gt;Server-Timing&lt;/code&gt; 标头指标显示在浏览器的开发人员工具中之外，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt;界面还使工具可以从JavaScript自动收集和处理指标。此接口被限制为具有相同的来源，但是您可以使用&lt;a href=&quot;timing-allow-origin&quot;&gt; &lt;code&gt;Timing-Allow-Origin&lt;/code&gt; &lt;/a&gt;标头指定允许访问服务器指标的域。该界面仅在某些浏览器中的安全上下文（HTTPS）中可用。</target>
        </trans-unit>
        <trans-unit id="a2dac2ae6a62ade1de285c71b6058d61de36159d" translate="yes" xml:space="preserve">
          <source>In addition to restricting the domains from which content can be loaded, the server can specify which protocols are allowed to be used; for example (and ideally, from a security standpoint), a server can specify that all content must be loaded using HTTPS. A complete data transmission security strategy includes not only enforcing HTTPS for data transfer, but also marking all &lt;a href=&quot;cookies&quot;&gt;cookies with the &lt;code&gt;secure&lt;/code&gt; attribute&lt;/a&gt; and providing automatic redirects from HTTP pages to their HTTPS counterparts. Sites may also use the &lt;a href=&quot;headers/strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; HTTP header to ensure that browsers connect to them only over an encrypted channel&lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">除了限制可以从中加载内容的域之外，服务器还可以指定允许使用哪些协议；例如：例如（从安全角度出发，最好是从服务器的角度来看），服务器可以指定必须使用HTTPS加载所有内容。完整的数据传输安全策略不仅包括强制HTTPS进行数据传输，而且还&lt;a href=&quot;cookies&quot;&gt;使用 &lt;code&gt;secure&lt;/code&gt; 属性&lt;/a&gt;标记所有cookie，并提供从HTTP页面到其HTTPS副本的自动重定向。站点还可以使用&lt;a href=&quot;headers/strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt; HTTP标头来确保浏览器仅通过加密通道连接到它们&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad2112dae19cc7c327768fb0823cb8c15ee2b0a2" translate="yes" xml:space="preserve">
          <source>In addition to restricting the domains from which content can be loaded, the server can specify which protocols are allowed to be used; for example (and ideally, from a security standpoint), a server can specify that all content must be loaded using HTTPS. A complete data transmission security strategy includes not only enforcing HTTPS for data transfer, but also marking all &lt;a href=&quot;cookies&quot;&gt;cookies with the secure flag&lt;/a&gt; and providing automatic redirects from HTTP pages to their HTTPS counterparts. Sites may also use the &lt;a href=&quot;headers/strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; HTTP header to ensure that browsers connect to them only over an encrypted channel&lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">除了限制可以加载内容的域之外，服务器还可以指定允许使用哪些协议；例如（从安全角度出发，理想情况下），服务器可以指定必须使用HTTPS加载所有内容。完整的数据传输安全策略不仅包括强制HTTPS进行数据传输，而且还&lt;a href=&quot;cookies&quot;&gt;使用安全标志&lt;/a&gt;标记所有cookie，并提供从HTTP页面到其HTTPS副本的自动重定向。站点还可以使用&lt;a href=&quot;headers/strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt; HTTP标头来确保浏览器仅通过加密通道连接到它们&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cc3248a0c52202ec569f1b1018d21d9a3d88bcc" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to COPY:

   201 (Created) - The source resource was successfully copied.  The
   COPY operation resulted in the creation of a new resource.

   204 (No Content) - The source resource was successfully copied to a
   preexisting destination resource.

   207 (Multi-Status) - Multiple resources were to be affected by the
   COPY, but errors on some of them prevented the operation from taking
   place.  Specific error messages, together with the most appropriate
   of the source and destination URLs, appear in the body of the multi-
   status response.  For example, if a destination resource was locked
   and could not be overwritten, then the destination resource URL
   appears with the 423 (Locked) status.

   403 (Forbidden) - The operation is forbidden.  A special case for
   COPY could be that the source and destination resources are the same
   resource.

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.

   412 (Precondition Failed) - A precondition header check failed, e.g.,
   the Overwrite header is &quot;F&quot; and the destination URL is already mapped
   to a resource. 

   423 (Locked) - The destination resource, or resource within the
   destination collection, was locked.  This response SHOULD contain the
   'lock-token-submitted' precondition element.

   502 (Bad Gateway) - This may occur when the destination is on another
   server, repository, or URL namespace.  Either the source namespace
   does not support copying to the destination namespace, or the
   destination namespace refuses to accept the resource.  The client may
   wish to try GET/PUT and PROPFIND/PROPPATCH instead.

   507 (Insufficient Storage) - The destination resource does not have
   sufficient space to record the state of the resource after the
   execution of this method.</source>
          <target state="translated">除了可能的一般状态代码外,以下状态代码对 COPY 有特定的适用性:201(创建)--源资源已成功复制。COPY 操作的结果是创建了一个新资源。204(无内容)--源资源被成功复制到一个预先存在的目标资源。207(多状态)--复制将影响多个资源,但其中一些资源的错误阻止了操作的进行。特定的错误消息,以及最合适的源和目标 URL,出现在多状态响应的正文中。例如,如果目标资源被锁定,无法被覆盖,那么目标资源URL会出现423(锁定)状态。403(禁止)--该操作被禁止。COPY的特殊情况可能是源资源和目的资源是同一个资源。409(冲突)--在一个或多个中间集合被创建之前,不能在目标地创建资源。服务器决不能自动创建这些中间集合。412(预设条件失败)--预设条件头检查失败,例如,覆写头是 &quot;F&quot;,并且目标 URL 已经映射到资源。423 (Locked)-目标资源或目标集合中的资源被锁定。这个响应应该包含'lock-token-submitted'的前提条件元素。502 (坏网关)-当目标资源在另一个服务器、存储库或 URL 命名空间上时,可能会发生这种情况。要么是源名称空间不支持复制到目标名称空间,要么是目标名称空间拒绝接受资源。客户端可能希望尝试使用GET/PUT和PROPFIND/PROPPATCH来代替。507 (Insufficient Storage)-目标资源没有足够的空间来记录该方法执行后的资源状态。</target>
        </trans-unit>
        <trans-unit id="ee897ff0362cf4245c71fb432f38bd23904179b3" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to LOCK:

   200 (OK) - The LOCK request succeeded and the value of the DAV:
   lockdiscovery property is included in the response body.

   201 (Created) - The LOCK request was to an unmapped URL, the request
   succeeded and resulted in the creation of a new resource, and the
   value of the DAV:lockdiscovery property is included in the response
   body. 

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.

   423 (Locked), potentially with 'no-conflicting-lock' precondition
   code - There is already a lock on the resource that is not compatible
   with the requested lock (see lock compatibility table above).

   412 (Precondition Failed), with 'lock-token-matches-request-uri'
   precondition code - The LOCK request was made with an If header,
   indicating that the client wishes to refresh the given lock.
   However, the Request-URI did not fall within the scope of the lock
   identified by the token.  The lock may have a scope that does not
   include the Request-URI, or the lock could have disappeared, or the
   token may be invalid.</source>
          <target state="translated">除了可能的一般状态码外,以下状态码对LOCK有特定的适用性:200(OK)--LOCK请求成功,DAV:lockdiscovery属性的值包含在响应体中。201(Created)--LOCK请求是向一个未映射的URL发出的,请求成功并导致创建了一个新的资源,DAV:lockdiscovery属性的值包含在响应体中。409(冲突)--在一个或多个中间集合被创建之前,不能在目标地创建资源。服务器决不能自动创建这些中间集合。423(锁定),可能带有'no-conflicting-lock'先决条件代码--资源上已经有一个与请求的锁不兼容的锁(参见上面的锁兼容性表)。412(预设条件失败),带有'lock-token-matches-request-uri'预设条件代码--LOCK请求是带If头的,表明客户端希望刷新给定的锁。然而,Request-URI并不属于该令牌所标识的锁的范围。该锁的范围可能不包括Request-URI,或者该锁可能已经消失,或者令牌可能是无效的。</target>
        </trans-unit>
        <trans-unit id="a26231e92d79838933371916af08188230312c93" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to MKCOL:

   201 (Created) - The collection was created.

   403 (Forbidden) - This indicates at least one of two conditions: 1)
   the server does not allow the creation of collections at the given
   location in its URL namespace, or 2) the parent collection of the
   Request-URI exists but cannot accept members.

   405 (Method Not Allowed) - MKCOL can only be executed on an unmapped
   URL.

   409 (Conflict) - A collection cannot be made at the Request-URI until
   one or more intermediate collections have been created.  The server
   MUST NOT create those intermediate collections automatically.

   415 (Unsupported Media Type) - The server does not support the
   request body type (although bodies are legal on MKCOL requests, since
   this specification doesn't define any, the server is likely not to
   support any given body type).

   507 (Insufficient Storage) - The resource does not have sufficient
   space to record the state of the resource after the execution of this
   method.</source>
          <target state="translated">除了可能的一般状态代码外,以下状态代码对MKCOL有特定的适用性:201(创建)--该集合已创建。403 (Forbidden)-这表示至少有两种情况之一。1)服务器不允许在其 URL 命名空间的指定位置创建集合,或 2)Request-URI 的父集合存在,但不能接受成员。405 (方法不允许)-MKCOL 只能在未映射的 URL 上执行。409(冲突)--在一个或多个中间集合被创建之前,不能在Request-URI上建立集合。服务器决不能自动创建这些中间集合。415(不支持的媒体类型)--服务器不支持请求主体类型(尽管主体在 MKCOL 请求中是合法的,但由于本规范没有定义任何类型,服务器可能不支持任何给定的主体类型)。507(存储不足)--资源没有足够的空间来记录本方法执行后资源的状态。</target>
        </trans-unit>
        <trans-unit id="abd88f2d1d87ef7a1f30945f9393736f0e9efad8" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to MOVE:

   201 (Created) - The source resource was successfully moved, and a new
   URL mapping was created at the destination.

   204 (No Content) - The source resource was successfully moved to a
   URL that was already mapped.

   207 (Multi-Status) - Multiple resources were to be affected by the
   MOVE, but errors on some of them prevented the operation from taking
   place.  Specific error messages, together with the most appropriate
   of the source and destination URLs, appear in the body of the multi-
   status response.  For example, if a source resource was locked and
   could not be moved, then the source resource URL appears with the 423
   (Locked) status.

   403 (Forbidden) - Among many possible reasons for forbidding a MOVE
   operation, this status code is recommended for use when the source
   and destination resources are the same.

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.
   Or, the server was unable to preserve the behavior of the live
   properties and still move the resource to the destination (see
   'preserved-live-properties' postcondition).

   412 (Precondition Failed) - A condition header failed.  Specific to
   MOVE, this could mean that the Overwrite header is &quot;F&quot; and the
   destination URL is already mapped to a resource.

   423 (Locked) - The source or the destination resource, the source or
   destination resource parent, or some resource within the source or
   destination collection, was locked.  This response SHOULD contain the
   'lock-token-submitted' precondition element.

   502 (Bad Gateway) - This may occur when the destination is on another
   server and the destination server refuses to accept the resource.
   This could also occur when the destination is on another sub-section
   of the same server namespace.</source>
          <target state="translated">除了可能的一般状态代码外,以下状态代码对 MOVE 具有特定的适用性:201(创建)--源资源被成功移动,并在目标处创建了新的 URL 映射。204(无内容)--源资源被成功移动到一个已经映射的 URL 上。207(多状态)--MOVE 将影响多个资源,但其中一些资源的错误阻止了操作的进行。特定的错误消息,以及最合适的源和目标 URL,会出现在多状态响应的主体中。例如,如果一个源资源被锁定,无法移动,那么源资源URL就会出现423(锁定)状态。403(禁止)--在禁止 MOVE 操作的许多可能的原因中,建议在源资源和目标资源相同时使用此状态码。409(冲突)--在一个或多个中间集合被创建之前,不能在目的地创建资源。服务器决不能自动创建这些中间集合。或者,服务器无法保留实时属性的行为,但仍然将资源移动到目标地(请参见'preserved-live-properties'后条件)。412 (Precondition Failed)-一个条件头失败。具体到MOVE,这可能意味着Overwrite头是 &quot;F&quot;,并且目标URL已经被映射到一个资源上。423 (Locked)-源或目标资源、源或目标资源的父资源、或源或目标集合中的某些资源被锁定。这个响应应该包含 &quot;锁定令牌-提交 &quot;的前提条件元素。502(坏网关)--当目标服务器在另一台服务器上,而目标服务器拒绝接受资源时,可能会发生这种情况。当目标服务器位于同一服务器命名空间的另一个子部分时,也可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="4629e09c06eba402676b36f28c77b568459e792b" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to UNLOCK:

   204 (No Content) - Normal success response (rather than 200 OK, since
   200 OK would imply a response body, and an UNLOCK success response
   does not normally contain a body).

   400 (Bad Request) - No lock token was provided.

   403 (Forbidden) - The currently authenticated principal does not have
   permission to remove the lock.

   409 (Conflict), with 'lock-token-matches-request-uri' precondition -
   The resource was not locked, or the request was made to a Request-URI
   that was not within the scope of the lock.</source>
          <target state="translated">除了可能的一般状态码外,以下状态码对UNLOCK有特定的适用性:204(无内容)--正常的成功响应(而不是200 OK,因为200 OK意味着响应主体,而UNLOCK成功响应通常不包含主体)。400(坏请求)--没有提供锁令牌。403(Forbidden)--当前已认证的委托人没有权限移除锁。409(冲突),带有 &quot;lock-token-matches-request-uri &quot;的先决条件--资源没有被锁定,或者请求是向一个不在锁的范围内的Request-URI发出的。</target>
        </trans-unit>
        <trans-unit id="9e2b59b56283e49cf87a4756ab287a316a572fba" translate="yes" xml:space="preserve">
          <source>In addition to these large extensions, numerous other headers have been added, sometimes experimentally only. Notable headers are Do Not Track (&lt;a href=&quot;../headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt;) header to control privacy, &lt;a href=&quot;../headers/x-frame-options&quot;&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../headers/upgrade-insecure-requests&quot;&gt;&lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt;&lt;/a&gt; but many more exist.</source>
          <target state="translated">除了这些大扩展名之外，还添加了许多其他标头，有时只是出于实验目的。值得注意的标头是&amp;ldquo;不跟踪&amp;rdquo;（&lt;a href=&quot;../headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;）标头，用于控制隐私，&lt;a href=&quot;../headers/x-frame-options&quot;&gt; &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../headers/upgrade-insecure-requests&quot;&gt; &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; ,&lt;/a&gt;但还有许多其他标头。</target>
        </trans-unit>
        <trans-unit id="3b131cf2fd0e3eeeeb8387fc020ce526e5bb2a21" translate="yes" xml:space="preserve">
          <source>In addition to these usual redirections, there are two specific redirections. The &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; (Not Modified) redirects a page to the locally cached copy (that was stale), and &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choice) is a manual redirection: the body, presented by the browser as a Web page, lists the possible redirections and the user clicks on one to select it.</source>
          <target state="translated">除了这些通常的重定向之外，还有两个特定的重定向。在&lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt;（未修改）的某个网页重定向到本地缓存的副本（这是陈旧的）和&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt;（可多选）是手动重定向：身体，由浏览器呈现为一个网页，列出了可能的重定向和用户单击一个将其选中。</target>
        </trans-unit>
        <trans-unit id="d635ae50b7ab2f51933a439ac178e121013926c5" translate="yes" xml:space="preserve">
          <source>In addition to these, there is an experimental proposal to add more headers to the list of available headers, called &lt;em&gt;client hints&lt;/em&gt;. Client hints advertise what kind of device the user agent runs on (for example, if it is a desktop computer or a mobile device).</source>
          <target state="translated">除了这些，还有一个实验性的建议，将更多的标头添加到可用标头列表中，称为&lt;em&gt;客户端提示&lt;/em&gt;。客户端提示会宣传用户代理在哪种设备上运行（例如，如果它是台式计算机或移动设备）。</target>
        </trans-unit>
        <trans-unit id="6be73b5e595cfda1b190216eea697e1e081f8638" translate="yes" xml:space="preserve">
          <source>In addition, cookies with the &lt;code&gt;__Host-&lt;/code&gt; prefix must have a path of &lt;code&gt;/&lt;/code&gt; (meaning any path at the host) and must not have a &lt;code&gt;Domain&lt;/code&gt; attribute.</source>
          <target state="translated">此外，带有 &lt;code&gt;__Host-&lt;/code&gt; 前缀的cookie的路径必须为 &lt;code&gt;/&lt;/code&gt; （表示主机上的任何路径），并且不得具有 &lt;code&gt;Domain&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="452c8d06b2f6623a8650c4fa111cc03980282cde" translate="yes" xml:space="preserve">
          <source>In an HTTP URL, the first substring that follows the initial &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt; is called the domain name. This domain name is hosted on a server where the document resides.</source>
          <target state="translated">在HTTP URL中，跟在初始 &lt;code&gt;http://&lt;/code&gt; 或 &lt;code&gt;https://&lt;/code&gt; 之后的第一个子字符串称为域名。该域名托管在文档所在的服务器上。</target>
        </trans-unit>
        <trans-unit id="c6a374d59d054a3737c0b7d32f324c37547cb7c5" translate="yes" xml:space="preserve">
          <source>In both cases it's clear, conditional requests are a fundamental feature behind the Web.</source>
          <target state="translated">在这两种情况下,很明显,条件请求是Web背后的一个基本特征。</target>
        </trans-unit>
        <trans-unit id="b7d3d4c052ce3a72008b8168b5362d9899fce376" translate="yes" xml:space="preserve">
          <source>In both cases, the user can't do much (unless a corruption is happening on their side, like a mismatch of cache or cookies).</source>
          <target state="translated">在这两种情况下,用户都做不了什么(除非他们那边发生了损坏,比如缓存或cookies不匹配)。</target>
        </trans-unit>
        <trans-unit id="891082881f414bc74764d1a5ea2c1afe84e85946" translate="yes" xml:space="preserve">
          <source>In browsers that support &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive will be ignored.</source>
          <target state="translated">在支持&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; 的&lt;/a&gt;浏览器中， &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令将被忽略。</target>
        </trans-unit>
        <trans-unit id="99d503921123b6885340a4372a8a6b0ea5626e01" translate="yes" xml:space="preserve">
          <source>In browsers that support &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive will be ignored.</source>
          <target state="translated">在支持&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; 的&lt;/a&gt;浏览器中， &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 指令将被忽略。</target>
        </trans-unit>
        <trans-unit id="7c5dd7c6036bb963177d127d1d450d8f1e98dec9" translate="yes" xml:space="preserve">
          <source>In case of a range request that is out of bounds (none of the range values overlap the extent of the resource, i.e first-byte-pos of all ranges is greater than the resource length), the server responds with a &lt;a href=&quot;status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Requested Range Not Satisfiable&lt;/code&gt; status.</source>
          <target state="translated">如果范围请求超出范围（范围值均不与资源范围重叠，即所有范围的第一个字节位置大于资源长度），服务器将响应&lt;a href=&quot;status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Requested Range Not Satisfiable&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="2eeb5d5719bfe66a723ed9a7de204a618f713d1f" translate="yes" xml:space="preserve">
          <source>In case of a range request that is out of bounds (range values overlap the extent of the resource), the server responds with a &lt;a href=&quot;status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Requested Range Not Satisfiable&lt;/code&gt; status.</source>
          <target state="translated">如果范围请求超出范围（范围值与资源范围重叠），服务器将以&lt;a href=&quot;status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Requested Range Not Satisfiable&lt;/code&gt; 状态进行响应。</target>
        </trans-unit>
        <trans-unit id="fe1bbb314fd4c01d67a4a1927444c74b1ecc3b84" translate="yes" xml:space="preserve">
          <source>In case of a successful range request, the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status is sent back from a server.</source>
          <target state="translated">如果成功发送了范围请求，则会从服务器发回&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="aedd7950da9e5893c670001b73efaf8f02facdd1" translate="yes" xml:space="preserve">
          <source>In case of no support of range requests, the &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status is sent back from a server.</source>
          <target state="translated">如果不支持范围请求，则会从服务器发回&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="73542c18d725b27c3411be51053fdddc86d53fc0" translate="yes" xml:space="preserve">
          <source>In cases of redirection, the HTTP method used to make the new request to fetch the page pointed to by &lt;code&gt;Location&lt;/code&gt; depends of the original method and of the kind of redirection:</source>
          <target state="translated">在重定向的情况下，用于发出新请求以提取 &lt;code&gt;Location&lt;/code&gt; 指向的页面的HTTP方法取决于原始方法和重定向的类型：</target>
        </trans-unit>
        <trans-unit id="400b65ba68994eae44783d4597cd6426d0ef1020" translate="yes" xml:space="preserve">
          <source>In cases of resource creation, it indicates the URL to the newly created resource.</source>
          <target state="translated">在创建资源时,它表示新创建资源的URL。</target>
        </trans-unit>
        <trans-unit id="83f79ebc079d3c0c0d4572bcf4378eb80a9d0af2" translate="yes" xml:space="preserve">
          <source>In client-server protocols, it is the client which establishes the connection. Opening a connection in HTTP means initiating a connection in the underlying transport layer, usually this is TCP.</source>
          <target state="translated">在客户端-服务器协议中,是客户端建立连接。在HTTP中打开连接意味着在底层传输层发起连接,通常这是TCP。</target>
        </trans-unit>
        <trans-unit id="8c10db7321992e2a8f17abad3e89745464a5099e" translate="yes" xml:space="preserve">
          <source>In client-server protocols, like HTTP, sessions consist of three phases:</source>
          <target state="translated">在客户端-服务器协议中,如HTTP,会话由三个阶段组成。</target>
        </trans-unit>
        <trans-unit id="3f9a70e3c7b55315e54b4db55bc22d039b7ec58c" translate="yes" xml:space="preserve">
          <source>In conjunction with a range request with a &lt;a href=&quot;if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; header, it can be used to ensure that the new fragment requested comes from an unmodified document.</source>
          <target state="translated">结合具有&lt;a href=&quot;if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt;标头的范围请求，可以将其用于确保请求的新片段来自未修改的文档。</target>
        </trans-unit>
        <trans-unit id="e9ab6733bb319a29784b72221a4697f634e9bdd1" translate="yes" xml:space="preserve">
          <source>In conjunction with non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; methods, like &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, it can be used to implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;optimistic concurrency control&lt;/a&gt;, like done by some wikis: editions are rejected if the stored document has been modified since the original has been retrieved.</source>
          <target state="translated">与一些&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;不安全的&lt;/a&gt;方法（如&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; )&lt;/a&gt;结合使用，它可以用于实现开放式&lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;并发控制&lt;/a&gt;，就像某些Wiki一样：如果由于检索到原始文档而对存储文档进行了修改，则拒绝版本。</target>
        </trans-unit>
        <trans-unit id="d493128c05add224d7034b297ae0a98230512595" translate="yes" xml:space="preserve">
          <source>In contrast to the previous &lt;code&gt;Accept-*&lt;/code&gt; headers, which are sent by the client, the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP header is sent by the web server in its response. It indicates the list of headers used by the server during the server-driven content negotiation phase. The header is needed in order to inform the cache of the decision criteria so that it can reproduce it, allowing the cache to be functional while preventing serving erroneous content to the user.</source>
          <target state="translated">与客户端发送的先前的 &lt;code&gt;Accept-*&lt;/code&gt; 标头不同，&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP标头是由Web服务器在其响应中发送的。它指示服务器驱动的内容协商阶段中服务器使用的标头列表。标头是必需的，以便将决策标准告知高速缓存，以便它可以重现它，从而在防止向用户提供错误内容的同时，使高速缓存发挥功能。</target>
        </trans-unit>
        <trans-unit id="a08f16f3855aa1f6d298ed8409da0b0dbfdf4c6d" translate="yes" xml:space="preserve">
          <source>In early 2018, two side-channel hardware vulnerabilities known as &lt;em&gt;Meltdown&lt;/em&gt; and &lt;em&gt;Spectre&lt;/em&gt; were disclosed. These vulnerabilities allowed sensitive data disclosure due to a race condition which arose as part of speculative execution functionality, designed to improve performance.</source>
          <target state="translated">在2018年初，披露了两个被称为&lt;em&gt;Meltdown&lt;/em&gt;和&lt;em&gt;Spectre的&lt;/em&gt;侧通道硬件漏洞。这些漏洞允许由于竞态产生的敏感数据泄露，而竞态条件是为提高性能而设计的推测执行功能的一部分。</target>
        </trans-unit>
        <trans-unit id="0701242525f77ea41dea13da7a10fb9576b0aa7f" translate="yes" xml:space="preserve">
          <source>In early versions of HTTP/1.1, a default character encoding was defined: ISO-8859-1. This is no longer recommended, and now each content-type may have its own default.</source>
          <target state="translated">在HTTP/1.1的早期版本中,定义了一个默认的字符编码。ISO-8859-1。现在不再推荐这样做,现在每个内容类型都可以有自己的默认值。</target>
        </trans-unit>
        <trans-unit id="fbebaf8ae5ad813c6e5579cad204cc0afeb3f2a6" translate="yes" xml:space="preserve">
          <source>In early versions of HTTP/1.1, a default charset (&lt;code&gt;ISO-8859-1&lt;/code&gt;) was defined. This is no more the case and now each content type may have its own default.</source>
          <target state="translated">在HTTP / 1.1的早期版本中，定义了默认字符集（ &lt;code&gt;ISO-8859-1&lt;/code&gt; ）。情况不再如此，现在每种内容类型都可以具有自己的默认值。</target>
        </trans-unit>
        <trans-unit id="76b87dd4cff176256a7ffd91b11051848e914ccf" translate="yes" xml:space="preserve">
          <source>In general, you don't need to do anything to manage prefetching. However, the user may wish to disable prefetching. On Firefox, this can be done by setting the &lt;code&gt;network.dns.disablePrefetch&lt;/code&gt; preference to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">通常，您无需执行任何操作即可管理预取。但是，用户可能希望禁用预取。在Firefox上，可以通过将 &lt;code&gt;network.dns.disablePrefetch&lt;/code&gt; 首选项设置为 &lt;code&gt;true&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="663b0e3712ad97e7d9fa6a474afdbfa58ef61280" translate="yes" xml:space="preserve">
          <source>In many cases, it is caused by a browser plugin (e.g. an ad blocker or privacy protector) blocking the request.</source>
          <target state="translated">在许多情况下,这是由于浏览器插件(如广告拦截器或隐私保护器)阻止了该请求。</target>
        </trans-unit>
        <trans-unit id="674099d2a81c401b8baaba7396a1a690e7a583af" translate="yes" xml:space="preserve">
          <source>In most cases, the policy-controlled features represent functionality that when used will negatively impact the user experience. To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. Best practices are then enforced by using policies that disable the policy-controlled features. For more details see &quot;Enforcing best practices for good user experiences&quot;.</source>
          <target state="translated">在大多数情况下,策略控制的功能代表着使用后会对用户体验产生负面影响的功能。为了避免破坏现有的网络内容,这类策略控制功能的默认情况是允许所有来源使用该功能。然后通过使用禁用策略控制功能的策略来执行最佳实践。更多细节请参见 &quot;执行最佳实践,实现良好的用户体验&quot;。</target>
        </trans-unit>
        <trans-unit id="5408e40c9a5920880e7570b54ae2fe87a76b064d" translate="yes" xml:space="preserve">
          <source>In opposition to the previous &lt;code&gt;Accept-*&lt;/code&gt; headers which are sent by the client, the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP header is sent by the web server in its response. It indicates the list of headers used by the server during the server-driven content negotiation phase. The header is needed in order to inform the cache of the decision criteria so that it can reproduce it, allowing the cache to be functional while preventing serving erroneous content to the user.</source>
          <target state="translated">与客户端发送的先前的 &lt;code&gt;Accept-*&lt;/code&gt; 标头相反，&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP标头由Web服务器在其响应中发送。它指示服务器驱动的内容协商阶段中服务器使用的标头列表。标头是必需的，以便将决策标准告知缓存，以便它可以重现它，从而在防止向用户提供错误内容的同时使缓存发挥作用。</target>
        </trans-unit>
        <trans-unit id="badfc139e7e8ad666da707d60e16523bcd32cfa3" translate="yes" xml:space="preserve">
          <source>In order to decide whether a response is fresh or stale, we need to
   compare its freshness lifetime to its age. The age is calculated as
   described in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;; this section describes how to calculate
   the freshness lifetime, and to determine if a response has expired.
   In the discussion below, the values can be represented in any form
   appropriate for arithmetic operations.

   We use the term &quot;expires_value&quot; to denote the value of the Expires
   header. We use the term &quot;max_age_value&quot; to denote an appropriate
   value of the number of seconds carried by the &quot;max-age&quot; directive of
   the Cache-Control header in a response (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;).

   The max-age directive takes priority over Expires, so if max-age is
   present in a response, the calculation is simply:

      freshness_lifetime = max_age_value

   Otherwise, if Expires is present in the response, the calculation is:

      freshness_lifetime = expires_value - date_value

   Note that neither of these calculations is vulnerable to clock skew,
   since all of the information comes from the origin server.

   If none of Expires, Cache-Control: max-age, or Cache-Control: s-
   maxage (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;) appears in the response, and the response
   does not include other restrictions on caching, the cache MAY compute
   a freshness lifetime using a heuristic. The cache MUST attach Warning
   113 to any response whose age is more than 24 hours if such warning
   has not already been added.

   Also, if the response does have a Last-Modified time, the heuristic
   expiration value SHOULD be no more than some fraction of the interval
   since that time. A typical setting of this fraction might be 10%.

   The calculation to determine if a response has expired is quite
   simple:

      response_is_fresh = (freshness_lifetime &amp;gt; current_age)</source>
          <target state="translated">为了确定响应是新鲜的还是陈旧的，我们需要将其新鲜度与寿命进行比较。年龄是按照&lt;a href=&quot;#section-13.2.3&quot;&gt;第13.2.3节中&lt;/a&gt;所述计算的；本节介绍如何计算保鲜期，以及确定响应是否过期。在下面的讨论中，可以用适合算术运算的任何形式来表示值。我们使用术语&amp;ldquo; expires_value&amp;rdquo;来表示Expires标头的值。我们使用术语&amp;ldquo; max_age_value&amp;rdquo;来表示响应中Cache-Control标头的&amp;ldquo; max-age&amp;rdquo;指令所载秒数的适当值（请参阅&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节）&lt;/a&gt;）。 max-age指令的优先级高于Expires，因此，如果响应中存在max-age，则计算很简单：新鲜度_生命时间= max_age_value否则，如果响应中存在Expires，则计算为：新鲜度_生命时间= expires_value-date_value这些计算都不容易受到时钟偏斜的影响，因为所有信息都来自原始服务器。如果没有Expires，Cache-Control：max-age或Cache-Control：s-maxage（请参阅&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节）&lt;/a&gt;）出现在响应中，并且响应不包括其他对缓存的限制，缓存可以使用启发式方法计算新鲜度生存期。如果还没有添加警告，则缓存必须将警告113附加到超过24小时的任何响应。同样，如果响应确实具有最后修改时间，则启发式到期值应不超过该时间间隔的一部分。该比例的典型设置可能是10％。确定响应是否已过期的计算非常简单：response_is_fresh =（freshness_lifetime&amp;gt; current_age）</target>
        </trans-unit>
        <trans-unit id="d03e66527d9041fe3d196b0602d934ec30eb980d" translate="yes" xml:space="preserve">
          <source>In order to fix this problem, Mozilla changed the behavior of loading resource: URIs in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=863246&quot;&gt;bug 863246&lt;/a&gt;, which landed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/57&quot;&gt;Firefox 57 (Quantum)&lt;/a&gt;.</source>
          <target state="translated">为了解决此问题，Mozilla更改了加载资源的行为：&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=863246&quot;&gt;Bug 863246中的&lt;/a&gt; URI ，该URI 降落在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/57&quot;&gt;Firefox 57（Quantum）中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3cacbc626f64e05a875aafa03b69d5da76a91ff" translate="yes" xml:space="preserve">
          <source>In order to know if a cached entry is fresh, a cache needs to know if
   its age exceeds its freshness lifetime. We discuss how to calculate
   the latter in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;; this section describes how to calculate
   the age of a response or cache entry.

   In this discussion, we use the term &quot;now&quot; to mean &quot;the current value
   of the clock at the host performing the calculation.&quot; Hosts that use
   HTTP, but especially hosts running origin servers and caches, SHOULD
   use NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;] or some similar protocol to synchronize their clocks to
   a globally accurate time standard. 

   HTTP/1.1 requires origin servers to send a Date header, if possible,
   with every response, giving the time at which the response was
   generated (see &lt;a href=&quot;#section-14.18&quot;&gt;section 14.18&lt;/a&gt;). We use the term &quot;date_value&quot; to denote
   the value of the Date header, in a form appropriate for arithmetic
   operations.

   HTTP/1.1 uses the Age response-header to convey the estimated age of
   the response message when obtained from a cache. The Age field value
   is the cache's estimate of the amount of time since the response was
   generated or revalidated by the origin server.

   In essence, the Age value is the sum of the time that the response
   has been resident in each of the caches along the path from the
   origin server, plus the amount of time it has been in transit along
   network paths.

   We use the term &quot;age_value&quot; to denote the value of the Age header, in
   a form appropriate for arithmetic operations.

   A response's age can be calculated in two entirely independent ways:

      1. now minus date_value, if the local clock is reasonably well
         synchronized to the origin server's clock. If the result is
         negative, the result is replaced by zero.

      2. age_value, if all of the caches along the response path
         implement HTTP/1.1.

   Given that we have two independent ways to compute the age of a
   response when it is received, we can combine these as

       corrected_received_age = max(now - date_value, age_value)

   and as long as we have either nearly synchronized clocks or all-
   HTTP/1.1 paths, one gets a reliable (conservative) result.

   Because of network-imposed delays, some significant interval might
   pass between the time that a server generates a response and the time
   it is received at the next outbound cache or client. If uncorrected,
   this delay could result in improperly low ages.

   Because the request that resulted in the returned Age value must have
   been initiated prior to that Age value's generation, we can correct
   for delays imposed by the network by recording the time at which the
   request was initiated. Then, when an Age value is received, it MUST
   be interpreted relative to the time the request was initiated, not 

   the time that the response was received. This algorithm results in
   conservative behavior no matter how much delay is experienced. So, we
   compute:

      corrected_initial_age = corrected_received_age
                            + (now - request_time)

   where &quot;request_time&quot; is the time (according to the local clock) when
   the request that elicited this response was sent.

   Summary of age calculation algorithm, when a cache receives a
   response:

      /*
       * age_value
       *      is the value of Age: header received by the cache with
       *              this response.
       * date_value
       *      is the value of the origin server's Date: header
       * request_time
       *      is the (local) time when the cache made the request
       *              that resulted in this cached response
       * response_time
       *      is the (local) time when the cache received the
       *              response
       * now
       *      is the current (local) time
       */

      apparent_age = max(0, response_time - date_value);
      corrected_received_age = max(apparent_age, age_value);
      response_delay = response_time - request_time;
      corrected_initial_age = corrected_received_age + response_delay;
      resident_time = now - response_time;
      current_age   = corrected_initial_age + resident_time;

   The current_age of a cache entry is calculated by adding the amount
   of time (in seconds) since the cache entry was last validated by the
   origin server to the corrected_initial_age. When a response is
   generated from a cache entry, the cache MUST include a single Age
   header field in the response with a value equal to the cache entry's
   current_age.

   The presence of an Age header field in a response implies that a
   response is not first-hand. However, the converse is not true, since
   the lack of an Age header field in a response does not imply that the 

   response is first-hand unless all caches along the request path are
   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement
   the Age header field).</source>
          <target state="translated">为了知道高速缓存的条目是否新鲜，高速缓存需要知道其寿命是否超过其新鲜寿命。我们将在&lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4节&lt;/a&gt;讨论如何计算后者;本节介绍如何计算响应或缓存条目的期限。在此讨论中，我们使用术语&amp;ldquo;现在&amp;rdquo;来表示&amp;ldquo;执行计算的主机上时钟的当前值&amp;rdquo;。使用HTTP的主机，尤其是运行原始服务器和缓存的主机，应使用NTP [ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt; ]或类似协议将其时钟同步到全球准确的时间标准。 HTTP / 1.1要求原始服务器在可能的情况下随每个响应发送一个Date标头，并给出生成响应的时间（请参阅&lt;a href=&quot;#section-14.18&quot;&gt;第14.18节）&lt;/a&gt;）。我们使用术语&amp;ldquo; date_value&amp;rdquo;以适合算术运算的形式表示Date标头的值。从缓存中获取HTTP / 1.1时，HTTP / 1.1使用&amp;ldquo;年龄&amp;rdquo;响应头来传达响应消息的估计寿命。年龄字段值是缓存对原始服务器生成或重新验证响应以来的时间量的估计。本质上，Age值是响应从源服务器沿路径驻留在每个缓存中的时间加上沿网络路径传输的时间之和。我们使用术语&amp;ldquo; age_value&amp;rdquo;以适合算术运算的形式表示Age标头的值。响应的年龄可以通过两种完全独立的方式计算：1。如果本地时钟与原始服务器的时钟相当合理地同步，则现在减去date_value。如果结果为负，则结果将替换为零。 2. age_value，如果响应路径上的所有缓存均实现HTTP / 1.1。假设我们有两种独立的方法来计算收到响应的时间，可以将它们合并为corrected_received_age = max（现在-date_value，age_value），并且只要我们具有几乎同步的时钟或全HTTP / 1.1路径，可以获得可靠（保守）的结果。由于网络造成的延迟，在服务器生成响应的时间与在下一个出站缓存或客户端处接收到响应的时间之间可能会经过一些重要的间隔。如果未纠正，这种延迟可能会导致年龄过低。因为导致返回的Age值的请求必须在该Age值生成之前就已经发起，所以我们可以通过记录发起请求的时间来纠正网络造成的延迟。然后，当接收到年龄值时，必须相对于发起请求的时间而不是响应的接收时间来解释它。无论经历多少延迟，此算法都会导致行为保守。因此，我们计算：corrected_initial_age = corrected_received_age +（现在为request_time），其中&amp;ldquo; request_time&amp;rdquo;是发出引发此响应的请求的时间（根据本地时钟）。年龄计算算法摘要，当缓存接收到响应时：/ * * age_value *是带有*该响应的缓存接收到的Age：标头的值。 * date_value *是原始服务器的Date的值：标头* request_time *是缓存发出请求时（导致此缓存的响应）的（本地）时间* response_time *是缓存接收到*的（本地）时间response * now *是当前（本地）时间* / parent_age = max（0，response_time-date_value）; Corrected_received_age = max（apparent_age，age_value）; response_delay = response_time-request_time; corrected_initial_age = corrected_received_age + response_delay;resident_time = now-response_time; current_age =校正后的初始年龄+ resident_time;缓存条目的current_age是通过将自原始服务器上次验证缓存条目以来的时间量（以秒为单位）添加到corrected_initial_age中来计算的。当从缓存条目生成响应时，缓存必须在响应中包含单个Age标头字段，其值等于缓存条目的current_age。响应中存在Age标头字段表示该响应不是第一手的。但是，反之则不成立，因为响应中缺少Age标头字段并不表示响应是第一手的，除非沿着请求路径的所有缓存均符合HTTP / 1.1（即，较旧的HTTP缓存不符合）实现Age标头字段）。</target>
        </trans-unit>
        <trans-unit id="93eea119dacd0c2679005705eb05947c3bbce8c5" translate="yes" xml:space="preserve">
          <source>In order to mitigate these flaws, HTTP/1.1 introduced pipelining (which proved difficult to implement) and persistent connections: the underlying TCP connection can be partially controlled using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header. HTTP/2 went a step further by multiplexing messages over a single connection, helping keep the connection warm, and more efficient.</source>
          <target state="translated">为了减轻这些缺陷，HTTP / 1.1引入了流水线（事实证明难以实现）和持久连接：可以使用&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头部分控制基础TCP连接。HTTP / 2通过在单个连接上多路复用消息来进一步提高连接的效率，从而使连接保持温暖。</target>
        </trans-unit>
        <trans-unit id="58bad13cde4243caa4f445a82bf628be18579594" translate="yes" xml:space="preserve">
          <source>In order to mitigate this flaw, HTTP/1.1 introduced &lt;em&gt;pipelining&lt;/em&gt; (which proved difficult to implement) and &lt;em&gt;persistent connections&lt;/em&gt;: the underlying TCP connection can be partially controlled using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header. HTTP/2 went a step further by multiplexing messages over a single connection, helping keep the connection warm and more efficient.</source>
          <target state="translated">为了缓解此缺陷，HTTP / 1.1引入了&lt;em&gt;流水线&lt;/em&gt;（事实证明难以实现）和&lt;em&gt;持久连接&lt;/em&gt;：可以使用&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头部分控制基础TCP连接。HTTP / 2通过在单个连接上多路复用消息来进一步提高了连接的效率，从而使连接保持温暖和高效。</target>
        </trans-unit>
        <trans-unit id="d06ed585978c0a513808590b8c6743bd98c74164" translate="yes" xml:space="preserve">
          <source>In parallel to the somewhat chaotic use of the diverse implementations of HTTP/1.0, and since 1995, well before the publication of HTTP/1.0 document the next year, proper standardization was in progress. The first standardized version of HTTP, HTTP/1.1 was published in early 1997, only a few months after HTTP/1.0.</source>
          <target state="translated">在使用HTTP/1.0的各种实现有些混乱的同时,自1995年起,远在第二年HTTP/1.0文档发布之前,适当的标准化工作就在进行中。HTTP的第一个标准化版本HTTP/1.1于1997年初发布,这仅仅是HTTP/1.0的几个月之后。</target>
        </trans-unit>
        <trans-unit id="4a373ca506ac7942c288749c8f149a921b16adb3" translate="yes" xml:space="preserve">
          <source>In particular, a request is preflighted if &lt;strong&gt;any of the following conditions&lt;/strong&gt; is true:</source>
          <target state="translated">特别是，如果&lt;strong&gt;满足以下任一条件&lt;/strong&gt;，则对请求进行预检：</target>
        </trans-unit>
        <trans-unit id="6d1e5ffefab8e49049390586276d922518d4d867" translate="yes" xml:space="preserve">
          <source>In particular, the request &lt;em&gt;requires&lt;/em&gt; these two additional headers:</source>
          <target state="translated">特别是，该请求&lt;em&gt;需要&lt;/em&gt;以下两个附加标头：</target>
        </trans-unit>
        <trans-unit id="32f825d053979b2bbea746eee217de968d1740ce" translate="yes" xml:space="preserve">
          <source>In practice, hop-by-hop compression is transparent for the server and the client, and is rarely used. &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; are mostly used to send a response by chunks, allowing to start transmitting a resource without knowing its length.</source>
          <target state="translated">实际上，逐跳压缩对于服务器和客户端是透明的，并且很少使用。&lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;通常用于按块发送响应，从而允许在不知道资源长度的情况下开始传输资源。</target>
        </trans-unit>
        <trans-unit id="6fb0378e9b8c8212e3d2de953dca5265e4ca3124" translate="yes" xml:space="preserve">
          <source>In practice, this error is very rarely used. Instead of responding using this error code, which would be cryptic for the end user and difficult to fix, servers ignore the relevant header and serve an actual page to the user. It is assumed that even if the user won't be completely happy, they will prefer this to an error code.</source>
          <target state="translated">在实践中,这种错误很少被使用。服务器不使用这个错误代码进行响应,因为它对最终用户来说是神秘的,而且难以修复,而是忽略相关的头,并向用户提供一个实际的页面。假设即使用户不会完全满意,他们也会喜欢这样的错误代码,而不是错误代码。</target>
        </trans-unit>
        <trans-unit id="5897a27e39859a1490a88859d07dae77805526ee" translate="yes" xml:space="preserve">
          <source>In practice, web developers don't need to implement compression mechanisms, both browsers and servers have it implemented already, but they have to be sure that the server is configured adequately. Compression happens at three different levels:</source>
          <target state="translated">在实践中,Web开发人员不需要实现压缩机制,浏览器和服务器都已经实现了压缩机制,但他们必须确保服务器有足够的配置。压缩发生在三个不同的层面。</target>
        </trans-unit>
        <trans-unit id="495136708e3b335d9a535e1968ab6547efcb7046" translate="yes" xml:space="preserve">
          <source>In presence of an &lt;code&gt;Accept-Ranges&lt;/code&gt; header, the browser may try to &lt;em&gt;resume&lt;/em&gt; an interrupted download, rather than to start it from the start again.</source>
          <target state="translated">在存在 &lt;code&gt;Accept-Ranges&lt;/code&gt; 标头的情况下，浏览器可能会尝试&lt;em&gt;恢复&lt;/em&gt;中断的下载，而不是从头开始。</target>
        </trans-unit>
        <trans-unit id="b7c4393bb4e04346146f3edbaf7c8cd5fd81dd69" translate="yes" xml:space="preserve">
          <source>In reality, there are more computers between a browser and the server handling the request: there are routers, modems, and more. Thanks to the layered design of the Web, these are hidden in the network and transport layers. HTTP is on top at the application layer. Although important to diagnose network problems, the underlying layers are mostly irrelevant to the description of HTTP.</source>
          <target state="translated">实际上,在浏览器和处理请求的服务器之间有更多的计算机:有路由器、调制解调器等等。由于Web的分层设计,这些都隐藏在网络层和传输层中。HTTP在应用层的顶端。虽然对诊断网络问题很重要,但底层对HTTP的描述大多无关紧要。</target>
        </trans-unit>
        <trans-unit id="6a1a0787f92838b7783a71a3a4c2afe47df40a00" translate="yes" xml:space="preserve">
          <source>In reality, there are more computers between a browser and the server handling the request: there are routers, modems, and more. Thanks to the layered design of the Web, these are hidden in the network and transport layers. HTTP is on top, at the application layer. Although important to diagnose network problems, the underlying layers are mostly irrelevant to the description of HTTP.</source>
          <target state="translated">实际上,在浏览器和处理请求的服务器之间有更多的计算机:有路由器、调制解调器等等。由于Web的分层设计,这些都隐藏在网络层和传输层中。HTTP在顶部,在应用层。虽然对诊断网络问题很重要,但底层对HTTP的描述大多无关紧要。</target>
        </trans-unit>
        <trans-unit id="1441977c1eecf0cbb90000197c29c7bf7c86dab2" translate="yes" xml:space="preserve">
          <source>In requests without credentials, you can also use a wildcard value:</source>
          <target state="translated">在没有凭证的请求中,你也可以使用通配符值。</target>
        </trans-unit>
        <trans-unit id="5bf5f583aa5451ac94eabad6345a75ed78fe4350" translate="yes" xml:space="preserve">
          <source>In requests, (such as &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;), the client tells the server what type of data is actually sent.</source>
          <target state="translated">在请求（例如&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;）中，客户端告诉服务器实际发送的数据类型。</target>
        </trans-unit>
        <trans-unit id="8a90c9dffff8f7d42978681a49c1181c2ea1638f" translate="yes" xml:space="preserve">
          <source>In response to &lt;a href=&quot;https://www.mozilla.org/en-US/security/advisories/mfsa2019-21/#CVE-2019-11730&quot;&gt;CVE-2019-11730&lt;/a&gt;, Firefox 68 and later define the origin of a page opened using a &lt;code&gt;file:///&lt;/code&gt; URI as unique. Therefore, other resources in the same directory or its subdirectories no longer satisfy the CORS same-origin rule. This new behavior is enabled by default using the &lt;code&gt;privacy.file_unique_origin&lt;/code&gt; preference.</source>
          <target state="translated">作为对&lt;a href=&quot;https://www.mozilla.org/en-US/security/advisories/mfsa2019-21/#CVE-2019-11730&quot;&gt;CVE-2019-11730的&lt;/a&gt;响应，Firefox 68和更高版本将使用 &lt;code&gt;file:///&lt;/code&gt; URI打开的页面的来源定义为唯一。因此，同一目录或其子目录中的其他资源不再满足CORS同源规则。默认情况下，使用 &lt;code&gt;privacy.file_unique_origin&lt;/code&gt; 首选项启用此新行为。</target>
        </trans-unit>
        <trans-unit id="205212e02d3ed8aca2b00bcaaead0dc09052b8b2" translate="yes" xml:space="preserve">
          <source>In response, Chromium shipped &lt;a href=&quot;https://fetch.spec.whatwg.org/#corb&quot;&gt;Cross-Origin Read Blocking&lt;/a&gt;, which automatically protects certain resources (of</source>
          <target state="translated">作为响应，Chromium交付了&lt;a href=&quot;https://fetch.spec.whatwg.org/#corb&quot;&gt;跨域读取阻止&lt;/a&gt;，可自动保护某些资源（</target>
        </trans-unit>
        <trans-unit id="f09312a5e29c9ecda7f1b42ac4b9044bcc540aa1" translate="yes" xml:space="preserve">
          <source>In response, the server sends back an &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header with &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt;, which means that the resource can be accessed by &lt;strong&gt;any&lt;/strong&gt; origin.</source>
          <target state="translated">作为响应，服务器发回一个&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;头与 &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; ，这意味着资源可接&lt;strong&gt;任何&lt;/strong&gt;来源。</target>
        </trans-unit>
        <trans-unit id="1d41bda365255372b63ef811da0c711c5a50b4a0" translate="yes" xml:space="preserve">
          <source>In responses, a &lt;code&gt;Content-Type&lt;/code&gt; header tells the client what the content type of the returned content actually is. Browsers will do MIME sniffing in some cases and will not necessarily follow the value of this header; to prevent this behavior, the header &lt;a href=&quot;x-content-type-options&quot;&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;&lt;/a&gt; can be set to &lt;code&gt;nosniff&lt;/code&gt;.</source>
          <target state="translated">作为响应， &lt;code&gt;Content-Type&lt;/code&gt; 标头告诉客户端返回的内容的内容类型实际上是什么。在某些情况下，浏览器将执行MIME嗅探，并且不一定遵循此标头的值；为防止此行为，可以将标头&lt;a href=&quot;x-content-type-options&quot;&gt; &lt;code&gt;X-Content-Type-Options&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;nosniff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7328d876f6eb63e7721164796f1284534dc9f3db" translate="yes" xml:space="preserve">
          <source>In short the EU directive means that before somebody can store or retrieve any information from a computer, mobile phone or other device, the user must give informed consent to do so. Many websites have added banners (AKA &quot;cookie banners&quot;) since then to inform the user about the use of cookies.</source>
          <target state="translated">简而言之,欧盟指令意味着,在别人从电脑、手机或其他设备上存储或检索任何信息之前,用户必须给予知情同意。从那时起,许多网站都添加了横幅(也就是 &quot;cookie横幅&quot;),以告知用户关于cookie的使用。</target>
        </trans-unit>
        <trans-unit id="1d12b916e1ea56872beecbf2e4e9757af03ec500" translate="yes" xml:space="preserve">
          <source>In some cases, the operator of a cache MAY choose to configure it to
   return stale responses even when not requested by clients. This
   decision ought not be made lightly, but may be necessary for reasons
   of availability or performance, especially when the cache is poorly
   connected to the origin server. Whenever a cache returns a stale
   response, it MUST mark it as such (using a Warning header) enabling
   the client software to alert the user that there might be a potential
   problem. 

   It also allows the user agent to take steps to obtain a first-hand or
   fresh response. For this reason, a cache SHOULD NOT return a stale
   response if the client explicitly requests a first-hand or fresh one,
   unless it is impossible to comply for technical or policy reasons.</source>
          <target state="translated">在某些情况下,缓存的操作者可以选择将其配置为即使客户没有请求也会返回陈旧的响应。这个决定不应该轻易做出,但出于可用性或性能的考虑,可能是必要的,特别是当缓存与源服务器的连接很差的时候。每当缓存返回一个陈旧的响应时,它必须将其标记为陈旧的响应(使用Warning头),使客户端软件能够提醒用户可能存在潜在的问题。它也允许用户代理采取措施来获得第一手或新鲜的响应。出于这个原因,如果客户端明确要求获得第一手或新鲜的响应,缓存不应该返回一个陈旧的响应,除非由于技术或政策原因无法遵守。</target>
        </trans-unit>
        <trans-unit id="d9444a4e91ad14c01e9590e0bedd4b5d6e8c782c" translate="yes" xml:space="preserve">
          <source>In summary, we recommend looking for the string &amp;ldquo;Mobi&amp;rdquo; anywhere in the User Agent to detect a mobile device.</source>
          <target state="translated">总之，我们建议在用户代理中的任意位置查找字符串&amp;ldquo; Mobi&amp;rdquo;以检测移动设备。</target>
        </trans-unit>
        <trans-unit id="b4e56f9ae18c2388ab7193bb81f5a1535e68eead" translate="yes" xml:space="preserve">
          <source>In that specification a client may send a request that contains an extension declaration, that describes the extension to be used. If the server receives such a request, but any described extensions are not supported for the request, then the server responds with the 510 status code.</source>
          <target state="translated">在该规范中,客户机可以发送一个包含扩展声明的请求,该声明描述了要使用的扩展。如果服务器收到这样的请求,但任何描述的扩展都不支持该请求,那么服务器就会以510状态码作出响应。</target>
        </trans-unit>
        <trans-unit id="10ded161d3ab76c69e065e7f428e51b119cc26b8" translate="yes" xml:space="preserve">
          <source>In the above scenario, &lt;code&gt;no-referrer&lt;/code&gt; will only be used if &lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; is not supported by the browser.</source>
          <target state="translated">在上述情况下，仅 &lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; 浏览器不支持strict-origin-when-cross-origin时，才使用 &lt;code&gt;no-referrer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32c2d5256e5dc0b53e01514a025fbdaca4825463" translate="yes" xml:space="preserve">
          <source>In the absence of a MIME type, or in certain cases where browsers believe they are incorrect, browsers may perform &lt;em&gt;MIME sniffing&lt;/em&gt; &amp;mdash; guessing the correct MIME type by looking at the bytes of the resource.</source>
          <target state="translated">在没有MIME类型的情况下，或者在某些情况下浏览器认为它们不正确，浏览器可能会执行&lt;em&gt;MIME嗅探&lt;/em&gt; -通过查看资源的字节来猜测正确的MIME类型。</target>
        </trans-unit>
        <trans-unit id="cdc3e1dfd2d8a54df8817aa9e2334a8c551dfaed" translate="yes" xml:space="preserve">
          <source>In the case of a &quot;Basic&quot; authentication like shown in the figure, the exchange &lt;strong&gt;must&lt;/strong&gt; happen over an HTTPS (TLS) connection to be secure.</source>
          <target state="translated">在如图所示的&amp;ldquo;基本&amp;rdquo;身份验证的情况下，交换&lt;strong&gt;必须&lt;/strong&gt;通过HTTPS（TLS）连接进行以确保安全。</target>
        </trans-unit>
        <trans-unit id="9597ab40baf818d41d5819712b2c6f8aebbfee81" translate="yes" xml:space="preserve">
          <source>In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give a response to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resource but a confirmation message such as: 'you successfully uploaded XYZ'.</source>
          <target state="translated">在您希望将方法更改为&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 的情况下&lt;/a&gt;，请使用&lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; &lt;/a&gt;。当您想响应一个&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;方法而不是上载的资源，而是一个确认消息，例如：&amp;ldquo;您已成功上载XYZ&amp;rdquo; 时，这很有用。</target>
        </trans-unit>
        <trans-unit id="8606d0b35470c00c20840dcc3a06c5fbe9904c62" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Accept = [ ( &quot;,&quot; / ( media-range [ accept-params ] ) ) *( OWS &quot;,&quot; [
    OWS ( media-range [ accept-params ] ) ] ) ]
   Accept-Charset = *( &quot;,&quot; OWS ) ( ( charset / &quot;*&quot; ) [ weight ] ) *( OWS
    &quot;,&quot; [ OWS ( ( charset / &quot;*&quot; ) [ weight ] ) ] )
   Accept-Encoding = [ ( &quot;,&quot; / ( codings [ weight ] ) ) *( OWS &quot;,&quot; [ OWS
    ( codings [ weight ] ) ] ) ]
   Accept-Language = *( &quot;,&quot; OWS ) ( language-range [ weight ] ) *( OWS
    &quot;,&quot; [ OWS ( language-range [ weight ] ) ] )
   Allow = [ ( &quot;,&quot; / method ) *( OWS &quot;,&quot; [ OWS method ] ) ]

   BWS = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Content-Encoding = *( &quot;,&quot; OWS ) content-coding *( OWS &quot;,&quot; [ OWS
    content-coding ] )
   Content-Language = *( &quot;,&quot; OWS ) language-tag *( OWS &quot;,&quot; [ OWS
    language-tag ] )
   Content-Location = absolute-URI / partial-URI
   Content-Type = media-type

   Date = HTTP-date

   Expect = &quot;100-continue&quot;

   From = mailbox

   GMT = %x47.4D.54 ; GMT

   HTTP-date = IMF-fixdate / obs-date

   IMF-fixdate = day-name &quot;,&quot; SP date1 SP time-of-day SP GMT

   Location = URI-reference

   Max-Forwards = 1*DIGIT

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   RWS = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
   Referer = absolute-URI / partial-URI
   Retry-After = HTTP-date / delay-seconds 

   Server = product *( RWS ( product / comment ) )

   URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   User-Agent = product *( RWS ( product / comment ) )

   Vary = &quot;*&quot; / ( *( &quot;,&quot; OWS ) field-name *( OWS &quot;,&quot; [ OWS field-name ]
    ) )

   absolute-URI = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]
   accept-params = weight *accept-ext
   asctime-date = day-name SP date3 SP time-of-day SP year

   charset = token
   codings = content-coding / &quot;identity&quot; / &quot;*&quot;
   comment = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   content-coding = token

   date1 = day SP month SP year
   date2 = day &quot;-&quot; month &quot;-&quot; 2DIGIT
   date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
   day = 2DIGIT
   day-name = %x4D.6F.6E ; Mon
    / %x54.75.65 ; Tue
    / %x57.65.64 ; Wed
    / %x54.68.75 ; Thu
    / %x46.72.69 ; Fri
    / %x53.61.74 ; Sat
    / %x53.75.6E ; Sun
   day-name-l = %x4D.6F.6E.64.61.79 ; Monday
    / %x54.75.65.73.64.61.79 ; Tuesday
    / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
    / %x54.68.75.72.73.64.61.79 ; Thursday
    / %x46.72.69.64.61.79 ; Friday
    / %x53.61.74.75.72.64.61.79 ; Saturday
    / %x53.75.6E.64.61.79 ; Sunday
   delay-seconds = 1*DIGIT

   field-name = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;

   hour = 2DIGIT

   language-range = &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;
   language-tag = &amp;lt;Language-Tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;[RFC5646], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
   media-range = ( &quot;*/*&quot; / ( type &quot;/*&quot; ) / ( type &quot;/&quot; subtype ) ) *( OWS
    &quot;;&quot; OWS parameter ) 

   media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
   method = token
   minute = 2DIGIT
   month = %x4A.61.6E ; Jan
    / %x46.65.62 ; Feb
    / %x4D.61.72 ; Mar
    / %x41.70.72 ; Apr
    / %x4D.61.79 ; May
    / %x4A.75.6E ; Jun
    / %x4A.75.6C ; Jul
    / %x41.75.67 ; Aug
    / %x53.65.70 ; Sep
    / %x4F.63.74 ; Oct
    / %x4E.6F.76 ; Nov
    / %x44.65.63 ; Dec

   obs-date = &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date / asctime-date

   parameter = token &quot;=&quot; ( token / quoted-string )
   partial-URI = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   product = token [ &quot;/&quot; product-version ]
   product-version = token
   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   qvalue = ( &quot;0&quot; [ &quot;.&quot; *3DIGIT ] ) / ( &quot;1&quot; [ &quot;.&quot; *3&quot;0&quot; ] )

   &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date = day-name-l &quot;,&quot; SP date2 SP time-of-day SP GMT

   second = 2DIGIT
   subtype = token

   time-of-day = hour &quot;:&quot; minute &quot;:&quot; second
   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   type = token

   weight = OWS &quot;;&quot; OWS &quot;q=&quot; qvalue

   year = 4DIGIT 

Index

   1
      1xx Informational (status code class)  50

   2
      2xx Successful (status code class)  51

   3
      3xx Redirection (status code class)  54

   4
      4xx Client Error (status code class)  58

   5
      5xx Server Error (status code class)  62

   1
      100 Continue (status code)  50
      100-continue (expect value)  34
      101 Switching Protocols (status code)  50

   2
      200 OK (status code)  51
      201 Created (status code)  52
      202 Accepted (status code)  52
      203 Non-Authoritative Information (status code)  52
      204 No Content (status code)  53
      205 Reset Content (status code)  53

   3
      300 Multiple Choices (status code)  55
      301 Moved Permanently (status code)  56
      302 Found (status code)  56
      303 See Other (status code)  57
      305 Use Proxy (status code)  58
      306 (Unused) (status code)  58
      307 Temporary Redirect (status code)  58

   4
      400 Bad Request (status code)  58
      402 Payment Required (status code)  59
      403 Forbidden (status code)  59
      404 Not Found (status code)  59
      405 Method Not Allowed (status code)  59
      406 Not Acceptable (status code)  59
      408 Request Timeout (status code)  60
      409 Conflict (status code)  60 

      410 Gone (status code)  60
      411 Length Required (status code)  61
      413 Payload Too Large (status code)  61
      414 URI Too Long (status code)  61
      415 Unsupported Media Type (status code)  62
      417 Expectation Failed (status code)  62
      426 Upgrade Required (status code)  62

   5
      500 Internal Server Error (status code)  63
      501 Not Implemented (status code)  63
      502 Bad Gateway (status code)  63
      503 Service Unavailable (status code)  63
      504 Gateway Timeout (status code)  63
      505 HTTP Version Not Supported (status code)  64

   A
      Accept header field  38
      Accept-Charset header field  40
      Accept-Encoding header field  41
      Accept-Language header field  42
      Allow header field  72

   C
      cacheable  24
      compress (content coding)  11
      conditional request  36
      CONNECT method  30
      content coding  11
      content negotiation  6
      Content-Encoding header field  12
      Content-Language header field  13
      Content-Location header field  15
      Content-Transfer-Encoding header field  89
      Content-Type header field  10

   D
      Date header field  67
      deflate (content coding)  11
      DELETE method  29

   E
      Expect header field  34

   F
      From header field  44 

   G
      GET method  24
      Grammar
         Accept  38
         Accept-Charset  40
         Accept-Encoding  41
         accept-ext  38
         Accept-Language  42
         accept-params  38
         Allow  72
         asctime-date  66
         charset  9
         codings  41
         content-coding  11
         Content-Encoding  12
         Content-Language  13
         Content-Location  15
         Content-Type  10
         Date  67
         date1  65
         day  65
         day-name  65
         day-name-l  65
         delay-seconds  69
         Expect  34
         From  44
         GMT  65
         hour  65
         HTTP-date  65
         IMF-fixdate  65
         language-range  42
         language-tag  13
         Location  68
         Max-Forwards  36
         media-range  38
         media-type  8
         method  21
         minute  65
         month  65
         obs-date  66
         parameter  8
         product  46
         product-version  46
         qvalue  38
         Referer  45
         Retry-After  69
         &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  66
         second  65 

         Server  73
         subtype  8
         time-of-day  65
         type  8
         User-Agent  46
         Vary  70
         weight  38
         year  65
      gzip (content coding)  11

   H
      HEAD method  25

   I
      idempotent  23

   L
      Location header field  68

   M
      Max-Forwards header field  36
      MIME-Version header field  89

   O
      OPTIONS method  31

   P
      payload  17
      POST method  25
      PUT method  26

   R
      Referer header field  45
      representation  7
      Retry-After header field  69

   S
      safe  22
      selected representation  7, 71
      Server header field  73
      Status Codes Classes
         1xx Informational  50
         2xx Successful  51
         3xx Redirection  54
         4xx Client Error  58
         5xx Server Error  62 

   T
      TRACE method  32

   U
      User-Agent header field  46

   V
      Vary header field  70

   X
      x-compress (content coding)  11
      x-gzip (content coding)  11

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                  [Page 101]</source>
          <target state="translated">在下面收集的ABNF中，列表规则&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;根据[RFC7230]的1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;节&lt;/a&gt;进行了扩展。接受= [（&amp;ldquo;，&amp;rdquo; /（媒体范围[accept-params]））*（OWS&amp;ldquo;，&amp;rdquo; [OWS（媒体范围[accept-params]]]）]] ）（（charset /&amp;ldquo; *&amp;rdquo;）[weight]）*（OWS&amp;ldquo;，&amp;rdquo; [OWS（（charset /&amp;ldquo; *&amp;rdquo;）[weight]]]）Accept-Encoding = [（&amp;ldquo;，&amp;rdquo; /（编码[weight] ））*（OWS&amp;ldquo;，&amp;rdquo; [OWS（编码[weight]）]）] Accept-Language = *（&amp;ldquo;，&amp;rdquo; OWS）（语言范围[weight]）*（OWS&amp;ldquo;，&amp;rdquo; [OWS（语言范围[weight]）]）Allow = [（&amp;ldquo;，&amp;rdquo; /方法）*（OWS&amp;ldquo;，&amp;rdquo; [OWS方法]）] BWS = &amp;lt;BWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt;&amp;gt; Content-Encoding = *（&amp;ldquo;，&amp;rdquo; OWS）内容编码*（OWS&amp;ldquo;，&amp;rdquo; [OWS content-coding]）Content-Language = *（&amp;ldquo;，&amp;rdquo; OWS）语言标签*（OWS&amp;ldquo;，&amp;rdquo; [OWS语言标签]）内容位置=绝对URI /部分URI内容类型=媒体类型日期= HTTP日期期望=&amp;ldquo; 100-continue&amp;rdquo;发件人=邮箱GMT =％x47.4D.54; GMT HTTP日期= IMF固定日期/ obs日期IMF固定日期=天名称&amp;ldquo;，&amp;rdquo; SP date1 SP一天中的时间SP GMT位置= URI引用Max-Forwards = 1 * DIGIT OWS = &amp;lt;OWS，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; RWS = &amp;lt;RWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt;引荐来源=绝对URI /部分URI重试之后= HTTP日期/延迟秒数服务器=产品*（RWS（产品/ comment））URI引用= &amp;lt;URI引用，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt; &amp;gt;用户代理=产品*（RWS（产品/评论））变量=&amp;ldquo; *&amp;rdquo; /（*（&amp;ldquo;，&amp;rdquo; OWS）字段名称*（OWS&amp;ldquo;，&amp;rdquo; [OWS字段名称] ））absolute-URI = &amp;lt;绝对URL，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt; &amp;gt; accept-ext = OWS&amp;ldquo;;&amp;rdquo; OWS令牌[&amp;ldquo; =&amp;rdquo;（令牌/带引号的字符串）] accept-params = weight * accept-ext asctime-date =日期名称SP date3 SP每日时间SP年字符集=令牌编码=内容编码/&amp;ldquo;身份&amp;rdquo; /&amp;ldquo; *&amp;rdquo;注释= &amp;lt;注释，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt;&amp;gt;内容编码=令牌日期1 = SP日SP月SP date date2 =日&amp;ldquo;-&amp;rdquo;月&amp;ldquo;-&amp;rdquo; 2DIGIT date3 =月SP（2DIGIT /（SP DIGIT））天= 2DIGIT日名称=％x4D.6F.6E;周一/％x54.75.65;星期二/％x57.65.64;周三/％x54.68.75;周四/％x46.72.69;星期五/％x53.61.74;星期六/％x53.75.6E;太阳日名称-l =％x4D.6F.6E.64.61.79;星期一/％x54.75.65.73.64.61.71.79;星期二/％x57.65.64.6E.65.73.64.61.79;星期三/％x54.68.75.72.73.64.61.71.79;星期四/％x46.72.69.64.61.799;星期五/％x53.61.74.75.72.64.61.71.79;星期六/％x53.75.6E.64.61.79;周日延迟秒= 1 * DIGIT字段名称= &amp;lt;注释，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]，第3.2节&lt;/a&gt; &amp;gt;小时= 2DIGIT语言范围= &amp;lt;语言范围，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647]，第2.1节&lt;/a&gt;&amp;gt;语言标签= &amp;lt;语言标签，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;[RFC5646]，第2.1节&lt;/a&gt; &amp;gt;邮箱= &amp;lt;邮箱，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]，第3.4节&lt;/a&gt; &amp;gt; media-range =（&amp;ldquo; * / *&amp;rdquo; /（输入&amp;ldquo; / *&amp;rdquo;）/ （类型&amp;ldquo; /&amp;rdquo;子类型））*（OWS&amp;ldquo;;&amp;rdquo; OWS参数）media-type =类型&amp;ldquo; /&amp;rdquo;子类型*（OWS&amp;ldquo;;&amp;rdquo; OWS参数）方法=令牌分钟= 2DIGIT月=％x4A.61.6E;一月/％x46.65.62; 2月/％x4D.61.72; Mar /％x41.70.72; 4月/％x4D.61.79; 5月/％x4A.75.6E; Jun /％x4A.75.6C; 7月/％x41.75.67; 8月/％x53.65.70; Sep /％x4F.63.74;十月/％x4E.6F.76; Nov /％x44.65.63; Dec obs-date = &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; -date / asctime-date参数=令牌&amp;ldquo; =&amp;rdquo;（标记/带引号的字符串）部分URI = &amp;lt;部分URI，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt;&amp;gt;产品=令牌[&amp;ldquo; /&amp;rdquo;产品版本]产品版本=令牌引号字符串= &amp;lt;引号字符串，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt; qvalue =（&amp;ldquo; 0&amp;rdquo; [&amp;ldquo;。&amp;rdquo; * 3DIGIT]） /（&amp;ldquo; 1&amp;rdquo; [&amp;ldquo;。&amp;rdquo; * 3&amp;ldquo; 0&amp;rdquo;]） &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; -date = day-name-l&amp;ldquo;，&amp;rdquo; SP date2 SP-day-SP SP GMT秒= 2DIGIT子类型=令牌-时间=小时&amp;ldquo;：&amp;rdquo;分钟&amp;ldquo;：&amp;rdquo;第二个令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt;&amp;gt;类型=令牌权重= OWS&amp;ldquo;;&amp;rdquo; OWS&amp;ldquo; q =&amp;rdquo;qvalue year = 4DIGIT索引1 1xx信息性（状态代码类）50 2 2xx成功（状态代码类）51 3 3xx重定向（状态代码类）54 4 4xx客户端错误（状态代码类）58 5 5xx服务器错误（状态代码类） ）62 1 100继续（状态代码）50100继续（期望值）34101切换协议（状态代码）50 2 200 OK（状态代码）51201创建（状态代码）52202接受（状态代码）52203非-权威信息（状态码）52204否内容（状态码）53205重置内容（状态码）53 3300多项选择（状态码）55301永久移动（状态码）56302找到（状态码）56303请参阅其他（状态码）57305使用代理（状态代码）58306（未使用）（状态代码）58307临时重定向（状态代码）58 4400错误的请求（状态代码）58402需要付款（状态代码）59403禁止（状态代码）59404未找到（状态码）59405不允许的方法（状态码）59406不可接受（状态码）59408请求超时（状态码）60409冲突（状态码）60410消失（状态码）60411所需的长度（状态码） ）61413有效负载太大（状态码）61414 URI太长（状态码）61415不支持的媒体类型（状态码）62417预期失败（状态码）62426需要升级（状态码）62 5500内部服务器错误（状态码）63501未实现（状态码）63502错误的网关（状态代码）63503服务不可用（状态代码）63504网关超时（状态代码）63505 HTTP版本不受支持（状态代码）64 A接受标头字段38接受字符集标头字段40接受编码标头字段41接受语言标头字段42允许标头字段72 C可缓存24压缩（内容编码）11条件请求36 CONNECT方法30内容编码11内容协商6内容编码标头字段12内容语言标头字段13内容位置标头字段15 Content-Transfer-Encoding标头字段89 Content-Type标头字段10 D日期标头字段67缩小（内容编码）11 DELETE方法29 E Expect标头字段34 F来自头字段44 G GET方法24语法接受38接受字符集40接受编码41 accept-ext 38接受语言42接受参数38允许72递增日期66字符集9编码41内容编码11内容-编码12内容语言13内容位置15内容类型10日期67 date1 65天65天名65天名l 65延迟秒数69期望34从44 GMT 65小时65 HTTP日期65 IMF-fixdate 65语言范围42语言标签13位置68最大前进36媒体范围38媒体类型8方法21分钟65个月65失效日期66参数8产品46产品版本46 q值38参照45重试后69 &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;射频850&lt;/a&gt;日期66秒65服务器73子类型8时间65类型8用户代理46变化70权重38年65 gzip（内容编码）11 H HEAD方法25等幂23 L位置标头字段68 M Max-Forward标头字段36 MIME版本标头字段89 O OPTIONS方法31 P有效载荷17 POST方法25 PUT方法26 R引用标头字段45表示形式7重试后标头字段69 S安全22选择的表示形式771服务器标头字段73状态代码类1xx信息50 2xx成功51 3xx重定向54 4xx客户端错误58 5xx服务器错误62 T TRACE方法32 U用户代理标头字段46 V可变标头字段70 X压缩（内容编码）11 x-gzip（内容编码）11作者的地址Roy T. Fielding（编辑）Adobe Systems Incorporated 345 Park Ave San Jose，CA 95110 USA电子邮件：fielding@gbiv.com URI：CA 95110 USA电子邮件：fielding@gbiv.com URI：CA 95110 USA电子邮件：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke（编辑）greenbytes GmbH Hafenweg 16 Muenster，NW 48155德国电子邮件：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding ＆Reschke标准跟踪[页101]</target>
        </trans-unit>
        <trans-unit id="e5c21a021da725c4cf94f0a415f9a51eddeeff8c" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Accept-Ranges = acceptable-ranges

   Content-Range = byte-content-range / other-content-range

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   If-Range = entity-tag / HTTP-date

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Range = byte-ranges-specifier / other-ranges-specifier

   acceptable-ranges = ( *( &quot;,&quot; OWS ) range-unit *( OWS &quot;,&quot; [ OWS
    range-unit ] ) ) / &quot;none&quot;

   byte-content-range = bytes-unit SP ( byte-range-resp /
    unsatisfied-range )
   byte-range = first-byte-pos &quot;-&quot; last-byte-pos
   byte-range-resp = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
   byte-range-set = *( &quot;,&quot; OWS ) ( byte-range-spec /
    suffix-byte-range-spec ) *( OWS &quot;,&quot; [ OWS ( byte-range-spec /
    suffix-byte-range-spec ) ] )
   byte-range-spec = first-byte-pos &quot;-&quot; [ last-byte-pos ]
   byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
   bytes-unit = &quot;bytes&quot;

   complete-length = 1*DIGIT

   entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;

   first-byte-pos = 1*DIGIT

   last-byte-pos = 1*DIGIT

   other-content-range = other-range-unit SP other-range-resp
   other-range-resp = *CHAR
   other-range-set = 1*VCHAR
   other-range-unit = token
   other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set

   range-unit = bytes-unit / other-range-unit

   suffix-byte-range-spec = &quot;-&quot; suffix-length 

   suffix-length = 1*DIGIT

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   unsatisfied-range = &quot;*/&quot; complete-length

Index

   2
      206 Partial Content (status code)  10

   4
      416 Range Not Satisfiable (status code)  15

   A
      Accept-Ranges header field  7

   C
      Content-Range header field  12

   G
      Grammar
         Accept-Ranges  7
         acceptable-ranges  7
         byte-content-range  12
         byte-range  12
         byte-range-resp  12
         byte-range-set  5
         byte-range-spec  5
         byte-ranges-specifier  5
         bytes-unit  5
         complete-length  12
         Content-Range  12
         first-byte-pos  5
         If-Range  9
         last-byte-pos  5
         other-content-range  12
         other-range-resp  12
         other-range-unit  5, 7
         Range  8
         range-unit  5
         ranges-specifier  5
         suffix-byte-range-spec  6
         suffix-length  6
         unsatisfied-range  12 

   I
      If-Range header field  9

   M
      Media Type
         multipart/byteranges  18, 21
         multipart/x-byteranges  19
      multipart/byteranges Media Type  18, 21
      multipart/x-byteranges Media Type  21

   R
      Range header field  8

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Yves Lafon (editor)
   World Wide Web Consortium
   W3C / ERCIM
   2004, rte des Lucioles
   Sophia-Antipolis, AM  06902
   France

   EMail: ylafon@w3.org
   URI:   &lt;a href=&quot;http://www.raubacapeu.net/people/yves/&quot;&gt;http://www.raubacapeu.net/people/yves/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding, et al.             Standards Track                   [Page 25]</source>
          <target state="translated">在下面收集的ABNF中，列表规则&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;根据[RFC7230]的1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;节&lt;/a&gt;进行了扩展。Accept-Ranges =可接受范围Content-Range =字节内容范围/ other-content-range HTTP日期= &amp;lt;HTTP日期，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]，第7.1.1.1节&lt;/a&gt; &amp;gt; If-Range =实体标签/ HTTP日期OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt;&amp;gt;范围=字节范围说明符/其他范围说明符可接受范围=（*（&amp;ldquo;，&amp;rdquo; OWS）范围单位*（OWS&amp;ldquo;，&amp;rdquo; [OWS范围单位]））/&amp;ldquo;无&amp;rdquo;字节内容-range =字节单位SP（byte-range-resp /不满足范围）byte-range =第一个字节pos&amp;ldquo;-&amp;rdquo; last-byte-pos byte-range-resp =字节范围&amp;ldquo; /&amp;rdquo;（complete- length /&amp;ldquo; *&amp;rdquo;）字节范围设置= *（&amp;ldquo;，&amp;rdquo; OWS）（字节范围规格/后缀字节范围规格）*（OWS&amp;ldquo;，&amp;rdquo; [OWS（字节范围规格/后缀-byte-range-spec）]）byte-range-spec =首个字节pos&amp;ldquo;-&amp;rdquo; [last-byte-pos] byte-ranges-specifier = bytes-unit&amp;ldquo; =&amp;rdquo;字节范围设置字节单位=&amp;ldquo; bytes&amp;rdquo; complete-length = 1 * DIGIT实体标签= &amp;lt;实体标签，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]，第2.3节&lt;/a&gt;&amp;gt;第一个字节pos = 1 * DIGIT最后一个字节pos = 1 * DIGIT其他内容范围=其他范围单位SP其他范围resp其他范围resp = * CHAR其他范围set = 1 * VCHAR other-range-unit =令牌other-ranges-specifier = other-range-unit&amp;ldquo; =&amp;rdquo; other-range-set range-unit =字节单位/ other-range-unit后缀-byte-range-spec = &amp;ldquo;-&amp;rdquo;后缀长度后缀长度= 1 * DIGIT令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt;&amp;gt;不满足范围=&amp;ldquo; * /&amp;rdquo;完整长度索引2206部分内容（状态代码）10 4 416范围不满足（状态代码）15 A接受范围标头字段7 C内容范围标头字段12 G语法接受-范围7可接受范围7字节内容范围12字节范围12字节范围resp 12字节范围集5字节范围规范5字节范围说明符5字节单位5完整长度12内容范围范围12首字节位5如果范围9末字节位5其他内容范围12其他范围resp 12其他范围单元57范围8范围单位5范围说明符5后缀字节范围说明6后缀长度6不满意范围12 I If-Range标头字段9 M媒体类型multipart / byteranges 18、21 multipart / x-byteranges 19 multipart / byteranges媒体类型18，21 multipart / x-byteranges媒体类型21 R范围标头字段8作者的地址Roy T. Fielding（编辑）Adobe Systems Incorporated 345 Park Ave San Jose，CA 95110 USA电子邮件：fielding@gbiv.com URI ：21个multipart / x字节范围的媒体类型21 R范围标头字段8作者的地址Roy T. Fielding（编辑）Adobe Systems Incorporated 345 Park Ave San Jose，CA 95110美国电子邮件：fielding@gbiv.com URI：21个multipart / x字节范围的媒体类型21 R范围标头字段8作者的地址Roy T. Fielding（编辑）Adobe Systems Incorporated 345 Park Ave San Jose，CA 95110美国电子邮件：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Yves Lafon（编辑）万维网联盟W3C / ERCIM 2004，卢西奥索&amp;middot;索菲亚-安提波利斯大街，法国06902法国电子邮件：ylafon@w3.org URI： &lt;a href=&quot;http://www.raubacapeu.net/people/yves/&quot;&gt;http：//www.raubacapeu .net / people / yves /&lt;/a&gt; Julian F. Reschke（编辑）greenbytes GmbH Hafenweg 16 Muenster，NW 48155德国电子邮件：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding等。标准跟踪[第25页]</target>
        </trans-unit>
        <trans-unit id="7f7187563510f7b95d508990280bc6d64358c455" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Age = delta-seconds

   Cache-Control = *( &quot;,&quot; OWS ) cache-directive *( OWS &quot;,&quot; [ OWS
    cache-directive ] )

   Expires = HTTP-date

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Pragma = *( &quot;,&quot; OWS ) pragma-directive *( OWS &quot;,&quot; [ OWS
    pragma-directive ] )

   Warning = *( &quot;,&quot; OWS ) warning-value *( OWS &quot;,&quot; [ OWS warning-value ]
    )

   cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   delta-seconds = 1*DIGIT

   extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   field-name = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;

   port = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   pragma-directive = &quot;no-cache&quot; / extension-pragma
   pseudonym = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;

   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   uri-host = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
   warn-code = 3DIGIT
   warn-date = DQUOTE HTTP-date DQUOTE
   warn-text = quoted-string
   warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date
    ] 

Index

   1
      110 (warn-code)  31
      111 (warn-code)  31
      112 (warn-code)  31
      113 (warn-code)  31
      199 (warn-code)  32

   2
      214 (warn-code)  32
      299 (warn-code)  32

   A
      age  11
      Age header field  21

   C
      cache  4
      cache entry  5
      cache key  5-6
      Cache-Control header field  21

   D
      Disconnected Operation (warn-text)  31

   E
      Expires header field  28
      explicit expiration time  11

   F
      fresh  11
      freshness lifetime  11

   G
      Grammar
         Age  21
         Cache-Control  22
         cache-directive  22
         delta-seconds  5
         Expires  28
         extension-pragma  29
         Pragma  29
         pragma-directive  29
         warn-agent  29
         warn-code  29
         warn-date  29
         warn-text  29 

         Warning  29
         warning-value  29

   H
      Heuristic Expiration (warn-text)  31
      heuristic expiration time  11
   M
      max-age (cache directive)  22, 26
      max-stale (cache directive)  22
      min-fresh (cache directive)  22
      Miscellaneous Persistent Warning (warn-text)  32
      Miscellaneous Warning (warn-text)  32
      must-revalidate (cache directive)  24

   N
      no-cache (cache directive)  23, 25
      no-store (cache directive)  23, 24
      no-transform (cache directive)  23, 25

   O
      only-if-cached (cache directive)  23

   P
      Pragma header field  29
      private (cache directive)  25
      private cache  4
      proxy-revalidate (cache directive)  26
      public (cache directive)  25

   R
      Response is Stale (warn-text)  30
      Revalidation Failed (warn-text)  31

   S
      s-maxage (cache directive)  27
      shared cache  4
      stale  11
      strong validator  18

   T
      Transformation Applied (warn-text)  32

   V
      validator  16

   W
      Warning header field  29 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Mark Nottingham (editor)
   Akamai

   EMail: mnot@mnot.net
   URI:   &lt;a href=&quot;http://www.mnot.net/&quot;&gt;http://www.mnot.net/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding, et al.             Standards Track                   [Page 43]</source>
          <target state="translated">在下面收集的ABNF中，列表规则&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;根据[RFC7230]的1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;节&lt;/a&gt;进行了扩展。 Age = delta-seconds Cache-Control = *（&amp;ldquo;，&amp;rdquo; OWS）缓存指令*（OWS&amp;ldquo;，&amp;rdquo; [OWS缓存指令]）到期时间= HTTP日期HTTP日期= &amp;lt;HTTP日期，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231] ，第&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;7.1.1.1 &lt;/a&gt;节 &amp;gt; OWS = &amp;lt;OWS，请参见[RFC7230]，第3.2.3节 &amp;gt; Pragma = *（&amp;ldquo;，&amp;rdquo; OWS）语法指示*（OWS&amp;ldquo;，&amp;rdquo; [OWS pragma指示]）警告= *（ &amp;ldquo;，&amp;rdquo; OWS）警告值*（OWS&amp;ldquo;，&amp;rdquo; [OWS警告值]）缓存指令=令牌[&amp;ldquo; =&amp;rdquo;（令牌/引用字符串）]增量秒= 1 * DIGIT扩展-杂注=令牌[&amp;ldquo; =&amp;rdquo;（标记/带引号的字符串）] field-name = &amp;lt;field-name，参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]，第3.2节&lt;/a&gt; &amp;gt; port = &amp;lt;port，参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt; &amp;gt; pragma-directive =&amp;ldquo; no-cache&amp;rdquo; / extension-pragma假名= &amp;lt;假名，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]，第5.7.1节&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6&lt;/a&gt; &amp;gt;令牌= &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt; uri-host = &amp;lt;uri-host，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt;&amp;gt; warn-agent =（uri-host [&amp;ldquo;：&amp;rdquo;port]）/化名warn-code = 3DIGIT warn-date = DQUOTE HTTP date DQUOTE warn-text =带引号的字符串警告值=警告码SP warn-agent SP warn-text [SP warn-date]索引1110 （警告代码）31111（警告代码）31112（警告代码）31113（警告代码）31199（警告代码）32 2214（警告代码）32299（警告代码）32 A年龄11年龄标头字段21 C高速缓存4高速缓存条目5高速缓存键5-6高速缓存控制标头字段21 D断开连接的操作（警告文本）31 E使标头字段到期28显式到期时间11 F新鲜11新鲜度生存期11 G语法年龄21缓存控制22缓存指令22增量秒5到期28extension-pragma 29 Pragma 29 pragma-directive 29警告代理29警告代码29警告日期29警告文本29警告29警告值29 H启发式到期时间（警告文本）31启发式到期时间11 M max-age（高速缓存指令）22，最大失效26（高速缓存指令）22最小刷新（高速缓存指令）22其他持续警告（警告文字）32其他警告（警告文字）32必须重新验证（高速缓存指令）24 N无缓存（缓存指令）23、25不存储（缓存指令）23、24不转换（缓存指令）23，25 O仅当缓存时（缓存指令）23 P语法头字段29私有（缓存指令）25私有缓存4代理重新验证（缓存指令）26公开（缓存指令）25 R响应为陈旧（警告文本）30重新验证失败（警告文本）31 S s-maxage（缓存指令）27共享缓存4过时11强验证器18 T转换已应用（警告文本）32 V验证器16 W警告头字段29作者的地址Roy T. Fielding（编辑器）Adobe Systems Incorporated美国加利福尼亚州95110，圣何塞帕克大街345号电子邮件：fielding@gbiv.com URI：菲尔丁（编辑）Adobe系统公司345 Park Ave San Jose，CA 95110 USA电子邮件：fielding@gbiv.com URI：菲尔丁（编辑）Adobe系统公司345 Park Ave San Jose，CA 95110 USA电子邮件：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Mark Nottingham（编辑）Akamai电子邮件：mnot@mnot.net URI：&lt;a href=&quot;http://www.mnot.net/&quot;&gt;http&lt;/a&gt; ://www.mnot.net/ Julian F. Reschke（编辑）greenbytes GmbH Hafenweg 16 Muenster，NW 48155德国电子邮件：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding等。标准跟踪[页43]</target>
        </trans-unit>
        <trans-unit id="161932215fd5630ce654b9fd942cca7efbb170ac" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Age = delta-seconds

   Cache-Control = *( &quot;,&quot; OWS ) cache-directive *( OWS &quot;,&quot; [ OWS
    cache-directive ] )

   Expires = HTTP-date

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Pragma = *( &quot;,&quot; OWS ) pragma-directive *( OWS &quot;,&quot; [ OWS
    pragma-directive ] )

   Warning = *( &quot;,&quot; OWS ) warning-value *( OWS &quot;,&quot; [ OWS warning-value ]
    )

   cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   delta-seconds = 1*DIGIT

   extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   field-name = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;

   port = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   pragma-directive = &quot;no-cache&quot; / extension-pragma
   pseudonym = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;

   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   uri-host = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
   warn-code = 3DIGIT
   warn-date = DQUOTE HTTP-date DQUOTE
   warn-text = quoted-string
   warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date
    ] 

Index

   1
      110 (warn-code)  31
      111 (warn-code)  31
      112 (warn-code)  31
      113 (warn-code)  31
      199 (warn-code)  32

   2
      214 (warn-code)  32
      299 (warn-code)  32

   A
      age  11
      Age header field  21

   C
      cache  4
      cache entry  5
      cache key  5-6
      Cache-Control header field  21

   D
      Disconnected Operation (warn-text)  31

   E
      Expires header field  28
      explicit expiration time  11

   F
      fresh  11
      freshness lifetime  11

   G
      Grammar
         Age  21
         Cache-Control  22
         cache-directive  22
         delta-seconds  5
         Expires  28
         extension-pragma  29
         Pragma  29
         pragma-directive  29
         warn-agent  29
         warn-code  29
         warn-date  29
         warn-text  29 

         Warning  29
         warning-value  29

   H
      Heuristic Expiration (warn-text)  31
      heuristic expiration time  11
   M
      max-age (cache directive)  22, 26
      max-stale (cache directive)  22
      min-fresh (cache directive)  22
      Miscellaneous Persistent Warning (warn-text)  32
      Miscellaneous Warning (warn-text)  32
      must-revalidate (cache directive)  24

   N
      no-cache (cache directive)  23, 25
      no-store (cache directive)  23, 24
      no-transform (cache directive)  23, 25

   O
      only-if-cached (cache directive)  23

   P
      Pragma header field  29
      private (cache directive)  25
      private cache  4
      proxy-revalidate (cache directive)  26
      public (cache directive)  25

   R
      Response is Stale (warn-text)  30
      Revalidation Failed (warn-text)  31

   S
      s-maxage (cache directive)  27
      shared cache  4
      stale  11
      strong validator  18

   T
      Transformation Applied (warn-text)  32

   V
      validator  16

   W
      Warning header field  29 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Mark Nottingham (editor)
   Akamai

   EMail: mnot@mnot.net
   URI:   &lt;a href=&quot;https://www.mnot.net/&quot;&gt;http://www.mnot.net/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding, et al.             Standards Track                   [Page 43]</source>
          <target state="translated">在下面收集的ABNF中，列表规则&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;根据[RFC7230]的1.2&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;节&lt;/a&gt;进行了扩展。 Age = delta-seconds Cache-Control = *（&amp;ldquo;，&amp;rdquo; OWS）缓存指令*（OWS&amp;ldquo;，&amp;rdquo; [OWS缓存指令]）到期时间= HTTP日期HTTP日期= &amp;lt;HTTP日期，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231] ，第&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;7.1.1.1&lt;/a&gt;节&amp;gt; OWS = &amp;lt;OWS，请参见[RFC7230]，第3.2.3节&amp;gt; Pragma = *（&amp;ldquo;，&amp;rdquo; OWS）语法指示*（OWS&amp;ldquo;，&amp;rdquo; [OWS pragma指示]）警告= *（ &amp;ldquo;，&amp;rdquo; OWS）警告值*（OWS&amp;ldquo;，&amp;rdquo; [OWS警告值]）缓存指令=令牌[&amp;ldquo; =&amp;rdquo;（令牌/带引号的字符串）]增量秒= 1 * DIGIT扩展-杂注=令牌[&amp;ldquo; =&amp;rdquo;（令牌/带引号的字符串）] field-name = &amp;lt;field-name，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]，第3.2节&lt;/a&gt;&amp;gt;port = &amp;lt;port，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt;&amp;gt; pragma-directive =&amp;ldquo; no-cache&amp;rdquo; / extension-pragma化名= &amp;lt;假名，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]，第5.7.1节&lt;/a&gt;&amp;gt; quoted-string = &amp;lt;带引号的字符串，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt;&amp;gt; token = &amp;lt;令牌，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt;&amp;gt; uri-host = &amp;lt;uri-host，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]，第2.7节&lt;/a&gt;&amp;gt; warn-agent =（uri-host [&amp;ldquo;：&amp;rdquo;port]）/化名warn-code = 3DIGIT warn-date = DQUOTE HTTP date DQUOTE warn-text =带引号的字符串警告值= warn-code SP warn-agent SP warn-text [SP warn-date]索引1110 （警告代码）31111（警告代码）31112（警告代码）31113（警告代码）31199（警告代码）32 2214（警告代码）32299（警告代码）32 A年龄11年龄标头字段21 C高速缓存4高速缓存条目5高速缓存键5-6高速缓存控制标头字段21 D断开连接的操作（警告文本）31 E使标头字段到期28显式的到期时间11 F新鲜11新鲜度生存期11 G语法年龄21缓存控制22缓存指令22 delta-seconds 5到期28扩展指令pragma 29指令29 pragma指令29警告代理29警告代码29警告日期29警告文本29警告29警告值29 H启发式到期（警告文本）31启发式到期时间11 M max-age（缓存指令）22，26 max-stale（高速缓存指令）22 min-fresh（高速缓存指令）22其他持续警告（警告文本）32其他警告（警告文本）32必须重新验证（高速缓存指令）24 N无高速缓存（高速缓存指令） 23、25无存储（高速缓存指令）23、24无转换（高速缓存指令）23、25仅当高速缓存（高速缓存指令）23 P Pragma标头字段29专用（高速缓存指令）25专用高速缓存4代理-重新验证（缓存指令）26公共（缓存指令）25 R响应为陈旧（警告文本）30重新验证失败（警告文本）31 S s-maxage（缓存指令）27共享缓存4过时11强验证器18 T转换已应用（警告文本）32 V验证程序16 W警告标题字段29作者的地址Roy T. Fielding（编辑）Adobe Systems Incorporated 345 Park Ave San Jose，CA 95110美国电子邮件：fielding@gbiv.com URI：25 O仅当缓存时（缓存指令）23 P语法头字段29私有（缓存指令）25私有缓存4代理重新验证（缓存指令）26公开（缓存指令）25 R响应为陈旧（警告文本）30重新验证失败（警告文本）31 S s-maxage（缓存指令）27共享缓存4过时11强验证器18 T转换已应用（警告文本）32 V验证器16 W警告头字段29作者的地址Roy T. Fielding（编辑器）Adobe Systems Incorporated美国加利福尼亚州95110，圣何塞，帕克大街345号电子邮件：fielding@gbiv.com URI：25 O仅当缓存时（缓存指令）23 P语法头字段29私有（缓存指令）25私有缓存4代理重新验证（缓存指令）26公开（缓存指令）25 R响应为陈旧（警告文本）30重新验证失败（警告文本）31 S s-maxage（缓存指令）27共享缓存4过时11强验证器18 T转换已应用（警告文本）32 V验证器16 W警告头字段29作者的地址Roy T. Fielding（编辑器）Adobe Systems Incorporated美国加利福尼亚州95110，圣何塞，帕克大街345号电子邮件：fielding@gbiv.com URI：&lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Mark Nottingham（编辑）Akamai电子邮件：mnot@mnot.net URI：&lt;a href=&quot;https://www.mnot.net/&quot;&gt;http&lt;/a&gt; ://www.mnot.net/ Julian F. Reschke（编辑）greenbytes GmbH Hafenweg 16 Muenster，NW 48155德国电子邮件：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding等。标准跟踪[页43]</target>
        </trans-unit>
        <trans-unit id="847bccd23d1c7feafc0bf9bbe4823064cad9878a" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Authorization = credentials

   BWS = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Proxy-Authenticate = *( &quot;,&quot; OWS ) challenge *( OWS &quot;,&quot; [ OWS
    challenge ] )
   Proxy-Authorization = credentials

   WWW-Authenticate = *( &quot;,&quot; OWS ) challenge *( OWS &quot;,&quot; [ OWS challenge
    ] )

   auth-param = token BWS &quot;=&quot; BWS ( token / quoted-string )
   auth-scheme = token

   challenge = auth-scheme [ 1*SP ( token68 / [ ( &quot;,&quot; / auth-param ) *(
    OWS &quot;,&quot; [ OWS auth-param ] ) ] ) ]
   credentials = auth-scheme [ 1*SP ( token68 / [ ( &quot;,&quot; / auth-param )
    *( OWS &quot;,&quot; [ OWS auth-param ] ) ] ) ]

   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   token68 = 1*( ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; )
    *&quot;=&quot; 

Index

   4
      401 Unauthorized (status code)  6
      407 Proxy Authentication Required (status code)  6

   A
      Authorization header field  8

   C
      Canonical Root URI  5

   G
      Grammar
         auth-param  4
         auth-scheme  4
         Authorization  8
         challenge  4
         credentials  5
         Proxy-Authenticate  8
         Proxy-Authorization  9
         token68  4
         WWW-Authenticate  7

   P
      Protection Space  5
      Proxy-Authenticate header field  8
      Proxy-Authorization header field  9

   R
      Realm  5

   W
      WWW-Authenticate header field  7 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 19]</source>
          <target state="translated">在下面收集的ABNF中，列表规则&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;根据[RFC7230]的1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;节&lt;/a&gt;进行了扩展。授权=凭证BWS = &amp;lt;BWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt;&amp;gt;代理验证= *（&amp;ldquo;，&amp;rdquo; OWS）挑战*（OWS&amp;ldquo;，&amp;rdquo; [OWS挑战]）代理授权=凭据WWW-Authenticate = *（&amp;ldquo;，&amp;rdquo; OWS）挑战*（OWS&amp;ldquo;，&amp;rdquo; [OWS挑战]）auth-param =令牌BWS&amp;ldquo; =&amp;rdquo; BWS（令牌/带引号的字符串）auth-scheme =令牌质询= auth-scheme [1 * SP（token68 / [（&amp;ldquo;，&amp;rdquo; / auth-param）*（OWS&amp;ldquo; ，&amp;ldquo;&amp;rdquo; [OWS auth-param]）]））=认证方案[1 * SP（token68 / [（&amp;ldquo;，&amp;rdquo; / auth-param）*（OWS&amp;ldquo;，&amp;rdquo; [OWS auth-param]]]）]] quoted-string = &amp;lt;quoted-string，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt; &amp;gt;令牌= &amp;lt;token，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt;&amp;gt; token68 = 1 *（ALPHA / DIGIT /&amp;ldquo;-&amp;rdquo; /&amp;ldquo;。&amp;rdquo; /&amp;ldquo; _&amp;rdquo; /&amp;ldquo;〜&amp;rdquo; /&amp;ldquo; +&amp;rdquo; /&amp;ldquo; /&amp;rdquo;）*&amp;ldquo; =&amp;rdquo;索引4401未经授权（状态码）6407代理验证必填（状态码）6 A授权标头字段8 C规范根URI 5 G语法auth-param 4 auth-scheme 4授权8质询4凭证5代理验证8代理授权9 token68 4 WWW验证7 P保护空间5 Proxy-Authenticate标头字段8 Proxy-Authorization标头字段9 R领域5 W WWW-Authenticate标头字段7作者的地址RoyT。菲尔丁（编辑）Adobe系统公司345 Park Ave San Jose，CA 95110 USA电子邮件：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke（编辑）greenbytes GmbH Hafenweg 16 Muenster，NW 48155德国电子邮件：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding ＆Reschke标准跟踪[页19]</target>
        </trans-unit>
        <trans-unit id="feeba52d99d5a0008f5d811bd13452d39d2497a5" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   ETag = entity-tag

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   If-Match = &quot;*&quot; / ( *( &quot;,&quot; OWS ) entity-tag *( OWS &quot;,&quot; [ OWS
    entity-tag ] ) )
   If-Modified-Since = HTTP-date
   If-None-Match = &quot;*&quot; / ( *( &quot;,&quot; OWS ) entity-tag *( OWS &quot;,&quot; [ OWS
    entity-tag ] ) )
   If-Unmodified-Since = HTTP-date

   Last-Modified = HTTP-date

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   entity-tag = [ weak ] opaque-tag
   etagc = &quot;!&quot; / %x23-7E ; '#'-'~'
    / obs-text

   obs-text = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   opaque-tag = DQUOTE *etagc DQUOTE

   weak = %x57.2F ; W/ 

Index

   3
      304 Not Modified (status code)  19

   4
      412 Precondition Failed (status code)  18

   E
      ETag header field  9

   G
      Grammar
         entity-tag  9
         ETag  9
         etagc  9
         If-Match  13
         If-Modified-Since  15
         If-None-Match  14
         If-Unmodified-Since  17
         Last-Modified  7
         opaque-tag  9
         weak  9

   I
      If-Match header field  13
      If-Modified-Since header field  16
      If-None-Match header field  14
      If-Unmodified-Since header field  17

   L
      Last-Modified header field  7

   M
      metadata  5

   S
      selected representation  4

   V
      validator  5
         strong  5
         weak  5 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 28]</source>
          <target state="translated">在下面收集的ABNF中，列表规则&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;根据[RFC7230]的1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;节&lt;/a&gt;进行了扩展。 ETag =实体标签HTTP日期= &amp;lt;HTTP日期，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]，第7.1.1.1节&lt;/a&gt; &amp;gt; If-Match =&amp;ldquo; *&amp;rdquo; /（*（&amp;ldquo;，&amp;rdquo; OWS）实体标签*（OWS&amp;ldquo;，&amp;rdquo; [ OWS实体标签]））If-Modified-Since = HTTP-date If-None-Match =&amp;ldquo; *&amp;rdquo; /（*（&amp;ldquo;，&amp;rdquo; OWS）实体标签*（OWS&amp;ldquo;，&amp;rdquo; [OWS实体标签]） ）If-Unmodified-Since = HTTP日期Last-Modified = HTTP日期OWS = &amp;lt;OWS，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]，第3.2.3节&lt;/a&gt; &amp;gt; entity-tag = [弱] opaque-tag etagc =&amp;ldquo;！&amp;rdquo; /％x23-7E; '＃'-'〜'/ obs-text obs-text = &amp;lt;obs-text，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]，第3.2.6节&lt;/a&gt;&amp;gt;不透明标签= DQUOTE * etagc DQUOTE弱=％x57.2F; W /索引3304未修改（状态码）19 4 412前提条件失败（状态码）18 E ETag标头字段9 G语法实体标签9 ETag 9 etagc 9 If-Match 13 If-Modified-Since 15 If-None-匹配14 If-Unified-Since 17 17 Last-Modified 7不透明标签9弱9 I If-Match标头字段13 If-Modified-Since标头字段16 If-None-Match标头字段14 If-Unmodified-Since标头字段17 L最后修改的标头字段7 M元数据5 S选择的表示形式4 V验证器5强5弱5作者的地址RoyT。菲尔丁（编辑）Adobe系统公司345 Park Ave San Jose，CA 95110 USA电子邮件：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke（编辑）greenbytes GmbH Hafenweg 16 Muenster，NW 48155德国电子邮件：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding ＆Reschke标准跟踪[页28]</target>
        </trans-unit>
        <trans-unit id="472f98def3eac77e06a2358d336b65f3adb470f7" translate="yes" xml:space="preserve">
          <source>In the example above, line 3 creates an XML body to send with the &lt;code&gt;POST&lt;/code&gt; request in line 8. Also, on line 9, a &quot;customized&quot; (non-standard) HTTP request header is set (&lt;code&gt;X-PINGOTHER: pingpong&lt;/code&gt;). Such headers are not part of the HTTP/1.1 protocol, but are generally useful to web applications. Since the request uses a Content-Type of &lt;code&gt;application/xml&lt;/code&gt;, and since a custom header is set, this request is preflighted.</source>
          <target state="translated">在上面的示例中，第3行创建了一个XML正文，以与第8行中的 &lt;code&gt;POST&lt;/code&gt; 请求一起发送。此外，在第9行中，设置了&amp;ldquo;定制&amp;rdquo;（非标准）HTTP请求标头（ &lt;code&gt;X-PINGOTHER: pingpong&lt;/code&gt; ）。此类标头不是HTTP / 1.1协议的一部分，但通常对Web应用程序有用。由于该请求使用 &lt;code&gt;application/xml&lt;/code&gt; 的Content-Type ，并且由于设置了自定义标头，因此该请求被预检。</target>
        </trans-unit>
        <trans-unit id="09022b0e85e69204da784160f58571ee0eaec54e" translate="yes" xml:space="preserve">
          <source>In the example below a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; response code is used, because the response does not carry a payload body. A &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; response could have contained a payload body.</source>
          <target state="translated">在下面的示例中，使用了&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;响应代码，因为该响应不携带有效载荷主体。阿&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;响应可能包含的有效载荷的身体。</target>
        </trans-unit>
        <trans-unit id="90a33fcc28f73464c7c1ed80b477376d44e96863" translate="yes" xml:space="preserve">
          <source>In the first half of the 2010s, Google demonstrated an alternative way of exchanging data between client and server, by implementing an experimental protocol SPDY. This amassed interest from developers working on both browsers and servers. Defining an increase in responsiveness, and solving the problem of duplication of data transmitted, SPDY served as the foundations of the HTTP/2 protocol.</source>
          <target state="translated">在2010年上半年,谷歌通过实施实验性协议SPDY,展示了客户端和服务器之间交换数据的另一种方式。这引起了在浏览器和服务器上工作的开发人员的兴趣。SPDY定义了响应速度的提高,并解决了传输数据重复的问题,成为HTTP/2协议的基础。</target>
        </trans-unit>
        <trans-unit id="4f83336e929fe39e857341053bf53bb9d367a72d" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;max-age&lt;/code&gt; is set to 2 years, raised from what was a former limit &lt;code&gt;max-age&lt;/code&gt; of 1 year. Note that 1 year is acceptable for a domain to be included in browsers' HSTS preload lists. 2 years is, however, the recommended goal as a website's final HSTS configuration as explained on &lt;a href=&quot;https://hstspreload.org&quot;&gt;https://hstspreload.org&lt;/a&gt;. It also suffixed with &lt;code&gt;preload&lt;/code&gt; which is necessary for inclusion in most major web browsers' HSTS preload lists, e.g. Chromium, Edge, &amp;amp; Firefox.</source>
          <target state="translated">在下面的示例中， &lt;code&gt;max-age&lt;/code&gt; 设置为2年，从之前的 &lt;code&gt;max-age&lt;/code&gt; 上限提高到1年。请注意，将域包含在浏览器的HSTS预加载列表中可以接受1年。但是，建议的目标是2年，作为网站的最终HSTS配置，如&lt;a href=&quot;https://hstspreload.org&quot;&gt;https://hstspreload.org所述&lt;/a&gt;。它还带有 &lt;code&gt;preload&lt;/code&gt; ，这对于包含在大多数主流Web浏览器的HSTS预加载列表（例如Chromium，Edge和Firefox）中是必需的。</target>
        </trans-unit>
        <trans-unit id="20562e67671b5bf845611bfa4f3b14fd6e956c7a" translate="yes" xml:space="preserve">
          <source>In the past, specific plug-ins, add-ons or extensions added user agent parts to notify sites they were installed. The recommended way to do this, if it's absolutely necessary (remember that it slows down every request) is to &lt;a href=&quot;https://developer.mozilla.org/en/Setting_HTTP_request_headers&quot;&gt;set a custom HTTP header&lt;/a&gt;.</source>
          <target state="translated">过去，特定的插件，附加组件或扩展添加了用户代理部分，以通知站点它们已安装。如果绝对必要（建议这样做会减慢每个请求的速度），建议的方法是&lt;a href=&quot;https://developer.mozilla.org/en/Setting_HTTP_request_headers&quot;&gt;设置自定义HTTP标头&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="312bfeb98e09b0ebf786270e4655ffbe98874e6b" translate="yes" xml:space="preserve">
          <source>In the past, web content was able to access whatever &lt;code&gt;resource:&lt;/code&gt; URIs were desired &amp;mdash; not only Firefox&amp;rsquo;s internal resources, but also extensions&amp;rsquo; assets. Now this behavior is prohibited by default.</source>
          <target state="translated">过去，Web内容可以访问任何 &lt;code&gt;resource:&lt;/code&gt; URI &amp;mdash;不仅需要Firefox的内部资源，还需要扩展程序的资产。现在默认情况下将禁止这种行为。</target>
        </trans-unit>
        <trans-unit id="75008cbe2513d02694dbb1b988119207d90d0106" translate="yes" xml:space="preserve">
          <source>In the realm of internationalization, this specification complies
   with the IETF Character Set Policy [&lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC2277&lt;/a&gt;].  In this specification,
   human-readable fields can be found either in the value of a property,
   or in an error message returned in a response entity body.  In both
   cases, the human-readable content is encoded using XML, which has
   explicit provisions for character set tagging and encoding, and
   requires that XML processors read XML elements encoded, at minimum,
   using the UTF-8 [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] and UTF-16 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC2781&lt;/a&gt;] encodings of the ISO
   10646 multilingual plane.  XML examples in this specification
   demonstrate use of the charset parameter of the Content-Type header
   (defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]), as well as XML charset declarations.

   XML also provides a language tagging capability for specifying the
   language of the contents of a particular XML element.  The &quot;xml:lang&quot;
   attribute appears on an XML element to identify the language of its
   content and attributes.  See [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;] for definitions of values and
   scoping.

   WebDAV applications MUST support the character set tagging, character
   set encoding, and the language tagging functionality of the XML
   specification.  Implementors of WebDAV applications are strongly
   encouraged to read &quot;XML Media Types&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;] for instruction on
   which MIME media type to use for XML transport, and on use of the
   charset parameter of the Content-Type header.

   Names used within this specification fall into four categories: names
   of protocol elements such as methods and headers, names of XML
   elements, names of properties, and names of conditions.  Naming of
   protocol elements follows the precedent of HTTP, using English names
   encoded in US-ASCII for methods and headers.  Since these protocol
   elements are not visible to users, and are simply long token
   identifiers, they do not need to support multiple languages.
   Similarly, the names of XML elements used in this specification are
   not visible to the user and hence do not need to support multiple
   languages.

   WebDAV property names are qualified XML names (pairs of XML namespace
   name and local name).  Although some applications (e.g., a generic
   property viewer) will display property names directly to their users,
   it is expected that the typical application will use a fixed set of
   properties, and will provide a mapping from the property name and
   namespace to a human-readable field when displaying the property name 

   to a user.  It is only in the case where the set of properties is not
   known ahead of time that an application need display a property name
   to a user.  We recommend that applications provide human-readable
   property names wherever feasible.

   For error reporting, we follow the convention of HTTP/1.1 status
   codes, including with each status code a short, English description
   of the code (e.g., 423 (Locked)).  While the possibility exists that
   a poorly crafted user agent would display this message to a user,
   internationalized applications will ignore this message, and display
   an appropriate message in the user's language and character set.

   Since interoperation of clients and servers does not require locale
   information, this specification does not specify any mechanism for
   transmission of this information.</source>
          <target state="translated">在国际化领域，此规范符合IETF字符集策略[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC2277&lt;/a&gt; ]。在本规范中，可以在属性的值中或在响应实体主体中返回的错误消息中找到人类可读的字段。在这两种情况下，人类可读的内容都是使用XML编码的，其中对字符集标记和编码有明确的规定，并且要求XM​​L处理器至少读取使用UTF-8 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt; ]和UTF-16 编码的XML元素。ISO 10646多语言平面的[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC2781&lt;/a&gt; ]编码。本规范中的XML示例演示了Content-Type标头（在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023中&lt;/a&gt;定义]），以及XML字符集声明。 XML还提供了用于指定特定XML元素内容的语言的语言标记功能。 &amp;ldquo; xml：lang&amp;rdquo;属性出现在XML元素上，以标识其内容和属性的语言。有关值和作用域的定义，请参见[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]。 WebDAV应用程序必须支持XML规范的字符集标记，字符集编码和语言标记功能。强烈建议WebDAV应用程序的实现者阅读&amp;ldquo; XML媒体类型&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;有关使用哪种MIME媒体类型进行XML传输以及使用Content-Type标头的charset参数的说明。本规范中使用的名称分为四类：协议元素的名称（例如方法和标头），XML元素的名称，属性的名称以及条件的名称。协议元素的命名遵循HTTP的先例，对方法和标头使用以US-ASCII编码的英文名称。由于这些协议元素对用户不可见，并且仅仅是长令牌标识符，因此它们不需要支持多种语言。类似地，该规范中使用的XML元素的名称对用户不可见，因此不需要支持多种语言。WebDAV属性名称是合格的XML名称（XML名称空间名称和本地名称的对）。尽管某些应用程序（例如，通用属性查看器）将直接向其用户显示属性名称，但可以预期的是，典型应用程序将使用一组固定的属性，并将提供从属性名称和名称空间到人为的映射。向用户显示属性名称时的可读字段。仅在事先不知道属性集的情况下，应用程序才需要向用户显示属性名称。我们建议应用程序在可行的情况下提供易于理解的属性名称。对于错误报告，我们遵循HTTP / 1.1状态代码的约定，包括每个状态代码的简短英文说明（例如423（锁定））。尽管存在设计不当的用户代理可能向用户显示此消息的可能性，但是国际化的应用程序将忽略此消息，并以用户的语言和字符集显示适当的消息。由于客户端和服务器的互操作不需要语言环境信息，因此本规范未指定用于传输此信息的任何机制。</target>
        </trans-unit>
        <trans-unit id="0c7caf7be6ba6f74cd1c7e69b2965145b991a7b6" translate="yes" xml:space="preserve">
          <source>In these examples, the entire reporting API payload is shown. The top-level &lt;code&gt;&quot;body&quot;&lt;/code&gt; key contains the network error report.</source>
          <target state="translated">在这些示例中，显示了整个报告API有效负载。顶级 &lt;code&gt;&quot;body&quot;&lt;/code&gt; 键包含网络错误报告。</target>
        </trans-unit>
        <trans-unit id="08819ce444413d248ed409d1bf3d59a094d39073" translate="yes" xml:space="preserve">
          <source>In this article, we focus on resource URIs, which are used internally by Firefox to point to built-in resources.</source>
          <target state="translated">在本文中,我们将重点关注资源URI,它是Firefox内部用来指向内置资源的。</target>
        </trans-unit>
        <trans-unit id="4a9daa27d7ffde10bb20032aa2c669c7114837b2" translate="yes" xml:space="preserve">
          <source>In this case look for a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; header. If this header is present, then the cache's freshness lifetime is equal to the value of the &lt;code&gt;Date&lt;/code&gt; header minus the value of the &lt;code&gt;Last-modified&lt;/code&gt; header divided by 10. The expiration time is computed as follows:</source>
          <target state="translated">在这种情况下，请查找&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;标头。如果存在此标头，则高速缓存的新鲜度生存期等于 &lt;code&gt;Date&lt;/code&gt; 标头的值减去 &lt;code&gt;Last-modified&lt;/code&gt; 标头的值除以10。到期时间的计算如下：</target>
        </trans-unit>
        <trans-unit id="0238c032fe8b075e22eb8b6c9fa8e03afd0be1e7" translate="yes" xml:space="preserve">
          <source>In this case, responses can be sent back based on some considerations.</source>
          <target state="translated">在这种情况下,可以基于一些考虑将回复发回。</target>
        </trans-unit>
        <trans-unit id="9c09df89aeef1f40e2d786af81ae2b5377bc9307" translate="yes" xml:space="preserve">
          <source>In this case, the server can send back a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) response for a URL that will contain the right information. If the reload button is pressed, only that page is redisplayed, without replaying the unsafe requests.</source>
          <target state="translated">在这种情况下，服务器可以针对包含正确信息的URL发送&lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（请参阅其他）响应。如果按下重新加载按钮，则仅重新显示该页面，而不重播不安全的请求。</target>
        </trans-unit>
        <trans-unit id="06b277eb0332b7d0f528bc488b7a6ac8fc32ac6b" translate="yes" xml:space="preserve">
          <source>In this case, the server can send back a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) response that will contain the right information, but if the reload button is pressed, only this page is redisplayed, without replaying the unsafe requests.</source>
          <target state="translated">在这种情况下，服务器可以发回包含正确信息的&lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（请参阅其他）响应，但是如果按下重新加载按钮，则仅重新显示此页面，而不会重放不安全的请求。</target>
        </trans-unit>
        <trans-unit id="18d9fe67ef95cf5048b92cb9c02dafef0b4ac177" translate="yes" xml:space="preserve">
          <source>In this case, you need to configure the server receiving the HTTP requests (which is most likely the same for www and non-www URLs) to respond with an adequate HTTP &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; response to any request to the non-canonical domain. This will redirect the browser trying to access the non-canonical URLs to their canonical equivalent. For example, if you've chosen to use non-www URLs as the canonical type, you should redirect all www URLs to their equivalent URL without the www.</source>
          <target state="translated">在这种情况下，您需要将接收HTTP请求的服务器（对于www和非www URL而言，最有可能是相同的）配置为使用适当的HTTP &lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;响应来响应对非规范域的任何请求。这会将尝试访问非规范URL的浏览器重定向到它们的规范等同名称。例如，如果您选择使用非www URL作为规范类型，则应将所有www URL重定向到它们的等效URL，而不包含www。</target>
        </trans-unit>
        <trans-unit id="7847050425f6d076cc4ad765d4143b2fe451ad2c" translate="yes" xml:space="preserve">
          <source>In this example all of the hosts in a given subnet are connected-to directly, others are connected through the proxy:</source>
          <target state="translated">在这个例子中,给定子网中的所有主机都是直接连接到的,其他主机是通过代理连接的。</target>
        </trans-unit>
        <trans-unit id="463b3c56a942948bf5001ffa290aad288ddfa0e2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. &lt;strong&gt;max-age=5184000&lt;/strong&gt; tells the client to store this information for two months, which is a reasonable time limit according to the IETF RFC. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.net/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">在此示例中，&lt;strong&gt;pin-sha256 =&amp;ldquo; cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&amp;rdquo;锁定&lt;/strong&gt;在生产中使用的服务器公钥。第二个引脚声明&lt;strong&gt;pin-sha256 =&amp;ldquo; M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&amp;rdquo;&lt;/strong&gt;也会&lt;strong&gt;锁定&lt;/strong&gt;备份密钥。&lt;strong&gt;max-age = 5184000&lt;/strong&gt;告诉客户端将这些信息存储两个月，根据IETF RFC，这是一个合理的时限。此键固定对所有子域均有效，这由&lt;strong&gt;includeSubDomains&lt;/strong&gt;声明告知。最后，&lt;strong&gt;report-uri =&amp;ldquo; https://www.example.net/hpkp-report&amp;rdquo;&lt;/strong&gt;解释了在何处报告引脚验证失败。</target>
        </trans-unit>
        <trans-unit id="15fe4fb824d6da70afb6414abaf5dbbc417ed391" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. &lt;strong&gt;max-age=5184000&lt;/strong&gt; tells the client to store this information for two months, which is a reasonable time limit according to the IETF RFC. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">在此示例中，&lt;strong&gt;pin-sha256 =&amp;ldquo; cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&amp;rdquo;锁定&lt;/strong&gt;在生产中使用的服务器公钥。第二个引脚声明&lt;strong&gt;pin-sha256 =&amp;ldquo; M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&amp;rdquo;&lt;/strong&gt;也会&lt;strong&gt;锁定&lt;/strong&gt;备份密钥。&lt;strong&gt;max-age = 5184000&lt;/strong&gt;告诉客户端将这些信息存储两个月，根据IETF RFC，这是一个合理的时限。此键固定对所有子域均有效，这由&lt;strong&gt;includeSubDomains&lt;/strong&gt;声明告知。最后，&lt;strong&gt;report-uri =&amp;ldquo; https://www.example.org/hpkp-report&amp;rdquo;&lt;/strong&gt;解释了在何处报告引脚验证失败。</target>
        </trans-unit>
        <trans-unit id="7b4d6bd9abca71a4536572bc7fcac564f95ec372" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">在此示例中，&lt;strong&gt;pin-sha256 =&amp;ldquo; cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&amp;rdquo;锁定&lt;/strong&gt;在生产中使用的服务器公钥。第二个引脚声明&lt;strong&gt;pin-sha256 =&amp;ldquo; M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&amp;rdquo;&lt;/strong&gt;也会&lt;strong&gt;锁定&lt;/strong&gt;备份密钥。此键固定对所有子域均有效，这由&lt;strong&gt;includeSubDomains&lt;/strong&gt;声明告知。最后，&lt;strong&gt;report-uri =&amp;ldquo; https://www.example.org/hpkp-report&amp;rdquo;&lt;/strong&gt;解释了在何处报告引脚验证失败。</target>
        </trans-unit>
        <trans-unit id="26e35d19a2c9f9c005f9c384d2fca94ef727d3c6" translate="yes" xml:space="preserve">
          <source>In this example, content originally loaded from &lt;code&gt;http://foo.example&lt;/code&gt; makes a simple GET request to a resource on &lt;code&gt;http://bar.other&lt;/code&gt; which sets Cookies. Content on foo.example might contain JavaScript like this:</source>
          <target state="translated">在此示例中，最初从 &lt;code&gt;http://foo.example&lt;/code&gt; 加载的内容对设置了Cookies的 &lt;code&gt;http://bar.other&lt;/code&gt; 上的资源进行了简单的GET请求。foo.example上的内容可能包含这样的JavaScript：</target>
        </trans-unit>
        <trans-unit id="1bad895874eb650b248a44ce79a14ea76d8467d2" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;a href=&quot;expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is used at the end of the chunked message and serves as a trailing header.</source>
          <target state="translated">在此示例中，&lt;a href=&quot;expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;标头用于分块消息的末尾，并用作尾标头。</target>
        </trans-unit>
        <trans-unit id="d3619c052570e6c7b13df3247db7eb34508081c2" translate="yes" xml:space="preserve">
          <source>In this example, the domain name &quot;&lt;a href=&quot;http://www.spreadfirefox.com&quot;&gt;www.spreadfirefox.com&lt;/a&gt;&quot; will be pre-resolved.</source>
          <target state="translated">在此示例中，域名&amp;ldquo; &lt;a href=&quot;http://www.spreadfirefox.com&quot;&gt;www.spreadfirefox.com&lt;/a&gt; &amp;rdquo;将被预先解析。</target>
        </trans-unit>
        <trans-unit id="87dc9881299868d18d5f581592c04cfda6647192" translate="yes" xml:space="preserve">
          <source>In this example, the domain name &quot;&lt;a href=&quot;https://www.mozilla.org/contribute/&quot;&gt;www.mozilla.org/contribute&lt;/a&gt;&quot; will be pre-resolved.</source>
          <target state="translated">在此示例中，域名&amp;ldquo; &lt;a href=&quot;https://www.mozilla.org/contribute/&quot;&gt;www.mozilla.org/contribute&lt;/a&gt; &amp;rdquo;将被预先解析。</target>
        </trans-unit>
        <trans-unit id="f69eca7e9cf725cc07d70aadad7696549a869cd3" translate="yes" xml:space="preserve">
          <source>In this example, the user agent string is mobile Safari&amp;rsquo;s version. It contains the word &lt;code&gt;&quot;Mobile&quot;&lt;/code&gt;.</source>
          <target state="translated">在此示例中，用户代理字符串是移动Safari的版本。它包含单词 &lt;code&gt;&quot;Mobile&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ece92baae1897d8ad92e5e7a0a62d4670b062563" translate="yes" xml:space="preserve">
          <source>In this example, the user agent string is mobile safari version. It contains the word &quot;Mobile&quot;.</source>
          <target state="translated">在这个例子中,用户代理字符串是移动Safari版本。它包含 &quot;Mobile &quot;一词。</target>
        </trans-unit>
        <trans-unit id="bb7d3fc0025e51622cf41c74720e5e287c75d33c" translate="yes" xml:space="preserve">
          <source>In this response, &lt;code&gt;Accept-Ranges: bytes&lt;/code&gt; indicates that bytes can be used as unit to define a range. Here the &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header is also useful as it indicates the full size of the image to retrieve.</source>
          <target state="translated">在此响应中， &lt;code&gt;Accept-Ranges: bytes&lt;/code&gt; 表示字节可以用作定义范围的单位。这里的&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;标头也很有用，因为它指示要检索的图像的完整大小。</target>
        </trans-unit>
        <trans-unit id="795b5c095ca34b9eb4357638cfdaae755baa1753" translate="yes" xml:space="preserve">
          <source>In this section, the final line of each section gives the element
   type declaration using the format defined in [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  The &quot;Value&quot;
   field, where present, specifies further restrictions on the allowable
   contents of the XML element using BNF (i.e., to further restrict the
   values of a PCDATA element).  Note that all of the elements defined
   here may be extended according to the rules defined in &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;.
   All elements defined here are in the &quot;DAV:&quot; namespace.</source>
          <target state="translated">在本节中，每节的最后一行使用[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]中定义的格式给出元素类型声明。&amp;ldquo;值&amp;rdquo;字段（如果存在）使用BNF指定对XML元素的允许内容的进一步限制（即，进一步限制PCDATA元素的值）。注意，这里定义的所有元素都可以根据&lt;a href=&quot;#section-17&quot;&gt;第17节中&lt;/a&gt;定义的规则进行扩展。此处定义的所有元素都在&amp;ldquo; DAV：&amp;rdquo;命名空间中。</target>
        </trans-unit>
        <trans-unit id="179432a2d14c1874e18b6638eed524eeb5842b02" translate="yes" xml:space="preserve">
          <source>Included in the response message from the server during the opening handshake process when the server is willing to initiate a WebSocket connection. It will appear no more than once in the response headers.</source>
          <target state="translated">当服务器愿意发起 WebSocket 连接时,在打开握手过程中服务器的响应消息中包含。它在响应头中出现的次数不会超过一次。</target>
        </trans-unit>
        <trans-unit id="9cab054870dbf49daaae3aee35de09e7abf09a42" translate="yes" xml:space="preserve">
          <source>Incomplete results: a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt; (Partial Content) response.</source>
          <target state="translated">结果不完整：响应为&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt;（部分内容）。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="522b16bedc865c8cbd64e7b9adb9223fbc62cbb9" translate="yes" xml:space="preserve">
          <source>IndexedDB (for each database execute &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase&quot;&gt;&lt;code&gt;IDBFactory.deleteDatabase&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IndexedDB（对每个数据库执行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase&quot;&gt; &lt;code&gt;IDBFactory.deleteDatabase&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="77a0f0c640c4020f67d5dbd8adc3745275738665" translate="yes" xml:space="preserve">
          <source>Indicates a URL path that must exist in the requested resource before sending the Cookie header. The %x2F (&quot;/&quot;) character is interpreted as a directory separator and sub directories will be matched as well (e.g. path=/docs, &quot;/docs&quot;, &quot;/docs/Web/&quot;, or &quot;/docs/Web/HTTP&quot; will all be matched).</source>
          <target state="translated">表示在发送Cookie头之前,请求的资源中必须存在的URL路径。%x2F (&quot;/&quot;)字符被解释为目录分隔符,子目录也将被匹配(例如,path=/docs、&quot;/docs&quot;、&quot;/docs/Web/&quot;或&quot;/docs/Web/HTTP &quot;都将被匹配)。</target>
        </trans-unit>
        <trans-unit id="2cd7bebabc246b7398c2557d2f27d3f5dfbfc228" translate="yes" xml:space="preserve">
          <source>Indicates an alternate location for the returned data.</source>
          <target state="translated">表示返回数据的备用位置。</target>
        </trans-unit>
        <trans-unit id="9bf3af3031e2a167d607e233517fe07840ad0ce2" translate="yes" xml:space="preserve">
          <source>Indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">表示为了正确处理请求,服务器需要满足的期望。</target>
        </trans-unit>
        <trans-unit id="c20b7c7e190c02dcd980a59596037eefb0d9d410" translate="yes" xml:space="preserve">
          <source>Indicates expectations that need to be fulfilled by the server to properly handle the request.</source>
          <target state="translated">表示服务器需要满足的期望,以正确处理该请求。</target>
        </trans-unit>
        <trans-unit id="552935b2453887e59cf2e4f3e94e2e9ac12d93ef" translate="yes" xml:space="preserve">
          <source>Indicates how long the results of a preflight request can be cached.</source>
          <target state="translated">表示飞行前请求的结果可以被缓存多长时间。</target>
        </trans-unit>
        <trans-unit id="7c9b44d689ef4104318af0511c11748dc3967c95" translate="yes" xml:space="preserve">
          <source>Indicates how long the user agent should wait before making a follow-up request.</source>
          <target state="translated">表示用户代理在提出后续请求前应等待多长时间。</target>
        </trans-unit>
        <trans-unit id="f6191c2fea1dc7665f3e010c435506f712c18963" translate="yes" xml:space="preserve">
          <source>Indicates if the resource transmitted should be displayed inline (default behavior without the header), or if it should be handled like a download and the browser should present a &amp;ldquo;Save As&amp;rdquo; dialog.</source>
          <target state="translated">指示传输的资源是应该内联显示（不带标题的默认行为），还是应该像下载一样进行处理，浏览器应显示&amp;ldquo;另存为&amp;rdquo;对话框。</target>
        </trans-unit>
        <trans-unit id="ad3a4c007f7db3dfac95c3ba5f703c8f8dd59961" translate="yes" xml:space="preserve">
          <source>Indicates if the server supports range requests and if so, in which unit the range can be expressed.</source>
          <target state="translated">表示服务器是否支持范围请求,如果支持,可以用哪个单位表示范围。</target>
        </trans-unit>
        <trans-unit id="46923176567e6f9182bcf4bbdd4ca07d5b57ade9" translate="yes" xml:space="preserve">
          <source>Indicates if the server supports range requests, and if so in which unit the range can be expressed.</source>
          <target state="translated">表示服务器是否支持范围请求,如果支持,范围可以用哪个单位表示。</target>
        </trans-unit>
        <trans-unit id="3430ae2cd395b1c94c2f79f53999b8989357367e" translate="yes" xml:space="preserve">
          <source>Indicates that either the client or the server would like to close the connection. This is the default on HTTP/1.0 requests.</source>
          <target state="translated">表示客户端或服务器要关闭连接。这是HTTP/1.0请求的默认值。</target>
        </trans-unit>
        <trans-unit id="e484e47b9ff40bcaf3bfce679a53ef13604e1c95" translate="yes" xml:space="preserve">
          <source>Indicates that once a resource becomes stale, caches must not use their stale copy without successful &lt;a href=&quot;../caching#Cache_validation&quot;&gt;validation&lt;/a&gt; on the origin server.</source>
          <target state="translated">表示一旦资源过时，缓存就必须在原始服务器上未成功&lt;a href=&quot;../caching#Cache_validation&quot;&gt;验证的&lt;/a&gt;情况下才使用其过时的副本。</target>
        </trans-unit>
        <trans-unit id="c99b1484ee170cc3fd51d8eb0f92ba2eff8fc73e" translate="yes" xml:space="preserve">
          <source>Indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application.</source>
          <target state="translated">表示浏览器(Internet Explorer)不应显示 &quot;打开 &quot;从应用程序下载的文件的选项,以防止钓鱼攻击,否则该文件将在应用程序的上下文中获得执行权限。</target>
        </trans-unit>
        <trans-unit id="c4f79f8a6a3c8718f3618cea1550c9060b2c9c67" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a response that has exceeded its expiration time. Optionally, you can assign a value in seconds, indicating the time the response must not be expired by.</source>
          <target state="translated">表示客户端愿意接受已经超过过期时间的响应。也可以指定一个以秒为单位的值,表示响应过期的时间。</target>
        </trans-unit>
        <trans-unit id="06f0d192853b0ab8b3406d2dd070fa47ec20ae34" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a stale response if the check for a fresh one fails. The seconds value indicates for how long the client is willing to accept the stale response after the initial expiration.</source>
          <target state="translated">表示如果检查新的响应失败,客户端愿意接受陈旧的响应。秒的值表示客户机愿意在初始过期后多长时间内接受陈旧的响应。</target>
        </trans-unit>
        <trans-unit id="deaef90dde647ea30a46f347a0d9e248199a5f91" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a stale response while asynchronously checking in the background for a fresh one. The seconds value indicates for how long the client is willing to accept a stale response.</source>
          <target state="translated">表示客户端愿意接受一个陈旧的响应,同时在后台异步检查一个新鲜的响应。秒的值表示客户端愿意接受陈旧响应的时间。</target>
        </trans-unit>
        <trans-unit id="33fbfac7a3753ad2fc4a262b8c0b818d20d43473" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept trailer fields in a chunked transfer coding.</source>
          <target state="translated">表示客户端愿意接受分块传输编码中的拖车字段。</target>
        </trans-unit>
        <trans-unit id="a44c16e62480d86b3a9b9458e2ea45fed4f4e530" translate="yes" xml:space="preserve">
          <source>Indicates that the client wants a response that will still be fresh for at least the specified number of seconds.</source>
          <target state="translated">表示客户端希望响应至少在指定的秒数内仍然是新鲜的。</target>
        </trans-unit>
        <trans-unit id="b642df972d92ffd9369fe8f647cb5c9e563d0505" translate="yes" xml:space="preserve">
          <source>Indicates that the client would like to keep the connection open. Having a persistent connection is the default on HTTP/1.1 requests. The list of headers are the name of the header to be removed by the first non-transparent proxy or cache in-between: these headers define the connection between the emitter and the first entity, not the destination node.</source>
          <target state="translated">表示客户端希望保持连接的开放性。在HTTP/1.1请求中,拥有一个持久连接是默认的。头文件列表是中间第一个非透明代理或缓存要删除的头文件的名称:这些头文件定义了发射者和第一个实体之间的连接,而不是目的节点。</target>
        </trans-unit>
        <trans-unit id="f97447000dd6a21db07563d6ef729be734f5e4a3" translate="yes" xml:space="preserve">
          <source>Indicates that the request has been conveyed in early data.</source>
          <target state="translated">表示请求已在早期数据中传达。</target>
        </trans-unit>
        <trans-unit id="0f74606c348d1fa1dbb5218dbab55ec440f2a48f" translate="yes" xml:space="preserve">
          <source>Indicates that the response body &lt;strong&gt;will not change&lt;/strong&gt; over time. The resource, if &lt;em&gt;unexpired&lt;/em&gt;, is unchanged on the server and therefore the client should not send a conditional revalidation for it (e.g. &lt;code&gt;If-None-Match&lt;/code&gt; or &lt;code&gt;If-Modified-Since&lt;/code&gt;) to check for updates, even when the user explicitly refreshes the page. Clients that aren't aware of this extension must ignore them as per the HTTP specification. In Firefox, &lt;code&gt;immutable&lt;/code&gt; is only honored on &lt;code&gt;https://&lt;/code&gt; transactions. For more information, see also this &lt;a href=&quot;https://bitsup.blogspot.de/2016/05/cache-control-immutable.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">指示响应主体&lt;strong&gt;将不会&lt;/strong&gt;随时间&lt;strong&gt;变化&lt;/strong&gt;。该资源（如果&lt;em&gt;未过期&lt;/em&gt;）在服务器上不变，因此，即使用户明确刷新页面，客户端也不应为其发送条件重新验证（例如 &lt;code&gt;If-None-Match&lt;/code&gt; 或 &lt;code&gt;If-Modified-Since&lt;/code&gt; ）以检查更新。 。根据HTTP规范，不知道此扩展的客户端必须忽略它们。在Firefox中， &lt;code&gt;immutable&lt;/code&gt; 仅适用于 &lt;code&gt;https://&lt;/code&gt; 事务。有关更多信息，另请参阅此&lt;a href=&quot;https://bitsup.blogspot.de/2016/05/cache-control-immutable.html&quot;&gt;博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5955a042968bb418bc770fb1ac84f6a1e3b04e52" translate="yes" xml:space="preserve">
          <source>Indicates that the response body will not change over time. The resource, if unexpired, is unchanged on the server and therefore the client should not send a conditional revalidation for it (e.g. &lt;code&gt;If-None-Match&lt;/code&gt; or &lt;code&gt;If-Modified-Since&lt;/code&gt;) to check for updates, even when the user explicitly refreshes the page. Clients that aren't aware of this extension must ignore them as per the HTTP specification. In Firefox, &lt;code&gt;immutable&lt;/code&gt; is only honored on &lt;code&gt;https://&lt;/code&gt; transactions. For more information, see also this &lt;a href=&quot;http://bitsup.blogspot.de/2016/05/cache-control-immutable.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">表示响应主体不会随时间变化。该资源（如果未过期）在服务器上不变，因此，即使用户显式刷新页面，客户端也不应为其发送条件重新验证（例如 &lt;code&gt;If-None-Match&lt;/code&gt; 或 &lt;code&gt;If-Modified-Since&lt;/code&gt; ）以检查更新。 。根据HTTP规范，不知道此扩展的客户端必须忽略它们。在Firefox中， &lt;code&gt;immutable&lt;/code&gt; 仅适用于 &lt;code&gt;https://&lt;/code&gt; 事务。有关更多信息，另请参见此&lt;a href=&quot;http://bitsup.blogspot.de/2016/05/cache-control-immutable.html&quot;&gt;博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d6f6e0f4b09d76d1dc1ccd2d2b141f2a442a1d2" translate="yes" xml:space="preserve">
          <source>Indicates that the response is intended for a single user and must not be stored by a shared cache. A private cache may store the response.</source>
          <target state="translated">表示响应是为单个用户准备的,不能由共享缓存存储。私人缓存可以存储响应。</target>
        </trans-unit>
        <trans-unit id="619c7b97c107a9d7b9f0f9a1bf6f8d31f3066053" translate="yes" xml:space="preserve">
          <source>Indicates that the response may be cached by any cache.</source>
          <target state="translated">表示响应可以被任何缓存。</target>
        </trans-unit>
        <trans-unit id="0a024414359139c546eb2b06d1c63cbb97a90599" translate="yes" xml:space="preserve">
          <source>Indicates that the server is unwilling to risk processing a request that might be replayed.</source>
          <target state="translated">表示服务器不愿意冒险处理可能被重播的请求。</target>
        </trans-unit>
        <trans-unit id="1764f0a2dc1d82d92287ff0957396522996daa3d" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to clear all types of data for the origin of the response. If more data types are added in future versions of this header, they will also be covered by it.</source>
          <target state="translated">表示服务器希望清除响应源的所有类型的数据。如果在这个头的未来版本中增加了更多的数据类型,它们也将被包括在内。</target>
        </trans-unit>
        <trans-unit id="d0874c17bb0051bdad46f81276a7a676b678ee89" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to reload all browsing contexts for the origin of the response (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Location/reload&quot;&gt;&lt;code&gt;Location.reload&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">指示服务器希望重新加载所有浏览上下文作为响应的来源（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Location/reload&quot;&gt; &lt;code&gt;Location.reload&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cc5b7853c11f1c815426aacf326e6a5f1048b0f0" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove all DOM storage for the origin of the response URL. This includes storage mechanisms such as:</source>
          <target state="translated">表示服务器希望删除响应URL的所有DOM存储。这包括存储机制,例如:</target>
        </trans-unit>
        <trans-unit id="ef7e1742a157a2de2bf388f99e235ed9711fd524" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove all cookies for the origin of the response URL. HTTP authentication credentials are also cleared out. This affects the entire registered domain, including subdomains. So https://example.com as well as https://stage.example.com, will have cookies cleared.</source>
          <target state="translated">表示服务器希望删除响应URL原点的所有Cookie。HTTP认证凭证也会被清除。这将影响整个注册域名,包括子域名。所以https://example.com 以及 https://stage.example.com,都会被清除cookie。</target>
        </trans-unit>
        <trans-unit id="ac63007b3c6f50bd4fa2b0ef581a82efee07a128" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove locally cached data (i.e. the browser cache, see &lt;a href=&quot;../caching&quot;&gt;HTTP caching&lt;/a&gt;) for the origin of the response URL. Depending on the browser, this might also clear out things like pre-rendered pages, script caches, WebGL shader caches, or address bar suggestions.</source>
          <target state="translated">指示服务器希望删除本地URL 缓存的数据（例如，浏览器缓存，请参阅&lt;a href=&quot;../caching&quot;&gt;HTTP caching&lt;/a&gt;）作为响应URL的来源。根据浏览器的不同，这可能还会清除诸如预渲染页面，脚本缓存，WebGL着色器缓存或地址栏建议之类的内容。</target>
        </trans-unit>
        <trans-unit id="cf528554c916e8834415e263fe337623229bfac2" translate="yes" xml:space="preserve">
          <source>Indicates the URL to redirect a page to.</source>
          <target state="translated">表示要重定向页面的URL。</target>
        </trans-unit>
        <trans-unit id="c8fbcc1100e604b3e848463d05946c3ca0c4fdb5" translate="yes" xml:space="preserve">
          <source>Indicates the approximate amount of device RAM. This value is an approximation given by rounding to the nearest power of 2 and dividing that number by 1024. For example, 512 megabytes will be reported as &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">指示设备RAM的大概数量。该值是一个近似值，取整为最接近的2的幂，然后将该数字除以1024。例如，将报告512兆字节为 &lt;code&gt;0.5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae0c2dd829c8b5d8d4e242e3869d139f81ef6d4f" translate="yes" xml:space="preserve">
          <source>Indicates the client wants a response that will still be fresh for &lt;em&gt;at least&lt;/em&gt; the specified number of seconds.</source>
          <target state="translated">表示客户端希望响应&lt;em&gt;至少&lt;/em&gt;在指定的秒数内仍然有效。</target>
        </trans-unit>
        <trans-unit id="e3b0306391348f832a38528343b5bbe9c4441f9b" translate="yes" xml:space="preserve">
          <source>Indicates the client will accept a stale response if the check for a fresh one fails. The &lt;em&gt;seconds&lt;/em&gt; value indicates how long the client will accept the stale response after the initial expiration.</source>
          <target state="translated">指示如果对新请求的检查失败，则客户端将接受陈旧的响应。的&lt;em&gt;秒&lt;/em&gt;值表明客户机将多久接受初始期满后陈旧的响应。</target>
        </trans-unit>
        <trans-unit id="6a3143e8d1d08e6bc3f0bc2cf897fbeba771a630" translate="yes" xml:space="preserve">
          <source>Indicates the client will accept a stale response, while asynchronously checking in the background for a fresh one. The &lt;em&gt;seconds&lt;/em&gt; value indicates how long the client will accept a stale response. See &quot;&lt;a href=&quot;https://web.dev/stale-while-revalidate&quot;&gt;Keeping things fresh with &lt;code&gt;stale-while-revalidate&lt;/code&gt;&lt;/a&gt;&quot; for more information.</source>
          <target state="translated">表示客户端将接受陈旧的响应，同时在后台异步检查是否有新的响应。该&lt;em&gt;秒&lt;/em&gt;值指示客户机将多久接受一个陈旧的响应。有关更多信息，请参见&amp;ldquo;&lt;a href=&quot;https://web.dev/stale-while-revalidate&quot;&gt;使用 &lt;code&gt;stale-while-revalidate&lt;/code&gt; &lt;/a&gt;保持新鲜&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ca02cf1f3493509e01b7edcf83dc8689814598fc" translate="yes" xml:space="preserve">
          <source>Indicates the client will accept a stale response. An optional value in seconds indicates the upper limit of staleness the client will accept.</source>
          <target state="translated">表示客户端将接受一个陈旧的响应。以秒为单位的可选值,表示客户机接受陈旧度的上限。</target>
        </trans-unit>
        <trans-unit id="79a4facd7bfa2752abc2651ad8a22d1290f85fac" translate="yes" xml:space="preserve">
          <source>Indicates the client's device pixel ratio.</source>
          <target state="translated">表示客户端设备的像素比例。</target>
        </trans-unit>
        <trans-unit id="7c99e10959087264a8f9f76bbe0fb6c6616be7db" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e. no compression, nor modification). This token, except if explicitly specified, is always deemed acceptable.</source>
          <target state="translated">表示身份功能(即不压缩,也不修改)。除非有明确的规定,否则这个标记总是被认为是可接受的。</target>
        </trans-unit>
        <trans-unit id="300e6bcab08b44f020c00b953beb914707cf781f" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e. no compression, nor modification). This value is always considered as acceptable, even if not present.</source>
          <target state="translated">表示身份功能(即没有压缩,也没有修改)。即使不存在,该值始终被认为是可以接受的。</target>
        </trans-unit>
        <trans-unit id="4412b21a02fb471172b40a65fca71a926bc03433" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e., no compression or modification). This token, except if explicitly specified, is always deemed acceptable.</source>
          <target state="translated">表示身份功能(即没有压缩或修改)。除非有明确的规定,否则该标记始终被认为是可接受的。</target>
        </trans-unit>
        <trans-unit id="76a871a5c993107287ac4f26321af85411e97af4" translate="yes" xml:space="preserve">
          <source>Indicates the layout viewport width in CSS pixels.</source>
          <target state="translated">表示布局的视窗宽度,单位为CSS像素。</target>
        </trans-unit>
        <trans-unit id="13225f32edcd936d283f2308a7685081e9a67758" translate="yes" xml:space="preserve">
          <source>Indicates the media type of the resource.</source>
          <target state="translated">表示资源的媒体类型。</target>
        </trans-unit>
        <trans-unit id="fc5582911590b64a930b456a56b69a37cf02610d" translate="yes" xml:space="preserve">
          <source>Indicates the part of a document that the server should return.</source>
          <target state="translated">表示服务器应该返回的文档部分。</target>
        </trans-unit>
        <trans-unit id="d639acdf32e7294320e546fc64936adb232d2c83" translate="yes" xml:space="preserve">
          <source>Indicates the resource width in physical pixels (in other words the intrinsic size of an image).</source>
          <target state="translated">表示以物理像素为单位的资源宽度(换句话说,图像的固有尺寸)。</target>
        </trans-unit>
        <trans-unit id="b493750d584250a2156de56f689aa3919765f8d9" translate="yes" xml:space="preserve">
          <source>Indicates the tracking status of the corresponding response.</source>
          <target state="translated">表示相应响应的跟踪状态。</target>
        </trans-unit>
        <trans-unit id="7befcc9a5a8e27a8f507455ba0c663658e48c7d6" translate="yes" xml:space="preserve">
          <source>Indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">表示适用于相应请求的跟踪状态。</target>
        </trans-unit>
        <trans-unit id="9743929feee03e6db93823d546a5b6519ece671b" translate="yes" xml:space="preserve">
          <source>Indicates to not retrieve new data. This being the case, the server wishes the client to obtain a response only once and then cache. From this moment the client should keep releasing a cached copy and avoid contacting the origin-server to see if a newer copy exists.</source>
          <target state="translated">表示不检索新数据。在这种情况下,服务器希望客户端只获取一次响应,然后进行缓存。从这一刻起,客户端应该不断释放缓存的副本,避免联系原服务器查看是否有更新的副本。</target>
        </trans-unit>
        <trans-unit id="c3f04a324f464c13b3de7ed6c10ccdaea39b71f5" translate="yes" xml:space="preserve">
          <source>Indicates where a fetch originates from.</source>
          <target state="translated">表示取物的来源。</target>
        </trans-unit>
        <trans-unit id="850af2d2f10fe8221618b8b2b077bcf0329a3edf" translate="yes" xml:space="preserve">
          <source>Indicates where in a full body message a partial message belongs.</source>
          <target state="translated">表示部分信息在全文中的位置。</target>
        </trans-unit>
        <trans-unit id="be2f75e053430254664cae4d27f3e51d38721d53" translate="yes" xml:space="preserve">
          <source>Indicates whether a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">指示是否应允许浏览器在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; 中&lt;/a&gt;呈现页面</target>
        </trans-unit>
        <trans-unit id="6967405f8a783a33baf1dce6db1454c9b6f37b69" translate="yes" xml:space="preserve">
          <source>Indicates whether a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示是否应允许浏览器在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; 中&lt;/a&gt;呈现页面。</target>
        </trans-unit>
        <trans-unit id="f69a3c7ddba822bcbbe58dfda37543497c04707b" translate="yes" xml:space="preserve">
          <source>Indicates whether the response can be shared.</source>
          <target state="translated">表示是否可以共享响应。</target>
        </trans-unit>
        <trans-unit id="b1d669ea27317208a9d7ef5173080a7f6aeec565" translate="yes" xml:space="preserve">
          <source>Indicates whether the response to the request can be exposed when the credentials flag is true.</source>
          <target state="translated">表示当凭证标志为真时,是否可以暴露请求的响应。</target>
        </trans-unit>
        <trans-unit id="5fc014b0691c6356400a50c33337bc3eb5a7b831" translate="yes" xml:space="preserve">
          <source>Indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">通过列出头文件的名称来表明哪些头文件可以作为响应的一部分。</target>
        </trans-unit>
        <trans-unit id="99d7331d101ff2b635886de75d335f15281ec8b0" translate="yes" xml:space="preserve">
          <source>Indicates which protocol was used to make the request (typically &quot;http&quot; or &quot;https&quot;).</source>
          <target state="translated">表示发出请求时使用的协议(通常是 &quot;http &quot;或 &quot;https&quot;)。</target>
        </trans-unit>
        <trans-unit id="0c0dafad80f67d7e9dd4f5b440cd064e7a6c1c13" translate="yes" xml:space="preserve">
          <source>Indicating a target audience for a resource</source>
          <target state="translated">指明资源的目标受众</target>
        </trans-unit>
        <trans-unit id="5a9618787236f752551e7febb8e28aa6e4ab7345" translate="yes" xml:space="preserve">
          <source>Indicating the URL of a transaction's result</source>
          <target state="translated">指明交易结果的URL。</target>
        </trans-unit>
        <trans-unit id="fca6301092f0f25b345065ddc8bcf56276e0afd5" translate="yes" xml:space="preserve">
          <source>Indicating the language a document is written in</source>
          <target state="translated">表示文件所使用的语言</target>
        </trans-unit>
        <trans-unit id="d2ba3b92f81a378a79261a6178d8927104366f37" translate="yes" xml:space="preserve">
          <source>Inferring the policy</source>
          <target state="translated">推断政策</target>
        </trans-unit>
        <trans-unit id="7f8525ef38cab4390ca786bdef36f2a78190d70f" translate="yes" xml:space="preserve">
          <source>Information regarding the HSTS preload list in Chrome : &lt;a href=&quot;https://www.chromium.org/hsts&quot;&gt;https://www.chromium.org/hsts&lt;/a&gt;</source>
          <target state="translated">有关Chrome中HSTS预加载列表的信息：&lt;a href=&quot;https://www.chromium.org/hsts&quot;&gt;https&lt;/a&gt; : //www.chromium.org/hsts</target>
        </trans-unit>
        <trans-unit id="a98006b47abdad4b8d9d147e829058b52579a85e" translate="yes" xml:space="preserve">
          <source>Information responses</source>
          <target state="translated">信息答复</target>
        </trans-unit>
        <trans-unit id="05f417a1323b0c40bcc8b6cef74f7ddad2f42684" translate="yes" xml:space="preserve">
          <source>Information should be stored in cookies with the understanding that all cookie values are visible to, and can be changed by, the end-user. Depending on the application, it may be desirable to use an opaque identifier which is looked-up by the server or to investigate alternative authentication/confidentiality mechanisms such as JSON Web Tokens.</source>
          <target state="translated">信息应存储在Cookie中,但有一项谅解,即所有Cookie的值对最终用户来说都是可见的,并可由其更改。根据不同的应用,可能需要使用一个不透明的标识符,由服务器进行查询,或者研究其他的认证/保密机制,如JSON网络令牌。</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="9e7c1323910f2b5174a834226f71b3b7aee441c8" translate="yes" xml:space="preserve">
          <source>Informational (Expired)</source>
          <target state="translated">信息性(过期)</target>
        </trans-unit>
        <trans-unit id="485d91f1d2933394df2618e86ac2b0b86484e6e6" translate="yes" xml:space="preserve">
          <source>Informational responses (&lt;code&gt;100&lt;/code&gt;&amp;ndash;&lt;code&gt;199&lt;/code&gt;)</source>
          <target state="translated">信息反馈（ &lt;code&gt;100&lt;/code&gt; &amp;ndash; &lt;code&gt;199&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1af57283b2cb4e6ccf06b8fbe5453fc2d6fbb913" translate="yes" xml:space="preserve">
          <source>Informs recipients that the client is about to send a (presumably large) message body in this request and wishes to receive a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) interim response.</source>
          <target state="translated">通知接收者该客户端即将在此请求中发送（可能很大）消息正文，并希望接收&lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt;（继续）临时响应。</target>
        </trans-unit>
        <trans-unit id="cd5eddf712118b9e10b11441a5d8a43d84753b52" translate="yes" xml:space="preserve">
          <source>Informs the server about the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;types&lt;/a&gt; of data that can be sent back.</source>
          <target state="translated">通知服务器有关可以发送回的数据&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59f3ea8d1fb37b159cf5cc21991810bccf67d68b" translate="yes" xml:space="preserve">
          <source>Informs the server about the encoding algorithm, usually a compression algorithm, that can be used on the resource sent back.</source>
          <target state="translated">通知服务器关于编码算法,通常是压缩算法,可以用于发送回来的资源。</target>
        </trans-unit>
        <trans-unit id="7d1c901efc56627410e469547e2e02c56e5888bd" translate="yes" xml:space="preserve">
          <source>Informs the server about the human language the server is expected to send back. This is a hint and is not necessarily under the full control of the user: the server should always pay attention not to override an explicit user choice (like selecting a language from a dropdown).</source>
          <target state="translated">告知服务器期望发回的人类语言。这是一个提示,不一定由用户完全控制:服务器应始终注意不要覆盖用户的明确选择(如从下拉菜单中选择语言)。</target>
        </trans-unit>
        <trans-unit id="ddb5e7a065792d4b30e1cbf2d728a2ac83ecc7bb" translate="yes" xml:space="preserve">
          <source>Informs the server about the language the server is expected to send back. This is a hint and is not necessarily under the full control of the user: the server should always pay attention not to override an explicit user choice (like selecting a language in a drop down list).</source>
          <target state="translated">告知服务器期望发回的语言。这是一个提示,不一定由用户完全控制:服务器应始终注意不要覆盖用户的明确选择(如在下拉列表中选择语言)。</target>
        </trans-unit>
        <trans-unit id="87b0141515a7b36be28ca5afb9e3d2f36da758a0" translate="yes" xml:space="preserve">
          <source>Informs the server about the types of data that can be sent back. It is MIME-type.</source>
          <target state="translated">告知服务器可以发回的数据类型。它是MIME类型的。</target>
        </trans-unit>
        <trans-unit id="eee6e27810ba2393a1392a0340b18fa6717ec6eb" translate="yes" xml:space="preserve">
          <source>Informs the server about which character set the client is able to understand.</source>
          <target state="translated">告知服务器客户端能够理解的字符集。</target>
        </trans-unit>
        <trans-unit id="42cf6c04980a1ce5076cbc436e3d8fd8f9bd1eaa" translate="yes" xml:space="preserve">
          <source>Inheritance of policy for embedded content</source>
          <target state="translated">嵌入内容的政策继承</target>
        </trans-unit>
        <trans-unit id="9e915d7086e42ba7ad8fb470ce6fd37be732353b" translate="yes" xml:space="preserve">
          <source>Initial definition</source>
          <target state="translated">初步定义</target>
        </trans-unit>
        <trans-unit id="7b309a69a69c83b16df2d7ed3a933148fd03e854" translate="yes" xml:space="preserve">
          <source>Initial definition of &lt;code&gt;screen-wake-lock&lt;/code&gt; feature directive.</source>
          <target state="translated">&lt;code&gt;screen-wake-lock&lt;/code&gt; 功能指令的初始定义。</target>
        </trans-unit>
        <trans-unit id="7c20ea0f7a5e6485b35d3ff374d22c887ebf5ccf" translate="yes" xml:space="preserve">
          <source>Initial definition of &lt;code&gt;wake-lock&lt;/code&gt; feature directive.</source>
          <target state="translated">&lt;code&gt;wake-lock&lt;/code&gt; 功能指令的初始定义。</target>
        </trans-unit>
        <trans-unit id="1996078361460df53a1d2f9e9930c7c26d7f873c" translate="yes" xml:space="preserve">
          <source>Initial definition.</source>
          <target state="translated">初步定义:</target>
        </trans-unit>
        <trans-unit id="e33acc0f454b7bc534181d5c180450e08b663048" translate="yes" xml:space="preserve">
          <source>Initial definition. Defines the &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header. Directives are defined in the specs for the features they control. See individual directive pages for details.</source>
          <target state="translated">初始定义。定义&lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头。规范在规范中针对其控制的功能进行了定义。有关详细信息，请参见各个指令页。</target>
        </trans-unit>
        <trans-unit id="edd05a55e87a0a4d81fe6d4260b5996b65256986" translate="yes" xml:space="preserve">
          <source>Inline style attributes are also blocked:</source>
          <target state="translated">内联样式属性也被屏蔽。</target>
        </trans-unit>
        <trans-unit id="b1392fca8ed54aab0cc2cacc082edcfe0d478690" translate="yes" xml:space="preserve">
          <source>Inspecting cookies using the Storage Inspector</source>
          <target state="translated">使用存储检查器检查cookies</target>
        </trans-unit>
        <trans-unit id="888016dc3b8bc43c7d35e5a67e82071570e7e662" translate="yes" xml:space="preserve">
          <source>Instantiation of an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; element will fail if:</source>
          <target state="translated">在以下情况下，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素的实例化将失败：</target>
        </trans-unit>
        <trans-unit id="fcd90298324aef5e8378a11b58c0458589479afd" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;child-src&lt;/code&gt;, authors who wish to regulate nested browsing contexts and workers should use the &lt;a href=&quot;content-security-policy/frame-src&quot;&gt;&lt;code&gt;frame-src&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;content-security-policy/worker-src&quot;&gt;&lt;code&gt;worker-src&lt;/code&gt;&lt;/a&gt; directives, respectively.</source>
          <target state="translated">希望规范嵌套浏览上下文和worker的作者应该使用&lt;a href=&quot;content-security-policy/frame-src&quot;&gt; &lt;code&gt;frame-src&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;content-security-policy/worker-src&quot;&gt; &lt;code&gt;worker-src&lt;/code&gt; &lt;/a&gt;指令来代替 &lt;code&gt;child-src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7d972ef39c5afd44ac2beb99c854651c87a78a6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;child-src&lt;/code&gt;, authors who wish to regulate nested browsing contexts and workers should use the &lt;a href=&quot;frame-src&quot;&gt;&lt;code&gt;frame-src&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;worker-src&quot;&gt;&lt;code&gt;worker-src&lt;/code&gt;&lt;/a&gt; directives, respectively.</source>
          <target state="translated">希望规范嵌套浏览上下文和worker的作者应该使用&lt;a href=&quot;frame-src&quot;&gt; &lt;code&gt;frame-src&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;worker-src&quot;&gt; &lt;code&gt;worker-src&lt;/code&gt; &lt;/a&gt;指令来代替 &lt;code&gt;child-src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="084aab59ba07fd42914dc61a350dfb0f10e90306" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;child-src&lt;/code&gt;, if you want to regulate nested browsing contexts and workers, you should use the &lt;a href=&quot;content-security-policy/frame-src&quot;&gt;&lt;code&gt;frame-src&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;content-security-policy/worker-src&quot;&gt;&lt;code&gt;worker-src&lt;/code&gt;&lt;/a&gt; directives, respectively.</source>
          <target state="translated">如果要管理嵌套的浏览上下文和worker，则应分别使用&lt;a href=&quot;content-security-policy/frame-src&quot;&gt; &lt;code&gt;frame-src&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;content-security-policy/worker-src&quot;&gt; &lt;code&gt;worker-src&lt;/code&gt; &lt;/a&gt;指令，而不是 &lt;code&gt;child-src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2c345c2bb8c9ae2f11a593aebecd152fbd0acd7" translate="yes" xml:space="preserve">
          <source>Instead of expiring when the client closes,&lt;em&gt;permanent cookies&lt;/em&gt; expire at a specific date (&lt;code&gt;Expires&lt;/code&gt;) or after a specific length of time (&lt;code&gt;Max-Age&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;永久性Cookie&lt;/em&gt;不会在客户端关闭时过期，而是在特定日期（ &lt;code&gt;Expires&lt;/code&gt; ）或特定时间长度（ &lt;code&gt;Max-Age&lt;/code&gt; ）之后过期。</target>
        </trans-unit>
        <trans-unit id="ddeb6a9e31213f28e884fd04ed1dcca7829587e3" translate="yes" xml:space="preserve">
          <source>Instead of expiring when the client is closed, &lt;strong&gt;permanent cookies&lt;/strong&gt; expire at a specific date (&lt;code&gt;Expires&lt;/code&gt;) or after a specific length of time (&lt;code&gt;Max-Age&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;永久性Cookie&lt;/strong&gt;不会在客户端关闭时过期，而是在特定日期（ &lt;code&gt;Expires&lt;/code&gt; ）或特定时间长度（ &lt;code&gt;Max-Age&lt;/code&gt; ）之后过期。</target>
        </trans-unit>
        <trans-unit id="687abe5b976f19cc45e08804dc047a80872035fb" translate="yes" xml:space="preserve">
          <source>Instead of expiring when the client is closed, permanent cookies expire at a specific date (&lt;code&gt;Expires&lt;/code&gt;) or after a specific length of time (&lt;code&gt;Max-Age&lt;/code&gt;).</source>
          <target state="translated">永久性Cookie不会在客户端关闭时过期，而是在特定日期（ &lt;code&gt;Expires&lt;/code&gt; ）或特定时间长度（ &lt;code&gt;Max-Age&lt;/code&gt; ）之后过期。</target>
        </trans-unit>
        <trans-unit id="36cf82c2a961317e1eff83740cd0b4132837ed88" translate="yes" xml:space="preserve">
          <source>Instead of using a &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; header you can also use a &lt;a href=&quot;headers/public-key-pins-report-only&quot;&gt;&lt;code&gt;Public-Key-Pins-Report-Only&lt;/code&gt;&lt;/a&gt; header. This header only sends reports to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header and does still allow browsers to connect to the webserver even if the pinning is violated.</source>
          <target state="translated">除了使用&lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;标头，还可以使用&lt;a href=&quot;headers/public-key-pins-report-only&quot;&gt; &lt;code&gt;Public-Key-Pins-Report-Only&lt;/code&gt; &lt;/a&gt;标头。此标头仅将报告发送到标头中指定的 &lt;code&gt;report-uri&lt;/code&gt; ，并且即使违反了固定，仍允许浏览器连接到Web服务器。</target>
        </trans-unit>
        <trans-unit id="3750ed931b77d473b6340fb847310a94be2c064d" translate="yes" xml:space="preserve">
          <source>Instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">指示用户代理报告违反内容安全策略的尝试。这些违规报告包含通过HTTP &lt;code&gt;POST&lt;/code&gt; 请求发送到指定URI 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="da42a3abb7f8b91ffc4fd5c08ba6b30c83141085" translate="yes" xml:space="preserve">
          <source>Instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">指示用户代理将网站的所有不安全URL(通过HTTP服务的URL)视为已被安全URL(通过HTTPS服务的URL)取代。该指令适用于有大量不安全的遗留URL需要重写的网站。</target>
        </trans-unit>
        <trans-unit id="206bbd6a7b7d6a23df99e3ac10a5c7e4495332dd" translate="yes" xml:space="preserve">
          <source>Integration with CSS</source>
          <target state="translated">与CSS整合</target>
        </trans-unit>
        <trans-unit id="eded9e1af9c609a228692b23c36ea0973e62cf9c" translate="yes" xml:space="preserve">
          <source>Integration with HTML</source>
          <target state="translated">与HTML整合</target>
        </trans-unit>
        <trans-unit id="241c7e4997c321b689e3324be2a21f7dbf1a7358" translate="yes" xml:space="preserve">
          <source>Integrity of a partial download</source>
          <target state="translated">部分下载的完整性</target>
        </trans-unit>
        <trans-unit id="d7339840c521459441002b60ebbff7f9e4807175" translate="yes" xml:space="preserve">
          <source>Internet Draft</source>
          <target state="translated">互联网草案</target>
        </trans-unit>
        <trans-unit id="a6663b7c68906c9f926b00ce9838f57dafd1e9c7" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                         M. Belshe
Request for Comments: 7540                                         BitGo
Category: Standards Track                                        R. Peon
ISSN: 2070-1721                                              Google, Inc
                                                         M. Thomson, Ed.
                                                                 Mozilla
                                                                May 2015</source>
          <target state="translated">互联网工程任务组(IETF)M.Belshe征求意见。7540 BitGo 类别:标准追踪 R.Peon ISSN:2070-1721 Google,Inc:标准追踪 R.Peon ISSN:2070-1721 Google,Inc M.Thomson,Ed.Mozilla 2015年5月</target>
        </trans-unit>
        <trans-unit id="944b611c46b28ffd8244fb42daaa4b9496b1cf13" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7230                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;2145&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                    J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;2818&lt;/a&gt;                                           greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">互联网工程任务组（IETF）R. Fielding，编。征求意见：7230的Adobe淘汰了：&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;2145&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J.雷什克，埃德。更新：&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;2818个&lt;/a&gt; greenbytes类别：标准跟踪2014年6月ISSN：2070年至1721年</target>
        </trans-unit>
        <trans-unit id="a37f9383c64e54f8eb287b01c2b6207a20637c11" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7231                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt;                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">互联网工程任务组（IETF）R. Fielding，编。请求注释：7231 Adob​​e已过时：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke，编辑。更新：&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt; greenbytes类别：Standards Track 2014年6月ISSN：2070-1721</target>
        </trans-unit>
        <trans-unit id="ac7e3a4b626b90a8dbd99bacd4566ca932b34a3b" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7232                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Category: Standards Track                                     greenbytes
ISSN: 2070-1721                                                June 2014</source>
          <target state="translated">互联网工程任务组（IETF）R. Fielding，编。请求注释：7232 Adob​​e已过时：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke，编辑。类别：标准Track greenbytes ISSN：2070-1721 2014年6月</target>
        </trans-unit>
        <trans-unit id="f19a38d04cab53923494c67976d4e498a99f2c29" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7233                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                            Y. Lafon, Ed.
Category: Standards Track                                            W3C
ISSN: 2070-1721                                          J. Reschke, Ed.
                                                              greenbytes
                                                              June 2014</source>
          <target state="translated">互联网工程任务组（IETF）R. Fielding，编。征求评论意见：7233 Adob​​e已过时：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; Y. Lafon，Ed。类别：标准Track W3C ISSN：2070-1721 J. Reschke，编辑。 greenbytes 2014年6月</target>
        </trans-unit>
        <trans-unit id="abf0c52384302c538626557887406ff5785b7493" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7234                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                       M. Nottingham, Ed.
Category: Standards Track                                         Akamai
ISSN: 2070-1721                                          J. Reschke, Ed.
                                                              greenbytes
                                                               June 2014</source>
          <target state="translated">互联网工程任务组（IETF）R. Fielding，编。请求注释：7234 Adob​​e已过时：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; M. Nottingham，ED。类别：Standard Track Akamai ISSN：2070-1721 J. Reschke，编辑。 greenbytes 2014年6月</target>
        </trans-unit>
        <trans-unit id="4cf7cbfbbfccd70ae7ed26796d1828c5ad2463df" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7235                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt;                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">互联网工程任务组（IETF）R. Fielding，编。请求注释：7235 Adob​​e已过时：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke，编辑。更新：&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt; greenbytes类别：Standards Track 2014年6月ISSN：2070-1721</target>
        </trans-unit>
        <trans-unit id="76d5733b82b9b85e7c7c9538c8b1cbf395dc743e" translate="yes" xml:space="preserve">
          <source>Internet Explorer</source>
          <target state="translated">互联网浏览器</target>
        </trans-unit>
        <trans-unit id="ee29687168fb4fd84a3acc654a9db5d9db8c1813" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8</source>
          <target state="translated">Internet Explorer 8</target>
        </trans-unit>
        <trans-unit id="400856455193d5665422e0bfcbb69ad86eadd5de" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 and 9 expose CORS via the &lt;code&gt;XDomainRequest&lt;/code&gt; object, but have a full implementation in IE 10</source>
          <target state="translated">Internet Explorer 8和9通过 &lt;code&gt;XDomainRequest&lt;/code&gt; 对象公开CORS ，但在IE 10中具有完整的实现</target>
        </trans-unit>
        <trans-unit id="b50d4fdd010f7da47bc090ba56b32ab192bd7efd" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 and 9 expose CORS via the &lt;code&gt;XDomainRequest&lt;/code&gt; object, but have a full implementation in IE 10.</source>
          <target state="translated">Internet Explorer 8和9通过 &lt;code&gt;XDomainRequest&lt;/code&gt; 对象公开CORS ，但在IE 10中具有完整的实现。</target>
        </trans-unit>
        <trans-unit id="f09fc55fe960cdc577a491b6af400c7ecc717639" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 or earlier</source>
          <target state="translated">Internet Explorer 8或更早</target>
        </trans-unit>
        <trans-unit id="9df82ce454660e2e95801528c257a56a7c65b8f4" translate="yes" xml:space="preserve">
          <source>Internet Explorer 9</source>
          <target state="translated">Internet Explorer 9</target>
        </trans-unit>
        <trans-unit id="ab3ccd4c44d2e9f7601c41c05c58eb093f7971c4" translate="yes" xml:space="preserve">
          <source>Internet Explorer UA string</source>
          <target state="translated">Internet Explorer UA字符串</target>
        </trans-unit>
        <trans-unit id="935b07a4771d1ecca905a5712a8abb0cb5f5eebd" translate="yes" xml:space="preserve">
          <source>Internet Explorer doesn't put its name in the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; format</source>
          <target state="translated">Internet Explorer不会将其名称设置为&lt;em&gt;BrowserName / VersionNumber&lt;/em&gt;格式</target>
        </trans-unit>
        <trans-unit id="b2b280e0cd215dee60eed1d1e3dbd22fa9b08456" translate="yes" xml:space="preserve">
          <source>Internet Explorer put this token in the &lt;em&gt;comment&lt;/em&gt; part of the User Agent String</source>
          <target state="translated">Internet Explorer将此令牌放在用户代理字符串的&lt;em&gt;注释&lt;/em&gt;部分中</target>
        </trans-unit>
        <trans-unit id="a1ee7fdf2dfeeebbbf381e7307a8cb5b69c060fd" translate="yes" xml:space="preserve">
          <source>Internet Standard</source>
          <target state="translated">互联网标准</target>
        </trans-unit>
        <trans-unit id="097b71887b4219ceb51b23addafcc7413a4278f3" translate="yes" xml:space="preserve">
          <source>Internet hosts by name or IP address, as well as an optional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/URIs_and_URLs&quot;&gt;URL scheme&lt;/a&gt; and/or port number, separated by spaces. The site's address may include an optional leading wildcard (the asterisk character, &lt;code&gt;'*'&lt;/code&gt;), and you may use a wildcard (again, &lt;code&gt;'*'&lt;/code&gt;) as the port number, indicating that all legal ports are valid for the source. Single quotes surrounding the host are not allowed.</source>
          <target state="translated">Internet主机按名称或IP地址，以及可选的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/URIs_and_URLs&quot;&gt;URL方案&lt;/a&gt;和/或端口号，以空格分隔。该站点的地址可能包括可选的前导通配符（星号字符 &lt;code&gt;'*'&lt;/code&gt; ），并且您可以使用通配符（再次为 &lt;code&gt;'*'&lt;/code&gt; ）作为端口号，表示所有合法端口均对源有效。不允许在主机周围使用单引号。</target>
        </trans-unit>
        <trans-unit id="a3dfded56299e82b9ecd1b36148982d1169af1c0" translate="yes" xml:space="preserve">
          <source>Internet hosts by name or IP address, as well as an optional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/URIs_and_URLs&quot;&gt;URL scheme&lt;/a&gt; and/or port number. The site's address may include an optional leading wildcard (the asterisk character, &lt;code&gt;'*'&lt;/code&gt;), and you may use a wildcard (again, &lt;code&gt;'*'&lt;/code&gt;) as the port number, indicating that all legal ports are valid for the source.</source>
          <target state="translated">Internet主机的名称或IP地址，以及可选的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/URIs_and_URLs&quot;&gt;URL方案&lt;/a&gt;和/或端口号。该站点的地址可能包含一个可选的前导通配符（星号字符 &lt;code&gt;'*'&lt;/code&gt; ），并且您可以使用通配符（再次为 &lt;code&gt;'*'&lt;/code&gt; ）作为端口号，表示所有合法端口均对源有效。</target>
        </trans-unit>
        <trans-unit id="037a2067974b5b1a90e1e346b9991a68825acb64" translate="yes" xml:space="preserve">
          <source>Internet media types are registered with a canonical form in order to
   be interoperable among systems with varying native encoding formats.
   Representations selected or transferred via HTTP ought to be in
   canonical form, for many of the same reasons described by the
   Multipurpose Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;].  However, the
   performance characteristics of email deployments (i.e., store and
   forward messages to peers) are significantly different from those
   common to HTTP and the Web (server-based information services).
   Furthermore, MIME's constraints for the sake of compatibility with
   older mail transfer protocols do not apply to HTTP (see &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;). 

   MIME's canonical form requires that media subtypes of the &quot;text&quot; type
   use CRLF as the text line break.  HTTP allows the transfer of text
   media with plain CR or LF alone representing a line break, when such
   line breaks are consistent for an entire representation.  An HTTP
   sender MAY generate, and a recipient MUST be able to parse, line
   breaks in text media that consist of CRLF, bare CR, or bare LF.  In
   addition, text media in HTTP is not limited to charsets that use
   octets 13 and 10 for CR and LF, respectively.  This flexibility
   regarding line breaks applies only to text within a representation
   that has been assigned a &quot;text&quot; media type; it does not apply to
   &quot;multipart&quot; types or HTTP elements outside the payload body (e.g.,
   header fields).

   If a representation is encoded with a content-coding, the underlying
   data ought to be in a form defined above prior to being encoded.</source>
          <target state="translated">Internet媒体类型以规范形式注册，以便可以在具有各种本机编码格式的系统之间互操作。由于多用途Internet邮件扩展（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ] 所述的许多相同原因，通过HTTP选择或传输的表示形式应采用规范形式。但是，电子邮件部署的性能特征（即，存储消息并将其转发给对等方）与HTTP和Web（基于服务器的信息服务）所共有的性能特征显着不同。此外，出于与旧邮件传输协议兼容的目的，MIME约束不适用于HTTP（请参阅&lt;a href=&quot;#appendix-A&quot;&gt;附录A）。&lt;/a&gt;）。 MIME的规范格式要求&amp;ldquo;文本&amp;rdquo;类型的媒体子类型使用CRLF作为文本换行符。 HTTP允许仅使用纯CR或LF表示换行符的文本媒体的传输，当这样的换行符对于整个表示而言是一致的时。 HTTP发送方可以生成并且接收方必须能够解析由CRLF，裸CR或裸LF组成的文本媒体中的换行符。此外，HTTP中的文本媒体不限于将CR和LF分别使用八位字节13和10的字符集。关于换行符的这种灵活性仅适用于已分配了&amp;ldquo;文本&amp;rdquo;媒体类型的表示形式中的文本；它不适用于有效负载主体外部的&amp;ldquo;多部分&amp;rdquo;类型或HTTP元素（例如，标头字段）。如果表示是用内容编码进行编码的，则基础数据应在编码之前采用上面定义的形式。</target>
        </trans-unit>
        <trans-unit id="23ce3ccc1ff356540fdaac404f8bf64e60f80ef1" translate="yes" xml:space="preserve">
          <source>Internet media types are registered with a canonical form. An
   entity-body transferred via HTTP messages MUST be represented in the
   appropriate canonical form prior to its transmission except for
   &quot;text&quot; types, as defined in the next paragraph.

   When in canonical form, media subtypes of the &quot;text&quot; type use CRLF as
   the text line break. HTTP relaxes this requirement and allows the
   transport of text media with plain CR or LF alone representing a line
   break when it is done consistently for an entire entity-body. HTTP
   applications MUST accept CRLF, bare CR, and bare LF as being
   representative of a line break in text media received via HTTP. In
   addition, if the text is represented in a character set that does not
   use octets 13 and 10 for CR and LF respectively, as is the case for
   some multi-byte character sets, HTTP allows the use of whatever octet
   sequences are defined by that character set to represent the
   equivalent of CR and LF for line breaks. This flexibility regarding
   line breaks applies only to text media in the entity-body; a bare CR
   or LF MUST NOT be substituted for CRLF within any of the HTTP control
   structures (such as header fields and multipart boundaries).

   If an entity-body is encoded with a content-coding, the underlying
   data MUST be in a form defined above prior to being encoded.

   The &quot;charset&quot; parameter is used with some media types to define the
   character set (&lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;) of the data. When no explicit charset
   parameter is provided by the sender, media subtypes of the &quot;text&quot;
   type are defined to have a default charset value of &quot;ISO-8859-1&quot; when
   received via HTTP. Data in character sets other than &quot;ISO-8859-1&quot; or
   its subsets MUST be labeled with an appropriate charset value. See
   &lt;a href=&quot;#section-3.4.1&quot;&gt;section 3.4.1&lt;/a&gt; for compatibility problems.</source>
          <target state="translated">Internet媒体类型以规范形式注册。通过HTTP消息传输的实体必须在传输之前以适当的规范形式表示，但&amp;ldquo;文本&amp;rdquo;类型除外，这将在下一段中定义。当采用规范形式时，&amp;ldquo;文本&amp;rdquo;类型的媒体子类型使用CRLF作为文本换行符。 HTTP放宽了此要求，并允许在整个实体主体上一致执行时仅使用纯CR或LF表示换行符的文本媒体传输。 HTTP应用程序必须接受CRLF，裸CR和裸LF来表示通过HTTP接收的文本媒体中的换行符。此外，如果文字是在不分别为CR和LF使用八位位组13和10的字符集中表示的，与某些多字节字符集的情况一样，HTTP允许使用该字符集定义的任何八位位组序列来表示换行符的CR和LF等效项。关于换行符的这种灵活性仅适用于实体主体中的文本媒体；在任何HTTP控制结构（例如标头字段和多部分边界）中，绝对不能用裸CR或LF代替CRLF。如果实体通过内容编码进行编码，则基础数据在编码之前必须采用上面定义的形式。 &amp;ldquo; charset&amp;rdquo;参数与某些媒体类型一起使用以定义字符集（关于换行符的这种灵活性仅适用于实体主体中的文本媒体；在任何HTTP控制结构（例如标头字段和多部分边界）中，绝对不能用裸CR或LF代替CRLF。如果实体通过内容编码进行编码，则基础数据在编码之前必须采用上面定义的形式。 &amp;ldquo; charset&amp;rdquo;参数与某些媒体类型一起使用以定义字符集（关于换行符的这种灵活性仅适用于实体主体中的文本媒体；在任何HTTP控制结构（例如标头字段和多部分边界）中，绝对不能用裸CR或LF代替CRLF。如果实体通过内容编码进行编码，则基础数据在编码之前必须采用上面定义的形式。 &amp;ldquo; charset&amp;rdquo;参数与某些媒体类型一起使用以定义字符集（参数与某些媒体类型一起使用以定义字符集（参数与某些媒体类型一起使用以定义字符集（&lt;a href=&quot;#section-3.4&quot;&gt;&lt;/a&gt;数据的第3.4节）。当发送方未提供任何明确的字符集参数时，&amp;ldquo;文本&amp;rdquo;类型的媒体子类型将定义为通过HTTP接收时具有默认字符集值&amp;ldquo; ISO-8859-1&amp;rdquo;。除&amp;ldquo; ISO-8859-1&amp;rdquo;以外的字符集中的数据或其子集必须使用适当的字符集值标记。有关兼容性问题，请参见 &lt;a href=&quot;#section-3.4.1&quot;&gt;第3.4.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ded9c72dfd997c4640e3e4defef803106231f1f6" translate="yes" xml:space="preserve">
          <source>Introduced in HTTP/1.0, &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; made this protocol easy to extend and experiment with. New functionality can even be introduced by a simple agreement between a client and a server about a new header's semantics.</source>
          <target state="translated">&lt;a href=&quot;headers&quot;&gt;HTTP标头&lt;/a&gt;是HTTP / 1.0中引入的，使该协议易于扩展和试验。甚至可以通过客户端与服务器之间关于新标头语义的简单协议来引入新功能。</target>
        </trans-unit>
        <trans-unit id="408ce1469d35c3a1c9fa2b8075ea8921344fc2af" translate="yes" xml:space="preserve">
          <source>Introduced in HTTP/1.0, &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; make this protocol easy to extend and experiment with. New functionality can even be introduced by a simple agreement between a client and a server about a new header's semantics.</source>
          <target state="translated">&lt;a href=&quot;headers&quot;&gt;HTTP标头&lt;/a&gt;是HTTP / 1.0中引入的，它使该协议易于扩展和试验。甚至可以通过客户端与服务器之间关于新标头语义的简单协议来引入新功能。</target>
        </trans-unit>
        <trans-unit id="1117753f6df6a46418e743d7060ef1767501957d" translate="yes" xml:space="preserve">
          <source>Introduction to Feature Policy</source>
          <target state="translated">特征政策介绍</target>
        </trans-unit>
        <trans-unit id="80e829c3a10d9e489ea935dbe19658e50845954c" translate="yes" xml:space="preserve">
          <source>Invalid dates, like the value 0, represent a date in the past and mean that the resource is already expired.</source>
          <target state="translated">无效日期,如值0,代表过去的日期,意味着资源已经过期。</target>
        </trans-unit>
        <trans-unit id="dfa60022094016d57bd557254bafb6ff9bbe3d2a" translate="yes" xml:space="preserve">
          <source>Invalid domains</source>
          <target state="translated">无效域名</target>
        </trans-unit>
        <trans-unit id="9032ed3737ead87641e8c9fd63add1c68fa832be" translate="yes" xml:space="preserve">
          <source>Invalid parameters in media, or typos when specifying &lt;code&gt;'base64'&lt;/code&gt;, are ignored, but no error is provided.</source>
          <target state="translated">媒体中的无效参数或指定 &lt;code&gt;'base64'&lt;/code&gt; 时的拼写错误都将被忽略，但不会提供错误。</target>
        </trans-unit>
        <trans-unit id="db5e158a717067d22e2fe4cb88250953ddf29eb6" translate="yes" xml:space="preserve">
          <source>Invalidation (RFC 7234)</source>
          <target state="translated">取消资格(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="380eceb118a2210931ae6c7c6f4918fcad2be151" translate="yes" xml:space="preserve">
          <source>Invention of the World Wide Web</source>
          <target state="translated">万维网的发明</target>
        </trans-unit>
        <trans-unit id="b00395d65a2e0cb5e4f72accad98e9c2d13dd4ca" translate="yes" xml:space="preserve">
          <source>Invocations of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch APIs&lt;/a&gt;, as discussed above.</source>
          <target state="translated">如上所述的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API的&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="96fe62d1784a07fd038cfab3bf1502f6c16a7790" translate="yes" xml:space="preserve">
          <source>Invocations of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIs in a cross-site manner, as discussed above.</source>
          <target state="translated">如上所述，以跨站点方式调用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; API。</target>
        </trans-unit>
        <trans-unit id="2422fcd418c687b013805ec7620a6399f1372c7e" translate="yes" xml:space="preserve">
          <source>Is a response header if the resource transmitted should be displayed inline (default behavior when the header is not present), or it should be handled like a download and the browser should present a 'Save As' window.</source>
          <target state="translated">是一个响应头,如果传输的资源应该内联显示(头不存在时的默认行为),或者应该像下载一样处理,浏览器应该显示一个 &quot;另存为 &quot;窗口。</target>
        </trans-unit>
        <trans-unit id="54e9ec692a56ffab91bf47f24b6f5f04f83ce33b" translate="yes" xml:space="preserve">
          <source>Is either the string &quot;GMT&quot; or is left out.</source>
          <target state="translated">是 &quot;格林尼治标准时间 &quot;的字符串,或者是遗漏。</target>
        </trans-unit>
        <trans-unit id="a64fa4c3a913c82e4add144ea7fbfd9cf3825b6d" translate="yes" xml:space="preserve">
          <source>Is either the string &quot;GMT&quot;, which makes time comparison occur in GMT timezone, or is left out. If left unspecified, times are taken to be in the local timezone.</source>
          <target state="translated">是字符串 &quot;GMT&quot;,使时间比较发生在GMT时区,或者不指定。如果不指定,则以当地时区的时间为准。</target>
        </trans-unit>
        <trans-unit id="2fda418b4e57fb88a74dfec63a3a823a7276ce48" translate="yes" xml:space="preserve">
          <source>Is followed by a string containing the name of the HTML field in the form that the content of this subpart refers to. When dealing with multiple files in the same field (for example, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-multiple&quot;&gt;multiple&lt;/a&gt;&lt;/code&gt; attribute of an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/a&gt;&lt;/code&gt; element), there can be several subparts with the same name.</source>
          <target state="translated">随后是一个字符串，其中包含此子部分的内容所引用的格式的HTML字段的名称。当处理同一个字段中的多个文件时（例如， &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/a&gt;&lt;/code&gt; 元素的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-multiple&quot;&gt;multiple&lt;/a&gt;&lt;/code&gt; 属性），可以有多个具有相同名称的子部分。</target>
        </trans-unit>
        <trans-unit id="7ba85fc81b8929d8f78e20fd1bc753c0fb30e0fc" translate="yes" xml:space="preserve">
          <source>Is followed by a string containing the name of the HTML field in the form that the content of this subpart refers to. When dealing with multiple files in the same field (for example, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-multiple&quot;&gt;multiple&lt;/a&gt;&lt;/code&gt; attribute of an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&amp;lt;input type=file&amp;gt;&lt;/a&gt;&lt;/code&gt; element), there can be several subparts with the same name.</source>
          <target state="translated">随后是一个字符串，其中包含此子部分的内容所引用的格式的HTML字段的名称。处理同一字段中的多个文件时（例如， &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&amp;lt;input type=file&amp;gt;&lt;/a&gt;&lt;/code&gt; 元素的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-multiple&quot;&gt;multiple&lt;/a&gt;&lt;/code&gt; 属性），可以有多个具有相同名称的子部分。</target>
        </trans-unit>
        <trans-unit id="3e092b4d92d6c6e47005b961bfdf49f31576121c" translate="yes" xml:space="preserve">
          <source>Is followed by a string containing the original name of the file transmitted. The filename is always optional and must not be used blindly by the application: path information should be stripped, and conversion to the server file system rules should be done. This parameter provides mostly indicative information. When used in combination with &lt;code&gt;Content-Disposition: attachment&lt;/code&gt;, it is used as the default filename for an eventual &quot;Save As&quot; dialog presented to the user.</source>
          <target state="translated">后跟一个包含所传输文件的原始名称的字符串。文件名始终是可选的，并且不能被应用程序盲目使用：路径信息应被删除，并且应完成向服务器文件系统规则的转换。此参数主要提供指示性信息。当与 &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; 结合使用时，它用作最终呈现给用户的&amp;ldquo;另存为&amp;rdquo;对话框的默认文件名。</target>
        </trans-unit>
        <trans-unit id="ad350b49b6105f7ba408d2cd47de12fe45080a69" translate="yes" xml:space="preserve">
          <source>Is one of the ordered month strings below.</source>
          <target state="translated">是下面订购的月份字符串之一。</target>
        </trans-unit>
        <trans-unit id="77e28a9350d45487207b84bc262233bfb40e6bc5" translate="yes" xml:space="preserve">
          <source>Is the domain name to test the hostname against.</source>
          <target state="translated">是用来测试主机名的域名。</target>
        </trans-unit>
        <trans-unit id="5e530d4a48748eedf183a271fc2d6561b7e57883" translate="yes" xml:space="preserve">
          <source>Is the hostname from the URL.</source>
          <target state="translated">是URL中的主机名。</target>
        </trans-unit>
        <trans-unit id="2e041ae111b4fa679b2480031c90505ef7ed4674" translate="yes" xml:space="preserve">
          <source>Is the hour from 0 to 23. (0 is midnight, 23 is 11 pm.)</source>
          <target state="translated">是0到23的时间。0是午夜,23是晚上11点)。</target>
        </trans-unit>
        <trans-unit id="76bc382859db96f13208fadcaadcd35c9c7d32d7" translate="yes" xml:space="preserve">
          <source>Is the ordered day of the month between 1 and 31 (as an integer).</source>
          <target state="translated">是每月1到31之间的顺序日(为整数)。</target>
        </trans-unit>
        <trans-unit id="7165ac45c85ea0d30878e33d1b544beb92ad0407" translate="yes" xml:space="preserve">
          <source>Is the ordered full year integer number. For example, 2016 (&lt;strong&gt;not&lt;/strong&gt; 16).</source>
          <target state="translated">是订购的全年整数。例如，2016（&lt;strong&gt;不是&lt;/strong&gt; 16）。</target>
        </trans-unit>
        <trans-unit id="0331e5317c1a5353192cf6b448ec4dc07116aaba" translate="yes" xml:space="preserve">
          <source>Is true if the hostname matches &lt;em&gt;exactly&lt;/em&gt; the specified hostname, or if there is no domain name part in the hostname, but the unqualified hostname matches.</source>
          <target state="translated">如果主机名与指定的主机名&lt;em&gt;完全&lt;/em&gt;匹配，或者该主机名中没有域名部分，但不合格的主机名匹配，则为true 。</target>
        </trans-unit>
        <trans-unit id="ecffee78fc03e20a569b23ceac7747629660f84c" translate="yes" xml:space="preserve">
          <source>Is true if the hostname matches exactly the specified hostname, or if there is no domain name part in the hostname, but the unqualified hostname matches.</source>
          <target state="translated">如果主机名与指定的主机名完全匹配,或者主机名中没有域名部分,但非限定主机名匹配,则为真。</target>
        </trans-unit>
        <trans-unit id="dc64e475d99a6f7197d18d5097b7b8434838014d" translate="yes" xml:space="preserve">
          <source>Isolates the browsing context exclusively to same-origin documents. Cross-origin documents are not loaded in the same browsing context.</source>
          <target state="translated">将浏览上下文仅隔离于同源文档。跨源文档不会在同一浏览上下文中加载。</target>
        </trans-unit>
        <trans-unit id="0bea60d3e6673895b89b3e27ba8883ed44567185" translate="yes" xml:space="preserve">
          <source>It allows a server to populate data in a client cache, in advance of it being required, through a mechanism called the server push.</source>
          <target state="translated">它允许服务器通过一种称为服务器推送的机制,在需要数据之前,将数据填充到客户端缓存中。</target>
        </trans-unit>
        <trans-unit id="f43fd22d2b5777ebb739889216138bbc5cbb86d9" translate="yes" xml:space="preserve">
          <source>It also needs to have a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;.</source>
          <target state="translated">它还需要具有解析度为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; ， &lt;code&gt;multipart/form-data&lt;/code&gt; 或 &lt;code&gt;text/plain&lt;/code&gt; 的MIME类型（忽略参数）。</target>
        </trans-unit>
        <trans-unit id="f005d0f75fee252497145808a577cd8d55b04051" translate="yes" xml:space="preserve">
          <source>It assumed that all user agent strings that include the substring &quot;Chrome&quot; are Chrome. UA strings are notoriously misleading.</source>
          <target state="translated">它假设所有包含子串 &quot;Chrome &quot;的用户代理字符串都是Chrome。UA字符串具有明显的误导性。</target>
        </trans-unit>
        <trans-unit id="00298a3bb5b667d923ae54e34aa323fff850e2de" translate="yes" xml:space="preserve">
          <source>It assumed that the lookbehind feature would always be available if the browser was Chrome. The agent might be an older version of Chrome, from before support was added, or (because the feature was experimental at the time) it could be a later version of Chrome that removed it.</source>
          <target state="translated">它假设如果浏览器是Chrome浏览器,lookbehind功能将始终可用。代理商可能是旧版本的Chrome浏览器,在添加支持之前,或者(因为该功能当时是试验性的)它可能是后来的Chrome浏览器版本,并将其删除。</target>
        </trans-unit>
        <trans-unit id="f46736fbac23773dd54664bce214c5dc4f10a2c6" translate="yes" xml:space="preserve">
          <source>It can be used when the total number of request header fields is too large, or when a single header field is at too large.</source>
          <target state="translated">当请求头字段总数过大,或单个头字段过大时,可以使用它。</target>
        </trans-unit>
        <trans-unit id="c1727a3eed7f9b9c35a928b776172744af8666f3" translate="yes" xml:space="preserve">
          <source>It compresses headers. As these are often similar among a set of requests, this removes duplication and overhead of data transmitted.</source>
          <target state="translated">它压缩了头文件。由于在一组请求中,这些请求往往是相似的,这就消除了传输数据的重复和开销。</target>
        </trans-unit>
        <trans-unit id="03150c53b496ba5d7d08bbe9124ae9e71723e36b" translate="yes" xml:space="preserve">
          <source>It indicates that a method could not be performed because the server cannot store the representation needed to successfully complete the request.</source>
          <target state="translated">它表明,由于服务器无法存储成功完成请求所需的表示,所以无法执行一个方法。</target>
        </trans-unit>
        <trans-unit id="bc98200fb5d715ddd3a57296b4af83524c9f7ff0" translate="yes" xml:space="preserve">
          <source>It indicates that the server terminated an operation because it encountered an infinite loop while processing a request with &quot;Depth: infinity&quot;. This status indicates that the entire operation failed.</source>
          <target state="translated">表示服务器在处理 &quot;深度:无穷大 &quot;的请求时,遇到了无限循环而终止了操作。此状态表示整个操作失败。</target>
        </trans-unit>
        <trans-unit id="4b480764290e819516d7c049141dbc95445b3642" translate="yes" xml:space="preserve">
          <source>It is a binary protocol rather than text. It can no longer be read and created manually. Despite this hurdle, improved optimization techniques can now be implemented.</source>
          <target state="translated">它是一个二进制协议而不是文本。它不再能被手动读取和创建。尽管存在这一障碍,但现在可以实施改进的优化技术。</target>
        </trans-unit>
        <trans-unit id="bad2ad311f9d8d7e181ed23c4b923cbf915ec8c4" translate="yes" xml:space="preserve">
          <source>It is a multiplexed protocol. Parallel requests can be handled over the same connection, removing the order and blocking constraints of the HTTP/1.x protocol.</source>
          <target state="translated">它是一个多路协议。可以通过同一连接处理并行请求,消除了HTTP/1.x协议的顺序和阻塞限制。</target>
        </trans-unit>
        <trans-unit id="a6445c1ff39b5450a5feef25fe2084062f1d4500" translate="yes" xml:space="preserve">
          <source>It is a request header that indicates the relationship between a request initiator's origin and its target's origin. It is a Structured Header whose value is a token with possible values &lt;code&gt;cross-site&lt;/code&gt;, &lt;code&gt;same-origin&lt;/code&gt;, &lt;code&gt;same-site&lt;/code&gt;, and &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">它是一个请求标头，指示请求发起方的来源与其目标的来源之间的关系。它是一个结构化报头，其值是一个令牌，其可能的值是 &lt;code&gt;cross-site&lt;/code&gt; ， &lt;code&gt;same-origin&lt;/code&gt; ， &lt;code&gt;same-site&lt;/code&gt; 和 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c11dc9b7ef22fb60dba4ef500da2f01db7a4466" translate="yes" xml:space="preserve">
          <source>It is a request header that indicates the request's destination to a server. It is a Structured Header whose value is a token with possible values &lt;code&gt;audio&lt;/code&gt;, &lt;code&gt;audioworklet&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, &lt;code&gt;embed&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;font&lt;/code&gt;, &lt;code&gt;image&lt;/code&gt;, &lt;code&gt;manifest&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;paintworklet&lt;/code&gt;, &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;serviceworker&lt;/code&gt;, &lt;code&gt;sharedworker&lt;/code&gt;, &lt;code&gt;style&lt;/code&gt;, &lt;code&gt;track&lt;/code&gt;, &lt;code&gt;video&lt;/code&gt;, &lt;code&gt;worker&lt;/code&gt;, &lt;code&gt;xslt&lt;/code&gt;, and &lt;code&gt;nested-document&lt;/code&gt;.</source>
          <target state="translated">它是一个请求标头，指示请求到服务器的目的地。这是一个结构化的头，它的值是一个令牌可能值 &lt;code&gt;audio&lt;/code&gt; ， &lt;code&gt;audioworklet&lt;/code&gt; ， &lt;code&gt;document&lt;/code&gt; ， &lt;code&gt;embed&lt;/code&gt; ， &lt;code&gt;empty&lt;/code&gt; ， &lt;code&gt;font&lt;/code&gt; ， &lt;code&gt;image&lt;/code&gt; ， &lt;code&gt;manifest&lt;/code&gt; ， &lt;code&gt;object&lt;/code&gt; ， &lt;code&gt;paintworklet&lt;/code&gt; ， &lt;code&gt;report&lt;/code&gt; ， &lt;code&gt;script&lt;/code&gt; ， &lt;code&gt;serviceworker&lt;/code&gt; ， &lt;code&gt;sharedworker&lt;/code&gt; ， &lt;code&gt;style&lt;/code&gt; ， &lt;code&gt;track&lt;/code&gt; ， &lt;code&gt;video&lt;/code&gt; ， &lt;code&gt;worker&lt;/code&gt; ， &lt;code&gt;xslt&lt;/code&gt; 和 &lt;code&gt;nested-document&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d36eba61499c051f255d5b1dd6e9cfd50aa960c2" translate="yes" xml:space="preserve">
          <source>It is a request header that indicates the request's mode to a server. It is a Structured Header whose value is a token with possible values &lt;code&gt;cors&lt;/code&gt;, &lt;code&gt;navigate&lt;/code&gt;, &lt;code&gt;nested-navigate&lt;/code&gt;, &lt;code&gt;no-cors&lt;/code&gt;, &lt;code&gt;same-origin&lt;/code&gt;, and &lt;code&gt;websocket&lt;/code&gt;.</source>
          <target state="translated">它是一个请求标头，向服务器指示请求的模式。这是一个结构化头，其值是一个令牌可能值 &lt;code&gt;cors&lt;/code&gt; ， &lt;code&gt;navigate&lt;/code&gt; ， &lt;code&gt;nested-navigate&lt;/code&gt; ， &lt;code&gt;no-cors&lt;/code&gt; ， &lt;code&gt;same-origin&lt;/code&gt; ，和 &lt;code&gt;websocket&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dadb148c476fc24dc7e1218baf0d8439e45ce0fd" translate="yes" xml:space="preserve">
          <source>It is a request header that indicates whether or not a navigation request was triggered by user activation. It is a Structured Header whose value is a boolean so possible values are &lt;code&gt;?0&lt;/code&gt; for false and &lt;code&gt;?1&lt;/code&gt; for true.</source>
          <target state="translated">它是一个请求标头，指示导航请求是否由用户激活触发。它是一个结构化标头，其值是布尔值，因此对于false可能值为 &lt;code&gt;?0&lt;/code&gt; ,对于true可能值为 &lt;code&gt;?1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7b12c882112937be30ce15f7fdc909be28edb8f" translate="yes" xml:space="preserve">
          <source>It is a validator, a unique string identifying the version of the resource. Conditional requests using &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">它是一个验证器，它是标识资源版本的唯一字符串。使用&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; 的&lt;/a&gt;条件请求使用此值来更改请求的行为。</target>
        </trans-unit>
        <trans-unit id="5cdf965cca7cbedbb40498332c66597692a803a9" translate="yes" xml:space="preserve">
          <source>It is a validator, the last modification date of the resource, used to compare several versions of the same resource. It is less accurate than &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but easier to calculate in some environments. Conditional requests using &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">它是一个验证器，即资源的最后修改日期，用于比较同一资源的多个版本。它不如&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;准确，但在某些环境中更易于计算。使用&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 的&lt;/a&gt;条件请求使用此值来更改请求的行为。</target>
        </trans-unit>
        <trans-unit id="9785aaf5047339a17ab49de4a65661f34c75c502" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of a protocol specification to mandate
   compliance with previous versions. HTTP/1.1 was deliberately
   designed, however, to make supporting previous versions easy. It is
   worth noting that, at the time of composing this specification
   (1996), we would expect commercial HTTP/1.1 servers to:

      - recognize the format of the Request-Line for HTTP/0.9, 1.0, and
        1.1 requests; 

      - understand any valid request in the format of HTTP/0.9, 1.0, or
        1.1;

      - respond appropriately with a message in the same major version
        used by the client.

   And we would expect HTTP/1.1 clients to:

      - recognize the format of the Status-Line for HTTP/1.0 and 1.1
        responses;

      - understand any valid response in the format of HTTP/0.9, 1.0, or
        1.1.

   For most implementations of HTTP/1.0, each connection is established
   by the client prior to the request and closed by the server after
   sending the response. Some implementations implement the Keep-Alive
   version of persistent connections described in section 19.7.1 of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">强制遵守以前的版本超出了协议规范的范围。但是，HTTP / 1.1是经过精心设计的，以简化对以前版本的支持。值得注意的是，在撰写本规范（1996年）时，我们希望商业HTTP / 1.1服务器能够：-识别HTTP / 0.9、1.0和1.1请求的请求行格式； -了解HTTP / 0.9、1.0或1.1格式的任何有效请求； -使用客户端使用的相同主要版本的消息进行适当响应。我们希望HTTP / 1.1客户端能够：-识别HTTP / 1.0和1.1响应的状态行格式； -了解HTTP / 0.9、1.0或1.1格式的任何有效响应。对于HTTP / 1.0的大多数实现，每个连接都由客户端在请求之前建立，并在服务器发送响应后关闭。一些实现实现了持久连接的Keep-Alive版本，如第19.7.1节所述。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="8259fef778fc701ed117ff363698b323da319cfd" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of this specification to describe how
   connections are established via various transport- or session-layer
   protocols.  Each connection applies to only one transport link.</source>
          <target state="translated">描述如何通过各种传输层或会话层协议建立连接,这超出了本规范的范围。每个连接只适用于一个传输链路。</target>
        </trans-unit>
        <trans-unit id="f2d087e11ffd49739b77d44827cb4d007b8288ad" translate="yes" xml:space="preserve">
          <source>It is especially important that proxies correctly implement the
   properties of the Connection header field as specified in &lt;a href=&quot;#section-14.10&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;.

   The proxy server MUST signal persistent connections separately with
   its clients and the origin servers (or other proxy servers) that it
   connects to. Each persistent connection applies to only one transport
   link.

   A proxy server MUST NOT establish a HTTP/1.1 persistent connection
   with an HTTP/1.0 client (but see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;] for information and
   discussion of the problems with the Keep-Alive header implemented by
   many HTTP/1.0 clients).</source>
          <target state="translated">代理正确实现&lt;a href=&quot;#section-14.10&quot;&gt;14.10 &lt;/a&gt;&lt;a href=&quot;#section-14.10&quot;&gt;节中&lt;/a&gt;指定的Connection标头字段的属性尤其重要。代理服务器务必用信号通知其与其客户端和其连接的原始服务器（或其他代理服务器）的持久连接。每个持久连接仅适用于一个传输链路。代理服务器不得与HTTP / 1.0客户端建立HTTP / 1.1持久连接（但请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]，以获取有关许多HTTP / 1.0客户端实现的Keep-Alive标头的信息和问题的讨论）。</target>
        </trans-unit>
        <trans-unit id="b498c25fadce9f183d82dd50870c277f51907a88" translate="yes" xml:space="preserve">
          <source>It is however still necessary for Firefox to load resources in web content under certain circumstances. For example, if you open the view source page (View Page Source or View Selection Source), you will find it requires &lt;code&gt;viewsource.css&lt;/code&gt; through a &lt;code&gt;resource:&lt;/code&gt; URI. Resources that have to be exposed to web content have been moved to a new location named &lt;code&gt;resource://content-accessible/&lt;/code&gt;, which is isolated and only contains non-sensitive resources. In this way we can keep essential resources exposed and have most threats eliminated.</source>
          <target state="translated">但是，在某些情况下，Firefox仍需要在Web内容中加载资源。例如，如果打开视图源页面（&amp;ldquo;视图页面源&amp;rdquo;或&amp;ldquo;视图选择源&amp;rdquo;），则会发现它需要通过 &lt;code&gt;resource:&lt;/code&gt; URI的 &lt;code&gt;viewsource.css&lt;/code&gt; 。必须向Web内容公开的资源已移动到名为 &lt;code&gt;resource://content-accessible/&lt;/code&gt; 的新位置，该位置是隔离的，仅包含不敏感的资源。这样，我们可以使重要资源暴露在外，并消除了大多数威胁。</target>
        </trans-unit>
        <trans-unit id="a7d678015e6dbddd6cd806a3a207ba38d15b32ae" translate="yes" xml:space="preserve">
          <source>It is important to avoid redirection loops as they completely break the user experience.</source>
          <target state="translated">避免重定向循环很重要,因为它们完全破坏了用户体验。</target>
        </trans-unit>
        <trans-unit id="9e2cb912ee31c4907225a745ba6545337d221db7" translate="yes" xml:space="preserve">
          <source>It is important to avoid redirection loops, as they completely break the user experience.</source>
          <target state="translated">避免重定向循环很重要,因为它们完全破坏了用户体验。</target>
        </trans-unit>
        <trans-unit id="7abd5b5646d7b956a07aef0207e3f862399863c2" translate="yes" xml:space="preserve">
          <source>It is possible to add a special HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element to a page to indicate what the canonical address of a page is. This has no impact on the human reader of the page, but tells search engine crawlers where the page actually lives. This way, search engines don't index the same page several times, potentially leading to it being considered as duplicate content or spam, and even removing or lowering your page from the search engine result pages.</source>
          <target state="translated">可以在页面上添加特殊的HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;元素，以指示页面的规范地址。这对网页的人类读者没有影响，但是会告诉搜索引擎搜寻器网页的实际位置。这样，搜索引擎不会多次索引同一页面，这有可能导致该页面被视为重复内容或垃圾邮件，甚至从搜索引擎结果页面中删除或降低您的页面。</target>
        </trans-unit>
        <trans-unit id="8a360170218e1e7d2c6f7cc097d32c2f58946eee" translate="yes" xml:space="preserve">
          <source>It is possible to deploy &lt;code&gt;strict-dynamic&lt;/code&gt; in a backwards compatible way, without requiring user-agent sniffing.</source>
          <target state="translated">可以以向后兼容的方式部署 &lt;code&gt;strict-dynamic&lt;/code&gt; ，而无需用户代理嗅探。</target>
        </trans-unit>
        <trans-unit id="d542c890e06636447b6f6b9d8af60c44ef672877" translate="yes" xml:space="preserve">
          <source>It is quite difficult to have a unique identifier for strong validation with &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt;. Often this is done using an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; with the MD5 hash of the resource (or a derivative).</source>
          <target state="translated">要使用&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;进行强力验证，很难有一个唯一的标识符。通常，这是通过使用带有资源（或衍生产品）的MD5哈希值的&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;来完成的。</target>
        </trans-unit>
        <trans-unit id="67317fd8b8bf14b0a6bd9419d261f53ed7a8e4f3" translate="yes" xml:space="preserve">
          <source>It takes three possible values: &lt;code&gt;Strict&lt;/code&gt;, &lt;code&gt;Lax&lt;/code&gt;, and &lt;code&gt;None&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, the cookie is sent only to the same site as the one that originated it; &lt;code&gt;Lax&lt;/code&gt; is similar, with an exception for when the user navigates to a URL from an external site, such as by following a link; &lt;code&gt;None&lt;/code&gt; has no restrictions on cross-site requests.</source>
          <target state="translated">它采用三个可能的值： &lt;code&gt;Strict&lt;/code&gt; ， &lt;code&gt;Lax&lt;/code&gt; 和 &lt;code&gt;None&lt;/code&gt; 。使用 &lt;code&gt;Strict&lt;/code&gt; ，Cookie仅发送到与它起源的站点相同的站点； &lt;code&gt;Lax&lt;/code&gt; 与之类似，但用户从外部站点导航到URL时（例如通过链接）除外。 &lt;code&gt;None&lt;/code&gt; 一个对跨站点请求没有任何限制。</target>
        </trans-unit>
        <trans-unit id="98ff32d0856e5c15bbca04673b6c6f97714c4530" translate="yes" xml:space="preserve">
          <source>It's difficult to build a website that uses all the latest best practices and provides great performance and user experiences. As the website evolves, it can become even harder to maintain the user experience over time. You can use feature policies to specify the desired best practices, and rely on the browser to enforce the policies to prevent regressions.</source>
          <target state="translated">建立一个使用所有最新的最佳实践并提供良好性能和用户体验的网站是很难的。随着网站的发展,随着时间的推移,维护用户体验会变得更加困难。您可以使用功能策略来指定所需的最佳实践,并依靠浏览器来执行策略以防止回归。</target>
        </trans-unit>
        <trans-unit id="efa57fd9b104487236e3d21ead681f7448b30db9" translate="yes" xml:space="preserve">
          <source>It's easy to find the correspondences by looking at the &lt;a href=&quot;https://hg.mozilla.org/releases&quot;&gt;Mercurial repository names&lt;/a&gt;: repositories starting by &lt;code&gt;mozilla-b2g&lt;/code&gt; are the release repositories for Firefox OS, and have both Firefox OS and Gecko versions in their names.</source>
          <target state="translated">通过查看&lt;a href=&quot;https://hg.mozilla.org/releases&quot;&gt;Mercurial存储库名称&lt;/a&gt;可以很容易地找到对应关系：以 &lt;code&gt;mozilla-b2g&lt;/code&gt; 开头的存储库是Firefox OS的发行库，名称中同时包含Firefox OS和Gecko版本。</target>
        </trans-unit>
        <trans-unit id="5250b829db5c42c7a082fb33c46a6aed6b45b478" translate="yes" xml:space="preserve">
          <source>It's important point to note that connection management in HTTP applies to the connection between two consecutive nodes, which is &lt;a href=&quot;headers#hbh&quot;&gt;hop-by-hop&lt;/a&gt; and not &lt;a href=&quot;headers#e2e&quot;&gt;end-to-end&lt;/a&gt;. The model used in connections between a client and its first proxy may differ from the model between a proxy and the destination server (or any intermediate proxies). The HTTP headers involved in defining the connection model, like &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, are &lt;a href=&quot;headers#hbh&quot;&gt;hop-by-hop&lt;/a&gt; headers with their values able to be changed by intermediary nodes.</source>
          <target state="translated">需要注意的重要一点是，HTTP中的连接管理适用于两个连续节点之间的连接，这是&lt;a href=&quot;headers#hbh&quot;&gt;逐跳&lt;/a&gt;而不是&lt;a href=&quot;headers#e2e&quot;&gt;端对端的&lt;/a&gt;。客户端与其第一代理之间的连接中使用的模型可能不同于代理与目标服务器（或任何中间代理）之间的模型。定义连接模型所涉及的HTTP标头（如&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;）是&lt;a href=&quot;headers#hbh&quot;&gt;逐跳&lt;/a&gt;标头，其值可以由中间节点更改。</target>
        </trans-unit>
        <trans-unit id="739ff299232862f99e9340517c687340775d8925" translate="yes" xml:space="preserve">
          <source>It's standard procedure to start a connection using HTTP/1.1, due to its broad support, then request an upgrade to HTTP/2. This way, you have a functioning connection still even if HTTP/2 isn't supported by the server. However, you can only upgrade to an insecure (cleartext) HTTP/2 connection. This is done using the target protocol name &lt;code&gt;h2c&lt;/code&gt;, which stands for &quot;HTTP/2 Cleartext&quot;. This also &lt;em&gt;requires&lt;/em&gt; the specification of the &lt;code&gt;HTTP2-Settings&lt;/code&gt; header field.</source>
          <target state="translated">由于它的广泛支持，因此是使用HTTP / 1.1开始连接的标准过程，然后请求升级到HTTP / 2。这样，即使服务器不支持HTTP / 2，您仍然可以正常工作。但是，您只能升级到不安全的（明文）HTTP / 2连接。这是使用目标协议名称 &lt;code&gt;h2c&lt;/code&gt; 来完成的，该名称代表&amp;ldquo; HTTP / 2明文&amp;rdquo;。这还&lt;em&gt;需要&lt;/em&gt;指定 &lt;code&gt;HTTP2-Settings&lt;/code&gt; 头字段。</target>
        </trans-unit>
        <trans-unit id="8bea6d61f9c2501d81011d81f34e205f8686dfa5" translate="yes" xml:space="preserve">
          <source>It's worth re-iterating: it's very rarely a good idea to use user agent sniffing. You can almost always find a better, more broadly compatible way to solve your problem!</source>
          <target state="translated">值得再次重申的是:使用用户代理嗅探很少是个好主意。你几乎总能找到更好、更广泛兼容的方法来解决你的问题!</target>
        </trans-unit>
        <trans-unit id="a45885aac538290762a4f7f3317abf411bb16059" translate="yes" xml:space="preserve">
          <source>JPEG</source>
          <target state="translated">JPEG</target>
        </trans-unit>
        <trans-unit id="1eed6d58a74c7c8d582fdf2be8d22bcb2c8939ca" translate="yes" xml:space="preserve">
          <source>JPEG images</source>
          <target state="translated">JPEG图像</target>
        </trans-unit>
        <trans-unit id="5766bfd5841dee1b6f2aaf89bbb921f60e7d1b6f" translate="yes" xml:space="preserve">
          <source>JSON format</source>
          <target state="translated">JSON格式</target>
        </trans-unit>
        <trans-unit id="a66f05ea5cca9de68a33b0638207bfbcd5641141" translate="yes" xml:space="preserve">
          <source>JSON-LD format</source>
          <target state="translated">JSON-LD格式</target>
        </trans-unit>
        <trans-unit id="eb7b5a55874bccbd5415aa333ebe2f4d5bc10f49" translate="yes" xml:space="preserve">
          <source>Java Archive (JAR)</source>
          <target state="translated">Java档案(JAR)</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="0bd88372ee65c120d42e02af79e6d6a3eb158cea" translate="yes" xml:space="preserve">
          <source>JavaScript (&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/javascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; Specification&lt;/em&gt;&lt;/a&gt;) (&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 Section 8.2&lt;/a&gt;)</source>
          <target state="translated">JavaScript（&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/javascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt;规范&lt;/em&gt;&lt;/a&gt;）（&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329第8.2节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="14198645a38762965b009588906bec6466424e7f" translate="yes" xml:space="preserve">
          <source>JavaScript access using &lt;code&gt;Document.cookie&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;Document.cookie&lt;/code&gt; 的 JavaScript访问</target>
        </trans-unit>
        <trans-unit id="f2e6e6231b726f3003de6b6cd95b2a1228b3c146" translate="yes" xml:space="preserve">
          <source>JavaScript access using Document.cookie</source>
          <target state="translated">使用Document.cookie访问JavaScript</target>
        </trans-unit>
        <trans-unit id="02726ffcb85ce089b78555f5977ff60b7b1e1236" translate="yes" xml:space="preserve">
          <source>JavaScript files</source>
          <target state="translated">JavaScript文件</target>
        </trans-unit>
        <trans-unit id="0394a047be98486e114cae8247a6233e345b8672" translate="yes" xml:space="preserve">
          <source>JavaScript module</source>
          <target state="translated">JavaScript模块</target>
        </trans-unit>
        <trans-unit id="3be64216bdf0b966d93ddd891c18c487fb2b9ae8" translate="yes" xml:space="preserve">
          <source>JavaScript redirections</source>
          <target state="translated">JavaScript重定向</target>
        </trans-unit>
        <trans-unit id="9495512a0ffe6408bf56b96c0f685997352e9772" translate="yes" xml:space="preserve">
          <source>JavaScript redirections via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;</source>
          <target state="translated">通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM进行&lt;/a&gt;JavaScript重定向</target>
        </trans-unit>
        <trans-unit id="8a908fed06c72f5e490a9950a8717a85839ac02f" translate="yes" xml:space="preserve">
          <source>JavaScript redirects are used as the last resort, and only if JavaScript is enabled on the client side.</source>
          <target state="translated">JavaScript重定向作为最后的手段,只有在客户端启用JavaScript时才会使用。</target>
        </trans-unit>
        <trans-unit id="047107c9d905d625d42fe9a86dcfdf5bbd7aed84" translate="yes" xml:space="preserve">
          <source>JavaScript redirects execute last, and only if JavaScript is enabled.</source>
          <target state="translated">JavaScript重定向最后执行,而且只有在JavaScript被启用的情况下。</target>
        </trans-unit>
        <trans-unit id="8a51f0d37d8a868b09fd7045118623248a30aff4" translate="yes" xml:space="preserve">
          <source>JavaScript types</source>
          <target state="translated">JavaScript类型</target>
        </trans-unit>
        <trans-unit id="25e0c3834572e2b5f374c1a40ffbd07f94e13112" translate="yes" xml:space="preserve">
          <source>Joint Photographic Expert Group image</source>
          <target state="translated">联合摄影专家组形象</target>
        </trans-unit>
        <trans-unit id="b2bea8b7008e2db2d0b0548f31cebaf54a8e8d9f" translate="yes" xml:space="preserve">
          <source>Julian Reschke
   &amp;lt;green/&amp;gt;bytes GmbH
   Hafenweg 16, 48155 Muenster, Germany
   EMail: julian.reschke@greenbytes.de


   Elias Sinderson
   University of California, Santa Cruz
   1156 High Street, Santa Cruz, CA 95064
   EMail: elias@cse.ucsc.edu


   Jim Whitehead
   University of California, Santa Cruz
   1156 High Street, Santa Cruz, CA 95064
   EMail: ejw@soe.ucsc.edu</source>
          <target state="translated">Julian Reschke &amp;lt;green /&amp;gt; bytes GmbH德国芬斯特Hafenweg 16，48155电子邮件：julian.reschke@greenbytes.de加利福尼亚州圣克鲁斯市埃里亚斯&amp;middot;辛德森大学1156 High Street，圣克鲁斯，CA 95064电子邮件：elias@cse.ucsc.edu吉姆怀特海德加利福尼亚大学圣克鲁斯分校1156 High Street，圣克鲁斯，CA 95064电子邮件：ejw@soe.ucsc.edu</target>
        </trans-unit>
        <trans-unit id="9c89e4dc68bedeca878534384b26901da1f8442a" translate="yes" xml:space="preserve">
          <source>Just as in HTTP/1, a header field in HTTP/2 is a name with one or
   more associated values.  Header fields are used within HTTP request
   and response messages as well as in server push operations (see
   &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;).

   Header lists are collections of zero or more header fields.  When
   transmitted over a connection, a header list is serialized into a
   header block using HTTP header compression [&lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt;].  The
   serialized header block is then divided into one or more octet
   sequences, called header block fragments, and transmitted within the
   payload of HEADERS (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;), PUSH_PROMISE (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;), or
   CONTINUATION (&lt;a href=&quot;#section-6.10&quot;&gt;Section 6.10&lt;/a&gt;) frames.

   The Cookie header field [&lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt;] is treated specially by the HTTP
   mapping (see &lt;a href=&quot;#section-8.1.2.5&quot;&gt;Section 8.1.2.5&lt;/a&gt;).

   A receiving endpoint reassembles the header block by concatenating
   its fragments and then decompresses the block to reconstruct the
   header list.

   A complete header block consists of either:

   o  a single HEADERS or PUSH_PROMISE frame, with the END_HEADERS flag
      set, or

   o  a HEADERS or PUSH_PROMISE frame with the END_HEADERS flag cleared
      and one or more CONTINUATION frames, where the last CONTINUATION
      frame has the END_HEADERS flag set.

   Header compression is stateful.  One compression context and one
   decompression context are used for the entire connection.  A decoding
   error in a header block MUST be treated as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type COMPRESSION_ERROR.

   Each header block is processed as a discrete unit.  Header blocks
   MUST be transmitted as a contiguous sequence of frames, with no
   interleaved frames of any other type or from any other stream.  The
   last frame in a sequence of HEADERS or CONTINUATION frames has the 

   END_HEADERS flag set.  The last frame in a sequence of PUSH_PROMISE
   or CONTINUATION frames has the END_HEADERS flag set.  This allows a
   header block to be logically equivalent to a single frame.

   Header block fragments can only be sent as the payload of HEADERS,
   PUSH_PROMISE, or CONTINUATION frames because these frames carry data
   that can modify the compression context maintained by a receiver.  An
   endpoint receiving HEADERS, PUSH_PROMISE, or CONTINUATION frames
   needs to reassemble header blocks and perform decompression even if
   the frames are to be discarded.  A receiver MUST terminate the
   connection with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   COMPRESSION_ERROR if it does not decompress a header block.</source>
          <target state="translated">就像在HTTP / 1中一样，HTTP / 2中的标头字段是具有一个或多个关联值的名称。标头字段在HTTP请求和响应消息以及服务器推送操作中使用（请参见&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节&lt;/a&gt;）。标头列表是零个或多个标头字段的集合。通过连接传输时，头文件列表会使用HTTP头文件压缩[ &lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt; ]序列化为头文件块。然后，已序列化的标题块被分为一个或多个八位位组序列，称为标题块片段，并在HEADERS（&lt;a href=&quot;#section-6.2&quot;&gt;第6.2节&lt;/a&gt;），PUSH_PROMISE（&lt;a href=&quot;#section-6.6&quot;&gt;第6.6节&lt;/a&gt;）或CONTINUATION（&lt;a href=&quot;#section-6.10&quot;&gt;第6.10节&lt;/a&gt;）帧的有效载荷内传输。 Cookie标头字段[ &lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt;]由HTTP映射特别处理（请参阅&lt;a href=&quot;#section-8.1.2.5&quot;&gt;第8.1.2.5节&lt;/a&gt;）。接收端点通过串联其片段来重组头块，然后解压缩该块以重建头列表。一个完整的标头块包括：单个HEADERS或PUSH_PROMISE帧（设置了END_HEADERS标志），或oa HEADERS或PUSH_PROMISE帧，清除了END_HEADERS标志以及一个或多个CONTINUATION帧，其中最后一个CONTINUATION帧设置了END_HEADERS标志。标头压缩是有状态的。一个压缩上下文和一个解压缩上下文用于整个连接。报头块中的解码错误必须被视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节）&lt;/a&gt;），类型为COMPRESSION_ERROR。每个标题块都作为离散单元进行处理。报头块必须作为连续的帧序列发送，没有任何其他类型或来自任何其他流的交织帧。 HEADERS或CONTINUATION帧序列中的最后一帧设置了END_HEADERS标志。 PUSH_PROMISE或CONTINUATION帧序列中的最后一个帧设置了END_HEADERS标志。这允许报头块在逻辑上等效于单个帧。报头块片段只能作为HEADERS，PUSH_PROMISE或CONTINUATION帧的有效载荷发送，因为这些帧承载的数据可以修改接收方维护的压缩上下文。即使要丢弃帧，接收HEADERS，PUSH_PROMISE或CONTINUATION帧的端点也需要重新组装头块并执行解压缩。接收方务必以连接错误终止连接（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;如果未解压缩标头块，则为COMPRESSION_ERROR类型的5.4.1节）。</target>
        </trans-unit>
        <trans-unit id="7e8b1d0fc088bb90dbbe8a2dbd8d00105aebfdf3" translate="yes" xml:space="preserve">
          <source>Keep-Alive</source>
          <target state="translated">Keep-Alive</target>
        </trans-unit>
        <trans-unit id="6146b34bc65ee03e10bb0d16dc15637d8d926be2" translate="yes" xml:space="preserve">
          <source>Keep-Alive Header (IETF Internet Draft)</source>
          <target state="translated">Keep-Alive头(IETF互联网草案)</target>
        </trans-unit>
        <trans-unit id="518fe23acc32b680b6c7064b18768ce9a4edc6c7" translate="yes" xml:space="preserve">
          <source>Keeping links alive</source>
          <target state="translated">保持链接的活力</target>
        </trans-unit>
        <trans-unit id="0b80404ac1f938e0ad58d9a575e0e0aa00a66dd0" translate="yes" xml:space="preserve">
          <source>Kind of document</source>
          <target state="translated">文件种类</target>
        </trans-unit>
        <trans-unit id="471e7dd9c2f2d4bd1722ed06bd63bae32d792b07" translate="yes" xml:space="preserve">
          <source>Klar Version (Rendering Engine)</source>
          <target state="translated">Klar版本(渲染引擎</target>
        </trans-unit>
        <trans-unit id="53a344b79c8c2c1639455bd4ca9631b250cbb736" translate="yes" xml:space="preserve">
          <source>Klar for Android</source>
          <target state="translated">Klar for Android</target>
        </trans-unit>
        <trans-unit id="1cfc0d8b05e463c4269f42611f344e37e54aaf18" translate="yes" xml:space="preserve">
          <source>Konqueror 4.6</source>
          <target state="translated">Konqueror 4.6</target>
        </trans-unit>
        <trans-unit id="1971c93380e2bf924d413b56239bd916d71c69a0" translate="yes" xml:space="preserve">
          <source>Lack of error handling</source>
          <target state="translated">缺乏错误处理</target>
        </trans-unit>
        <trans-unit id="3df68e70fa194f3c844cf64d5417d8356ae60b51" translate="yes" xml:space="preserve">
          <source>Large message body</source>
          <target state="translated">大信息体</target>
        </trans-unit>
        <trans-unit id="aba1a47c51ae2e1013a1da8b769f84aea5b8154d" translate="yes" xml:space="preserve">
          <source>Large-Allocation</source>
          <target state="translated">Large-Allocation</target>
        </trans-unit>
        <trans-unit id="4312b9cdc22a0d8cf25ab213c9d034cee9ce16ee" translate="yes" xml:space="preserve">
          <source>Last-Modified</source>
          <target state="translated">Last-Modified</target>
        </trans-unit>
        <trans-unit id="5ad73a8c3ddef48b03c719ec7b68bf049b1d82e3" translate="yes" xml:space="preserve">
          <source>Last-Modified (RFC 2616)</source>
          <target state="translated">最后修改 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="99e5db4754c5b7e5f7aa2bb6b93799f72088bd2e" translate="yes" xml:space="preserve">
          <source>Last-Modified (RFC 7232)</source>
          <target state="translated">最后修改 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="47055864cbe7192dae27bdfff260957e5075db67" translate="yes" xml:space="preserve">
          <source>Lastly, the above code snippets bring about a critical issue with cross-browser coding that must always be taken into account. Don't unintentionally use the API you are testing for in unsupported browsers. This may sound obvious and simple, but sometimes it is not. For example, in the above code snippets, using lookbehind in short-regexp notation (e.g. /reg/igm) will cause a parser error in unsupported browsers. Thus, in the above example, you would use &lt;em&gt;new RegExp(&quot;(?&amp;lt;=look_behind_stuff)&quot;);&lt;/em&gt; instead of &lt;em&gt;/(?&amp;lt;=look_behind_stuff)/&lt;/em&gt;, even in the lookbehind supported section of your code.</source>
          <target state="translated">最后，上述代码段带来了跨浏览器编码的关键问题，必须始终予以考虑。不要在不受支持的浏览器中无意中使用要测试的API。这听起来似乎很简单，但有时却并非如此。例如，在上面的代码段中，以短正则表达式（例如/ reg / igm）使用lookbehind将在不支持的浏览器中导致解析器错误。因此，在上面的示例中，您将使用&lt;em&gt;new RegExp（&amp;ldquo;（?? == look_behind_stuff）&amp;rdquo;）;&lt;/em&gt;而不是&lt;em&gt;/（？&amp;lt;= look_behind_stuff）/&lt;/em&gt;，即使在代码的受支持的&lt;em&gt;后面&lt;/em&gt;部分中也是如此。</target>
        </trans-unit>
        <trans-unit id="eafc1856088b0c25b5dc46fcf0e9827359916eb5" translate="yes" xml:space="preserve">
          <source>Layout-inducing Animations</source>
          <target state="translated">布局诱导动画</target>
        </trans-unit>
        <trans-unit id="2c4b740fafd105be97b958562b8d0b2c61b96ad1" translate="yes" xml:space="preserve">
          <source>Layout-inducing animations</source>
          <target state="translated">诱导布局的动画</target>
        </trans-unit>
        <trans-unit id="002f595b3413c96ece78e3ec6628adfe5d342941" translate="yes" xml:space="preserve">
          <source>Lazyload</source>
          <target state="translated">Lazyload</target>
        </trans-unit>
        <trans-unit id="a40fd5847ed3e1026e0e2408645ee12816f7b517" translate="yes" xml:space="preserve">
          <source>Learn about: Content Security Policy</source>
          <target state="translated">了解一下。内容安全政策</target>
        </trans-unit>
        <trans-unit id="4c1df5a82059a1ccfbe352d4ab0834213813478b" translate="yes" xml:space="preserve">
          <source>Learn how to use HTTP with guides and tutorials.</source>
          <target state="translated">通过指南和教程了解如何使用HTTP。</target>
        </trans-unit>
        <trans-unit id="14b20b4a9f9427cb013c488330c0a01cc370bf8c" translate="yes" xml:space="preserve">
          <source>Legacy image formats</source>
          <target state="translated">传统的图像格式</target>
        </trans-unit>
        <trans-unit id="55585bc793f35049b20c241f9615d3aad00963a1" translate="yes" xml:space="preserve">
          <source>Legislation or regulations that cover the use of cookies include:</source>
          <target state="translated">涉及使用cookies的立法或条例包括:</target>
        </trans-unit>
        <trans-unit id="657da249aededaf980a2d1ed290fee63a37d340e" translate="yes" xml:space="preserve">
          <source>Length limitations</source>
          <target state="translated">长度限制</target>
        </trans-unit>
        <trans-unit id="abe8b1855b255aecb73e65c60887adb2dd17eb4f" translate="yes" xml:space="preserve">
          <source>Length limited to 4096 bytes</source>
          <target state="translated">长度限制为4096字节</target>
        </trans-unit>
        <trans-unit id="5084aa81ee35e345974545e25d8c6c32ab615e45" translate="yes" xml:space="preserve">
          <source>Let us look at what the browser will send to the server in this case, and let's see how the server responds:</source>
          <target state="translated">让我们看看在这种情况下,浏览器会向服务器发送什么,让我们看看服务器是如何响应的。</target>
        </trans-unit>
        <trans-unit id="fa210c261a8eda6a3085253bdfc33931dfb0a50f" translate="yes" xml:space="preserve">
          <source>Let's consider a page located at &lt;code&gt;&lt;a href=&quot;http://example.com/signup.html&quot;&gt;http://example.com/signup.html&lt;/a&gt;&lt;/code&gt;. It uses the following policy, disallowing everything but stylesheets from &lt;code&gt;cdn.example.com&lt;/code&gt;.</source>
          <target state="translated">让我们考虑一个位于 &lt;code&gt;&lt;a href=&quot;http://example.com/signup.html&quot;&gt;http://example.com/signup.html&lt;/a&gt;&lt;/code&gt; 的页面。它使用以下策略， &lt;code&gt;cdn.example.com&lt;/code&gt; 样式表外，不包含任何内容。</target>
        </trans-unit>
        <trans-unit id="152516c7d9cfd6fae5d3a79c8e35a362dbc55ac2" translate="yes" xml:space="preserve">
          <source>Let's consider a page located at &lt;code&gt;http://example.com/signup.html&lt;/code&gt;. It uses the following policy, disallowing everything but stylesheets from &lt;code&gt;cdn.example.com&lt;/code&gt;.</source>
          <target state="translated">让我们考虑一个位于 &lt;code&gt;http://example.com/signup.html&lt;/code&gt; 的页面。它使用以下策略， &lt;code&gt;cdn.example.com&lt;/code&gt; 样式表外，不包含任何内容。</target>
        </trans-unit>
        <trans-unit id="adad50c91bb6c2e681c25e53578bd93aba54f1ba" translate="yes" xml:space="preserve">
          <source>Let's look at an example of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; involving &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;.</source>
          <target state="translated">让我们看一个涉及 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;示例。</target>
        </trans-unit>
        <trans-unit id="442acc84011b22aa128b910d7dd61aeabb2c24b6" translate="yes" xml:space="preserve">
          <source>Let's look at an example of a preflight request involving &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;.</source>
          <target state="translated">让我们看一个涉及 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 的预检请求示例。</target>
        </trans-unit>
        <trans-unit id="a6f2cc4219a3b1353640b6f36885fb2d82681621" translate="yes" xml:space="preserve">
          <source>Let's look at the full exchange between client and server. The first exchange is the &lt;em&gt;preflight request/response&lt;/em&gt;:</source>
          <target state="translated">让我们看一下客户端和服务器之间的完整交换。第一个交换是&lt;em&gt;预检请求/响应&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="e42d1be5f2d0916b7b05c410c632eba10326aa68" translate="yes" xml:space="preserve">
          <source>Let's look at what the browser will send to the server in this case, and let's see how the server responds:</source>
          <target state="translated">让我们看看在这种情况下,浏览器会向服务器发送什么,让我们看看服务器是如何响应的。</target>
        </trans-unit>
        <trans-unit id="928b6441798d4590009f5cc1febcd4f4cc9b6912" translate="yes" xml:space="preserve">
          <source>Let's say a site's API can return data in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XML&quot;&gt;XML&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma-separated_values&quot;&gt;CSV&lt;/a&gt; formats. If the URL for a particular document is at &lt;code&gt;https://example.com/documents/foo&lt;/code&gt;, the site could return different URLs for &lt;code&gt;Content-Location&lt;/code&gt; depending on the request's &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="translated">假设某个网站的API可以返回&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XML&quot;&gt;XML&lt;/a&gt;或&lt;a href=&quot;https://en.wikipedia.org/wiki/Comma-separated_values&quot;&gt;CSV&lt;/a&gt;格式的数据。如果特定文档的URL位于 &lt;code&gt;https://example.com/documents/foo&lt;/code&gt; ，则该站点可以根据请求的&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;标头返回 &lt;code&gt;Content-Location&lt;/code&gt; 的不同URL ：</target>
        </trans-unit>
        <trans-unit id="a649ee77f17b9ff4d60ac31c6bda763b09061da1" translate="yes" xml:space="preserve">
          <source>Let's take a look at the full exchange between client and server. The first exchange is the &lt;em&gt;preflight request/response&lt;/em&gt;:</source>
          <target state="translated">让我们看一下客户端和服务器之间的完整交换。第一个交换是&lt;em&gt;预检请求/响应&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="e07eff52aa81cb70622273914da9f4d944a0a8a8" translate="yes" xml:space="preserve">
          <source>Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.</source>
          <target state="translated">让资源导航到顶层浏览上下文,但只有在用户手势启动的情况下。</target>
        </trans-unit>
        <trans-unit id="e749390204ffe84807c0bf8aa779eaba96be86a5" translate="yes" xml:space="preserve">
          <source>Lets the resource request access to the parent's storage capabilities with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API&quot;&gt;Storage Access API&lt;/a&gt;.</source>
          <target state="translated">允许资源使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API&quot;&gt;Storage Access API&lt;/a&gt;请求访问父级的存储功能。</target>
        </trans-unit>
        <trans-unit id="095cbdfe7047e224c585adc3fd8460ae3e349338" translate="yes" xml:space="preserve">
          <source>Library and net tool UA strings</source>
          <target state="translated">图书馆和网络工具UA字符串</target>
        </trans-unit>
        <trans-unit id="76d8e88746aed29c5732084d86f85c42f51868b5" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.</source>
          <target state="translated">根据知识共享署名-相同方式共享许可协议V2.5或更高版本授权。</target>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="9f3f4cf072da64f11ef4837f26d8ed4cef440ef9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;must-revalidate&lt;/code&gt;, but only for shared caches (e.g., proxies). Ignored by private caches.</source>
          <target state="translated">类似于 &lt;code&gt;must-revalidate&lt;/code&gt; ，但仅适用于共享缓存（例如代理）。被私有缓存忽略。</target>
        </trans-unit>
        <trans-unit id="b82d716bd3bf87fe044e3e34804e6da8259e4d37" translate="yes" xml:space="preserve">
          <source>Like HTML redirections, this can't work on all resources, and obviously, this will only work on clients that execute JavaScript. On the other hand, there are more possibilities: for example, you can trigger the redirect only if some conditions are met.</source>
          <target state="translated">就像HTML重定向一样,这不可能对所有的资源都有效,很明显,这只对执行JavaScript的客户端有效。另一方面,还有更多的可能性:例如,你可以只在满足某些条件时才触发重定向。</target>
        </trans-unit>
        <trans-unit id="db10ddafdbaf44fe84055e66ecf49ecd6e6f7755" translate="yes" xml:space="preserve">
          <source>Like HTML redirections, this can't work on all resources, and obviously, this will only work on clients that execute JavaScript. On the other side, there are more possibilities as you can trigger the redirection only if some conditions are met, for example.</source>
          <target state="translated">就像HTML重定向一样,这不可能对所有资源都有效,很明显,这只对执行JavaScript的客户端有效。另一方面,有更多的可能性,因为你可以只在满足某些条件的情况下触发重定向,例如。</target>
        </trans-unit>
        <trans-unit id="70be75ce577f3ebafccca55b5df13ee8aef2157c" translate="yes" xml:space="preserve">
          <source>Like any generic data transfer protocol, HTTP cannot regulate the
   content of the data that is transferred, nor is there any a priori
   method of determining the sensitivity of any particular piece of
   information within the context of any given request. Therefore,
   applications SHOULD supply as much control over this information as
   possible to the provider of that information. Four header fields are
   worth special mention in this context: Server, Via, Referer and From.

   Revealing the specific software version of the server might allow the
   server machine to become more vulnerable to attacks against software
   that is known to contain security holes. Implementors SHOULD make the
   Server header field a configurable option.

   Proxies which serve as a portal through a network firewall SHOULD
   take special precautions regarding the transfer of header information
   that identifies the hosts behind the firewall. In particular, they
   SHOULD remove, or replace with sanitized versions, any Via fields
   generated behind the firewall.

   The Referer header allows reading patterns to be studied and reverse
   links drawn. Although it can be very useful, its power can be abused
   if user details are not separated from the information contained in 

   the Referer. Even when the personal information has been removed, the
   Referer header might indicate a private document's URI whose
   publication would be inappropriate.

   The information sent in the From field might conflict with the user's
   privacy interests or their site's security policy, and hence it
   SHOULD NOT be transmitted without the user being able to disable,
   enable, and modify the contents of the field. The user MUST be able
   to set the contents of this field within a user preference or
   application defaults configuration.

   We suggest, though do not require, that a convenient toggle interface
   be provided for the user to enable or disable the sending of From and
   Referer information.

   The User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;) or Server (&lt;a href=&quot;#section-14.38&quot;&gt;section 14.38&lt;/a&gt;) header
   fields can sometimes be used to determine that a specific client or
   server have a particular security hole which might be exploited.
   Unfortunately, this same information is often used for other valuable
   purposes for which HTTP currently has no better mechanism.</source>
          <target state="translated">像任何通用数据传输协议一样，HTTP无法调节所传输数据的内容，也没有任何先验的方法可以在任何给定请求的上下文中确定任何特定信息的敏感度。因此，应用程序应该对该信息的提供者提供尽可能多的对该信息的控制。在这种情况下，有四个头字段值得特别提及：服务器，通过，引用和发件人。揭示服务器的特定软件版本可能会使服务器计算机更容易受到针对已知包含安全漏洞的软件的攻击。实施者应该使服务器头字段成为可配置的选项。通过网络防火墙充当门户的代理应特别注意标头信息的传输，以识别防火墙后面的主机。特别是，它们应该删除防火墙后生成的任何&amp;ldquo;通过&amp;rdquo;字段，或以经过清理的版本替换。 Referer标头允许研究阅读模式并绘制反向链接。尽管它可能非常有用，但是如果用户详细信息未与Referer中包含的信息分开，则可能会滥用其功能。即使删除了个人信息，Referer标头也可能指示私有文档的URI，其发布将不适当。在&amp;ldquo;发件人&amp;rdquo;字段中发送的信息可能与用户的隐私权或其网站的安全政策冲突，因此，如果用户无法禁用，启用和修改该字段的内容，则不应传输该内容。用户必须能够在用户首选项或应用程序默认配置中设置此字段的内容。我们建议（尽管不要求）提供一个方便的切换界面，供用户启用或禁用&amp;ldquo;发件人&amp;rdquo;和&amp;ldquo;引荐来源&amp;rdquo;信息的发送。用户代理（为用户提供了方便的切换界面，以启用或禁用发件人和引荐来源信息的发送。用户代理（为用户提供了方便的切换界面，以启用或禁用发件人和引荐来源信息的发送。用户代理（&lt;a href=&quot;#section-14.43&quot;&gt;第14.43节&lt;/a&gt;）或服务器（&lt;a href=&quot;#section-14.38&quot;&gt;第14.38节&lt;/a&gt;）标头字段有时可用于确定特定的客户端或服务器具有可能被利用的特定安全漏洞。不幸的是，这些相同的信息经常被用于其他有价值的目的，而HTTP目前还没有更好的机制。</target>
        </trans-unit>
        <trans-unit id="de09479df824aa67e637b0690aa7154dd273d917" translate="yes" xml:space="preserve">
          <source>Like images, HTML doesn't define supported types for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, so only some can be used on the Web. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats&quot;&gt;Media formats supported by the HTML audio and video elements&lt;/a&gt; explains both the codecs and container formats which can be used.</source>
          <target state="translated">与图像一样，HTML并未为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素定义受支持的类型，因此在Web上只能使用某些类型。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats&quot;&gt;HTML音频和视频元素支持的媒体格式&lt;/a&gt;说明了可以使用的编解码器和容器格式。</target>
        </trans-unit>
        <trans-unit id="b17f9b3a3f5f94964505eae8dc076c8167b437f2" translate="yes" xml:space="preserve">
          <source>Like in all cases, these strings may change in the future, one should use them only in conjunction with the detection of already released browsers. A technological survey must be in place to adapt the script when new browser versions are coming out.</source>
          <target state="translated">和所有情况一样,这些字符串在未来可能会发生变化,人们应该只在检测已经发布的浏览器时才使用它们。当新的浏览器版本出来时,必须进行技术调查,以调整脚本。</target>
        </trans-unit>
        <trans-unit id="c3f7813f6513530fae5d20c357e1018dfbdab752" translate="yes" xml:space="preserve">
          <source>Like the compress program, which has disappeared from most UNIX distributions, this content-encoding is used by almost no browsers today, partly because of a patent issue (which expired in 2003).</source>
          <target state="translated">就像已经从大多数UNIX发行版中消失的压缩程序一样,今天几乎没有浏览器使用这种内容编码,部分原因是专利问题(2003年到期)。</target>
        </trans-unit>
        <trans-unit id="c924aeab714bffe66c4c22bc5d8bd00099533380" translate="yes" xml:space="preserve">
          <source>Limiting the possible &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; values to a set of allowed origins requires code on the server side to check the value of the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header, compare that to a list of allowed origins, and then if the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; value is in the list, to set the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">将可能的 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 值限制为一组允许的来源，要求服务器端的代码检查&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;请求头的值，将其与允许的来源列表进行比较，然后检查&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; 的&lt;/a&gt;值是否在在列表中，将 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 值设置为与&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;值相同的值。</target>
        </trans-unit>
        <trans-unit id="a118fb8cb53f5dd1fc14f29be01804384762f7e9" translate="yes" xml:space="preserve">
          <source>Line 7 shows the flag on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; that has to be set in order to make the invocation with Cookies, namely the &lt;code&gt;withCredentials&lt;/code&gt; boolean value. By default, the invocation is made without Cookies. Since this is a simple &lt;code&gt;GET&lt;/code&gt; request, it is not preflighted, but the browser will &lt;strong&gt;reject&lt;/strong&gt; any response that does not have the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header, and &lt;strong&gt;not&lt;/strong&gt; make the response available to the invoking web content.</source>
          <target state="translated">第7行显示&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;上的标志，必须设置该标志才能使用Cookie进行调用，即 &lt;code&gt;withCredentials&lt;/code&gt; 布尔值。默认情况下，调用是在不使用Cookie的情况下进行的。由于这是一个简单的 &lt;code&gt;GET&lt;/code&gt; 请求，因此不会进行预检，但是浏览器将&lt;strong&gt;拒绝&lt;/strong&gt;任何没有&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; 标头的响应，并且&lt;strong&gt;不会&lt;/strong&gt;使响应可用于调用Web内容。</target>
        </trans-unit>
        <trans-unit id="afff9baac3ee3d5a86ba3d479a5d4eb896a2ee71" translate="yes" xml:space="preserve">
          <source>Lines 1 - 10 above represent the preflight request with the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method. The browser determines that it needs to send this based on the request parameters that the JavaScript code snippet above was using, so that the server can respond whether it is acceptable to send the request with the actual request parameters. OPTIONS is an HTTP/1.1 method that is used to determine further information from servers, and is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, meaning that it can't be used to change the resource. Note that along with the OPTIONS request, two other request headers are sent (lines 9 and 10 respectively):</source>
          <target state="translated">上面的1-10行代表使用&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;方法的预检请求。浏览器根据上面的JavaScript代码段所使用的请求参数确定是否需要发送此请求，以便服务器可以响应是否可以使用实际请求参数发送请求。 OPTIONS是一种HTTP / 1.1方法，用于确定来自服务器的更多信息，并且是一种&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;方法，这意味着它不能用于更改资源。请注意，与OPTIONS请求一起，还发送了另外两个请求标头（分别是第9行和第10行）：</target>
        </trans-unit>
        <trans-unit id="3e4ad5eac403df09e0c0c7d48c364588c499b639" translate="yes" xml:space="preserve">
          <source>Lines 1 - 10 are headers sent. The main HTTP request header of note here is the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header on line 10 above, which shows that the invocation is coming from content on the domain &lt;code&gt;http://foo.example&lt;/code&gt;.</source>
          <target state="translated">第1-10行是已发送的标头。注意，这里的主要HTTP请求标头是上面第10行上的&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;标头，它表明调用来自域 &lt;code&gt;http://foo.example&lt;/code&gt; 上的内容。</target>
        </trans-unit>
        <trans-unit id="a288b2c5ce1d7dc2f4906f2097cd01bf3ad43ed7" translate="yes" xml:space="preserve">
          <source>Lines 1 - 12 above represent the preflight request with the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method. The browser determines that it needs to send this based on the request parameters that the JavaScript code snippet above was using, so that the server can respond whether it is acceptable to send the request with the actual request parameters. OPTIONS is an HTTP/1.1 method that is used to determine further information from servers, and is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, meaning that it can't be used to change the resource. Note that along with the OPTIONS request, two other request headers are sent (lines 10 and 11 respectively):</source>
          <target state="translated">上面的1-12行代表使用&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;方法的飞行前请求。浏览器根据上面的JavaScript代码段所使用的请求参数确定是否需要发送此请求，以便服务器可以响应是否可以使用实际请求参数发送请求。 OPTIONS是一种HTTP / 1.1方法，用于确定来自服务器的更多信息，并且是一种&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;方法，这意味着它不能用于更改资源。请注意，与OPTIONS请求一起，还发送了另外两个请求标头（分别是第10行和第11行）：</target>
        </trans-unit>
        <trans-unit id="755ba040dbf11df7afee309c945c9ca76a93a22e" translate="yes" xml:space="preserve">
          <source>Lines 13 - 22 above are the response that the server sends back, which indicate that the request method (&lt;code&gt;POST&lt;/code&gt;) and request headers (&lt;code&gt;X-PINGOTHER&lt;/code&gt;) are acceptable. In particular, let's look at lines 16-19:</source>
          <target state="translated">上面的第13至22行是服务器发回的响应，指示请求方法（ &lt;code&gt;POST&lt;/code&gt; ）和请求标头（ &lt;code&gt;X-PINGOTHER&lt;/code&gt; ）是可接受的。特别地，让我们看一下第16-19行：</target>
        </trans-unit>
        <trans-unit id="656e5cef78d93570c111bd1f498ea5a75f7e0f4b" translate="yes" xml:space="preserve">
          <source>Lines 13 - 22 show the HTTP response from the server on domain &lt;code&gt;http://bar.other&lt;/code&gt;. In response, the server sends back an &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, shown above in line 16. The use of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header and of &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; show the access control protocol in its simplest use. In this case, the server responds with a &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; which means that the resource can be accessed by &lt;strong&gt;any&lt;/strong&gt; domain in a cross-site manner. If the resource owners at &lt;code&gt;http://bar.other&lt;/code&gt; wished to restrict access to the resource to requests only from &lt;code&gt;http://foo.example&lt;/code&gt;, they would send back:</source>
          <target state="translated">第13-22行显示了来自域 &lt;code&gt;http://bar.other&lt;/code&gt; 上服务器的HTTP响应。作为响应，服务器发回一个&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;标头，如上面的第16行所示&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;标头和&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 的使用&lt;/a&gt;显示了最简单的访问控制协议。在这种情况下，服务器将以 &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; 进行响应，这意味着&lt;strong&gt;任何&lt;/strong&gt;域都可以以跨站点的方式访问资源。如果位于 &lt;code&gt;http://bar.other&lt;/code&gt; 的资源所有者希望将对资源的访问限制为仅来自 &lt;code&gt;http://foo.example&lt;/code&gt; 的请求，则他们将发送回：</target>
        </trans-unit>
        <trans-unit id="0936ed44f0ff243a8948b7ff1f3424ae3dd946dd" translate="yes" xml:space="preserve">
          <source>Lines 14 - 26 above are the response that the server sends back indicating that the request method (&lt;code&gt;POST&lt;/code&gt;) and request headers (&lt;code&gt;X-PINGOTHER&lt;/code&gt;) are acceptable. In particular, let's look at lines 17-20:</source>
          <target state="translated">上面的第14至26行是服务器发回的响应，指示请求方法（ &lt;code&gt;POST&lt;/code&gt; ）和请求标头（ &lt;code&gt;X-PINGOTHER&lt;/code&gt; ）是可接受的。特别地，让我们看一下第17-20行：</target>
        </trans-unit>
        <trans-unit id="d0517071aa376e797705058bbad4b658954b9930" translate="yes" xml:space="preserve">
          <source>Link</source>
          <target state="translated">Link</target>
        </trans-unit>
        <trans-unit id="aa65b658f4f7a0604beb1fd4219975007f50e35a" translate="yes" xml:space="preserve">
          <source>Linked Data Platform 1.0, Section 7.1: The Accept-Post Response Header</source>
          <target state="translated">关联数据平台1.0,第7.1节。接受-发布响应头</target>
        </trans-unit>
        <trans-unit id="82027c0f9c7057e65bf210d13353910e8d71c0f4" translate="yes" xml:space="preserve">
          <source>Links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;.</source>
          <target state="translated">将生成的代码链接到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;源映射&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="319f6b56be87378e2eef2436fa7e744a9edd1729" translate="yes" xml:space="preserve">
          <source>Linux desktop on i686 CPU</source>
          <target state="translated">i686 CPU上的Linux桌面</target>
        </trans-unit>
        <trans-unit id="7e761763f3a77622bf4eba6f67716c21b35193a4" translate="yes" xml:space="preserve">
          <source>Linux desktop on x86_64 CPU</source>
          <target state="translated">x86_64 CPU的Linux桌面</target>
        </trans-unit>
        <trans-unit id="549589564fb88551ce209cf08bbdd821d0b56959" translate="yes" xml:space="preserve">
          <source>Linux desktop, i686</source>
          <target state="translated">Linux桌面,i686</target>
        </trans-unit>
        <trans-unit id="2c1006c548ffce988561b572ae63ee4b2e4e044d" translate="yes" xml:space="preserve">
          <source>Linux desktop, i686 running on x86_64</source>
          <target state="translated">Linux桌面,在x86_64上运行的i686。</target>
        </trans-unit>
        <trans-unit id="7162da293f4c110abd9006ea0fe9502688b6d134" translate="yes" xml:space="preserve">
          <source>Linux desktop, x86_64</source>
          <target state="translated">Linux桌面,x86_64</target>
        </trans-unit>
        <trans-unit id="ceb42a6047d0fbee0d6dbc845c8b0bf73fb0ee1b" translate="yes" xml:space="preserve">
          <source>Linux is a more diverse platform. A few common examples are given below.</source>
          <target state="translated">Linux是一个比较多样化的平台。下面举几个常见的例子。</target>
        </trans-unit>
        <trans-unit id="d420ef77bdfa54732d5aecb6c40af8088cd0093b" translate="yes" xml:space="preserve">
          <source>Linux is a more diverse platform. Your distribution of Linux might include an extension that changes your user-agent. A few common examples are given below.</source>
          <target state="translated">Linux是一个更多样化的平台。你的Linux发行版可能包含一个扩展,它可以改变你的用户代理。下面给出几个常见的例子。</target>
        </trans-unit>
        <trans-unit id="065f1e3b7da760e47bd326f001407c11b87dca01" translate="yes" xml:space="preserve">
          <source>Linux version</source>
          <target state="translated">Linux版本</target>
        </trans-unit>
        <trans-unit id="f35d685de7aa50ed56af00a2c8d048a65fb3313a" translate="yes" xml:space="preserve">
          <source>List of HTTP status codes on Wikipedia</source>
          <target state="translated">维基百科上的HTTP状态码列表</target>
        </trans-unit>
        <trans-unit id="c7facdad0c38a8be559aae543266310890041f74" translate="yes" xml:space="preserve">
          <source>Lists the set of HTTP request methods support by a resource.</source>
          <target state="translated">列出一个资源所支持的HTTP请求方法的集合。</target>
        </trans-unit>
        <trans-unit id="bf846e5d6a49925e3756fb19a1fc2ca1fb129084" translate="yes" xml:space="preserve">
          <source>Lists the set of HTTP request methods supported by a resource.</source>
          <target state="translated">列出资源所支持的HTTP请求方法的集合。</target>
        </trans-unit>
        <trans-unit id="59afca4aa349dcb2585efb358d932b086d06c52a" translate="yes" xml:space="preserve">
          <source>Live properties described in this document SHOULD be moved along with
   the resource, such that the resource has identically behaving live
   properties at the destination resource, but not necessarily with the
   same values.  Note that some live properties are defined such that
   the absence of the property has a specific meaning (e.g., a flag with
   one meaning if present, and the opposite if absent), and in these
   cases, a successful MOVE might result in the property being reported
   as &quot;Not Found&quot; in subsequent requests.  If the live properties will
   not work the same way at the destination, the server MAY fail the
   request.

   MOVE is frequently used by clients to rename a file without changing
   its parent collection, so it's not appropriate to reset all live
   properties that are set at resource creation.  For example, the DAV:
   creationdate property value SHOULD remain the same after a MOVE.

   Dead properties MUST be moved along with the resource.</source>
          <target state="translated">本文档中描述的活属性应该与资源一起移动,这样资源在目标资源中就会有行为相同的活属性,但不一定具有相同的值。请注意,有些活的属性被定义为该属性的缺失具有特定的含义(例如,一个标志,如果存在则具有一种含义,如果不存在则具有相反的含义),在这些情况下,成功的 MOVE 可能会导致该属性在随后的请求中被报告为 &quot;未找到&quot;。如果活的属性在目的地不会以同样的方式工作,服务器可能会失败请求。客户端经常使用MOVE来重命名一个文件,而不改变它的父集合,因此重置所有在资源创建时设置的活属性是不合适的。例如,DAV:createdate属性值在MOVE后应该保持不变。死的属性必须和资源一起移动。</target>
        </trans-unit>
        <trans-unit id="d81b072a609cb829f45333cb83e086a659ba9738" translate="yes" xml:space="preserve">
          <source>Living Standard</source>
          <target state="translated">生活标准</target>
        </trans-unit>
        <trans-unit id="6a7b5bd9c1e9247bb26bc70611e9ed0c08ee1e45" translate="yes" xml:space="preserve">
          <source>Load balancing/routing based on URL patterns</source>
          <target state="translated">基于URL模式的负载均衡/路由选择。</target>
        </trans-unit>
        <trans-unit id="2bf154fc59dbac071e95bfd447b96ee4cb26055c" translate="yes" xml:space="preserve">
          <source>Load balancing: distribute the load to several web servers,</source>
          <target state="translated">负载均衡:将负载分配给多个Web服务器。</target>
        </trans-unit>
        <trans-unit id="780b9308173b538a799446bb3515d17b56539241" translate="yes" xml:space="preserve">
          <source>Local File Security in Firefox 68</source>
          <target state="translated">火狐浏览器中的本地文件安全</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="a65e984205ab4c0ed633ba5ae6a32d6c797cec2d" translate="yes" xml:space="preserve">
          <source>Location (RFC 2616)</source>
          <target state="translated">租金(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="a192553dfc610dd4624b27cebff4825c0c7e9331" translate="yes" xml:space="preserve">
          <source>Location (RFC 7231)</source>
          <target state="translated">租金(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="c6e7ecfb5bf0d5af9da443ea9b5d77cb9bee2bce" translate="yes" xml:space="preserve">
          <source>Lock-Token = &quot;Lock-Token&quot; &quot;:&quot; Coded-URL

   The Lock-Token request header is used with the UNLOCK method to
   identify the lock to be removed.  The lock token in the Lock-Token
   request header MUST identify a lock that contains the resource
   identified by Request-URI as a member.

   The Lock-Token response header is used with the LOCK method to
   indicate the lock token created as a result of a successful LOCK
   request to create a new lock.</source>
          <target state="translated">Lock-Token=&quot;Lock-Token&quot; &quot;:&quot; Coded-URL 锁定令牌请求头与 UNLOCK 方法一起使用,以识别要删除的锁。Lock-Token请求头中的锁令牌必须标识一个包含Request-URI标识为成员的资源的锁。Lock-Token 响应头与 LOCK 方法一起使用,以指示创建新锁的 LOCK 请求成功后创建的锁令牌。</target>
        </trans-unit>
        <trans-unit id="55430a651698b7d81aef1e04d11d9a2d806ddbab" translate="yes" xml:space="preserve">
          <source>Logging utility</source>
          <target state="translated">记录工具</target>
        </trans-unit>
        <trans-unit id="1a4b53727bcb9a035c59d80c57451cf3de2a5c3e" translate="yes" xml:space="preserve">
          <source>Logins, shopping carts, game scores, or anything else the server should remember</source>
          <target state="translated">登录,购物车,游戏分数,或其他任何服务器应该记住的东西。</target>
        </trans-unit>
        <trans-unit id="bf49284c6e80b1a37a4cb9aa4fa17eb56ebba27b" translate="yes" xml:space="preserve">
          <source>Look, or ask, in specialized forums: you're unlikely to be the first to hit this problem. Also, experts, or simply people with another point of view, can give you ideas for working around the bug. If the problem seems uncommon, it's worth checking if this bug has been reported to the browser vendor via their bug tracking system (&lt;a href=&quot;https://bugzilla.mozilla.org&quot;&gt;Mozilla&lt;/a&gt;; &lt;a href=&quot;http://bugs.webkit.org&quot;&gt;WebKit&lt;/a&gt;; &lt;a href=&quot;https://www.chromium.org/issue-tracking&quot;&gt;Blink&lt;/a&gt;; &lt;a href=&quot;https://bugs.opera.com/&quot;&gt;Opera&lt;/a&gt;). Browser makers do pay attention to bug reports, and the analysis may hint about other workarounds for the bug.</source>
          <target state="translated">在专业论坛中查看或询问：您不太可能是第一个遇到此问题的人。此外，专家或仅是具有其他观点的人员，都可以为您提供解决此错误的想法。如果问题似乎不常见，则值得检查该错误是否已通过其错误跟踪系统（&lt;a href=&quot;https://bugzilla.mozilla.org&quot;&gt;Mozilla&lt;/a&gt;；&lt;a href=&quot;http://bugs.webkit.org&quot;&gt;WebKit&lt;/a&gt;；&lt;a href=&quot;https://www.chromium.org/issue-tracking&quot;&gt;Blink&lt;/a&gt;；&lt;a href=&quot;https://bugs.opera.com/&quot;&gt;Opera&lt;/a&gt;）报告给浏览器供应商。浏览器制造商确实会注意错误报告，并且分析可能会提示该错误的其他解决方法。</target>
        </trans-unit>
        <trans-unit id="682f96fa9b4131718e0aecf2b0551b2c7792bb34" translate="yes" xml:space="preserve">
          <source>Look, or ask, in specialized forums: you're unlikely to be the first to hit this problem. Also, experts, or simply people with another point of view, can give you ideas for working around the bug. If the problem seems uncommon, it's worth checking if this bug has been reported to the browser vendor via their bug tracking system (&lt;a href=&quot;https://bugzilla.mozilla.org&quot;&gt;Mozilla&lt;/a&gt;; &lt;a href=&quot;https://bugs.webkit.org&quot;&gt;WebKit&lt;/a&gt;; &lt;a href=&quot;https://www.chromium.org/issue-tracking&quot;&gt;Blink&lt;/a&gt;; &lt;a href=&quot;https://bugs.opera.com/&quot;&gt;Opera&lt;/a&gt;). Browser makers do pay attention to bug reports, and the analysis may hint about other workarounds for the bug.</source>
          <target state="translated">在专门的论坛上查看或询问：您不太可能是第一个遇到此问题的人。此外，专家或仅是另一种观点的人，都可以为您提供解决该bug的想法。如果问题似乎不常见，则值得检查此错误是否已通过其错误跟踪系统（&lt;a href=&quot;https://bugzilla.mozilla.org&quot;&gt;Mozilla&lt;/a&gt;；&lt;a href=&quot;https://bugs.webkit.org&quot;&gt;WebKit&lt;/a&gt;；&lt;a href=&quot;https://www.chromium.org/issue-tracking&quot;&gt;Blink&lt;/a&gt;；&lt;a href=&quot;https://bugs.opera.com/&quot;&gt;Opera&lt;/a&gt;）报告给浏览器供应商。浏览器制造商确实会注意错误报告，并且分析可能会提示该错误的其他解决方法。</target>
        </trans-unit>
        <trans-unit id="6909ecb298632f0b40975bb7028079f6f4501940" translate="yes" xml:space="preserve">
          <source>Lossy compression algorithms are usually more efficient than loss-less ones.</source>
          <target state="translated">有损压缩算法通常比无损压缩算法更有效率。</target>
        </trans-unit>
        <trans-unit id="43ddda7cc2412992344e22fd844143dbcfe3bfc3" translate="yes" xml:space="preserve">
          <source>Lossy compression algorithms are usually more efficient that loss-less ones.</source>
          <target state="translated">有损压缩算法通常比无损压缩算法更有效。</target>
        </trans-unit>
        <trans-unit id="ac2665911917ab5f698cf6ff5ed62343c6057a6a" translate="yes" xml:space="preserve">
          <source>MIME Type</source>
          <target state="translated">MIME类型</target>
        </trans-unit>
        <trans-unit id="403274b7a1852e5261e595fa61397d41178bdb18" translate="yes" xml:space="preserve">
          <source>MIME Types</source>
          <target state="translated">MIME类型</target>
        </trans-unit>
        <trans-unit id="8e48cee9b67b50e883f2ce1444b5166e76e1cf17" translate="yes" xml:space="preserve">
          <source>MIME does not include any concept equivalent to HTTP/1.1's
   Content-Encoding header field.  Since this acts as a modifier on the
   media type, proxies and gateways from HTTP to MIME-compliant
   protocols ought to either change the value of the Content-Type header
   field or decode the representation before forwarding the message.
   (Some experimental applications of Content-Type for Internet mail
   have used a media-type parameter of &quot;;conversions=&amp;lt;content-coding&amp;gt;&quot;
   to perform a function equivalent to Content-Encoding.  However, this
   parameter is not part of the MIME standards).</source>
          <target state="translated">MIME不包含任何等效于HTTP / 1.1的Content-Encoding标头字段的概念。由于这是媒体类型的修饰符，因此从HTTP到MIME兼容协议的代理和网关应在转发消息之前更改Content-Type标头字段的值或解码表示形式。 （Internet邮件的Content-Type的一些实验性应用程序使用媒体类型参数&amp;ldquo;; conversions = &amp;lt;content-coding&amp;gt;&amp;rdquo;来执行等效于Content-Encoding的功能。但是，此参数不是MIME标准的一部分。 ）。</target>
        </trans-unit>
        <trans-unit id="969c21cbc7a0aaa20e68f4d797544fee58a73005" translate="yes" xml:space="preserve">
          <source>MIME media types define what kind of document a specific resource is. This article presents both the syntax and the most useful MIME types for use on the Web.</source>
          <target state="translated">MIME媒体类型定义了一个特定资源是什么样的文件.本文介绍了网络上使用的MIME类型的语法和最有用的MIME类型。</target>
        </trans-unit>
        <trans-unit id="6bd9c9b5a57f317bcf5534bd7d83b023a8ee7df7" translate="yes" xml:space="preserve">
          <source>MIME provides for a number of &quot;multipart&quot; types -- encapsulations of
   one or more entities within a single message-body. All multipart
   types share a common syntax, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;section&amp;nbsp;5.1.1 of RFC 2046&lt;/a&gt; 

   [&lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt;], and MUST include a boundary parameter as part of the media type
   value. The message body is itself a protocol element and MUST
   therefore use only CRLF to represent line breaks between body-parts.
   Unlike in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;, the epilogue of any multipart message MUST be
   empty; HTTP applications MUST NOT transmit the epilogue (even if the
   original multipart contains an epilogue). These restrictions exist in
   order to preserve the self-delimiting nature of a multipart message-
   body, wherein the &quot;end&quot; of the message-body is indicated by the
   ending multipart boundary.

   In general, HTTP treats a multipart message-body no differently than
   any other media type: strictly as payload. The one exception is the
   &quot;multipart/byteranges&quot; type (appendix 19.2) when it appears in a 206
   (Partial Content) response, which will be interpreted by some HTTP
   caching mechanisms as described in sections &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; and &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. In all
   other cases, an HTTP user agent SHOULD follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   The MIME header fields within each body-part of a multipart message-
   body do not have any significance to HTTP beyond that defined by
   their MIME semantics.

   In general, an HTTP user agent SHOULD follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   If an application receives an unrecognized multipart subtype, the
   application MUST treat it as being equivalent to &quot;multipart/mixed&quot;.

      Note: The &quot;multipart/form-data&quot; type has been specifically defined
      for carrying form data suitable for processing via the POST
      request method, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC 1867&lt;/a&gt; [&lt;a href=&quot;#ref-15&quot;&gt;15&lt;/a&gt;].</source>
          <target state="translated">MIME提供了许多&amp;ldquo;多部分&amp;rdquo;类型-在单个消息正文中封装一个或多个实体。所有的多部分类型都共享一种通用语法，如&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;RFC 2046&lt;/a&gt; [ &lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt; ]的5.1.1节所定义，并且务必包括一个边界参数作为媒体类型值的一部分。消息主体本身就是协议元素，因此必须仅使用CRLF表示主体部分之间的换行符。不同于&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;，任何多部分消息的结尾必须为空； HTTP应用程序不得传输尾声（即使原始多部分包含尾声）。存在这些限制是为了保留多部分消息主体的自定界性质，其中消息主体的&amp;ldquo;结束&amp;rdquo;由结束的多部分边界指示。通常，HTTP与任何其他媒体类型一样对待多部分消息主体：严格作为有效负载。一个例外是出现在206（部分内容）响应中的&amp;ldquo; multipart / byteranges&amp;rdquo;类型（附录19.2），这将由部分&lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;和&lt;a href=&quot;#section-14.16&quot;&gt;14.16中&lt;/a&gt;描述的HTTP缓存机制进行解释。。在所有其他情况下，HTTP用户代理应遵循与MIME用户代理在收到多部分类型时相同或相似的行为。多部分消息正文的每个正文部分中的MIME头字段对HTTP而言，除了其MIME语义所定义的含义外，没有其他意义。通常，HTTP用户代理应该遵循与MIME用户代理在接收到多部分类型时相同或相似的行为。如果应用程序收到无法识别的多部分子类型，则该应用程序必须将其视为等同于&amp;ldquo;多部分/混合&amp;rdquo;。注意：专门定义了&amp;ldquo; multipart / form-data&amp;rdquo;类型，用于携带适合通过POST请求方法处理的表单数据，如&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC 1867&lt;/a&gt; [ &lt;a href=&quot;#ref-15&quot;&gt;15&lt;/a&gt; ]中所述。</target>
        </trans-unit>
        <trans-unit id="4a0b826ef29a7a4a5fcb4cc1856fb5706a1d940c" translate="yes" xml:space="preserve">
          <source>MIME provides for a number of &quot;multipart&quot; types -- encapsulations of
   one or more representations within a single message body.  All
   multipart types share a common syntax, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of
   [RFC2046]&lt;/a&gt;, and include a boundary parameter as part of the media type
   value.  The message body is itself a protocol element; a sender MUST
   generate only CRLF to represent line breaks between body parts.

   HTTP message framing does not use the multipart boundary as an
   indicator of message body length, though it might be used by
   implementations that generate or process the payload.  For example,
   the &quot;multipart/form-data&quot; type is often used for carrying form data
   in a request, as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC2388&lt;/a&gt;], and the &quot;multipart/
   byteranges&quot; type is defined by this specification for use in some 206
   (Partial Content) responses [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;].</source>
          <target state="translated">MIME提供了许多&amp;ldquo;多部分&amp;rdquo;类型-在单个消息正文中封装一个或多个表示形式。所有多部分类型都共享一种通用语法，如&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;[RFC2046]的5.1.1节中&lt;/a&gt;所定义，并且包括一个边界参数作为媒体类型值的一部分。消息主体本身就是一个协议元素。发送者必须仅生成CRLF来表示身体各部位之间的换行。尽管HTTP消息框架可能会被生成或处理有效负载的实现所使用，但它并未将多部分边界用作消息正文长度的指标。例如，如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC2388中&lt;/a&gt;所述，&amp;ldquo; multipart / form-data&amp;rdquo;类型通常用于在请求中携带表单数据。]，&amp;ldquo; multipart / byteranges&amp;rdquo;类型由该规范定义，用于206个（部分内容）响应[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="c8e0f31f1df09630671c1f651e4e3b3a2f9c9629" translate="yes" xml:space="preserve">
          <source>MIME requires that an Internet mail body part be converted to
   canonical form prior to being transferred, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2049#section-4&quot;&gt;Section&amp;nbsp;4
   of [RFC2049]&lt;/a&gt;.  &lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; of this document describes the forms
   allowed for subtypes of the &quot;text&quot; media type when transmitted over
   HTTP.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] requires that content with a type of &quot;text&quot;
   represent line breaks as CRLF and forbids the use of CR or LF outside
   of line break sequences.  HTTP allows CRLF, bare CR, and bare LF to
   indicate a line break within text content.

   A proxy or gateway from HTTP to a strict MIME environment ought to
   translate all line breaks within the text media types described in
   &lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; of this document to the &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt; canonical form of
   CRLF.  Note, however, this might be complicated by the presence of a
   Content-Encoding and by the fact that HTTP allows the use of some
   charsets that do not use octets 13 and 10 to represent CR and LF,
   respectively. 

   Conversion will break any cryptographic checksums applied to the
   original content unless the original content is already in canonical
   form.  Therefore, the canonical form is recommended for any content
   that uses such checksums in HTTP.</source>
          <target state="translated">MIME要求将Internet邮件正文部分转换为规范形式，然后再进行传输，如&lt;a href=&quot;https://tools.ietf.org/html/rfc2049#section-4&quot;&gt;[RFC2049]的第4节中&lt;/a&gt;所述。 本文档的&lt;a href=&quot;#section-3.1.1.3&quot;&gt;第3.1.1.3节&lt;/a&gt;介绍了通过HTTP传输时&amp;ldquo;文本&amp;rdquo;媒体类型的子类型所允许的形式。 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]要求类型为&amp;ldquo;文本&amp;rdquo;的内容将换行符表示为CRLF，并禁止在换行符序列之外使用CR或LF。 HTTP允许CRLF，裸CR和裸LF指示文本内容内的换行符。从HTTP到严格MIME环境的代理或网关&lt;a href=&quot;#section-3.1.1.3&quot;&gt;应将&lt;/a&gt;本文档第3.1.1.3节中描述的文本媒体类型内的所有换行符转换 为&lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;CRLF的规范形式。但是请注意，由于存在Content-Encoding，并且HTTP允许使用一些不使用八位位组13和10分别表示CR和LF的字符集，因此这可能会使情况变得复杂。除非原始内容已经是规范形式，否则转换将破坏应用于原始内容的任何密码校验和。因此，对于在HTTP中使用此类校验和的任何内容，建议使用规范形式。</target>
        </trans-unit>
        <trans-unit id="dc3173f339d6234c3d312054225c8bdaf39b65b0" translate="yes" xml:space="preserve">
          <source>MIME sniffing</source>
          <target state="translated">MIME嗅探</target>
        </trans-unit>
        <trans-unit id="8c6307bfb3b795f533739b8404318fa008b26432" translate="yes" xml:space="preserve">
          <source>MIME type</source>
          <target state="translated">MIME类型</target>
        </trans-unit>
        <trans-unit id="a4195024d58b7afd14c9753b91c2a9db35d2b08f" translate="yes" xml:space="preserve">
          <source>MIME types</source>
          <target state="translated">MIME类型</target>
        </trans-unit>
        <trans-unit id="85b225fe3d478022bad59031409ac72b140a5366" translate="yes" xml:space="preserve">
          <source>MIME types are case-insensitive but are traditionally written in lowercase, with the exception of parameter values, whose case may or may not have specific meaning.</source>
          <target state="translated">MIME类型不区分大小写,但传统上用小写,但参数值除外,其大小写可能有或没有特定的意义。</target>
        </trans-unit>
        <trans-unit id="c3957f21878ad7ce2b26fefff8051376805431e8" translate="yes" xml:space="preserve">
          <source>MIME types are case-insensitive but traditionally written in lowercase.</source>
          <target state="translated">MIME类型不区分大小写,但传统上用小写。</target>
        </trans-unit>
        <trans-unit id="b860a02c04e9037685ceb44ac49fc8833ef95f3c" translate="yes" xml:space="preserve">
          <source>MIME types are not the only way to convey document type information:</source>
          <target state="translated">MIME类型并不是传递文件类型信息的唯一方式。</target>
        </trans-unit>
        <trans-unit id="4da8182b81c1bb802c3acafa674af9adc81313c0" translate="yes" xml:space="preserve">
          <source>MIME types: Complete list of MIME types</source>
          <target state="translated">MIME类型。MIME类型的完整列表</target>
        </trans-unit>
        <trans-unit id="148704e082bf337e21217553e9d3d3709aea42bf" translate="yes" xml:space="preserve">
          <source>MKCOL creates a new collection resource at the location specified by
   the Request-URI.  If the Request-URI is already mapped to a resource,
   then the MKCOL MUST fail.  During MKCOL processing, a server MUST
   make the Request-URI an internal member of its parent collection,
   unless the Request-URI is &quot;/&quot;.  If no such ancestor exists, the
   method MUST fail.  When the MKCOL operation creates a new collection
   resource, all ancestors MUST already exist, or the method MUST fail
   with a 409 (Conflict) status code.  For example, if a request to
   create collection /a/b/c/d/ is made, and /a/b/c/ does not exist, the
   request must fail.

   When MKCOL is invoked without a request body, the newly created
   collection SHOULD have no members. 

   A MKCOL request message may contain a message body.  The precise
   behavior of a MKCOL request when the body is present is undefined,
   but limited to creating collections, members of a collection, bodies
   of members, and properties on the collections or members.  If the
   server receives a MKCOL request entity type it does not support or
   understand, it MUST respond with a 415 (Unsupported Media Type)
   status code.  If the server decides to reject the request based on
   the presence of an entity or the type of an entity, it should use the
   415 (Unsupported Media Type) status code.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">MKCOL在Request-URI指定的位置创建一个新的收集资源。如果Request-URI已经映射到资源，则MKCOL务必失败。在MKCOL处理期间，服务器必须使Request-URI成为其父集合的内部成员，除非Request-URI为&amp;ldquo; /&amp;rdquo;。如果没有这样的祖先，则该方法必须失败。当MKCOL操作创建一个新的收集资源时，所有祖先必须已经存在，否则该方法必须以409（冲突）状态代码失败。例如，如果发出创建集合/ a / b / c / d /的请求，而/ a / b / c /不存在，则该请求必须失败。在没有请求主体的情况下调用MKCOL时，新创建的集合应该没有成员。 MKCOL请求消息可能包含消息正文。存在主体时，MKCOL请求的确切行为是不确定的，但仅限于创建集合，集合的成员，成员的主体以及集合或成员的属性。如果服务器收到了它不支持或无法理解的MKCOL请求实体类型，则它必须以415（不支持的媒体类型）状态码进行响应。如果服务器根据实体的存在或实体的类型决定拒绝该请求，则应使用415（不支持的媒体类型）状态码。此方法是幂等的，但不安全（请参阅如果服务器收到了它不支持或无法理解的MKCOL请求实体类型，则它必须以415（不支持的媒体类型）状态码进行响应。如果服务器根据实体的存在或实体的类型决定拒绝该请求，则它应使用415（不支持的媒体类型）状态码。此方法是幂等的，但不安全（请参阅如果服务器收到了它不支持或无法理解的MKCOL请求实体类型，则它必须以415（不支持的媒体类型）状态码进行响应。如果服务器根据实体的存在或实体的类型决定拒绝该请求，则它应使用415（不支持的媒体类型）状态码。此方法是幂等的，但不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="d34f4fbf660e43b546f36ad8f422be2614555dcd" translate="yes" xml:space="preserve">
          <source>MP3 audio</source>
          <target state="translated">MP3音频</target>
        </trans-unit>
        <trans-unit id="2a7163944345c31e87c18d422da826101ae9abe5" translate="yes" xml:space="preserve">
          <source>MPEG Video</source>
          <target state="translated">MPEG视频</target>
        </trans-unit>
        <trans-unit id="76ffb6887eba7a2790b86a61c748c98d3d1e8f9c" translate="yes" xml:space="preserve">
          <source>MPEG transport stream</source>
          <target state="translated">MPEG传输流</target>
        </trans-unit>
        <trans-unit id="6856eb8cd7bbe158e86b90aca7643f9eb2028c7e" translate="yes" xml:space="preserve">
          <source>MS Embedded OpenType fonts</source>
          <target state="translated">MS嵌入式OpenType字体</target>
        </trans-unit>
        <trans-unit id="6ee635274712baef8781c8d8f996b059e9c0d4e0" translate="yes" xml:space="preserve">
          <source>Mac OS X on Intel x86 or x86_64</source>
          <target state="translated">Intel x86或x86_64的Mac OS X。</target>
        </trans-unit>
        <trans-unit id="973e3aaf5ab321c24d7296e6f425c45df453a860" translate="yes" xml:space="preserve">
          <source>Mac OS X on PowerPC</source>
          <target state="translated">Mac OS X on PowerPC</target>
        </trans-unit>
        <trans-unit id="70bafc26930c7270181eba7fdab16bde2ac8ad22" translate="yes" xml:space="preserve">
          <source>Mac OS X version</source>
          <target state="translated">Mac OS X版本</target>
        </trans-unit>
        <trans-unit id="c0fd8053739db52e4d7f47348c57c75e3099c202" translate="yes" xml:space="preserve">
          <source>Macintosh</source>
          <target state="translated">Macintosh</target>
        </trans-unit>
        <trans-unit id="cd1cb4ddbb5f5f302fe8ca08ece123325b6c28dd" translate="yes" xml:space="preserve">
          <source>Magic numbers. The syntax of different formats allows file-type inference by looking at their byte structure. For example, GIF files start with the &lt;code&gt;47 49 46 38 39&lt;/code&gt; hexadecimal value (&lt;code&gt;GIF89&lt;/code&gt;), and PNG files with &lt;code&gt;89 50 4E 47&lt;/code&gt; (&lt;code&gt;.PNG&lt;/code&gt;). Not all file types have magic numbers, so this is not 100% reliable either.</source>
          <target state="translated">魔术数字。不同格式的语法允许通过查看字节结构来推断文件类型。例如，GIF文件以 &lt;code&gt;47 49 46 38 39&lt;/code&gt; 十六进制值（ &lt;code&gt;GIF89&lt;/code&gt; ）开头，PNG文件以 &lt;code&gt;89 50 4E 47&lt;/code&gt; （ &lt;code&gt;.PNG&lt;/code&gt; ）开头。并非所有文件类型都具有幻数，因此也不是100％可靠。</target>
        </trans-unit>
        <trans-unit id="09abc5b909a0fed32e43a7d4b0340a7125fc3cd6" translate="yes" xml:space="preserve">
          <source>Magnetometer</source>
          <target state="translated">Magnetometer</target>
        </trans-unit>
        <trans-unit id="37e6025eda2c374b5e1db64db721c1f61e0d7e8c" translate="yes" xml:space="preserve">
          <source>Make a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; (using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Response/url&quot;&gt;&lt;code&gt;Response.url&lt;/code&gt;&lt;/a&gt; for the Fetch API, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL&quot;&gt;&lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt;&lt;/a&gt;) to determine what URL the real preflighted request would end up at.</source>
          <target state="translated">进行一个&lt;a href=&quot;#Simple_requests&quot;&gt;简单的请求&lt;/a&gt;（使用Fetch API的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Response/url&quot;&gt; &lt;code&gt;Response.url&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL&quot;&gt; &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; &lt;/a&gt;）来确定实际的预检请求将以哪个URL结尾。</target>
        </trans-unit>
        <trans-unit id="db608f8e24798e21b8d041453cb94e74e2d2499f" translate="yes" xml:space="preserve">
          <source>Make another request (the &amp;ldquo;real&amp;rdquo; request) using the URL you obtained from &lt;code&gt;Response.url&lt;/code&gt; or &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; in the first step.</source>
          <target state="translated">使用第一步中从 &lt;code&gt;Response.url&lt;/code&gt; 或 &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; 获得的URL发出另一个请求（&amp;ldquo;真实&amp;rdquo;请求）。</target>
        </trans-unit>
        <trans-unit id="05029130870878b79b7335852828d865e01799dc" translate="yes" xml:space="preserve">
          <source>Make sure your code only uses the permitted HTTP methods when accessing the service.</source>
          <target state="translated">确保你的代码在访问服务时只使用允许的HTTP方法。</target>
        </trans-unit>
        <trans-unit id="85896aa2638b32ee0bc92737649fbc2fda06cf32" translate="yes" xml:space="preserve">
          <source>Make your page work for both</source>
          <target state="translated">让你的页面两全其美</target>
        </trans-unit>
        <trans-unit id="f989199f5291676ea54cc4b082182819742c121f" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and applies the method only if the stored resource doesn't match any of the given ETags. This is used to update caches (for safe requests), or to prevent to upload a new resource when one is already existing.</source>
          <target state="translated">使请求成为有条件的,并且只有当存储的资源不匹配任何给定的ETags时才应用该方法。这用于更新缓存(对于安全请求),或者防止上传新的资源,如果一个资源已经存在。</target>
        </trans-unit>
        <trans-unit id="44bbd70969c3a3e1d64163feeed015fad79d423a" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and applies the method only if the stored resource matches one of the given ETags.</source>
          <target state="translated">使请求成为有条件的,并且只有当存储的资源与给定的ET标签之一相匹配时才应用该方法。</target>
        </trans-unit>
        <trans-unit id="169b3478c02104479a6e6958b18af330ce9e16b1" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and expects the entity to be transmitted only if it has been modified after the given date. This is used to transmit data only when the cache is out of date.</source>
          <target state="translated">使请求成为有条件的,并期望只有在给定的日期之后修改过的实体才会被传送。只有当缓存过期时,才会用这个方法来传输数据。</target>
        </trans-unit>
        <trans-unit id="09d74b4e76e350446f9d2ba5e44f9fb97d8901cd" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and expects the entity to be transmitted only if it has not been modified after the given date. This is used to ensure the coherence of a new fragment of a specific range with previous ones, or to implement an optimistic concurrency control system when modifying existing documents.</source>
          <target state="translated">使请求成为有条件的,并期望只有在给定日期之后没有修改实体时才会传送。这用于确保特定范围的新片段与之前的片段的一致性,或者在修改现有文档时实施乐观的并发控制系统。</target>
        </trans-unit>
        <trans-unit id="7f7a333068288562b3d5298c97a47ff5d31cad69" translate="yes" xml:space="preserve">
          <source>Makes the request conditional, and applies the method only if the stored resource &lt;em&gt;doesn't&lt;/em&gt; match any of the given ETags. This is used to update caches (for safe requests), or to prevent to upload a new resource when one already exists.</source>
          <target state="translated">使请求成为条件请求，并仅在存储的资源与任何给定的ETag&lt;em&gt;不&lt;/em&gt;匹配时才应用该方法。这用于更新缓存（用于安全请求），或用于防止已经存在的新资源上载。</target>
        </trans-unit>
        <trans-unit id="096d2ea5d3c4755584b006d2100bd34959cc8db1" translate="yes" xml:space="preserve">
          <source>Makes the request conditional, and applies the method only if the stored resource matches one of the given ETags.</source>
          <target state="translated">使请求成为有条件的,并且只有当存储的资源与给定的ETag之一相匹配时,才应用该方法。</target>
        </trans-unit>
        <trans-unit id="1dbe6e81622971be5c832e4b1e9abaa33bb8ba48" translate="yes" xml:space="preserve">
          <source>Makes the request conditional, and expects the entity to be transmitted only if it has been modified after the given date. This is used to transmit data only when the cache is out of date.</source>
          <target state="translated">使请求成为有条件的,并期望只有在给定日期之后修改过的实体才会被传送。只有当缓存过期时,才会使用这个方法来传输数据。</target>
        </trans-unit>
        <trans-unit id="ee09c9d066e168f9305938a8aef194729c4bca51" translate="yes" xml:space="preserve">
          <source>Makes the request conditional, and expects the entity to be transmitted only if it has not been modified after the given date. This ensures the coherence of a new fragment of a specific range with previous ones, or to implement an optimistic concurrency control system when modifying existing documents.</source>
          <target state="translated">使请求成为有条件的,只有在给定的日期之后没有被修改的实体才会被传送。这确保了特定范围内的新片段与之前的片段的一致性,或者在修改现有文档时实施乐观的并发控制系统。</target>
        </trans-unit>
        <trans-unit id="0eae6a4d1eb4ec4b7a532a8a7ad3964da33fdb3a" translate="yes" xml:space="preserve">
          <source>Making the best of user agent sniffing</source>
          <target state="translated">充分利用用户代理嗅觉</target>
        </trans-unit>
        <trans-unit id="ee449b1a1e7a790032bd3390fdea7fc50fbb85e5" translate="yes" xml:space="preserve">
          <source>Mandatory upgrade</source>
          <target state="translated">强制升级</target>
        </trans-unit>
        <trans-unit id="aa95526dca52047ea17840984f5ae03c1700be81" translate="yes" xml:space="preserve">
          <source>Many &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;developer tools' network panels&lt;/a&gt; of browsers create extraneous requests leading to &lt;code&gt;304&lt;/code&gt; responses, so that access to the local cache is visible to developers.</source>
          <target state="translated">许多&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;开发人员工具&lt;/a&gt;的浏览器网络面板会创建无关的请求，导致 &lt;code&gt;304&lt;/code&gt; 个响应，因此开发人员可以看到对本地缓存的访问。</target>
        </trans-unit>
        <trans-unit id="a0c2d53d901c528a1965720abe35932f4bbca17a" translate="yes" xml:space="preserve">
          <source>Many WebDAV clients that have already been implemented have account
   settings (similar to the way email clients store IMAP account
   settings).  Thus, the WebDAV client would be able to authenticate
   with its first couple requests to the server, provided it had a way
   to get the authentication challenge from the server with realm name, 

   nonce, and other challenge information.  Note that the results of
   some requests might vary according to whether or not the client is
   authenticated -- a PROPFIND might return more visible resources if
   the client is authenticated, yet not fail if the client is anonymous.

   There are a number of ways the client might be able to trigger the
   server to provide an authentication challenge.  This appendix
   describes a couple approaches that seem particularly likely to work.

   The first approach is to perform a request that ought to require
   authentication.  However, it's possible that a server might handle
   any request even without authentication, so to be entirely safe, the
   client could add a conditional header to ensure that even if the
   request passes permissions checks, it's not actually handled by the
   server.  An example of following this approach would be to use a PUT
   request with an &quot;If-Match&quot; header with a made-up ETag value.  This
   approach might fail to result in an authentication challenge if the
   server does not test authorization before testing conditionals as is
   required (see &lt;a href=&quot;#section-8.5&quot;&gt;Section 8.5&lt;/a&gt;), or if the server does not need to test
   authorization.

   Example - forcing auth challenge with write request

   &amp;gt;&amp;gt;Request

     PUT /forceauth.txt HTTP/1.1
     Host: www.example.com
     If-Match: &quot;xxx&quot;
     Content-Type: text/plain
     Content-Length: 0


   The second approach is to use an Authorization header (defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;]), which is likely to be rejected by the server but which
   will then prompt a proper authentication challenge.  For example, the
   client could start with a PROPFIND request containing an
   Authorization header containing a made-up Basic userid:password
   string or with actual plausible credentials.  This approach relies on
   the server responding with a &quot;401 Unauthorized&quot; along with a
   challenge if it receives an Authorization header with an unrecognized
   username, invalid password, or if it doesn't even handle Basic
   authentication.  This seems likely to work because of the
   requirements of &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;: 

   &quot;If the origin server does not wish to accept the credentials sent
   with a request, it SHOULD return a 401 (Unauthorized) response.  The
   response MUST include a WWW-Authenticate header field containing at
   least one (possibly new) challenge applicable to the requested
   resource.&quot;

   There's a slight problem with implementing that recommendation in
   some cases, because some servers do not even have challenge
   information for certain resources.  Thus, when there's no way to
   authenticate to a resource or the resource is entirely publicly
   available over all accepted methods, the server MAY ignore the
   Authorization header, and the client will presumably try again later.

   Example - forcing auth challenge with Authorization header

   &amp;gt;&amp;gt;Request

     PROPFIND /docs/ HTTP/1.1
     Host: www.example.com
     Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
     Content-type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     [body omitted]</source>
          <target state="translated">许多已经实现的WebDAV客户端都有帐户设置（类似于电子邮件客户端存储IMAP帐户设置的方式）。因此，WebDAV客户端将能够使用其对服务器的第一个请求来进行身份验证，前提是它有一种方法可以使用域名称，随机数和其他质询信息从服务器获取身份验证质询。请注意，某些请求的结果可能会根据客户端是否通过身份验证而有所不同-如果客户端通过身份验证，则PROPFIND可能会返回更多可见资源，但如果客户端是匿名的，则PROPFIND不会失败。客户端可以通过多种方式触发服务器以提供身份验证质询。本附录描述了几种似乎特别可行的方法。第一种方法是执行应要求身份验证的请求。但是，即使没有身份验证，服务器也可能处理任何请求，因此，为了完全安全，客户端可以添加条件标头，以确保即使请求通过权限检查，服务器也不会真正处理该请求。遵循此方法的一个示例是将PUT请求与带有虚假ETag值的&amp;ldquo; If-Match&amp;rdquo;标头一起使用。如果服务器在根据需要测试条件之前未测试授权，则此方法可能不会导致身份验证挑战（请参阅客户端可以添加条件标头，以确保即使请求通过权限检查，服务器也不会真正处理该请求。遵循此方法的一个示例是将PUT请求与带有虚假ETag值的&amp;ldquo; If-Match&amp;rdquo;标头一起使用。如果服务器在根据需要测试条件之前未测试授权，则此方法可能不会导致身份验证挑战（请参阅客户端可以添加条件标头，以确保即使请求通过权限检查，服务器也不会真正处理该请求。遵循此方法的一个示例是将PUT请求与带有虚假ETag值的&amp;ldquo; If-Match&amp;rdquo;标头一起使用。如果服务器在根据需要测试条件之前未测试授权，则此方法可能不会导致身份验证挑战（请参阅如果服务器在根据需要测试条件之前未测试授权，则此方法可能不会导致身份验证挑战（请参阅如果服务器在根据需要测试条件之前未测试授权，则此方法可能不会导致身份验证挑战（请参阅&lt;a href=&quot;#section-8.5&quot;&gt;8.5节&lt;/a&gt;），或者服务器不需要测试授权。示例-使用写请求&amp;gt;&amp;gt;请求PUT强制进行身份验证挑战/forceauth.txt HTTP / 1.1主机：www.example.com If-Match：&amp;ldquo; xxx&amp;rdquo; Content-Type：text / plain Content-Length：0第二种方法是使用授权标头（在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617中&lt;/a&gt;定义]），可能会被服务器拒绝，但随后将提示适当的身份验证质询。例如，客户端可以从包含授权头的PROPFIND请求开始，该授权头包含伪造的Basic userid：password字符串或实际的可信凭证。如果服务器接收到带有未识别的用户名，无效密码的Authorization标头，或者甚至不处理基本身份验证，则此方法依赖于服务器以&amp;ldquo; 401 Unauthorized&amp;rdquo;响应以及质询。由于&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;的要求，这似乎可行：&amp;ldquo;如果原始服务器不希望接受随请求发送的凭据，则它应返回401（未经授权）响应。响应必须包含一个WWW-Authenticate标头字段，其中至少包含一个适用于该请求的（可能是新的）质询。要求的资源。&amp;rdquo;在某些情况下，实施该建议会有一个小问题，因为某些服务器甚至没有某些资源的质询信息。因此，当无法对资源进行身份验证或资源在所有接受的方法上完全公开可用时，服务器可以忽略授权标头，并且客户端可能稍后再试。示例-使用Authorization标头&amp;gt;&amp;gt;请求PROPFIND / docs / HTTP / 1.1主机强制进行身份验证质询：www.example。com授权：基本QWxhZGRpbjpvcGVuIHNlc2FtZQ ==内容类型：application / xml; charset =&amp;ldquo; utf-8&amp;rdquo;内容长度：xxxx [省略的正文]</target>
        </trans-unit>
        <trans-unit id="c2f40e3ce20552730e2da9b44cf88aa049c3f277" translate="yes" xml:space="preserve">
          <source>Many clients also let you avoid the login prompt by using an encoded URL containing the username and the password like this:</source>
          <target state="translated">许多客户端还可以让你通过使用包含用户名和密码的编码URL来避免登录提示,比如这样。</target>
        </trans-unit>
        <trans-unit id="283c9af22dd90c8866e71dddbfce0cce3700a5b6" translate="yes" xml:space="preserve">
          <source>Many of the request header fields for proactive negotiation use a
   common parameter, named &quot;q&quot; (case-insensitive), to assign a relative
   &quot;weight&quot; to the preference for that associated kind of content.  This
   weight is referred to as a &quot;quality value&quot; (or &quot;qvalue&quot;) because the
   same parameter name is often used within server configurations to
   assign a weight to the relative quality of the various
   representations that can be selected for a resource. 

   The weight is normalized to a real number in the range 0 through 1,
   where 0.001 is the least preferred and 1 is the most preferred; a
   value of 0 means &quot;not acceptable&quot;.  If no &quot;q&quot; parameter is present,
   the default weight is 1.

     weight = OWS &quot;;&quot; OWS &quot;q=&quot; qvalue
     qvalue = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
            / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   A sender of qvalue MUST NOT generate more than three digits after the
   decimal point.  User configuration of these values ought to be
   limited in the same fashion.</source>
          <target state="translated">许多用于主动协商的请求头字段使用一个名为 &quot;q&quot;(不区分大小写)的通用参数,为该相关内容的偏好分配一个相对的 &quot;权重&quot;。这个权重被称为 &quot;质量值&quot;(或 &quot;q值&quot;),因为在服务器配置中,经常使用相同的参数名称来为可以为资源选择的各种表示形式的相对质量分配权重。权重被归一化为0到1范围内的实数,其中0.001是最不喜欢的,1是最喜欢的;0的值表示 &quot;不可接受&quot;。如果没有 &quot;q &quot;参数,则默认权重为1。 weight=OWS &quot;;&quot; OWS &quot;q=&quot; qvalue qvalue=(&quot;0&quot;[&quot;.&quot; 0*3DIGIT ])/(&quot;1&quot;[&quot;.&quot; 0*3(&quot;0&quot;)])qvalue的发送者不得在小数点后产生超过三位的数字。用户对这些值的配置应该以同样的方式进行限制。</target>
        </trans-unit>
        <trans-unit id="2fec0947cbf922d8434fc8fe01a93bf6110f4bdb" translate="yes" xml:space="preserve">
          <source>Many user agents make it possible for users to override the basic
   caching mechanisms. For example, the user agent might allow the user
   to specify that cached entities (even explicitly stale ones) are
   never validated. Or the user agent might habitually add &quot;Cache-
   Control: max-stale=3600&quot; to every request. The user agent SHOULD NOT
   default to either non-transparent behavior, or behavior that results
   in abnormally ineffective caching, but MAY be explicitly configured
   to do so by an explicit action of the user.

   If the user has overridden the basic caching mechanisms, the user
   agent SHOULD explicitly indicate to the user whenever this results in
   the display of information that might not meet the server's
   transparency requirements (in particular, if the displayed entity is
   known to be stale). Since the protocol normally allows the user agent
   to determine if responses are stale or not, this indication need only
   be displayed when this actually happens. The indication need not be a
   dialog box; it could be an icon (for example, a picture of a rotting
   fish) or some other indicator.

   If the user has overridden the caching mechanisms in a way that would
   abnormally reduce the effectiveness of caches, the user agent SHOULD
   continually indicate this state to the user (for example, by a
   display of a picture of currency in flames) so that the user does not
   inadvertently consume excess resources or suffer from excessive
   latency.</source>
          <target state="translated">许多用户代理使用户可以覆盖基本的缓存机制。例如,用户代理可能允许用户指定缓存的实体(甚至是显式的陈旧实体)永远不会被验证。或者用户代理可能会习惯性地在每个请求中添加 &quot;Cache-Control:max-stale=3600&quot;。用户代理不应该默认为非透明行为,或者导致异常无效的缓存行为,但可以通过用户的显式操作进行显式配置。如果用户已经覆盖了基本的缓存机制,那么每当这导致显示的信息可能不符合服务器的透明度要求时(特别是,如果显示的实体已知是陈旧的),用户代理就应该明确地指示给用户。由于协议通常允许用户代理确定响应是否陈旧,所以只需要在实际发生时才显示这种指示。该指示不需要是一个对话框;它可以是一个图标(例如,一张腐烂的鱼的图片)或其他指示器。如果用户以一种会异常降低缓存有效性的方式覆盖了缓存机制,用户代理应该持续向用户指示这种状态(例如,通过显示一张火焰中的货币图片),这样用户就不会在无意中消耗过多的资源或遭受过大的延迟。</target>
        </trans-unit>
        <trans-unit id="91d901c4ba5ec936d334c6e339e3c5a344ea50ad" translate="yes" xml:space="preserve">
          <source>Many web sites customize the look of a 404 page to be more helpful to the user and provide guidance on what to do next. Apache servers can be configured using an &lt;code&gt;.htaccess&lt;/code&gt; file and a code snippet like the following example.</source>
          <target state="translated">许多网站自定义404页面的外观，以便对用户有更大帮助，并提供下一步操作的指导。可以使用 &lt;code&gt;.htaccess&lt;/code&gt; 文件和代码段（如以下示例）来配置Apache服务器。</target>
        </trans-unit>
        <trans-unit id="a17963b7961c54316ccf166b602f9000c64c4f9a" translate="yes" xml:space="preserve">
          <source>Matches any content encoding not already listed in the header. This is the default value if the header is not present. It doesn't mean that any algorithm is supported; merely that no preference is expressed.</source>
          <target state="translated">匹配任何尚未在头中列出的内容编码。如果没有头,这是默认值。这并不意味着支持任何算法,只是没有表达任何偏好。</target>
        </trans-unit>
        <trans-unit id="380542fdbbc688e8e6c3dd27ea8f678b7e9f1ca5" translate="yes" xml:space="preserve">
          <source>Max-Age=&amp;lt;number&amp;gt; Optional</source>
          <target state="translated">Max-Age = &amp;lt;数字&amp;gt;可选</target>
        </trans-unit>
        <trans-unit id="1f82181c1557956a09c87927dc4ce27ccc4098f3" translate="yes" xml:space="preserve">
          <source>Max-Forwards (RFC 2616)</source>
          <target state="translated">最大转发量(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="2b2d8c8ce404909b199641932433093016cba38f" translate="yes" xml:space="preserve">
          <source>Max-Forwards (RFC 7231)</source>
          <target state="translated">最大转发量(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="02e6cf952f41741b2d0d0521bab1b080b79a5956" translate="yes" xml:space="preserve">
          <source>Maximum number of seconds the results can be cached.</source>
          <target state="translated">缓存结果的最大秒数。</target>
        </trans-unit>
        <trans-unit id="c94f479833c5d401cffdfa7afe6c9c2d56448019" translate="yes" xml:space="preserve">
          <source>May</source>
          <target state="translated">May</target>
        </trans-unit>
        <trans-unit id="cfef933803d5e6538306daeac1d4318fa9cda10c" translate="yes" xml:space="preserve">
          <source>May be set by hosting environments or other frameworks and contains information about them while not providing any usefulness to the application or its visitors. Unset this header to avoid exposing potential vulnerabilities.</source>
          <target state="translated">可能由托管环境或其他框架设置,并包含有关它们的信息,同时不向应用程序或其访问者提供任何有用性。取消设置此标头以避免暴露潜在的漏洞。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="0d2e9b5ce7309f95a7890febc6e837b7f6d73bb0" translate="yes" xml:space="preserve">
          <source>Media formats supported by the HTML audio and video elements</source>
          <target state="translated">HTML音频和视频元素支持的媒体格式</target>
        </trans-unit>
        <trans-unit id="e73c2e204a43c925f331f4a9f4aa965ffa11300d" translate="yes" xml:space="preserve">
          <source>Media is only allowed from media1.com and media2.com (and not from subdomains of those sites).</source>
          <target state="translated">媒体只允许来自media1.com和media2.com(而不是来自这些网站的子域名)。</target>
        </trans-unit>
        <trans-unit id="62da738dbc54cd00c3ecc7aaa0efba6cf80eed5e" translate="yes" xml:space="preserve">
          <source>Message Format (RFC 7230)</source>
          <target state="translated">信息格式(RFC 7230)</target>
        </trans-unit>
        <trans-unit id="cd72d478c14d1e61f4d253f077b3b5817e52cd02" translate="yes" xml:space="preserve">
          <source>Message Routing (RFC 7230)</source>
          <target state="translated">消息路由(RFC 7230)</target>
        </trans-unit>
        <trans-unit id="ed576c67d1fde583bfb7d4b0af04da9e09035d6c" translate="yes" xml:space="preserve">
          <source>Message body information</source>
          <target state="translated">信息主体信息</target>
        </trans-unit>
        <trans-unit id="f1702b4686278becffc88baabe6f4b7a8355532c" translate="yes" xml:space="preserve">
          <source>Messages</source>
          <target state="translated">Messages</target>
        </trans-unit>
        <trans-unit id="f361b914c2431b8337949e5a832a53f9c04c4160" translate="yes" xml:space="preserve">
          <source>Messages are parsed using a generic algorithm, independent of the
   individual header field names.  The contents within a given field
   value are not parsed until a later stage of message interpretation
   (usually after the message's entire header section has been
   processed).  Consequently, this specification does not use ABNF rules
   to define each &quot;Field-Name: Field Value&quot; pair, as was done in
   previous editions.  Instead, this specification uses ABNF rules that
   are named according to each registered field name, wherein the rule
   defines the valid grammar for that field's corresponding field values
   (i.e., after the field-value has been extracted from the header
   section by a generic field parser).

   No whitespace is allowed between the header field-name and colon.  In
   the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.  A
   server MUST reject any received request message that contains
   whitespace between a header field-name and colon with a response code
   of 400 (Bad Request).  A proxy MUST remove any such whitespace from a
   response message before forwarding the message downstream.

   A field value might be preceded and/or followed by optional
   whitespace (OWS); a single SP preceding the field-value is preferred
   for consistent readability by humans.  The field value does not
   include any leading or trailing whitespace: OWS occurring before the
   first non-whitespace octet of the field value or after the last
   non-whitespace octet of the field value ought to be excluded by
   parsers when extracting the field value from a header field.

   Historically, HTTP header field values could be extended over
   multiple lines by preceding each extra line with at least one space
   or horizontal tab (obs-fold).  This specification deprecates such
   line folding except within the message/http media type
   (&lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).  A sender MUST NOT generate a message that includes
   line folding (i.e., that has any field-value that contains a match to
   the obs-fold rule) unless the message is intended for packaging
   within the message/http media type. 

   A server that receives an obs-fold in a request message that is not
   within a message/http container MUST either reject the message by
   sending a 400 (Bad Request), preferably with a representation
   explaining that obsolete line folding is unacceptable, or replace
   each received obs-fold with one or more SP octets prior to
   interpreting the field value or forwarding the message downstream.

   A proxy or gateway that receives an obs-fold in a response message
   that is not within a message/http container MUST either discard the
   message and replace it with a 502 (Bad Gateway) response, preferably
   with a representation explaining that unacceptable line folding was
   received, or replace each received obs-fold with one or more SP
   octets prior to interpreting the field value or forwarding the
   message downstream.

   A user agent that receives an obs-fold in a response message that is
   not within a message/http container MUST replace each received
   obs-fold with one or more SP octets prior to interpreting the field
   value.

   Historically, HTTP has allowed field content with text in the
   ISO-8859-1 charset [&lt;a href=&quot;#ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt;], supporting other charsets only
   through use of [&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC2047&lt;/a&gt;] encoding.  In practice, most HTTP header
   field values use only a subset of the US-ASCII charset [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;].
   Newly defined header fields SHOULD limit their field values to
   US-ASCII octets.  A recipient SHOULD treat other octets in field
   content (obs-text) as opaque data.</source>
          <target state="translated">使用通用算法解析消息，而与各个标头字段名称无关。直到消息解释的后续阶段（通常在处理完消息的整个标头部分之后），才会解析给定字段值内的内容。因此，此规范未使用ABNF规则来定义每个&amp;ldquo;字段名称：字段值&amp;rdquo;对，就像以前的版本一样。相反，本规范使用根据每个注册的字段名称命名的ABNF规则，其中该规则定义了该字段的相应字段值的有效语法（即，在通用字段解析器已从标头部分提取了字段值之后） ）。标头字段名和冒号之间不允许有空格。在过去，这种空白的处理上的差异导致了请求路由和响应处理中的安全漏洞。服务器必须拒绝任何接收到的请求消息，该请求消息的头域名称和冒号之间包含空格，响应码为400（错误请求）。在向下游转发消息之前，代理必须从响应消息中删除任何这样的空格。字段值可以在可选的空格（OWS）之前和/或之后；为了使人类具有一致的可读性，最好在字段值之前使用单个SP。字段值不包含任何前导或尾随空格：从标题字段中提取字段值时，解析器应排除在字段值的第一个非空白八位字节之前或字段值的最后一个非空白八位字节之后发生的OWS。从历史上看，HTTP标头字段值可以通过在每条额外的行之前添加至少一个空格或水平制表符（折叠）来扩展多行。除了在message / http媒体类型（&lt;a href=&quot;#section-8.3.1&quot;&gt;第8.3.1节&lt;/a&gt;）。发件人不得生成包含换行符的消息（即，其任何字段值都包含与obs-fold规则匹配的消息），除非该消息打算用于包装在message / http媒体类型内。接收到不在消息/ http容器之内的请求消息中包含obs-fold的服务器必须通过发送400（错误请求）拒绝消息，最好使用一种表示过时的行折叠是不可接受的表示法，或者替换每个在解释字段值或向下游转发消息之前，先接收一个或多个SP八位位组的二进制文件。接收到不在消息/ http容器内的响应消息中包含obs-fold的代理或网关必须丢弃该消息，并将其替换为502（错误网关）响应，最好使用一种解释说明已接收到不可接受的行折叠，或者在解释字段值或向下游转发消息之前，用一个或多个SP八位位组替换每个接收到的对折。在消息/ http容器之外的响应消息中收到obs-fold的用户代理必须在解释字段值之前用一个或多个SP八位位组替换每个收到的obs-fold。历史上，HTTP允许使用ISO-8859-1字符集[接收到不在消息/ http容器中的响应消息中包含obs-fold的用户代理必须在解释字段值之前用一个或多个SP八位位组替换每个接收到的obs-fold。历史上，HTTP允许使用ISO-8859-1字符集[在消息/ http容器之外的响应消息中接收到obs-fold的用户代理必须在解释字段值之前用一个或多个SP八位位组替换每个接收到的obs-fold。历史上，HTTP允许使用ISO-8859-1字符集[&lt;a href=&quot;#ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt; ]，仅通过使用[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC2047&lt;/a&gt; ]编码支持其他字符集。实际上，大多数HTTP标头字段值仅使用US-ASCII字符集[ &lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ] 的子集。新定义的标头字段应将其字段值限制为US-ASCII八位位组。接收者应将字段内容（obs-text）中的其他八位字节视为不透明数据。</target>
        </trans-unit>
        <trans-unit id="a45a53f69ac8d4f9beb81fdb6abdda0d81b83401" translate="yes" xml:space="preserve">
          <source>Meta tag configuration</source>
          <target state="translated">元标签配置</target>
        </trans-unit>
        <trans-unit id="d3bc7449553df912945049faf23d54805daa3cef" translate="yes" xml:space="preserve">
          <source>Method Definitions (RFC 2616)</source>
          <target state="translated">方法定义(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="cb7ac4b5940dd1c323d62b5a8e651330e7495257" translate="yes" xml:space="preserve">
          <source>Method and body not changed</source>
          <target state="translated">方法和主体不变</target>
        </trans-unit>
        <trans-unit id="2d2721aaa9ac715c71cff1347bdeb0765b82f40d" translate="yes" xml:space="preserve">
          <source>Method and body not changed.</source>
          <target state="translated">方法和体例没有改变。</target>
        </trans-unit>
        <trans-unit id="53d262d73147d297967a65df5e7306875b16e48d" translate="yes" xml:space="preserve">
          <source>Method handling</source>
          <target state="translated">方法处理</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="7e8cf9e2eae4020fb1e8917e8ab3068925ba7380" translate="yes" xml:space="preserve">
          <source>Methods can also have the property of &quot;idempotence&quot; in that (aside
   from error or expiration issues) the side-effects of N &amp;gt; 0 identical
   requests is the same as for a single request. The methods GET, HEAD,
   PUT and DELETE share this property. Also, the methods OPTIONS and
   TRACE SHOULD NOT have side effects, and so are inherently idempotent. 

   However, it is possible that a sequence of several requests is non-
   idempotent, even if all of the methods executed in that sequence are
   idempotent. (A sequence is idempotent if a single execution of the
   entire sequence always yields a result that is not changed by a
   reexecution of all, or part, of that sequence.) For example, a
   sequence is non-idempotent if its result depends on a value that is
   later modified in the same sequence.

   A sequence that never has side effects is idempotent, by definition
   (provided that no concurrent operations are being executed on the
   same set of resources).</source>
          <target state="translated">方法还可以具有&amp;ldquo;幂等&amp;rdquo;的特性，因为（错误或过期问题除外）N&amp;gt; 0个相同请求的副作用与单个请求的副作用相同。 GET，HEAD，PUT和DELETE方法共享此属性。同样，方法OPTIONS和TRACE不应有副作用，因此本质上是幂等的。但是，即使按顺序执行的所有方法都是幂等的，几个请求的序列也可能是非幂等的。 （如果整个序列的单次执行始终产生的结果不会因重新执行该序列的全部或一部分而改变，则该序列是幂等的。）例如，如果序列的结果取决于a，则该序列是非幂等的。以后按相同顺序修改的值。根据定义，从不具有副作用的序列是幂等的（前提是在同一组资源上不执行任何并发操作）。</target>
        </trans-unit>
        <trans-unit id="242805378404a310345cf70839197bf474f74005" translate="yes" xml:space="preserve">
          <source>Microphone</source>
          <target state="translated">Microphone</target>
        </trans-unit>
        <trans-unit id="87276ecf605640589cec1d79d00bf26c970b94e4" translate="yes" xml:space="preserve">
          <source>Microsoft Excel</source>
          <target state="translated">微软Excel</target>
        </trans-unit>
        <trans-unit id="2a323ed6449b617238b82a3dfc75eb9621adc7da" translate="yes" xml:space="preserve">
          <source>Microsoft Excel (OpenXML)</source>
          <target state="translated">微软Excel(OpenXML)</target>
        </trans-unit>
        <trans-unit id="ab9f2a2052ea77406213e4dbe99b5967437a187b" translate="yes" xml:space="preserve">
          <source>Microsoft Icon</source>
          <target state="translated">微软图标</target>
        </trans-unit>
        <trans-unit id="95afea748c2d83deeb5e505cb3467080a79ec0dd" translate="yes" xml:space="preserve">
          <source>Microsoft PowerPoint</source>
          <target state="translated">微软PowerPoint</target>
        </trans-unit>
        <trans-unit id="66f10ebd0f328820d7789369e62c94f10eb4d83b" translate="yes" xml:space="preserve">
          <source>Microsoft PowerPoint (OpenXML)</source>
          <target state="translated">Microsoft PowerPoint (OpenXML)</target>
        </trans-unit>
        <trans-unit id="f8f6993a5165c131c1d8c5214734c809b756f2ef" translate="yes" xml:space="preserve">
          <source>Microsoft Visio</source>
          <target state="translated">微软Visio</target>
        </trans-unit>
        <trans-unit id="1549499155dcad76ee4cf933519cd8cacaf632b7" translate="yes" xml:space="preserve">
          <source>Microsoft Word</source>
          <target state="translated">微软Word</target>
        </trans-unit>
        <trans-unit id="36cf4ee07cac5059a5ad97ffe928503bd176751c" translate="yes" xml:space="preserve">
          <source>Microsoft Word (OpenXML)</source>
          <target state="translated">Microsoft Word (OpenXML)</target>
        </trans-unit>
        <trans-unit id="1198ed8512c8cdd797293daa67494bddc3770413" translate="yes" xml:space="preserve">
          <source>Microsoft document</source>
          <target state="translated">微软文档</target>
        </trans-unit>
        <trans-unit id="039b0b863da28e2c4f9c09377b4e7260a857282b" translate="yes" xml:space="preserve">
          <source>Microsoft in general made its own implementation. There used to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_auto-config#Old_Microsoft_problems&quot;&gt;some problems with their libraries&lt;/a&gt;, but most are resolved by now. They have defined &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/winhttp/ipv6-extensions-to-navigator-auto-config-file-format&quot;&gt;some new &quot;Ex&quot; suffixed functions&lt;/a&gt; around the address handling parts to support IPv6. The feature is supported by Chromium, but not yet by Firefox (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=558253&quot;&gt;bugzilla #558253&lt;/a&gt;).</source>
          <target state="translated">微软通常会自己实施。&lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_auto-config#Old_Microsoft_problems&quot;&gt;他们的库&lt;/a&gt;过去曾经有一些问题，但是现在大多数问题已经解决了。他们在地址处理部分周围定义了&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/winhttp/ipv6-extensions-to-navigator-auto-config-file-format&quot;&gt;一些新的&lt;/a&gt;带有&amp;ldquo; Ex&amp;rdquo;后缀的功能，以支持IPv6。Chromium支持此功能，但Firefox不支持此功能（&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=558253&quot;&gt;bugzilla＃558253&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1df4b94ae4d5602d088aff532dae5e38510a6678" translate="yes" xml:space="preserve">
          <source>Midi</source>
          <target state="translated">Midi</target>
        </trans-unit>
        <trans-unit id="f3c717723ab8734d12784f68a0722e11e80fcc72" translate="yes" xml:space="preserve">
          <source>Minutes from 0 to 59.</source>
          <target state="translated">分钟从0到59。</target>
        </trans-unit>
        <trans-unit id="89539c6918ebad2db5606b4128932b01811ff405" translate="yes" xml:space="preserve">
          <source>Miscellaneous Persistent Warning</source>
          <target state="translated">各种持续警告</target>
        </trans-unit>
        <trans-unit id="a58539b42f2a5b03e79f0e0357f01220b1c564c9" translate="yes" xml:space="preserve">
          <source>Miscellaneous Warning</source>
          <target state="translated">杂项警告</target>
        </trans-unit>
        <trans-unit id="6440b6c15fbd440237dd7ddf04fa83c555b31d51" translate="yes" xml:space="preserve">
          <source>Mitigating MIME Confusion Attacks in Firefox</source>
          <target state="translated">缓解Firefox中的MIME混淆攻击</target>
        </trans-unit>
        <trans-unit id="5d489f5457c01748e6b6d121f8ab0bb76ce6faab" translate="yes" xml:space="preserve">
          <source>Mitigating cross site scripting</source>
          <target state="translated">缓解跨站点脚本的问题</target>
        </trans-unit>
        <trans-unit id="a06d1d2ac6f2847420dd550f09dcb2166ef5252d" translate="yes" xml:space="preserve">
          <source>Mitigating packet sniffing attacks</source>
          <target state="translated">缓解数据包嗅探攻击</target>
        </trans-unit>
        <trans-unit id="f7fb61404c2b0add12a8de94361ca1262d06c970" translate="yes" xml:space="preserve">
          <source>Mixed Content</source>
          <target state="translated">混合内容</target>
        </trans-unit>
        <trans-unit id="4a03a5aca91ea4ae835ab37b3456e345e1c824ad" translate="yes" xml:space="preserve">
          <source>Mixed Content&lt;br/&gt;&lt;small&gt;The definition of 'block-all-mixed-content' in that specification.&lt;/small&gt;</source>
          <target state="translated">混合内容&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;块所有混合内容&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="69248b8f3367a963f6ed1431265d03d542c43778" translate="yes" xml:space="preserve">
          <source>Mixed content</source>
          <target state="translated">混合内容</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="0efeb0636336539c3bcea3d1fe128360ba3a0b9d" translate="yes" xml:space="preserve">
          <source>Mobile Device Detection</source>
          <target state="translated">移动设备检测</target>
        </trans-unit>
        <trans-unit id="2ae9795ad44783e26e39ba8db6b981786d39f71b" translate="yes" xml:space="preserve">
          <source>Mobile and Tablet indicators</source>
          <target state="translated">移动和平板电脑指标</target>
        </trans-unit>
        <trans-unit id="165a63ecf9a6d73eec0fb95be501c468fde2ff9d" translate="yes" xml:space="preserve">
          <source>Mobile device detection</source>
          <target state="translated">移动设备检测</target>
        </trans-unit>
        <trans-unit id="183f26ae5771e151ff87bc3aac010eef4b387ac0" translate="yes" xml:space="preserve">
          <source>Mobile, Tablet or Desktop</source>
          <target state="translated">移动、平板电脑或桌面</target>
        </trans-unit>
        <trans-unit id="6ea99682b2b19e3567543027b85a36a6c1be1a86" translate="yes" xml:space="preserve">
          <source>Model data for a 3D object or scene. Examples include &lt;code&gt;model/3mf&lt;/code&gt; and &lt;code&gt;model/vml&lt;/code&gt;.</source>
          <target state="translated">3D对象或场景的模型数据。示例包括 &lt;code&gt;model/3mf&lt;/code&gt; 和 &lt;code&gt;model/vml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5864387b4a66bda62e2067620df614155f02985" translate="yes" xml:space="preserve">
          <source>More detail and examples are provided in the topic &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;协议升级机制&lt;/a&gt;主题中提供了更多详细信息和示例。</target>
        </trans-unit>
        <trans-unit id="7b1e02c916056823b64ff86eab6f60b7e49761cf" translate="yes" xml:space="preserve">
          <source>More specifically, this article is for &lt;strong&gt;web administrators&lt;/strong&gt;, &lt;strong&gt;server developers&lt;/strong&gt;, and &lt;strong&gt;front-end developers&lt;/strong&gt;. Modern browsers handle the client side of cross-origin sharing, including headers and policy enforcement. But the CORS standard means servers have to handle new request and response headers. Another article for server developers discussing &lt;a href=&quot;server-side_access_control&quot;&gt;cross-origin sharing from a server perspective (with PHP code snippets)&lt;/a&gt; is supplementary reading.</source>
          <target state="translated">更具体地说，本文适用于&lt;strong&gt;Web管理员&lt;/strong&gt;，&lt;strong&gt;服务器开发人员&lt;/strong&gt;和&lt;strong&gt;前端开发人员&lt;/strong&gt;。现代浏览器处理跨域共享的客户端，包括标头和策略实施。但是，CORS标准意味着服务器必须处理新的请求和响应头。服务器开发人员的另一篇文章是&lt;a href=&quot;server-side_access_control&quot;&gt;从服务器角度&lt;/a&gt;讨论跨域共享（带有PHP代码段）的补充读物。</target>
        </trans-unit>
        <trans-unit id="1387238e2992cdaf972778c0a1519b7892c33930" translate="yes" xml:space="preserve">
          <source>More specifically, this article is for web administrators, server developers, and front-end developers. Modern browsers handle the client-side components of cross-origin sharing, including headers and policy enforcement. But this new standard means servers have to handle new request and response headers. Another article for server developers discussing &lt;a href=&quot;server-side_access_control&quot;&gt;cross-origin sharing from a server perspective (with PHP code snippets)&lt;/a&gt; is supplementary reading.</source>
          <target state="translated">更具体地说，本文适用于Web管理员，服务器开发人员和前端开发人员。现代浏览器可以处理跨域共享的客户端组件，包括标头和策略实施。但是这个新标准意味着服务器必须处理新的请求和响应头。服务器开发人员的另一篇文章是&lt;a href=&quot;server-side_access_control&quot;&gt;从服务器角度&lt;/a&gt;讨论跨域共享（带有PHP代码段）的补充读物。</target>
        </trans-unit>
        <trans-unit id="4d672ad094374129b7ac45aa56021f772e22d674" translate="yes" xml:space="preserve">
          <source>More than 15 years of extensions</source>
          <target state="translated">延长15年以上</target>
        </trans-unit>
        <trans-unit id="93defa8d9384e526ec8c563df8553e7f68474a93" translate="yes" xml:space="preserve">
          <source>More than one &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header was sent by the server. This isn't allowed.</source>
          <target state="translated">服务器发送了多个&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;标头。这是不允许的。</target>
        </trans-unit>
        <trans-unit id="1be543deb68df132d0c179bafbe0c9f9d5ae66cd" translate="yes" xml:space="preserve">
          <source>Most HTTP header field values are defined using common syntax
   components (token, quoted-string, and comment) separated by
   whitespace or specific delimiting characters.  Delimiters are chosen
   from the set of US-ASCII visual characters not allowed in a token
   (DQUOTE and &quot;(),/:;&amp;lt;=&amp;gt;?@[\]{}&quot;).

     token          = 1*tchar

     tchar          = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;amp;&quot; / &quot;'&quot; / &quot;*&quot;
                    / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; / &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot;
                    / DIGIT / ALPHA
                    ; any VCHAR, except delimiters

   A string of text is parsed as a single value if it is quoted using
   double-quote marks.

     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
     obs-text       = %x80-FF

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses.  Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.

     comment        = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
     ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text

   The backslash octet (&quot;\&quot;) can be used as a single-octet quoting
   mechanism within quoted-string and comment constructs.  Recipients
   that process the value of a quoted-string MUST handle a quoted-pair
   as if it were replaced by the octet following the backslash.

     quoted-pair    = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )

   A sender SHOULD NOT generate a quoted-pair in a quoted-string except
   where necessary to quote DQUOTE and backslash octets occurring within
   that string.  A sender SHOULD NOT generate a quoted-pair in a comment
   except where necessary to quote parentheses [&quot;(&quot; and &quot;)&quot;] and
   backslash octets occurring within that comment.</source>
          <target state="translated">大多数HTTP标头字段值都是使用常见的语法组件（令牌，带引号的字符串和注释）定义的，这些组件由空格或特定的定界字符分隔。分隔符是从令牌中不允许的US-ASCII可视字符集中选择的（DQUOTE和&amp;ldquo;（），/ :; &amp;lt;=&amp;gt;？@ [\] {}&amp;rdquo;）。令牌= 1 * tchar tchar =&amp;ldquo;！&amp;rdquo; /&amp;ldquo;＃&amp;rdquo; /&amp;ldquo; $&amp;rdquo; /&amp;ldquo;％&amp;rdquo; /&amp;ldquo;＆&amp;rdquo; /&amp;ldquo;'&amp;rdquo; /&amp;ldquo; *&amp;rdquo; /&amp;ldquo; +&amp;rdquo; /&amp;ldquo;-&amp;rdquo; /&amp;ldquo;。 /&amp;ldquo; ^&amp;rdquo; /&amp;ldquo; _&amp;rdquo; /&amp;ldquo;`&amp;rdquo; /&amp;ldquo; |&amp;rdquo; /&amp;ldquo;〜&amp;rdquo; / DIGIT / ALPHA;除分隔符外的任何VCHAR如果使用双引号将文本字符串引起来，则将其解析为单个值。带引号的字符串= DQUOTE *（qdtext /引号对）DQUOTE qdtext = HTAB / SP /％x21 /％x23-5B /％x5D-7E / obs-text obs-text =％x80-FF HTTP标头字段，将注释文本括在括号中。仅在包含&amp;ldquo;注释&amp;rdquo;作为其字段值定义一部分的字段中才允许使用注释。 comment =&amp;ldquo;（&amp;rdquo; *（ctext /引号对/ comment）&amp;ldquo;）&amp;rdquo; ctext = HTAB / SP /％x21-27 /％x2A-5B /％x5D-7E / obs-text反斜杠八位字节（&amp;ldquo; \&amp;rdquo;）可以用作带引号的字符串和注释构造中的单字节引用机制。处理带引号的字符串的值的接收者必须处理带引号的对，就好像它被反斜杠后的八位字节所代替。 quoted-pair =&amp;ldquo;\&amp;ldquo;（HTAB / SP / VCHAR / obs-text）发送者不应该在带引号的字符串中生成带引号的对，除非有必要对字符串中出现的DQUOTE和反斜杠八位字节加引号。发送者不应该生成带引号的对在注释中，除非有必要在该注释中引用括号[&amp;ldquo;（&amp;rdquo;和&amp;ldquo;）&amp;rdquo;]和反斜杠八位字节）。</target>
        </trans-unit>
        <trans-unit id="812bdf18b5a605c99457c43782814e036fcbedcf" translate="yes" xml:space="preserve">
          <source>Most HTTP responses include an entity which contains information for
   interpretation by a human user. Naturally, it is desirable to supply
   the user with the &quot;best available&quot; entity corresponding to the
   request. Unfortunately for servers and caches, not all users have the
   same preferences for what is &quot;best,&quot; and not all user agents are
   equally capable of rendering all entity types. For that reason, HTTP
   has provisions for several mechanisms for &quot;content negotiation&quot; --
   the process of selecting the best representation for a given response
   when there are multiple representations available.

      Note: This is not called &quot;format negotiation&quot; because the
      alternate representations may be of the same media type, but use
      different capabilities of that type, be in different languages,
      etc. 

   Any response containing an entity-body MAY be subject to negotiation,
   including error responses.

   There are two kinds of content negotiation which are possible in
   HTTP: server-driven and agent-driven negotiation. These two kinds of
   negotiation are orthogonal and thus may be used separately or in
   combination. One method of combination, referred to as transparent
   negotiation, occurs when a cache uses the agent-driven negotiation
   information provided by the origin server in order to provide
   server-driven negotiation for subsequent requests.</source>
          <target state="translated">大多数HTTP响应包括一个实体,其中包含供人类用户解释的信息。自然,向用户提供与请求相对应的 &quot;最佳可用 &quot;实体是可取的。不幸的是,对于服务器和缓存来说,并不是所有的用户对什么是 &quot;最好的 &quot;都有相同的偏好,也不是所有的用户代理都同样能够呈现所有的实体类型。出于这个原因,HTTP规定了几种 &quot;内容协商 &quot;机制--当有多种表示方式可用时,为给定响应选择最佳表示方式的过程。注意:这不叫 &quot;格式协商&quot;,因为替代的表示可能是相同的媒体类型,但使用该类型的不同功能,是不同的语言等。任何包含实体主体的响应都可以进行协商,包括错误响应。在HTTP中,有两种内容协商是可能的:服务器驱动的协商和代理驱动的协商。这两种协商是正交的,因此可以单独使用,也可以结合使用。其中一种组合方法被称为透明协商,当缓存使用源服务器提供的代理驱动协商信息,以便为后续请求提供服务器驱动协商时,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="7460036b5d618f72b9d5e87b1f21806669419e9d" translate="yes" xml:space="preserve">
          <source>Most browsers set the name and version in the format &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt;, with the notable exception of Internet Explorer. But as the name is not the only information in a user agent string that is in that format, you can not discover the name of the browser, you can only check if the name you are looking for. But note that some browsers are lying: Chrome for example reports both as Chrome and Safari. So to detect Safari you have to check for the Safari string and the absence of the Chrome string, Chromium often reports itself as Chrome too or Seamonkey sometimes reports itself as Firefox.</source>
          <target state="translated">大多数浏览器都以&lt;em&gt;BrowserName / VersionNumber&lt;/em&gt;格式设置名称和版本，Internet Explorer除外。但是，由于名称不是该格式的用户代理字符串中唯一的信息，因此您无法发现浏览器的名称，因此只能检查您要查找的名称。但请注意，有些浏览器在撒谎：例如，Chrome会同时报告Chrome和Safari。因此，要检测Safari，您必须检查Safari字符串以及是否缺少Chrome字符串，Chromium经常也将自己报告为Chrome，或者Seamonkey有时将自己报告为Firefox。</target>
        </trans-unit>
        <trans-unit id="e4008ade4042fb7c7a965933bdf292eb96d44308" translate="yes" xml:space="preserve">
          <source>Most importantly, it assumed no other browsers would support the feature. Support could have been added to other browsers at any time, but this code would have continued choosing the inferior path.</source>
          <target state="translated">最重要的是,它假设其他浏览器不支持该功能。其他浏览器可以随时添加支持,但这段代码会继续选择劣势路径。</target>
        </trans-unit>
        <trans-unit id="8812a6ba3333d88ab3035fd80151158d9cd5096a" translate="yes" xml:space="preserve">
          <source>Most of the standard JavaScript functionality is available for use in the &lt;code&gt;FindProxyForURL()&lt;/code&gt; function. As an example, to set different proxies based on the protocol the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith&quot;&gt;&lt;code&gt;startsWith()&lt;/code&gt;&lt;/a&gt; function can be used:</source>
          <target state="translated">大多数标准JavaScript功能都可以在 &lt;code&gt;FindProxyForURL()&lt;/code&gt; 函数中使用。例如，要基于协议设置不同的代理，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith&quot;&gt; &lt;code&gt;startsWith()&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="02c0fa975a9a4f1c1a39487a5147f2636b69eb9e" translate="yes" xml:space="preserve">
          <source>Most of the standard JavaScript functionality is available for use in the FindProxyForURL() function. As an example, to set different proxies based on the protocol the substring() function can be used:</source>
          <target state="translated">大多数标准的JavaScript功能都可以在FindProxyForURL()函数中使用。例如,要根据协议设置不同的代理,可以使用substring()函数。</target>
        </trans-unit>
        <trans-unit id="92624466818eb51fd53a17208603205adea7766c" translate="yes" xml:space="preserve">
          <source>Most of the time identity and location of a Web resource are shared, this can be changed with the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Web资源的大多数时间标识和位置是共享的，可以使用&lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;标头更改此信息。</target>
        </trans-unit>
        <trans-unit id="112a5d486922ba62900e7ec6537ffa88c946451f" translate="yes" xml:space="preserve">
          <source>Most of the time the identity and location of a web resource are shared, this can be changed with the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">大多数情况下，Web资源的标识和位置是共享的，这可以使用&lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;标头进行更改。</target>
        </trans-unit>
        <trans-unit id="7b365dcd7a6f5dfd969c8f5a85717b49e744e8f9" translate="yes" xml:space="preserve">
          <source>Most of the time this is a server problem, and if the server cannot detect it, it will send back a &lt;a href=&quot;status/500&quot;&gt;&lt;code&gt;500&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Internal Server Error&lt;/code&gt;. If you encounter such an error soon after modifying a server configuration, this is likely a redirection loop.</source>
          <target state="translated">在大多数情况下，这是服务器问题，如果服务器无法检测到它，它将发回&lt;a href=&quot;status/500&quot;&gt; &lt;code&gt;500&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Internal Server Error&lt;/code&gt; 。如果在修改服务器配置后不久遇到此类错误，则可能是重定向循环。</target>
        </trans-unit>
        <trans-unit id="bd93e26ede2192a4f8e353e3bbf7ab476b541a23" translate="yes" xml:space="preserve">
          <source>Most rendering engines put the version number in the &lt;em&gt;RenderingEngine/VersionNumber&lt;/em&gt; token, with the notable exception of Gecko. Gecko puts the Gecko version number in the comment part of the User Agent after the &lt;code&gt;rv:&lt;/code&gt; string. From Gecko 14 for the mobile version and Gecko 17 for the desktop version, it also puts this value in the &lt;code&gt;Gecko/version&lt;/code&gt; token (previous version put there the build date, then a fixed date called the GeckoTrail).</source>
          <target state="translated">除了Gecko以外，大多数渲染引擎都将版本号放入&lt;em&gt;RenderingEngine / VersionNumber&lt;/em&gt;令牌中。Gecko在 &lt;code&gt;rv:&lt;/code&gt; 字符串后将Gecko版本号放在用户代理的注释部分中。从用于移动版本的Gecko 14和用于桌面版本的Gecko 17开始，该值还会将其放在 &lt;code&gt;Gecko/version&lt;/code&gt; 令牌中（先前的版本将其生成日期，然后是一个固定的日期，称为GeckoTrail）。</target>
        </trans-unit>
        <trans-unit id="5accc4ae9c97c9b25a00a6dd3d1020db39dc3e71" translate="yes" xml:space="preserve">
          <source>Most values in SETTINGS benefit from or require an understanding of
   when the peer has received and applied the changed parameter values.
   In order to provide such synchronization timepoints, the recipient of
   a SETTINGS frame in which the ACK flag is not set MUST apply the
   updated parameters as soon as possible upon receipt.

   The values in the SETTINGS frame MUST be processed in the order they
   appear, with no other frame processing between values.  Unsupported
   parameters MUST be ignored.  Once all values have been processed, the 

   recipient MUST immediately emit a SETTINGS frame with the ACK flag
   set.  Upon receiving a SETTINGS frame with the ACK flag set, the
   sender of the altered parameters can rely on the setting having been
   applied.

   If the sender of a SETTINGS frame does not receive an acknowledgement
   within a reasonable amount of time, it MAY issue a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type SETTINGS_TIMEOUT.</source>
          <target state="translated">SETTINGS中的大多数值都受益于或需要了解对等方何时接收并应用更改后的参数值。为了提供这样的同步时间点，未设置ACK标志的SETTINGS帧的接收者务必在收到后尽快应用更新后的参数。 SETTINGS帧中的值必须按它们出现的顺序进行处理，值之间不得进行其他帧处理。不支持的参数必须被忽略。处理完所有值后，接收者必须立即发出带有ACK标志设置的SETTINGS帧。在接收到设置了ACK标志的SETTINGS帧后，更改后的参数的发送方可以依赖于已应用的设置。如果&amp;ldquo;设置&amp;rdquo;帧的发送者在合理的时间内未收到确认，它可能会发出连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;类型SETTINGS_TIMEOUT的第5.4.1节）。</target>
        </trans-unit>
        <trans-unit id="c37f0d1445fedf718be400753c3dbf6a2412f759" translate="yes" xml:space="preserve">
          <source>Most web servers send unrecognized resources as the &lt;code&gt;application/octet-stream&lt;/code&gt; MIME type. For security reasons, most browsers do not allow setting a custom default action for such resources, forcing the user to save it to disk to use it.</source>
          <target state="translated">大多数Web服务器将无法识别的资源作为 &lt;code&gt;application/octet-stream&lt;/code&gt; MIME类型发送。出于安全原因，大多数浏览器不允许为此类资源设置自定义默认操作，从而迫使用户将其保存到磁盘以使用它。</target>
        </trans-unit>
        <trans-unit id="6a8946eed2c78e3706e8f2276333fa60dc5390eb" translate="yes" xml:space="preserve">
          <source>Moving to a different domain. For example, your company has been renamed and you when searching for the old name, you want people used to the old company Web site still find you under the new name.</source>
          <target state="translated">移动到不同的域名。例如,您的公司已经重新命名,而您在搜索旧名时,您希望习惯使用旧公司网站的人仍能在新名下找到您。</target>
        </trans-unit>
        <trans-unit id="fe05d533d29bed0680c710b5026f9e8e7d2dbbe4" translate="yes" xml:space="preserve">
          <source>Moving to a new domain</source>
          <target state="translated">移动到一个新的域名</target>
        </trans-unit>
        <trans-unit id="0ef3be393a351dfa2ef963cfdc34f9e6563cc892" translate="yes" xml:space="preserve">
          <source>Mozilla (Gecko, Firefox)</source>
          <target state="translated">Mozilla (Gecko,Firefox)</target>
        </trans-unit>
        <trans-unit id="a0934075575145263129d33cbbd963bcda3860f4" translate="yes" xml:space="preserve">
          <source>Mozilla Observatory</source>
          <target state="translated">Mozilla观察站</target>
        </trans-unit>
        <trans-unit id="decab94514e261dda8ed0ab5f5a50868157343e3" translate="yes" xml:space="preserve">
          <source>Mozilla web security guidelines</source>
          <target state="translated">Mozilla网络安全指南</target>
        </trans-unit>
        <trans-unit id="0fee1a221e5d621522c4cae25d2d3f0781412c73" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 4.4; Mobile; rv:41.0) Gecko/41.0 Firefox/41.0</source>
          <target state="translated">Mozilla/5.0 (Android 4.4;Mobile;rv:41.0)Gecko/41.0 Firefox/41.0</target>
        </trans-unit>
        <trans-unit id="06ca2e8b107ebc3017f1b6838abe49d90a2337b1" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 4.4; Tablet; rv:41.0) Gecko/41.0 Firefox/41.0</source>
          <target state="translated">Mozilla/5.0 (Android 4.4;平板电脑;rv:41.0)Gecko/41.0 Firefox/41.0</target>
        </trans-unit>
        <trans-unit id="12388f0ea73a7de9d571898b4be2154ce15cb9f4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 7.0; Mobile; rv:62.0) Gecko/62.0 Firefox/62.0</source>
          <target state="translated">Mozilla/5.0 (Android 7.0;Mobile;rv:62.0)Gecko/62.0 Firefox/62.0</target>
        </trans-unit>
        <trans-unit id="adf944b54ec9b6df9ba954b5789e4f037d57ad12" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Mobile; rv:13.0) Gecko/13.0 Firefox/13.0</source>
          <target state="translated">Mozilla/5.0 (Android;Mobile;rv:13.0)Gecko/13.0 Firefox/13.0</target>
        </trans-unit>
        <trans-unit id="4d33bd8f87ba06abe4fe1c0b9f3fd3d4ef39a64b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/40.0</source>
          <target state="translated">Mozilla/5.0 (Android;Mobile;rv:40.0)Gecko/40.0 Firefox/40.0</target>
        </trans-unit>
        <trans-unit id="b1165e7e7925427d068dfe4278ee0a0ab81d03a6" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Tablet; rv:40.0) Gecko/40.0 Firefox/40.0</source>
          <target state="translated">Mozilla/5.0 (Android;平板电脑;rv:40.0)Gecko/40.0 Firefox/40.0</target>
        </trans-unit>
        <trans-unit id="1eff4492cf201da272b181a0826abf69087bdbae" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 4.4.2); Nexus 5 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.117 Mobile Safari/537.36 OPR/20.0.1396.72047</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 4.4.2);Nexus 5 Build/KOT49H)AppleWebKit/537.36 (KHTML,像 Gecko)Chrome/33.0.1750.117 Mobile Safari/537.36 OPR/20.0.1396.72047</target>
        </trans-unit>
        <trans-unit id="187263e2548b4eea2d8d1b7718d1e58bc486ee8f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 5.1.1) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.1 Chrome/59.0.3017.125 Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 5.1.1)AppleWebKit/537.36 (KHTML,like Gecko)Version/4.0 Focus/1.1 Chrome/59.0.3017.125 Safari/537.36</target>
        </trans-unit>
        <trans-unit id="f069d17af594e5cc6ceb8bcf6da674fc68ec9615" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.0)AppleWebKit/537.36 (KHTML,像 Gecko)Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Mobile Safari/537.36</target>
        </trans-unit>
        <trans-unit id="5cdca6439d9f4f75159a9c3f7e09c52e695e1e6d" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.0)AppleWebKit/537.36 (KHTML,像 Gecko)Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Safari/537.36</target>
        </trans-unit>
        <trans-unit id="d3772cfc2095a71baa2d031dbccc5f42fe0a9faa" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/4.1 Chrome/62.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.0)AppleWebKit/537.36 (KHTML,像Gecko一样)Version/4.0 Focus/4.1 Chrome/62.0.3029.83 移动Safari/537.36</target>
        </trans-unit>
        <trans-unit id="5c9a7c5212d961b33810bd5d24bd5d65d22acc7b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Klar/1.0 Chrome/58.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.0)AppleWebKit/537.36 (KHTML,像 Gecko)Version/4.0 Klar/1.0 Chrome/58.0.3029.83 移动 Safari/537.36</target>
        </trans-unit>
        <trans-unit id="3ebf95e0e00b50d02895700858ee637ccce16aee" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.1.2) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/3.0 Chrome/59.0.3017.125 Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.1.2)AppleWebKit/537.36 (KHTML,像 Gecko)Version/4.0 Focus/3.0 Chrome/59.0.3017.125 Safari/537.36</target>
        </trans-unit>
        <trans-unit id="2107ee483b37620cd27469a83622677f75ba74e7" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; U; Android 4.0.3; de-ch; HTC Sensation Build/IML74K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</source>
          <target state="translated">Mozilla/5.0 (Linux;U;Android 4.0.3;de-ch;HTC Sensation Build/IML74K)AppleWebKit/534.30 (KHTML,like Gecko)Version/4.0 Mobile Safari/534.30。</target>
        </trans-unit>
        <trans-unit id="b1d3f926e92bfa21fd4b0d0fe771e000d5d2b871" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla/5.0 (Macintosh;Intel Mac OS X 10.5;rv:10.0.1)Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</target>
        </trans-unit>
        <trans-unit id="6d87ab26fc3278b385f67646186cafe62f1226c0" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; rv:2.0.1) Gecko/20100101 Firefox/4.0.1 Camino/2.2.1</source>
          <target state="translated">Mozilla/5.0 (Macintosh;Intel Mac OS X 10.5;rv:2.0.1)Gecko/20100101 Firefox/4.0.1 Camino/2.2.1</target>
        </trans-unit>
        <trans-unit id="08a47789f901ac4697d74b3d7f335103a2d1b4b2" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X &lt;em&gt;x.y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0（Macintosh; Intel Mac OS X &lt;em&gt;xy&lt;/em&gt; ; rv：10.0）Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="92e71ac1941b70b8a195b2038b988eb15e2633cf" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; PPC Mac OS X &lt;em&gt;x.y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0（Macintosh; PPC Mac OS X &lt;em&gt;xy&lt;/em&gt; ; rv：10.0）Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="49a7b83668313b9e1281eda63779e0047234a704" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Maemo; Linux armv7l; rv:10.0) Gecko/20100101 Firefox/10.0 Fennec/10.0</source>
          <target state="translated">Mozilla/5.0 (Maemo;Linux armv7l;rv:10.0)Gecko/20100101 Firefox/10.0 Fennec/10.0</target>
        </trans-unit>
        <trans-unit id="4912bc7f8d14158acb5958155825887af72f69e0" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Maemo; Linux armv7l; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 Fennec/10.0.1</source>
          <target state="translated">Mozilla/5.0 (Maemo;Linux armv7l;rv:10.0.1)Gecko/20100101 Firefox/10.0.1 Fennec/10.0.1</target>
        </trans-unit>
        <trans-unit id="24d7bfb4e448eb6a6f2b2c05f9ccace8303e7951" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Mobile; &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla / 5.0（移动版；&lt;em&gt;&lt;strong&gt;nnnn；&lt;/strong&gt;&lt;/em&gt; rv：26.0）Gecko / 26.0 Firefox / 26.0</target>
        </trans-unit>
        <trans-unit id="fe824479059b41314b08fccf6ffd2df216b210a4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Mobile; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla/5.0 (Mobile;rv:26.0)Gecko/26.0 Firefox/26.0</target>
        </trans-unit>
        <trans-unit id="1e65d98e39260d268ec140c75dfc14eb88fe1d22" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (TV; rv:44.0) Gecko/44.0 Firefox/44.0</source>
          <target state="translated">Mozilla/5.0 (TV;rv:44.0)Gecko/44.0 Firefox/44.0</target>
        </trans-unit>
        <trans-unit id="1b0c7be81a38400e6eab6ae6602316f1c9727b89" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Tablet; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla/5.0 (平板电脑;Rv:26.0)Gecko/26.0 Firefox/26.0</target>
        </trans-unit>
        <trans-unit id="d5494fe16df11ab5f5d2c945da5478c2861a6327" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT 5.2; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla/5.0 (Windows NT 5.2;rv:10.0.1)Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</target>
        </trans-unit>
        <trans-unit id="c103c7575720327d828e07fcd68a2f214656eb84" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; WOW64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">的Mozilla / 5.0（Windows NT的&lt;em&gt;X&lt;/em&gt;。&lt;em&gt;&amp;yuml;&lt;/em&gt; ; WOW64; RV：10.0）壁虎/ 20100101火狐/ 10.0</target>
        </trans-unit>
        <trans-unit id="e357311b1eddbb286305456c0cae57cb232b5c1f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; Win64; x64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">的Mozilla / 5.0（Windows NT的&lt;em&gt;X&lt;/em&gt;。&lt;em&gt;&amp;yuml;&lt;/em&gt; ; Win64的; 64; RV：10.0）壁虎/ 20100101火狐/ 10.0</target>
        </trans-unit>
        <trans-unit id="325bb5b76845bcf2d6d17880f0df8de3120fa91b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">的Mozilla / 5.0（Windows NT的&lt;em&gt;X&lt;/em&gt;。&lt;em&gt;&amp;yuml;&lt;/em&gt; ; RV：10.0）壁虎/ 20100101火狐/ 10.0</target>
        </trans-unit>
        <trans-unit id="81f3af5f3aa598d0b0fee4970a50aaf001611378" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows Phone 10.0; Android 6.0.1; Xbox; Xbox One) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Mobile Safari/537.36 Edge/16.16299</source>
          <target state="translated">Mozilla/5.0(Windows Phone 10.0;Android 6.0.1;Xbox;Xbox One)AppleWebKit/537.36(KHTML,像Gecko)Chrome/58.0.3029.110 Mobile Safari/537.36 Edge/16.16299。</target>
        </trans-unit>
        <trans-unit id="5530c08605b863c3ac834dac7f9e551adfc1e552" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686 on x86_64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla/5.0 (X11;Linux i686 on x86_64;rv:10.0)Gecko/20100101 Firefox/10.0</target>
        </trans-unit>
        <trans-unit id="b117257c04f02d34e73001cfc8d0da1abaac01f8" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla/5.0 (X11;Linux i686;rv:10.0)Gecko/20100101 Firefox/10.0</target>
        </trans-unit>
        <trans-unit id="fa04af9816f0793fdc1a867eef08c9bba4602d70" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla/5.0 (X11;Linux i686;rv:10.0.1)Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</target>
        </trans-unit>
        <trans-unit id="3d160a2e76c2d144bd854abad33abe579e0d1e79" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla/5.0 (X11;Linux x86_64;rv:10.0)Gecko/20100101 Firefox/10.0</target>
        </trans-unit>
        <trans-unit id="709cd7ecb895ccc0d811c9b3e76ade66b0e1f3aa" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0)</source>
          <target state="translated">Mozilla/5.0(兼容;MSIE 9.0;Windows Phone OS 7.5;Trident/5.0;IEMobile/9.0)</target>
        </trans-unit>
        <trans-unit id="eb659b396a68f6ea514ab25964c9404e2397367b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPad; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0（iPad； CPU iPhone OS 8_3，如Mac OS X）AppleWebKit / 600.1.4（KHTML，如Gecko）&lt;strong&gt;FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="4e72c500d652c15de7cda1433b6379f4dfd1c6c4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0（iPhone； CPU iPhone OS 8_3，如Mac OS X）AppleWebKit / 600.1.4（KHTML，如Gecko）&lt;strong&gt;FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="f8a8856f3bffbe976e558e919bc886558bcab84f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPod touch; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0（iPod touch； CPU iPhone OS 8_3，例如Mac OS X）AppleWebKit / 600.1.4（KHTML，例如Gecko）&lt;strong&gt;FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="6c18301fd3a10882deaa39ee10288f7f929f1e77" translate="yes" xml:space="preserve">
          <source>Multipart ranges</source>
          <target state="translated">多部分范围</target>
        </trans-unit>
        <trans-unit id="6492593dec5dae0d0f4611760da5545108ace9bb" translate="yes" xml:space="preserve">
          <source>Multipart types</source>
          <target state="translated">多部分类型</target>
        </trans-unit>
        <trans-unit id="d39efeff869bd677fa96ec0c45b55ce64ce505cd" translate="yes" xml:space="preserve">
          <source>Multiple content security policies</source>
          <target state="translated">多种内容安全政策</target>
        </trans-unit>
        <trans-unit id="16f27a967676caac72dd673312bcaadcdd0612f0" translate="yes" xml:space="preserve">
          <source>Multiple directives are comma-separated.</source>
          <target state="translated">多条指令以逗号分隔。</target>
        </trans-unit>
        <trans-unit id="faf6894b2c9c5935b46458a0fd870cc102ebf570" translate="yes" xml:space="preserve">
          <source>Multiple entries can be specified in a single &lt;code&gt;Alt-Svc&lt;/code&gt; header using comma as separator. In that case, early entries are considered more preferable.</source>
          <target state="translated">可以在单个 &lt;code&gt;Alt-Svc&lt;/code&gt; 标头中使用逗号作为分隔符来指定多个条目。在这种情况下，更早进入是更可取的。</target>
        </trans-unit>
        <trans-unit id="313424e8960d9a8154e0f8c4d03334fd46afad67" translate="yes" xml:space="preserve">
          <source>Multiple headers</source>
          <target state="translated">多个标题</target>
        </trans-unit>
        <trans-unit id="8df1cc9a00d7049c317f44f9975e955ab77a7480" translate="yes" xml:space="preserve">
          <source>Multiple host/domain values are &lt;em&gt;not&lt;/em&gt; allowed, but if a domain &lt;em&gt;is&lt;/em&gt; specified, then subdomains are always included.</source>
          <target state="translated">多个主机/域值是&lt;em&gt;不是&lt;/em&gt;允许的，但如果一个域名&lt;em&gt;被&lt;/em&gt;指定，那么子域总是被包括在内。</target>
        </trans-unit>
        <trans-unit id="bdca688fc4125e8ff0c8017144fee0ab18afe32f" translate="yes" xml:space="preserve">
          <source>Multiple language tags are separated by comma. Each language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character (&quot;&lt;code&gt;-&lt;/code&gt;&quot;, &lt;code&gt;%x2D&lt;/code&gt;). In most cases, a language tag consists of a primary language subtag that identifies a broad family of related languages (e.g., &quot;&lt;code&gt;en&lt;/code&gt;&quot; = English), which is optionally followed by a series of subtags that refine or narrow that language's range (e.g., &quot;&lt;code&gt;en-CA&lt;/code&gt;&quot; = the variety of English as communicated in Canada).</source>
          <target state="translated">多种语言标签用逗号分隔。每个语言标签都是一个或多个不区分大小写的子标签的序列，每个子标签都用连字符（&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;， &lt;code&gt;%x2D&lt;/code&gt; ）分隔。在大多数情况下，语言标签由主要的语言子标签组成，该子语言标签标识了广泛的相关语言系列（例如&amp;ldquo; &lt;code&gt;en&lt;/code&gt; &amp;rdquo; =英语），然后可以选择后面跟着一系列子标签，这些子标签可以缩小或缩小该语言的范围（例如， &amp;ldquo; &lt;code&gt;en-CA&lt;/code&gt; &amp;rdquo; =加拿大交流的英语种类。</target>
        </trans-unit>
        <trans-unit id="340550b49e9608b118f45b82b60784f8192c8553" translate="yes" xml:space="preserve">
          <source>Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</source>
          <target state="translated">多用途互联网邮件扩展名(MIME)第二部分:媒体类型</target>
        </trans-unit>
        <trans-unit id="b290c69355489b91460f7513bfaca4d5713cfa85" translate="yes" xml:space="preserve">
          <source>Musical Instrument Digital Interface (MIDI)</source>
          <target state="translated">乐器数字接口(MIDI)</target>
        </trans-unit>
        <trans-unit id="38d7a0163e1ee433772d04a8bfb66c70abef1a41" translate="yes" xml:space="preserve">
          <source>Must contain</source>
          <target state="translated">必须包含</target>
        </trans-unit>
        <trans-unit id="7eb2625cecaa68b91f751ad2fe9dc1b532d0b9b2" translate="yes" xml:space="preserve">
          <source>Must not contain</source>
          <target state="translated">不得含有</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="efc3e3a9091331fea65bdf78fb5cc0f8f7a3acf5" translate="yes" xml:space="preserve">
          <source>NEL</source>
          <target state="translated">NEL</target>
        </trans-unit>
        <trans-unit id="7fba45dc69034264a59f6cf73b586c39dab3f873" translate="yes" xml:space="preserve">
          <source>Name/alias of an internal proxy.</source>
          <target state="translated">内部代理的名称/名称。</target>
        </trans-unit>
        <trans-unit id="fc0e8280e5c94d0883853c5c4b17f81c3e799bdf" translate="yes" xml:space="preserve">
          <source>Name:   activelock

   Purpose:   Describes a lock on a resource.


   &amp;lt;!ELEMENT activelock (lockscope, locktype, depth, owner?, timeout?,
             locktoken?, lockroot)&amp;gt;</source>
          <target state="translated">名称：activelock用途：描述对资源的锁定。&amp;lt;！ELEMENT activelock（锁范围，锁类型，深度，所有者，超时，锁令牌，lockroot）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7309308604381e0eab9cfba61516e4469cbce658" translate="yes" xml:space="preserve">
          <source>Name:   allprop

   Purpose:   Specifies that all names and values of dead properties and
      the live properties defined by this document existing on the
      resource are to be returned.

   &amp;lt;!ELEMENT allprop EMPTY &amp;gt;</source>
          <target state="translated">名称：allprop用途：指定将返回该文档在资源上存在的无效属性和活动属性的所有名称和值。&amp;lt;！ELEMENT ALLPRO EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1ba1c5dfdf3f6b036dcf6b3dcedf50ec6b5d7aa0" translate="yes" xml:space="preserve">
          <source>Name:   collection

   Purpose:   Identifies the associated resource as a collection.  The
      DAV:resourcetype property of a collection resource MUST contain
      this element.  It is normally empty but extensions may add sub-
      elements.

   &amp;lt;!ELEMENT collection EMPTY &amp;gt;</source>
          <target state="translated">名称：集合用途：将关联的资源标识为集合。收集资源的DAV：resourcetype属性必须包含此元素。通常为空，但扩展名可能会添加子元素。&amp;lt;！ELEMENT集合为空&amp;gt;</target>
        </trans-unit>
        <trans-unit id="87181b0cf2e6abfd8e3d27cf6a43721cccb1a786" translate="yes" xml:space="preserve">
          <source>Name:   creationdate

   Purpose:   Records the time and date the resource was created.

   Value:   date-time (defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC3339&lt;/a&gt;], see the ABNF in &lt;a href=&quot;#section-5.6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-5.6&quot;&gt;5.6&lt;/a&gt;.)

   Protected:   MAY be protected.  Some servers allow DAV:creationdate
      to be changed to reflect the time the document was created if that
      is more meaningful to the user (rather than the time it was
      uploaded).  Thus, clients SHOULD NOT use this property in
      synchronization logic (use DAV:getetag instead).

   COPY/MOVE behavior:   This property value SHOULD be kept during a
      MOVE operation, but is normally re-initialized when a resource is
      created with a COPY.  It should not be set in a COPY. 

   Description:   The DAV:creationdate property SHOULD be defined on all
      DAV compliant resources.  If present, it contains a timestamp of
      the moment when the resource was created.  Servers that are
      incapable of persistently recording the creation date SHOULD
      instead leave it undefined (i.e. report &quot;Not Found&quot;).

   &amp;lt;!ELEMENT creationdate (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：creationdate用途：记录创建资源的时间和日期。值：日期时间（在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC3339&lt;/a&gt; ]中定义，请参见&lt;a href=&quot;#section-5.6&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-5.6&quot;&gt;5.6 &lt;/a&gt;节中的ABNF。）受保护：可以受到保护。一些服务器允许更改DAV：creationdate以反映文档创建的时间（如果对用户更有意义）（而不是上载的时间）。因此，客户端不应在同步逻辑中使用此属性（请改用DAV：getetag）。 COPY / MOVE行为：此属性值应在MOVE操作期间保留，但通常在使用COPY创建资源时会重新初始化。不应在COPY中设置。描述：应该在所有符合DAV的资源上定义DAV：creationdate属性。如果存在，它包含创建资源时的时间戳。无法永久记录创建日期的服务器应将其保留为未定义（即报告&amp;ldquo;未找到&amp;rdquo;）。 &amp;lt;！ELEMENT creationdate（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5001a824af50b50969330b6c455279fcb16d4902" translate="yes" xml:space="preserve">
          <source>Name:   depth

   Purpose:   Used for representing depth values in XML content (e.g.,
      in lock information).

   Value:   &quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;

   &amp;lt;!ELEMENT depth (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：depth用途：用于表示XML内容（例如，锁信息中）的深度值。值：&amp;ldquo; 0&amp;rdquo; | &amp;ldquo; 1&amp;rdquo; | &amp;ldquo; infinity&amp;rdquo; &amp;lt;！ELEMENT深度（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7e7ea482bed86ee2dc49b17649f3cd7cddfe06a" translate="yes" xml:space="preserve">
          <source>Name:   displayname

   Purpose:   Provides a name for the resource that is suitable for
      presentation to a user.

   Value:   Any text.

   Protected:   SHOULD NOT be protected.  Note that servers implementing
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] might have made this a protected property as this is a
      new requirement.

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   Contains a description of the resource that is
      suitable for presentation to a user.  This property is defined on
      the resource, and hence SHOULD have the same value independent of
      the Request-URI used to retrieve it (thus, computing this property
      based on the Request-URI is deprecated).  While generic clients
      might display the property value to end users, client UI designers
      must understand that the method for identifying resources is still
      the URL.  Changes to DAV:displayname do not issue moves or copies
      to the server, but simply change a piece of meta-data on the
      individual resource.  Two resources can have the same DAV:
      displayname value even within the same collection.

   &amp;lt;!ELEMENT displayname (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：displayname用途：提供适合于呈现给用户的资源名称。值：任何文本。受保护：不应受到保护。请注意，实施[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518的&lt;/a&gt;服务器]可能已将此设置为受保护的属性，因为这是一项新要求。 COPY / MOVE行为：应在COPY和MOVE操作中保留此属性值。描述：包含适合于向用户展示的资源的描述。这个属性是在资源上定义的，因此应该具有与用于获取它的Request-URI无关的相同值（因此，不赞成基于Request-URI计算此属性）。虽然通用客户端可能会向最终用户显示属性值，但客户端UI设计人员必须理解，用于标识资源的方法仍然是URL。对DAV：displayname的更改不会向服务器发出移动或复制，而只是更改单个资源上的一部分元数据。两个资源可以具有相同的DAV：即使在同一集合中，其displayname值也是如此。 &amp;lt;！ELEMENT显示名称（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="908d0146c1dea86489e704e923e0d7a5ee16a7b9" translate="yes" xml:space="preserve">
          <source>Name:   error

   Purpose:   Error responses, particularly 403 Forbidden and 409
      Conflict, sometimes need more information to indicate what went
      wrong.  In these cases, servers MAY return an XML response body
      with a document element of 'error', containing child elements
      identifying particular condition codes.

   Description:   Contains at least one XML element, and MUST NOT
      contain text or mixed content.  Any element that is a child of the
      'error' element is considered to be a precondition or
      postcondition code.  Unrecognized elements MUST be ignored.

   &amp;lt;!ELEMENT error ANY &amp;gt;</source>
          <target state="translated">名称：错误用途：错误响应，尤其是403 Forbidden和409 Conflict，有时需要更多信息来指示出了什么问题。在这些情况下，服务器可以返回一个XML响应主体，其文档元素为&amp;ldquo;错误&amp;rdquo;，其中包含标识特定条件代码的子元素。说明：至少包含一个XML元素，并且不得包含文本或混合内容。作为&amp;ldquo;错误&amp;rdquo;元素的子元素的任何元素均被视为前提条件或后置条件代码。无法识别的元素必须被忽略。&amp;lt;！ELEMENT错误ANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2f1ac95ad14a19297b93321befb3877e2c61a0da" translate="yes" xml:space="preserve">
          <source>Name:   exclusive

   Purpose:   Specifies an exclusive lock.


   &amp;lt;!ELEMENT exclusive EMPTY &amp;gt;</source>
          <target state="translated">名称：排他目的：指定排他锁。&amp;lt;！ELEMENT专用EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1139af3688a412e172379a1792bf370d7f0f7b0c" translate="yes" xml:space="preserve">
          <source>Name:   getcontentlanguage

   Purpose:   Contains the Content-Language header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;14.12 of [RFC2616]&lt;/a&gt;) as it would be returned by a GET without
      accept headers.

   Value:   language-tag (language-tag is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.10&quot;&gt;Section&amp;nbsp;3.10 of
      [RFC2616]&lt;/a&gt;) 

   Protected:   SHOULD NOT be protected, so that clients can reset the
      language.  Note that servers implementing [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] might have
      made this a protected property as this is a new requirement.

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   The DAV:getcontentlanguage property MUST be defined on
      any DAV-compliant resource that returns the Content-Language
      header on a GET.

   &amp;lt;!ELEMENT getcontentlanguage (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：getcontentlanguage用途：包含Content-Language头值（来自&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;[RFC2616]的14.12 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;节&lt;/a&gt;），因为该值将由不具有接受头的GET返回。值：语言标签（语言标签在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.10&quot;&gt;[RFC2616]的3.10节中&lt;/a&gt;定义）受保护：不应受保护，以便客户端可以重置语言。请注意，实施[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518的&lt;/a&gt;服务器]可能已将此设置为受保护的属性，因为这是一项新要求。 COPY / MOVE行为：应在COPY和MOVE操作中保留此属性值。说明：必须在返回DATE的Content-Language标头的任何DAV兼容资源上定义DAV：getcontentlanguage属性。 &amp;lt;！ELEMENT getcontentlanguage（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="741fdc043a5b70d84410dff935be0a476ea27e62" translate="yes" xml:space="preserve">
          <source>Name:   getcontentlength

   Purpose:   Contains the Content-Length header returned by a GET
      without accept headers.

   Value:   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.13&quot;&gt;Section&amp;nbsp;14.13 of [RFC2616]&lt;/a&gt;.

   Protected:   This property is computed, therefore protected.

   Description:   The DAV:getcontentlength property MUST be defined on
      any DAV-compliant resource that returns the Content-Length header
      in response to a GET.

   COPY/MOVE behavior:   This property value is dependent on the size of
      the destination resource, not the value of the property on the
      source resource.

   &amp;lt;!ELEMENT getcontentlength (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：getcontentlength用途：包含由GET返回的Content-Length头，而没有accept头。值：请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.13&quot;&gt;[RFC2616]的14.13节&lt;/a&gt;。受保护的：此属性已计算，因此受保护。描述：必须在任何DAV兼容资源上定义DAV：getcontentlength属性，该资源会响应GET返回Content-Length头。 COPY / MOVE行为：此属性值取决于目标资源的大小，而不取决于源资源上的属性的值。 &amp;lt;！ELEMENT getcontentlength（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="55495eb7b11d239e680b68a767ce90c04bf9b3b4" translate="yes" xml:space="preserve">
          <source>Name:   getcontenttype

   Purpose:   Contains the Content-Type header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.17&quot;&gt;Section&amp;nbsp;14.17
      of [RFC2616]&lt;/a&gt;) as it would be returned by a GET without accept
      headers.

   Value:   media-type (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.7&quot;&gt;Section&amp;nbsp;3.7 of [RFC2616]&lt;/a&gt;)

   Protected:   Potentially protected if the server prefers to assign
      content types on its own (see also discussion in &lt;a href=&quot;#section-9.7.1&quot;&gt;Section 9.7.1&lt;/a&gt;). 

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   This property MUST be defined on any DAV-compliant
      resource that returns the Content-Type header in response to a
      GET.

   &amp;lt;!ELEMENT getcontenttype (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：getcontenttype用途：包含Content-Type头值（来自&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.17&quot;&gt;[RFC2616]的14.17节&lt;/a&gt;），因为它会由没有接受头的GET返回。值：媒体类型（在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.7&quot;&gt;[RFC2616]的3.7节中&lt;/a&gt;定义）受保护：如果服务器更喜欢自行分配内容类型，则可能受到保护（另请参阅&lt;a href=&quot;#section-9.7.1&quot;&gt;第9.7.1节中的&lt;/a&gt;讨论）。 COPY / MOVE行为：应在COPY和MOVE操作中保留此属性值。描述：必须在任何DAV兼容资源上定义此属性，该资源会响应GET返回Content-Type头。 &amp;lt;！ELEMENT getcontenttype（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1498b05efb25d9004f005f650420e0059a4a660f" translate="yes" xml:space="preserve">
          <source>Name:   getetag

   Purpose:   Contains the ETag header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.19&quot;&gt;Section&amp;nbsp;14.19 of
      [RFC2616]&lt;/a&gt;) as it would be returned by a GET without accept
      headers.

   Value:   entity-tag (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;)

   Protected:  MUST be protected because this value is created and
      controlled by the server.

   COPY/MOVE behavior:   This property value is dependent on the final
      state of the destination resource, not the value of the property
      on the source resource.  Also note the considerations in
      &lt;a href=&quot;#section-8.8&quot;&gt;Section 8.8&lt;/a&gt;.

   Description:   The getetag property MUST be defined on any DAV-
      compliant resource that returns the Etag header.  Refer to &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;3.11 of RFC 2616&lt;/a&gt; for a complete definition of the semantics of an
      ETag, and to &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt; for a discussion of ETags in WebDAV.

   &amp;lt;!ELEMENT getetag (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：getetag用途：包含ETag头值（来自&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.19&quot;&gt;[RFC2616]的14.19节&lt;/a&gt;），因为该值将由不具有接受头的GET返回。值：实体标签（在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]的3.11节中&lt;/a&gt;定义）受保护：必须受保护，因为此值是由服务器创建和控制的。 COPY / MOVE行为：此属性值取决于目标资源的最终状态，而不是源资源上的属性值。还要注意&lt;a href=&quot;#section-8.8&quot;&gt;第8.8节中的&lt;/a&gt;注意事项 。描述：必须在任何返回Etag头的DAV兼容资源上定义getetag属性。请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;RFC 2616的3.11 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;节&lt;/a&gt;有关ETag语义的完整定义，请参见&lt;a href=&quot;#section-8.6&quot;&gt;第8.6节&lt;/a&gt;以讨论WebDAV中的ETag。&amp;lt;！ELEMENT getetag（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="11ad3ec496de5f06b2c28a5d5dd7a81ca07caa74" translate="yes" xml:space="preserve">
          <source>Name:   getlastmodified

   Purpose:   Contains the Last-Modified header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;14.29 of [RFC2616]&lt;/a&gt;) as it would be returned by a GET method
      without accept headers.

   Value:   &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC2616]&lt;/a&gt;)

   Protected:   SHOULD be protected because some clients may rely on the
      value for appropriate caching behavior, or on the value of the
      Last-Modified header to which this property is linked. 

   COPY/MOVE behavior:   This property value is dependent on the last
      modified date of the destination resource, not the value of the
      property on the source resource.  Note that some server
      implementations use the file system date modified value for the
      DAV:getlastmodified value, and this can be preserved in a MOVE
      even when the HTTP Last-Modified value SHOULD change.  Note that
      since [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] requires clients to use ETags where provided, a
      server implementing ETags can count on clients using a much better
      mechanism than modification dates for offline synchronization or
      cache control.  Also note the considerations in &lt;a href=&quot;#section-8.8&quot;&gt;Section 8.8&lt;/a&gt;.

   Description:   The last-modified date on a resource SHOULD only
      reflect changes in the body (the GET responses) of the resource.
      A change in a property only SHOULD NOT cause the last-modified
      date to change, because clients MAY rely on the last-modified date
      to know when to overwrite the existing body.  The DAV:
      getlastmodified property MUST be defined on any DAV-compliant
      resource that returns the Last-Modified header in response to a
      GET.

   &amp;lt;!ELEMENT getlastmodified (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：getlastmodified目的：包含Last-Modified头值（来自&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;[RFC2616]的14.29 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;节&lt;/a&gt;），因为该值将由不带有接受头的GET方法返回。值： &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date（在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.3.1&quot;&gt;[RFC2616]的3.3.1节中&lt;/a&gt;定义）受保护：应该受到保护，因为某些客户端可能依赖于该值来实现适当的缓存行为，或者依赖于此属性链接到的Last-Modified头的值。 COPY / MOVE行为：此属性值取决于目标资源的最后修改日期，而不是源资源上的属性值。请注意，某些服务器实现将文件系统日期修改后的值用于DAV：getlastmodified值，即使HTTP Last-Modified值应更改，也可以将其保留在MOVE中。请注意，由于[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]要求客户端在提供的地方使用ETag，实现ETag的服务器可以使用比修改日期更好的机制依靠客户端进行脱机同步或缓存控制。还要注意&lt;a href=&quot;#section-8.8&quot;&gt;第8.8节中的&lt;/a&gt;注意事项。描述：资源上的最后修改日期应仅反映资源主体（GET响应）中的更改。属性的改变仅不应导致最后修改日期发生改变，因为客户可以依靠最后修改日期来知道何时覆盖现有主体。必须在任何DAV兼容资源上定义DAV：getlastmodified属性，该资源会响应GET返回Last-Modified头。 &amp;lt;！ELEMENT getlastmodified（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="863060182a5c2848f88469f61b18814776f39625" translate="yes" xml:space="preserve">
          <source>Name:   href

   Purpose:   MUST contain a URI or a relative reference.

   Description:   There may be limits on the value of 'href' depending
      on the context of its use.  Refer to the specification text where
      'href' is used to see what limitations apply in each case.

   Value:   Simple-ref


   &amp;lt;!ELEMENT href (#PCDATA)&amp;gt;</source>
          <target state="translated">名称：href用途：必须包含URI或相对引用。说明：根据其使用的上下文，&amp;ldquo; href&amp;rdquo;的值可能有限制。请参阅规范文本，其中使用&amp;ldquo; href&amp;rdquo;以查看每种情况下适用的限制。值：Simple-ref &amp;lt;！ELEMENT href（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="893dbb5e6ea2e164b3fe7cab59b462026c86e341" translate="yes" xml:space="preserve">
          <source>Name:   include

   Purpose:   Any child element represents the name of a property to be
      included in the PROPFIND response.  All elements inside an
      'include' XML element MUST define properties related to the
      resource, although possible property names are in no way limited
      to those property names defined in this document or other
      standards.  This element MUST NOT contain text or mixed content.

   &amp;lt;!ELEMENT include ANY &amp;gt;</source>
          <target state="translated">名称：include用途：任何子元素均表示要包含在PROPFIND响应中的属性的名称。&amp;ldquo;包括&amp;rdquo; XML元素内的所有元素都必须定义与资源相关的属性，尽管可能的属性名称绝不限于本文档或其他标准中定义的那些属性名称。该元素不得包含文本或混合内容。&amp;lt;！ELEMENT包括ANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6c0d5c7c18f7351f5e5ec4a0e565194906f570e3" translate="yes" xml:space="preserve">
          <source>Name:   location

   Purpose:   HTTP defines the &quot;Location&quot; header (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-14.30&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;) for use with some status codes (such as 201 and the 300
      series codes).  When these codes are used inside a 'multistatus'
      element, the 'location' element can be used to provide the
      accompanying Location header value. 

   Description:   Contains a single href element with the same value
      that would be used in a Location header.


   &amp;lt;!ELEMENT location (href)&amp;gt;</source>
          <target state="translated">名称：location用途：HTTP定义&amp;ldquo; Location&amp;rdquo;标头（请参阅[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]，&lt;a href=&quot;#section-14.30&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.30&quot;&gt;14.30 &lt;/a&gt;节），以与某些状态代码（例如201和300系列代码）一起使用。在&amp;ldquo; multistatus&amp;rdquo;元素中使用这些代码时，&amp;ldquo; location&amp;rdquo;元素可用于提供随附的Location标头值。描述：包含一个href元素，该元素具有与Location标头中使用的值相同的值。 &amp;lt;！ELEMENT位置（href）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="611ed05ab7ed30cc8633acf614bc5f74d180e99e" translate="yes" xml:space="preserve">
          <source>Name:   lockdiscovery

   Purpose:   Describes the active locks on a resource

   Protected:   MUST be protected.  Clients change the list of locks
      through LOCK and UNLOCK, not through PROPPATCH.

   COPY/MOVE behavior:   The value of this property depends on the lock
      state of the destination, not on the locks of the source resource.
      Recall that locks are not moved in a MOVE operation.

   Description:   Returns a listing of who has a lock, what type of lock
      he has, the timeout type and the time remaining on the timeout,
      and the associated lock token.  Owner information MAY be omitted
      if it is considered sensitive.  If there are no locks, but the
      server supports locks, the property will be present but contain
      zero 'activelock' elements.  If there are one or more locks, an
      'activelock' element appears for each lock on the resource.  This
      property is NOT lockable with respect to write locks (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   &amp;lt;!ELEMENT lockdiscovery (activelock)* &amp;gt;</source>
          <target state="translated">名称：lockdiscovery用途：描述资源上的活动锁受保护：必须受保护。客户通过LOCK和UNLOCK而不是通过PROPPATCH来更改锁的列表。 COPY / MOVE行为：此属性的值取决于目标的锁定状态，而不取决于源资源的锁定。记得在MOVE操作中锁没有移动。描述：返回列出拥有锁的人，其拥有的锁的类型，超时类型和超时时间以及相关的锁令牌。如果所有者信息被认为是敏感的，则可以省略。如果没有锁，但是服务器支持锁，​​则该属性将存在，​​但包含零个&amp;ldquo; activelock&amp;rdquo;元素。如果有一个或多个锁，则&amp;ldquo;对资源上的每个锁都会显示&amp;ldquo; activelock&amp;rdquo;元素。对于写锁，此属性不可锁定（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）。&amp;lt;！ELEMENT锁定发现（activelock）*&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7c16989808c9336197d43ba1941662e1c595ca03" translate="yes" xml:space="preserve">
          <source>Name:   lockentry

   Purpose:   Defines the types of locks that can be used with the
      resource.

   &amp;lt;!ELEMENT lockentry (lockscope, locktype) &amp;gt;</source>
          <target state="translated">名称：lockentry用途：定义可与资源一起使用的锁的类型。&amp;lt;！ELEMENT锁定项（lockscope，locktype）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5083904af81384e6886493a202104354cd3f8853" translate="yes" xml:space="preserve">
          <source>Name:   lockinfo

   Purpose:   The 'lockinfo' XML element is used with a LOCK method to
      specify the type of lock the client wishes to have created.


   &amp;lt;!ELEMENT lockinfo (lockscope, locktype, owner?)  &amp;gt;</source>
          <target state="translated">名称：lockinfo用途：&amp;ldquo; lockinfo&amp;rdquo; XML元素与LOCK方法一起使用，以指定客户端希望创建的锁的类型。&amp;lt;！ELEMENT lockinfo（lockscope，locktype，所有者？）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="852a23c678d8306e5d8708150d7c2bf16c39adbc" translate="yes" xml:space="preserve">
          <source>Name:   lockroot

   Purpose:   Contains the root URL of the lock, which is the URL
      through which the resource was addressed in the LOCK request.

   Description:   The href element contains the root of the lock.  The
      server SHOULD include this in all DAV:lockdiscovery property
      values and the response to LOCK requests.

   &amp;lt;!ELEMENT lockroot (href) &amp;gt;</source>
          <target state="translated">名称：lockroot目的：包含锁的根URL，即LOCK请求中用来寻址资源的URL。说明：href元素包含锁的根。服务器应在所有DAV：lockdiscovery属性值和对LOCK请求的响应中包含此内容。&amp;lt;！ELEMENT lockroot（href）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="00e11eedce57a66ee497b17831a568c69036832c" translate="yes" xml:space="preserve">
          <source>Name:   lockscope

   Purpose:   Specifies whether a lock is an exclusive lock, or a shared
      lock.


     &amp;lt;!ELEMENT lockscope (exclusive | shared) &amp;gt;</source>
          <target state="translated">名称：lockscope用途：指定锁是排他锁还是共享锁。&amp;lt;！ELEMENT锁定范围（专有|共享）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="82de61827789e036e8393a1e1b328cd94701a6ea" translate="yes" xml:space="preserve">
          <source>Name:   locktoken

   Purpose:   The lock token associated with a lock.

   Description:   The href contains a single lock token URI, which
      refers to the lock.

   &amp;lt;!ELEMENT locktoken (href) &amp;gt;</source>
          <target state="translated">名称：locktoken用途：与锁关联的锁令牌。说明：href包含单个锁令牌URI，它引用了锁。&amp;lt;！ELEMENT锁令牌（href）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="598c85ffd24685cdfcbe4799404f4c9aeaa83551" translate="yes" xml:space="preserve">
          <source>Name:   locktype

   Purpose:   Specifies the access type of a lock.  At present, this
      specification only defines one lock type, the write lock.


   &amp;lt;!ELEMENT locktype (write) &amp;gt;</source>
          <target state="translated">名称：locktype用途：指定锁的访问类型。目前，该规范仅定义一种锁类型，即写锁。&amp;lt;！ELEMENT锁定类型（写）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e05fdca8059417af4c532004b86578fb46a8667c" translate="yes" xml:space="preserve">
          <source>Name:   multistatus

   Purpose:   Contains multiple response messages.

   Description:   The 'responsedescription' element at the top level is
      used to provide a general message describing the overarching
      nature of the response.  If this value is available, an
      application may use it instead of presenting the individual
      response descriptions contained within the responses.


   &amp;lt;!ELEMENT multistatus (response*, responsedescription?)  &amp;gt;</source>
          <target state="translated">名称：multistatus用途：包含多个响应消息。描述：顶层的&amp;ldquo; responsedescription&amp;rdquo;元素用于提供描述响应总体性质的一般消息。如果此值可用，则应用程序可以使用它而不是显示响应中包含的各个响应描述。 &amp;lt;！ELEMENT多状态（响应*，响应描述？）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e7255f62e0866a1ff69ffde8c78451b0557e060" translate="yes" xml:space="preserve">
          <source>Name:   owner

   Purpose:   Holds client-supplied information about the creator of a
      lock.

   Description:   Allows a client to provide information sufficient for
      either directly contacting a principal (such as a telephone number
      or Email URI), or for discovering the principal (such as the URL 

      of a homepage) who created a lock.  The value provided MUST be
      treated as a dead property in terms of XML Information Item
      preservation.  The server MUST NOT alter the value unless the
      owner value provided by the client is empty.  For a certain amount
      of interoperability between different client implementations, if
      clients have URI-formatted contact information for the lock
      creator suitable for user display, then clients SHOULD put those
      URIs in 'href' child elements of the 'owner' element.

   Extensibility:   MAY be extended with child elements, mixed content,
      text content or attributes.

   &amp;lt;!ELEMENT owner ANY &amp;gt;</source>
          <target state="translated">名称：owner用途：保留客户端提供的有关锁创建者的信息。描述：允许客户端提供足够的信息来直接联系委托人（例如电话号码或电子邮件URI），或者发现创建锁的委托人（例如主页的URL）。就XML信息项的保存而言，提供的值必须视为无效属性。除非客户端提供的所有者值为空，否则服务器不得更改该值。为了实现不同客户端实现之间的一定程度的互操作性，如果客户端具有适用于用户显示的锁创建者的URI格式的联系信息，则客户端应将这些URI放入&amp;ldquo;所有者元素。可扩展性：可以用子元素，混合内容，文本内容或属性扩展。 &amp;lt;！ELEMENT所有者ANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1a4e49012d04e6acebeb0c6719ce7d291a7d9aa8" translate="yes" xml:space="preserve">
          <source>Name:   prop

   Purpose:   Contains properties related to a resource.

   Description:   A generic container for properties defined on
      resources.  All elements inside a 'prop' XML element MUST define
      properties related to the resource, although possible property
      names are in no way limited to those property names defined in
      this document or other standards.  This element MUST NOT contain
      text or mixed content.

   &amp;lt;!ELEMENT prop ANY &amp;gt;</source>
          <target state="translated">名称：prop目的：包含与资源有关的属性。说明：用于在资源上定义的属性的通用容器。&amp;ldquo; prop&amp;rdquo; XML元素内的所有元素都必须定义与资源相关的属性，尽管可能的属性名称绝不限于本文档或其他标准中定义的那些属性名称。该元素不得包含文本或混合内容。&amp;lt;！ELEMENT prop ANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2a17076c9f6d61a5ed9b6362d78be28ae87fb3ec" translate="yes" xml:space="preserve">
          <source>Name:   propertyupdate

   Purpose:   Contains a request to alter the properties on a resource.

   Description:   This XML element is a container for the information
      required to modify the properties on the resource.

   &amp;lt;!ELEMENT propertyupdate (remove | set)+ &amp;gt;</source>
          <target state="translated">名称：propertyupdate用途：包含更改资源属性的请求。说明：此XML元素是用于修改资源属性的信息的容器。&amp;lt;！ELEMENT属性更新（删除|设置）+&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f033076f90b712249c25c9cf538723f50fb05452" translate="yes" xml:space="preserve">
          <source>Name:   propfind 

   Purpose:   Specifies the properties to be returned from a PROPFIND
      method.  Four special elements are specified for use with
      'propfind': 'prop', 'allprop', 'include', and 'propname'.  If
      'prop' is used inside 'propfind', it MUST NOT contain property
      values.

   &amp;lt;!ELEMENT propfind ( propname | (allprop, include?) | prop ) &amp;gt;</source>
          <target state="translated">名称：propfind用途：指定要从PROPFIND方法返回的属性。为&amp;ldquo; propfind&amp;rdquo;指定了四个特殊元素：&amp;ldquo; prop&amp;rdquo;，&amp;ldquo; allprop&amp;rdquo;，&amp;ldquo; include&amp;rdquo;和&amp;ldquo; propname&amp;rdquo;。如果在'propfind'内使用'prop'，则不得包含属性值。&amp;lt;！ELEMENT propfind（propname |（allprop，include？）| prop）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b132fa457cc7b2c94116ac2aad40a7507857d840" translate="yes" xml:space="preserve">
          <source>Name:   propname

   Purpose:   Specifies that only a list of property names on the
      resource is to be returned.

   &amp;lt;!ELEMENT propname EMPTY &amp;gt;</source>
          <target state="translated">名称：propname用途：指定仅返回资源上属性名称的列表。&amp;lt;！ELEMENT属性名EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb18d77861af3bb5b094ee60954452e584d7dbd8" translate="yes" xml:space="preserve">
          <source>Name:   propstat

   Purpose:   Groups together a prop and status element that is
      associated with a particular 'href' element.

   Description:   The propstat XML element MUST contain one prop XML
      element and one status XML element.  The contents of the prop XML
      element MUST only list the names of properties to which the result
      in the status element applies.  The optional precondition/
      postcondition element and 'responsedescription' text also apply to
      the properties named in 'prop'.

   &amp;lt;!ELEMENT propstat (prop, status, error?, responsedescription?) &amp;gt;</source>
          <target state="translated">名称：propstat用途：将与特定&amp;ldquo; href&amp;rdquo;元素关联的prop和status元素组合在一起。描述：propstat XML元素必须包含一个prop XML元素和一个status XML元素。 prop XML元素的内容务必仅列出status元素中的结果适用的属性名称。可选的precondition / postcondition元素和&amp;ldquo; responsedescription&amp;rdquo;文本也适用于&amp;ldquo; prop&amp;rdquo;中命名的属性。 &amp;lt;！ELEMENT propstat（属性，状态，错误？，响应描述？）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="54b0bd4bd32a031047ae1be302a66b6e6c5b1f5b" translate="yes" xml:space="preserve">
          <source>Name:   remove

   Purpose:   Lists the properties to be removed from a resource.

   Description:   Remove instructs that the properties specified in prop
      should be removed.  Specifying the removal of a property that does
      not exist is not an error.  All the XML elements in a 'prop' XML
      element inside of a 'remove' XML element MUST be empty, as only
      the names of properties to be removed are required.

   &amp;lt;!ELEMENT remove (prop) &amp;gt;</source>
          <target state="translated">名称：remove用途：列出要从资源中删除的属性。说明：删除指示应删除prop中指定的属性。指定删除不存在的属性不是错误。 &amp;ldquo;删除&amp;rdquo; XML元素内的&amp;ldquo;专用&amp;rdquo; XML元素中的所有XML元素必须为空，因为仅需要删除的属性名称是必需的。 &amp;lt;！ELEMENT移除（prop）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bf23482b4d15a7ccf582eb373f0c59dfd927c56a" translate="yes" xml:space="preserve">
          <source>Name:   resourcetype

   Purpose:   Specifies the nature of the resource.

   Protected:   SHOULD be protected.  Resource type is generally decided
      through the operation creating the resource (MKCOL vs PUT), not by
      PROPPATCH.

   COPY/MOVE behavior:   Generally a COPY/MOVE of a resource results in
      the same type of resource at the destination.

   Description:   MUST be defined on all DAV-compliant resources.  Each
      child element identifies a specific type the resource belongs to,
      such as 'collection', which is the only resource type defined by
      this specification (see &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;).  If the element contains
      the 'collection' child element plus additional unrecognized
      elements, it should generally be treated as a collection.  If the
      element contains no recognized child elements, it should be
      treated as a non-collection resource.  The default value is empty.
      This element MUST NOT contain text or mixed content.  Any custom
      child element is considered to be an identifier for a resource
      type.

   Example: (fictional example to show extensibility)

       &amp;lt;x:resourcetype xmlns:x=&quot;DAV:&quot;&amp;gt;
           &amp;lt;x:collection/&amp;gt;
           &amp;lt;f:search-results xmlns:f=&quot;http://www.example.com/ns&quot;/&amp;gt;
       &amp;lt;/x:resourcetype&amp;gt;</source>
          <target state="translated">名称：resourcetype用途：指定资源的性质。受保护：应该受到保护。资源类型通常是通过创建资源的操作（MKCOL与PUT）决定的，而不是由PROPPATCH决定的。 COPY / MOVE行为：通常，资源的COPY / MOVE会在目标位置产生相同类型的资源。说明：必须在所有符合DAV的资源上定义。每个子元素都标识资源所属的特定类型，例如&amp;ldquo;集合&amp;rdquo;，这是此规范定义的唯一资源类型（请参见&lt;a href=&quot;#section-14.3&quot;&gt;第14.3节）&lt;/a&gt;）。如果该元素包含&amp;ldquo;集合&amp;rdquo;子元素以及其他无法识别的元素，则通常应将其视为集合。如果元素不包含公认的子元素，则应将其视为非集合资源。默认值为空。该元素不得包含文本或混合内容。任何自定义子元素都被视为资源类型的标识符。示例：（显示扩展性的虚构示例）&amp;lt;x：resourcetype xmlns：x =&amp;ldquo; DAV：&amp;rdquo;&amp;gt; &amp;lt;x：collection /&amp;gt; &amp;lt;f：search-results xmlns：f =&amp;ldquo; http://www.example.com/ns &amp;ldquo; /&amp;gt; &amp;lt;/ x：resourcetype&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ba963fb29afc5c7063b3f544c4e233040e8f1dab" translate="yes" xml:space="preserve">
          <source>Name:   response

   Purpose:   Holds a single response describing the effect of a method
      on resource and/or its properties.

   Description:   The 'href' element contains an HTTP URL pointing to a
      WebDAV resource when used in the 'response' container.  A
      particular 'href' value MUST NOT appear more than once as the
      child of a 'response' XML element under a 'multistatus' XML
      element.  This requirement is necessary in order to keep
      processing costs for a response to linear time.  Essentially, this
      prevents having to search in order to group together all the
      responses by 'href'.  There are, however, no requirements
      regarding ordering based on 'href' values.  The optional
      precondition/postcondition element and 'responsedescription' text
      can provide additional information about this resource relative to
      the request or result.


   &amp;lt;!ELEMENT response (href, ((href*, status)|(propstat+)),
                       error?, responsedescription? , location?) &amp;gt;</source>
          <target state="translated">名称：响应目的：保留一个描述方法对资源和/或其属性的影响的单个响应。说明：当在&amp;ldquo;响应&amp;rdquo;容器中使用时，&amp;ldquo; href&amp;rdquo;元素包含指向WebDAV资源的HTTP URL。特定的&amp;ldquo; href&amp;rdquo;值不得作为&amp;ldquo; multistatus&amp;rdquo; XML元素下&amp;ldquo; response&amp;rdquo; XML元素的子元素出现多次。为了保持处理成本以响应线性时间，此要求是必需的。本质上，这避免了为了通过&amp;ldquo; href&amp;rdquo;将所有响应分组在一起而进行搜索。但是，对于基于&amp;ldquo; href&amp;rdquo;值的排序没有任何要求。可选的前提条件/后置条件元素和&amp;ldquo;responsedescription'文本可以提供有关此资源相对于请求或结果的其他信息。 &amp;lt;！ELEMENT响应（href，（（（href *，status）|（propstat +）），error ?, responsedescription ?, location？）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e79aa3cfbb4886f68f0cdccf03d0aaa6df292652" translate="yes" xml:space="preserve">
          <source>Name:   responsedescription

   Purpose:   Contains information about a status response within a
      Multi-Status.

   Description:   Provides information suitable to be presented to a
      user.

   &amp;lt;!ELEMENT responsedescription (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：responsedescription用途：包含有关多状态中状态响应的信息。描述：提供适合呈现给用户的信息。 &amp;lt;！ELEMENT响应描述（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="faf150c453c206be333d64c2eb169ece66eddf4f" translate="yes" xml:space="preserve">
          <source>Name:   set

   Purpose:   Lists the property values to be set for a resource.

   Description:   The 'set' element MUST contain only a 'prop' element.
      The elements contained by the 'prop' element inside the 'set'
      element MUST specify the name and value of properties that are set
      on the resource identified by Request-URI.  If a property already
      exists, then its value is replaced.  Language tagging information
      appearing in the scope of the 'prop' element (in the &quot;xml:lang&quot; 

      attribute, if present) MUST be persistently stored along with the
      property, and MUST be subsequently retrievable using PROPFIND.

   &amp;lt;!ELEMENT set (prop) &amp;gt;</source>
          <target state="translated">名称：set用途：列出要为资源设置的属性值。描述：'set'元素必须只包含一个'prop'元素。set元素内的prop元素所包含的元素必须指定在Request-URI标识的资源上设置的属性的名称和值。如果属性已经存在，则其值将被替换。出现在'prop'元素范围内的语言标记信息（在&amp;ldquo; xml：lang&amp;rdquo;属性中，如果存在的话）必须与属性一起永久存储，并且随后必须使用PROPFIND进行检索。&amp;lt;！ELEMENT set（prop）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="034ef0121821410e6799f280fbce98e61bb36fec" translate="yes" xml:space="preserve">
          <source>Name:   shared

   Purpose:   Specifies a shared lock.


   &amp;lt;!ELEMENT shared EMPTY &amp;gt;</source>
          <target state="translated">名称：shared用途：指定共享锁。&amp;lt;！ELEMENT分享了EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="89e2c86f49074c5456840897eea52e652dab08d2" translate="yes" xml:space="preserve">
          <source>Name:   status

   Purpose:   Holds a single HTTP status-line.

   Value:   status-line (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC2616]&lt;/a&gt;)

   &amp;lt;!ELEMENT status (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：status用途：保留单个HTTP状态行。值：状态行（在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-6.1&quot;&gt;[RFC2616]的6.1节中&lt;/a&gt;定义）&amp;lt;！ELEMENT status（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6cd030e3b2b200c8abb49cd69f079bd0720dc672" translate="yes" xml:space="preserve">
          <source>Name:   supportedlock

   Purpose:   To provide a listing of the lock capabilities supported by
      the resource.

   Protected:   MUST be protected.  Servers, not clients, determine what
      lock mechanisms are supported. 

   COPY/MOVE behavior:   This property value is dependent on the kind of
      locks supported at the destination, not on the value of the
      property at the source resource.  Servers attempting to COPY to a
      destination should not attempt to set this property at the
      destination.

   Description:   Returns a listing of the combinations of scope and
      access types that may be specified in a lock request on the
      resource.  Note that the actual contents are themselves controlled
      by access controls, so a server is not required to provide
      information the client is not authorized to see.  This property is
      NOT lockable with respect to write locks (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   &amp;lt;!ELEMENT supportedlock (lockentry)* &amp;gt;</source>
          <target state="translated">名称：supportedlock用途：提供资源支持的锁定功能的列表。受保护：必须受到保护。服务器而不是客户端确定支持哪些锁定机制。 COPY / MOVE行为：此属性值取决于目标上支持的锁的类型，而不取决于源资源上的属性的值。尝试复制到目标的服务器不应尝试在目标上设置此属性。说明：返回可能在资源上的锁定请求中指定的范围和访问类型的组合的列表。请注意，实际内容本身由访问控制控制，因此不需要服务器提供客户端无权查看的信息。对于写锁，此属性不可锁定（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）。&amp;lt;！ELEMENT支持的锁定（锁定）*&amp;gt;</target>
        </trans-unit>
        <trans-unit id="35119527bc63f501789916897c0befe464dc6217" translate="yes" xml:space="preserve">
          <source>Name:   timeout

   Purpose:   The number of seconds remaining before a lock expires.

   Value:   TimeType (defined in &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)


      &amp;lt;!ELEMENT timeout (#PCDATA) &amp;gt;</source>
          <target state="translated">名称：超时目的：锁定到期之前剩余的秒数。值：TimeType（在&lt;a href=&quot;#section-10.7&quot;&gt;10.7节中&lt;/a&gt;定义）&amp;lt;！ELEMENT超时（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89a920056d92541b3e4aaafcac0f2c97ae89ad3" translate="yes" xml:space="preserve">
          <source>Name:   write

   Purpose:   Specifies a write lock.


   &amp;lt;!ELEMENT write EMPTY &amp;gt;</source>
          <target state="translated">名称：write用途：指定写锁定。&amp;lt;！ELEMENT写空&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef928101d810c7b294edc543143c4a9808fc0cd4" translate="yes" xml:space="preserve">
          <source>Navigate to the web site or web app in question and open the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools&quot;&gt;Developer Tools&lt;/a&gt;.</source>
          <target state="translated">导航到有问题的网站或Web应用程序，然后打开&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools&quot;&gt;开发人员工具&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24cfea67414a6051f8ef6f58e4703f34128176fb" translate="yes" xml:space="preserve">
          <source>Navigation directive</source>
          <target state="translated">导航指令</target>
        </trans-unit>
        <trans-unit id="6cb820339644262483e0df69ef7b63b3ff7eb0cf" translate="yes" xml:space="preserve">
          <source>Navigation directives</source>
          <target state="translated">导航指令</target>
        </trans-unit>
        <trans-unit id="3d7680d3ffd85eebd63677687a9aa06b50aefc80" translate="yes" xml:space="preserve">
          <source>Navigation directives govern to which location a user can navigate to or submit a form to, for example.</source>
          <target state="translated">例如,导航指令规定用户可以导航到哪个位置或提交表单。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
