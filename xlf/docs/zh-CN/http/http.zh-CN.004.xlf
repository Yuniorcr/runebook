<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">默认值</target>
        </trans-unit>
        <trans-unit id="a5c2516af3446d0b014a66cd8335c651bab61880" translate="yes" xml:space="preserve">
          <source>Define the lifetime of a cookie</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dead4f5e7150393c68c21004bedb55c7c195d60" translate="yes" xml:space="preserve">
          <source>Define where cookies are sent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245c3e85d7084e6fe802cca877477e7792e1d78f" translate="yes" xml:space="preserve">
          <source>Defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab39d71630263cb06de73047fe986abf13013e75" translate="yes" xml:space="preserve">
          <source>Defines &lt;code&gt;connect-src&lt;/code&gt;, &lt;code&gt;default-src&lt;/code&gt;, &lt;code&gt;font-src&lt;/code&gt;, &lt;code&gt;frame-src&lt;/code&gt;, &lt;code&gt;img-src&lt;/code&gt;, &lt;code&gt;media-src&lt;/code&gt;, &lt;code&gt;object-src&lt;/code&gt;, report-uri, &lt;code&gt;sandbox&lt;/code&gt;, &lt;code&gt;script-src,&lt;/code&gt; and &lt;code&gt;style-src&lt;/code&gt;.</source>
          <target state="translated">定义 &lt;code&gt;connect-src&lt;/code&gt; ， &lt;code&gt;default-src&lt;/code&gt; ， &lt;code&gt;font-src&lt;/code&gt; ， &lt;code&gt;frame-src&lt;/code&gt; ， &lt;code&gt;img-src&lt;/code&gt; ， &lt;code&gt;media-src&lt;/code&gt; ， &lt;code&gt;object-src&lt;/code&gt; ，report-uri， &lt;code&gt;sandbox&lt;/code&gt; ， &lt;code&gt;script-src,&lt;/code&gt; 和 &lt;code&gt;style-src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40978ed9d38521abaff2d2262f9c89c7cd595480" translate="yes" xml:space="preserve">
          <source>Defines a mechanism that enables developers to declare a network error reporting policy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacb52986e3e740e8c70b75c3e7482999a612bff" translate="yes" xml:space="preserve">
          <source>Defines the &lt;code&gt;fullscreen&lt;/code&gt; policy.</source>
          <target state="translated">定义 &lt;code&gt;fullscreen&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="d951108d1c6ab12879dc6ad6f06e33639209ba4b" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to access a resource behind a proxy server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ebc06a403db3f222282cbfb2aa8be80e23aefc" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to access a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b169a4830ca101a24b3e67607bce56b1c91720" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource behind a Proxy server.</source>
          <target state="translated">定义用于访问Proxy服务器后的资源的验证方法。</target>
        </trans-unit>
        <trans-unit id="6543a340c8cdd818ac73a63a94d4fd7de57aba8d" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">定义访问资源时应使用的认证方法。</target>
        </trans-unit>
        <trans-unit id="7826d05e84456b5b15119edee382be8851b9547e" translate="yes" xml:space="preserve">
          <source>Defines the range unit the server supports. Though &lt;code&gt;bytes&lt;/code&gt; is the only range unit formally defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, additional range units may be registered in the&lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#range-units&quot;&gt; HTTP Range Unit Registry&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8dcc75b63979f2db11f899a91470adab4ff1cb6" translate="yes" xml:space="preserve">
          <source>Defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素加载的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Worker&lt;/a&gt;和嵌套浏览上下文定义有效源。</target>
        </trans-unit>
        <trans-unit id="b64b866be84f841a370d95030a45025c6a3e04e9" translate="yes" xml:space="preserve">
          <source>Denial-of-service attacks are of special concern to WebDAV servers.
   WebDAV plus HTTP enables denial-of-service attacks on every part of a
   system's resources.

   o  The underlying storage can be attacked by PUTting extremely large
      files.

   o  Asking for recursive operations on large collections can attack
      processing time.

   o  Making multiple pipelined requests on multiple connections can
      attack network connections.

   WebDAV servers need to be aware of the possibility of a denial-of-
   service attack at all levels.  The proper response to such an attack
   MAY be to simply drop the connection.  Or, if the server is able to
   make a response, the server MAY use a 400-level status request such
   as 400 (Bad Request) and indicate why the request was refused (a 500-
   level status response would indicate that the problem is with the
   server, whereas unintentional DoS attacks are something the client is
   capable of remedying).</source>
          <target state="translated">拒绝服务攻击是WebDAV服务器特别关注的问题。WebDAV加HTTP可以对系统资源的每一个部分进行拒绝服务攻击。 o对底层存储进行PUT,可以攻击超大文件;o对大集合进行请求递归操作,可以攻击处理时间;o对多个连接进行多个流水线请求,可以攻击网络连接。WebDAV服务器需要意识到各级拒绝服务攻击的可能性。对这种攻击的正确响应可能是简单地放弃连接。或者,如果服务器能够做出响应,服务器可以使用400级别的状态请求,如400(Bad Request),并说明请求被拒绝的原因(500级别的状态响应将表明问题出在服务器上,而无意的DoS攻击则是客户端有能力补救的)。</target>
        </trans-unit>
        <trans-unit id="89de95bda785091ad4670c2c51c5dd042349d3eb" translate="yes" xml:space="preserve">
          <source>Deprecate modification of 'secure' cookies from non-secure origins</source>
          <target state="translated">废弃对非安全来源的 &quot;安全 &quot;cookies的修改。</target>
        </trans-unit>
        <trans-unit id="efb41926689d64456523d9abd88a8e204ff7906a" translate="yes" xml:space="preserve">
          <source>Deprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">弃用 &lt;code&gt;frame-src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4f0c7b98ab40a4d967b59248a69752d5ae464d4" translate="yes" xml:space="preserve">
          <source>Depth = &quot;Depth&quot; &quot;:&quot; (&quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;)

   The Depth request header is used with methods executed on resources
   that could potentially have internal members to indicate whether the
   method is to be applied only to the resource (&quot;Depth: 0&quot;), to the
   resource and its internal members only (&quot;Depth: 1&quot;), or the resource
   and all its members (&quot;Depth: infinity&quot;).

   The Depth header is only supported if a method's definition
   explicitly provides for such support.

   The following rules are the default behavior for any method that
   supports the Depth header.  A method may override these defaults by
   defining different behavior in its definition. 

   Methods that support the Depth header may choose not to support all
   of the header's values and may define, on a case-by-case basis, the
   behavior of the method if a Depth header is not present.  For
   example, the MOVE method only supports &quot;Depth: infinity&quot;, and if a
   Depth header is not present, it will act as if a &quot;Depth: infinity&quot;
   header had been applied.

   Clients MUST NOT rely upon methods executing on members of their
   hierarchies in any particular order or on the execution being atomic
   unless the particular method explicitly provides such guarantees.

   Upon execution, a method with a Depth header will perform as much of
   its assigned task as possible and then return a response specifying
   what it was able to accomplish and what it failed to do.

   So, for example, an attempt to COPY a hierarchy may result in some of
   the members being copied and some not.

   By default, the Depth header does not interact with other headers.
   That is, each header on a request with a Depth header MUST be applied
   only to the Request-URI if it applies to any resource, unless
   specific Depth behavior is defined for that header.

   If a source or destination resource within the scope of the Depth
   header is locked in such a way as to prevent the successful execution
   of the method, then the lock token for that resource MUST be
   submitted with the request in the If request header.

   The Depth header only specifies the behavior of the method with
   regards to internal members.  If a resource does not have internal
   members, then the Depth header MUST be ignored.</source>
          <target state="translated">Depth=&quot;Depth&quot; &quot;:&quot; (&quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;)Depth 请求头用于在可能有内部成员的资源上执行的方法,以指示该方法是否只应用于资源(&quot;Depth:0&quot;),是否只应用于资源及其内部成员(&quot;Depth:1&quot;),还是应用于资源及其所有成员(&quot;Depth:infinity&quot;)。只有当一个方法的定义明确规定支持Depth头时,才会支持Depth头。以下规则是任何支持深度头的方法的默认行为。一个方法可以通过在其定义中定义不同的行为来覆盖这些默认行为。支持深度头的方法可以选择不支持头的所有值,并且可以根据具体情况定义方法在深度头不存在时的行为。例如,MOVE方法只支持 &quot;Depth:infinity&quot;,如果Depth头不存在,它将像应用了 &quot;Depth:infinity &quot;头一样行事。客户端绝不能依赖方法以任何特定的顺序在其层次结构的成员上执行,也不能依赖方法的执行是原子的,除非特定的方法明确提供了这样的保证。在执行时,带有深度头的方法将尽可能多地执行其分配的任务,然后返回一个响应,指定它能够完成的任务和未能完成的任务。因此,举例来说,试图复制一个层次结构可能会导致一些成员被复制,而一些没有被复制。默认情况下,深度头不会与其他头交互。也就是说,请求中带有深度头的每个头必须只应用于Request-URI,如果它应用于任何资源,除非为该头定义了特定的深度行为。如果Depth头的范围内的源或目标资源被锁定,从而阻止了方法的成功执行,那么该资源的锁定令牌必须与If请求头中的请求一起提交。深度标头只指定方法对内部成员的行为。如果一个资源没有内部成员,那么深度头必须被忽略。</target>
        </trans-unit>
        <trans-unit id="c3f35f2651dfb57ad3dbd2465104d1927bb97b16" translate="yes" xml:space="preserve">
          <source>Describes how Web resources are referenced and how to locate them.</source>
          <target state="translated">说明如何引用网络资源以及如何找到它们。</target>
        </trans-unit>
        <trans-unit id="13eefb880344c770ed016914712964de5ecee92a" translate="yes" xml:space="preserve">
          <source>Describes how web resources are referenced and how to locate them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932bd93206e0c74c22f35c1fa3ed7a4be6439b83" translate="yes" xml:space="preserve">
          <source>Describes the human language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c9f2b9944695efcc3168d72ca8c97f9659ed15" translate="yes" xml:space="preserve">
          <source>Describes the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">描述面向受众的语言,使用户能够根据自己的偏好语言进行区分。</target>
        </trans-unit>
        <trans-unit id="d5ca427b8a632e16915ddd1ca200bfe11ba09ba7" translate="yes" xml:space="preserve">
          <source>Describes the three connection management models available in HTTP/1.x, their strengths, and their weaknesses.</source>
          <target state="translated">描述了HTTP/1.x中可用的三种连接管理模式,它们的优点和缺点。</target>
        </trans-unit>
        <trans-unit id="a9a26ce3467081341f2f33fd2f385b9b4b5a76b7" translate="yes" xml:space="preserve">
          <source>Describes the type and structure of the different kind of messages of HTTP/1.x and HTTP/2.</source>
          <target state="translated">描述HTTP/1.x和HTTP/2的不同类型的消息的类型和结构。</target>
        </trans-unit>
        <trans-unit id="045b1f4c38aa570756046a04e9ca60247fc160b5" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in the Web architecture, its position in the protocol stack.</source>
          <target state="translated">描述了什么是HTTP,它在Web架构中的作用,它在协议栈中的地位。</target>
        </trans-unit>
        <trans-unit id="724e541fe26287b5d45feca3f617b30de64a8464" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in web architecture, including its position in the protocol stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="6011dbf6cfab599fb1f5bc7fc964691bbd1b3180" translate="yes" xml:space="preserve">
          <source>Designed in the early 1990s, HTTP is an extensible protocol which has evolved over time. It is an application layer protocol that is sent over &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt;, or over a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;-encrypted TCP connection, though any reliable transport protocol could theoretically be used. Due to its extensibility, it is used to not only fetch hypertext documents, but also images and videos or to post content to servers, like with HTML form results. HTTP can also be used to fetch parts of documents to update Web pages on demand.</source>
          <target state="translated">HTTP是在1990年代初设计的，是随时间发展的可扩展协议。它是通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;加密的TCP连接发送的应用程序层协议，尽管理论上可以使用任何可靠的传输协议。由于其可扩展性，它不仅可用于获取超文本文档，而且还可用于获取图像和视频，或将内容发布到服务器（如HTML表单结果）。HTTP还可以用于获取部分文档以按需更新Web页面。</target>
        </trans-unit>
        <trans-unit id="532c67fe1b5afae15d2d08fba7a78de0f63cc4b5" translate="yes" xml:space="preserve">
          <source>Desktop</source>
          <target state="translated">Desktop</target>
        </trans-unit>
        <trans-unit id="dfd0263c11d50bfbcd6f11a03ba9f3544f34bf13" translate="yes" xml:space="preserve">
          <source>Despite &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; being &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;registered with IANA&lt;/a&gt;, it is largely unsupported, and &lt;code&gt;image/x-icon&lt;/code&gt; is being used instead.</source>
          <target state="translated">尽管 &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; 正在&lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;与IANA注册&lt;/a&gt;，它在很大程度上是不支持的，以及 &lt;code&gt;image/x-icon&lt;/code&gt; 被代替使用。</target>
        </trans-unit>
        <trans-unit id="2c9a54d2465a44e3b40b84b59d11de3a6c0cadc8" translate="yes" xml:space="preserve">
          <source>Determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">决定如何匹配未来的请求头,以决定是否可以使用缓存的响应,而不是从源服务器请求一个新的响应。</target>
        </trans-unit>
        <trans-unit id="6d8108385e143b7a138219a9ade7a2c3c2bf95f5" translate="yes" xml:space="preserve">
          <source>Determines how to match request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e965db93ca2d2ed880afa222771550e11edd88c" translate="yes" xml:space="preserve">
          <source>Device-specific</source>
          <target state="translated">Device-specific</target>
        </trans-unit>
        <trans-unit id="504f16935ab18165c15c8ac0d71a7134e267a656" translate="yes" xml:space="preserve">
          <source>Device-specific user agent strings</source>
          <target state="translated">特定设备的用户代理字符串</target>
        </trans-unit>
        <trans-unit id="ceb4688658b58abe9c95bf427c98e66f4be1e7a3" translate="yes" xml:space="preserve">
          <source>Different kinds of caches</source>
          <target state="translated">不同种类的缓存</target>
        </trans-unit>
        <trans-unit id="1ca0ed6389159c54076291dfd79987d9f92fb6b6" translate="yes" xml:space="preserve">
          <source>Directive type</source>
          <target state="translated">指令类型</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="691c26c4ce33366b87dae4f9e53ebeaaa6a4d716" translate="yes" xml:space="preserve">
          <source>Directives for caching mechanisms in both requests and responses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32a74ca0f336eef375d6cd3af907aa1d40f0be6" translate="yes" xml:space="preserve">
          <source>Directives that define whether a response/request can be cached, where it may be cached, and whether it must be validated with the origin server before caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f4473df8cb59f0a369aebee3d1509adc0151c6" translate="yes" xml:space="preserve">
          <source>Disabled</source>
          <target state="translated">Disabled</target>
        </trans-unit>
        <trans-unit id="787d14cbc3437c5c1be6e012c1af87a9cce09ce1" translate="yes" xml:space="preserve">
          <source>Disabled From version 35 until version 37 (exclusive): this feature is behind the &lt;code&gt;network.http.altsvc.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;) and the &lt;code&gt;altsvc.oe&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f484ad36a1ee3a334bfeaabcdd32d70515f88ee" translate="yes" xml:space="preserve">
          <source>Disabled From version 47: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b112b210a8f4589c98ad826e6212c056804fde" translate="yes" xml:space="preserve">
          <source>Disabled From version 48: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89947c297946cdea762cd2db19147fd97a643839" translate="yes" xml:space="preserve">
          <source>Disabled From version 49 until version 68 (exclusive): this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23e78cd51ef4c7696b73e65f06fc0fba687013d" translate="yes" xml:space="preserve">
          <source>Disabled From version 49: this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">从49版禁用：此功能位于 &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;true&lt;/code&gt; ）的后面。要在Firefox中更改首选项，请访问about：config。</target>
        </trans-unit>
        <trans-unit id="acf361a5483e12203a0c0598d3d3f3664a139585" translate="yes" xml:space="preserve">
          <source>Disabled From version 50: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7790dccb9f3d88c21e6418f32f87789fb463366" translate="yes" xml:space="preserve">
          <source>Disabled From version 52: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">已禁用从版本52开始：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。</target>
        </trans-unit>
        <trans-unit id="ad350d06e4ae5e37d57c0405b7c8e1fbfca3f705" translate="yes" xml:space="preserve">
          <source>Disabled From version 53: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">已禁用从版本53开始：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。</target>
        </trans-unit>
        <trans-unit id="01d0cf4c918a77e56e449b4d149616907d38849e" translate="yes" xml:space="preserve">
          <source>Disabled From version 55: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">已禁用从55版开始：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。</target>
        </trans-unit>
        <trans-unit id="02423b2163f75291aa5854698bba6b1f6a5052f1" translate="yes" xml:space="preserve">
          <source>Disabled From version 56: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">已禁用从版本56开始：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。</target>
        </trans-unit>
        <trans-unit id="4b34d34dcaec154df6181d68e5bec4643debe21c" translate="yes" xml:space="preserve">
          <source>Disabled From version 59: this feature is behind the &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">已禁用从版本59开始：此功能位于 &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; 后面。http.sendOriginHeader首选项（需要设置为 &lt;code&gt;true&lt;/code&gt; ）。要在Firefox中更改首选项，请访问about：config。</target>
        </trans-unit>
        <trans-unit id="40734bba86a26fa4c0ddd48daccbe4d758349227" translate="yes" xml:space="preserve">
          <source>Disabled From version 60: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73719b598079cc354ff255d41acbbe0b420ae879" translate="yes" xml:space="preserve">
          <source>Disabled From version 62: this feature is behind the &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">从62版禁用：此功能位于 &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;true&lt;/code&gt; ）的后面。要在Firefox中更改首选项，请访问about：config。</target>
        </trans-unit>
        <trans-unit id="7847ec1580ce5ad83ab59a78912ccb3ab21e102b" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">从65版开始已禁用：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。</target>
        </trans-unit>
        <trans-unit id="5a54bae2672ba58fd0d7d8cd35ca056cf1ce8f92" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">从65版开始已禁用：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。要在Chrome中更改偏好设置，请访问chrome：// flags。</target>
        </trans-unit>
        <trans-unit id="6aac50e494a4685cfa01b409c7700b3851e9f9e7" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726ec65869fe460716d9db41541949cae8c24c4e" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">从66版开始已禁用：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。</target>
        </trans-unit>
        <trans-unit id="aebc6632a71f5502b11ed22ad8c5755ec1c88bfe" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">从66版开始已禁用：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。要在Chrome中更改偏好设置，请访问chrome：// flags。</target>
        </trans-unit>
        <trans-unit id="366e50a33639dd16e2b224c5a3ee5b82578e4e0e" translate="yes" xml:space="preserve">
          <source>Disabled From version 67: this feature is behind the &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56705b66ed39339d0a4b894306b2ecabb3efd7c6" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">从68版禁用：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。</target>
        </trans-unit>
        <trans-unit id="2dcbb985ceab20f02611932df74cc051d6062ad2" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">从68版禁用：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。要在Chrome中更改偏好设置，请访问chrome：// flags。</target>
        </trans-unit>
        <trans-unit id="d28e2d242fc0c32d88a4828425be70d8d4e9386c" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">已禁用从69版开始：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。</target>
        </trans-unit>
        <trans-unit id="dc43adf822f8071bf38b741b4c8b4ff8caa87dd2" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">已禁用从69版开始：此功能位于 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 首选项（需要设置为 &lt;code&gt;Enabled&lt;/code&gt; ）的后面。要在Chrome中更改偏好设置，请访问chrome：// flags。</target>
        </trans-unit>
        <trans-unit id="e63694ea8ef64e459c00d7c0d93772ca98cd8c0d" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;network.cookie.sameSite.laxByDefault&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6c448fbfef096f82b450df55d6a46e80c7144a" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;network.cookie.sameSite.noneRequiresSecure&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2696e5d2f6597ff6db717b5917fe7ef78b21f49" translate="yes" xml:space="preserve">
          <source>Disabled From version 72: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932bbade750d61ada15f0c29ceb15ac8767a08c2" translate="yes" xml:space="preserve">
          <source>Disabled From version 72: this feature is behind the &lt;code&gt;security.cert_pinning.hpkp.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78775da32cd4aa8691fe3765af5c89229860835" translate="yes" xml:space="preserve">
          <source>Disabled From version 73 until version 76 (exclusive): this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49a2f2138558d7e247fc15cdf0f8f8e80da02a9" translate="yes" xml:space="preserve">
          <source>Disabled From version 79: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbf731d4f27dd707439b02e0fcf767655467961" translate="yes" xml:space="preserve">
          <source>Disables DNS prefetching. This is useful if you don't control the link on the pages, or know that you don't want to leak information to these domains.</source>
          <target state="translated">禁用DNS预取。如果你不控制页面上的链接,或者你知道你不想把信息泄露给这些域,这很有用。</target>
        </trans-unit>
        <trans-unit id="58f5f4ebc16939ddad056d1835f255075e38be52" translate="yes" xml:space="preserve">
          <source>Disables MIME sniffing and forces browser to use the type given in &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">禁用MIME嗅探，并强制浏览器使用&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 中&lt;/a&gt;给定的类型。</target>
        </trans-unit>
        <trans-unit id="4c27076a7d462b5b7f6f1b44922f1242a3e46ba5" translate="yes" xml:space="preserve">
          <source>Disables XSS filtering.</source>
          <target state="translated">禁用XSS过滤。</target>
        </trans-unit>
        <trans-unit id="57822983bbd8b7a6c9f3de16f7fe5eab989d06a5" translate="yes" xml:space="preserve">
          <source>Disabling a feature in a policy is a one-way toggle. If a feature has been disabled for a child frame by its parent frame, the child cannot re-enable it, and neither can any of the child's descendants.</source>
          <target state="translated">在策略中禁用一个功能是一个单向的切换。如果父帧禁用了子帧的功能,子帧就不能重新启用,子帧的任何子代也不能重新启用。</target>
        </trans-unit>
        <trans-unit id="b95dd3eb6900d93a418238bf7a5a3a1a746e7c86" translate="yes" xml:space="preserve">
          <source>Disallowing plugins</source>
          <target state="translated">不允许使用插件</target>
        </trans-unit>
        <trans-unit id="93902c2eda1c4f4fa6e24f3a214f7642478627b6" translate="yes" xml:space="preserve">
          <source>Disconnected Operation</source>
          <target state="translated">断线操作</target>
        </trans-unit>
        <trans-unit id="c5bdaaa9046da0ea03b3b9660b87425b983b09dd" translate="yes" xml:space="preserve">
          <source>Discrete types</source>
          <target state="translated">离散型</target>
        </trans-unit>
        <trans-unit id="d69e4d6aad6c625810f7014dfc3dfbd01898d5b3" translate="yes" xml:space="preserve">
          <source>Discussion of HTTP headers</source>
          <target state="translated">关于HTTP头文件的讨论</target>
        </trans-unit>
        <trans-unit id="e7414bd7b2a8ae1b4152a32e27208f6ea5703ede" translate="yes" xml:space="preserve">
          <source>Display security and privacy policies In Firefox Developer Tools</source>
          <target state="translated">显示安全和隐私政策 在Firefox开发者工具中</target>
        </trans-unit>
        <trans-unit id="d78de940f6bf90261043cb8bd08624772df60547" translate="yes" xml:space="preserve">
          <source>Disregarding DNT. The origin server is unable or unwilling to respect a tracking preference received from the requesting user agent.</source>
          <target state="translated">无视DNT。源服务器不能或不愿尊重从请求用户代理处收到的跟踪偏好。</target>
        </trans-unit>
        <trans-unit id="4a1de6fc43e38e089c17a80c82ba419f8f473962" translate="yes" xml:space="preserve">
          <source>Do &lt;strong&gt;not&lt;/strong&gt; use this meta element like this for stating a document language:</source>
          <target state="translated">千万&lt;strong&gt;不能&lt;/strong&gt;使用这样这个荟萃元素说明文档语言：</target>
        </trans-unit>
        <trans-unit id="2c25376cd1e5d495d8c85d1b29c113dcd4496160" translate="yes" xml:space="preserve">
          <source>Do Not Track</source>
          <target state="translated">不要跟踪</target>
        </trans-unit>
        <trans-unit id="70f963907a2dc441e4078146477cb1ac975253ce" translate="yes" xml:space="preserve">
          <source>Do Not Track on Wikipedia</source>
          <target state="translated">不要在维基百科上追踪</target>
        </trans-unit>
        <trans-unit id="5de6d660ffd0c31bb077df9301609dfb8cf69667" translate="yes" xml:space="preserve">
          <source>Do you want to provide different HTML depending on which browser is being used?</source>
          <target state="translated">您是否想根据使用的浏览器提供不同的HTML?</target>
        </trans-unit>
        <trans-unit id="96d09f4b8e17c5718c2731ce7ab9928e287257a4" translate="yes" xml:space="preserve">
          <source>Do-Not-Track</source>
          <target state="translated">Do-Not-Track</target>
        </trans-unit>
        <trans-unit id="e214b8a29923056887b7edf6635d90dcbb2abe88" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="translated">Document</target>
        </trans-unit>
        <trans-unit id="54500ed3527305b0f92d5cf278622f552f491a43" translate="yes" xml:space="preserve">
          <source>Document directive</source>
          <target state="translated">指令性文件</target>
        </trans-unit>
        <trans-unit id="f2213ce4b36d0f4e6e226bd21f16b5d5bf80dcba" translate="yes" xml:space="preserve">
          <source>Document directives</source>
          <target state="translated">准则文件</target>
        </trans-unit>
        <trans-unit id="ec6b0754c2e6157428f7e2691227c09de666ec35" translate="yes" xml:space="preserve">
          <source>Document directives govern the properties of a document or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;worker&lt;/a&gt; environment to which a policy applies.</source>
          <target state="translated">文档指令控制策略所适用的文档或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;工作人员&lt;/a&gt;环境的属性。</target>
        </trans-unit>
        <trans-unit id="48b3bb8b0a579c9e6fbd40516291d94dca86d1ba" translate="yes" xml:space="preserve">
          <source>Does not work below Windows 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6dfa8179f4637130555f525186dd9377736169" translate="yes" xml:space="preserve">
          <source>Does not work on Windows 7 and Windows 8.1.</source>
          <target state="translated">在Windows 7和Windows 8.1上无法使用。</target>
        </trans-unit>
        <trans-unit id="ea664539e7e07c3b3cb2d4e3bb71cc99d18e5b5b" translate="yes" xml:space="preserve">
          <source>Domain aliasing</source>
          <target state="translated">域名别名</target>
        </trans-unit>
        <trans-unit id="3b549bffd9a85f8fa78b065a75e77e845bc42471" translate="yes" xml:space="preserve">
          <source>Domain aliasing can be done for several reasons:</source>
          <target state="translated">域名别名有几种原因。</target>
        </trans-unit>
        <trans-unit id="66a72f8713e4b8fdfa4a8582d2a117d6b82dbadd" translate="yes" xml:space="preserve">
          <source>Domain attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690d7332b26bc38eab02d6b1abf316a940401914" translate="yes" xml:space="preserve">
          <source>Domain sharding</source>
          <target state="translated">域名屏蔽</target>
        </trans-unit>
        <trans-unit id="3c61580d55d642952fbec533e8d3f2630a7d8e94" translate="yes" xml:space="preserve">
          <source>Domain=&amp;lt;domain-value&amp;gt; Optional</source>
          <target state="translated">Domain = &amp;lt;域值&amp;gt;可选</target>
        </trans-unit>
        <trans-unit id="dc4653bff510cf1118951874eb552343ce4eeea4" translate="yes" xml:space="preserve">
          <source>Download resumption in Internet Explorer</source>
          <target state="translated">在Internet Explorer中下载恢复</target>
        </trans-unit>
        <trans-unit id="a862c2b21b5e1337de2b76d5e43ae1375117d34d" translate="yes" xml:space="preserve">
          <source>Downloads</source>
          <target state="translated">Downloads</target>
        </trans-unit>
        <trans-unit id="23d33e22acfcb9ecddb4a85f10607dc4ff49e23c" translate="yes" xml:space="preserve">
          <source>Draft</source>
          <target state="translated">Draft</target>
        </trans-unit>
        <trans-unit id="13ae8e0a7cb29b1ff62023de94998bfc639787c9" translate="yes" xml:space="preserve">
          <source>Draft document</source>
          <target state="translated">文件草案</target>
        </trans-unit>
        <trans-unit id="ddc6d4101d699284c4ee49346220f3fb8a444994" translate="yes" xml:space="preserve">
          <source>Draft spec</source>
          <target state="translated">规格草案</target>
        </trans-unit>
        <trans-unit id="8a8aba5130fcc62311d7ddc3b7380514a11ed8fe" translate="yes" xml:space="preserve">
          <source>Due to the &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;configuration-based entropy&lt;/a&gt; increase, a modified value can be used to fingerprint the user, it is not recommended to change it and a Web site cannot trust this value to reflect the actual wish of the user. Site designers must not be over-zealous by using language detection via this header as it can lead to a poor user experience:</source>
          <target state="translated">由于&lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;基于配置的熵&lt;/a&gt;增加，因此可以使用修改后的值来对用户进行指纹识别，不建议对其进行更改，并且网站无法信任该值以反映用户的实际意愿。站点设计人员一定不要对通过此标头使用语言进行检测过分热心，因为这会导致不良的用户体验：</target>
        </trans-unit>
        <trans-unit id="408eba332fcca84c3bed5ec905d05209bce63d2e" translate="yes" xml:space="preserve">
          <source>Due to their emphasis on authoring, WebDAV servers need to use
   authentication technology to protect not just access to a network
   resource, but the integrity of the resource as well.  Furthermore,
   the introduction of locking functionality requires support for
   authentication.

   A password sent in the clear over an insecure channel is an
   inadequate means for protecting the accessibility and integrity of a
   resource as the password may be intercepted.  Since Basic
   authentication for HTTP/1.1 performs essentially clear text
   transmission of a password, Basic authentication MUST NOT be used to
   authenticate a WebDAV client to a server unless the connection is
   secure.  Furthermore, a WebDAV server MUST NOT send a Basic
   authentication challenge in a WWW-Authenticate header unless the
   connection is secure.  An example of a secure connection would be a
   Transport Layer Security (TLS) connection employing a strong cipher
   suite and server authentication. 

   WebDAV applications MUST support the Digest authentication scheme
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].  Since Digest authentication verifies that both parties to
   a communication know a shared secret, a password, without having to
   send that secret in the clear, Digest authentication avoids the
   security problems inherent in Basic authentication while providing a
   level of authentication that is useful in a wide range of scenarios.</source>
          <target state="translated">由于WebDAV服务器着重于创作，因此需要使用身份验证技术来保护其访问网络资源和完整性的能力。此外，锁定功能的引入要求支持身份验证。通过不安全的通道以明文形式发送的密码是一种不足的方法，无法保护资源的可访问性和完整性，因为密码可能会被截获。由于HTTP / 1.1的基本身份验证本质上执行密码的明文传输，因此，除非连接安全，否则基本身份验证不得用于向服务器验证WebDAV客户端。此外，除非连接是安全的，否则WebDAV服务器不得在WWW-Authenticate标头中发送基本身份验证质询。安全连接的一个示例是采用强密码套件和服务器身份验证的传输层安全性（TLS）连接。 WebDAV应用程序必须支持摘要式身份验证方案[&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]。由于摘要式身份验证可以验证通信的双方都知道共享的机密，密码，而无需明文发送该秘密，因此摘要式身份验证避免了基本身份验证固有的安全性问题，同时提供了在广泛范围内有用的身份验证级别场景范围。</target>
        </trans-unit>
        <trans-unit id="997743d612e18993ff8dc7080968428d093101a4" translate="yes" xml:space="preserve">
          <source>During the same time, the need for an encrypted transport layer raised: the Web left the relative trustiness of a mostly academic network, to a jungle where advertisers, random individuals or criminals compete to get as much private information about people, try to impersonate them or even to replace data transmitted by altered ones. As the applications built over HTTP became more and more powerful, having access to more and more private information like address books, e-mail, or the geographic position of the user, the need to have TLS became ubiquitous even outside the e-commerce use case.</source>
          <target state="translated">在同一时期,对加密传输层的需求也随之增加:网络离开了相对可信的学术网络,变成了一个广告商、随机的个人或犯罪分子争相获取尽可能多的私人信息,试图冒充他们,甚至用被篡改的数据来替代传输的数据的丛林。随着建立在HTTP上的应用程序变得越来越强大,可以访问越来越多的私人信息,如地址簿、电子邮件或用户的地理位置,即使在电子商务使用案例之外,对TLS的需求也变得无处不在。</target>
        </trans-unit>
        <trans-unit id="95b3251ec6e19bc2e780b0b452fffbe79113def2" translate="yes" xml:space="preserve">
          <source>Dynamic serving</source>
          <target state="translated">动态服务</target>
        </trans-unit>
        <trans-unit id="57313c5dd0c9956db75ecb6a66db1c8dbb3f5fdf" translate="yes" xml:space="preserve">
          <source>Dynamic. The origin server needs more information to determine tracking status.</source>
          <target state="translated">动态。源服务器需要更多信息来确定跟踪状态。</target>
        </trans-unit>
        <trans-unit id="705ecd20fdc7a1a80cbce38adda833a8e258328f" translate="yes" xml:space="preserve">
          <source>ECMAScript (&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; Specification&lt;/em&gt;&lt;/a&gt;) (&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 Section 8.2&lt;/a&gt;)</source>
          <target state="translated">ECMAScript（&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt;规范&lt;/em&gt;&lt;/a&gt;）（&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329第8.2节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="11d00f6ed181afbae6281cf892e585dcee85b274" translate="yes" xml:space="preserve">
          <source>ETag</source>
          <target state="translated">ETag</target>
        </trans-unit>
        <trans-unit id="a9cf203d9639d2de24fc7e1aabf9a3f1d1b216fd" translate="yes" xml:space="preserve">
          <source>ETag (RFC 2616)</source>
          <target state="translated">ETag</target>
        </trans-unit>
        <trans-unit id="c3c187693ac73afbe58b0355bda0f434ddd57b14" translate="yes" xml:space="preserve">
          <source>ETag (RFC 7232)</source>
          <target state="translated">交易所标记(RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2586de7225abd1a31095cd8e2595f05492c55926" translate="yes" xml:space="preserve">
          <source>ETags</source>
          <target state="translated">ETags</target>
        </trans-unit>
        <trans-unit id="91b64bf36619dc548bb6dc82aa7a3172dcb0fa4a" translate="yes" xml:space="preserve">
          <source>EU cookie directive</source>
          <target state="translated">欧盟cookie指令</target>
        </trans-unit>
        <trans-unit id="aacf5c8fecb249d308c1a10d329efa9aa9c43e95" translate="yes" xml:space="preserve">
          <source>Each Hypertext Transfer Protocol (HTTP) message is either a request
   or a response.  A server listens on a connection for a request,
   parses each message received, interprets the message semantics in
   relation to the identified request target, and responds to that
   request with one or more response messages.  A client constructs
   request messages to communicate specific intentions, examines
   received responses to see if the intentions were carried out, and
   determines how to interpret the results.  This document defines
   HTTP/1.1 request and response semantics in terms of the architecture
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;].

   HTTP provides a uniform interface for interacting with a resource
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;), regardless of its type, nature, or implementation, via
   the manipulation and transfer of representations (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).

   HTTP semantics include the intentions defined by each request method
   (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), extensions to those semantics that might be described in
   request header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), the meaning of status codes to
   indicate a machine-readable response (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;), and the meaning of
   other control data and resource metadata that might be given in
   response header fields (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   This document also defines representation metadata that describe how
   a payload is intended to be interpreted by a recipient, the request
   header fields that might influence content selection, and the various
   selection algorithms that are collectively referred to as &quot;content
   negotiation&quot; (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).</source>
          <target state="translated">每个超文本传输​​协议（HTTP）消息都是请求或响应。服务器在连接上侦听请求，解析接收到的每个消息，解释与所标识的请求目标有关的消息语义，并使用一个或多个响应消息响应该请求。客户端构造请求消息以传达特定意图，检查收到的响应以查看意图是否得到执行，并确定如何解释结果。本文档根据[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]中定义的体系结构定义了HTTP / 1.1请求和响应语义。 HTTP提供了用于与资源交互的统一接口（&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;），无论其类型，性质或实现方式如何，都可以通过对表示的操纵和转移来实现（&lt;a href=&quot;#section-3&quot;&gt;第3节&lt;/a&gt;）。 HTTP语义包括每种请求方法定义的意图（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;），对可能在请求标头字段中描述的语义的扩展（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;），指示机器可读响应的状态码的含义（&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）以及响应头字段中可能给出的其他控制数据和资源元数据的含义（&lt;a href=&quot;#section-7&quot;&gt;第7节）&lt;/a&gt;）。该文档还定义了表示形式元数据，这些元数据描述了接收方应如何解释有效负载，可能影响内容选择的请求标头字段以及统称为&amp;ldquo;内容协商&amp;rdquo;的各种选择算法（&lt;a href=&quot;#section-3.4&quot;&gt;第3.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="057e4721fb960e50e6bc2f172224db4e1bf70d8b" translate="yes" xml:space="preserve">
          <source>Each Status-Code is described below, including a description of which
   method(s) it can follow and any metainformation required in the
   response.</source>
          <target state="translated">下文对每个状态代码进行了描述,包括对其可采用的方法的描述以及答复中所要求的任何元信息。</target>
        </trans-unit>
        <trans-unit id="0bafccf37828f0cf81554847666fb3201e53972e" translate="yes" xml:space="preserve">
          <source>Each browser performs MIME sniffing differently and under different circumstances. (For example, Safari will look at the file extension in the URL if the sent MIME type is unsuitable.) There are security concerns as some MIME types represent executable content. Servers can prevent MIME sniffing by sending the &lt;a href=&quot;../headers/x-content-type-options&quot;&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">每个浏览器在不同的情况下执行MIME嗅探的方式都不同。（例如，如果发送的MIME类型不合适，Safari将查看URL中的文件扩展名。）由于某些MIME类型表示可执行内容，因此存在安全方面的问题。服务器可以通过发送&lt;a href=&quot;../headers/x-content-type-options&quot;&gt; &lt;code&gt;X-Content-Type-Options&lt;/code&gt; &lt;/a&gt;标头来防止MIME嗅探。</target>
        </trans-unit>
        <trans-unit id="82fa8700dcf214b80fbd4de6e7bf762e538223a6" translate="yes" xml:space="preserve">
          <source>Each client in the request chain may have its own cache, so it is
   common for a cache at an intermediary to receive conditional requests
   from other (outbound) caches.  Likewise, some user agents make use of
   conditional requests to limit data transfers to recently modified
   representations or to complete the transfer of a partially retrieved
   representation.

   If a cache receives a request that can be satisfied by reusing one of
   its stored 200 (OK) or 206 (Partial Content) responses, the cache
   SHOULD evaluate any applicable conditional header field preconditions
   received in that request with respect to the corresponding validators
   contained within the selected response.  A cache MUST NOT evaluate 

   conditional header fields that are only applicable to an origin
   server, found in a request with semantics that cannot be satisfied
   with a cached response, or applied to a target resource for which it
   has no stored responses; such preconditions are likely intended for
   some other (inbound) server.

   The proper evaluation of conditional requests by a cache depends on
   the received precondition header fields and their precedence, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7232]&lt;/a&gt;.  The If-Match and
   If-Unmodified-Since conditional header fields are not applicable to a
   cache.

   A request containing an If-None-Match header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7232]&lt;/a&gt;) indicates that the client wants to validate one or more of
   its own stored responses in comparison to whichever stored response
   is selected by the cache.  If the field-value is &quot;*&quot;, or if the
   field-value is a list of entity-tags and at least one of them matches
   the entity-tag of the selected stored response, a cache recipient
   SHOULD generate a 304 (Not Modified) response (using the metadata of
   the selected stored response) instead of sending that stored
   response.

   When a cache decides to revalidate its own stored responses for a
   request that contains an If-None-Match list of entity-tags, the cache
   MAY combine the received list with a list of entity-tags from its own
   stored set of responses (fresh or stale) and send the union of the
   two lists as a replacement If-None-Match header field value in the
   forwarded request.  If a stored response contains only partial
   content, the cache MUST NOT include its entity-tag in the union
   unless the request is for a range that would be fully satisfied by
   that partial stored response.  If the response to the forwarded
   request is 304 (Not Modified) and has an ETag header field value with
   an entity-tag that is not in the client's list, the cache MUST
   generate a 200 (OK) response for the client by reusing its
   corresponding stored response, as updated by the 304 response
   metadata (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;).

   If an If-None-Match header field is not present, a request containing
   an If-Modified-Since header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt;)
   indicates that the client wants to validate one or more of its own
   stored responses by modification date.  A cache recipient SHOULD
   generate a 304 (Not Modified) response (using the metadata of the
   selected stored response) if one of the following cases is true: 1)
   the selected stored response has a Last-Modified field-value that is
   earlier than or equal to the conditional timestamp; 2) no
   Last-Modified field is present in the selected stored response, but
   it has a Date field-value that is earlier than or equal to the
   conditional timestamp; or, 3) neither Last-Modified nor Date is 

   present in the selected stored response, but the cache recorded it as
   having been received at a time earlier than or equal to the
   conditional timestamp.

   A cache that implements partial responses to range requests, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;], also needs to evaluate a received If-Range
   header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;) with respect to its selected
   stored response.</source>
          <target state="translated">请求链中的每个客户端可能都有其自己的缓存，因此，中间设备的缓存通常会从其他（出站）缓存接收条件请求。同样，某些用户代理使用条件请求将数据传输限制为最近修改的表示形式，或完成部分检索的表示形式的传输。如果缓存接收到一个可以通过重用其存储的200（OK）或206（部分内容）响应之一来满足的请求，则该缓存应针对包含在其中的相应验证器，评估在该请求中接收到的任何适用的条件标头字段前提条件选定的响应。缓存不得评估仅适用于原始服务器的条件标头字段，在请求中找到的语义无法满足缓存的响应，或者应用于没有存储响应的目标资源；这样的前提条件可能是针对其他（入站）服务器的。高速缓存对条件请求的正确评估取决于所接收的前提条件标头字段及其优先级，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;[RFC7232]的第6节&lt;/a&gt;。 If-Match和If-Unmodified-Since条件标头字段不适用于高速缓存。包含If-None-Match标头字段的请求（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232]的3.2节&lt;/a&gt;）表示与缓存选择的存储响应相比，客户端要验证其自身存储的响应中的一个或多个。如果该字段值为&amp;ldquo; *&amp;rdquo;，或者该字段值为实体标签列表，并且其中至少有一个与所选存储响应的实体标签匹配，则缓存接收者应生成304（未修改）响应（使用所选存储的响应的元数据），而不是发送该存储的响应。当缓存决定对包含实体标签的If-None-Match列表的请求重新验证其自身存储的响应时，缓存可以将接收到的列表与来自其自身存储的一组响应（新的或陈旧的）的实体标签列表进行组合，并在转发的请求中将两个列表的并集作为替换的If-None-Match标头字段值发送。如果存储的响应仅包含部分内容，则除非请求的范围是该部分存储的响应将完全满足，否则缓存不得在联合中包括其实体标签。如果对转发请求的响应是304（未修改），并且具有带有不在客户端列表中的实体标签的ETag头字段值，则缓存必须通过重用其对应的内容为客户端生成200（OK）响应存储的响应，由304个响应元数据更新（除非请求是针对部分存储的响应将完全满足的范围，否则缓存不得在联合中包括其实体标签。如果对转发请求的响应是304（未修改），并且具有带有不在客户端列表中的实体标签的ETag头字段值，则缓存必须通过重用其对应的内容为客户端生成200（OK）响应存储的响应，由304响应元数据更新（除非请求是针对部分存储的响应将完全满足的范围，否则缓存不得在联合中包括其实体标签。如果对转发请求的响应是304（未修改），并且具有带有不在客户端列表中的实体标签的ETag头字段值，则缓存必须通过重用其对应的内容为客户端生成200（OK）响应存储的响应，由304个响应元数据更新（如304响应元数据所更新，缓存必须通过重用其相应的存储响应为客户端生成200（OK）响应（如304响应元数据所更新，缓存必须通过重用其相应的存储响应为客户端生成200（OK）响应（&lt;a href=&quot;#section-4.3.4&quot;&gt;第4.3.4节&lt;/a&gt;）。如果不存在If-None-Match标头字段，则请求包含If-Modified-Since标头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232]的3.3节）&lt;/a&gt;）表示客户希望在修改日期之前验证其自己存储的一个或多个响应。如果以下情况之一为真，则缓存接收者应该使用选定的存储响应的元数据生成304（未修改）响应：1）选定的存储响应的Last-Modified字段值早于或等于条件时间戳； 2）所选存储的响应中没有Last-Modified字段，但它的Date字段值早于或等于条件时间戳；或3）所选存储的响应中既没有Last-Modified也不存在Date，但是缓存将其记录为在早于或等于条件时间戳的时间接收到。实现对范围请求的部分响应的缓存，如[&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]，还需要相对于其选定的存储响应来评估接收到的If-Range标头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]的3.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cdfff658f8638be3f51c025575b0ddaed39961ef" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types are taking a lot of space to store and the need to regain this wasted space appeared very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="translated">每种数据类型都有一些冗余，即&lt;em&gt;浪费空间&lt;/em&gt;。如果文本通常具有多达60％的冗余度，则对于某些其他媒体（如音频和视频），此比率可能会更高。与文本不同，这些其他媒体类型占用了大量存储空间，并且很早就需要重新获得这种浪费的空间。工程师设计了针对该特定目的的文件格式所使用的优化压缩算法。用于文件的压缩算法可以分为两大类：</target>
        </trans-unit>
        <trans-unit id="ae7498ae0f7b36b2dcd84d942c2be51971574fec" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types use lot of space to store their data and the need to optimize storage and regain space was apparent very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c418e981dde2783c397a4ab8566b1987e0ddccd" translate="yes" xml:space="preserve">
          <source>Each header field consists of a case-insensitive field name followed
   by a colon (&quot;:&quot;), optional leading whitespace, the field value, and
   optional trailing whitespace. 

     header-field   = field-name &quot;:&quot; OWS field-value OWS

     field-name     = token
     field-value    = *( field-content / obs-fold )
     field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     field-vchar    = VCHAR / obs-text

     obs-fold       = CRLF 1*( SP / HTAB )
                    ; obsolete line folding
                    ; see &lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;

   The field-name token labels the corresponding field-value as having
   the semantics defined by that header field.  For example, the Date
   header field is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&amp;nbsp;7.1.1.2 of [RFC7231]&lt;/a&gt; as containing
   the origination timestamp for the message in which it appears.</source>
          <target state="translated">每个标题字段均由不区分大小写的字段名，后跟冒号（&amp;ldquo;：&amp;rdquo;），可选的前导空白，字段值和可选的尾随空白组成。 header-field =字段名称&amp;ldquo;：&amp;rdquo; OWS字段值OWS字段名称=令牌字段值= *（field-content / obs-fold）field-content = field-vchar [1 *（SP / HTAB）field -vchar]字段-vchar = VCHAR / obs-text obs-fold = CRLF 1 *（SP / HTAB）;过时的折线;请参见&lt;a href=&quot;#section-3.2.4&quot;&gt;第3.2.4节&lt;/a&gt; 。字段名称标记将相应的字段值标记为具有该标头字段定义的语义。例如，日期标题字段在&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;[RFC7231]的7.1.1.2节中&lt;/a&gt;定义 包含出现消息的原始时间戳。</target>
        </trans-unit>
        <trans-unit id="9565e409b5a13cd6eeebcf793281c0c14e6920fb" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which handles it and provides an answer, called the &lt;em&gt;response&lt;/em&gt;. Between the client and the server there are numerous entities, collectively called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa9777361801f65cdbd5d095a27001848c440f6" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which will handle it and provide an answer, called the &lt;em&gt;response&lt;/em&gt;. Between this request and response there are numerous entities, collectively designated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="translated">每个单独的请求都发送到服务器，服务器将处理该请求并提供答案（称为&lt;em&gt;response）&lt;/em&gt;。在此请求和响应之间，有许多实体（统称为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;代理）&lt;/a&gt;，它们执行不同的操作并充当网关或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;缓存&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d47e568ac317d800ba83293a6e6b145c10f0e3f" translate="yes" xml:space="preserve">
          <source>Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.

   Registrations happen on a &quot;First Come First Served&quot; basis (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC5226]&lt;/a&gt;) and are subject to the following rules:

   1.  A protocol-name token, once registered, stays registered forever.

   2.  The registration MUST name a responsible party for the
       registration.

   3.  The registration MUST name a point of contact.

   4.  The registration MAY name a set of specifications associated with
       that token.  Such specifications need not be publicly available.

   5.  The registration SHOULD name a set of expected &quot;protocol-version&quot;
       tokens associated with that token at the time of registration. 

   6.  The responsible party MAY change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.

   7.  The IESG MAY reassign responsibility for a protocol token.  This
       will normally only be used in the case when a responsible party
       cannot be contacted.

   This registration procedure for HTTP Upgrade Tokens replaces that
   previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">每个注册的协议名称都与联系信息和一组可选的规范相关联，这些规范详细说明了升级连接后将如何处理该连接。注册以&amp;ldquo;先到先得&amp;rdquo;的方式进行（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226]第4.1节&lt;/a&gt;），并遵守以下规则：1.协议名称令牌一旦注册，便永远保持注册状态。 2.注册必须指定注册的责任方。 3.注册必须指定联系人。 4.注册可以命名与该令牌相关的一组规范。此类规范无需公开获得。 5.注册应该在注册时命名与该令牌关联的一组预期的&amp;ldquo;协议版本&amp;rdquo;令牌。 6.责任方可以随时更改注册。 IANA将保留所有此类更改的记录，并应要求提供这些更改。 7. IESG可以重新分配协议令牌的责任。通常仅在无法联系责任方时使用。 HTTP升级令牌的此注册过程取代了先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]的7.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f681ccf67162d9cff0a908b916182711ed9cc29e" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;no-store&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb1874585ee277130e7dcc804818855ef02a2e2" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: private&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="translated">每个对URL的请求都应被视为唯一且不可缓存的请求。更好的方法是使用&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: private&lt;/code&gt; ，它更易于阅读，并且还指示该对象永远不应存储。</target>
        </trans-unit>
        <trans-unit id="06c0d14065b0e4f4c93db5d7ec072d4c7ca36aee" translate="yes" xml:space="preserve">
          <source>Each type has its own set of possible subtypes, and a MIME type always has both a type and a subtype, never just one or the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083351d889941c99f11bdb7f8dc5b5a5a90e3651" translate="yes" xml:space="preserve">
          <source>Early-Data</source>
          <target state="translated">Early-Data</target>
        </trans-unit>
        <trans-unit id="8440b9eb7d03917b2509b5baeab2a299ce257eb0" translate="yes" xml:space="preserve">
          <source>Edge</source>
          <target state="translated">Edge</target>
        </trans-unit>
        <trans-unit id="aa5e3465605004afca0f330dee1d92d60e4608d6" translate="yes" xml:space="preserve">
          <source>Edge 17 skips the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive (&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;bug&lt;/a&gt;).</source>
          <target state="translated">Edge 17跳过&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt;指令（&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;bug&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="40943d342558e930e5fd4552c5671ad9d18db865" translate="yes" xml:space="preserve">
          <source>Edge Mobile</source>
          <target state="translated">边缘移动</target>
        </trans-unit>
        <trans-unit id="8186c1b8199a285af780f2cff07d80dbd60cd881" translate="yes" xml:space="preserve">
          <source>Edge has &lt;a href=&quot;https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/&quot;&gt;retired their XSS filter&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1594fb58d4be36a563bbf83f00f527da6feeed9b" translate="yes" xml:space="preserve">
          <source>Edge on Windows 10 Mobile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ed0aee9b31cc8d3563818529b7abccaaaad432" translate="yes" xml:space="preserve">
          <source>Edge/xyz</source>
          <target state="translated">Edge/xyz</target>
        </trans-unit>
        <trans-unit id="d5fbe14f72118336fc25fa625850b0c5c3be431a" translate="yes" xml:space="preserve">
          <source>EdgeHTML</source>
          <target state="translated">EdgeHTML</target>
        </trans-unit>
        <trans-unit id="add94fac827b3ed02fee4c1b72173331645c25b8" translate="yes" xml:space="preserve">
          <source>Edit this page on MDN</source>
          <target state="translated">在MDN上编辑此页</target>
        </trans-unit>
        <trans-unit id="a769fc9fd1bf50a69b3839fd2f92626878d5b626" translate="yes" xml:space="preserve">
          <source>Editor's Draft</source>
          <target state="translated">编辑稿</target>
        </trans-unit>
        <trans-unit id="f0aaf1ff183fe38a130caadf7977863f8e2a59f3" translate="yes" xml:space="preserve">
          <source>Editor's draft</source>
          <target state="translated">编辑的草稿</target>
        </trans-unit>
        <trans-unit id="90b56ed596b137c9da80b986161d0bd1c8d62cba" translate="yes" xml:space="preserve">
          <source>Editor's draft / Candidate recommendation</source>
          <target state="translated">编辑稿/候选人推荐</target>
        </trans-unit>
        <trans-unit id="1c3d5530a42ab230eeb2ce3fa0fa80758453dd56" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;report&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb29b12af265782c792c3f30babdfaf626f24932" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;report&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcd0c7316a8c31f4e9ceb1db446cf33c197f076" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="translated">无论是 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; 取决于是否&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;头或 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 是使用的头。</target>
        </trans-unit>
        <trans-unit id="d8d9968b1d7df53b6e4cf681453c3df54edc30bf" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="translated">无论是 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; 取决于是否&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;标题或 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 头使用。</target>
        </trans-unit>
        <trans-unit id="fa29e4650b1639a98c0c8f55d262398a02155fba" translate="yes" xml:space="preserve">
          <source>Either the string &quot;GMT&quot; for GMT timezone, or not specified, for local timezone.</source>
          <target state="translated">字符串 &quot;GMT &quot;代表GMT时区,或者没有指定,代表本地时区。</target>
        </trans-unit>
        <trans-unit id="eec5a0a958a1fbddcf0daab821af65ae5b6cc34b" translate="yes" xml:space="preserve">
          <source>Electronic mail address</source>
          <target state="translated">电子信箱地址</target>
        </trans-unit>
        <trans-unit id="f98f953a2a328bdea00e564fed7dfd322a69cd6d" translate="yes" xml:space="preserve">
          <source>Electronic publication (EPUB)</source>
          <target state="translated">电子出版物(EPUB)</target>
        </trans-unit>
        <trans-unit id="5a67bc2ccc5173b788a5682e69fed1656994a358" translate="yes" xml:space="preserve">
          <source>Elements controlled by &lt;code&gt;object-src&lt;/code&gt; are perhaps coincidentally considered legacy HTML elements and are not receiving new standardized features (such as the security attributes &lt;code&gt;sandbox&lt;/code&gt; or &lt;code&gt;allow&lt;/code&gt; for &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;). Therefore it is &lt;strong&gt;recommended&lt;/strong&gt; to restrict this fetch-directive (e.g., explicitly set &lt;code&gt;object-src 'none'&lt;/code&gt; if possible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3465998ffce5d1b11571e20db3e058cd0d4176c" translate="yes" xml:space="preserve">
          <source>Elements controlled by &lt;code&gt;object-src&lt;/code&gt; are perhaps coincidentally considered legacy HTML elements and aren't receiving new standardized features (such as the security attributes &lt;code&gt;sandbox&lt;/code&gt; or &lt;code&gt;allow&lt;/code&gt; for &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;). Therefore it is &lt;a href=&quot;https://csp.withgoogle.com/docs/strict-csp.html&quot;&gt;recommended&lt;/a&gt; to restrict this fetch-directive (e.g. explicitly set &lt;code&gt;object-src 'none'&lt;/code&gt; if possible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70620ad9a50dbab17deb7f1669beeb98b33e7dd5" translate="yes" xml:space="preserve">
          <source>Enable CORS: I want to add CORS support to my server</source>
          <target state="translated">启用CORS。我想在我的服务器上添加CORS支持。</target>
        </trans-unit>
        <trans-unit id="7060cb09d904d309fcf66579b0dfa0ec89ffc7ea" translate="yes" xml:space="preserve">
          <source>Enables Cross-Origin Read Blocking (CORB) protection for the MIME-types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a23cd75e8cc48555a5cc4d39dc5d353f54219c1" translate="yes" xml:space="preserve">
          <source>Enables DNS prefetching. This is what browsers do, if they support the feature, when this header is not present</source>
          <target state="translated">启用DNS预取功能。如果浏览器支持该功能,当该头不存在时,浏览器会这样做。</target>
        </trans-unit>
        <trans-unit id="15f6f232156085ea4d4637fb11cb65dea424795d" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering (usually default in browsers). If a cross-site scripting attack is detected, the browser will sanitize the page (remove the unsafe parts).</source>
          <target state="translated">启用XSS过滤功能(通常是浏览器的默认值)。如果检测到跨站脚本攻击,浏览器将对页面进行消毒(删除不安全部分)。</target>
        </trans-unit>
        <trans-unit id="2afff7cdf670cfcd98e1bf3804e6db1cd9978584" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. If a cross-site scripting attack is detected, the browser will sanitize the page and report the violation. This uses the functionality of the CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive to send a report.</source>
          <target state="translated">启用XSS过滤。如果检测到跨站点脚本攻击，浏览器将对页面进行清理并报告违规行为。这使用CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;指令的功能来发送报告。</target>
        </trans-unit>
        <trans-unit id="04c90c3404283e6479b83c3594ac6645fd7a76cf" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. Rather than sanitizing the page, the browser will prevent rendering of the page if an attack is detected.</source>
          <target state="translated">启用XSS过滤功能。如果检测到攻击,浏览器将阻止页面的渲染,而不是对页面进行消毒。</target>
        </trans-unit>
        <trans-unit id="22ebba1e22e214dfdd20ecfca28bb3fc46c19982" translate="yes" xml:space="preserve">
          <source>Enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">为请求的资源启用沙箱，类似于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="d9c536a9d2dc890eb3a315dacecf7bf8af2ea7a0" translate="yes" xml:space="preserve">
          <source>Enables cross-site scripting filtering.</source>
          <target state="translated">启用跨站点脚本过滤。</target>
        </trans-unit>
        <trans-unit id="22f217de833d7c0f4da332bd436a93307529d3b5" translate="yes" xml:space="preserve">
          <source>Enabling HPKP</source>
          <target state="translated">启用HPKP</target>
        </trans-unit>
        <trans-unit id="bd97d929640fde2abf473682141dfee61b906111" translate="yes" xml:space="preserve">
          <source>Enabling reporting</source>
          <target state="translated">启用报告</target>
        </trans-unit>
        <trans-unit id="d51a5760383324ea2ced3708f0c4f21b3b6433db" translate="yes" xml:space="preserve">
          <source>Encoding data into base64 format</source>
          <target state="translated">将数据编码为base64格式</target>
        </trans-unit>
        <trans-unit id="5a526ce1054f67846c014806870479f982067006" translate="yes" xml:space="preserve">
          <source>Encoding in Javascript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1b3d87041d9d3f6d49d001407d5e51e783220a" translate="yes" xml:space="preserve">
          <source>Encoding on Microsoft Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a85145b06e5a569eeab2640e8113603e4dec581" translate="yes" xml:space="preserve">
          <source>Encoding on Windows can be done through powershell or some dedicated tool. It can even be done via bash &lt;code&gt;base64&lt;/code&gt; utility (see section Encoding on a Unix system) if &lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux&quot;&gt;WSL&lt;/a&gt; is activated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9723a9fa3539530df973d9238398c2287f9fc64" translate="yes" xml:space="preserve">
          <source>Encoding on a Unix system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635fc00ea52427c14323d1d4ec9234a0c136c15e" translate="yes" xml:space="preserve">
          <source>Encrypted Media Extensions&lt;br/&gt;&lt;small&gt;The definition of 'Feature Policy integration' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b844634b78bbf66c2386fb7400b4efd46ba2fc" translate="yes" xml:space="preserve">
          <source>Encrypted media</source>
          <target state="translated">加密媒体</target>
        </trans-unit>
        <trans-unit id="bb7917263fb0376ecaaebc6aea8b04a067f36021" translate="yes" xml:space="preserve">
          <source>End-to-end compression</source>
          <target state="translated">端到端压缩</target>
        </trans-unit>
        <trans-unit id="a93b3f3b09d62b69cd48fa61fb8317033f43c87d" translate="yes" xml:space="preserve">
          <source>End-to-end headers</source>
          <target state="translated">端到端标题</target>
        </trans-unit>
        <trans-unit id="c1f86bbe0ad1ce921865c4c1081ca46c634279dd" translate="yes" xml:space="preserve">
          <source>Enforces &lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;Trusted Types&lt;/a&gt; at the DOM XSS injection sinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a78c23ebe3e022d382e262e5bb0fac3b0c04eb" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences</source>
          <target state="translated">强化良好用户体验的最佳实践</target>
        </trans-unit>
        <trans-unit id="434a202c7ecffe7d7bd9b742b730a5afd1676889" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences.</source>
          <target state="translated">强化良好用户体验的最佳实践。</target>
        </trans-unit>
        <trans-unit id="ffa0f5134bbe5f9da939c45f920a197f4634fba1" translate="yes" xml:space="preserve">
          <source>Ensure images are sized properly and are not too big for the viewport.</source>
          <target state="translated">确保图像的大小合适,对视口来说不要太大。</target>
        </trans-unit>
        <trans-unit id="2a6cc6b1ec9b8b2e989114255b4da3ce2b2f166e" translate="yes" xml:space="preserve">
          <source>Ensures a resource will disown its opener when navigated to.</source>
          <target state="translated">确保资源在导航到时,将不承认其打开器。</target>
        </trans-unit>
        <trans-unit id="2f61151d2512a5c88d23bfe8d6fbd9a0947b4f37" translate="yes" xml:space="preserve">
          <source>Entity (RFC 2616)</source>
          <target state="translated">实体(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="234e8581d4bf52bbea04d4ae883867b5f00f2402" translate="yes" xml:space="preserve">
          <source>Entity header</source>
          <target state="translated">实体头</target>
        </trans-unit>
        <trans-unit id="83a31c55ad20bb3cf7572f62e10bce1fa2085786" translate="yes" xml:space="preserve">
          <source>Entity tag uniquely representing the requested resource. They are a string of ASCII characters placed between double quotes, like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;. The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Often, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hexadecimal hash of the wiki article content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9024c46dde9f89740b2171b9280d89a9caba4424" translate="yes" xml:space="preserve">
          <source>Entity tags are used for comparing two or more entities from the same
   requested resource. HTTP/1.1 uses entity tags in the ETag (&lt;a href=&quot;#section-14.19&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;), If-Match (&lt;a href=&quot;#section-14.24&quot;&gt;section 14.24&lt;/a&gt;), If-None-Match (&lt;a href=&quot;#section-14.26&quot;&gt;section 14.26&lt;/a&gt;), and
   If-Range (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) header fields. The definition of how they
   are used and compared as cache validators is in &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;. An
   entity tag consists of an opaque quoted string, possibly prefixed by
   a weakness indicator.

      entity-tag = [ weak ] opaque-tag
      weak       = &quot;W/&quot;
      opaque-tag = quoted-string

   A &quot;strong entity tag&quot; MAY be shared by two entities of a resource
   only if they are equivalent by octet equality.

   A &quot;weak entity tag,&quot; indicated by the &quot;W/&quot; prefix, MAY be shared by
   two entities of a resource only if the entities are equivalent and
   could be substituted for each other with no significant change in
   semantics. A weak entity tag can only be used for weak comparison.

   An entity tag MUST be unique across all versions of all entities
   associated with a particular resource. A given entity tag value MAY
   be used for entities obtained by requests on different URIs. The use
   of the same entity tag value in conjunction with entities obtained by
   requests on different URIs does not imply the equivalence of those
   entities.</source>
          <target state="translated">实体标签用于比较来自同一请求资源的两个或多个实体。 HTTP / 1.1在ETag（&lt;a href=&quot;#section-14.19&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19 &lt;/a&gt;节），If-Match（&lt;a href=&quot;#section-14.24&quot;&gt;第14.24节&lt;/a&gt;），If-None-Match（&lt;a href=&quot;#section-14.26&quot;&gt;第14.26节&lt;/a&gt;）和If-Range（&lt;a href=&quot;#section-14.27&quot;&gt;第14.27节&lt;/a&gt;）标头字段中使用实体标签。&lt;a href=&quot;#section-13.3.3&quot;&gt;第13.3.3节中&lt;/a&gt;定义了如何使用和比较它们作为缓存验证器。。实体标签由不透明的带引号的字符串组成，可能以漏洞指示器为前缀。实体标签= [弱]透明标签弱=&amp;ldquo; W /&amp;rdquo;透明标签=带引号的字符串&amp;ldquo;强实体标签&amp;rdquo;仅在资源的两个实体通过八位字节相等等效时才可以共享。由&amp;ldquo; W /&amp;rdquo;前缀表示的&amp;ldquo;弱实体标签&amp;rdquo;，只有在两个实体相等且可以在语义上没有显着变化的情况下彼此替换时，才可以由资源的两个实体共享。弱实体标签只能用于弱比较。实体标签在与特定资源相关联的所有实体的所有版本中必须是唯一的。给定的实体标签值可以用于通过不同URI请求获得的实体。将相同的实体标记值与通过对不同URI的请求获得的实体结合使用并不意味着这些实体是等效的。</target>
        </trans-unit>
        <trans-unit id="843ca4f28f9ce3aa7d78cfc1dd5d180a8db20d61" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used (This is useless with &lt;code&gt;If-None-Match&lt;/code&gt; as it only uses that algorithm).</source>
          <target state="translated">实体标签唯一代表所请求的资源。它们是放在双引号之间的一串ASCII字符（如 &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ），并且可能以 &lt;code&gt;W/&lt;/code&gt; 开头，以指示应使用弱比较算法（这对于 &lt;code&gt;If-None-Match&lt;/code&gt; 无效，因为它仅使用该算法）。</target>
        </trans-unit>
        <trans-unit id="cb4831ed8a07834c227f88278424a465acad3a5a" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used.</source>
          <target state="translated">实体标签唯一代表所请求的资源。它们是放在双引号之间的一串ASCII字符（如 &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ），并且可能以 &lt;code&gt;W/&lt;/code&gt; 开头，以指示应使用弱比较算法。</target>
        </trans-unit>
        <trans-unit id="f511403ebe3ad82f8791c9cc50f7078c288954a3" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Oftentimes, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hash of hexadecimal digits of the wiki content.</source>
          <target state="translated">实体标签唯一代表所请求的资源。它们是放在双引号之间的一串ASCII字符（例如 &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ）。未指定生成 &lt;code&gt;ETag&lt;/code&gt; 值的方法。通常，使用内容的哈希值，上次修改时间戳的哈希值或仅使用修订号。例如，MDN使用Wiki内容的十六进制数字的哈希。</target>
        </trans-unit>
        <trans-unit id="3b0aa4ab650e7127575b944e7c4f357507fe1bf6" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). They may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that they are &quot;weak&quot;, i.e. that they represent the resource semantically, but not byte-for-byte. However, in an &lt;code&gt;If-Match&lt;/code&gt; header, weak entity tags will never match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d3b3c670a7def682fbdd286ebd5fcf01de31d4" translate="yes" xml:space="preserve">
          <source>Entity-header fields define metainformation about the entity-body or,
   if no body is present, about the resource identified by the request.
   Some of this metainformation is OPTIONAL; some might be REQUIRED by
   portions of this specification.

       entity-header  = Allow                    ; &lt;a href=&quot;#section-14.7&quot;&gt;Section 14.7&lt;/a&gt;
                      | Content-Encoding         ; &lt;a href=&quot;#section-14.11&quot;&gt;Section 14.11&lt;/a&gt;
                      | Content-Language         ; &lt;a href=&quot;#section-14.12&quot;&gt;Section 14.12&lt;/a&gt;
                      | Content-Length           ; &lt;a href=&quot;#section-14.13&quot;&gt;Section 14.13&lt;/a&gt;
                      | Content-Location         ; &lt;a href=&quot;#section-14.14&quot;&gt;Section 14.14&lt;/a&gt;
                      | Content-MD5              ; &lt;a href=&quot;#section-14.15&quot;&gt;Section 14.15&lt;/a&gt;
                      | Content-Range            ; &lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;
                      | Content-Type             ; &lt;a href=&quot;#section-14.17&quot;&gt;Section 14.17&lt;/a&gt;
                      | Expires                  ; &lt;a href=&quot;#section-14.21&quot;&gt;Section 14.21&lt;/a&gt;
                      | Last-Modified            ; &lt;a href=&quot;#section-14.29&quot;&gt;Section 14.29&lt;/a&gt;
                      | extension-header

       extension-header = message-header

   The extension-header mechanism allows additional entity-header fields
   to be defined without changing the protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fields SHOULD be ignored by the recipient and MUST be forwarded by
   transparent proxies.</source>
          <target state="translated">实体标头字段定义有关实体主体的元信息，如果没有主体，则定义有关请求标识的资源的元信息。其中一些元信息是可选的；本规范的某些部分可能需要某些。实体标题=允许; &lt;a href=&quot;#section-14.7&quot;&gt;第14.7节&lt;/a&gt; |内容编码&lt;a href=&quot;#section-14.11&quot;&gt;第14.11节&lt;/a&gt; |内容语言&lt;a href=&quot;#section-14.12&quot;&gt;第14.12节&lt;/a&gt; |内容长度&lt;a href=&quot;#section-14.13&quot;&gt;第14.13节&lt;/a&gt; |内容位置&lt;a href=&quot;#section-14.14&quot;&gt;第14.14节&lt;/a&gt; |内容MD5; &lt;a href=&quot;#section-14.15&quot;&gt;第14.15节&lt;/a&gt; |内容范围&lt;a href=&quot;#section-14.16&quot;&gt;第14.16节&lt;/a&gt; | 内容类型 ; &lt;a href=&quot;#section-14.17&quot;&gt;第14.17节&lt;/a&gt; | 到期; &lt;a href=&quot;#section-14.21&quot;&gt;第14.21节&lt;/a&gt; | 最后修改 ; &lt;a href=&quot;#section-14.29&quot;&gt;第14.29节&lt;/a&gt; | extension-header extension-header = message-header扩展头机制允许在不更改协议的情况下定义其他实体头字段，但是不能假定收件人可以识别这些字段。接收者应忽略无法识别的报头字段，并且必须由透明代理转发。</target>
        </trans-unit>
        <trans-unit id="dc77c92755cf792527e0b3edc88e46b61f8087b7" translate="yes" xml:space="preserve">
          <source>Error responses: a &lt;a href=&quot;status/404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; (Not Found) result page.</source>
          <target state="translated">错误响应：&lt;a href=&quot;status/404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt;（未找到）结果页面。</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="ec4322ae064b7f4e2416acd40d4d58f17e5f8f12" translate="yes" xml:space="preserve">
          <source>Errors: CORSAllowOriginNotMatchingOrigin</source>
          <target state="translated">错误。CORSAllowOriginNotMatchingOrigin。</target>
        </trans-unit>
        <trans-unit id="4087c6aa16b5abf1735ae9f8137528c87023309b" translate="yes" xml:space="preserve">
          <source>Errors: CORSDidNotSucceed</source>
          <target state="translated">错误。CORSDidNotSucceed</target>
        </trans-unit>
        <trans-unit id="1110c379846585f2593a508b8c164b5bd8320b76" translate="yes" xml:space="preserve">
          <source>Errors: CORSDisabled</source>
          <target state="translated">错误。CORSDisabled</target>
        </trans-unit>
        <trans-unit id="dac4e756c8a76cbef1b33dca607cb3bc5b771e95" translate="yes" xml:space="preserve">
          <source>Errors: CORSExternalRedirectNotAllowed</source>
          <target state="translated">错误。CORSExternalRedirectNotAllowed。</target>
        </trans-unit>
        <trans-unit id="ce973b3c74a1ebbfbbd6d7dec66c6bb20ce1f763" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowHeader</source>
          <target state="translated">错误。CORSInvalidAllowHeader</target>
        </trans-unit>
        <trans-unit id="a282fd28c28a400d13afa18351e51568b54396d2" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowMethod</source>
          <target state="translated">错误。CORSInvalidAllowMethod</target>
        </trans-unit>
        <trans-unit id="b8d43e50964c1cfd887f4afc94b47bcdd5d69570" translate="yes" xml:space="preserve">
          <source>Errors: CORSMIssingAllowCredentials</source>
          <target state="translated">错误。CORSMIssingAllowCredentials.</target>
        </trans-unit>
        <trans-unit id="710e0ccb5287b4319b0c5fdee5593e1d13fa6e37" translate="yes" xml:space="preserve">
          <source>Errors: CORSMethodNotFound</source>
          <target state="translated">错误。CORSMethodNotFound</target>
        </trans-unit>
        <trans-unit id="a307f601e16873b1a5a1472fa793e47e1b28b743" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowHeaderFromPreflight</source>
          <target state="translated">错误。CORSMissingAllowHeaderFromPreflight.</target>
        </trans-unit>
        <trans-unit id="3d47284892dc16fb82eea87c1c413d4b5c528c8b" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowOrigin</source>
          <target state="translated">错误。CORSMissingAllowOrigin</target>
        </trans-unit>
        <trans-unit id="59e949130b0899712b1a17c6d46a1f58dc1ad38e" translate="yes" xml:space="preserve">
          <source>Errors: CORSMultipleAllowOriginNotAllowed</source>
          <target state="translated">错误。CORSMultipleAllowOriginNotAllowed。</target>
        </trans-unit>
        <trans-unit id="fe11294cab619d12140db3bf906980249f0d9b51" translate="yes" xml:space="preserve">
          <source>Errors: CORSNotSupportingCredentials</source>
          <target state="translated">错误。CORSNotSupportingCredentials</target>
        </trans-unit>
        <trans-unit id="9d941c8ccc9202a89b0022d5ed88c86d19e065a4" translate="yes" xml:space="preserve">
          <source>Errors: CORSOriginHeaderNotAdded</source>
          <target state="translated">错误。CORSOriginHeaderNotAdded。</target>
        </trans-unit>
        <trans-unit id="4b2583c03a065a201e0c7af7eb778cf128afcc99" translate="yes" xml:space="preserve">
          <source>Errors: CORSPreflightDidNotSucceed</source>
          <target state="translated">错误:&quot;CORSPreflightDidNotSuc成功&quot;。CORSPreflightDidNotSuc成功</target>
        </trans-unit>
        <trans-unit id="a43f3bb8e46c7f4d0e112510dc95499734debf0d" translate="yes" xml:space="preserve">
          <source>Errors: CORSRequestNotHttp</source>
          <target state="translated">错误。CORSRequestNotHttp</target>
        </trans-unit>
        <trans-unit id="76e3d52572cfb5f282f24af08ceb3c93515e0c23" translate="yes" xml:space="preserve">
          <source>Establishing a connection</source>
          <target state="translated">建立连接</target>
        </trans-unit>
        <trans-unit id="d9c2c223b0f7d2f2a1d0a4ab149a50dae5eaf1dd" translate="yes" xml:space="preserve">
          <source>Evaluation (RFC 7232)</source>
          <target state="translated">评估(RFC 7232)</target>
        </trans-unit>
        <trans-unit id="016549bb81a6b73cbdac91b27317bed690bbaf39" translate="yes" xml:space="preserve">
          <source>Even if both the client and the server supports the same compression algorithms, the server may choose not to compress the body of a response, if the identity value is also acceptable. Two common cases lead to this:</source>
          <target state="translated">即使客户端和服务器都支持相同的压缩算法,如果身份值也可以接受,服务器可能会选择不压缩响应的主体。有两种常见的情况会导致这种情况。</target>
        </trans-unit>
        <trans-unit id="39e1dc57ed79bde6d7d9296899ff80637127740c" translate="yes" xml:space="preserve">
          <source>Even if identity and location are both described using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, they are two different concepts and it is useful sometimes to distinguished between them. This article introduces the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">即使使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;描述身份和位置，它们也是两个不同的概念，有时区分它们是有用的。本文介绍了&lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="d11701203cf55bb28a83c78028e1b759782a7ab9" translate="yes" xml:space="preserve">
          <source>Even if server-driven content negotiation is the most common way to agree on a specific representation of a resource, it has several drawbacks:</source>
          <target state="translated">即使服务器驱动的内容协商是就资源的特定表示达成一致的最常见方式,它也有几个缺点。</target>
        </trans-unit>
        <trans-unit id="d8b58599d2ecd8aca415a34fd71768d962e8e310" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents align with it - you can still find this type of bugged software out there. It is therefore recommended to use the &lt;code&gt;301&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use the &lt;a href=&quot;308&quot;&gt;&lt;code&gt;308 Permanent Redirect&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; methods instead, as the method change is explicitly prohibited with this status.</source>
          <target state="translated">即使规范要求在执行重定向时不更改方法（和主体），但并非所有用户代理都与之对齐-您仍然可以在那里找到这种类型的错误软件。因此，建议仅将 &lt;code&gt;301&lt;/code&gt; 代码用作&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法的响应，而将&lt;a href=&quot;308&quot;&gt; &lt;code&gt;308 Permanent Redirect&lt;/code&gt; &lt;/a&gt;用于&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;方法，因为此状态明确禁止更改方法。</target>
        </trans-unit>
        <trans-unit id="60e9e00953556ca6c857baf9a61ba9002b374a14" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents conform here - you can still find this type of bugged software out there. It is therefore recommended to set the &lt;code&gt;302&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use &lt;a href=&quot;307&quot;&gt;&lt;code&gt;307 Temporary Redirect&lt;/code&gt;&lt;/a&gt; instead, as the method change is explicitly prohibited in that case.</source>
          <target state="translated">即使规范要求执行重定向时不更改方法（和主体），但并不是所有的用户代理都符合此处的规定-您仍然可以在那里找到这种类型的错误软件。因此，建议仅将 &lt;code&gt;302&lt;/code&gt; 代码设置为&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法的响应，而改为使用&lt;a href=&quot;307&quot;&gt; &lt;code&gt;307 Temporary Redirect&lt;/code&gt; &lt;/a&gt;，因为在这种情况下，方法更改被明确禁止。</target>
        </trans-unit>
        <trans-unit id="41dab3c71327a38803685ef6e3cebc869962fcfb" translate="yes" xml:space="preserve">
          <source>Even if this method works, it adds an extra response/request exchange when the document has been changed. This impairs performance, and HTTP has a specific header to avoid this scenario: &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">即使此方法有效，当文档已更改时，它也会添加额外的响应/请求交换。这会降低性能，并且HTTP有一个特定的标头来避免这种情况：&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b284eb5d595f914af47d2a8c3a9cef82f913efb4" translate="yes" xml:space="preserve">
          <source>Even if this technique also works for internal links, you should try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request is done) and if you can avoid it by correcting internal links, you should fix these links.</source>
          <target state="translated">即使这种技术对内部链接也有效,你也应该尽量避免出现内部重定向。重定向有很大的性能成本(因为要做一个额外的HTTP请求),如果你可以通过修正内部链接来避免,你应该修正这些链接。</target>
        </trans-unit>
        <trans-unit id="58665e4007bca0cad4410abfb11d1a4668903330" translate="yes" xml:space="preserve">
          <source>Even with more complexity, introduced in HTTP/2 by encapsulating HTTP messages into frames, HTTP is generally designed to be simple and human readable. HTTP messages can be read and understood by humans, providing easier developer testing, and reduced complexity for new-comers.</source>
          <target state="translated">即使有更多的复杂性,在HTTP/2中通过将HTTP消息封装成帧而引入,HTTP通常被设计成简单和人类可读的。HTTP消息可以被人类阅读和理解,为开发者测试提供了方便,并为新用户降低了复杂性。</target>
        </trans-unit>
        <trans-unit id="8b42fb3b1821d636c208455d3a9009fab5579ed3" translate="yes" xml:space="preserve">
          <source>Evercookie by Samy Kamkar</source>
          <target state="translated">Evercookie by Samy Kamkar</target>
        </trans-unit>
        <trans-unit id="f7b5a8683f9a1cf2ee2d67f073ba064ecc576032" translate="yes" xml:space="preserve">
          <source>Everyone, really.</source>
          <target state="translated">每个人,真的。</target>
        </trans-unit>
        <trans-unit id="f49a3e37d7614909e74abaad869cfa8d5952bf40" translate="yes" xml:space="preserve">
          <source>Evolution of HTTP</source>
          <target state="translated">HTTP的演变</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">例1</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">例二</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">例三</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">例四</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">例五</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">例六</target>
        </trans-unit>
        <trans-unit id="fad75d0ce8eb620d0eb8c90ad36bb1d3ba100630" translate="yes" xml:space="preserve">
          <source>Example HPKP Header</source>
          <target state="translated">HPKP标头示例</target>
        </trans-unit>
        <trans-unit id="6f262b0de6886f68de9a7f3020d9645e1a46ad07" translate="yes" xml:space="preserve">
          <source>Example of typical subtypes</source>
          <target state="translated">典型子类型的例子</target>
        </trans-unit>
        <trans-unit id="987339acda1c7e11edad694279b3ef232cafa98c" translate="yes" xml:space="preserve">
          <source>Example preflight request</source>
          <target state="translated">飞行前请求示例</target>
        </trans-unit>
        <trans-unit id="1937f18faac9b560d6b0ad0c27d8e5021d3c2ec8" translate="yes" xml:space="preserve">
          <source>Example requests</source>
          <target state="translated">请求示例</target>
        </trans-unit>
        <trans-unit id="101e766cdf474de8672fa38603435f2c2f88941b" translate="yes" xml:space="preserve">
          <source>Example response</source>
          <target state="translated">答复示例</target>
        </trans-unit>
        <trans-unit id="9e9047fddfc8910797ad5dcc2be127acbfe08b7f" translate="yes" xml:space="preserve">
          <source>Example responses</source>
          <target state="translated">答复示例</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1391352a916b067bd98f31a68d100a8e123a5170" translate="yes" xml:space="preserve">
          <source>Example: Disable unsafe inline/eval, only allow loading of resources (images, fonts, scripts, etc.) over https:</source>
          <target state="translated">例如 禁用不安全的inline/eval,只允许通过https加载资源(图片、字体、脚本等)。</target>
        </trans-unit>
        <trans-unit id="c7fd2423984ee2e46f44f28ab3c25a81d90c3fd1" translate="yes" xml:space="preserve">
          <source>Example: Do not implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179aebe7be456d632b5d789d99331eede78b73e3" translate="yes" xml:space="preserve">
          <source>Example: Don't implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="translated">例子。先不要执行上述政策,而只需报告会发生的违规行为。</target>
        </trans-unit>
        <trans-unit id="6a1a9b351cb6e527d7405905cebedc49fbc528bb" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over HTTPS and to disable plugins:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17700dcd76dcab4611e46cba8a84a5260c2c790" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over https and disable plugins:</source>
          <target state="translated">例子 现有的网站,使用了太多的内联代码,无法修复,但又想保证资源只通过https加载,并禁用插件。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd077131fc10d919fcb4af0bc52b5d5dc3bff60d" translate="yes" xml:space="preserve">
          <source>Examples of Access Control in Action</source>
          <target state="translated">操作中的访问控制实例</target>
        </trans-unit>
        <trans-unit id="42b05d16ad1706c69b98dcd1d0beab7d996df8be" translate="yes" xml:space="preserve">
          <source>Examples of access control scenarios</source>
          <target state="translated">出入控制方案的例子</target>
        </trans-unit>
        <trans-unit id="8b6959ab8197d951dfd31c9bfb60d608f8853eea" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above.&lt;/a&gt;</source>
          <target state="translated">可以在&lt;a href=&quot;#Preflighted_requests&quot;&gt;上面找到&lt;/a&gt;这种用法的示例。</target>
        </trans-unit>
        <trans-unit id="65a7ed9127c8003c7810083e7bbc1569d8b66810" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;#Preflighted_requests&quot;&gt;上面找到&lt;/a&gt;这种用法的示例。</target>
        </trans-unit>
        <trans-unit id="47abb8e5ca6a2e13e7aa85756a29b3a05a3d8d7b" translate="yes" xml:space="preserve">
          <source>Examples of what you can do with Feature Policy:</source>
          <target state="translated">使用功能策略可以做什么的例子。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="57e9b7197782a4e7584bbc9820ab7355aa88a3d3" translate="yes" xml:space="preserve">
          <source>Examples: Common use cases</source>
          <target state="translated">实例。共同使用案例</target>
        </trans-unit>
        <trans-unit id="997886ce9b39820b9d7574fbb168082bb6c4cfb9" translate="yes" xml:space="preserve">
          <source>Except for the standard hop-by-hop headers (&lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;), any hop-by-hop headers used by the message must be listed in the &lt;code&gt;Connection&lt;/code&gt; header, so that the first proxy knows it has to consume them and not forward them further. Standard hop-by-hop headers can be listed too (it is often the case of &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, but this is not mandatory).</source>
          <target state="translated">除了标准的逐跳标头（&lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;）之外，还必须列出消息使用的任何逐跳标头在 &lt;code&gt;Connection&lt;/code&gt; 标头中，以便第一个代理知道它必须使用它们并且不再进一步转发它们。也可以列出标准的逐跳标头（通常是&lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;的情况，但这不是强制性的）。</target>
        </trans-unit>
        <trans-unit id="7233a11fc2426584ed01a173a4d930d34926020b" translate="yes" xml:space="preserve">
          <source>Except when excluded below, a recipient cache or origin server MUST
   evaluate received request preconditions after it has successfully
   performed its normal request checks and just before it would perform
   the action associated with the request method.  A server MUST ignore
   all received preconditions if its response to the same request
   without those conditions would have been a status code other than a
   2xx (Successful) or 412 (Precondition Failed).  In other words,
   redirects and failures take precedence over the evaluation of
   preconditions in conditional requests. 

   A server that is not the origin server for the target resource and
   cannot act as a cache for requests on the target resource MUST NOT
   evaluate the conditional request header fields defined by this
   specification, and it MUST forward them if the request is forwarded,
   since the generating client intends that they be evaluated by a
   server that can provide a current representation.  Likewise, a server
   MUST ignore the conditional request header fields defined by this
   specification when received with a request method that does not
   involve the selection or modification of a selected representation,
   such as CONNECT, OPTIONS, or TRACE.

   Conditional request header fields that are defined by extensions to
   HTTP might place conditions on all recipients, on the state of the
   target resource in general, or on a group of resources.  For
   instance, the &quot;If&quot; header field in WebDAV can make a request
   conditional on various aspects of multiple resources, such as locks,
   if the recipient understands and implements that field (&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918],
   Section&amp;nbsp;10.4&lt;/a&gt;).

   Although conditional request header fields are defined as being
   usable with the HEAD method (to keep HEAD's semantics consistent with
   those of GET), there is no point in sending a conditional HEAD
   because a successful response is around the same size as a 304 (Not
   Modified) response and more useful than a 412 (Precondition Failed)
   response.</source>
          <target state="translated">除非在下面进行了排除，否则接收者缓存或原始服务器必须在成功执行其正常请求检查之后以及即将执行与请求方法关联的操作之前，评估接收到的请求前提条件。如果服务器对同一请求的响应没有这些条件，则它必须忽略所有接收到的条件，而不是2xx（成功）或412（条件失败）状态代码。换句话说，重定向和失败优先于条件请求中前提条件的评估。不是目标资源的原始服务器且不能充当目标资源上的请求的缓存的服务器不得评估本规范定义的条件请求标头字段，并且如果请求已转发，则必须转发它们，因为生成客户端打算由可以提供当前表示的服务器对它们进行评估。同样，当服务器使用不涉及选定表示形式的选择或修改的请求方法（例如CONNECT，OPTIONS或TRACE）接收时，服务器务必忽略此规范定义的条件请求标头字段。由HTTP扩展定义的条件请求标头字段可能会在所有收件人，通常在目标资源的状态或一组资源上放置条件。例如，如果收件人理解并实现了该字段，则WebDAV中的&amp;ldquo; If&amp;rdquo;标头字段可以根据多种资源的各个方面（例如锁）提出请求，如果收件人理解并实现了该字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918]，第10.4节&lt;/a&gt;）。尽管将条件请求标头字段定义为可与HEAD方法一起使用（以使HEAD的语义与GET的语义保持一致），但是发送条件HEAD毫无意义，因为成功的响应与304大小相同（未修改） ）响应，并且比412（前提条件失败）响应更有用。</target>
        </trans-unit>
        <trans-unit id="25c9949f0e8e682737f53bb3d3d209c13c6e1d5b" translate="yes" xml:space="preserve">
          <source>Executable script is only allowed from userscripts.example.com.</source>
          <target state="translated">可执行脚本只允许从userscripts.example.com。</target>
        </trans-unit>
        <trans-unit id="2d47895b1210b1ebd4fa933059d36aed26cda284" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely.  HTTP does not provide a mechanism for the
   origin server to direct clients to discard these cached credentials,
   since the protocol has no awareness of how credentials are obtained 

   or managed by the user agent.  The mechanisms for expiring or
   revoking credentials can be specified as part of an authentication
   scheme definition.

   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

   o  Clients that have been idle for an extended period, following
      which the server might wish to cause the client to re-prompt the
      user for credentials.

   o  Applications that include a session termination indication (such
      as a &quot;logout&quot; or &quot;commit&quot; button on a page) after which the server
      side of the application &quot;knows&quot; that there is no further reason
      for the client to retain the credentials.

   User agents that cache credentials are encouraged to provide a
   readily accessible mechanism for discarding cached credentials under
   user control.</source>
          <target state="translated">现有的HTTP客户端和用户代理通常会无限期地保留认证信息。HTTP没有提供一种机制,让源服务器引导客户丢弃这些缓存的凭证,因为协议没有意识到用户代理是如何获得或管理凭证的。过期或撤销凭证的机制可以作为认证方案定义的一部分来指定。凭证缓存可能会干扰应用程序的安全模型的情况包括但不限于:o 长时间闲置的客户端,之后服务器可能希望导致客户端重新提示用户获取凭证。 o 包含会话终止指示的应用程序(如页面上的 &quot;注销 &quot;或 &quot;提交 &quot;按钮),之后应用程序的服务器端 &quot;知道 &quot;客户端没有进一步保留凭证的理由。鼓励缓存凭证的用户代理提供一个容易访问的机制,以便在用户控制下丢弃缓存的凭证。</target>
        </trans-unit>
        <trans-unit id="6ccac52b5d4274914636579bf1636b1d5fa966cc" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely. HTTP/1.1. does not provide a method for a
   server to direct clients to discard these cached credentials. This is
   a significant defect that requires further extensions to HTTP.
   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

      - Clients which have been idle for an extended period following
        which the server might wish to cause the client to reprompt the
        user for credentials.

      - Applications which include a session termination indication
        (such as a `logout' or `commit' button on a page) after which
        the server side of the application `knows' that there is no
        further reason for the client to retain the credentials.

   This is currently under separate study. There are a number of work-
   arounds to parts of this problem, and we encourage the use of
   password protection in screen savers, idle time-outs, and other
   methods which mitigate the security problems inherent in this
   problem. In particular, user agents which cache credentials are
   encouraged to provide a readily accessible mechanism for discarding
   cached credentials under user control.</source>
          <target state="translated">现有的HTTP客户端和用户代理通常会无限期地保留认证信息。HTTP/1.1.没有提供一种方法让服务器引导客户端丢弃这些缓存的凭证。这是一个重大的缺陷,需要进一步扩展HTTP。凭证缓存会干扰应用程序的安全模型的情况包括但不限于。-客户端在长时间闲置后,服务器可能希望让客户端重新提示用户输入凭证。-应用程序包括一个会话终止指示(如页面上的 &quot;登出 &quot;或 &quot;提交 &quot;按钮),之后应用程序的服务器端 &quot;知道 &quot;客户机没有进一步的理由保留凭证。这一点目前正在单独研究中。对于这个问题的一部分,有许多变通的办法,我们鼓励在屏幕保护程序中使用密码保护,空闲超时,以及其他可以减轻这个问题中固有的安全问题的方法。特别是,我们鼓励缓存凭证的用户代理提供一个容易访问的机制,以便在用户控制下丢弃缓存的凭证。</target>
        </trans-unit>
        <trans-unit id="a57a461722611e40b9d47ce41e5966ee9c0e2bfc" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a76f4ceddd2c24dfba52fcd6415b4a5d7627655" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site. A common case is when your site resides under the &lt;code&gt;www.example.com&lt;/code&gt; domain and accessing your pages from &lt;code&gt;example.com&lt;/code&gt; should be possible, too. Redirections for &lt;code&gt;example.com&lt;/code&gt; pages to &lt;code&gt;www.example.com&lt;/code&gt; are set up in this case. You might also provide commonly used synonym names or frequent typos of your domain names.</source>
          <target state="translated">扩大您的网站范围。常见的情况是您的网站位于 &lt;code&gt;www.example.com&lt;/code&gt; 域下，并且也可以从 &lt;code&gt;example.com&lt;/code&gt; 访问您的页面。在这种情况下，将 &lt;code&gt;example.com&lt;/code&gt; 页面重定向到 &lt;code&gt;www.example.com&lt;/code&gt; 。您可能还会提供常用的同义词名称或域名的常见错字。</target>
        </trans-unit>
        <trans-unit id="58fc1be971a32518b08bb4967f47c3e29fc379b9" translate="yes" xml:space="preserve">
          <source>Expect</source>
          <target state="translated">Expect</target>
        </trans-unit>
        <trans-unit id="994027919b14e63b028676f8e18f24f8c3412b5f" translate="yes" xml:space="preserve">
          <source>Expect (RFC 2616)</source>
          <target state="translated">期待(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="53f1bb33df8415879d9607269fadc4b08f7884fc" translate="yes" xml:space="preserve">
          <source>Expect (RFC 7231)</source>
          <target state="translated">期待(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="dac7eb9f8e739ef71916b8aa6eabe504d21db9ae" translate="yes" xml:space="preserve">
          <source>Expect-CT</source>
          <target state="translated">Expect-CT</target>
        </trans-unit>
        <trans-unit id="1782a86fff7281c9294c0d3eefa4ab6846695cc2" translate="yes" xml:space="preserve">
          <source>Expect-CT Extension for HTTP</source>
          <target state="translated">HTTP的Expect-CT扩展</target>
        </trans-unit>
        <trans-unit id="79322ef6edc1926ecbca88fd7e24b3ff46c3ac45" translate="yes" xml:space="preserve">
          <source>Experimental spec</source>
          <target state="translated">实验规格</target>
        </trans-unit>
        <trans-unit id="549fb9eb005687c11bca9c3462372257a7683df5" translate="yes" xml:space="preserve">
          <source>Experiments are in progress to design a better transport protocol more suited to HTTP. For example, Google is experimenting with &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt; which builds on UDP to provide a more reliable and efficient transport protocol.</source>
          <target state="translated">正在进行实验，以设计更适合HTTP的更好的传输协议。例如，谷歌正在试验基于UDP的&lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt;，以提供更可靠和有效的传输协议。</target>
        </trans-unit>
        <trans-unit id="1c82119c31678afc6233c719096414eef0fb22b6" translate="yes" xml:space="preserve">
          <source>Expiration</source>
          <target state="translated">Expiration</target>
        </trans-unit>
        <trans-unit id="a99be3da0c9da2f3c64500b5ef8a8e48f503d127" translate="yes" xml:space="preserve">
          <source>Expires</source>
          <target state="translated">Expires</target>
        </trans-unit>
        <trans-unit id="cc75acb2b0ea3b677a15b0b6b818f64332802b2f" translate="yes" xml:space="preserve">
          <source>Expires (RFC 2616)</source>
          <target state="translated">过期(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="668c321a385a7ec5effd27dc4959016e1b54db8c" translate="yes" xml:space="preserve">
          <source>Expires (RFC 7234)</source>
          <target state="translated">过期(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="798d2fe08024167fc3592a3e1fdd8f0482db3150" translate="yes" xml:space="preserve">
          <source>Expires=&amp;lt;date&amp;gt; Optional</source>
          <target state="translated">Expires = &amp;lt;日期&amp;gt;可选</target>
        </trans-unit>
        <trans-unit id="440f936591556c4ab22d4ca93b07905600bf80fc" translate="yes" xml:space="preserve">
          <source>Explains how a client and a server can negotiate a specific HTTP version and eventually upgrade the protocol version used.</source>
          <target state="translated">解释了客户端和服务器如何协商一个特定的HTTP版本,并最终升级使用的协议版本。</target>
        </trans-unit>
        <trans-unit id="4c04fa2d870e27906bb18e89eabbb66f7bf88805" translate="yes" xml:space="preserve">
          <source>Expresses the user's tracking preference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a639e6f336caa1c98ebcd19c35befb40a19c9aca" translate="yes" xml:space="preserve">
          <source>Extending a database through an append operation.</source>
          <target state="translated">通过append操作扩展数据库。</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="a5be9d96e47f86f30faca0b0c0d8cd92b6b591df" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives</source>
          <target state="translated">扩展 &lt;code&gt;Cache-Control&lt;/code&gt; 指令</target>
        </trans-unit>
        <trans-unit id="fef92b354ef2777bc846bf834005b52b7dd4a00e" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Be sure to check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support.</source>
          <target state="translated">扩展 &lt;code&gt;Cache-Control&lt;/code&gt; 指令不是核心HTTP缓存标准文档的一部分。确保检查&lt;a href=&quot;#Browser_compatibility&quot;&gt;兼容性表&lt;/a&gt;以获取支持。</target>
        </trans-unit>
        <trans-unit id="790215898ba9547c6ca3b5fc75be3806f3e82b33" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support; user-agents that don't recognize them should ignore them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b9d10d572cffd131c6e10d79fd13870c1b14e9" translate="yes" xml:space="preserve">
          <source>Extension Cache-Control directives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9618205d36acb2ec9a802339b387cf754ed53de" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;) unless it's overwritten via an HTTP header that is set for a CSS stylesheet specifically.</source>
          <target state="translated">外部CSS样式表使用默认策略（ &lt;code&gt;no-referrer-when-downgrade&lt;/code&gt; ），除非通过专门为CSS样式表设置的HTTP标头覆盖它。</target>
        </trans-unit>
        <trans-unit id="1f757e53076199141ccd603fa5607cc746399b36" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;), unless it's overwritten via a &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header on the CSS stylesheet&amp;rsquo;s response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b4519004830e628fefbfc612f64b245ab37406" translate="yes" xml:space="preserve">
          <source>Extracting the Base64 encoded public key information</source>
          <target state="translated">提取Base64编码的公钥信息。</target>
        </trans-unit>
        <trans-unit id="82ca99fbea5a5ea4d775520c3099a29adbd2bbf4" translate="yes" xml:space="preserve">
          <source>F.1.  Changes for Both Client and Server Implementations</source>
          <target state="translated">F.1.客户端和服务器实施的变化</target>
        </trans-unit>
        <trans-unit id="e3444e81a7c395eacc8d894f9505a6b6ec9ed898" translate="yes" xml:space="preserve">
          <source>F.2.  Changes for Server Implementations</source>
          <target state="translated">F.2.服务器实施的变化</target>
        </trans-unit>
        <trans-unit id="8d6a58de84dd929ed244644a2cc93d7d20768fb2" translate="yes" xml:space="preserve">
          <source>F.3.  Other Changes</source>
          <target state="translated">F.3.其他变化</target>
        </trans-unit>
        <trans-unit id="22da6d41863afa4c87a7a2a96539883a5b235c05" translate="yes" xml:space="preserve">
          <source>FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.</source>
          <target state="translated">在顶层,FTP仍然是可以接受的(比如直接输入浏览器的URL栏,或者链接的目标),尽管一些浏览器可能会将加载FTP内容的工作委托给另一个应用程序。</target>
        </trans-unit>
        <trans-unit id="92fe61c3f61162d432bcc18c5c3c2721f89c4867" translate="yes" xml:space="preserve">
          <source>Faced with this error, browsers usually either abort the operation (for example, a download will be considered as non-resumable) or ask for the whole document again.</source>
          <target state="translated">面对这个错误,浏览器通常会中止操作(例如,下载会被认为是不可恢复的),或者再次要求提供整个文档。</target>
        </trans-unit>
        <trans-unit id="b4a100ebc4c1820c605bd96d9dd279ff888640e2" translate="yes" xml:space="preserve">
          <source>Fallback</source>
          <target state="translated">Fallback</target>
        </trans-unit>
        <trans-unit id="eba72e67a897b4f1538c1c559bf91bf79d26f8df" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;fullscreen&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc.希望对所有跨域子帧禁用 &lt;code&gt;fullscreen&lt;/code&gt; 显示，但特定的&amp;lt;iframe&amp;gt;除外。为此，可以提供以下HTTP响应标头以定义功能部件策略：</target>
        </trans-unit>
        <trans-unit id="30c4b13be3aa4b1468bedb0d443187e381399c80" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;geolocation&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc.希望对除特定&amp;lt;iframe&amp;gt;以外的所有跨域子框架禁用 &lt;code&gt;geolocation&lt;/code&gt; 。为此，可以提供以下HTTP响应标头以定义功能部件策略：</target>
        </trans-unit>
        <trans-unit id="2b02ecda0275dbc6a16322d0aa2715bb1b0c7f16" translate="yes" xml:space="preserve">
          <source>Feature Policy</source>
          <target state="translated">特征政策</target>
        </trans-unit>
        <trans-unit id="116ce4ea97fc76a7402a5b9f210f36fadfbb4c2b" translate="yes" xml:space="preserve">
          <source>Feature Policy allows web developers to selectively enable, disable, and modify the behavior of certain features and APIs in the browser. It is similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;Content Security Policy&lt;/a&gt; but controls features instead of security behavior.</source>
          <target state="translated">功能策略允许Web开发人员有选择地启用，禁用和修改浏览器中某些功能和API的行为。它类似于&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;内容安全策略&amp;rdquo;，&lt;/a&gt;但控制功能而不是安全行为。</target>
        </trans-unit>
        <trans-unit id="c53bb4cebead9ce42d5d5eff5bdc667fd91758b5" translate="yes" xml:space="preserve">
          <source>Feature Policy allows you to control which origins can use which features, both in the top-level page and in embedded frames. Essentially, you write a policy, which is an allowed list of origins for each feature. For every feature controlled by Feature Policy, the feature is only enabled in the current document or frame if its origin matches the allowed list of origins.</source>
          <target state="translated">功能策略允许您控制哪些起源可以使用哪些功能,包括在顶层页面和嵌入式框架中。本质上,您编写了一个策略,它是每个特性的允许起源列表。对于每个由特性策略控制的特性,只有当其起源符合允许的起源列表时,该特性才会在当前文档或框架中启用。</target>
        </trans-unit>
        <trans-unit id="23cd7a78a2dc77e19ba57e025deceab5b480ee5d" translate="yes" xml:space="preserve">
          <source>Feature Policy provides a mechanism to explicitly declare what functionality is used (or not used), throughout your website. This allows you to lock in best practices, even as the codebase evolves over time &amp;mdash; as well as to more safely compose third-party content &amp;mdash; by limiting which features are available.</source>
          <target state="translated">功能策略提供了一种机制，用于在整个网站中明确声明已使用（或未使用）的功能。通过限制可用功能，即使代码库随时间发展，您也可以锁定最佳实践，并更安全地编写第三方内容。</target>
        </trans-unit>
        <trans-unit id="92799190c0f4fe5ecaee2952ecf286aa6cce9ac3" translate="yes" xml:space="preserve">
          <source>Feature Policy provides two ways to specify policies to control features:</source>
          <target state="translated">特性策略提供了两种方法来指定策略来控制特性。</target>
        </trans-unit>
        <trans-unit id="0847c40e72979da8866a8e8b3f1f0cc411a2dad3" translate="yes" xml:space="preserve">
          <source>Feature Policy: Using Feature Policy</source>
          <target state="translated">功能策略。使用特性策略</target>
        </trans-unit>
        <trans-unit id="fcae4ecf5da500dd00bf9572a09b7e678697d109" translate="yes" xml:space="preserve">
          <source>Feature Policy&lt;br/&gt;&lt;small&gt;The definition of 'Feature-Policy' in that specification.&lt;/small&gt;</source>
          <target state="translated">功能策略&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;功能策略&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="294d4d9a4eaac5449bf61242940545b797efd4f7" translate="yes" xml:space="preserve">
          <source>Feature detection</source>
          <target state="translated">特征检测</target>
        </trans-unit>
        <trans-unit id="6680a4d48c2812c07a01fb3632993e80d45a2200" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. In those rare cases where behavior differs between browsers, instead of checking the user agent string, you should instead implement a test to detect how the browser implements the API and determine how to use it from that. An example of feature detection is as follows. In 2017, Chrome &lt;a href=&quot;https://www.chromestatus.com/feature/5668726032564224&quot;&gt;unflagged experimental lookbehind support in regular expressions&lt;/a&gt;, but no other browser supported it. So, you might have thought to do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfcbb2b685a05f07291909f36952c99a4e2fe7b" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. There are never any rare cases where you should use the user agent string, such as to detect a browser which implements the behavior of an API differently. Rather, in such rare cases, you should implement a test to detect how the browser implements the API and then determine when and how to use it instead. A good current example of feature detection is as follows. Recently, Chrome has added experimental look behind support to regular expressions, but no other browser currently supports this. So, you might incorrectly assume you should do this:</source>
          <target state="translated">功能检测是指你不试图找出哪个浏览器在渲染你的页面,而是检查你需要的特定功能是否可用。如果没有,你就使用后备功能。从来没有任何罕见的情况下,你应该使用用户代理字符串,例如检测一个以不同方式实现API行为的浏览器。相反,在这种罕见的情况下,你应该实现一个测试来检测浏览器如何实现API,然后确定何时以及如何使用它来代替。目前一个很好的功能检测的例子如下。最近,Chrome浏览器对正则表达式增加了实验性的看后支持,但目前没有其他浏览器支持这个功能。所以,你可能会错误地认为你应该这样做。</target>
        </trans-unit>
        <trans-unit id="95c726252d0d002492bfb760d3686808998bb8df" translate="yes" xml:space="preserve">
          <source>Feature policies on www.chromestatus.com</source>
          <target state="translated">专题政策:www.chromestatus.com</target>
        </trans-unit>
        <trans-unit id="d7fb77650eb9c4f73d9377f06679ca2cd28df471" translate="yes" xml:space="preserve">
          <source>Feature-Policy</source>
          <target state="translated">Feature-Policy</target>
        </trans-unit>
        <trans-unit id="6731078bdcb61e26085f7dc9985790c18e8a240e" translate="yes" xml:space="preserve">
          <source>Feature-Policy Tester (Chrome Developer Tools extension)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ee4ffa583da7bdf223c2ffed9d85ab239371e0" translate="yes" xml:space="preserve">
          <source>Feature-Policy: autoplay</source>
          <target state="translated">特征-政策:自动播放</target>
        </trans-unit>
        <trans-unit id="31f9ca897eb5c9f44de8842f2516fb02a54faa2e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: camera</source>
          <target state="translated">特征-政策:相机</target>
        </trans-unit>
        <trans-unit id="bf16c6ee691c8e9ca8e2dbe87a3f347fcb570cc7" translate="yes" xml:space="preserve">
          <source>Feature-Policy: document-domain</source>
          <target state="translated">特征-政策:文档-域</target>
        </trans-unit>
        <trans-unit id="fe796e681d5c63dcc531be776ac43685da71889f" translate="yes" xml:space="preserve">
          <source>Feature-Policy: encrypted-media</source>
          <target state="translated">特征-政策:加密媒体</target>
        </trans-unit>
        <trans-unit id="37767aecde5e9787909f7866d3735071b1ccad3d" translate="yes" xml:space="preserve">
          <source>Feature-Policy: fullscreen</source>
          <target state="translated">特征-政策:全屏</target>
        </trans-unit>
        <trans-unit id="9488de5430b2b3fc9fd436b5e2d0c394e296837e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: geolocation</source>
          <target state="translated">特征-政策:地理位置</target>
        </trans-unit>
        <trans-unit id="2c61ebc183f28f44ab1b2b148b5d57942442df26" translate="yes" xml:space="preserve">
          <source>Feature-Policy: microphone</source>
          <target state="translated">特征-政策:麦克风</target>
        </trans-unit>
        <trans-unit id="596057da4c0cdcb20ea8b614fd43950671e7a493" translate="yes" xml:space="preserve">
          <source>Feature-Policy: midi</source>
          <target state="translated">特点-政策:midi</target>
        </trans-unit>
        <trans-unit id="6ae2a5e94ce91f2de51637745788fb01a6ad53dc" translate="yes" xml:space="preserve">
          <source>Feature-Policy: payment</source>
          <target state="translated">特征-政策:付款</target>
        </trans-unit>
        <trans-unit id="6392e975cf7e0435d78f4e6d61f8527537c58cfd" translate="yes" xml:space="preserve">
          <source>Feature-Policy: vr</source>
          <target state="translated">特征-政策:VR</target>
        </trans-unit>
        <trans-unit id="088204f1105dd468d38881f2fd12a0b4aa4c7aab" translate="yes" xml:space="preserve">
          <source>Feature-Policy:fullscreen</source>
          <target state="translated">Feature-Policy:fullscreen</target>
        </trans-unit>
        <trans-unit id="d710338755da08a83c18e218bac6cbaa1e2a4fd1" translate="yes" xml:space="preserve">
          <source>Feature-Policy:geolocation</source>
          <target state="translated">Feature-Policy:geolocation</target>
        </trans-unit>
        <trans-unit id="9d7e13756d87f97651352edd83fe4becad54f376" translate="yes" xml:space="preserve">
          <source>Feature-Policy:microphone</source>
          <target state="translated">Feature-Policy:microphone</target>
        </trans-unit>
        <trans-unit id="e7e6e3dcff550300eec2d95910564a70e893cba4" translate="yes" xml:space="preserve">
          <source>Features are each defined to have a default allowlist, which is one of:</source>
          <target state="translated">每个功能都被定义为有一个默认的允许列表,它是其中之一。</target>
        </trans-unit>
        <trans-unit id="73987c80f34346a88ab75127eefbe27a82362092" translate="yes" xml:space="preserve">
          <source>Features restricted to secure contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e28fef517be6e0fc21d5716c7662e4801ad299" translate="yes" xml:space="preserve">
          <source>Fetch API</source>
          <target state="translated">获取API</target>
        </trans-unit>
        <trans-unit id="0c16479e5749d322208146b5b5f7624d72ebd140" translate="yes" xml:space="preserve">
          <source>Fetch directive</source>
          <target state="translated">获取指令</target>
        </trans-unit>
        <trans-unit id="e53b45c9af742d503a22c70314dddb7873195091" translate="yes" xml:space="preserve">
          <source>Fetch directives</source>
          <target state="translated">获取指令</target>
        </trans-unit>
        <trans-unit id="7a5dfae050f11fd6283650bfb92f289b86d2ac98" translate="yes" xml:space="preserve">
          <source>Fetch directives control locations from which certain resource types may be loaded.</source>
          <target state="translated">Fetch指令控制某些资源类型可能被加载的位置。</target>
        </trans-unit>
        <trans-unit id="6117c09509a0de56a9b4f6836fda41153fe625f3" translate="yes" xml:space="preserve">
          <source>Fetch directives control the locations from which certain resource types may be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdd60e438b0416f34aeb50bf03aae713ddb1bda" translate="yes" xml:space="preserve">
          <source>Fetch metadata request headers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916f35ff813a6743346055125d97c6cbba1aaedc" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Credentials' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;访问控制权限证书&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0678866e50722f12e36a5dc2fec0748a692fe2ca" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;访问控制允许标题&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2cf87afd008c8c6a087d3cc6f98ba0277b9043b7" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Methods' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;访问控制允许方法&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e4f7ed2d1134249b47bfd1f0ca53f80515e1563f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Origin' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;访问控制允许来源&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b6d65973f43b54eb3f3ef47447a2bae6cff6fe97" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Expose-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo; Access-Control-Expose-Header&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8089c31c9e26d8f2db19edbf9e44a130bc5eddd3" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Max-Age' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo; Access-Control-Max-Age&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9397823a091bbc18047f30f651f6476462ab4fa8" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;访问控制请求头&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="82f6f83e1801614fce5a5524369fe1de50f85da5" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Method' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;访问控制请求方法&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7e1eb076c3812c097fec7c1be9899bd085c5fbf1" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'CORS' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo; CORS&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fe63ee35db7f3102d616e69a27e101cdcc18b63a" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Origin header' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;原始标头&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1446331a1b71bc30148510fc4d99d0e0ec91086f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'X-Content-Type-Options definition' in that specification.&lt;/small&gt;</source>
          <target state="translated">获取&lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo; X-Content-Type-Options定义&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="918815e8513a9d78892a5b82f5db40dddb1a7f3b" translate="yes" xml:space="preserve">
          <source>Fetching the root page of developer.mozilla.org, i.e. &lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt;, and telling the server that the user-agent would prefer the page in French, if possible:</source>
          <target state="translated">获取developer.mozilla.org的根页面（即&lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/）&lt;/a&gt;，并告诉服务器用户代理希望法语页面，如果可能的话：</target>
        </trans-unit>
        <trans-unit id="3253d0b90d63fd1a7b31fd3494e21aaa52e7e42e" translate="yes" xml:space="preserve">
          <source>File Transfer Protocol</source>
          <target state="translated">文件传输协议</target>
        </trans-unit>
        <trans-unit id="5d438ceeae874a432c5e55fd5791a60c59eb0d8f" translate="yes" xml:space="preserve">
          <source>File extension(s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361a82465491c9161713f597566a3f42e5734e1b" translate="yes" xml:space="preserve">
          <source>File format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7b57a8f84d5b2b2d5abb274bb773348457c9ea" translate="yes" xml:space="preserve">
          <source>File format compression</source>
          <target state="translated">文件格式压缩</target>
        </trans-unit>
        <trans-unit id="57fa91ed93807da407d7147d7099ef87d3eef96c" translate="yes" xml:space="preserve">
          <source>Filename suffixes are sometimes used, especially on Microsoft Windows. Not all operating systems consider these suffixes meaningful (such as Linux and MacOS), and there is no guarantee they are correct.</source>
          <target state="translated">文件名后缀有时会被使用,特别是在Microsoft Windows上。并非所有的操作系统都认为这些后缀是有意义的(如Linux和MacOS),也不能保证它们是正确的。</target>
        </trans-unit>
        <trans-unit id="b8a4a48235c2528b57fabea0f16e59922544df82" translate="yes" xml:space="preserve">
          <source>Files whose MIME type is &lt;code&gt;image&lt;/code&gt; contain image data. The subtype specifies which specific image file format the data represents. Only a few image types are used commonly enough to be considered safe for use on web pages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1888d033ef09f73993a1ae6180b384a516770e4" translate="yes" xml:space="preserve">
          <source>Filtration based on &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, if any at all.</source>
          <target state="translated">基于&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; 的&lt;/a&gt;过滤（如果有的话）。</target>
        </trans-unit>
        <trans-unit id="02b7b1f402f1dad5cba5d5c6f4047891c00d3834" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; gives the value in seconds for how long the response to the preflight request can be cached for without sending another preflight request. In this case, 86400 seconds is 24 hours. Note that each browser has a &lt;a href=&quot;headers/access-control-max-age&quot;&gt;maximum internal value&lt;/a&gt; that takes precedence when the &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; is greater.</source>
          <target state="translated">最后，&lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt;以秒为单位给出一个值，该值表示对预检请求的响应可以缓存多长时间而无需发送另一个预检请求。在这种情况下，86400秒是24小时。请注意，每个浏览器都有一个&lt;a href=&quot;headers/access-control-max-age&quot;&gt;最大的内部值&lt;/a&gt;，当 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 更大时，该内部值优先。</target>
        </trans-unit>
        <trans-unit id="9c162123e6b08c6245b8c567094309cf3046a7d6" translate="yes" xml:space="preserve">
          <source>Finding insecure requests</source>
          <target state="translated">发现不安全的请求</target>
        </trans-unit>
        <trans-unit id="b4ee6522335b033249255b4cc1d572993282aafb" translate="yes" xml:space="preserve">
          <source>Firefox</source>
          <target state="translated">Firefox</target>
        </trans-unit>
        <trans-unit id="3d69145991747b3ff98ca2ac235bf9a2b6c0b22b" translate="yes" xml:space="preserve">
          <source>Firefox 3.6 and later</source>
          <target state="translated">火狐3.6及以后</target>
        </trans-unit>
        <trans-unit id="9a053be79e5c0ac7481cbdffd78827759a3ed9f5" translate="yes" xml:space="preserve">
          <source>Firefox 4</source>
          <target state="translated">火狐4</target>
        </trans-unit>
        <trans-unit id="e75eacacb146d953aa91455b2699bff5088fb836" translate="yes" xml:space="preserve">
          <source>Firefox 5 handles the &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP response header more effectively if both the &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; parameters are provided; it looks through all provided names, using the &lt;code&gt;filename*&lt;/code&gt; parameter if one is available, even if a &lt;code&gt;filename&lt;/code&gt; parameter is included first. Previously, the first matching parameter would be used, thereby preventing a more appropriate name from being used. See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;bug 588781&lt;/a&gt;.</source>
          <target state="translated">如果同时提供 &lt;code&gt;filename&lt;/code&gt; 和 &lt;code&gt;filename*&lt;/code&gt; 参数，则Firefox 5可以更有效地处理 &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP响应标头。它会使用 &lt;code&gt;filename*&lt;/code&gt; 参数（如果最先包含 &lt;code&gt;filename&lt;/code&gt; 参数的情况）使用所有提供的名称进行查找。以前，将使用第一个匹配参数，从而防止使用更合适的名称。请参阅&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;错误588781&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4443afafb8462a4928ffbe0151cd70875fd784c9" translate="yes" xml:space="preserve">
          <source>Firefox 72 enables &lt;code&gt;X-Content-Type-Options: nosniff&lt;/code&gt; for top-level documents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98488d27ab42c5d6a59371f548c195bffbe9d824" translate="yes" xml:space="preserve">
          <source>Firefox 82 (and later) and Chrome prioritize the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&amp;lt;a&amp;gt; element's&lt;/a&gt;&lt;code&gt;download&lt;/code&gt; attribute over the &lt;code&gt;Content-Disposition&lt;/code&gt;&lt;code&gt;inline&lt;/code&gt; parameter (for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin URLs&lt;/a&gt;). Earlier Firefox versions prioritize the header and will display the content inline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389872f22235d2e890d3e24f0e0fb6d81e0c8a59" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds) and Chromium at &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10 minutes&lt;/a&gt; (600 seconds). Chromium also specifies a default value of 5 seconds.</source>
          <target state="translated">Firefox的&lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;上限为24小时&lt;/a&gt;（86400秒），而Chromium的上限为&lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10分钟&lt;/a&gt;（600秒）。铬还指定了5秒的默认值。</target>
        </trans-unit>
        <trans-unit id="90fb1b1a36a9c036151eeced597d613144d0f291" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1444ac74d1094f6f34b49da3ee9966b7b93f1731" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools</source>
          <target state="translated">火狐开发者工具</target>
        </trans-unit>
        <trans-unit id="f300fd41a795a419c45aee9c6cb726e738e71b7e" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools: using a source map</source>
          <target state="translated">火狐开发者工具:使用源码图</target>
        </trans-unit>
        <trans-unit id="e4b319de38dd3b5708092c79d821e3e2547bbfeb" translate="yes" xml:space="preserve">
          <source>Firefox OS</source>
          <target state="translated">火狐操作系统</target>
        </trans-unit>
        <trans-unit id="08b98a32baa6ee15d09f718291f659a3f7d5a387" translate="yes" xml:space="preserve">
          <source>Firefox OS devices identify themselves without any operating system indication; for example: &quot;Mozilla/5.0 (Mobile; rv:15.0) Gecko/15.0 Firefox/15.0&quot;. The web is the platform.</source>
          <target state="translated">火狐操作系统的设备在没有任何操作系统标识的情况下进行自我识别,例如:&quot;Mozilla/5.0 (Mobile;rv:15.0 Gecko/15.0 Firefox/15.0&quot;。&quot;Mozilla/5.0 (Mobile;rv:15.0)Gecko/15.0 Firefox/15.0&quot;。网络是平台。</target>
        </trans-unit>
        <trans-unit id="096d24033e6a963360da3b94208e68f8d97b00a8" translate="yes" xml:space="preserve">
          <source>Firefox OS has a four-digit version number:</source>
          <target state="translated">火狐操作系统有一个四位数的版本号。</target>
        </trans-unit>
        <trans-unit id="ee0b8d61fb018abae298ec4b7eb6bf2ea815cea8" translate="yes" xml:space="preserve">
          <source>Firefox OS version number</source>
          <target state="translated">火狐操作系统版本号</target>
        </trans-unit>
        <trans-unit id="0b43f7fedde8c737f31357ef6642b9b7dec844af" translate="yes" xml:space="preserve">
          <source>Firefox UA string</source>
          <target state="translated">火狐UA字符串</target>
        </trans-unit>
        <trans-unit id="cd5ecb0a55376afe3b1ad82fbe8b4cecc9e76924" translate="yes" xml:space="preserve">
          <source>Firefox Web Runtime</source>
          <target state="translated">火狐网络运行时</target>
        </trans-unit>
        <trans-unit id="0c516be8bc16e485b9c5dea3cac5637b2be7f8c3" translate="yes" xml:space="preserve">
          <source>Firefox and Chrome&lt;strong&gt; disable pin validation&lt;/strong&gt; for pinned hosts whose validated certificate chain terminates at a &lt;strong&gt;user-defined trust anchor&lt;/strong&gt; (rather than a built-in trust anchor). This means that for users who imported custom root certificates all pinning violations are ignored.</source>
          <target state="translated">Firefox和Chrome 对已验证证书链终止于&lt;strong&gt;用户定义的信任锚&lt;/strong&gt;（而不是内置信任锚）的固定主机&lt;strong&gt;禁用销钉验证&lt;/strong&gt;。这意味着对于导入自定义根证书的用户，将忽略所有固定冲突。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f46b1448185527825780f84cfe778a2558ec052f" translate="yes" xml:space="preserve">
          <source>Firefox currently only supports the &lt;code&gt;Large-Allocation&lt;/code&gt; header in our 32-bit Windows builds, as memory fragmentation is not an issue in 64-bit builds. If you are running a non-win32 version of Firefox, this error will appear. This check can be disabled with the &quot;dom.largeAllocation.</source>
          <target state="translated">Firefox当前在我们的32位Windows版本中仅支持 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头，因为在64位版本中内存碎片不是问题。如果您运行的是非Win32版本的Firefox，则会出现此错误。可以使用&amp;ldquo; dom.largeAllocation&amp;rdquo;禁用此检查。</target>
        </trans-unit>
        <trans-unit id="fd814d6c03ca30a65e6eae11a110b64dbd4091ec" translate="yes" xml:space="preserve">
          <source>Firefox earlier than 3.6</source>
          <target state="translated">早于3.6的Firefox</target>
        </trans-unit>
        <trans-unit id="35e08ebaf6a034e084ac621e4a8de400a08ba9e7" translate="yes" xml:space="preserve">
          <source>Firefox for Android</source>
          <target state="translated">安卓版火狐浏览器</target>
        </trans-unit>
        <trans-unit id="6b3b609703588318cf5eddb907cb036af5b8fa9f" translate="yes" xml:space="preserve">
          <source>Firefox for Echo Show</source>
          <target state="translated">火狐浏览器的回声显示</target>
        </trans-unit>
        <trans-unit id="70bde33b11b3ebf831139347906ee55c0954e773" translate="yes" xml:space="preserve">
          <source>Firefox for Fire TV</source>
          <target state="translated">Firefox for Fire TV</target>
        </trans-unit>
        <trans-unit id="aa1b6f07af81be5e73ca90848517f82656d9b533" translate="yes" xml:space="preserve">
          <source>Firefox for Maemo (Nokia N900)</source>
          <target state="translated">火狐Maemo(诺基亚N900)</target>
        </trans-unit>
        <trans-unit id="d796cd118178bed42189a33b56788596ce709a40" translate="yes" xml:space="preserve">
          <source>Firefox for iOS</source>
          <target state="translated">iOS版火狐浏览器</target>
        </trans-unit>
        <trans-unit id="4a1947cf48de07acf77d4542c741b3b264b1d589" translate="yes" xml:space="preserve">
          <source>Firefox for iOS user agent string</source>
          <target state="translated">Firefox for iOS用户代理字符串</target>
        </trans-unit>
        <trans-unit id="520f59d4c4564c36ce2dffd8248ed3f436481f50" translate="yes" xml:space="preserve">
          <source>Firefox for iOS uses the default Mobile Safari UA string, with an additional &lt;strong&gt;FxiOS/&amp;lt;version&amp;gt;&lt;/strong&gt; token, similar to how &lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome for iOS identifies itself&lt;/a&gt;.</source>
          <target state="translated">Firefox（iOS版）使用默认的Mobile Safari UA字符串以及一个额外的&lt;strong&gt;FxiOS / &amp;lt;version&amp;gt;&lt;/strong&gt;令牌，类似于&lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome for iOS自身的标识&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57d4690e6cf1e25d65d0fd2cf1024daa1be89df4" translate="yes" xml:space="preserve">
          <source>Firefox has detected that the server is redirecting the request for this address in a way that will never complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d9b72ae732fc5ec0d2b8c7b9205f083804989f" translate="yes" xml:space="preserve">
          <source>Firefox has moved to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;multiprocess architecture&lt;/a&gt;, and this architecture is required in order to support the &lt;code&gt;Large-Allocation&lt;/code&gt; header. Some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;legacy Addons&lt;/a&gt; can prevent Firefox from using this new, faster, multiprocess architecture. If you have one of these Addons installed, then we will continue to use the old single process architecuture for compatibility, and cannot handle the &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">Firefox已迁移到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;多&lt;/a&gt;进程体系结构，并且该体系结构是必需的，以便支持 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头。一些&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;旧版插件&lt;/a&gt;会阻止Firefox使用这种新的，更快的多进程体系结构。如果您安装了这些插件之一，那么为了兼容性，我们将继续使用旧的单进程体系结构，并且无法处理 &lt;code&gt;Large-Allocation&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="cea7ce89d775de0cacc4bf3ee3434d91b180561e" translate="yes" xml:space="preserve">
          <source>Firefox has not, and &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=528661&quot;&gt;will not implement &lt;code&gt;X-XSS-Protection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce4010ab4d918ae6e0eb7de27062f406a172591" translate="yes" xml:space="preserve">
          <source>Firefox once used &lt;code&gt;ISO-8859-1&lt;/code&gt;, but changed to &lt;code&gt;utf-8&lt;/code&gt; for parity with other browsers and to avoid potential problems as described in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;bug 1419658&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa353bc27c77608b28b6a494fb71634a8d1229" translate="yes" xml:space="preserve">
          <source>Firefox user agent string reference</source>
          <target state="translated">火狐用户代理字符串参考</target>
        </trans-unit>
        <trans-unit id="824138edb7e10e6cc870e036060b42fe43828628" translate="yes" xml:space="preserve">
          <source>Firefox's console displays messages in its console when requests fail due to CORS. Part of the error text is a &quot;reason&quot; message that provides added insight into what went wrong. The reason messages are listed below; click the message to open an article explaining the error in more detail and offering possible solutions.</source>
          <target state="translated">当由于CORS导致请求失败时,Firefox的控制台会在其控制台中显示消息。错误文本的一部分是 &quot;原因 &quot;消息,它提供了对出错原因的额外见解。下面列出了原因消息;单击消息打开一篇文章,更详细地解释错误并提供可能的解决方案。</target>
        </trans-unit>
        <trans-unit id="7d1c6e60d05a2c5211575867279c806da9425465" translate="yes" xml:space="preserve">
          <source>Firefox, Chrome and Safari do not support multiple origins in the Access-Control-Allow-Origin header.</source>
          <target state="translated">Firefox、Chrome和Safari不支持Access-Control-Allow-Origin头中的多个起源。</target>
        </trans-unit>
        <trans-unit id="be168c2fee1a2d9fa42cc62fef4298c4cbcefbf2" translate="yes" xml:space="preserve">
          <source>Firefox/xyz</source>
          <target state="translated">Firefox/xyz</target>
        </trans-unit>
        <trans-unit id="f614dfafdbd42e06d5c689e2cc52f2820578b824" translate="yes" xml:space="preserve">
          <source>Firefox: &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;bug 1309358&lt;/a&gt;</source>
          <target state="translated">Firefox：&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;错误1309358&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a0200dffc7bdc64d4a349f323b1653382469567" translate="yes" xml:space="preserve">
          <source>Fires a &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt;.</source>
          <target state="translated">触发 &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b748324a443374f003fb0c40ffc43547df0d368f" translate="yes" xml:space="preserve">
          <source>First you need to extract the public key information from your certificate or key file and encode them using Base64.</source>
          <target state="translated">首先,你需要从证书或密钥文件中提取公钥信息,并使用Base64进行编码。</target>
        </trans-unit>
        <trans-unit id="72a34e1cd654a785a78eeb2f1af6246aef47a923" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request that includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56777de18c704b8472efc7f29607549036e406b" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request which includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, such as:</source>
          <target state="translated">首先，要求。预检请求是一个&lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;请求，其中包括三个预检请求标头的某种组合：&lt;a href=&quot;access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;，例如：</target>
        </trans-unit>
        <trans-unit id="1856a70ba04296bbf62c2e423de0fbdcfb0f5adf" translate="yes" xml:space="preserve">
          <source>Flow of an HTTP session</source>
          <target state="translated">一个HTTP会话的流程</target>
        </trans-unit>
        <trans-unit id="bcbad51a46a03dbd80a644d3f941e3c1172162b3" translate="yes" xml:space="preserve">
          <source>Focus Version (Rendering Engine)</source>
          <target state="translated">焦点版(渲染引擎</target>
        </trans-unit>
        <trans-unit id="56c6a4ca5cb7ee3279f46162d43efe44a37848d9" translate="yes" xml:space="preserve">
          <source>Focus for Android</source>
          <target state="translated">Focus for Android</target>
        </trans-unit>
        <trans-unit id="9c96a14d8cf5e47753d46702539d3958d06bb67a" translate="yes" xml:space="preserve">
          <source>Focus for iOS</source>
          <target state="translated">iOS的焦点</target>
        </trans-unit>
        <trans-unit id="aa5bdfcda9154f616d3599ff8019fe359c3f4231" translate="yes" xml:space="preserve">
          <source>Followed by a second connection and request to fetch the image (followed by a response to that request):</source>
          <target state="translated">紧接着是第二个连接,并请求获取图像(紧接着是对该请求的响应)。</target>
        </trans-unit>
        <trans-unit id="453b3d513097bbb5dad0b729903f4324d053ad1f" translate="yes" xml:space="preserve">
          <source>Font/typeface data. Common examples include &lt;code&gt;font/woff&lt;/code&gt;, &lt;code&gt;font/ttf&lt;/code&gt;, and &lt;code&gt;font/otf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1d332ceb92dcde1fcd283f80c52096a5c624f8" translate="yes" xml:space="preserve">
          <source>Footnote 1</source>
          <target state="translated">脚注1</target>
        </trans-unit>
        <trans-unit id="a2e8427dcb2cd9ff2779aa2b38c7e477133f780c" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, to update a cached entity that has an associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法，更新具有关联的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;的缓存的实体。</target>
        </trans-unit>
        <trans-unit id="4a4b7f7de1f1cba719e4bebb16b0fc5cf663d900" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt; (Range Not Satisfiable) response is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523ad4bead51d0b08a4fff5dbbe8221c7a8666b5" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with an &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;(Range Not Satisfiable) response is returned.</source>
          <target state="translated">对于与&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;标头结合使用的&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法，它可以确保请求的新范围与上一个范围来自同一资源。如果不匹配，则返回&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt;（Range Not Satisfiable）响应。</target>
        </trans-unit>
        <trans-unit id="01925d81b53df8220be1ab3b85de00880bc40ace" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt; attributes&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a5e026c5b9f4e6d8669a37e565175368c88cdf" translate="yes" xml:space="preserve">
          <source>For DAV properties, the name of the property is also the same as the
   name of the XML element that contains its value.  In the section
   below, the final line of each section gives the element type
   declaration using the format defined in [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  The &quot;Value&quot;
   field, where present, specifies further restrictions on the allowable
   contents of the XML element using BNF (i.e., to further restrict the
   values of a PCDATA element).

   A protected property is one that cannot be changed with a PROPPATCH
   request.  There may be other requests that would result in a change
   to a protected property (as when a LOCK request affects the value of
   DAV:lockdiscovery).  Note that a given property could be protected on
   one type of resource, but not protected on another type of resource.

   A computed property is one with a value defined in terms of a
   computation (based on the content and other properties of that
   resource, or even of some other resource).  A computed property is
   always a protected property.

   COPY and MOVE behavior refers to local COPY and MOVE operations.

   For properties defined based on HTTP GET response headers (DAV:get*),
   the header value could include LWS as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;.  Server implementors SHOULD strip LWS from these values before
   using as WebDAV property values.</source>
          <target state="translated">对于DAV属性，属性的名称也与包含其值的XML元素的名称相同。在下面的部分中，每个部分的最后一行使用[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML中&lt;/a&gt;定义的格式]。 &amp;ldquo;值&amp;rdquo;字段（如果存在）使用BNF指定对XML元素的允许内容的进一步限制（即，进一步限制PCDATA元素的值）。受保护的属性是不能通过PROPPATCH请求进行更改的属性。可能还有其他请求会导致对受保护属性的更改（例如，当LOCK请求影响DAV：lockdiscovery的值时）。请注意，给定属性可以在一种类型的资源上受到保护，而在另一种类型的资源上不受保护。计算属性是一种具有根据计算定义的值的属性（基于该资源甚至某些其他资源的内容和其他属性）。计算属性始终是受保护的属性。COPY和MOVE行为是指本地COPY和MOVE操作。对于基于HTTP GET响应标头（DAV：get *）定义的属性，标头值可以包含[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]，&lt;a href=&quot;#section-4.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2 &lt;/a&gt;节。服务器实现者应在用作WebDAV属性值之前从这些值中删除LWS。</target>
        </trans-unit>
        <trans-unit id="7578507963f5f6a92a4ce0b4b4477e8db695266c" translate="yes" xml:space="preserve">
          <source>For Nginx, the command to set up this header is:</source>
          <target state="translated">对于Nginx来说,设置这个头的命令是。</target>
        </trans-unit>
        <trans-unit id="1714ef110b1269230d283611695b8af7bcd041c3" translate="yes" xml:space="preserve">
          <source>For an example of a custom 404 page, see &lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDN's 404 page&lt;/a&gt;.</source>
          <target state="translated">有关自定义404页面的示例，请参见&lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDN的404页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1da755a1735ea720fcbdf190446a592e95aff7a8" translate="yes" xml:space="preserve">
          <source>For authoring to commence, a client needs to discover the
   capabilities and locations of the available Collections.  Service
   Documents are designed to support this discovery process.

   How Service Documents are discovered is not defined in this
   specification. 

   Service Documents are identified with the &quot;application/atomsvc+xml&quot;
   media type (see &lt;a href=&quot;#section-16.2&quot;&gt;Section 16.2&lt;/a&gt;).</source>
          <target state="translated">为了开始创作，客户需要发现可用集合的功能和位置。服务文档旨在支持此发现过程。在本规范中未定义如何发现服务文档。服务文档以&amp;ldquo; application / atomsvc​​ + xml&amp;rdquo;媒体类型标识（请参阅&lt;a href=&quot;#section-16.2&quot;&gt;第16.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="074190f3eb43757a18a5c3d3ad9b48a9217873dc" translate="yes" xml:space="preserve">
          <source>For clients that don't implement cookie prefixes, you cannot count on these additional assurances, and prefixed cookies will always be accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc6e3c719ad40719899f3731172d36e94077ff2" translate="yes" xml:space="preserve">
          <source>For compression, end-to-end compression is where the largest performance improvements of Web sites reside. End-to-end compression refers to a compression of the body of a message that is done by the server and will last unchanged until it reaches the client. Whatever the intermediate nodes are, they leave the body untouched.</source>
          <target state="translated">对于压缩来说,端到端压缩是网站性能提升最大的地方。端到端压缩指的是对消息的主体进行压缩,由服务器完成,直到到达客户端之前都会持续不变。无论中间节点是什么,都会让正文不受影响。</target>
        </trans-unit>
        <trans-unit id="f0f988728409b019db831b62218300a55ac3d394" translate="yes" xml:space="preserve">
          <source>For convenience, this protocol can be referred to as the &quot;Atom
   Protocol&quot; or &quot;AtomPub&quot;.  The following terminology is used by this
   specification:

   o  URI - A Uniform Resource Identifier as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].  In
      this specification, the phrase &quot;the URI of a document&quot; is
      shorthand for &quot;a URI which, when dereferenced, is expected to
      produce that document as a representation&quot;.

   o  IRI - An Internationalized Resource Identifier as defined in
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;].  Before an IRI found in a document is used by HTTP, the
      IRI is first converted to a URI.  See &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;.

   o  Resource - A network-accessible data object or service identified
      by an IRI, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  See [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt;] for further
      discussion on Resources.

   o  relation (or &quot;relation of&quot;) - Refers to the &quot;rel&quot; attribute value
      of an atom:link element.

   o  Representation - An entity included with a request or response as
      defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   o  Collection - A Resource that contains a set of Member Resources.
      Collections are represented as Atom Feeds.  See &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;. 

   o  Member (or Member Resource) - A Resource whose IRI is listed in a
      Collection by an atom:link element with a relation of &quot;edit&quot; or
      &quot;edit-media&quot;.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt;.  The protocol defines two kinds of
      Members:

      *  Entry Resource - Members of a Collection that are represented
         as Atom Entry Documents, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

      *  Media Resource - Members of a Collection that have
         representations other than Atom Entry Documents.

   o  Media Link Entry - An Entry Resource that contains metadata about
      a Media Resource.  See &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.

   o  Workspace - A named group of Collections.  See &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   o  Service Document - A document that describes the location and
      capabilities of one or more Collections, grouped into Workspaces.
      See &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   o  Category Document - A document that describes the categories
      allowed in a Collection.  See &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">为了方便起见，该协议可以称为&amp;ldquo; Atom协议&amp;rdquo;或&amp;ldquo; AtomPub&amp;rdquo;。本规范使用以下术语：o &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;URI-&lt;/a&gt; [ RFC3986 ]中定义的统一资源标识符。在本说明书中，短语&amp;ldquo;文档的URI&amp;rdquo;是&amp;ldquo;当被取消引用时预期将产生该文档作为表示的URI&amp;rdquo;的简写。 o &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;IRI-&lt;/a&gt; [ RFC3987 ]中定义的国际化资源标识符。在HTTP中使用文档中找到的IRI之前，首先将IRI转换为URI。参见&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;。 o资源-由IRI标识的网络可访问数据对象或服务，如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中所定义。见[&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt; ]进一步讨论资源。 o关系（或&amp;ldquo; relation of&amp;rdquo;）-引用atom：link元素的&amp;ldquo; rel&amp;rdquo;属性值。 o表示-包含在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中定义的请求或响应中的实体。 o集合-包含一组成员资源的资源。集合表示为Atom Feed。参见&lt;a href=&quot;#section-9&quot;&gt;第9节&lt;/a&gt;。 o成员（或成员资源）-一种资源，其IRI在一个Collection中由atom：link元素列出，关系为&amp;ldquo; edit&amp;rdquo;或&amp;ldquo; edit-media&amp;rdquo;。参见&lt;a href=&quot;#section-9.1&quot;&gt;第9.1节&lt;/a&gt;。该协议定义了两种成员：*入口资源-表示为Atom入口文档的集合的成员，如[&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]。*媒体资源-具有Atom条目文档以外的表示形式的集合成员。o媒体链接条目-条目资源，其中包含有关媒体资源的元数据。见&lt;a href=&quot;#section-9.6&quot;&gt;9.6节&lt;/a&gt;。o工作区-一组命名的集合。参见&lt;a href=&quot;#section-8.1&quot;&gt;8.1节&lt;/a&gt;。o服务文档-一种文档，它描述了一个或多个集合的位置和功能，这些集合归为工作区。参见&lt;a href=&quot;#section-8&quot;&gt;第8节&lt;/a&gt;。o类别文档-描述集合中允许的类别的文档。参见&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eef31d3a1350a01572c86bb4dfa3d00e0c975e26" translate="yes" xml:space="preserve">
          <source>For each policy-controlled feature, the browser maintains a list of origins for which the feature is enabled, known as an allowlist. If you do not specify a policy for a feature, then a default allowlist will be used. The default allowlist is specific to each feature.</source>
          <target state="translated">对于每个策略控制的功能,浏览器都会维护一个启用该功能的起源列表,称为允许列表。如果您没有为某一功能指定策略,则将使用默认的允许列表。默认允许列表是每个功能所特有的。</target>
        </trans-unit>
        <trans-unit id="bbfd900d40adcb99301092c21f8010e24f933f46" translate="yes" xml:space="preserve">
          <source>For example when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="translated">例如，当编辑MDN时，将对当前Wiki内容进行哈希处理并将其放入响应中的 &lt;code&gt;Etag&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="9445e49e152cffd5d9a04a8f80bbd49732b55bc8" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;a script on Browserleaks&lt;/a&gt; highlights what Firefox reveals when queried by a simple script running on the site (you can find the code in &lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more&lt;/a&gt;).</source>
          <target state="translated">例如，&lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;Browserleaks上的脚本&lt;/a&gt;突出显示了Firefox在站点上运行的简单脚本查询时所显示的内容（您可以在&lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more中&lt;/a&gt;找到代码）。</target>
        </trans-unit>
        <trans-unit id="8282891590c0b08790018d81b4f472f2cf7db144" translate="yes" xml:space="preserve">
          <source>For example, a document at &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b899bc979c38aad573a87de3d6fa69123c484f" translate="yes" xml:space="preserve">
          <source>For example, allow all browsing contexts within this iframe to use fullscreen:</source>
          <target state="translated">例如,允许该iframe内的所有浏览上下文使用全屏。</target>
        </trans-unit>
        <trans-unit id="eac94e3ce15d79355451ea902d576dd478ad2b17" translate="yes" xml:space="preserve">
          <source>For example, by default all of the following result in a separate request to the origin and a separate cache entry: &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt;, &lt;code&gt;Accept-Encoding: gzip,deflate&lt;/code&gt;, &lt;code&gt;Accept-Encoding: gzip&lt;/code&gt;. This is true even though the origin server will probably respond with &amp;mdash; and store &amp;mdash; the same resource for all requests (a gzip)!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5100e86095301001726a9dd07582fc20d58ee08d" translate="yes" xml:space="preserve">
          <source>For example, for any MIME type whose main type is &lt;code&gt;text&lt;/code&gt;, the optional &lt;code&gt;charset&lt;/code&gt; parameter can be used to specify the character set used for the characters in the data. If no &lt;code&gt;charset&lt;/code&gt; is specified, the default is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ASCII&quot;&gt;ASCII&lt;/a&gt; (&lt;code&gt;US-ASCII&lt;/code&gt;) unless overridden by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent's&lt;/a&gt; settings. To specify a UTF-8 text file, the MIME type &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b715bba658a875ffba997c7f848a3f6b1c1f7c" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers).</source>
          <target state="translated">例如，如果设置了&amp;ldquo; &lt;code&gt;Content-Language: de-DE&lt;/code&gt; &amp;rdquo;，则表示该文档适用于讲德语的人（但是，它并不表示该文档是用德语编写的。例如，它可能以英语是德语德语课程的一部分）。</target>
        </trans-unit>
        <trans-unit id="7c8d24654bcc03695c4c0562fb4fd4f65c41f354" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers. If you want to indicate which language the document is written in, use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;&lt;code&gt;lang&lt;/code&gt; attribute&lt;/a&gt; instead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931c15cbf1cb0d096c2f7f3977e96a703c6efded" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are available on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6412826a466b2db302aa194f4e3daf55e5d61efd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are included on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="translated">例如，如果设置了 &lt;code&gt;Domain=mozilla.org&lt;/code&gt; ，则cookie会包含在像 &lt;code&gt;developer.mozilla.org&lt;/code&gt; 这样的子域中。</target>
        </trans-unit>
        <trans-unit id="f88d60c9d2f02ed6a1a1bf95ce9b557bca2dbed6" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0625b9fc57344582bbde2ab4696157ad3f42eb" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths will match:</source>
          <target state="translated">例如，如果设置了 &lt;code&gt;Path=/docs&lt;/code&gt; ，则这些路径将匹配：</target>
        </trans-unit>
        <trans-unit id="fa9700b85e0e01538fcca2eb77f677f69026288f" translate="yes" xml:space="preserve">
          <source>For example, if the page &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; were requested, and the HTTP response is &quot;301 Moved Permanently&quot;, &quot;307 Temporary Redirect&quot;, or &quot;308 Permanent Redirect&quot; with a &lt;code&gt;Location&lt;/code&gt; of &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt;, the CORS request will fail in this manner.</source>
          <target state="translated">例如，如果请求页面 &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; ，并且HTTP响应是 &lt;code&gt;Location&lt;/code&gt; 为 &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt; &amp;ldquo; 301永久移动&amp;rdquo;，&amp;ldquo; 307临时重定向&amp;rdquo;或&amp;ldquo; 308永久重定向&amp;rdquo; .net / getdata，CORS请求将以这种方式失败。</target>
        </trans-unit>
        <trans-unit id="7b87738a4c88c7a7b6a1a09e51a26bf1a734d5d4" translate="yes" xml:space="preserve">
          <source>For example, if the response includes:</source>
          <target state="translated">例如,如果响应包括:</target>
        </trans-unit>
        <trans-unit id="66e0a70fb691c18fbdd0bd050b60e272a1fe413f" translate="yes" xml:space="preserve">
          <source>For example, in Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">例如，在Apache中，将以下内容添加到服务器的配置中（在相应的 &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 部分中）。该配置通常在 &lt;code&gt;.conf&lt;/code&gt; 文件（ &lt;code&gt;httpd.conf&lt;/code&gt; 和 &lt;code&gt;apache.conf&lt;/code&gt; 是它们的通用名称）或 &lt;code&gt;.htaccess&lt;/code&gt; 文件中找到。</target>
        </trans-unit>
        <trans-unit id="619f3c064cc0ce3bc00c710809c1ce33e001a212" translate="yes" xml:space="preserve">
          <source>For example, sending the result of a form:</source>
          <target state="translated">例如,发送表格的结果。</target>
        </trans-unit>
        <trans-unit id="142fdc15f7a89b9c24c2befb228055d091883a52" translate="yes" xml:space="preserve">
          <source>For example, suppose web content at &lt;code&gt;https://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;https://bar.other&lt;/code&gt;. Code of this sort might be used in JavaScript deployed on &lt;code&gt;foo.example&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b184b5ed58eb6819039876c32250bc43b4bad555" translate="yes" xml:space="preserve">
          <source>For example, suppose web content on domain &lt;code&gt;http://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;http://bar.other&lt;/code&gt;. Code of this sort might be used within JavaScript deployed on foo.example:</source>
          <target state="translated">例如，在域假设网页内容 &lt;code&gt;http://foo.example&lt;/code&gt; 要调用域内容 &lt;code&gt;http://bar.other&lt;/code&gt; 。在foo.example上部署的JavaScript中可能会使用这种代码：</target>
        </trans-unit>
        <trans-unit id="ac8d0edbbe6f6a992074ea6f9eb0145ef93102b7" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;Proxy server&lt;/a&gt; to tunnel the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;Proxy server&lt;/a&gt; continues to proxy the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; stream to and from the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20e4a9531f0f953723ad2bce29ba67c92820b20" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.</source>
          <target state="translated">例如， &lt;code&gt;CONNECT&lt;/code&gt; 方法可用于访问使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;）的网站。客户端要求HTTP代理服务器将TCP连接隧穿到所需的目的地。然后，服务器继续代表客户端进行连接。服务器建立连接后，代理服务器将继续代理与客户端之间的TCP流。</target>
        </trans-unit>
        <trans-unit id="71916a917e381d9f4baa72eb7d0f481b27298684" translate="yes" xml:space="preserve">
          <source>For example, the following are equivalent:</source>
          <target state="translated">例如,以下是等价的。</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32905633351c047f12f27629c2b7dbcbd3258eb" translate="yes" xml:space="preserve">
          <source>For example, the server may reject a request if its &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; is too large.</source>
          <target state="translated">例如，如果服务器的&lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;太大，则服务器可能拒绝该请求。</target>
        </trans-unit>
        <trans-unit id="d63752de4fee204887b96a1631e06acc76c5193f" translate="yes" xml:space="preserve">
          <source>For example, this blocks the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; from using the camera and microphone:</source>
          <target state="translated">例如，这会阻止 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 使用相机和麦克风：</target>
        </trans-unit>
        <trans-unit id="667503768ab9f00b3c857611676b705bf222dc50" translate="yes" xml:space="preserve">
          <source>For example, to allow a site at https://amazing.site to access the resource using CORS, the header should be:</source>
          <target state="translated">例如,要允许https://amazing.site 的网站使用 CORS 访问资源,标头应该是:</target>
        </trans-unit>
        <trans-unit id="dc1f722176891e42941f464101332b2ba20f6189" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;http://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="translated">例如，要允许源 &lt;code&gt;http://mozilla.org&lt;/code&gt; 的代码访问资源，可以指定：</target>
        </trans-unit>
        <trans-unit id="74f296365850776cc0a36afe6f2ae5336b6c5ffa" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;https://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8dcd604f2bec51e5cc439af7d8b146ce60c0ce" translate="yes" xml:space="preserve">
          <source>For example, to block all content from using the Geolocation API across your site:</source>
          <target state="translated">例如,阻止所有内容在您的网站上使用地理位置API。</target>
        </trans-unit>
        <trans-unit id="b10aebfe3ed1f1d241d8fb042922d4cfda18c68c" translate="yes" xml:space="preserve">
          <source>For example, when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2c26aca152b85331257eaf1e9e80e1fb0d82dc" translate="yes" xml:space="preserve">
          <source>For example, your company was renamed, but you want existing links or bookmarks to still find you under the new name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="de2cc7afb113653239fadefd58531368ab6e0fde" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt; (the definition of how browsers should interpret media types and figure out what to do with content that doesn't have a valid one) allows JavaScript to be served using any MIME type that essentially matches any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc7ca2973a124b54e9384bba7dd4138b39eb2ca" translate="yes" xml:space="preserve">
          <source>For images, &lt;code&gt;gif&lt;/code&gt; or &lt;code&gt;png&lt;/code&gt; are using loss-less compression.</source>
          <target state="translated">对于图像， &lt;code&gt;gif&lt;/code&gt; 或 &lt;code&gt;png&lt;/code&gt; 使用无损压缩。</target>
        </trans-unit>
        <trans-unit id="f96d0e055aab7967e098e229f35a70f7d0cf4499" translate="yes" xml:space="preserve">
          <source>For inline styles or styles created from APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;HTMLElement.style&lt;/code&gt;&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="translated">对于内联样式或从&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;HTMLElement.style&lt;/code&gt; &lt;/a&gt;之类的API创建的样式，将使用所有者文档的引荐来源网址策略。</target>
        </trans-unit>
        <trans-unit id="84bf50840f620c842f8d504aeebea80f2ae78a0a" translate="yes" xml:space="preserve">
          <source>For locking mechanisms, it is the opposite: Web developers need to issue a request with the proper headers, while webmasters can mostly rely on the application to carry out the checks for them.</source>
          <target state="translated">对于锁定机制来说,情况正好相反。网络开发人员需要在发出请求时附上适当的标题,而网站管理员则主要依靠应用程序来进行检查。</target>
        </trans-unit>
        <trans-unit id="05bc2f18a1040cbebb023b0b22da7d3057050814" translate="yes" xml:space="preserve">
          <source>For more details on Firefox and Gecko based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">有关基于Firefox和Gecko的用户代理字符串的更多详细信息，请参阅&lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox用户代理字符串参考&lt;/a&gt;。Firefox的UA字符串本身分为四个部分：</target>
        </trans-unit>
        <trans-unit id="1512d2a0f3572c16865118ba125042228226dfbe" translate="yes" xml:space="preserve">
          <source>For more details on autoplay and autoplay blocking, see the article &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide&quot;&gt;Autoplay guide for media and Web Audio APIs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d24847af6c0b28f664c1b1ecd25eca36f5dc16" translate="yes" xml:space="preserve">
          <source>For more details see &lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;Using Feature Policy&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;使用功能策略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f2fd29856862ed0ab79e6861cc4858f4155a7dc" translate="yes" xml:space="preserve">
          <source>For more details, see also the &lt;a href=&quot;#Freshness&quot;&gt;Freshness&lt;/a&gt; section below.</source>
          <target state="translated">有关更多详细信息，另请参见下面的&amp;ldquo; &lt;a href=&quot;#Freshness&quot;&gt;新鲜度&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="5761c54fb5552b444dde1792f6afdb1a5c918baa" translate="yes" xml:space="preserve">
          <source>For more information about cookie prefixes and the current state of browser support, see the &lt;a href=&quot;headers/set-cookie#Cookie_prefixes&quot;&gt;Prefixes section of the Set-Cookie reference article&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a6b38e5e421526b3d5933f3b867e718bd90436" translate="yes" xml:space="preserve">
          <source>For more information, see also this article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，另请参见有关&lt;a href=&quot;../csp&quot;&gt;内容安全策略（CSP）的本文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07a2c7640b2fa8de34fac3055d8b39541b74752f" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../cookies&quot;&gt;guide on HTTP cookies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3aa6b680bc6518edc5c36b2eb482864b073f5d2" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt;文章。</target>
        </trans-unit>
        <trans-unit id="f6388d0122d4c6699e1cf73b26f4fab54e1e4ece" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; header reference page and the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;标头参考页和&lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt;文章。</target>
        </trans-unit>
        <trans-unit id="16d858e940de2d5add12c93eacce99796fbd8dc3" translate="yes" xml:space="preserve">
          <source>For more information, see the guide on &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参阅&lt;a href=&quot;../cookies&quot;&gt;HTTP cookie&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="6025b5f65ce2bedee9e205665e9c4e24e2e5b2f7" translate="yes" xml:space="preserve">
          <source>For more information, see the introductory article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf003bb7d49f08a37fe6d4505f868da1702a5d5" translate="yes" xml:space="preserve">
          <source>For more information, see the main &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;Feature Policy&lt;/a&gt; article.</source>
          <target state="translated">有关更多信息，请参见主要的&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;功能策略&lt;/a&gt;文章。</target>
        </trans-unit>
        <trans-unit id="0e6566bd07adb3ff65425532a199412494bb4520" translate="yes" xml:space="preserve">
          <source>For more on Firefox- and Gecko-based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox is broken down into 4 components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c13a01882beedd60ef040f694851d73933cf613" translate="yes" xml:space="preserve">
          <source>For more prevention tips, see the &lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF prevention cheat sheet&lt;/a&gt;.</source>
          <target state="translated">有关更多预防技巧，请参阅&lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF预防备忘单&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b991665d6c852df1848b14e1c2237629d3e471a4" translate="yes" xml:space="preserve">
          <source>For more, see &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;this Wikipedia section&lt;/a&gt; and consult state laws for the latest and most accurate information.</source>
          <target state="translated">有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;维基百科&amp;rdquo;部分，&lt;/a&gt;并咨询州法律以获取最新和最准确的信息。</target>
        </trans-unit>
        <trans-unit id="16bc316a5e9428e01ce42d164953682ad4eeadaf" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often the header boundary is prepended by two dashes in the body and the final boundary also have a two dashes appended to it.</source>
          <target state="translated">对于多部分实体，要求使用 &lt;code&gt;boundary&lt;/code&gt; 指令，该指令由一组字符中的1至70个字符组成，这些字符通过电子邮件网关非常健壮，并且不以空格结尾。它用于封装消息多个部分的边界。标题边界通常在正文中以两个破折号开头，并且最终边界也附加有两个破折号。</target>
        </trans-unit>
        <trans-unit id="7c3aed89e6dab97831be498c22ad6502ef3a5cd6" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often, the header boundary is prepended with two dashes and the final boundary has two dashes appended at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093b1094cde6e7f4f4d8f8b971af7a8990963019" translate="yes" xml:space="preserve">
          <source>For new content, you can start developing with a policy that disables all the features. This approach ensures that none of the functionality is introduced. When applying a policy to existing content, testing is likely required to verify it continues to work as expected. This is especially important for embedded or third-party content that you do not control.</source>
          <target state="translated">对于新的内容,你可以从禁用所有功能的策略开始开发。这种方法可以确保没有任何功能被引入。在对现有内容应用策略时,可能需要进行测试,以验证它是否能按预期继续工作。这对于您无法控制的嵌入式或第三方内容尤为重要。</target>
        </trans-unit>
        <trans-unit id="2f39ad9de038e309432fa2abc7e02992cadbd96a" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a .htpasswd file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="translated">对于nginx，您将需要指定要保护的位置以及提供密码保护区域名称的 &lt;code&gt;auth_basic&lt;/code&gt; 指令。然后， &lt;code&gt;auth_basic_user_file&lt;/code&gt; 指令指向一个包含加密用户凭据的.htpasswd文件，就像上面的Apache示例一样。</target>
        </trans-unit>
        <trans-unit id="b60310977b1322aae7188c84f1d2bec064596b5e" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a &lt;code&gt;.htpasswd&lt;/code&gt; file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70553b80e8be103814c1eb5f51fa3a904090e239" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Match&lt;/code&gt; can be used to prevent the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) response is returned.</source>
          <target state="translated">对于其他方法，尤其是对于&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;，可以使用 &lt;code&gt;If-Match&lt;/code&gt; 来防止&lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;丢失更新问题&lt;/a&gt;。它可以检查用户要上传的资源的修改是否不会覆盖自获取原始资源以来所做的另一次更改。如果无法满足该请求，则返回&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（前提条件失败）响应。</target>
        </trans-unit>
        <trans-unit id="538225086d2d3b055913158dd5b4c3b9bfc1f097" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; used with the &lt;code&gt;*&lt;/code&gt; value can be used to save a file not known to exist, guaranteeing that another upload didn't happen before, losing the data of the previous put; this problem is a variation of the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;.</source>
          <target state="translated">对于其他方法，特别是对于&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; 而言&lt;/a&gt;，可以将带 &lt;code&gt;*&lt;/code&gt; 值的 &lt;code&gt;If-None-Match&lt;/code&gt; 用来保存不存在的文件，从而确保之前没有发生其他上载，从而丢失了先前放置的数据；此问题是&lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;丢失更新问题的&lt;/a&gt;一种变体。</target>
        </trans-unit>
        <trans-unit id="89936fcb3c720f2a1e2c92027641b334e9357ffd" translate="yes" xml:space="preserve">
          <source>For other products based on Gecko, the string can take one of two forms, where the tokens have the same meaning except those noted below:</source>
          <target state="translated">对于基于Gecko的其他产品,字符串可以采取两种形式之一,其中除了下面提到的那些之外,代币具有相同的意义。</target>
        </trans-unit>
        <trans-unit id="907135173500e7b45556d497127edb70bd3fb716" translate="yes" xml:space="preserve">
          <source>For reasons of security and privacy, it is necessary to make a
   distinction between &quot;shared&quot; and &quot;non-shared&quot; caches. A non-shared
   cache is one that is accessible only to a single user. Accessibility
   in this case SHOULD be enforced by appropriate security mechanisms.
   All other caches are considered to be &quot;shared.&quot; Other sections of 

   this specification place certain constraints on the operation of
   shared caches in order to prevent loss of privacy or failure of
   access controls.</source>
          <target state="translated">出于安全和隐私的考虑,有必要对 &quot;共享 &quot;和 &quot;非共享 &quot;缓存进行区分。非共享缓存是指只能由一个用户访问的缓存。这种情况下的可访问性应该由适当的安全机制来强制执行。所有其他缓存都被认为是 &quot;共享 &quot;的。本规范的其他部分对共享缓存的操作进行了某些限制,以防止隐私的丢失或访问控制的失败。</target>
        </trans-unit>
        <trans-unit id="257548a557c142ce44b1aa876c1f52d0b2cfeb6c" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;*&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="translated">对于&lt;em&gt;没有凭证的&lt;/em&gt;请求，可以将字面值&amp;ldquo; *&amp;rdquo;指定为通配符；该值告诉浏览器允许从任何来源请求代码来访问资源。尝试将通配符与凭据一起使用&lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;将导致错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c5ca72995d97f0458eaf84378300b9b55e7ea55" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;&lt;code&gt;*&lt;/code&gt;&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a1bfce12feb1fb720a7fe1100883e79f123be1" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request resources from the same origin the application was loaded from unless the response from other origins includes the right CORS headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351e6c404b20eecdc808fd67608ccc7928ea6386" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from within scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request HTTP resources from the same origin the application was loaded from, unless the response from the other origin includes the right CORS headers.</source>
          <target state="translated">出于安全原因，浏览器限制了从脚本内部发起的跨域HTTP请求。例如， &lt;code&gt;XMLHttpRequest&lt;/code&gt; 和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;遵循&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;同源策略&lt;/a&gt;。这意味着使用这些API的Web应用程序只能从加载应用程序的相同来源请求HTTP资源，除非来自其他来源的响应包括正确的CORS标头。</target>
        </trans-unit>
        <trans-unit id="ee3a9635da3f4811be8395ffd6f2c7c100ed7868" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used.</source>
          <target state="translated">对于没有特定子类型的文本文档，应使用 &lt;code&gt;text/plain&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cb9d98048f241ce3bdc766680c13b98ba44670c" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used. Similarly, for binary documents without a specific or known subtype, &lt;code&gt;application/octet-stream&lt;/code&gt; should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01fd2dd2707385a8305b768f33bb65eb7bcb3f6d" translate="yes" xml:space="preserve">
          <source>For the files in the application that will not change, you can usually add aggressive caching by sending the response header below. This includes static files that are served by the application such as images, CSS files and JavaScript files, for example. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; header.</source>
          <target state="translated">对于应用程序中不会更改的文件，通常可以通过发送以下响应标头来添加主动缓存。这包括应用程序提供的静态文件，例如图像，CSS文件和JavaScript文件。此外，另请参阅 &lt;code&gt;Expires&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="47f9208ec82cf7fb7519a3acacb255f0ed8d2472" translate="yes" xml:space="preserve">
          <source>For the purpose of defining the behavior of caches and non-caching
   proxies, we divide HTTP headers into two categories:

      - End-to-end headers, which are  transmitted to the ultimate
        recipient of a request or response. End-to-end headers in
        responses MUST be stored as part of a cache entry and MUST be
        transmitted in any response formed from a cache entry.

      - Hop-by-hop headers, which are meaningful only for a single
        transport-level connection, and are not stored by caches or
        forwarded by proxies.

   The following HTTP/1.1 headers are hop-by-hop headers:

      - Connection
      - Keep-Alive
      - Proxy-Authenticate
      - Proxy-Authorization
      - TE
      - Trailers
      - Transfer-Encoding
      - Upgrade

   All other headers defined by HTTP/1.1 are end-to-end headers.

   Other hop-by-hop headers MUST be listed in a Connection header,
   (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) to be introduced into HTTP/1.1 (or later).</source>
          <target state="translated">为了定义缓存和非缓存代理的行为，我们将HTTP标头分为两类：-端到端标头，它们被传输到请求或响应的最终接收者。响应中的端到端头必须作为高速缓存条目的一部分存储，并且必须在由高速缓存条目形成的任何响应中进行传输。 -逐跳头，仅对单个传输级别连接有意义，并且不由缓存存储或由代理转发。以下HTTP / 1.1标头是逐跳标头：-连接-保持活动状态-代理验证-代理授权-TE-拖车-传输编码-升级HTTP / 1.1定义的所有其他标头都是端到端-end标头。其他逐跳标头必须在连接标头中列出，（&lt;a href=&quot;#section-14.10&quot;&gt;第14.10节&lt;/a&gt;）引入HTTP / 1.1（或更高版本）。</target>
        </trans-unit>
        <trans-unit id="21bafa062922688ae091d5ac581f85b2253ab9b7" translate="yes" xml:space="preserve">
          <source>For these reasons, pipelining has been superseded by a better algorithm, &lt;em&gt;multiplexing&lt;/em&gt;, that is used by HTTP/2.</source>
          <target state="translated">由于这些原因，流水线已被HTTP / 2使用的更好的算法&lt;em&gt;multiplexing&lt;/em&gt;取代。</target>
        </trans-unit>
        <trans-unit id="e0fe7bfcb91231799d489fc2723d6dd4bbc0c043" translate="yes" xml:space="preserve">
          <source>Forbidden header name</source>
          <target state="translated">禁止使用的标题名称</target>
        </trans-unit>
        <trans-unit id="f09e76e0b403d1bc7b01b5a7432c7aadcdb4a81e" translate="yes" xml:space="preserve">
          <source>Forbidden response-header name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdbc655eb3ebf83109410af71e822cca4455369" translate="yes" xml:space="preserve">
          <source>Forbids JavaScript from accessing the cookie, for example, through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property. Note that a cookie that has been created with HttpOnly will still be sent with JavaScript-initiated requests, e.g. when calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send&quot;&gt;&lt;code&gt;XMLHttpRequest.send()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch&quot;&gt;&lt;code&gt;fetch()&lt;/code&gt;&lt;/a&gt;. This mitigates attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b412bc69411dace0d04398d6ef301aa1c667a968" translate="yes" xml:space="preserve">
          <source>Force communication using HTTPS instead of HTTP.</source>
          <target state="translated">强制使用HTTPS代替HTTP进行通信。</target>
        </trans-unit>
        <trans-unit id="eef9c57759e4f6a908b3d969fe32e4b1fa5c2a10" translate="yes" xml:space="preserve">
          <source>Forced prefetching of hostnames might be useful, for example, on the homepage of a site to force pre-resolution of domain names that are referenced frequently throughout the site even though they are not used on the home page itself. This will improve the overall performance of site even though the performance of the home page may not be affected.</source>
          <target state="translated">强制预取主机名可能会很有用,例如,在网站的主页上,强制预解析那些在整个网站中经常被引用的域名,即使这些域名没有在主页上使用。这将提高网站的整体性能,即使主页的性能可能不会受到影响。</target>
        </trans-unit>
        <trans-unit id="07c90eda5719a0767b7585d1fae63b890d2df734" translate="yes" xml:space="preserve">
          <source>Forces caches to submit the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">强制缓存在释放缓存副本之前将请求提交给源服务器进行验证。</target>
        </trans-unit>
        <trans-unit id="5e4ea8df1ce37991d82f8682bf378d09968f9b0d" translate="yes" xml:space="preserve">
          <source>Forcing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/https&quot;&gt;HTTPS&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4634694667d40eda0bbe0a5024383a25099b93b8" translate="yes" xml:space="preserve">
          <source>Forcing HTTPS. Requests to the HTTP version of your site will be redirected to the HTTPS version of your site.</source>
          <target state="translated">强制使用HTTPS。对您网站的HTTP版本的请求将被重定向到您网站的HTTPS版本。</target>
        </trans-unit>
        <trans-unit id="e65113ef7489ad2e3e6bcd61586a5a6e130fc3a1" translate="yes" xml:space="preserve">
          <source>Forcing lookup of specific hostnames</source>
          <target state="translated">强制查找特定的主机名</target>
        </trans-unit>
        <trans-unit id="ab88e44a21e56a74ea52f9806dd114accfebc6fd" translate="yes" xml:space="preserve">
          <source>Form factor</source>
          <target state="translated">形状因素</target>
        </trans-unit>
        <trans-unit id="d4287342eaedf156edc375518b5469130015c5b1" translate="yes" xml:space="preserve">
          <source>Formatting in HTML</source>
          <target state="translated">HTML中的格式化</target>
        </trans-unit>
        <trans-unit id="72574aaae0c03841c4924b83ccaa181535815a29" translate="yes" xml:space="preserve">
          <source>Fortunately, as long as you have access to the server's configuration, fixing this is easy. The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header supports multiple origins, separated by commas, like this:</source>
          <target state="translated">幸运的是，只要您可以访问服务器的配置，就可以轻松地进行修复。的 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 头支持多个起源，由逗号分隔的，这样的：</target>
        </trans-unit>
        <trans-unit id="88300ac449331e8942e45db76cb6c950d0433ba5" translate="yes" xml:space="preserve">
          <source>Forward proxies</source>
          <target state="translated">远期代理</target>
        </trans-unit>
        <trans-unit id="f39bbf5e0d44588e0ee44ca9d11dbdff07723664" translate="yes" xml:space="preserve">
          <source>Forward proxies can also be anonymous proxies and allow users to hide their IP address while browsing the Web or using other Internet services. &lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt; (The Onion Router), routes internet traffic through multiple proxies for anonymity.</source>
          <target state="translated">转发代理也可以是匿名代理，并允许用户在浏览Web或使用其他Internet服务时隐藏其IP地址。&lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt;（洋葱路由器）通过多个代理路由互联网流量以实现匿名。</target>
        </trans-unit>
        <trans-unit id="5e96e7529d107df0e1753fe21bd01b67d79778d3" translate="yes" xml:space="preserve">
          <source>Forwarded</source>
          <target state="translated">Forwarded</target>
        </trans-unit>
        <trans-unit id="879b7cb814cbc842f6566b4b5009e2ae4c5e4256" translate="yes" xml:space="preserve">
          <source>Forwarded HTTP Extension</source>
          <target state="translated">转发的HTTP扩展名</target>
        </trans-unit>
        <trans-unit id="a751a7c6f5ebc769cdda2c0d60519a9100785f00" translate="yes" xml:space="preserve">
          <source>Forwarding client information through proxies</source>
          <target state="translated">通过代理转发客户信息</target>
        </trans-unit>
        <trans-unit id="3f19d616ab1973eab54443edad1f469f67e51a95" translate="yes" xml:space="preserve">
          <source>Fragment</source>
          <target state="translated">Fragment</target>
        </trans-unit>
        <trans-unit id="7bf6780ba1203e0c37a2bbe6f2b29b2481023856" translate="yes" xml:space="preserve">
          <source>Frame and message structure in HTTP/2</source>
          <target state="translated">HTTP/2中的帧和消息结构</target>
        </trans-unit>
        <trans-unit id="5b968bd2c47b3621328bcde661b5d00bbb234e51" translate="yes" xml:space="preserve">
          <source>Freshness</source>
          <target state="translated">Freshness</target>
        </trans-unit>
        <trans-unit id="71fec796b8ce84752a371f57c6e5fa7e23101e6f" translate="yes" xml:space="preserve">
          <source>Freshness (RFC 7234)</source>
          <target state="translated">新鲜度(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="061140cd8957c1a20500ec4735145a4823d87854" translate="yes" xml:space="preserve">
          <source>From (RFC 2616)</source>
          <target state="translated">来自(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="ab25ccd00949ff6aec782bce24f64f443ae8183b" translate="yes" xml:space="preserve">
          <source>From (RFC 7231)</source>
          <target state="translated">来自(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="fc8df84d4beeac0f9b5f8d6d828c77f7b287a76a" translate="yes" xml:space="preserve">
          <source>From the beginnings of HTTP, the protocol allowed another negotiation type: &lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;. In this negotiation, when facing an ambiguous request, the server sends back a page containing links to the available alternative resources. The user is presented the resources and choose the one to use.</source>
          <target state="translated">从HTTP开始，该协议就允许另一种协商类型：&lt;em&gt;代理驱动的协商&lt;/em&gt;或&lt;em&gt;反应式协商&lt;/em&gt;。在此协商中，当面临不明确的请求时，服务器会发回一个页面，该页面包含指向可用替代资源的链接。向用户显示资源并选择要使用的资源。</target>
        </trans-unit>
        <trans-unit id="2a0830997625a669017113736869c02cdf00c6fb" translate="yes" xml:space="preserve">
          <source>From version 1, Focus is powered by Android WebView and uses the following user agent string format:</source>
          <target state="translated">从版本1开始,Focus由Android WebView提供支持,并使用以下用户代理字符串格式。</target>
        </trans-unit>
        <trans-unit id="bf2dddbd41ffb807d3f91b7c00d45658b62cbe7d" translate="yes" xml:space="preserve">
          <source>From version 1.1, Firefox for Echo Show uses a user agent string with the following format:</source>
          <target state="translated">从1.1版本开始,Firefox for Echo Show使用了格式如下的用户代理字符串。</target>
        </trans-unit>
        <trans-unit id="b65dd0e7d73eba5ec8f68b41e102211c26e17c9c" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt; &amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634b1e47168d224b18cc5d200468a1a666ff4f5b" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt;&amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="translated">从版本53开始，Gecko在 &lt;code&gt;about:config&lt;/code&gt; 中提供了一个首选项，以允许用户设置其默认的 &lt;code&gt;Referrer-Policy&lt;/code&gt; &amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f46e7fd368eae55073e0a8f47aee34fcd932ec29" translate="yes" xml:space="preserve">
          <source>From version 59 onwards (See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;#587523&lt;/a&gt;), this has been replaced by &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; and &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt;.</source>
          <target state="translated">从版本59开始（请参阅&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;＃587523&lt;/a&gt;），已由 &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; 和 &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="4d0bf1cf951361338f44d3f633af3e9f659dd546" translate="yes" xml:space="preserve">
          <source>From version 82, if an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element's &lt;code&gt;download&lt;/code&gt; attribute is set (for a same-origin URL) then the &lt;code&gt;inline&lt;/code&gt; directive is ignored. Earlier versions did not match the specification and respected the header directive over the attribute. See &lt;a href=&quot;https://bugzil.la/1658877&quot;&gt;bug 1658877&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb08d10b00a6114f53ac03b662cd5c0fa2fadf2c" translate="yes" xml:space="preserve">
          <source>Fullscreen</source>
          <target state="translated">Fullscreen</target>
        </trans-unit>
        <trans-unit id="d1c21c81f5e9278875fd7faba9e8ce5fee900412" translate="yes" xml:space="preserve">
          <source>Fullscreen API&lt;br/&gt;&lt;small&gt;The definition of 'Fullscreen' in that specification.&lt;/small&gt;</source>
          <target state="translated">全屏API &lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;全屏&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9cf4076ad8ca1d493e56ac7306efcb34aa07f0cd" translate="yes" xml:space="preserve">
          <source>Fully qualified hostname to match against.</source>
          <target state="translated">完全合格的主机名与之匹配。</target>
        </trans-unit>
        <trans-unit id="70e18d39d91b0bb23213a714597ec6ac0a18898d" translate="yes" xml:space="preserve">
          <source>Functional overview</source>
          <target state="translated">功能概述</target>
        </trans-unit>
        <trans-unit id="d121b74dc433c61707ecf2145f14c0087235e9c1" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfil it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859debff3eb6a95e21550e12eaa3e9501db63349" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfill it.</source>
          <target state="translated">服务器需要对请求进行进一步的扩展才能完成。</target>
        </trans-unit>
        <trans-unit id="c09cf39e0efd384b99059d76f22ce0c68ab74478" translate="yes" xml:space="preserve">
          <source>Furthermore, some default values of preferences differ between build configurations, such as platform and locale, which means web sites could identify individual users using this information.</source>
          <target state="translated">此外,一些偏好的默认值在不同的构建配置之间是不同的,例如平台和地域,这意味着网站可以使用这些信息识别个人用户。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="828d617ffbd78d6822f9aa5a1a25e2e9a6f4041d" translate="yes" xml:space="preserve">
          <source>GET (RFC 7231)</source>
          <target state="translated">GET (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="889241fb06a8d7a9634f3ef3d8c354487e92626b" translate="yes" xml:space="preserve">
          <source>GET: The resource has been fetched and is transmitted in the message body.</source>
          <target state="translated">GET。资源已被获取,并在信息主体中传输。</target>
        </trans-unit>
        <trans-unit id="758f6c9347b91091c38ad698a8eba6aeac47b9c4" translate="yes" xml:space="preserve">
          <source>GIF</source>
          <target state="translated">GIF</target>
        </trans-unit>
        <trans-unit id="ad6e940d0a1449c3f043c3a92ac96eacb89d1691" translate="yes" xml:space="preserve">
          <source>GIF images (lossless compression, superseded by PNG)</source>
          <target state="translated">GIF图像(无损压缩,被PNG取代)</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="352e09ef4c24f106ac21c027ee173d9c89b53400" translate="yes" xml:space="preserve">
          <source>GZip Compressed Archive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b0db79f60240a0079907f498493dc26899f285" translate="yes" xml:space="preserve">
          <source>Gateway or multiple parties. The server is acting as a gateway to an exchange involving multiple parties.</source>
          <target state="translated">网关或多方。服务器作为涉及多方交流的网关。</target>
        </trans-unit>
        <trans-unit id="75402c80a4e4ffb05b2e1744866544933eef7e16" translate="yes" xml:space="preserve">
          <source>Gecko</source>
          <target state="translated">Gecko</target>
        </trans-unit>
        <trans-unit id="d377c8358e2e4b422fb5f7dadb1f64fb8c95cca2" translate="yes" xml:space="preserve">
          <source>Gecko user agent string</source>
          <target state="translated">Gecko用户代理字符串</target>
        </trans-unit>
        <trans-unit id="64f2d81db08b8b5b6d065aef938e7abd5e149546" translate="yes" xml:space="preserve">
          <source>Gecko version number</source>
          <target state="translated">Gecko版本号</target>
        </trans-unit>
        <trans-unit id="ab051d4c4633073d92cf5eecdf9929aa43fd1d4b" translate="yes" xml:space="preserve">
          <source>Gecko/xyz</source>
          <target state="translated">Gecko/xyz</target>
        </trans-unit>
        <trans-unit id="40fe0205052be8e7ff127e8675aa5f542d969bde" translate="yes" xml:space="preserve">
          <source>General example</source>
          <target state="translated">一般例子</target>
        </trans-unit>
        <trans-unit id="8fccc069576bf17f5e7e17b4b3c176d69ed30562" translate="yes" xml:space="preserve">
          <source>General form</source>
          <target state="translated">一般形式</target>
        </trans-unit>
        <trans-unit id="c1e2a5611d6d492bfc81f68a60efadd4f6151c4e" translate="yes" xml:space="preserve">
          <source>General header</source>
          <target state="translated">一般标题</target>
        </trans-unit>
        <trans-unit id="ce7515fe427724c3a8ec1e689f1513ade3494a01" translate="yes" xml:space="preserve">
          <source>General structure</source>
          <target state="translated">总体结构</target>
        </trans-unit>
        <trans-unit id="5739e547142aa8443b5825e26cdfefcbe00318e3" translate="yes" xml:space="preserve">
          <source>General warning information about possible problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee8f734456eeec6f1528c29e7b9dd676c82ba5c" translate="yes" xml:space="preserve">
          <source>Geolocation</source>
          <target state="translated">Geolocation</target>
        </trans-unit>
        <trans-unit id="85b8d61e7354b7736b7ec8ca91e1105f85435b65" translate="yes" xml:space="preserve">
          <source>Given this CSP header:</source>
          <target state="translated">鉴于这个CSP头。</target>
        </trans-unit>
        <trans-unit id="4e8b70f78453a41b0760bb603aa5281fa0436163" translate="yes" xml:space="preserve">
          <source>Glossary: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</source>
          <target state="translated">词汇表：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="bad9e9df904c73f497b664b045343bef194565df" translate="yes" xml:space="preserve">
          <source>Google Chrome handles DNS prefetching control</source>
          <target state="translated">谷歌浏览器处理DNS预取控制</target>
        </trans-unit>
        <trans-unit id="4d6910e3810a19ca345b6c8578f0e4ba472ba3b8" translate="yes" xml:space="preserve">
          <source>Google Docs CORB explainer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e389ee93fcba3ef467be442186c13f4427744a6" translate="yes" xml:space="preserve">
          <source>Google Webmaster blog: How to deal with planned site downtime</source>
          <target state="translated">谷歌站长博客。如何处理计划中的网站停机时间</target>
        </trans-unit>
        <trans-unit id="ea0c0aed6cf9a0c5b577d1e3a89cbf79500b4710" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="translated">Google维护&lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;HSTS预加载服务&lt;/a&gt;。通过遵循准则并成功提交您的域，浏览器将永远不会使用不安全的连接连接到您的域。由Google托管该服务时，所有浏览器均已声明打算使用（或实际上开始使用）预加载列表。但是，它不是HSTS规范的一部分，因此不应被视为官方。</target>
        </trans-unit>
        <trans-unit id="60827ebdcf1686e9d01ea4b0e1ab1925903a2c9b" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.org/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef239b0e9b523a211062dd9a992489254f2934aa" translate="yes" xml:space="preserve">
          <source>Governs which referrer information sent in the &lt;a href=&quot;headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header should be included with requests made.</source>
          <target state="translated">控制在&lt;a href=&quot;headers/referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;标头中发送的哪些Referrer信息应包含在所提出的请求中。</target>
        </trans-unit>
        <trans-unit id="360bdb2acc65ada59d8a23e434964675641d9c45" translate="yes" xml:space="preserve">
          <source>Graceful degradation</source>
          <target state="translated">优雅的退化</target>
        </trans-unit>
        <trans-unit id="14d1e14f4035027adcdfb20a1541aae1745796ae" translate="yes" xml:space="preserve">
          <source>Granular control over certain features</source>
          <target state="translated">对某些特征的精细控制</target>
        </trans-unit>
        <trans-unit id="acdb09fe43197ccedd1630af2f50c572c32d3061" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94265c1a4efc21014ed0c288b4d4deab23d58e6c" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format (GIF)</source>
          <target state="translated">图像交换格式(GIF)</target>
        </trans-unit>
        <trans-unit id="07dad8754dab2f22b2c67d2717531b2161e04c97" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time. HTTP dates are always expressed in GMT, never in local time.</source>
          <target state="translated">格林尼治标准时间。HTTP日期总是以GMT表示,而不是以当地时间表示。</target>
        </trans-unit>
        <trans-unit id="fac27197d986ea2b588d07c83185f5503eea7d94" translate="yes" xml:space="preserve">
          <source>Guide to media types used on the web</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63172a5d2ab37e128a6f6cf25b0335129725a21c" translate="yes" xml:space="preserve">
          <source>Guide: &lt;em&gt;&lt;a href=&quot;https://csswizardry.com/2019/03/cache-control-for-civilians&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt; for civilians&lt;/a&gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="82ee9a2ace2ff133591d7f8cb5b72ca9b839fcd4" translate="yes" xml:space="preserve">
          <source>Guides: Basics</source>
          <target state="translated">指南。基础知识</target>
        </trans-unit>
        <trans-unit id="6e029883c1d4de187688b7e7b2376708429e4061" translate="yes" xml:space="preserve">
          <source>Gyroscope</source>
          <target state="translated">Gyroscope</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="780c90e89bccb7fed5c8548e6fe499017ad97ffb" translate="yes" xml:space="preserve">
          <source>HEAD (RFC 7231)</source>
          <target state="translated">头部(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="562b472b05f04a6dd479541dc3fcef670a17fed9" translate="yes" xml:space="preserve">
          <source>HEAD: The entity headers are in the message body.</source>
          <target state="translated">HEAD:消息主体中的实体标题。</target>
        </trans-unit>
        <trans-unit id="c194c3625b9314d21fe00e2a5b33960d2235d75a" translate="yes" xml:space="preserve">
          <source>HPACK: Header Compression for HTTP/2</source>
          <target state="translated">HPACK:HTTP/2的报头压缩。</target>
        </trans-unit>
        <trans-unit id="f4ce8cef0273faa8edf023797bff38c190bc758e" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommend.</source>
          <target state="translated">如果使用不当,HPKP有可能长期锁定用户! 建议使用备份证书和/或钉住CA证书。</target>
        </trans-unit>
        <trans-unit id="fc0a0d888f6e163542c2141a305027befded2018" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommended.</source>
          <target state="translated">如果使用不当,HPKP有可能长期锁定用户! 建议使用备份证书和/或钉住CA证书。</target>
        </trans-unit>
        <trans-unit id="f7a71b290916b9c6df149f326df62ff64346f837" translate="yes" xml:space="preserve">
          <source>HPKP is a &lt;em&gt;Trust on First Use&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt;) technique. The first time a web server tells a client via a special HTTP header which public keys belong to it, the client stores this information for a given period of time. When the client visits the server again, it expects at least one certificate in the certificate chain to contain a public key whose fingerprint is already known via HPKP. If the server delivers an unknown public key, the client should present a warning to the user.</source>
          <target state="translated">HPKP是&lt;em&gt;首次使用信任&lt;/em&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt;）技术。Web服务器第一次通过特殊的HTTP标头告诉客户端哪个公钥属于它，客户端在给定的时间段内存储此信息。当客户端再次访问服务器时，它期望证书链中的至少一个证书包含一个公钥，该公钥的指纹已经通过HPKP知道。如果服务器提供了未知的公共密钥，则客户端应向用户显示警告。</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="f23df8f2db7fa54c086120949c75120681957c68" translate="yes" xml:space="preserve">
          <source>HTML &lt;code&gt;lang&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b74ec0b3fb709ed009e59e071a8ce0a9039c38" translate="yes" xml:space="preserve">
          <source>HTML Forms</source>
          <target state="translated">HTML表格</target>
        </trans-unit>
        <trans-unit id="2abbe4c282803f8a491f6e980e7fc519bd5a7483" translate="yes" xml:space="preserve">
          <source>HTML Living Standard</source>
          <target state="translated">HTML生活标准</target>
        </trans-unit>
        <trans-unit id="b7098c07bc2151e34df998ef11bad7237b20c9ba" translate="yes" xml:space="preserve">
          <source>HTML Living Standard&lt;br/&gt;&lt;small&gt;The definition of 'document-domain' in that specification.&lt;/small&gt;</source>
          <target state="translated">HTML Living Standard &lt;small&gt;该&lt;/small&gt;规范&lt;br/&gt;&lt;small&gt;中&amp;ldquo;文档域&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="18d5d7015a5c0d8f94531cdc381221d904d7cbf2" translate="yes" xml:space="preserve">
          <source>HTML files</source>
          <target state="translated">HTML文件</target>
        </trans-unit>
        <trans-unit id="6390be00d32679564fc38130d4ea8471a4d82c91" translate="yes" xml:space="preserve">
          <source>HTML redirections</source>
          <target state="translated">HTML重定向</target>
        </trans-unit>
        <trans-unit id="f66adf007a33a0423e5b7102cdbe9c27c03d133c" translate="yes" xml:space="preserve">
          <source>HTML redirections with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7508e59dac25653bfafc78c94cdfff1f91c75f89" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) are executed if there weren't any HTTP redirects.</source>
          <target state="translated">如果没有任何HTTP重定向，则执行HTML重定向（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8486d6ebac41d1efb6780b5d1b64cf90fff3aae8" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) execute if there weren't any HTTP redirects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="83ef326d5040783a2304cd9c3d4b2741d50432d8" translate="yes" xml:space="preserve">
          <source>HTTP 1.1 recommends the use of ETags rather than modification dates,
   for cache control, and there are even stronger reasons to prefer
   ETags for authoring.  Correct use of ETags is even more important in
   a distributed authoring environment, because ETags are necessary
   along with locks to avoid the lost-update problem.  A client might
   fail to renew a lock, for example, when the lock times out and the
   client is accidentally offline or in the middle of a long upload.
   When a client fails to renew the lock, it's quite possible the
   resource can still be relocked and the user can go on editing, as
   long as no changes were made in the meantime.  ETags are required for
   the client to be able to distinguish this case.  Otherwise, the 

   client is forced to ask the user whether to overwrite the resource on
   the server without even being able to tell the user if it has
   changed.  Timestamps do not solve this problem nearly as well as
   ETags.

   Strong ETags are much more useful for authoring use cases than weak
   ETags (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Section&amp;nbsp;13.3.3 of [RFC2616]&lt;/a&gt;).  Semantic equivalence can be
   a useful concept but that depends on the document type and the
   application type, and interoperability might require some agreement
   or standard outside the scope of this specification and HTTP.  Note
   also that weak ETags have certain restrictions in HTTP, e.g., these
   cannot be used in If-Match headers.

   Note that the meaning of an ETag in a PUT response is not clearly
   defined either in this document or in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; (i.e., whether the
   ETag means that the resource is octet-for-octet equivalent to the
   body of the PUT request, or whether the server could have made minor
   changes in the formatting or content of the document upon storage).
   This is an HTTP issue, not purely a WebDAV issue.

   Because clients may be forced to prompt users or throw away changed
   content if the ETag changes, a WebDAV server SHOULD NOT change the
   ETag (or the Last-Modified time) for a resource that has an unchanged
   body and location.  The ETag represents the state of the body or
   contents of the resource.  There is no similar way to tell if
   properties have changed.</source>
          <target state="translated">HTTP 1.1建议使用ETag而不是修改日期来进行缓存控制，并且甚至有更强烈的理由更倾向于使用ETag进行创作。在分布式创作环境中，正确使用ETag更为重要，因为ETag与锁一起是必需的，以避免丢失更新问题。客户端可能无法更新锁定，例如，当锁定超时且客户端意外脱机或长时间上传时。当客户端无法更新锁定时，只要在此期间未进行任何更改，很有可能仍可以重新锁定资源，并且用户可以继续编辑。客户端需要ETag才能区分这种情况。除此以外，客户被迫询问用户是否覆盖服务器上的资源，甚至无法告诉用户资源是否已更改。时间戳不能像ETag一样解决此问题。与弱ETag相比，强ETag在编写用例时更有用（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;[RFC2616]的13.3.3节&lt;/a&gt;）。语义等效可能是一个有用的概念，但这取决于文档类型和应用程序类型，并且互操作性可能需要本规范和HTTP范围之外的某些协议或标准。还要注意，弱ETag在HTTP中具有某些限制，例如，不能在If-Match标头中使用。请注意，在本文档或&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616中，&lt;/a&gt; PUT响应中ETag的含义均未明确定义。（即，ETag是否意味着资源是八位字节到八位字节，等​​同于PUT请求的主体，或者服务器在存储时是否可以对文档的格式或内容进行较小的更改）。这是一个HTTP问题，而不仅仅是WebDAV问题。因为如果ETag发生更改，可能会迫使客户端提示用户或丢弃更改的内容，所以WebDAV服务器不应更改正文和位置不变的资源的ETag（或上次修改时间）。ETag表示资源主体或内容的状态。没有类似的方法可以判断属性是否已更改。</target>
        </trans-unit>
        <trans-unit id="056cc5e9a537351fb174e8ebbb3ca2b1700c2d47" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;</source>
          <target state="translated">HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="392079fd3fa793eb6c0e1335885b8cddafea9ef8" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;headers&quot;&gt;headers&lt;/a&gt;, like those for requests.</source>
          <target state="translated">HTTP &lt;a href=&quot;headers&quot;&gt;标头&lt;/a&gt;，例如用于请求的标头。</target>
        </trans-unit>
        <trans-unit id="c6a6635bbee752fe5fb0f3784e33cdf15bd75ab6" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client hints&lt;/a&gt; are a work in progress. Actual documentation can be found on the &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html&quot;&gt;website of the HTTP working group&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2ed3fe8a3093e057602abdf74477e83473a214" translate="yes" xml:space="preserve">
          <source>HTTP &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTP &lt;em&gt;主机：端口&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae47637ce45f4b16c54404dff4cb129bfbe68800" translate="yes" xml:space="preserve">
          <source>HTTP Access Control covering the HTTP headers</source>
          <target state="translated">覆盖HTTP头的HTTP访问控制</target>
        </trans-unit>
        <trans-unit id="d601b5bb2c1cad46bb9aa46a3ee39b64315236e7" translate="yes" xml:space="preserve">
          <source>HTTP Alternative Services</source>
          <target state="translated">HTTP替代服务</target>
        </trans-unit>
        <trans-unit id="965e2184c8e7927a43f2bee90d3f5ececba434b6" translate="yes" xml:space="preserve">
          <source>HTTP Cache</source>
          <target state="translated">HTTP缓存</target>
        </trans-unit>
        <trans-unit id="f54d56b271b9875e48fe27b600b0dc067a9f284e" translate="yes" xml:space="preserve">
          <source>HTTP Cache-Control Extensions for Stale Content</source>
          <target state="translated">针对陈旧内容的HTTP缓存控制扩展</target>
        </trans-unit>
        <trans-unit id="6c1e735662c0178e6f3fe960f4930ffeabb6f7fe" translate="yes" xml:space="preserve">
          <source>HTTP Caching FAQ</source>
          <target state="translated">HTTP缓存常见问题</target>
        </trans-unit>
        <trans-unit id="0b0260299fa380d7d3a7ccc7edbf8a208c829f61" translate="yes" xml:space="preserve">
          <source>HTTP Client Hints</source>
          <target state="translated">HTTP客户端提示</target>
        </trans-unit>
        <trans-unit id="17e0afd9e45a02ae60f6b6aed60a68bef13f3af0" translate="yes" xml:space="preserve">
          <source>HTTP Conditional Requests</source>
          <target state="translated">HTTP条件请求</target>
        </trans-unit>
        <trans-unit id="186213537e6fba63d1dd994c6c9b358b6f840caf" translate="yes" xml:space="preserve">
          <source>HTTP Cookies</source>
          <target state="translated">HTTP Cookies</target>
        </trans-unit>
        <trans-unit id="ae2fa3648597031d5a833b5724263dbfd920c241" translate="yes" xml:space="preserve">
          <source>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</source>
          <target state="translated">用于网络分布式创作和版本管理的HTTP扩展(WebDAV)</target>
        </trans-unit>
        <trans-unit id="6cee8a3bc57d158b257c68ed73852449cb27b716" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options</source>
          <target state="translated">HTTP標頭欄位 X-File-Options (X-Frame-Options)</target>
        </trans-unit>
        <trans-unit id="f88eb2164f3dbd137bca83f451898992e6e6b039" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options - RFC 7034</source>
          <target state="translated">HTTP 标头字段 X-File-Options-RFC 7034</target>
        </trans-unit>
        <trans-unit id="cc46670cd995848df63f3703c3400f81060dd482" translate="yes" xml:space="preserve">
          <source>HTTP Headers</source>
          <target state="translated">HTTP头文件</target>
        </trans-unit>
        <trans-unit id="d5d09479cf8d4e2b8c35798b4a19c06e1f5461b3" translate="yes" xml:space="preserve">
          <source>HTTP Immutable Responses</source>
          <target state="translated">HTTP不可更改的响应</target>
        </trans-unit>
        <trans-unit id="d1d0c4dbc1b360b38cb5161612b50b3934e501fa" translate="yes" xml:space="preserve">
          <source>HTTP Keep-Alive Header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc68b45ed9f862b4a9cd7aa0be2cfbc7e016a6ef" translate="yes" xml:space="preserve">
          <source>HTTP Message (RFC 2616)</source>
          <target state="translated">HTTP消息(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="645acbbc29e90c2c68542670b051cdcea02987bc" translate="yes" xml:space="preserve">
          <source>HTTP Messages</source>
          <target state="translated">HTTP消息</target>
        </trans-unit>
        <trans-unit id="3ccf0b57b902eafdb8fbf2b560f880d3eb800cc2" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure. This introductory article describes this structure, its purpose, and its possibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583d9f510824dc860b8faad49ebe7579ffd29c0b" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure; this introductory article describes this structure, its purpose and its possibilities.</source>
          <target state="translated">在请求或响应过程中传输的HTTP消息有一个非常清晰的结构,本文介绍了这个结构、它的目的和它的可能性。</target>
        </trans-unit>
        <trans-unit id="1b57e4650aa38c4a92f3b3fc02ea7dab930ee663" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HPKP&quot;&gt;HPKP&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34a93534eb1b632f2a799adfc1786464f6439f8" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning has been deprecated and removed in favor of Certificate Transparency and &lt;a href=&quot;headers/expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fdc3e6f5c751d82295ac7ade9d715a4814c0d4" translate="yes" xml:space="preserve">
          <source>HTTP Request Methods</source>
          <target state="translated">HTTP请求方法</target>
        </trans-unit>
        <trans-unit id="147cce8975179e5500fc1bb079891e026beac7f0" translate="yes" xml:space="preserve">
          <source>HTTP Requests</source>
          <target state="translated">HTTP请求</target>
        </trans-unit>
        <trans-unit id="7402660b7ec42f5008e637f7d416a9463ae2ce2f" translate="yes" xml:space="preserve">
          <source>HTTP Responses</source>
          <target state="translated">HTTP响应</target>
        </trans-unit>
        <trans-unit id="1e3c49a8c708be92f5037401d92246426a46dc11" translate="yes" xml:space="preserve">
          <source>HTTP State Management Mechanism</source>
          <target state="translated">HTTP状态管理机制</target>
        </trans-unit>
        <trans-unit id="a5fc269de1ce9034a5e3e1936288b84520462ea3" translate="yes" xml:space="preserve">
          <source>HTTP Status Response Codes</source>
          <target state="translated">HTTP状态响应代码</target>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="translated">HTTP严格传输安全(HSTS)</target>
        </trans-unit>
        <trans-unit id="30491b8aa76d328aca84cd3704d383ab97b03407" translate="yes" xml:space="preserve">
          <source>HTTP Working Group</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc09a66647a44074ee04da1ac1771e8479c9d8b" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to a communicate with different &lt;em&gt;resources&lt;/em&gt; on Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="translated">HTTP允许浏览器或另一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;与Internet 上的不同&lt;em&gt;资源&lt;/em&gt;进行通信：为此，浏览器需要资源的&lt;em&gt;身份&lt;/em&gt;和&lt;em&gt;位置&lt;/em&gt;。这两个信息位由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="1cc8c4caf634d96aa87067b5477aecd5ac3e698e" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to communicate with different &lt;em&gt;resources&lt;/em&gt; on the Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d82f24e44e689920296a131052df78d102bbaff" translate="yes" xml:space="preserve">
          <source>HTTP and WebDAV did not use the bodies of most error responses for
   machine-parsable information until the specification for Versioning
   Extensions to WebDAV introduced a mechanism to include more specific
   information in the body of an error response (&lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;Section&amp;nbsp;1.6 of
   [RFC3253]&lt;/a&gt;).  The error body mechanism is appropriate to use with any
   error response that may take a body but does not already have a body
   defined.  The mechanism is particularly appropriate when a status
   code can mean many things (for example, 400 Bad Request can mean
   required headers are missing, headers are incorrectly formatted, or
   much more).  This error body mechanism is covered in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;.</source>
          <target state="translated">HTTP和WebDAV并未将大多数错误响应的主体用于机器可解析的信息，直到WebDAV的Versioning Extensions规范引入了一种机制，以在错误响应的主体中包含更多特定的信息（&lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;[RFC3253]的1.6节&lt;/a&gt;）。错误主体机制适用于可能带有主体但尚未定义主体的任何错误响应。当状态代码可能意味着很多事情时（例如，400 Bad Request可能意味着缺少必需的标头，标头格式错误或更多），该机制特别合适。&lt;a href=&quot;#section-16&quot;&gt;第16节&lt;/a&gt;介绍了此错误体机制。</target>
        </trans-unit>
        <trans-unit id="170502bb0d853c3d72e45f0eef9c00311f2253c6" translate="yes" xml:space="preserve">
          <source>HTTP and connections</source>
          <target state="translated">HTTP和连接</target>
        </trans-unit>
        <trans-unit id="70e2789624d7913484672252eb44130b859ad66a" translate="yes" xml:space="preserve">
          <source>HTTP applications have historically allowed three different formats
   for the representation of date/time stamps:

      Sun, 06 Nov 1994 08:49:37 GMT  ; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;, updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;
      Sunday, 06-Nov-94 08:49:37 GMT ; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;
      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format

   The first format is preferred as an Internet standard and represents
   a fixed-length subset of that defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;] (an update to
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]). The second format is in common use, but is based on the
   obsolete &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [&lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;] date format and lacks a four-digit year.
   HTTP/1.1 clients and servers that parse the date value MUST accept
   all three formats (for compatibility with HTTP/1.0), though they MUST
   only generate the &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; format for representing HTTP-date values
   in header fields. See &lt;a href=&quot;#section-19.3&quot;&gt;section 19.3&lt;/a&gt; for further information.

      Note: Recipients of date values are encouraged to be robust in
      accepting date values that may have been sent by non-HTTP
      applications, as is sometimes the case when retrieving or posting
      messages via proxies/gateways to SMTP or NNTP. 

   All HTTP date/time stamps MUST be represented in Greenwich Mean Time
   (GMT), without exception. For the purposes of HTTP, GMT is exactly
   equal to UTC (Coordinated Universal Time). This is indicated in the
   first two formats by the inclusion of &quot;GMT&quot; as the three-letter
   abbreviation for time zone, and MUST be assumed when reading the
   asctime format. HTTP-date is case sensitive and MUST NOT include
   additional LWS beyond that specifically included as SP in the
   grammar.

       HTTP-date    = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date | &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date | asctime-date
       &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date = wkday &quot;,&quot; SP date1 SP time SP &quot;GMT&quot;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  = weekday &quot;,&quot; SP date2 SP time SP &quot;GMT&quot;
       asctime-date = wkday SP date3 SP time SP 4DIGIT
       date1        = 2DIGIT SP month SP 4DIGIT
                      ; day month year (e.g., 02 Jun 1982)
       date2        = 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT
                      ; day-month-year (e.g., 02-Jun-82)
       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                      ; month day (e.g., Jun  2)
       time         = 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT
                      ; 00:00:00 - 23:59:59
       wkday        = &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot;
                    | &quot;Thu&quot; | &quot;Fri&quot; | &quot;Sat&quot; | &quot;Sun&quot;
       weekday      = &quot;Monday&quot; | &quot;Tuesday&quot; | &quot;Wednesday&quot;
                    | &quot;Thursday&quot; | &quot;Friday&quot; | &quot;Saturday&quot; | &quot;Sunday&quot;
       month        = &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot;
                    | &quot;May&quot; | &quot;Jun&quot; | &quot;Jul&quot; | &quot;Aug&quot;
                    | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;

      Note: HTTP requirements for the date/time stamp format apply only
      to their usage within the protocol stream. Clients and servers are
      not required to use these formats for user presentation, request
      logging, etc.</source>
          <target state="translated">HTTP应用程序历来允许使用三种不同的格式来表示日期/时间戳：Sun，1994年11月6日08:49:37 GMT; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;，由&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; 周日，94-Nov-94 08:49:37 GMT更新；&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt; 已于1994年11月6日星期日8:49:37废弃； ANSI C的asctime（）格式首选第一种格式作为Internet标准，它表示&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt; ]（对&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] 的更新） 定义的固定长度的子集。第二种格式是常用的，但是基于过时的&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [ &lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;]日期格式，并且缺少四位数的年份。解析日期值的HTTP / 1.1客户端和服务器必须接受所有三种格式（为了与HTTP / 1.0兼容），尽管它们必须仅生成&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;格式来表示报头字段中的HTTP日期值。见&lt;a href=&quot;#section-19.3&quot;&gt;19.3节&lt;/a&gt;了解更多信息。注意：鼓励日期值的接收者在接受可能由非HTTP应用程序发送的日期值时保持鲁棒性，例如在通过代理/网关将消息检索或发布到SMTP或NNTP时，有时会遇到这种情况。所有HTTP日期/时间戳都必须毫无例外地以格林威治标准时间（GMT）表示。就HTTP而言，GMT完全等于UTC（世界标准时间）。这在前两种格式中通过包含&amp;ldquo; GMT&amp;rdquo;作为时区的三个字母的缩写来表示，并且在读取asctime格式时必须假定。 HTTP日期区分大小写，并且除语法中作为SP特别包含的内容外，不得包含其他LWS。HTTP日期= &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123-&lt;/a&gt;日期|&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850-&lt;/a&gt;日期| asctime-date &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date = wkday&amp;ldquo;，&amp;rdquo; SP date1 SP时间SP&amp;ldquo; GMT&amp;rdquo; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date =工作日&amp;ldquo;，&amp;rdquo; SP date2 SP时间SP&amp;ldquo; GMT&amp;rdquo; asctime-date = wkday SP date3 SP时间SP 4DIGIT date1 = 2DIGIT SP月SP 4DIGIT;日月年（例如1982年6月2日）date2 = 2DIGIT&amp;ldquo;-&amp;rdquo;月&amp;ldquo;-&amp;rdquo; 2DIGIT;日-月-年（例如，82年6月2日）date3 =月SP（2DIGIT |（SP 1DIGIT））；一个月的一天（例如，6月2日）时间= 2DIGIT&amp;ldquo;：&amp;rdquo; 2DIGIT&amp;ldquo;：&amp;rdquo; 2DIGIT; 00:00:00-23:59:59 wkday =&amp;ldquo;星期一&amp;rdquo; | &amp;ldquo;星期二&amp;rdquo; | &amp;ldquo;星期三&amp;rdquo; | &amp;ldquo;星期四&amp;rdquo; | &amp;ldquo;星期五&amp;rdquo; | &amp;ldquo;星期六&amp;rdquo; | &amp;ldquo; Sun&amp;rdquo;工作日=&amp;ldquo;星期一&amp;rdquo; | &amp;ldquo;星期二&amp;rdquo; | &amp;ldquo;星期三&amp;rdquo; | &amp;rdquo;&amp;ldquo;星期四&amp;rdquo; |&amp;ldquo;星期五&amp;rdquo; |&amp;ldquo;星期六&amp;rdquo; |&amp;ldquo;星期日&amp;rdquo;月=&amp;ldquo; 1月&amp;rdquo; |&amp;ldquo; 2月&amp;rdquo; |&amp;ldquo; 3月&amp;rdquo; |&amp;ldquo; 4月&amp;rdquo; |&amp;ldquo; 5月&amp;rdquo; |&amp;ldquo; 6月&amp;rdquo; |&amp;ldquo; 7月&amp;rdquo; |&amp;ldquo; 8月&amp;rdquo; |&amp;ldquo; 9月&amp;rdquo; &amp;ldquo; |&amp;rdquo; Oct&amp;ldquo; |&amp;rdquo; Nov&amp;ldquo; |&amp;rdquo; Dec&amp;ldquo;注意：日期/时间戳格式的HTTP要求仅适用于协议流中的用法。客户端和服务器不需要使用这些格式来进行用户演示，请求日志记录等| &amp;ldquo; 9月&amp;rdquo; | &amp;ldquo;十月&amp;rdquo; | &amp;ldquo;十一月&amp;rdquo; | &amp;ldquo; Dec&amp;rdquo;注意：日期/时间戳格式的HTTP要求仅适用于协议流中的用法。客户端和服务器不需要使用这些格式进行用户演示，请求日志记录等。| &amp;ldquo; 9月&amp;rdquo; | &amp;ldquo;十月&amp;rdquo; | &amp;ldquo;十一月&amp;rdquo; | &amp;ldquo; Dec&amp;rdquo;注意：日期/时间戳格式的HTTP要求仅适用于协议流中的用法。客户端和服务器不需要使用这些格式进行用户演示，请求日志记录等。</target>
        </trans-unit>
        <trans-unit id="3cd45603fb781257153f9081597101ece177c7d0" translate="yes" xml:space="preserve">
          <source>HTTP authentication</source>
          <target state="translated">HTTP认证</target>
        </trans-unit>
        <trans-unit id="ab4ed2ef5f3094275f004bff5889feddcf0ad10a" translate="yes" xml:space="preserve">
          <source>HTTP caching &amp;ndash; Ilya Grigorik</source>
          <target state="translated">HTTP缓存&amp;ndash; Ilya Grigorik</target>
        </trans-unit>
        <trans-unit id="d4978c013ac3d81e858ff3f4bb1b87778fc8087f" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional but usually desirable. HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;; they may decline other methods. The primary cache key consists of the request method and target URI (often only the URI is used &amp;mdash; this is because only &lt;code&gt;GET&lt;/code&gt; requests are caching targets).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0f4dfb9b0a4bec403f49cd2c2239e560902813" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional, but reusing a cached resource is usually desirable. However, common HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and may decline other methods. The primary cache key consists of the request method and target URI (oftentimes only the URI is used as only GET requests are caching targets). Common forms of caching entries are:</source>
          <target state="translated">HTTP缓存是可选的，但是通常需要重用缓存的资源。但是，常见的HTTP缓存通常仅限于缓存对&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 的&lt;/a&gt;响应，并且可能会拒绝其他方法。主缓存键由请求方法和目标URI组成（通常仅使用URI，因为只有GET请求才是缓存目标）。缓存条目的常见形式是：</target>
        </trans-unit>
        <trans-unit id="64f23433ac676ea06e9a1900351a7ac4a13f68a1" translate="yes" xml:space="preserve">
          <source>HTTP caching works best when caches can entirely avoid making
   requests to the origin server. The primary mechanism for avoiding
   requests is for an origin server to provide an explicit expiration
   time in the future, indicating that a response MAY be used to satisfy
   subsequent requests. In other words, a cache can return a fresh
   response without first contacting the server.

   Our expectation is that servers will assign future explicit
   expiration times to responses in the belief that the entity is not
   likely to change, in a semantically significant way, before the
   expiration time is reached. This normally preserves semantic
   transparency, as long as the server's expiration times are carefully
   chosen. 

   The expiration mechanism applies only to responses taken from a cache
   and not to first-hand responses forwarded immediately to the
   requesting client.

   If an origin server wishes to force a semantically transparent cache
   to validate every request, it MAY assign an explicit expiration time
   in the past. This means that the response is always stale, and so the
   cache SHOULD validate it before using it for subsequent requests. See
   &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt; for a more restrictive way to force revalidation.

   If an origin server wishes to force any HTTP/1.1 cache, no matter how
   it is configured, to validate every request, it SHOULD use the &quot;must-
   revalidate&quot; cache-control directive (see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).

   Servers specify explicit expiration times using either the Expires
   header, or the max-age directive of the Cache-Control header.

   An expiration time cannot be used to force a user agent to refresh
   its display or reload a resource; its semantics apply only to caching
   mechanisms, and such mechanisms need only check a resource's
   expiration status when a new request for that resource is initiated.
   See &lt;a href=&quot;#section-13.13&quot;&gt;section 13.13&lt;/a&gt; for an explanation of the difference between caches
   and history mechanisms.</source>
          <target state="translated">当缓存可以完全避免向原始服务器发出请求时，HTTP缓存效果最好。避免请求的主要机制是让源服务器在将来提供明确的到期时间，这表明可以使用响应来满足后续请求。换句话说，缓存无需先联系服务器即可返回新的响应。我们的期望是，服务器将认为响应在达到到期时间之前该实体不太可能以语义上重要的方式进行更改，因此会为响应分配未来的明确到期时间。只要仔细选择服务器的到期时间，通常就可以保持语义透明性。过期机制仅适用于从缓存中获取的响应，不适用于立即转发给发出请求的客户端的第一手响应。如果源服务器希望强制使用语义透明的缓存来验证每个请求，它可以在过去分配一个明确的到期时间。这意味着响应始终是陈旧的，因此缓存应在将其用于后续请求之前对其进行验证。看到 &lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节提供&lt;/a&gt;了一种更严格的强制重新验证方法。如果原始服务器希望强制任何HTTP / 1.1缓存，无论其配置如何，以验证每个请求，它都应使用&amp;ldquo;必须重新验证&amp;rdquo;缓存控制指令（请参见&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt;）。服务器使用Expires标头或Cache-Control标头的max-age指令指定显式的到期时间。到期时间不能用于强制用户代理刷新其显示内容或重新加载资源。它的语义仅适用于缓存机制，并且此类机制仅在启动对该资源的新请求时才需要检查该资源的到期状态。见&lt;a href=&quot;#section-13.13&quot;&gt;13.13节&lt;/a&gt; 解释缓存和历史记录机制之间的区别。</target>
        </trans-unit>
        <trans-unit id="7f76c971673910b6c1b10deaca8522002aada40e" translate="yes" xml:space="preserve">
          <source>HTTP clients are often privy to large amounts of personal information
   (e.g. the user's name, location, mail address, passwords, encryption
   keys, etc.), and SHOULD be very careful to prevent unintentional
   leakage of this information via the HTTP protocol to other sources.
   We very strongly recommend that a convenient interface be provided
   for the user to control dissemination of such information, and that
   designers and implementors be particularly careful in this area.
   History shows that errors in this area often create serious security
   and/or privacy problems and generate highly adverse publicity for the
   implementor's company.</source>
          <target state="translated">HTTP客户端通常会掌握大量的个人信息(如用户的姓名、位置、邮件地址、密码、加密密钥等),因此要非常小心地防止这些信息通过HTTP协议无意中泄露给其他来源。我们非常强烈地建议为用户提供一个方便的接口来控制这些信息的传播,设计者和实现者在这方面要特别小心。历史表明,这方面的错误往往会造成严重的安全和/或隐私问题,并给实施者的公司带来非常不利的宣传。</target>
        </trans-unit>
        <trans-unit id="0593fb953516cec3cb50e486b7c0cd80aa7ff135" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests</source>
          <target state="translated">HTTP条件请求</target>
        </trans-unit>
        <trans-unit id="a24d61eed6303644578268bb7ece0c747329e619" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests are requests that are executed differently, depending on the value of specific headers. These headers define a precondition, and the result of the request will be different if the precondition is matched or not.</source>
          <target state="translated">HTTP条件请求是指根据特定头信息的值,执行不同的请求。这些头信息定义了一个先决条件,如果先决条件符合或不符合,请求的结果就会不同。</target>
        </trans-unit>
        <trans-unit id="7cb9523b16d3c9a97f6ddd095333da9f953ccd3f" translate="yes" xml:space="preserve">
          <source>HTTP content negotiation (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) uses short &quot;floating point&quot;
   numbers to indicate the relative importance (&quot;weight&quot;) of various
   negotiable parameters.  A weight is normalized to a real number in
   the range 0 through 1, where 0 is the minimum and 1 the maximum
   value. If a parameter has a quality value of 0, then content with
   this parameter is `not acceptable' for the client. HTTP/1.1
   applications MUST NOT generate more than three digits after the
   decimal point. User configuration of these values SHOULD also be
   limited in this fashion.

       qvalue         = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                      | ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   &quot;Quality values&quot; is a misnomer, since these values merely represent
   relative degradation in desired quality.</source>
          <target state="translated">HTTP内容协商（&lt;a href=&quot;#section-12&quot;&gt;第12节&lt;/a&gt;）使用简短的&amp;ldquo;浮点&amp;rdquo;数字表示各种可协商参数的相对重要性（&amp;ldquo;权重&amp;rdquo;）。权重标准化为0到1范围内的实数，其中0是最小值，而1是最大值。如果参数的质量值为0，则客户端对该参数的内容&amp;ldquo;不可接受&amp;rdquo;。 HTTP / 1.1应用程序生成的小数点后不得超过三位数。这些值的用户配置也应该以这种方式受到限制。 qvalue =（&amp;ldquo; 0&amp;rdquo; [&amp;ldquo;。&amp;rdquo; 0 * 3DIGIT]）| （&amp;ldquo; 1&amp;rdquo; [&amp;ldquo;。&amp;rdquo; 0 * 3（&amp;ldquo; 0&amp;rdquo;）]）&amp;ldquo;质量值&amp;rdquo;是用词不当，因为这些值仅表示所需质量的相对下降。</target>
        </trans-unit>
        <trans-unit id="7b89b9e50093443d13f8d95c6b289f93dce89159" translate="yes" xml:space="preserve">
          <source>HTTP cookie</source>
          <target state="translated">超文本标记符</target>
        </trans-unit>
        <trans-unit id="49bceea2f43dd4ce87f70babc4ac786f9373fb9b" translate="yes" xml:space="preserve">
          <source>HTTP cookie on Wikipedia</source>
          <target state="translated">维基百科上的HTTP cookie</target>
        </trans-unit>
        <trans-unit id="d913ef28f4b5c9d1334d825b1c91fdfabe426299" translate="yes" xml:space="preserve">
          <source>HTTP cookies</source>
          <target state="translated">汉字档案</target>
        </trans-unit>
        <trans-unit id="d449bb5c3598a5a64c8ae94493892b59bad9bafe" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;a href=&quot;methods&quot;&gt;request methods&lt;/a&gt; indicating the desired action to be performed upon a resource. Although they can also be nouns, these requests methods are sometimes referred as HTTP verbs. The most common requests are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;:</source>
          <target state="translated">HTTP定义了一组&lt;a href=&quot;methods&quot;&gt;请求方法&lt;/a&gt;，这些方法指示对资源执行的所需操作。尽管它们也可以是名词，但这些请求方法有时也称为HTTP动词。最常见的请求是 &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;POST&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="30ad447e6db12c17885856bdde1f5bd54513584a" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="translated">HTTP定义了一组&lt;strong&gt;请求方法，&lt;/strong&gt;以指示要对给定资源执行的所需操作。尽管它们也可以是名词，但这些请求方法有时也称为&lt;em&gt;HTTP动词&lt;/em&gt;。它们中的每个实现了不同的语义，但是它们的某些组共享了一些共有的功能：例如，请求方法可以是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;幂等的&lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;可缓存的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98d83c5b67ede465177980174dae53107f9fcd36" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred to as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3823907860c4fbcb228c6adf9d8a7633b5e997" translate="yes" xml:space="preserve">
          <source>HTTP defines many headers that can be used in WebDAV requests and
   responses.  Not all of these are appropriate in all situations and
   some interactions may be undefined.  Note that HTTP 1.1 requires the
   Date header in all responses if possible (see &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]).

   The server MUST do authorization checks before checking any HTTP
   conditional header.</source>
          <target state="translated">HTTP定义了许多可用于WebDAV请求和响应的标头。并非所有这些方法都适用于所有情况，并且某些交互作用可能不确定。请注意，如果可能，HTTP 1.1在所有响应中都需要Date标头（请参见&lt;a href=&quot;#section-14.18&quot;&gt;第14.18节&lt;/a&gt; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]）。服务器必须在检查任何HTTP条件标头之前进行授权检查。</target>
        </trans-unit>
        <trans-unit id="8a133de8128e059a1d8a37cda84e730f09f27e2d" translate="yes" xml:space="preserve">
          <source>HTTP defines the Location header to indicate a preferred URL for the
   resource that was addressed in the Request-URI (e.g., in response to
   successful PUT requests or in redirect responses).  However, use of
   this header creates ambiguity when there are URLs in the body of the
   response, as with Multi-Status.  Thus, use of the Location header
   with the Multi-Status response is intentionally undefined.</source>
          <target state="translated">HTTP定义了Location头,用于指示资源的首选URL,该资源在Request-URI中被处理(例如,响应成功的PUT请求或重定向响应)。然而,当响应的主体中有 URL 时,使用该头会产生歧义,就像使用 Multi-Status 一样。因此,在Multi-Status响应中使用Location头是故意不定义的。</target>
        </trans-unit>
        <trans-unit id="3a87bd3891b7e9c3d201f6e5eb6fa13e129baa69" translate="yes" xml:space="preserve">
          <source>HTTP didn't stop evolving upon the release of HTTP/2. Like with HTTP/1.x previously, HTTP's extensibility is still being used to add new features. Notably, we can cite new extensions of the HTTP protocol appearing in 2016:</source>
          <target state="translated">HTTP并没有因为HTTP/2的发布而停止发展。就像之前的HTTP/1.x一样,HTTP的可扩展性仍然被用来增加新的功能。值得注意的是,我们可以举出HTTP协议在2016年出现的新扩展。</target>
        </trans-unit>
        <trans-unit id="b88a5eff6f325b12d08c43e0aa22f6a60e181d3d" translate="yes" xml:space="preserve">
          <source>HTTP does not define a specific mechanism for ensuring message
   integrity, instead relying on the error-detection ability of
   underlying transport protocols and the use of length or
   chunk-delimited framing to detect completeness.  Additional integrity
   mechanisms, such as hash functions or digital signatures applied to
   the content, can be selectively added to messages via extensible 

   metadata header fields.  Historically, the lack of a single integrity
   mechanism has been justified by the informal nature of most HTTP
   communication.  However, the prevalence of HTTP as an information
   access mechanism has resulted in its increasing use within
   environments where verification of message integrity is crucial.

   User agents are encouraged to implement configurable means for
   detecting and reporting failures of message integrity such that those
   means can be enabled within environments for which integrity is
   necessary.  For example, a browser being used to view medical history
   or drug interaction information needs to indicate to the user when
   such information is detected by the protocol to be incomplete,
   expired, or corrupted during transfer.  Such mechanisms might be
   selectively enabled via user agent extensions or the presence of
   message integrity metadata in a response.  At a minimum, user agents
   ought to provide some indication that allows a user to distinguish
   between a complete and incomplete response message (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;) when
   such verification is desired.</source>
          <target state="translated">HTTP并未定义用于确保消息完整性的特定机制，而是依靠基础传输协议的错误检测能力以及使用长度或块分隔的帧来检测完整性。可以通过可扩展的元数据头字段将其他完整性机制（例如应用于内容的哈希函数或数字签名）选择性地添加到消息中。从历史上看，大多数HTTP通信的非正式性质证明缺乏单一的完整性机制。但是，HTTP作为信息访问机制的盛行已导致其在对消息完整性进行验证至关重要的环境中越来越多地使用它。鼓励用户代理实现用于检测和报告消息完整性失败的可配置方式，以便可以在需要完整性的环境中启用这些方式。例如，用于查看病史或药物相互作用信息的浏览器需要在协议期间检测到该信息在传输过程中不完整，过期或损坏时向用户指示。可以通过用户代理扩展或响应中消息完整性元数据的存在来选择性地启用此类机制。用户代理至少应提供一些指示，以允许用户区分完整的响应消息和不完整的响应消息（例如，用于查看病史或药物相互作用信息的浏览器需要在协议期间检测到该信息在传输过程中不完整，过期或损坏时向用户指示。可以通过用户代理扩展或响应中消息完整性元数据的存在来选择性地启用此类机制。用户代理至少应提供一些指示，以允许用户区分完整的响应消息和不完整的响应消息（例如，用于查看病史或药物相互作用信息的浏览器需要在协议期间检测到该信息在传输过程中不完整，过期或损坏时向用户指示。可以通过用户代理扩展或响应中消息完整性元数据的存在来选择性地启用此类机制。用户代理至少应提供一些指示，以允许用户区分完整的响应消息和不完整的响应消息（可以通过用户代理扩展或响应中消息完整性元数据的存在来选择性地启用此类机制。用户代理至少应提供一些指示，以允许用户区分完整的响应消息和不完整的响应消息（可以通过用户代理扩展或响应中消息完整性元数据的存在来选择性地启用此类机制。用户代理至少应提供一些指示，以允许用户区分完整的响应消息和不完整的响应消息（&lt;a href=&quot;#section-3.4&quot;&gt;第3.4节&lt;/a&gt;）何时需要进行此类验证。</target>
        </trans-unit>
        <trans-unit id="87d2894d742e24a75af2f1ab57c0987684b7ec4b" translate="yes" xml:space="preserve">
          <source>HTTP does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond
   exactly to the order in which requests are made on the same
   connection.  More than one response message per request only occurs
   when one or more informational responses (1xx, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;Section&amp;nbsp;6.2 of
   [RFC7231]&lt;/a&gt;) precede a final response to the same request. 

   A client that has more than one outstanding request on a connection
   MUST maintain a list of outstanding requests in the order sent and
   MUST associate each received response message on that connection to
   the highest ordered request that has not yet received a final
   (non-1xx) response.</source>
          <target state="translated">HTTP不包括用于将给定请求消息与其对应的一个或多个响应消息相关联的请求标识符。因此，它依赖于响应到达的顺序，以完全对应于在同一连接上发出请求的顺序。每个请求仅在一个或多个信息响应（1xx，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;[RFC7231]的6.2节&lt;/a&gt;）位于对同一请求的最终响应之前时，才会出现多个响应消息。在一个连接上有多个未决请求的客户端必须按发送顺序维护一个未决请求列表，并且必须将该连接上的每个接收到的响应消息与尚未收到最终请求（非1xx）的最高顺序请求相关联响应。</target>
        </trans-unit>
        <trans-unit id="125fe50c360004e5dcd111f8af56cce35d120574" translate="yes" xml:space="preserve">
          <source>HTTP does not place a predefined limit on the length of each header
   field or on the length of the header section as a whole, as described
   in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.  Various ad hoc limitations on individual header
   field length are found in practice, often depending on the specific
   field semantics.

   A server that receives a request header field, or set of fields,
   larger than it wishes to process MUST respond with an appropriate 4xx
   (Client Error) status code.  Ignoring such header fields would
   increase the server's vulnerability to request smuggling attacks
   (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;).

   A client MAY discard or truncate received header fields that are
   larger than the client wishes to process if the field semantics are
   such that the dropped value(s) can be safely ignored without changing
   the message framing or response semantics.</source>
          <target state="translated">HTTP并未对每个标头字段的长度或标头部分的整体长度进行预定义的限制，如&lt;a href=&quot;#section-2.5&quot;&gt;2.5节&lt;/a&gt;所述。在实践中，通常会根据特定的字段语义找到对各个标头字段长度的各种特殊限制。接收到大于其希望处理的请求标头字段或一组字段的服务器，必须以适当的4xx（客户端错误）状态码进行响应。忽略此类标头字段将增加服务器请求走私攻击的漏洞（&lt;a href=&quot;#section-9.5&quot;&gt;第9.5节）&lt;/a&gt;）。如果字段语义使得在不改变消息帧或响应语义的情况下可以安全地忽略丢弃的值，则客户端可以丢弃或截断大于客户端希望处理的报头字段。</target>
        </trans-unit>
        <trans-unit id="7af78e2e7197dc15cd8324e0e4f1f29b3b33d7e4" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding (CTE) field of &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways from MIME-compliant protocols to HTTP MUST
   remove any non-identity CTE (&quot;quoted-printable&quot; or &quot;base64&quot;) encoding
   prior to delivering the response message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe 

   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway SHOULD label the data with an appropriate
   Content-Transfer-Encoding if doing so will improve the likelihood of
   safe transport over the destination protocol.</source>
          <target state="translated">HTTP不使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;的Content-Transfer-Encoding（CTE）字段。从MIME兼容协议到HTTP的代理和网关必须在将响应消息传递到HTTP客户端之前，删除所有非身份CTE（&amp;ldquo; quoted-printable&amp;rdquo;或&amp;ldquo; base64&amp;rdquo;）编码。从HTTP到MIME兼容协议的代理和网关负责确保消息的格式和编码正确，以确保该协议上的安全传输，其中&amp;ldquo;安全传输&amp;rdquo;由所使用协议的限制定义。这样的代理或网关应该使用适当的Content-Transfer-Encoding标记数据，如果这样做会提高通过目标协议进行安全传输的可能性。</target>
        </trans-unit>
        <trans-unit id="983fa6dde64a744fecec4d6eaeb6ead62114677a" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP need to
   remove any Content-Transfer-Encoding prior to delivering the response
   message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe
   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway ought to transform and label the data with an
   appropriate Content-Transfer-Encoding if doing so will improve the
   likelihood of safe transport over the destination protocol.</source>
          <target state="translated">HTTP 不使用 MIME 的 Content-Transfer-Encoding 字段。从MIME兼容协议到HTTP的代理和网关需要在向HTTP客户端发送响应消息之前删除任何Content-Transfer-Encoding。从HTTP到MIME兼容协议的代理和网关负责确保消息是以正确的格式和编码在该协议上安全传输,其中 &quot;安全传输 &quot;是由正在使用的协议的限制所定义的。这样的代理或网关应该用适当的Content-Transfer-Encoding来转换和标记数据,如果这样做可以提高在目的协议上安全传输的可能性。</target>
        </trans-unit>
        <trans-unit id="b9046bf180bf7e78db825b7e37fce06636dac2f9" translate="yes" xml:space="preserve">
          <source>HTTP enables the use of intermediaries to satisfy requests through a
   chain of connections.  There are three common forms of HTTP
   intermediary: proxy, gateway, and tunnel.  In some cases, a single
   intermediary might act as an origin server, proxy, gateway, or
   tunnel, switching behavior based on the nature of each request.

            &amp;gt;             &amp;gt;             &amp;gt;             &amp;gt;
       UA =========== A =========== B =========== C =========== O
                  &amp;lt;             &amp;lt;             &amp;lt;             &amp;lt;

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server.  A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options might apply only to the connection
   with the nearest, non-tunnel neighbor, only to the endpoints of the
   chain, or to all connections along the chain.  Although the diagram
   is linear, each participant might be engaged in multiple,
   simultaneous communications.  For example, B might be receiving
   requests from many clients other than A, and/or forwarding requests
   to servers other than C, at the same time that it is handling A's 

   request.  Likewise, later requests might be sent through a different
   path of connections, often based on dynamic configuration for load
   balancing.

   The terms &quot;upstream&quot; and &quot;downstream&quot; are used to describe
   directional requirements in relation to the message flow: all
   messages flow from upstream to downstream.  The terms &quot;inbound&quot; and
   &quot;outbound&quot; are used to describe directional requirements in relation
   to the request route: &quot;inbound&quot; means toward the origin server and
   &quot;outbound&quot; means toward the user agent.

   A &quot;proxy&quot; is a message-forwarding agent that is selected by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some
   translations are minimal, such as for proxy requests for &quot;http&quot; URIs,
   whereas other requests might require translation to and from entirely
   different application-level protocols.  Proxies are often used to
   group an organization's HTTP requests through a common intermediary
   for the sake of security, annotation services, or shared caching.
   Some proxies are designed to apply transformations to selected
   messages or payloads while they are being forwarded, as described in
   &lt;a href=&quot;#section-5.7.2&quot;&gt;Section 5.7.2&lt;/a&gt;.

   A &quot;gateway&quot; (a.k.a. &quot;reverse proxy&quot;) is an intermediary that acts as
   an origin server for the outbound connection but translates received
   requests and forwards them inbound to another server or servers.
   Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   &quot;accelerator&quot; caching, and to enable partitioning or load balancing
   of HTTP services across multiple machines.

   All HTTP requirements applicable to an origin server also apply to
   the outbound communication of a gateway.  A gateway communicates with
   inbound servers using any protocol that it desires, including private
   extensions to HTTP that are outside the scope of this specification.
   However, an HTTP-to-HTTP gateway that wishes to interoperate with
   third-party HTTP servers ought to conform to user agent requirements
   on the gateway's inbound connection.

   A &quot;tunnel&quot; acts as a blind relay between two connections without
   changing the messages.  Once active, a tunnel is not considered a
   party to the HTTP communication, though the tunnel might have been
   initiated by an HTTP request.  A tunnel ceases to exist when both
   ends of the relayed connection are closed.  Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) is used to establish
   confidential communication through a shared firewall proxy. 

   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also
   intermediaries that can act on lower layers of the network protocol
   stack, filtering or redirecting HTTP traffic without the knowledge or
   permission of message senders.  Network intermediaries are
   indistinguishable (at a protocol level) from a man-in-the-middle
   attack, often introducing security flaws or interoperability problems
   due to mistakenly violating HTTP semantics.

   For example, an &quot;interception proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt;] (also commonly known
   as a &quot;transparent proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;] or &quot;captive portal&quot;) differs from
   an HTTP proxy because it is not selected by the client.  Instead, an
   interception proxy filters or redirects outgoing TCP port 80 packets
   (and occasionally other common port traffic).  Interception proxies
   are commonly found on public network access points, as a means of
   enforcing account subscription prior to allowing use of non-local
   Internet services, and within corporate firewalls to enforce network
   usage policies.

   HTTP is defined as a stateless protocol, meaning that each request
   message can be understood in isolation.  Many implementations depend
   on HTTP's stateless design in order to reuse proxied connections or
   dynamically load balance requests across multiple servers.  Hence, a
   server MUST NOT assume that two requests on the same connection are
   from the same user agent unless the connection is secured and
   specific to that agent.  Some non-standard HTTP extensions (e.g.,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt;]) have been known to violate this requirement, resulting in
   security and interoperability problems.</source>
          <target state="translated">HTTP使中间人可以通过连接链来满足请求。 HTTP中介有三种常见的形式：代理，网关和隧道。在某些情况下，单个中介可以充当源服务器，代理，网关或隧道，并根据每个请求的性质进行切换。 &amp;gt;&amp;gt;&amp;gt;&amp;gt; UA =========== A =========== B =========== C ========= == O &amp;lt;&amp;lt;&amp;lt;&amp;lt;上图显示了用户代理和原始服务器之间的三个中介（A，B和C）。遍及整个链的请求或响应消息将通过四个单独的连接。某些HTTP通信选项可能仅适用于距离最近，非隧道邻居，仅到链的端点或到链上的所有连接。尽管该图是线性的，但每个参与者都可能参与多个同时进行的通信。例如，B在处理A的请求的同时，可能正在从A以外的许多客户端接收请求，和/或将请求转发到C以外的服务器。同样，以后的请求可能会通过不同的连接路径发送，通常基于用于负载平衡的动态配置。术语&amp;ldquo;上游&amp;rdquo;和&amp;ldquo;下游&amp;rdquo;用于描述与消息流有关的方向性要求：所有消息从上游流向下游。术语&amp;ldquo;入站&amp;rdquo;和&amp;ldquo;出站&amp;rdquo;用来描述与请求路由有关的方向性要求：&amp;ldquo;入站&amp;rdquo;表示指向原始服务器，&amp;ldquo;出站&amp;rdquo;表示指向用户代理。 &amp;ldquo;代理&amp;rdquo;是消息转发代理，客户端通常通过本地配置规则选择该代理来接收对某些绝对URI类型的请求，并尝试通过HTTP接口进行转换来满足这些请求。某些转换是最少的，例如针对&amp;ldquo; http&amp;rdquo; URI的代理请求，而其他请求可能需要与完全不同的应用程序级协议进行转换。出于安全性，注释服务或共享缓存的目的，代理通常用于通过通用中介对组织的HTTP请求进行分组。某些代理旨在在转发时将转换应用于选定的消息或有效负载，如 &lt;a href=&quot;#section-5.7.2&quot;&gt;第5.7.2节&lt;/a&gt;。 &amp;ldquo;网关&amp;rdquo;（也称为&amp;ldquo;反向代理&amp;rdquo;）是充当出站连接的原始服务器，但转换接收到的请求并将其入站转发到另一个服务器的中介。网关通常用于封装旧的或不受信任的信息服务，以通过&amp;ldquo;加速器&amp;rdquo;缓存提高服务器性能，并在多台计算机之间实现HTTP服务的分区或负载平衡。适用于原始服务器的所有HTTP要求也适用于网关的出站通信。网关使用其所需的任何协议与入站服务器进行通信，包括本规范范围之外的HTTP专用扩展。然而，希望与第三方HTTP服务器进行互操作的HTTP到HTTP网关应符合网关入站连接上的用户代理要求。 &amp;ldquo;隧道&amp;rdquo;充当两个连接之间的盲中继，而不会更改消息。一旦激活，隧道就不会被视为HTTP通信的一方，尽管该隧道可能是由HTTP请求发起的。当中继连接的两端都关闭时，隧道不再存在。隧道用于通过中介扩展虚拟连接，例如在传输层安全性（TLS，[尽管隧道可能是由HTTP请求发起的，但该隧道不被视为HTTP通信的一方。当中继连接的两端都关闭时，隧道不再存在。隧道用于通过中介扩展虚拟连接，例如在传输层安全性（TLS，[尽管隧道可能是由HTTP请求发起的，但该隧道不被视为HTTP通信的一方。当中继连接的两端都关闭时，隧道不再存在。隧道用于通过中介扩展虚拟连接，例如在传输层安全性（TLS，[&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]）用于通过共享的防火墙代理建立机密通信。上面的中介类别仅考虑那些充当HTTP通信参与者的角色。还有一些中介可以在网络协议栈的较低层上起作用，无需消息发送者的了解或许可就可以过滤或重定向HTTP通信。网络中间人（在协议级别）与中间人攻击是无法区分的，由于错误地违反了HTTP语义，经常会引入安全漏洞或互操作性问题。例如，&amp;ldquo;拦截代理&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; ]（也通常称为&amp;ldquo;透明代理&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;]或&amp;ldquo;强制门户&amp;rdquo;）与HTTP代理不同，因为客户端未选择它。取而代之的是，拦截代理会过滤或重定向传出的TCP端口80数据包（有时还会重定向其他常见端口流量）。拦截代理通常在公共网络访问点上找到，作为在允许使用非本地Internet服务之前强制执行帐户订阅的方法，并且在公司防火墙内可以强制执行网络使用策略。 HTTP被定义为无状态协议，这意味着可以单独理解每个请求消息。许多实现依赖于HTTP的无状态设计，以便在多个服务器之间重用代理连接或动态负载平衡请求。因此，除非连接是安全的并且特定于该代理，否则服务器不得假定同一连接上的两个请求来自同一用户代理。一些非标准的HTTP扩展名（例如[&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;已知RFC4559&lt;/a&gt; ]）违反了此要求，从而导致安全性和互操作性问题。</target>
        </trans-unit>
        <trans-unit id="8db8a2b5c25cf2c27eaf8a47b284cc3768fbc846" translate="yes" xml:space="preserve">
          <source>HTTP flow</source>
          <target state="translated">HTTP流</target>
        </trans-unit>
        <trans-unit id="ef8491af63ac960b4c3bb2e915780d4330bd99fe" translate="yes" xml:space="preserve">
          <source>HTTP frames are now transparent to Web developers. This is an additional step in HTTP/2, between HTTP/1.1 messages and the underlying transport protocol. No changes are needed in the APIs used by Web developers to utilize HTTP frames; when available in both the browser and the server, HTTP/2 is switched on and used.</source>
          <target state="translated">HTTP框架现在对Web开发者是透明的。这是HTTP/2中的一个额外步骤,介于HTTP/1.1消息和底层传输协议之间。Web开发者利用HTTP框架所使用的API不需要改变;当浏览器和服务器都可用时,HTTP/2就会被打开并使用。</target>
        </trans-unit>
        <trans-unit id="c4d23b3cd8874c5cafac5c54211af2245465e64f" translate="yes" xml:space="preserve">
          <source>HTTP has a concept of &lt;em&gt;conditional requests&lt;/em&gt;, where the result, and even the success of a request, can be changed by comparing the affected resources with the value of a &lt;em&gt;validator&lt;/em&gt;. Such requests can be useful to validate the content of a cache, and sparing a useless control, to verify the integrity of a document, like when resuming a download, or when preventing to lose updates when uploading or modifying a document on the server.</source>
          <target state="translated">HTTP具有&lt;em&gt;条件请求&lt;/em&gt;的概念，通过比较受影响的资源和&lt;em&gt;验证器&lt;/em&gt;的值，可以更改&lt;em&gt;条件&lt;/em&gt;甚至请求的成功。这样的请求可用于验证缓存的内容，并保留无用的控件，以验证文档的完整性，例如在恢复下载时，或在服务器上上传或修改文档时防止丢失更新时。</target>
        </trans-unit>
        <trans-unit id="d453645149af5aacd6ac81b6f3d3ee73f00f71ff" translate="yes" xml:space="preserve">
          <source>HTTP has been in use since 1990.  The first version, later referred
   to as HTTP/0.9, was a simple protocol for hypertext data transfer
   across the Internet, using only a single request method (GET) and no
   metadata.  HTTP/1.0, as defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;], added a range of
   request methods and MIME-like messaging, allowing for metadata to be
   transferred and modifiers placed on the request/response semantics.
   However, HTTP/1.0 did not sufficiently take into consideration the
   effects of hierarchical proxies, caching, the need for persistent
   connections, or name-based virtual hosts.  The proliferation of
   incompletely implemented applications calling themselves &quot;HTTP/1.0&quot;
   further necessitated a protocol version change in order for two
   communicating applications to determine each other's true
   capabilities.

   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only those
   features that can either be safely ignored by an HTTP/1.0 recipient
   or only be sent when communicating with a party advertising
   conformance with HTTP/1.1.

   HTTP/1.1 has been designed to make supporting previous versions easy.
   A general-purpose HTTP/1.1 server ought to be able to understand any
   valid request in the format of HTTP/1.0, responding appropriately
   with an HTTP/1.1 message that only uses features understood (or
   safely ignored) by HTTP/1.0 clients.  Likewise, an HTTP/1.1 client
   can be expected to understand any valid HTTP/1.0 response.

   Since HTTP/0.9 did not support header fields in a request, there is
   no mechanism for it to support name-based virtual hosts (selection of
   resource by inspection of the Host header field).  Any server that
   implements name-based virtual hosts ought to disable support for
   HTTP/0.9.  Most requests that appear to be HTTP/0.9 are, in fact,
   badly constructed HTTP/1.x requests caused by a client failing to
   properly encode the request-target.</source>
          <target state="translated">HTTP自1990年以来一直在使用。第一个版本（后来称为HTTP / 0.9）是用于Internet上超文本数据传输的简单协议，仅使用单个请求方法（GET），不使用元数据。 HTTP / 1.0，由[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]，添加了一系列请求方法和类似MIME的消息传递，允许传输元数据，并在请求/响应语义上放置修饰符。但是，HTTP / 1.0没有充分考虑分层代理，缓存，对持久连接的需求或基于名称的虚拟主机的影响。称为&amp;ldquo; HTTP / 1.0&amp;rdquo;的未完全实现的应用程序的激增进一步需要更改协议版本，以便两个通信的应用程序确定彼此的真实功能。通过包含更严格的要求以实现可靠的实现，HTTP / 1.1与HTTP / 1.0保持兼容，仅添加那些可由HTTP / 1安全忽略的功能。0个收件人，或仅在与使用HTTP / 1.1进行广告宣传的一方进行通信时发送。 HTTP / 1.1旨在简化对先前版本的支持。通用HTTP / 1.1服务器应该能够理解HTTP / 1.0格式的任何有效请求，并以仅使用HTTP / 1.0客户端理解（或安全忽略）功能的HTTP / 1.1消息进行适当响应。同样，可以期望HTTP / 1.1客户端理解任何有效的HTTP / 1.0响应。由于HTTP / 0.9不支持请求中的标头字段，因此没有机制可以支持基于名称的虚拟主机（通过检查主机标头字段来选择资源）。任何实现基于名称的虚拟主机的服务器都应禁用对HTTP / 0.9的支持。大部分请求似乎是HTTP / 0。实际上，图9中的图是由于客户端未能正确编码请求目标而导致构造错误的HTTP / 1.x请求。</target>
        </trans-unit>
        <trans-unit id="d9e77166a8c6244ca9fbbd6e6d1edc2dc7a40b2e" translate="yes" xml:space="preserve">
          <source>HTTP has the ability to host programs that are executed on client
   machines.  These programs can take many forms including Web scripts,
   executables, plug-in modules, and macros in documents.  WebDAV does
   not change any of the security concerns around these programs, yet
   often WebDAV is used in contexts where a wide range of users can
   publish documents on a server.  The server might not have a close 

   trust relationship with the author that is publishing the document.
   Servers that allow clients to publish arbitrary content can usefully
   implement precautions to check that content published to the server
   is not harmful to other clients.  Servers could do this by techniques
   such as restricting the types of content that is allowed to be
   published and running virus and malware detection software on
   published content.  Servers can also mitigate the risk by having
   appropriate access restriction and authentication of users that are
   allowed to publish content to the server.</source>
          <target state="translated">HTTP具有承载在客户端机器上执行的程序的能力。这些程序可以采取多种形式,包括Web脚本、可执行文件、插件模块和文档中的宏。WebDAV并没有改变围绕这些程序的任何安全问题,然而WebDAV经常被用于广泛的用户可以在服务器上发布文档的情况下。服务器可能与发布文档的作者没有密切的信任关系。允许客户端发布任意内容的服务器可以有效地实施预防措施,以检查发布到服务器上的内容对其他客户端是否有害。服务器可以通过限制允许发布的内容类型和对发布的内容运行病毒和恶意软件检测软件等技术来实现。服务器还可以通过对允许向服务器发布内容的用户进行适当的访问限制和认证来降低风险。</target>
        </trans-unit>
        <trans-unit id="d67c4ad19745067f8e2d7649769ed21fc1c5ca16" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry located at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt;&amp;gt;, as defined by
   [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].</source>
          <target state="translated">HTTP标头字段在[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 定义的&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt; &amp;gt;中的&amp;ldquo;消息标头&amp;rdquo;注册表中注册。</target>
        </trans-unit>
        <trans-unit id="1d6d97f7196be4dd0bf90ee5372fccc2a746c5ee" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+---------------+
   | Header Field Name | Protocol | Status   | Reference     |
   +-------------------+----------+----------+---------------+
   | Connection        | http     | standard | &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;   |
   | Content-Length    | http     | standard | &lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt; |
   | Host              | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;   |
   | TE                | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;   |
   | Trailer           | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;   |
   | Transfer-Encoding | http     | standard | &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt; |
   | Upgrade           | http     | standard | &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;   |
   | Via               | http     | standard | &lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt; |
   +-------------------+----------+----------+---------------+

   Furthermore, the header field-name &quot;Close&quot; has been registered as
   &quot;reserved&quot;, since using that name as an HTTP header field might
   conflict with the &quot;close&quot; connection option of the Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Close             | http     | reserved | &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP标头字段在维护在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 的&amp;ldquo;消息标头&amp;rdquo;注册表中注册。本文档定义了以下HTTP标头字段，因此&amp;ldquo;永久消息标头字段名称&amp;rdquo;注册表已进行了相应的更新（请参见[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]）。 + ------------------- + ---------- + ---------- + ------- -------- + |标头字段名称|协议|现状参考| + ------------------- + ---------- + ---------- + ------- -------- + |连接| http |标准| &lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt; | |内容长度| http |标准| &lt;a href=&quot;#section-3.3.2&quot;&gt;第3.3.2节&lt;/a&gt; | |主持人http |标准| &lt;a href=&quot;#section-5.4&quot;&gt;第5.4节&lt;/a&gt; | | TE | http |标准| &lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt; | |拖车| http |标准| &lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt; | |传输编码| http |标准| &lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节&lt;/a&gt; | |升级| http |标准| &lt;a href=&quot;#section-6.7&quot;&gt;第6.7节&lt;/a&gt; | |通过| http |标准| &lt;a href=&quot;#section-5.7.1&quot;&gt;第5.7.1节&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- -------- +此外，标头字段名称&amp;ldquo; Close&amp;rdquo;已注册为&amp;ldquo; reserved&amp;rdquo;，因为使用该名称作为HTTP标头字段可能会与Connection标头字段的&amp;ldquo; close&amp;rdquo;连接选项冲突（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）。 + ------------------- + ---------- + ---------- + ------- ------ + |标头字段名称|协议|现状参考| + ------------------- + ---------- + ---------- + ------- ------ + |关闭| http |保留| &lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +更改控制者为：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="66ddb22b9ea74c6c2384f567cca6126c75a248f7" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | Authorization       | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | Proxy-Authenticate  | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt; |
   | Proxy-Authorization | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   | WWW-Authenticate    | http     | standard | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP标头字段在维护在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 的&amp;ldquo;消息标头&amp;rdquo;注册表中注册。本文档定义了以下HTTP标头字段，因此&amp;ldquo;永久消息标头字段名称&amp;rdquo;注册表已进行了相应的更新（请参见[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]）。 + --------------------- + ---------- + ---------- + ----- -------- + |标头字段名称|协议|现状参考| + --------------------- + ---------- + ---------- + ----- -------- + |授权| http |标准| &lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt; | |代理验证| http |标准| &lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt; | |代理授权| http |标准| &lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;| | WWW认证http |标准| &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- +更改控制者为：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="20431a45dc8eadae77ecc94ccdfbb95f3cbd8c6e" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Accept-Ranges     | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | Content-Range     | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | If-Range          | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | Range             | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP标头字段在维护在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 的&amp;ldquo;消息标头&amp;rdquo;注册表中注册。本文档定义了以下HTTP标头字段，因此已根据下面的永久注册更新了它们的关联注册表项（请参阅[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]）：+ ------------------- + ---------- + ---------- + ------------- + |标头字段名称|协议|现状参考| + ------------------- + ---------- + ---------- + ------- ------ + |接受范围| http |标准| &lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt; | |内容范围| http |标准| &lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt; | |如果范围| http |标准| &lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;| |范围| http |标准| &lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +更改控制者为：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="abd476ef3b0f23a2fb0e1c507e9aa66688224abd" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | ETag                | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | If-Match            | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | If-Modified-Since   | http     | standard | &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt; |
   | If-None-Match       | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | If-Unmodified-Since | http     | standard | &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt; |
   | Last-Modified       | http     | standard | &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP标头字段在维护在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 的&amp;ldquo;消息标头&amp;rdquo;注册表中注册。本文档定义了以下HTTP标头字段，因此已根据下面的永久注册更新了它们的关联注册表项（请参阅[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]）：+ ------------------- -+ ---------- + ---------- + ------------- + |标头字段名称|协议|现状参考| + --------------------- + ---------- + ---------- + ----- -------- + | ETag | http |标准| &lt;a href=&quot;#section-2.3&quot;&gt;第2.3节&lt;/a&gt; | |如果匹配| http |标准| &lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt; | | If-Modified-Since | http |标准| &lt;a href=&quot;#section-3.3&quot;&gt;第3.3节&lt;/a&gt;| |如果不匹配| http |标准| &lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt; | | If-Unmodified-Since | http |标准| &lt;a href=&quot;#section-3.4&quot;&gt;第3.4节&lt;/a&gt; | |最后修改| http |标准| &lt;a href=&quot;#section-2.2&quot;&gt;第2.2节&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- +更改控制者为：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ab0fef364114802e59e987c48134f247b0ff269b" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;. 

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Age               | http     | standard | &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; |
   | Cache-Control     | http     | standard | &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt; |
   | Expires           | http     | standard | &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; |
   | Pragma            | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt; |
   | Warning           | http     | standard | &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP标头字段在维护在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 的&amp;ldquo;消息标头&amp;rdquo;注册表中注册。本文档定义了以下HTTP标头字段，因此&amp;ldquo;永久消息标头字段名称&amp;rdquo;注册表已进行了相应的更新（请参见[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]）。 + ------------------- + ---------- + ---------- + ------- ------ + |标头字段名称|协议|现状参考| + ------------------- + ---------- + ---------- + ------- ------ + |年龄| http |标准| &lt;a href=&quot;#section-5.1&quot;&gt;第5.1节&lt;/a&gt; | |缓存控制| http |标准| &lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt; | |过期| http |标准| &lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;| | 语文| http | 标准| &lt;a href=&quot;#section-5.4&quot;&gt;第5.4节&lt;/a&gt; | | 警告| http | 标准| &lt;a href=&quot;#section-5.5&quot;&gt;第5.5节&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +更改控制者为：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e44fb4fb2547d4ca031836cab9543ab18adb9840" translate="yes" xml:space="preserve">
          <source>HTTP header fields which will be present in the trailer part of chunked messages. These header fields are &lt;strong&gt;disallowed&lt;/strong&gt;:</source>
          <target state="translated">HTTP标头字段，将在分块消息的尾部中显示。这些标头字段是&lt;strong&gt;不允许的&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="c4df20b3f27418d9364765f0fd87a2e34f853b85" translate="yes" xml:space="preserve">
          <source>HTTP header fields, which include general-header (&lt;a href=&quot;#section-4.5&quot;&gt;section 4.5&lt;/a&gt;),
   request-header (&lt;a href=&quot;#section-5.3&quot;&gt;section 5.3&lt;/a&gt;), response-header (&lt;a href=&quot;#section-6.2&quot;&gt;section 6.2&lt;/a&gt;), and
   entity-header (&lt;a href=&quot;#section-7.1&quot;&gt;section 7.1&lt;/a&gt;) fields, follow the same generic format as
   that given in &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Each header field consists
   of a name followed by a colon (&quot;:&quot;) and the field value. Field names
   are case-insensitive. The field value MAY be preceded by any amount
   of LWS, though a single SP is preferred. Header fields can be
   extended over multiple lines by preceding each extra line with at
   least one SP or HT. Applications ought to follow &quot;common form&quot;, where
   one is known or indicated, when generating HTTP constructs, since
   there might exist some implementations that fail to accept anything 

   beyond the common forms.

       message-header = field-name &quot;:&quot; [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = &amp;lt;the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string&amp;gt;

   The field-content does not include any leading or trailing LWS:
   linear white space occurring before the first non-whitespace
   character of the field-value or after the last non-whitespace
   character of the field-value. Such leading or trailing LWS MAY be
   removed without changing the semantics of the field value. Any LWS
   that occurs between field-content MAY be replaced with a single SP
   before interpreting the field value or forwarding the message
   downstream.

   The order in which header fields with differing field names are
   received is not significant. However, it is &quot;good practice&quot; to send
   general-header fields first, followed by request-header or response-
   header fields, and ending with the entity-header fields.

   Multiple message-header fields with the same field-name MAY be
   present in a message if and only if the entire field-value for that
   header field is defined as a comma-separated list [i.e., #(values)].
   It MUST be possible to combine the multiple header fields into one
   &quot;field-name: field-value&quot; pair, without changing the semantics of the
   message, by appending each subsequent field-value to the first, each
   separated by a comma. The order in which header fields with the same
   field-name are received is therefore significant to the
   interpretation of the combined field value, and thus a proxy MUST NOT
   change the order of these field values when a message is forwarded.</source>
          <target state="translated">HTTP报头字段，其中包括通用头（&lt;a href=&quot;#section-4.5&quot;&gt;第4.5节&lt;/a&gt;），请求头（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;），响应头（&lt;a href=&quot;#section-6.2&quot;&gt;第6.2节&lt;/a&gt;），和实体标题（&lt;a href=&quot;#section-7.1&quot;&gt;第7.1节&lt;/a&gt;）字段，遵循相同的通用格式定义在给定的&lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;第RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9的&lt;/a&gt;3.1]。每个标题字段均由名称，后跟冒号（&amp;ldquo;：&amp;rdquo;）和字段值组成。字段名称不区分大小写。字段值可以在任何数量的LWS之前，尽管首选单个SP。通过在每条额外的行之前添加至少一个SP或HT，可以将标题字段扩展到多行。在生成HTTP构造时，应用程序应遵循&amp;ldquo;通用形式&amp;rdquo;，即已知形式或表示形式，因为某些实现可能无法接受通用形式以外的任何形式。 message-header =字段名称&amp;ldquo;：&amp;rdquo; [字段值]字段名称=令牌字段值= *（字段内容| LWS）字段内容= &amp;lt;组成字段值并由* TEXT或令牌，分隔符和带引号的字符串的组合组成的OCTET&amp;gt;字段内容不包括任何前导或尾随LWS：线性空白出现在第一个非空白字符之前字段值的形式或字段值的最后一个非空白字符之后。这种前导或尾随的LWS可以在不改变字段值语义的情况下删除。在解释字段值或向下游转发消息之前，在字段内容之间发生的任何LWS都可以用单个SP替换。具有不同字段名称的头字段的接收顺序并不重要。但是，&amp;ldquo;最佳做法&amp;rdquo;是先发送通用标头字段，后跟请求标头或响应标头字段，并以实体标头字段结尾。当且仅当该报头字段的整个字段值定义为以逗号分隔的列表[即，＃（值）]时，消息中才会存在多个具有相同字段名的消息报头字段。通过将每个后续的字段值附加到第一个字段（每个字段用逗号分隔），必须在不改变消息语义的情况下将多个报头字段组合成一对&amp;ldquo;字段名称：field-value&amp;rdquo;。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。并以实体标题字段结尾。当且仅当该报头字段的整个字段值定义为以逗号分隔的列表[即，＃（值）]时，消息中才会存在多个具有相同字段名称的报头字段。通过将每个随后的字段值附加到第一个字段（每个字段用逗号分隔），必须在不改变消息语义的情况下将多个报头字段组合成一对&amp;ldquo;字段名：字段-值&amp;rdquo;。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。并以实体标题字段结尾。当且仅当该报头字段的整个字段值定义为以逗号分隔的列表[即，＃（值）]时，消息中才会存在多个具有相同字段名称的报头字段。通过将每个随后的字段值附加到第一个字段（每个字段用逗号分隔），必须在不改变消息语义的情况下，将多个头字段组合成一对&amp;ldquo;字段名：字段-值&amp;rdquo;。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。当且仅当该报头字段的整个字段值定义为以逗号分隔的列表[即，＃（值）]时，消息中才会存在多个具有相同字段名的消息报头字段。通过将每个随后的字段值附加到第一个字段（每个字段用逗号分隔），必须在不改变消息语义的情况下，将多个头字段组合成一对&amp;ldquo;字段名：字段-值&amp;rdquo;。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。当且仅当该报头字段的整个字段值定义为以逗号分隔的列表[即，＃（值）]时，消息中才会存在多个具有相同字段名称的报头字段。通过将每个后续的字段值附加到第一个字段（每个字段用逗号分隔），必须在不改变消息语义的情况下将多个报头字段组合成一对&amp;ldquo;字段名称：field-value&amp;rdquo;。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。通过将每个后续的字段值附加到第一个字段（每个字段用逗号分隔），必须在不改变消息语义的情况下将多个报头字段组合成一对&amp;ldquo;字段名称：field-value&amp;rdquo;。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。通过将每个随后的字段值附加到第一个字段（每个字段用逗号分隔），必须在不改变消息语义的情况下将多个报头字段组合成一对&amp;ldquo;字段名：字段-值&amp;rdquo;。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。因此，具有相同字段名称的报头字段的接收顺序对于组合字段值的解释很重要，因此代理在转发消息时不得更改这些字段值的顺序。</target>
        </trans-unit>
        <trans-unit id="2ee53c95b1d46b2119a03c49e611077033b4d0b3" translate="yes" xml:space="preserve">
          <source>HTTP headers</source>
          <target state="translated">HTTP头文件</target>
        </trans-unit>
        <trans-unit id="48536d1a36cdc18529d34d2b1499b1bddb33777a" translate="yes" xml:space="preserve">
          <source>HTTP headers allow the client and the server to pass additional information with the request or the response. An HTTP header consists of its case-insensitive name followed by a colon '&lt;code&gt;:&lt;/code&gt;', then by its value (without line breaks). Leading white space before the value is ignored.</source>
          <target state="translated">HTTP标头允许客户端和服务器将附加信息与请求或响应一起传递。 HTTP标头由不区分大小写的名称组成，后跟冒号' &lt;code&gt;:&lt;/code&gt; '，然后是其值（无换行符）。值前的空白将被忽略。</target>
        </trans-unit>
        <trans-unit id="8e56498c371e01a01014a24b174120a52a7628f8" translate="yes" xml:space="preserve">
          <source>HTTP headers, meta elements and language information</source>
          <target state="translated">HTTP头文件、元元素和语言信息。</target>
        </trans-unit>
        <trans-unit id="63565f85024865ce35e9904d8dab88b231490429" translate="yes" xml:space="preserve">
          <source>HTTP implementations that share code with MHTML [&lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt;]
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long
   lines.  MHTML messages being transported by HTTP follow all
   conventions of MHTML, including line length limitations and folding,
   canonicalization, etc., since HTTP transfers message-bodies as 

   payload and, aside from the &quot;multipart/byteranges&quot; type (Appendix A
   of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), does not interpret the content or any MIME header
   lines that might be contained therein.</source>
          <target state="translated">与MHTML [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt; ]实现共享代码的HTTP实现需要了解MIME行长限制。由于HTTP没有此限制，因此HTTP不会折叠长行。通过HTTP传输的MHTML消息遵循MHTML的所有约定，包括行长限制和折叠，规范化等，因为HTTP会将消息主体作为有效负载进行传输，并且除了&amp;ldquo; multipart / byteranges&amp;rdquo;类型（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]的附录A ），不会解释其中的内容或任何MIME标头行。</target>
        </trans-unit>
        <trans-unit id="de5402f673a6f75205a2fa61021e4a87fd38eaf7" translate="yes" xml:space="preserve">
          <source>HTTP implementations which share code with MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;] implementations
   need to be aware of MIME line length limitations. Since HTTP does not
   have this limitation, HTTP does not fold long lines. MHTML messages
   being transported by HTTP follow all conventions of MHTML, including
   line length limitations and folding, canonicalization, etc., since
   HTTP transports all message-bodies as payload (see &lt;a href=&quot;#section-3.7.2&quot;&gt;section 3.7.2&lt;/a&gt;) and
   does not interpret the content or any MIME header lines that might be
   contained therein.</source>
          <target state="translated">与MHTML [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt; ]实现共享代码的HTTP实现需要了解MIME行长限制。由于HTTP没有此限制，因此HTTP不会折叠长行。 HTTP传输的MHTML消息遵循MHTML的所有约定，包括行长限制和折叠，规范化等，因为HTTP 会将所有消息体都作为有效载荷进行传输（请参阅&lt;a href=&quot;#section-3.7.2&quot;&gt;第3.7.2节&lt;/a&gt;），并且不解释内容或任何MIME头其中可能包含的行。</target>
        </trans-unit>
        <trans-unit id="4924be195f30ae39945dc7a126df600856cfafd8" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710a819ac327fdfc49afc67cb5bdfc03f98d8ddc" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;Accept-&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react and how it will choose the most adequate response.</source>
          <target state="translated">HTTP引入了一组头，以 &lt;code&gt;Accept-&lt;/code&gt; 开头，这是浏览器宣布其喜欢的格式，语言或编码的一种方式。本文介绍了此广告的发生方式，服务器的预期反应以及如何选择最适当的响应。</target>
        </trans-unit>
        <trans-unit id="7bce7c5f422974cc46aee17e50fec032a864e5fe" translate="yes" xml:space="preserve">
          <source>HTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example a robot that crawls the Web to populate and maintain a search engine index.</source>
          <target state="translated">HTTP是一个客户-服务器协议:请求由一个实体发送,即用户代理(或代表它的代理)。大多数情况下,用户代理是一个网络浏览器,但它可以是任何东西,例如一个机器人,它抓取网络来填充和维护搜索引擎的索引。</target>
        </trans-unit>
        <trans-unit id="b485125423c17b1efeda78b6422f6043dbfdd69f" translate="yes" xml:space="preserve">
          <source>HTTP is a pretty extensible protocol. It relies on a few basic concepts like the notion of resources and URIs, a simple structure of messages, and a client-server structure for the communication flow. On top of these basic concepts, numerous extensions have appeared over the years, adding new functionality and new semantics by creating new HTTP methods or headers.</source>
          <target state="translated">HTTP是一个相当可扩展的协议。它依赖于一些基本的概念,比如资源和URI的概念,简单的消息结构,以及通信流的客户端-服务器结构。在这些基本概念之上,多年来出现了许多扩展,通过创建新的HTTP方法或头文件来增加新的功能和新的语义。</target>
        </trans-unit>
        <trans-unit id="1e62200cdd839db28dbcb3a764ce93c997d72428" translate="yes" xml:space="preserve">
          <source>HTTP is a stateless request/response protocol that operates by
   exchanging messages (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) across a reliable transport- or
   session-layer &quot;connection&quot; (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  An HTTP &quot;client&quot; is a
   program that establishes a connection to a server for the purpose of
   sending one or more HTTP requests.  An HTTP &quot;server&quot; is a program
   that accepts connections in order to service HTTP requests by sending
   HTTP responses.

   The terms &quot;client&quot; and &quot;server&quot; refer only to the roles that these
   programs perform for a particular connection.  The same program might
   act as a client on some connections and a server on others.  The term
   &quot;user agent&quot; refers to any of the various client programs that
   initiate a request, including (but not limited to) browsers, spiders
   (web-based robots), command-line tools, custom applications, and
   mobile apps.  The term &quot;origin server&quot; refers to the program that can
   originate authoritative responses for a given target resource.  The
   terms &quot;sender&quot; and &quot;recipient&quot; refer to any implementation that sends
   or receives a given message, respectively.

   HTTP relies upon the Uniform Resource Identifier (URI) standard
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to indicate the target resource (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) and
   relationships between resources.  Messages are passed in a format
   similar to that used by Internet mail [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;Appendix&amp;nbsp;A of
   [RFC7231]&lt;/a&gt; for the differences between HTTP and MIME messages).

   Most HTTP communication consists of a retrieval request (GET) for a
   representation of some resource identified by a URI.  In the simplest
   case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin
   server (O).

            request   &amp;gt;
       UA ======================================= O
                                   &amp;lt;   response

   A client sends an HTTP request to a server in the form of a request
   message, beginning with a request-line that includes a method, URI,
   and protocol version (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;), followed by header fields
   containing request modifiers, client information, and representation
   metadata (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the
   header section, and finally a message body containing the payload
   body (if any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;). 

   A server responds to a client's request by sending one or more HTTP
   response messages, each beginning with a status line that includes
   the protocol version, a success or error code, and textual reason
   phrase (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;), possibly followed by header fields containing
   server information, resource metadata, and representation metadata
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the header
   section, and finally a message body containing the payload body (if
   any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;).

   A connection might be used for multiple request/response exchanges,
   as defined in &lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;.

   The following example illustrates a typical message exchange for a
   GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;) on the URI
   &quot;http://www.example.com/hello.txt&quot;:

   Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi


   Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: &quot;34aa387-d-1568eb00&quot;
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World! My payload includes a trailing CRLF.</source>
          <target state="translated">HTTP是一种无状态请求/响应协议，通过在可靠的传输层或会话层&amp;ldquo;连接&amp;rdquo;（&lt;a href=&quot;#section-6&quot;&gt;第6 &lt;/a&gt;&lt;a href=&quot;#section-3&quot;&gt;节&lt;/a&gt;）之间交换消息（第3节）进行操作）。 HTTP&amp;ldquo;客户端&amp;rdquo;是一种程序，用于建立与服务器的连接，以发送一个或多个HTTP请求。 HTTP&amp;ldquo;服务器&amp;rdquo;是接受连接以便通过发送HTTP响应来服务HTTP请求的程序。术语&amp;ldquo;客户端&amp;rdquo;和&amp;ldquo;服务器&amp;rdquo;仅指这些程序为特定连接执行的角色。同一程序可能在某些连接上充当客户端，而在另一些连接上充当服务器。术语&amp;ldquo;用户代理&amp;rdquo;是指发起请求的各种客户端程序中的任何一个，包括（但不限于）浏览器，蜘蛛网（基于网络的机器人），命令行工具，自定义应用程序和移动应用程序。术语&amp;ldquo;原始服务器&amp;rdquo;指可以针对给定目标资源发起权威响应的程序。术语&amp;ldquo;发送者&amp;rdquo;和&amp;ldquo;收件人&amp;rdquo;分别是指发送或接收给定消息的任何实现。 HTTP依赖于统一资源标识符（URI）标准[&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]指示目标资源（&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节&lt;/a&gt;）和资源之间的关系。邮件以类似于Internet邮件[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ]和多用途Internet邮件扩展（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ] 的格式传递（请参阅[ RFC7231 ]的&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;附录A&lt;/a&gt;（HTTP和MIME消息之间的差异）。大多数HTTP通信都包含一个检索请求（GET），用于表示由URI标识的某些资源。在最简单的情况下，这可以通过用户代理（UA）与原始服务器（O）之间的单个双向连接（===）来实现。请求&amp;gt; UA ======================================= O &amp;lt;响应客户端发送HTTP以请求消息的形式向服务器发送请求，从包含方法，URI和协议版本的请求行开始（&lt;a href=&quot;#section-3.1.1&quot;&gt;第3.1.1节&lt;/a&gt;），然后是包含请求修饰符，客户端信息和表示元数据的标头字段（&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;），空行表示标头部分的末尾，最后是包含有效内容主体（如果有的话，&lt;a href=&quot;#section-3.3&quot;&gt;第3.3节&lt;/a&gt;）的消息主体。服务器通过发送一个或多个HTTP响应消息来响应客户端的请求，每个HTTP响应消息都以一个状态行开头，该状态行包括协议版本，成功或错误代码以及文本原因短语（&lt;a href=&quot;#section-3.1.2&quot;&gt;第3.1.2节&lt;/a&gt;），可能后跟标头字段包含服务器信息，资源元数据和表示形式元数据（&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;），用于指示标头节末尾的空行，最后是包含有效内容正文的消息正文（如果有，&lt;a href=&quot;#section-3.3&quot;&gt;第3.3节）&lt;/a&gt;）。如&lt;a href=&quot;#section-6.3&quot;&gt;第6.3节&lt;/a&gt;所定义，连接可以用于多个请求/响应交换。以下示例说明了在URI&amp;ldquo; http://www.example.com/hello.txt&amp;rdquo;上针对GET请求（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]的第4.3.1节&lt;/a&gt;）的典型消息交换：客户端请求：GET /hello.txt HTTP /1.1用户代理：curl / 7.16.3 libcurl / 7.16.3 OpenSSL / 0.9.7l zlib / 1.2.3主机：www.example.com接受语言：en，mi服务器响应：HTTP / 1.1 200 OK日期： 2009年7月27日星期一12:28:53 GMT服务器：Apache上一次修改时间：2009年7月22日星期三19:15:56 GMT ETag：&amp;ldquo; 34aa387-d-1568eb00&amp;rdquo;接受范围：字节内容长度：51变化：接受编码内容类型：文本/纯文本Hello World！我的有效载荷包括尾随CRLF。</target>
        </trans-unit>
        <trans-unit id="5cc2a6ae91625497aff3803fe93d9cda3d79e909" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that is easy to use. The client-server structure, combined with the ability to simply add headers, allows HTTP to advance along with the extended capabilities of the Web.</source>
          <target state="translated">HTTP是一个易于使用的可扩展协议。客户端-服务器的结构,加上简单添加头的能力,使得HTTP能够随着网络功能的扩展而进步。</target>
        </trans-unit>
        <trans-unit id="bbcb125f3701fe50926501831f8f7ee161444b57" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), simple message structure, and client-server communication flow. On top of these basic concepts, numerous extensions have been developed over the years that add updated functionality and semantics with new HTTP methods or headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20fa14d437b5a88c718d590e0efda20242112a2" translate="yes" xml:space="preserve">
          <source>HTTP is extensible</source>
          <target state="translated">HTTP是可扩展的</target>
        </trans-unit>
        <trans-unit id="18ad92cc7b82eb0d0efdfdb9ee61c4c2a39d270e" translate="yes" xml:space="preserve">
          <source>HTTP is generally designed to be simple and human readable, even with the added complexity introduced in HTTP/2 by encapsulating HTTP messages into frames. HTTP messages can be read and understood by humans, providing easier testing for developers, and reduced complexity for newcomers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e492d2fcbffcb461a67019008cf2c966900353b" translate="yes" xml:space="preserve">
          <source>HTTP is independent of the security model of the Web, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. In fact, the current Web security model has been developed after the creation of HTTP! Over the years, it has proved useful to be able to be more lenient, by allowing under certain constraints to lift some of the restriction of this policy. How much and when such restrictions are lifted is transmitted by the server to the client using a new bunch of HTTP headers. These are defined in specifications like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; (CORS) or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy&lt;/a&gt; (CSP).</source>
          <target state="translated">HTTP独立于Web的安全&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;策略&lt;/a&gt;，即同源策略。实际上，当前的Web安全模型是在创建HTTP之后开发的！多年来，事实证明，通过允许某些限制解除该政策的某些限制，能够更加宽容。服务器使用新的一堆HTTP标头将多少种限制以及何时解除这些限制发送给客户端。这些在诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;跨域资源共享&lt;/a&gt;（CORS）或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;内容安全策略&lt;/a&gt;（CSP）的规范中定义。</target>
        </trans-unit>
        <trans-unit id="844e92e43f2d1fe1edd17a77bc8a5a11e990e4be" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol.  However, messages can include
   a single MIME-Version header field to indicate what version of the
   MIME protocol was used to construct the message.  Use of the
   MIME-Version header field indicates that the message is in full
   conformance with the MIME protocol (as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;]).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.</source>
          <target state="translated">HTTP不是兼容MIME的协议。但是，消息可以包含单个MIME-Version头字段，以指示使用了哪个版本的MIME协议来构造消息。 MIME-Version头字段的使用表示该消息与MIME协议（如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]中所定义）完全一致。当将HTTP消息导出到严格的MIME环境时，发件人负责确保完全一致（如果可能）。</target>
        </trans-unit>
        <trans-unit id="e53f9322a91df40e55625dc45bd212cc6e3463d2" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY
   include a single MIME-Version general-header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full compliance with the MIME protocol (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;[&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]).
   Proxies/gateways are responsible for ensuring full compliance (where
   possible) when exporting HTTP messages to strict MIME environments.

       MIME-Version   = &quot;MIME-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   MIME version &quot;1.0&quot; is the default for use in HTTP/1.1. However,
   HTTP/1.1 message parsing and semantics are defined by this document
   and not the MIME specification.</source>
          <target state="translated">HTTP不是兼容MIME的协议。但是，HTTP / 1.1消息可以包含一个MIME-Version总头字段，以指示使用哪个版本的MIME协议来构造消息。使用MIME-Version头字段表示该消息完全符合MIME协议（如&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]中所定义）。将HTTP消息导出到严格的MIME环境时，代理/网关负责确保完全合规（在可能的情况下）。 MIME-Version =&amp;ldquo; MIME-Version&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1 * DIGIT&amp;ldquo;。 1 * DIGIT MIME版本&amp;ldquo; 1.0&amp;rdquo;是HTTP / 1.1中使用的默认版本。但是，HTTP / 1.1消息解析和语义是由本文档而不是MIME规范定义的。</target>
        </trans-unit>
        <trans-unit id="dca5ebedb205dfacf9266ff93c066cf81c69779d" translate="yes" xml:space="preserve">
          <source>HTTP is simple</source>
          <target state="translated">HTTP很简单</target>
        </trans-unit>
        <trans-unit id="505159632976cbe17f2844bb8f7ce15822bb5f60" translate="yes" xml:space="preserve">
          <source>HTTP is stateless, but not sessionless</source>
          <target state="translated">HTTP是无状态的,但不是无会话的</target>
        </trans-unit>
        <trans-unit id="809c123eeed8b2f5fd5ed3274c85be36e7f59d12" translate="yes" xml:space="preserve">
          <source>HTTP is stateless: there is no link between two requests being successively carried out on the same connection. This immediately has the prospect of being problematic for users attempting to interact with certain pages coherently, for example, using e-commerce shopping baskets. But while the core of HTTP itself is stateless, HTTP cookies allow the use of stateful sessions. Using header extensibility, HTTP Cookies are added to the workflow, allowing session creation on each HTTP request to share the same context, or the same state.</source>
          <target state="translated">HTTP是无状态的:在同一连接上连续执行的两个请求之间没有联系。这对于试图与某些页面进行连贯性交互的用户来说,例如,使用电子商务购物篮的用户来说,马上就会出现问题。但是,虽然HTTP本身的核心是无状态的,但HTTP cookies允许使用有状态的会话。利用头扩展性,HTTP Cookie被添加到工作流中,允许在每个HTTP请求上创建会话,以共享相同的上下文,或相同的状态。</target>
        </trans-unit>
        <trans-unit id="40096b223d68b1f8c1440bbea86dad29e675b9a1" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches.  This
   document defines aspects of HTTP/1.1 related to caching and reusing
   response messages.

   An HTTP cache is a local store of response messages and the subsystem
   that controls storage, retrieval, and deletion of messages in it.  A
   cache stores cacheable responses in order to reduce the response time
   and network bandwidth consumption on future, equivalent requests.
   Any client or server MAY employ a cache, though a cache cannot be
   used by a server that is acting as a tunnel.

   A shared cache is a cache that stores responses to be reused by more
   than one user; shared caches are usually (but not always) deployed as
   a part of an intermediary.  A private cache, in contrast, is
   dedicated to a single user; often, they are deployed as a component
   of a user agent.

   The goal of caching in HTTP/1.1 is to significantly improve
   performance by reusing a prior response message to satisfy a current
   request.  A stored response is considered &quot;fresh&quot;, as defined in
   &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;, if the response can be reused without &quot;validation&quot;
   (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh response can therefore
   reduce both latency and network overhead each time it is reused.
   When a cached response is not fresh, it might still be reusable if it
   can be freshened by validation (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) or if the origin is
   unavailable (&lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">HTTP通常用于分布式信息系统，其中可以通过使用响应缓存来提高性能。本文档定义了与缓存和重用响应消息有关的HTTP / 1.1的各个方面。 HTTP缓存是响应消息的本地存储，是控制其中消息的存储，检索和删除的子系统。缓存存储可缓存的响应，以减少响应时间和未来等效请求的网络带宽消耗。任何客户端或服务器都可以使用缓存，尽管充当隧道的服务器不能使用缓存。共享缓存是一种缓存，用于存储要由多个用户重用的响应。共享缓存通常（但不总是）作为中介的一部分进行部署。相比之下，专用缓存专用于单个用户；通常，它们被部署为用户代理的组件。 HTTP / 1.1中缓存的目标是通过重用先前的响应消息来满足当前请求，从而显着提高性能。根据定义，存储的响应被认为是&amp;ldquo;新的&amp;rdquo; &lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt;，如果可以在没有&amp;ldquo;验证&amp;rdquo;的情况下重用响应（请与原始服务器进行检查，以了解缓存的响应是否对该请求仍然有效）。因此，每次重新使用响应时，新响应都可以减少延迟和网络开销。如果缓存的响应不是新鲜的，则可以通过验证（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）对其进行刷新，或者如果原始不可用（&lt;a href=&quot;#section-4.2.4&quot;&gt;第4.2.4 &lt;/a&gt;节），则该响应仍可以重用。</target>
        </trans-unit>
        <trans-unit id="bc0cee4ed0cc389fa445e5f9f96d84585ff6e837" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. The
   HTTP/1.1 protocol includes a number of elements intended to make
   caching work as well as possible. Because these elements are
   inextricable from other aspects of the protocol, and because they
   interact with each other, it is useful to describe the basic caching
   design of HTTP separately from the detailed descriptions of methods,
   headers, response codes, etc.

   Caching would be useless if it did not significantly improve
   performance. The goal of caching in HTTP/1.1 is to eliminate the need
   to send requests in many cases, and to eliminate the need to send
   full responses in many other cases. The former reduces the number of
   network round-trips required for many operations; we use an
   &quot;expiration&quot; mechanism for this purpose (see &lt;a href=&quot;#section-13.2&quot;&gt;section 13.2&lt;/a&gt;). The
   latter reduces network bandwidth requirements; we use a &quot;validation&quot;
   mechanism for this purpose (see &lt;a href=&quot;#section-13.3&quot;&gt;section 13.3&lt;/a&gt;).

   Requirements for performance, availability, and disconnected
   operation require us to be able to relax the goal of semantic
   transparency. The HTTP/1.1 protocol allows origin servers, caches, 

   and clients to explicitly reduce transparency when necessary.
   However, because non-transparent operation may confuse non-expert
   users, and might be incompatible with certain server applications
   (such as those for ordering merchandise), the protocol requires that
   transparency be relaxed

      - only by an explicit protocol-level request when relaxed by
        client or origin server

      - only with an explicit warning to the end user when relaxed by
        cache or client

   Therefore, the HTTP/1.1 protocol provides these important elements:

      1. Protocol features that provide full semantic transparency when
         this is required by all parties.

      2. Protocol features that allow an origin server or user agent to
         explicitly request and control non-transparent operation.

      3. Protocol features that allow a cache to attach warnings to
         responses that do not preserve the requested approximation of
         semantic transparency.

   A basic principle is that it must be possible for the clients to
   detect any potential relaxation of semantic transparency.

      Note: The server, cache, or client implementor might be faced with
      design decisions not explicitly discussed in this specification.
      If a decision might affect semantic transparency, the implementor
      ought to err on the side of maintaining transparency unless a
      careful and complete analysis shows significant benefits in
      breaking transparency.</source>
          <target state="translated">HTTP通常用于分布式信息系统，其中可以通过使用响应缓存来提高性能。 HTTP / 1.1协议包含许多旨在使缓存尽可能正常工作的元素。因为这些元素与协议的其他方面是不可分割的，并且彼此相互作用，所以与方法，标头，响应代码等的详细描述分开描述HTTP的基本缓存设计很有用。缓存将是无用的如果没有显着提高性能。 HTTP / 1.1中缓存的目的是在许多情况下消除发送请求的需要，在许多其他情况下消除发送完整的响应的需要。前者减少了许多操作所需的网络往返次数；为此，我们使用了&amp;ldquo;到期&amp;rdquo;机制（请参见&lt;a href=&quot;#section-13.2&quot;&gt;第13.2节&lt;/a&gt;）。后者降低了网络带宽需求；为此，我们使用&amp;ldquo;验证&amp;rdquo;机制（请参阅&lt;a href=&quot;#section-13.3&quot;&gt;第13.3节&lt;/a&gt;）。对性能，可用性和非连续操作的要求要求我们能够放宽语义透明性的目标。 HTTP / 1.1协议允许原始服务器，缓存和客户端在必要时显式降低透明度。但是，由于非透明操作可能会使非专家用户感到困惑，并且可能与某些服务器应用程序（例如用于订购商品的服务器应用程序）不兼容，因此该协议要求放宽透明度-仅当放宽操作时才通过显式协议级请求客户端或原始服务器-仅在缓存或客户端放宽时才向最终用户发出明确警告，因此HTTP / 1.1协议提供了以下重要元素：1。协议功能可在所有各方都需要时提供完全的语义透明性。 2.允许源服务器或用户代理显式请求和控制非透明操作的协议功能。 3.允许高速缓存将警告附加到响应的协议功能，这些响应未保留所请求的语义透明性近似值。基本原则是，客户端必须有可能检测到语义透明性的任何潜在松弛。注意：服务器，缓存或客户端实现者可能会面临本规范中未明确讨论的设计决策。如果决定可能会影响语义透明性，实施者应该在保持透明性方面犯错误，除非经过仔细而完整的分析显示出打破透明性的显着益处。</target>
        </trans-unit>
        <trans-unit id="ee5bd85f6de02476bff1ddc097b7f7447096c5a2" translate="yes" xml:space="preserve">
          <source>HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web
   browsers.

   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;], and a target resource upon which to apply those
   semantics.  A URI reference (&lt;a href=&quot;#section-2.7&quot;&gt;Section 2.7&lt;/a&gt;) is typically used as an 

   identifier for the &quot;target resource&quot;, which a user agent would
   resolve to its absolute form in order to obtain the &quot;target URI&quot;.
   The target URI excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;).</source>
          <target state="translated">HTTP被用于从通用计算机到家用电器的各种应用程序中。在某些情况下，通信选项被硬编码在客户端的配置中。但是，大多数HTTP客户端依赖与通用Web浏览器相同的资源标识机制和配置技术。 HTTP通信是由用户代理出于某种目的而发起的。目的是将[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 中定义的请求语义与应用这些语义的目标资源结合在一起。 URI参考（&lt;a href=&quot;#section-2.7&quot;&gt;第2.7节&lt;/a&gt;）通常用作&amp;ldquo;目标资源&amp;rdquo;的标识符，用户代理会将其解析为其绝对形式以获得&amp;ldquo;目标URI&amp;rdquo;。目标URI排除了引用的片段组件（如果有的话），因为片段标识符是为客户端处理保留的（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986]，第3.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="14fc3ba32d80ac4a60cf241e5c4400241293ff7f" translate="yes" xml:space="preserve">
          <source>HTTP message headers are used to describe a resource, or the behavior of the server or the client. Custom proprietary headers can be added using the &lt;code&gt;X-&lt;/code&gt; prefix; others in an &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA registry&lt;/a&gt;, whose original content was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt;. IANA also maintains a &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;registry of proposed new HTTP message headers&lt;/a&gt;.</source>
          <target state="translated">HTTP消息头用于描述资源或服务器或客户端的行为。可以使用 &lt;code&gt;X-&lt;/code&gt; 前缀添加自定义专有头。他人在&lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA注册表中&lt;/a&gt;，其原始内容中定义&lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt;。IANA还维护&lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;建议的新HTTP消息头&lt;/a&gt;的注册表。</target>
        </trans-unit>
        <trans-unit id="2638b56fdde689e585c5bdfb740cd6d868d52464" translate="yes" xml:space="preserve">
          <source>HTTP messages are composed of textual information encoded in ASCII, and span over multiple lines. In HTTP/1.1, and earlier versions of the protocol, these messages were openly sent across the connection. In HTTP/2, the once human-readable message is now divided up into HTTP frames, providing optimization and performance improvements.</source>
          <target state="translated">HTTP消息由ASCII编码的文本信息组成,并跨越多行。在HTTP/1.1以及协议的早期版本中,这些消息是通过连接公开发送的。在HTTP/2中,曾经人类可读的消息现在被分成了HTTP帧,提供了优化和性能改进。</target>
        </trans-unit>
        <trans-unit id="118d6001c735751f3c84aa7e43184e1a5916e130" translate="yes" xml:space="preserve">
          <source>HTTP messages are how data is exchanged between a server and a client. There are two types of messages: &lt;em&gt;requests&lt;/em&gt; sent by the client to trigger an action on the server, and &lt;em&gt;responses&lt;/em&gt;, the answer from the server.</source>
          <target state="translated">HTTP消息是服务器和客户端之间如何交换数据的方式。有两种类型的消息：&lt;em&gt;请求&lt;/em&gt;客户端发送到触发服务器上的动作，并且&lt;em&gt;响应&lt;/em&gt;，从服务器的答案。</target>
        </trans-unit>
        <trans-unit id="2f6109f653584ed6dc3dfe16c53952b62bfd3c70" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="translated">HTTP消息是使用HTTP的关键;它们的结构简单,而且具有高度的可扩展性。HTTP/2框架机制在HTTP/1.x语法和底层传输协议之间增加了一个新的中间层,而没有从根本上修改它:建立在成熟的机制之上。</target>
        </trans-unit>
        <trans-unit id="891aa548a3155a7bc116f727c4c9e489c435ed0b" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple, and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167bf47970009cc8e263d7f95620e5a732a4503a" translate="yes" xml:space="preserve">
          <source>HTTP messages consist of requests from client to server and responses
   from server to client.

       HTTP-message   = Request | Response     ; HTTP/1.1 messages

   Request (&lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;) and Response (&lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;) messages use the generic
   message format of &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] for transferring entities (the payload
   of the message). Both types of message consist of a start-line, zero
   or more header fields (also known as &quot;headers&quot;), an empty line (i.e.,
   a line with nothing preceding the CRLF) indicating the end of the
   header fields, and possibly a message-body.

        generic-message = start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line

   In the interest of robustness, servers SHOULD ignore any empty
   line(s) received where a Request-Line is expected. In other words, if
   the server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, it should ignore the CRLF.

   Certain buggy HTTP/1.0 client implementations generate extra CRLF's
   after a POST request. To restate what is explicitly forbidden by the
   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an
   extra CRLF.</source>
          <target state="translated">HTTP消息包括从客户端到服务器的请求和从服务器到客户端的响应。HTTP消息=请求| 反应; HTTP / 1.1消息&amp;ldquo;请求&amp;rdquo;（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）和&amp;ldquo;响应&amp;rdquo;（&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）消息使用&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;的通用消息格式。]用于传输实体（消息的有效负载）。两种类型的消息都由一个起始行，零个或多个标头字段（也称为&amp;ldquo;标头&amp;rdquo;），一个空行（即在CRLF之前没有任何内容的行）以及标头字段的结尾组成。邮件正文。 generic-message =起始行*（message-header CRLF）CRLF [message-body]起始行=请求行|状态行为了鲁棒性，服务器应该忽略在预期有请求行的情况下收到的任何空行。换句话说，如果服务器在消息开头读取协议流并首先接收到CRLF，则服务器应忽略该CRLF。某些错误的HTTP / 1。0个客户端实现在POST请求后生成额外的CRLF。为了重述BNF明确禁止的内容，HTTP / 1.1客户端务必不得在请求前或之后加上额外的CRLF。</target>
        </trans-unit>
        <trans-unit id="a514b96da0b4952018a9659e3ae2424d71abef2e" translate="yes" xml:space="preserve">
          <source>HTTP messages, as defined in HTTP/1.1 and earlier, are human-readable. In HTTP/2, these messages are embedded into a binary structure, a &lt;em&gt;frame&lt;/em&gt;, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e792736752047fb0b0f5fa09841f2859bfcdc55a" translate="yes" xml:space="preserve">
          <source>HTTP messaging is independent of the underlying transport- or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.

   As described in &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;, the specific connection protocols to be
   used for an HTTP interaction are determined by client configuration
   and the target URI.  For example, the &quot;http&quot; URI scheme
   (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) indicates a default connection of TCP over IP, with a
   default TCP port of 80, but the client might be configured to use a
   proxy via some other connection, port, or protocol. 

   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections,
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.  Most clients maintain
   multiple connections in parallel, including more than one connection
   per server endpoint.  Most servers are designed to maintain thousands
   of concurrent connections, while controlling request queues to enable
   fair use and detect denial-of-service attacks.</source>
          <target state="translated">HTTP消息传递独立于基础传输层或会话层连接协议。 HTTP仅假定可靠传输，并且按顺序传递请求和相应的按顺序传递响应。 HTTP请求和响应结构到基础传输协议的数据单元上的映射超出了本规范的范围。如&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;所述，用于HTTP交互的特定连接协议由客户端配置和目标URI决定。例如，&amp;ldquo; http&amp;rdquo; URI方案（&lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节&lt;/a&gt;）表示TCP over IP的默认连接，默认TCP端口为80，但客户端可能配置为通过其他连接，端口或协议使用代理。期望HTTP实现能够参与连接管理，包括维持当前连接的状态，建立新连接或重用现有连接，处理在连接上接收到的消息，检测连接失败以及关闭每个连接。大多数客户端并行维护多个连接，每个服务器端点包括多个连接。大多数服务器旨在维护数千个并发连接，同时控制请求队列以实现合理使用和检测拒绝服务攻击。</target>
        </trans-unit>
        <trans-unit id="a512b6978afa758b64c87ca8fb2b859560321f57" translate="yes" xml:space="preserve">
          <source>HTTP method registrations MUST include the following fields:

   o  Method Name (see &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;)

   o  Safe (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;)

   o  Idempotent (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">HTTP方法注册必须包括以下字段：o方法名称（请参阅&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;）o安全（&amp;ldquo;是&amp;rdquo;或&amp;ldquo;否&amp;rdquo;，请参阅&lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt;）o幂等（&amp;ldquo;是&amp;rdquo;或&amp;ldquo;否&amp;rdquo;，请参阅&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节）&lt;/a&gt;）o指向规范文本的指针要添加到此命名空间的值需要IETF审核（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226]，第4.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7962f2b4e2fb00149a92feb9ef354150c4b8364c" translate="yes" xml:space="preserve">
          <source>HTTP methods</source>
          <target state="translated">HTTP方法</target>
        </trans-unit>
        <trans-unit id="16b2633fc11a6a9453f446495015f632c3dba72e" translate="yes" xml:space="preserve">
          <source>HTTP mostly relies on TCP for its transport protocol, providing a connection between the client and the server. In its infancy, HTTP used a single model to handle such connections. These connections were short-lived: a new one created each time a request needed sending, and closed once the answer had been received.</source>
          <target state="translated">HTTP主要依靠TCP作为传输协议,提供客户端和服务器之间的连接。在其初期,HTTP使用一个单一的模型来处理这种连接。这些连接是短暂的:每次需要发送请求时,都会创建一个新的连接,一旦收到应答就会关闭。</target>
        </trans-unit>
        <trans-unit id="e6523763c79c318a3d3099179709a1159fa699ff" translate="yes" xml:space="preserve">
          <source>HTTP pipelining</source>
          <target state="translated">HTTP管道化</target>
        </trans-unit>
        <trans-unit id="c04bfd419ae2ca3a5245f7e1492aab6d7596ed0e" translate="yes" xml:space="preserve">
          <source>HTTP pipelining is not activated by default in modern browsers:</source>
          <target state="translated">在现代浏览器中,HTTP pipelining默认情况下没有被激活。</target>
        </trans-unit>
        <trans-unit id="0912d51b43dfca3b2cf9646a999e4cef417cee1d" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and
   authentication, via an extensible set of challenge-response
   authentication schemes, which can be used by a server to challenge a
   client request and by a client to provide authentication information.
   This document defines HTTP/1.1 authentication in terms of the
   architecture defined in &quot;Hypertext Transfer Protocol (HTTP/1.1):
   Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], including the general
   framework previously described in &quot;HTTP Authentication: Basic and
   Digest Access Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] and the related fields and
   status codes previously defined in &quot;Hypertext Transfer Protocol --
   HTTP/1.1&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   The IANA Authentication Scheme Registry (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) lists
   registered authentication schemes and their corresponding
   specifications, including the &quot;basic&quot; and &quot;digest&quot; authentication
   schemes previously defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.</source>
          <target state="translated">HTTP通过一组可扩展的质询-响应认证方案，提供了用于访问控制和认证的通用框架，服务器可以使用质询-响应认证方案来质询客户端请求，客户端可以使用它来提供认证信息。本文档根据&amp;ldquo;超文本传输​​协议（HTTP / 1.1）：消息语法和路由&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]中定义的体系结构定义HTTP / 1.1身份验证，包括先前在&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo;中描述的通用框架。 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]以及先前在&amp;ldquo;超文本传输​​协议-HTTP / 1.1&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]中定义的相关字段和状态代码。IANA认证方案注册中心（ &lt;a href=&quot;#section-5.1&quot;&gt;第5.1节）&lt;/a&gt;）列出了注册的身份验证方案及其相应的规范，包括先前由&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;定义的&amp;ldquo;基本&amp;rdquo;和&amp;ldquo;摘要&amp;rdquo;身份验证方案。</target>
        </trans-unit>
        <trans-unit id="7885aa462dbdfaf51f0c394e3808399fbb15bff6" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. The most common HTTP authentication is based on the &quot;Basic&quot; schema. This page shows an introduction to the HTTP framework for authentication and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="translated">HTTP提供了一个访问控制和认证的一般框架。最常见的HTTP认证是基于 &quot;Basic &quot;模式的。本页介绍了HTTP认证框架,并展示了如何使用HTTP &quot;Basic &quot;模式限制对服务器的访问。</target>
        </trans-unit>
        <trans-unit id="f0b556a167d090c37ed069f694278c1d0f8c8b55" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. This page is an introduction to the HTTP framework for authentication, and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbb32950149f0405fef2566ee545e5f42986bc6" translate="yes" xml:space="preserve">
          <source>HTTP provides a simple challenge-response authentication framework
   that can be used by a server to challenge a client request and by a
   client to provide authentication information.  It uses a case-
   insensitive token as a means to identify the authentication scheme,
   followed by additional information necessary for achieving 

   authentication via that scheme.  The latter can be either a comma-
   separated list of parameters or a single sequence of characters
   capable of holding base64-encoded information.

   Authentication parameters are name=value pairs, where the name token
   is matched case-insensitively, and each parameter name MUST only
   occur once per challenge.

     auth-scheme    = token

     auth-param     = token BWS &quot;=&quot; BWS ( token / quoted-string )

     token68        = 1*( ALPHA / DIGIT /
                          &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;

   The token68 syntax allows the 66 unreserved URI characters
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]), plus a few others, so that it can hold a base64,
   base64url (URL and filename safe alphabet), base32, or base16 (hex)
   encoding, with or without padding, but excluding whitespace
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]).

   A 401 (Unauthorized) response message is used by an origin server to
   challenge the authorization of a user agent, including a
   WWW-Authenticate header field containing at least one challenge
   applicable to the requested resource.

   A 407 (Proxy Authentication Required) response message is used by a
   proxy to challenge the authorization of a client, including a
   Proxy-Authenticate header field containing at least one challenge
   applicable to the proxy for the requested resource.

     challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

      Note: Many clients fail to parse a challenge that contains an
      unknown scheme.  A workaround for this problem is to list well-
      supported schemes (such as &quot;basic&quot;) first.

   A user agent that wishes to authenticate itself with an origin server
   -- usually, but not necessarily, after receiving a 401 (Unauthorized)
   -- can do so by including an Authorization header field with the
   request.

   A client that wishes to authenticate itself with a proxy -- usually,
   but not necessarily, after receiving a 407 (Proxy Authentication
   Required) -- can do so by including a Proxy-Authorization header
   field with the request. 

   Both the Authorization field value and the Proxy-Authorization field
   value contain the client's credentials for the realm of the resource
   being requested, based upon a challenge received in a response
   (possibly at some point in the past).  When creating their values,
   the user agent ought to do so by selecting the challenge with what it
   considers to be the most secure auth-scheme that it understands,
   obtaining credentials from the user as appropriate.  Transmission of
   credentials within header field values implies significant security
   considerations regarding the confidentiality of the underlying
   connection, as described in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;.

     credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

   Upon receipt of a request for a protected resource that omits
   credentials, contains invalid credentials (e.g., a bad password) or
   partial credentials (e.g., when the authentication scheme requires
   more than one round trip), an origin server SHOULD send a 401
   (Unauthorized) response that contains a WWW-Authenticate header field
   with at least one (possibly new) challenge applicable to the
   requested resource.

   Likewise, upon receipt of a request that omits proxy credentials or
   contains invalid or partial proxy credentials, a proxy that requires
   authentication SHOULD generate a 407 (Proxy Authentication Required)
   response that contains a Proxy-Authenticate header field with at
   least one (possibly new) challenge applicable to the proxy.

   A server that receives valid credentials that are not adequate to
   gain access ought to respond with the 403 (Forbidden) status code
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;Section&amp;nbsp;6.5.3 of [RFC7231]&lt;/a&gt;).

   HTTP does not restrict applications to this simple challenge-response
   framework for access authentication.  Additional mechanisms can be
   used, such as authentication at the transport level or via message
   encapsulation, and with additional header fields specifying
   authentication information.  However, such additional mechanisms are
   not defined by this specification.</source>
          <target state="translated">HTTP提供了一个简单的质询-响应认证框架，服务器可以使用它来质询客户端请求，客户端可以使用它来提供认证信息。它使用不区分大小写的令牌作为识别身份验证方案的方式，然后是通过该方案实现身份验证所需的其他信息。后者可以是逗号分隔的参数列表，也可以是能够保存base64编码信息的单个字符序列。身份验证参数是&amp;ldquo;名称=值&amp;rdquo;对，其中名称令牌不区分大小写地匹配，并且每个参数名称每次挑战仅应出现一次。 auth-scheme =令牌auth-param =令牌BWS&amp;ldquo; =&amp;rdquo;BWS（令牌/带引号的字符串）token68 = 1 *（ALPHA / DIGIT /&amp;ldquo;-&amp;rdquo; /&amp;ldquo;。&amp;rdquo; /&amp;ldquo; _&amp;rdquo; /&amp;ldquo;〜&amp;rdquo; /&amp;ldquo; +&amp;rdquo; /&amp;ldquo; /&amp;rdquo;）*&amp;ldquo; =&amp;rdquo; token68语法允许66个未保留的URI字符（[&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]），以及其他一些名称，因此它可以保留base64，base64url（URL和文件名安全字母），base32或base16（十六进制）编码，并带有或不带有填充，但不包括空格（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]）。原始服务器使用401（未经授权）响应消息来质询用户代理的授权，包括WWW-Authenticate标头字段，其中包含至少一个适用于所请求资源的质询。代理使用407（需要代理身份验证）响应消息来质询客户端的授权，包括一个Proxy-Authenticate标头字段，其中包含至少一个适用于所请求资源的代理的质询。 Challenge = auth-scheme [1 * SP（token68 /＃auth-param）]注意：许多客户端无法解析包含未知方案的质询。解决此问题的方法是首先列出受支持的方案（例如&amp;ldquo;基本&amp;rdquo;）。希望通过原始服务器进行身份验证的用户代理-通常，但不一定会这样，在收到401（未经授权）后，可以在请求中包含一个Authorization标头字段。希望使用代理进行身份验证的客户端（通常但并非必须如此，在收到407（需要代理身份验证）之后）可以通过在请求中包含Proxy-Authorization标头字段来实现。根据响应中收到的质询（可能是在过去的某个时间点），Authorization字段值和Proxy-Authorization字段值都包含客户端对所请求资源领域的凭据。在创建他们的价值时，用户代理应该通过选择挑战，以其认为是自己了解的最安全的身份验证方案来做到这一点，并适当地从用户那里获取凭据。头字段值内凭据的传输意味着有关基础连接的机密性的重要安全考虑，如&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;。凭证= auth-scheme [1 * SP（token68 /＃auth-param）]在收到对忽略凭证的受保护资源的请求后，包含无效凭证（例如，错误的密码）或部分凭证（例如，当进行身份验证时）方案需要多次往返），原始服务器应发送401（未经授权）响应，该响应包含WWW-Authenticate标头字段，其中至少包含一个（可能是新的）质询适用于请求的资源。同样，在收到忽略代理证书或包含无效或部分代理证书的请求后，需要身份验证的代理应生成407（要求代理身份验证）响应，该响应包含具有至少一个（可能是新的）代理身份验证标头字段适用于代理的挑战。收到不足以获取访问权限的有效凭据的服务器应使用403（禁止）状态代码（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;[RFC7231]的6.5.3节&lt;/a&gt;）。 HTTP并不将应用程序限制为用于访问身份验证的简单质询-响应框架。可以使用其他机制，例如在传输级别或通过消息封装进行身份验证，并使用其他头字段指定身份验证信息。但是，此规范未定义此类其他机制。</target>
        </trans-unit>
        <trans-unit id="373942ad0bad321a26d1a83f0200afd58d5697de" translate="yes" xml:space="preserve">
          <source>HTTP provides several OPTIONAL challenge-response authentication
   mechanisms which can be used by a server to challenge a client
   request and by a client to provide authentication information. The
   general framework for access authentication, and the specification of
   &quot;basic&quot; and &quot;digest&quot; authentication, are specified in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. This
   specification adopts the definitions of &quot;challenge&quot; and &quot;credentials&quot;
   from that specification.</source>
          <target state="translated">HTTP提供了几种可选的质询响应身份验证机制，服务器可以使用这些质询机制来质询客户端请求，客户端可以使用这些机制来提供身份验证信息。访问身份验证的通用框架以及&amp;ldquo;基本&amp;rdquo;和&amp;ldquo;摘要&amp;rdquo;身份验证的规范在&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]中指定。本规范采用该规范中&amp;ldquo;挑战&amp;rdquo;和&amp;ldquo;凭证&amp;rdquo;的定义。</target>
        </trans-unit>
        <trans-unit id="a37a5613d3d5d4214d5abfa3246a8f2754483f2a" translate="yes" xml:space="preserve">
          <source>HTTP range requests allow to send only a portion of an HTTP message from a server to a client. Partial requests are useful for large media or downloading files with pause and resume functions, for example.</source>
          <target state="translated">HTTP范围请求允许只从服务器向客户端发送HTTP消息的一部分。部分请求对于大型媒体或下载具有暂停和恢复功能的文件很有用,例如。</target>
        </trans-unit>
        <trans-unit id="f0381d73cd3211cb7f1d5c958b65d38f42cff6af" translate="yes" xml:space="preserve">
          <source>HTTP redirects always execute first &amp;mdash; they exist when there is not even a transmitted page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5389896e588834f2b24421a83cb0356215da18cf" translate="yes" xml:space="preserve">
          <source>HTTP redirects are always executed first when there is not even a page transmitted, and of course not even read.</source>
          <target state="translated">在连一个页面都没有传输的情况下,HTTP重定向总是先执行,当然连读都没有。</target>
        </trans-unit>
        <trans-unit id="7fcfef93fd3c40ba7ae279fc8feebbaed226cca1" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the best way to create redirections, but sometimes you don't have control over the server. In that case, try a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with its &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;Refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will go to the indicated URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b493de0ada593e9de6d698d017989888be7557a7" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the preferred way to create redirections, but sometimes the Web developer doesn't have control over the server or cannot configure it. For these specific cases, the Web developers can craft an HTML page with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element and the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will find this element and will go to the indicated page.</source>
          <target state="translated">HTTP重定向是创建重定向的首选方法，但是Web开发人员有时无法控制服务器或无法对其进行配置。对于这些特定情况，Web开发人员可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素和设置为在页面的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt; &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; &lt;/a&gt;中 &lt;code&gt;refresh&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 属性来制作HTML 页面。显示页面时，浏览器将找到此元素，然后转到指示的页面。</target>
        </trans-unit>
        <trans-unit id="40e98c57f45ddbbd1f7fd8fe0e605fd5413464d7" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two other methods: HTML redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and JavaScript redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;.</source>
          <target state="translated">HTTP重定向不是定义重定向的唯一方法。还有其他两种方法：使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素的HTML重定向和使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM的&lt;/a&gt; JavaScript重定向。</target>
        </trans-unit>
        <trans-unit id="862c8627d2b4f34ae450a4e001c8246586866cf8" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two others:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f59fe5f8bdc78024da5c64132db3a21db48277" translate="yes" xml:space="preserve">
          <source>HTTP referer on Wikipedia</source>
          <target state="translated">维基百科上的HTTP引用器</target>
        </trans-unit>
        <trans-unit id="7695bd9fd17d8eeddb124e64ff2e516e51ad7340" translate="yes" xml:space="preserve">
          <source>HTTP relies on the notion of an authoritative response: a response
   that has been determined by (or at the direction of) the authority
   identified within the target URI to be the most appropriate response
   for that request given the state of the target resource at the time
   of response message origination.  Providing a response from a
   non-authoritative source, such as a shared cache, is often useful to
   improve performance and availability, but only to the extent that the
   source can be trusted or the distrusted response can be safely used.

   Unfortunately, establishing authority can be difficult.  For example,
   phishing is an attack on the user's perception of authority, where
   that perception can be misled by presenting similar branding in 

   hypertext, possibly aided by userinfo obfuscating the authority
   component (see &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  User agents can reduce the impact of
   phishing attacks by enabling users to easily inspect a target URI
   prior to making an action, by prominently distinguishing (or
   rejecting) userinfo when present, and by not sending stored
   credentials and cookies when the referring document is from an
   unknown or untrusted source.

   When a registered name is used in the authority component, the &quot;http&quot;
   URI scheme (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) relies on the user's local name resolution
   service to determine where it can find authoritative responses.  This
   means that any attack on a user's network host table, cached names,
   or name resolution libraries becomes an avenue for attack on
   establishing authority.  Likewise, the user's choice of server for
   Domain Name Service (DNS), and the hierarchy of servers from which it
   obtains resolution results, could impact the authenticity of address
   mappings; DNS Security Extensions (DNSSEC, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt;]) are one way to
   improve authenticity.

   Furthermore, after an IP address is obtained, establishing authority
   for an &quot;http&quot; URI is vulnerable to attacks on Internet Protocol
   routing.

   The &quot;https&quot; scheme (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) is intended to prevent (or at
   least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated TLS connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]).
   Correctly implementing such verification can be difficult (see
   [&lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]).</source>
          <target state="translated">HTTP依赖于权威响应的概念：在目标URI当时给定的状态下，由目标URI中标识的权限（或在该方向上确定）的响应是对该请求最合适的响应响应消息来源。提供来自非授权源（例如共享缓存）的响应通常对提高性能和可用性很有用，但是仅在可以信任源或可以安全使用不信任响应的范围内。不幸的是，建立权威可能很困难。例如，网络钓鱼是对用户对权威的感知的攻击，在这种感知中，可以通过在超文本中显示类似的品牌来误导该感知，可能是由于userinfo混淆了授权组件（请参阅&lt;a href=&quot;#section-2.7.1&quot;&gt;2.7.1节&lt;/a&gt;）。用户代理可以通过使用户能够在执行操作之前轻松检查目标URI，显着地区分（或拒绝）用户信息（如果存在）以及在引用文档来自某个参考文档时不发送存储的凭据和cookie，来减少网络钓鱼攻击的影响。来源不明或不受信任。在授权组件中使用注册名称时，将使用&amp;ldquo; http&amp;rdquo; URI方案（&lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节）&lt;/a&gt;）依靠用户的本地名称解析服务来确定可以在哪里找到权威响应。这意味着对用户网络主机表，缓存的名称或名称解析库的任何攻击都将成为攻击建立授权的途径。同样，用户对域名服务（DNS）服务器的选择以及从中获取解析结果的服务器层次结构可能会影响地址映射的真实性。 DNS安全扩展（DNSSEC，[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt; ]）是一种提高真实性的方法。此外，在获取IP地址之后，建立&amp;ldquo; http&amp;rdquo; URI的权限很容易受到Internet协议路由的攻击。 &amp;ldquo; https&amp;rdquo;方案（&lt;a href=&quot;#section-2.7.2&quot;&gt;第2.7.2节&lt;/a&gt;）旨在防止（或至少揭示出）许多对建立授权机构的潜在攻击，只要已协商的TLS连接受到保护并且客户端正确地验证通信服务器的身份与目标URI的授权机构相匹配（请参阅[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; ]） 。正确实施此类验证可能很困难（请参阅[ &lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt; ]）。</target>
        </trans-unit>
        <trans-unit id="9f50e4941b29dd7e65e26b2c2ee8f27fd3643197" translate="yes" xml:space="preserve">
          <source>HTTP relies on underlying transport protocols to provide message
   confidentiality when that is desired.  HTTP has been specifically
   designed to be independent of the transport protocol, such that it
   can be used over many different forms of encrypted connection, with
   the selection of such transports being identified by the choice of
   URI scheme or within user agent configuration.

   The &quot;https&quot; scheme can be used to identify resources that require a
   confidential connection, as described in &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;.</source>
          <target state="translated">HTTP依赖底层的传输协议在需要时提供消息机密性。HTTP已专门设计为独立于传输协议，因此可以通过许多不同形式的加密连接使用HTTP，并且可以通过选择URI方案或在用户代理配置中识别此类传输。如&lt;a href=&quot;#section-2.7.2&quot;&gt;第2.7.2节&lt;/a&gt;所述，&amp;ldquo; https&amp;rdquo;方案可用于标识需要机密连接的资源。</target>
        </trans-unit>
        <trans-unit id="5cfd05af6cff4f10fa13fcdf1e53531e0f64c32a" translate="yes" xml:space="preserve">
          <source>HTTP request message routing is determined by each client based on
   the target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the
   client.</source>
          <target state="translated">HTTP请求消息路由由每个客户端根据目标资源、客户端的代理配置以及建立或重用入站连接来决定。相应的响应路由按照相同的连接链回到客户端。</target>
        </trans-unit>
        <trans-unit id="2c8a5e9aaefc55ae6f8b58628a6a46daf09140bd" translate="yes" xml:space="preserve">
          <source>HTTP request methods</source>
          <target state="translated">HTTP请求方法</target>
        </trans-unit>
        <trans-unit id="13dd6cb8837a7e513f219955d516b3e87a62005c" translate="yes" xml:space="preserve">
          <source>HTTP requests are messages sent by the client to initiate an action on the server. Their &lt;em&gt;start-line&lt;/em&gt; contain three elements:</source>
          <target state="translated">HTTP请求是客户端发送的消息，用于在服务器上启动操作。它们的&lt;em&gt;起始行&lt;/em&gt;包含三个元素：</target>
        </trans-unit>
        <trans-unit id="914464e25e17836661d23d43c1739c512c319a50" translate="yes" xml:space="preserve">
          <source>HTTP requests, and responses, share similar structure and are composed of:</source>
          <target state="translated">HTTP请求和响应,有着相似的结构,由以下几部分组成。</target>
        </trans-unit>
        <trans-unit id="baed8872df40013bfa5b06f559f07e0a29344282" translate="yes" xml:space="preserve">
          <source>HTTP response codes indicate whether a specific HTTP request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirections, client errors, and servers errors.</source>
          <target state="translated">HTTP响应代码表示特定的HTTP请求是否已经成功完成。响应分为五类:信息响应、成功响应、重定向、客户端错误和服务器错误。</target>
        </trans-unit>
        <trans-unit id="0e68989f0a2de628c6a35155870120ca03c2f18a" translate="yes" xml:space="preserve">
          <source>HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">HTTP响应头字段指示用户代理为一个原点存储报告端点。</target>
        </trans-unit>
        <trans-unit id="9bae5d05ad944fb1e294a99bcffd4e35229e257f" translate="yes" xml:space="preserve">
          <source>HTTP response status codes</source>
          <target state="translated">HTTP响应状态码</target>
        </trans-unit>
        <trans-unit id="b57d1200b41d22a049735dbac8f54f4cf988cf0d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c76e508f304e725a4ab9639fbe06b8e54f58b4d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirects, client errors, and servers errors. Status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;.</source>
          <target state="translated">HTTP响应状态代码指示特定的&lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt;请求是否已成功完成。响应分为五类：信息响应，成功响应，重定向，客户端错误和服务器错误。状态代码由&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;RFC 2616的第10节&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="b5a6f42d4f42646541a1cb9ef004b15fc1e9d233" translate="yes" xml:space="preserve">
          <source>HTTP retrieval requests using conditional or unconditional GET
   methods MAY request one or more sub-ranges of the entity, instead of
   the entire entity, using the Range request header, which applies to
   the entity returned as the result of the request:

      Range = &quot;Range&quot; &quot;:&quot; ranges-specifier 

   A server MAY ignore the Range header. However, HTTP/1.1 origin
   servers and intermediate caches ought to support byte ranges when
   possible, since Range supports efficient recovery from partially
   failed transfers, and supports efficient partial retrieval of large
   entities.

   If the server supports the Range header and the specified range or
   ranges are appropriate for the entity:

      - The presence of a Range header in an unconditional GET modifies
        what is returned if the GET is otherwise successful. In other
        words, the response carries a status code of 206 (Partial
        Content) instead of 200 (OK).

      - The presence of a Range header in a conditional GET (a request
        using one or both of If-Modified-Since and If-None-Match, or
        one or both of If-Unmodified-Since and If-Match) modifies what
        is returned if the GET is otherwise successful and the
        condition is true. It does not affect the 304 (Not Modified)
        response returned if the conditional is false.

   In some cases, it might be more appropriate to use the If-Range
   header (see &lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) in addition to the Range header.

   If a proxy that supports ranges receives a Range request, forwards
   the request to an inbound server, and receives an entire entity in
   reply, it SHOULD only return the requested range to its client. It
   SHOULD store the entire received response in its cache if that is
   consistent with its cache allocation policies.</source>
          <target state="translated">使用条件或无条件GET方法的HTTP检索请求可以使用Range请求标头，而不是整个实体，请求实体的一个或多个子范围，该范围适用于作为请求结果返回的实体：Range =&amp;ldquo; Range &amp;ldquo;&amp;rdquo;：&amp;ldquo; ranges-specifier服务器可以忽略Range标头。但是，HTTP / 1.1源服务器和中间缓存应尽可能支持字节范围，因为Range支持从部分失败的传输中进行有效恢复，并支持大型实体的有效部分检索。如果服务器支持Range标头，并且指定的范围适用于该实体：-如果GET成功，则无条件GET中存在Range标头会修改返回的内容。换句话说，响应中携带的状态码为206（部分内容），而不是200（确定）。 -条件GET中存在Range标头（使用If-Modified-Since和If-None-Match中的一个或两个，或者使用If-Unmodified-Since和If-Match中的一个或两个的请求）修改返回的内容如果GET成功，则条件为true。如果条件为假，它不会影响返回的304（未修改）响应。在某些情况下，使用If-Range标头可能更合适（请参见如果GET成功，且条件为true，则If-Unmodified-Since和If-Match中的一个或两个都将修改返回的内容。如果条件为假，它不会影响返回的304（未修改）响应。在某些情况下，使用If-Range标头可能更合适（请参见如果GET成功，且条件为true，则If-Unmodified-Since和If-Match中的一个或两个都将修改返回的内容。如果条件为假，它不会影响返回的304（未修改）响应。在某些情况下，使用If-Range标头可能更合适（请参见&lt;a href=&quot;#section-14.27&quot;&gt;第14.27节&lt;/a&gt;）以及Range标头。如果支持范围的代理接收到一个范围请求，将该请求转发到入站服务器，并收到整个实体作为回应，则它应该只将请求的范围返回给它的客户端。如果应该将整个接收到的响应与其缓存分配策略一致，则应将其存储在其缓存中。</target>
        </trans-unit>
        <trans-unit id="764bdb74b95275c85a8d7aa1fe3fe82d3d5e9d0f" translate="yes" xml:space="preserve">
          <source>HTTP status: &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/202&quot;&gt;&lt;code&gt;202&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">HTTP状态：&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/202&quot;&gt; &lt;code&gt;202&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e2aaa2653ba0ee26b576dfaebf0854b040cb7a" translate="yes" xml:space="preserve">
          <source>HTTP tunneling</source>
          <target state="translated">HTTP隧道</target>
        </trans-unit>
        <trans-unit id="269219e381ce4221eb783ce2498c82ac2c3eba0d" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet Media Types [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;] in the Content-Type (&lt;a href=&quot;#section-14.17&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;) header fields in order to provide
   open and extensible data typing and type negotiation.

       media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
       type           = token
       subtype        = token

   Parameters MAY follow the type/subtype in the form of attribute/value
   pairs (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

   The type, subtype, and parameter attribute names are case-
   insensitive. Parameter values might or might not be case-sensitive,
   depending on the semantics of the parameter name. Linear white space
   (LWS) MUST NOT be used between the type and subtype, nor between an
   attribute and its value. The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry. 

   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations SHOULD only use media type parameters when they are
   required by that type/subtype definition.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). The media type registration process is
   outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]. Use of non-registered media types is
   discouraged.</source>
          <target state="translated">HTTP 在Content-Type（&lt;a href=&quot;#section-14.17&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17 &lt;/a&gt;节）和Accept（&lt;a href=&quot;#section-14.1&quot;&gt;第14.1节&lt;/a&gt;）标头字段中使用Internet媒体类型[ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]，以提供开放的和可扩展的数据类型以及类型协商。 media-type =类型&amp;ldquo; /&amp;rdquo;子类型*（&amp;ldquo;;&amp;rdquo;参数）type =标记子类型=标记参数可以属性/值对的形式遵循类型/子类型（如&lt;a href=&quot;#section-3.6&quot;&gt;3.6节中&lt;/a&gt;所定义））。类型，子类型和参数属性名称不区分大小写。参数值可能区分大小写，也可能不区分大小写，具体取决于参数名称的语义。不能在类型和子类型之间，属性及其值之间使用线性空格（LWS）。参数的存在与否对媒体类型的处理可能很重要，具体取决于媒体类型注册表中的参数定义。请注意，某些较旧的HTTP应用程序无法识别媒体类型参数。在将数据发送到较旧的HTTP应用程序时，实现应仅在该类型/子类型定义要求使用媒体类型参数时使用。媒体类型值已向互联网号码分配机构（IANA [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]）。&lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]中概述了媒体类型注册过程。不鼓励使用未注册的媒体类型。</target>
        </trans-unit>
        <trans-unit id="b80bb07a4e60213a6bb04971b80d505cc84d5109" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet media types [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] in the Content-Type
   (&lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;) header fields in order
   to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.

     media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
     type       = token
     subtype    = token

   The type/subtype MAY be followed by parameters in the form of
   name=value pairs.

     parameter      = token &quot;=&quot; ( token / quoted-string ) 

   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on
   the semantics of the parameter name.  The presence or absence of a
   parameter might be significant to the processing of a media-type,
   depending on its definition within the media type registry.

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string.  The quoted
   and unquoted values are equivalent.  For example, the following
   examples are all equivalent, but the first is preferred for
   consistency:

     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset=&quot;utf-8&quot;
     text/html; charset=&quot;utf-8&quot;

   Internet media types ought to be registered with IANA according to
   the procedures defined in [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;].

      Note: Unlike some similar constructs in other header fields, media
      type parameters do not allow whitespace (even &quot;bad&quot; whitespace)
      around the &quot;=&quot; character.</source>
          <target state="translated">HTTP 在Content-Type（&lt;a href=&quot;#section-3.1.1.5&quot;&gt;第3.1.1.5节&lt;/a&gt;）和Accept（&lt;a href=&quot;#section-5.3.2&quot;&gt;第5.3.2 &lt;/a&gt;节）中使用Internet媒体类型[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]）标头字段，以提供开放且可扩展的数据类型输入和类型协商。媒体类型定义了数据格式和各种处理模型：如何根据接收数据的每个上下文来处理数据。媒体类型=类型&amp;ldquo; /&amp;rdquo;子类型*（OWS&amp;ldquo;;&amp;rdquo; OWS参数）类型=标记子类型=标记类型/子类型后可以跟着名称=值对形式的参数。 parameter =令牌&amp;ldquo; =&amp;rdquo;（token / quoted-string）类型，子类型和参数名称令牌不区分大小写。参数值可能区分大小写，也可能不区分大小写，具体取决于参数名称的语义。参数的存在与否对于媒体类型的处理可能很重要，取决于其在媒体类型注册表中的定义。与令牌产生匹配的参数值可以作为令牌或在带引号的字符串中传输。带引号和不带引号的值是等效的。例如，以下示例都是等效的，但为了保持一致性，首选第一个示例：text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset =&amp;ldquo; utf-8&amp;rdquo; text / html ; charset =&amp;ldquo; utf-8&amp;rdquo; Internet媒体类型应根据[但为了保持一致性，首选第一个：text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset =&amp;ldquo; utf-8&amp;rdquo; text / html; charset =&amp;ldquo; utf-8&amp;rdquo; Internet媒体类型应根据[但为了保持一致性，首选第一个：text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset =&amp;ldquo; utf-8&amp;rdquo; text / html; charset =&amp;ldquo; utf-8&amp;rdquo; Internet媒体类型应根据[&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]。注意：与其他标头字段中的某些类似构造不同，媒体类型参数不允许在&amp;ldquo; =&amp;rdquo;字符周围使用空格（甚至是&amp;ldquo;坏&amp;rdquo;空格）。</target>
        </trans-unit>
        <trans-unit id="aa6f0f90fa306d4b1ed46d12bd83446d94bb910c" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol.  This specification defines version &quot;1.1&quot;.  The
   protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification of HTTP. 

   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message.  HTTP-version is case-sensitive.

     HTTP-version  = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
     HTTP-name     = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive

   The HTTP version number consists of two decimal digits separated by a
   &quot;.&quot; (period or decimal point).  The first digit (&quot;major version&quot;)
   indicates the HTTP messaging syntax, whereas the second digit (&quot;minor
   version&quot;) indicates the highest minor version within that major
   version to which the sender is conformant and able to understand for
   future communication.  The minor version advertises the sender's
   communication capabilities even when the sender is only using a
   backwards-compatible subset of the protocol, thereby letting the
   recipient know that more advanced features can be used in response
   (by servers) or in future requests (by clients).

   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]
   or a recipient whose version is unknown, the HTTP/1.1 message is
   constructed such that it can be interpreted as a valid HTTP/1.0
   message if all of the newer features are ignored.  This specification
   places recipient-version requirements on some new features so that a
   conformant sender will only use compatible features until it has
   determined, through configuration or the receipt of a message, that
   the recipient supports HTTP/1.1.

   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default behavior
   of a recipient in the absence of such a field can change.  Unless
   specified otherwise, header fields defined in HTTP/1.1 are defined
   for all versions of HTTP/1.x.  In particular, the Host and Connection
   header fields ought to be implemented by all HTTP/1.x implementations
   whether or not they advertise conformance with HTTP/1.1.

   New header fields can be introduced without changing the protocol
   version if their defined semantics allow them to be safely ignored by
   recipients that do not recognize them.  Header field extensibility is
   discussed in &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;.

   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) MUST send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to
   blindly forward the first line of an HTTP message without ensuring
   that the protocol version in that message matches a version to which
   that intermediary is conformant for both the receiving and sending of
   messages.  Forwarding an HTTP message without rewriting the 

   HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what
   features are safe to use for later communication with that sender.

   A client SHOULD send a request version equal to the highest version
   to which the client is conformant and whose major version is no
   higher than the highest version supported by the server, if this is
   known.  A client MUST NOT send a version to which it is not
   conformant.

   A client MAY send a lower request version if it is known that the
   server incorrectly implements the HTTP specification, but only after
   the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., Server) that
   the server improperly handles higher request versions.

   A server SHOULD send a response version equal to the highest version
   to which the server is conformant that has a major version less than
   or equal to the one received in the request.  A server MUST NOT send
   a version to which it is not conformant.  A server can send a 505
   (HTTP Version Not Supported) response if it wishes, for any reason,
   to refuse service of the client's major protocol version.

   A server MAY send an HTTP/1.0 response to a request if it is known or
   suspected that the client incorrectly implements the HTTP
   specification and is incapable of correctly processing later version
   responses, such as when a client fails to parse the version number
   correctly or when an intermediary is known to blindly forward the
   HTTP-version even when it doesn't conform to the given minor version
   of the protocol.  Such protocol downgrades SHOULD NOT be performed
   unless triggered by specific client attributes, such as when one or
   more of the request header fields (e.g., User-Agent) uniquely match
   the values sent by a client known to be in error.

   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.
   However, the minor version was not incremented for the changes
   introduced between [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], and this revision has
   specifically avoided any such changes to the protocol.

   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient SHOULD process the message as if
   it were in the highest minor version within that major version to
   which the recipient is conformant.  A recipient can assume that a 

   message with a higher minor version, when sent to a recipient that
   has not yet indicated support for that higher version, is
   sufficiently backwards-compatible to be safely processed by any
   implementation of the same major version.</source>
          <target state="translated">HTTP使用&amp;ldquo; &amp;lt;major&amp;gt;。&amp;lt;minor&amp;gt;&amp;rdquo;编号方案来指示协议的版本。该规范定义了版本&amp;ldquo; 1.1&amp;rdquo;。总体而言，协议版本指示发送方是否符合该版本的相应HTTP规范中列出的一组要求。 HTTP消息的版本由消息第一行中的HTTP版本字段指示。 HTTP版本区分大小写。 HTTP版本= HTTP名称&amp;ldquo; /&amp;rdquo; DIGIT&amp;ldquo;。 DIGIT HTTP名称=％x48.54.54.50; &amp;ldquo; HTTP&amp;rdquo;，区分大小写HTTP版本号由两个小数点组成，中间用&amp;ldquo;。&amp;rdquo;分隔。 （句点或小数点）。第一位数字（&amp;ldquo;主要版本&amp;rdquo;）表示HTTP消息传递语法，而第二个数字（&amp;ldquo;次要版本&amp;rdquo;）表示发件人符合并能够理解以供将来通信的那个主要版本中的最高次要版本。即使发件人仅使用协议的向后兼容子集，次版本也可以通告该发件人的通信功能，从而使收件人知道可以在响应（服务器）或将来的请求（客户端）中使用更多高级功能。 。当HTTP / 1.1消息发送到HTTP / 1.0收件人时[即使发送方仅使用协议的向后兼容子集，也具有通信能力，从而使接收方知道可以在响应（服务器）或将来的请求（客户端）中使用更多高级功能。当HTTP / 1.1消息发送到HTTP / 1.0收件人时[即使发送方仅使用协议的向后兼容子集，也具有通信能力，从而使接收方知道可以在响应（服务器）或将来的请求（客户端）中使用更多高级功能。当HTTP / 1.1消息发送到HTTP / 1.0收件人时[&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]或版本未知的收件人，构造HTTP / 1.1消息，以便在忽略所有较新功能的情况下将其解释为有效的HTTP / 1.0消息。该规范对一些新功能提出了接收者版本的要求，以便一致的发送者将仅使用兼容的功能，直到它通过配置或消息接收确定接收者支持HTTP / 1.1。尽管相同的主要HTTP版本的次要版本之间，标头字段的解释不会更改，但是在没有此类字段的情况下收件人的默认行为可能会更改。除非另有说明，否则将为HTTP / 1.x的所有版本定义HTTP / 1.1中定义的标头字段。特别是，Host和Connection标头字段应该由所有HTTP / 1.x实现实现，无论它们是否宣传与HTTP / 1.1的一致性。如果新标头字段的定义语义允许不识别它们的接收者安全地忽略它们，则可以在不更改协议版本的情况下引入新标头字段。标头字段可扩展性在&lt;a href=&quot;#section-3.2.1&quot;&gt;第3.2.1节&lt;/a&gt;。处理HTTP消息的中介（即，除充当隧道的中介以外的所有中介）必须在转发的消息中发送其自己的HTTP版本。换句话说，不允许他们盲目转发HTTP消息的第一行，而不确保该消息中的协议版本与该中间件在接收和发送消息时都符合的版本相匹配。当下游收件人使用消息发送者的版本来确定哪些功能可安全用于以后与该发送者进行通信时，转发HTTP消息而不重写HTTP版本可能会导致通信错误。客户端应该发送一个请求版本，该版本等于该客户端符合的最高版本，并且其主要版本不高于服务器支持的最高版本（如果已知）。客户不得发送不符合的版本。如果已知服务器错误地实现了HTTP规范，则客户端可以发送较低的请求版本，但是仅在客户端尝试了至少一个正常请求并从响应状态代码或标头字段（例如，服务器）确定该客户端请求之后，客户端才可以发送较低的请求版本。服务器不正确地处理更高的请求版本。服务器应该发送一个响应版本，该响应版本等于该服务器所遵循的最高版本，该版本的主版本小于或等于请求中接收到的主版本。服务器不得发送与其不一致的版本。如果服务器出于任何原因希望拒绝客户的主要协议版本的服务，则可以发送505（不支持HTTP版本）响应。如果已知或怀疑客户端错误地实现了HTTP规范并且不能正确处理更高版本的响应，例如当客户端无法正确解析版本号或何时客户端，服务器可以发送对请求的HTTP / 1.0响应。众所周知，即使中介不符合给定的次要版本，它也会盲目转发HTTP版本。除非由特定的客户端属性触发（例如，当一个或多个请求标头字段（例如，用户代理）唯一匹配已知错误的客户端发送的值。 HTTP的版本设计的目的是，仅当引入了不兼容的消息语法时，才会增加主号码，并且仅当对协议进行的更改具有增加消息语义或暗示其他附加内容的作用时，才会增加次要号码。发送者的功能。但是，次版本并未因[并且仅当对协议所做的更改具有增加消息语义或暗示发送方其他功能的作用时，次要编号才会增加。但是，次版本并未因[并且仅当对协议所做的更改具有增加消息语义或暗示发送方其他功能的作用时，次要编号才会增加。但是，次版本并未因[&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;和[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]，并且此修订特别避免了对协议的任何此类更改。当接收到一条HTTP消息，该消息带有接收者实现的主要版本号，但其次要版本号高于接收者实现的次要版本号时，接收者应像处理该消息的主要版本中的最高次要版本一样处理该消息。收件人是合格的。收件人可以假定具有较高次要版本的消息发送给尚未指示对该较高版本支持的收件人时，具有足够的向后兼容性，可以由同一主要版本的任何实现安全地处理。</target>
        </trans-unit>
        <trans-unit id="d3a5b43c3101b03cd5693da68dc42b80224e0a29" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender to indicate the format of a message and its capacity for
   understanding further HTTP communication, rather than the features
   obtained via that communication. No change is made to the version
   number for the addition of message components which do not affect
   communication behavior or which only add to extensible field values.
   The &amp;lt;minor&amp;gt; number is incremented when the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, but which may add to the message semantics and imply
   additional capabilities of the sender. The &amp;lt;major&amp;gt; number is
   incremented when the format of a message within the protocol is
   changed. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;] for a fuller explanation. 

   The version of an HTTP message is indicated by an HTTP-Version field
   in the first line of the message.

       HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   Note that the major and minor numbers MUST be treated as separate
   integers and that each MAY be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and
   MUST NOT be sent.

   An application that sends a request or response message that includes
   HTTP-Version of &quot;HTTP/1.1&quot; MUST be at least conditionally compliant
   with this specification. Applications that are at least conditionally
   compliant with this specification SHOULD use an HTTP-Version of
   &quot;HTTP/1.1&quot; in their messages, and MUST do so for any message that is
   not compatible with HTTP/1.0. For more details on when to send
   specific HTTP-Version values, see &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;].

   The HTTP version of an application is the highest HTTP version for
   which the application is at least conditionally compliant.

   Proxy and gateway applications need to be careful when forwarding
   messages in protocol versions different from that of the application.
   Since the protocol version indicates the protocol capability of the
   sender, a proxy/gateway MUST NOT send a message with a version
   indicator which is greater than its actual version. If a higher
   version request is received, the proxy/gateway MUST either downgrade
   the request version, or respond with an error, or switch to tunnel
   behavior.

   Due to interoperability problems with HTTP/1.0 proxies discovered
   since the publication of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;[&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], caching proxies MUST, gateways
   MAY, and tunnels MUST NOT upgrade the request to the highest version
   they support. The proxy/gateway's response to that request MUST be in
   the same major version as the request.

      Note: Converting between versions of HTTP may involve modification
      of header fields required or forbidden by the versions involved.</source>
          <target state="translated">HTTP使用&amp;ldquo; &amp;lt;major&amp;gt;。&amp;lt;minor&amp;gt;&amp;rdquo;编号方案来指示协议的版本。协议版本控制策略旨在允许发送方指示消息的格式及其理解进一步HTTP通信的能力，而不是指示通过该通信获得的功能。对于添加消息组件的版本号不会做任何更改，这些消息组件不会影响通信行为或仅添加到可扩展的字段值。当对协议所做的更改添加了不更改常规消息解析算法但可以增加消息语义并暗示发送方其他功能的功能时，&amp;lt;minor&amp;gt;号将增加。 &amp;lt;主要&amp;gt;当协议中消息的格式改变时，数字增加。看到&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;]进行更详细的说明。 HTTP消息的版本由消息第一行中的HTTP-Version字段指示。 HTTP版本=&amp;ldquo; HTTP&amp;rdquo;&amp;ldquo; /&amp;rdquo; 1 * DIGIT&amp;ldquo;。 1 * DIGIT注意，必须将主数字和次数字视为单独的整数，并且每个数字都可以递增到高于一位数字。因此，HTTP / 2.4的版本低于HTTP / 2.13的版本，而HTTP / 2.13的版本又低于HTTP / 12.3。接收者必须忽略前导零，并且不得发送前导零。发送包含&amp;ldquo; HTTP / 1.1&amp;rdquo;的HTTP版本的请求或响应消息的应用程序必须至少有条件地符合此规范。至少有条件地符合此规范的应用程序应使用HTTP版本&amp;ldquo; HTTP / 1.1&amp;rdquo;在他们的消息中，对于与HTTP / 1.0不兼容的任何消息，都必须这样做。有关何时发送特定HTTP版本值的更多详细信息，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt; ]。应用程序的HTTP版本是该应用程序至少有条件兼容的最高HTTP版本。代理和网关应用程序在转发与应用程序协议版本不同的协议版本的消息时需要小心。由于协议版本指示发送者的协议能力，因此代理/网关不得发送消息，该消息的版本指示符应大于其实际版本。如果收到更高版本的请求，则代理/网关必须降级请求的版本，或响应错误，或切换到隧道行为。由于自&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;发布以来发现的HTTP / 1.0代理的互操作性问题[ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]，缓存代理必须，网关可以和隧道不得将请求升级到其支持的最高版本。代理/网关对该请求的响应必须与该请求使用相同的主要版本。注意：在HTTP版本之间进行转换可能涉及修改所涉及版本所需或禁止的标头字段。</target>
        </trans-unit>
        <trans-unit id="de9ea4b9303de1ca70c1a8e05822b3b34b2bc2c1" translate="yes" xml:space="preserve">
          <source>HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA &quot;Character Sets&quot;
   registry (&amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;&amp;gt;) according
   to the procedures defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt;].</source>
          <target state="translated">HTTP使用字符集名称来指示或协商文本表示形式的字符编码方案[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]。字符集由不区分大小写的标记标识。charset =令牌应根据[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt; ]中定义的过程，在IANA&amp;ldquo;字符集&amp;rdquo;注册表（&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt; &amp;gt;）中注册字符集名称。</target>
        </trans-unit>
        <trans-unit id="f64b344cb46f8dc4aefac27a98f9f8e7568e4d7b" translate="yes" xml:space="preserve">
          <source>HTTP uses the same definition of the term &quot;character set&quot; as that
   described for MIME: 

   The term &quot;character set&quot; is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters may
   be available in a given character set and a character set may provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name MUST fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.

      Note: This use of the term &quot;character set&quot; is more commonly
      referred to as a &quot;character encoding.&quot; However, since HTTP and
      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;].

       charset = token

   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;] MUST represent the character set defined
   by that registry. Applications SHOULD limit their use of character
   sets to those defined by the IANA registry.

   Implementors should be aware of IETF character set requirements [&lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt;]
   [&lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt;].</source>
          <target state="translated">HTTP使用与MIME相同的术语&amp;ldquo;字符集&amp;rdquo;定义：本文档中使用的术语&amp;ldquo;字符集&amp;rdquo;是指与一个或多个表一起使用的将八位位组序列转换为八位位组序列的方法。字符。注意，不需要另一个方向的无条件转换，因为在给定的字符集中并非所有字符都可用，并且字符集可以提供一个以上的八位位组序列来表示特定字符​​。此定义旨在允许各种字符编码，从简单的单表映射（例如US-ASCII）到复杂的表切换方法（例如使用ISO-2022的技术）。然而，与MIME字符集名称关联的定义必须完全指定要执行的从八位字节到字符的映射。特别是，不允许使用外部配置文件信息来确定确切的映射。注意：术语&amp;ldquo;字符集&amp;rdquo;的这种用法通常被称为&amp;ldquo;字符编码&amp;rdquo;。但是，由于HTTP和MIME共享同一个注册表，因此也必须共享该术语，这一点很重要。 HTTP字符集由不区分大小写的标记标识。完整的令牌集由IANA字符集注册表[通常被称为&amp;ldquo;字符编码&amp;rdquo;。但是，由于HTTP和MIME共享同一个注册表，因此也必须共享该术语，这一点很重要。 HTTP字符集由不区分大小写的标记标识。完整的令牌集由IANA字符集注册表[通常被称为&amp;ldquo;字符编码&amp;rdquo;。但是，由于HTTP和MIME共享同一个注册表，因此也必须共享该术语，这一点很重要。 HTTP字符集由不区分大小写的标记标识。完整的令牌集由IANA字符集注册表[&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]。 charset =令牌尽管HTTP允许将任意令牌用作字符集值，但IANA字符集注册表[ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ] 中具有预定义值的任何令牌都必须表示该注册表定义的字符集。应用程序应将其字符集的使用限制为IANA注册中心定义的字符集。实施者应了解IETF字符集要求[ &lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt; ] [ &lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="4998cbc56519b60012d9ddef5a93ab40ac390988" translate="yes" xml:space="preserve">
          <source>HTTP was created for the World Wide Web (WWW) architecture and has
   evolved over time to support the scalability needs of a worldwide
   hypertext system.  Much of that architecture is reflected in the
   terminology and syntax productions used to define HTTP.</source>
          <target state="translated">HTTP是为万维网(WWW)架构而创建的,并随着时间的推移不断发展,以支持全球超文本系统的可扩展性需求。这一架构在很大程度上反映在用于定义HTTP的术语和语法产品中。</target>
        </trans-unit>
        <trans-unit id="40aed2983145eadb2c78a80757cda404bbec1b9e" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2 as well as minor novelties introduced over the years.</source>
          <target state="translated">HTTP创建于20世纪90年代初,曾多次扩展。本文介绍了HTTP/0.9、HTTP/1.0、HTTP/1.1和现代HTTP/2的历史,以及多年来引入的一些小的新技术。</target>
        </trans-unit>
        <trans-unit id="6691219872cf8222b135471124cba8cce6315df4" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2, as well as novelties introduced over the years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8847a48bfa3a8070b11a550d8e6423fe9a938e29" translate="yes" xml:space="preserve">
          <source>HTTP was first specified in the early 1990s. Designed with extensibility in mind, it has seen numerous additions over the years; this lead to its specification being scattered through numerous specification documents (in the midst of experimental abandoned extensions). This page lists relevant resources about HTTP.</source>
          <target state="translated">HTTP在20世纪90年代初首次被指定。在设计时考虑到了可扩展性,多年来,它经历了无数次的添加;这导致它的规范分散在许多规范文档中(在实验性的废弃扩展中)。本页列出了有关HTTP的相关资源。</target>
        </trans-unit>
        <trans-unit id="c36d6fae868bc13b893908c5f64cbe8e452543ec" translate="yes" xml:space="preserve">
          <source>HTTP's approach to error handling has been explained.  (&lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;)

   The HTTP-version ABNF production has been clarified to be case-
   sensitive.  Additionally, version numbers have been restricted to
   single digits, due to the fact that implementations are known to
   handle multi-digit version numbers incorrectly.  (&lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;)

   Userinfo (i.e., username and password) are now disallowed in HTTP and
   HTTPS URIs, because of security issues related to their transmission
   on the wire.  (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;)

   The HTTPS URI scheme is now defined by this specification;
   previously, it was done in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;Section&amp;nbsp;2.4 of [RFC2818]&lt;/a&gt;.  Furthermore, it
   implies end-to-end security.  (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;)

   HTTP messages can be (and often are) buffered by implementations;
   despite it sometimes being available as a stream, HTTP is
   fundamentally a message-oriented protocol.  Minimum supported sizes
   for various protocol elements have been suggested, to improve
   interoperability.  (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;)

   Invalid whitespace around field-names is now required to be rejected,
   because accepting it represents a security vulnerability.  The ABNF
   productions defining header fields now only list the field value.
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   Rules about implicit linear whitespace between certain grammar
   productions have been removed; now whitespace is only allowed where
   specifically defined in the ABNF.  (&lt;a href=&quot;#section-3.2.3&quot;&gt;Section 3.2.3&lt;/a&gt;)

   Header fields that span multiple lines (&quot;line folding&quot;) are
   deprecated.  (&lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;)

   The NUL octet is no longer allowed in comment and quoted-string text,
   and handling of backslash-escaping in them has been clarified.  The
   quoted-pair rule no longer allows escaping control characters other
   than HTAB.  Non-US-ASCII content in header fields and the reason
   phrase has been obsoleted and made opaque (the TEXT rule was
   removed).  (&lt;a href=&quot;#section-3.2.6&quot;&gt;Section 3.2.6&lt;/a&gt;)

   Bogus Content-Length header fields are now required to be handled as
   errors by recipients.  (&lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt;)

   The algorithm for determining the message body length has been
   clarified to indicate all of the special cases (e.g., driven by
   methods or status codes) that affect it, and that new protocol 

   elements cannot define such special cases.  CONNECT is a new, special
   case in determining message body length. &quot;multipart/byteranges&quot; is no
   longer a way of determining message body length detection.
   (&lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;)

   The &quot;identity&quot; transfer coding token has been removed.  (Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
   and 4)

   Chunk length does not include the count of the octets in the chunk
   header and trailer.  Line folding in chunk extensions is disallowed.
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The meaning of the &quot;deflate&quot; content coding has been clarified.
   (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The segment + query components of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; have been used to define
   the request-target, instead of abs_path from &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;.  The
   asterisk-form of the request-target is only allowed with the OPTIONS
   method.  (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The term &quot;Effective Request URI&quot; has been introduced.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   Gateways do not need to generate Via header fields anymore.
   (&lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt;)

   Exactly when &quot;close&quot; connection options have to be sent has been
   clarified.  Also, &quot;hop-by-hop&quot; header fields are required to appear
   in the Connection header field; just because they're defined as hop-
   by-hop in this specification doesn't exempt them.  (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;)

   The limit of two connections per server has been removed.  An
   idempotent sequence of requests is no longer required to be retried.
   The requirement to retry requests under certain circumstances when
   the server prematurely closes the connection has been removed.  Also,
   some extraneous requirements about when servers are allowed to close
   connections prematurely have been removed.  (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;)

   The semantics of the Upgrade header field is now defined in responses
   other than 101 (this was incorporated from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;]).  Furthermore,
   the ordering in the field value is now significant.  (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;)

   Empty list elements in list productions (e.g., a list header field
   containing &quot;, ,&quot;) have been deprecated.  (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;)

   Registration of Transfer Codings now requires IETF Review
   (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;) 

   This specification now defines the Upgrade Token Registry, previously
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.  (&lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;)

   The expectation to support HTTP/0.9 requests has been removed.
   (Appendix A)

   Issues with the Keep-Alive and Proxy-Connection header fields in
   requests are pointed out, with use of the latter being discouraged
   altogether.  (Appendix A.1.2)</source>
          <target state="translated">已经说明了HTTP处理错误的方法。 （&lt;a href=&quot;#section-2.5&quot;&gt;第2.5节&lt;/a&gt;）HTTP版本ABNF生成已被区分大小写。此外，由于已知实现会错误地处理多位数字版本号，因此版本号已被限制为一位数字。 （&lt;a href=&quot;#section-2.6&quot;&gt;第2.6节&lt;/a&gt;）由于与在线传输有关的安全性问题，HTTP和HTTPS URI中现在禁止使用Userinfo（即用户名和密码）。 （&lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节&lt;/a&gt;）HTTPS URI方案现在由该规范定义。之前，它是在&lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;[RFC2818]的2.4节&lt;/a&gt;中完成的。此外，这意味着端到端的安全性。 （&lt;a href=&quot;#section-2.7.2&quot;&gt;第2.7.2节&lt;/a&gt;）HTTP消息可以（并且经常）由实现缓冲；尽管HTTP有时可以作为流使用，但从根本上来说，HTTP是一种面向消息的协议。已经提出了各种协议元素的最小支持大小，以提高互操作性。 （&lt;a href=&quot;#section-3&quot;&gt;第3节&lt;/a&gt;）现在必须拒绝字段名周围的无效空格，因为接受它表示安全漏洞。现在，定义标头字段的ABNF生产仅列出字段值。 （&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;）删除了某些语法生成之间隐式线性空白的规则；现在，仅在ABNF中明确定义的地方才允许使用空格。 （&lt;a href=&quot;#section-3.2.3&quot;&gt;第3.2.3节&lt;/a&gt;）不建议使用跨越多行的标题字段（&amp;ldquo;行折叠&amp;rdquo;）。 （&lt;a href=&quot;#section-3.2.4&quot;&gt;第3.2.4节&lt;/a&gt;）注释和带引号的字符串文本中不再允许使用NUL八位字节，并且已经澄清了其中的反斜杠转义的处理。引号对规则不再允许转义除HTAB以外的控制字符。标头字段和原因短语中的非US-ASCII内容已过时且不透明（已删除TEXT规则）。 （&lt;a href=&quot;#section-3.2.6&quot;&gt;第3.2.6节&lt;/a&gt;）现在，伪造的Content-Length标头字段需要由接收者作为错误处理。 （&lt;a href=&quot;#section-3.3.2&quot;&gt;第3.3.2节&lt;/a&gt;）已经明确了确定消息正文长度的算法，以指示影响消息正文长度的所有特殊情况（例如，由方法或状态代码驱动），并且新协议元素无法定义此类特殊情况。 CONNECT是确定邮件正文长度的一种新的特殊情况。 &amp;ldquo; multipart / byteranges&amp;rdquo;不再是确定邮件正文长度检测的方法。 （&lt;a href=&quot;#section-3.3.3&quot;&gt;第3.3.3节&lt;/a&gt;）&amp;ldquo;身份&amp;rdquo;转移编码令牌已被删除。 （第&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;节 和第4 节）块长度不包括块头和尾中八位字节的计数。块扩展中的行折叠是不允许的。 （&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;）已经阐明了&amp;ldquo;压缩&amp;rdquo;内容编码的含义。 （&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;）&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;的segment + query组件已用于定义请求目标，而不是&lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808中&lt;/a&gt;的abs_path 。仅使用OPTIONS方法允许请求目标的星号形式。 （&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）引入了&amp;ldquo;有效请求URI&amp;rdquo;一词。 （&lt;a href=&quot;#section-5.5&quot;&gt;第5.5节&lt;/a&gt;）网关不再需要生成Via标头字段。 （&lt;a href=&quot;#section-5.7.1&quot;&gt;第5.7.1节&lt;/a&gt;）明确了何时必须发送&amp;ldquo;关闭&amp;rdquo;连接选项。同样，&amp;ldquo;逐跳&amp;rdquo;标头字段必须显示在&amp;ldquo;连接&amp;rdquo;标头字段中。仅仅因为在本规范中将它们定义为逐跳方法并不能免除它们。（ &lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）已删除了每个服务器两个连接的限制。幂等的请求序列不再需要重试。在服务器过早关闭连接的某些情况下，重试请求的要求已删除。此外，还删除了一些有关何时允许服务器过早关闭连接的多余要求。 （&lt;a href=&quot;#section-6.3&quot;&gt;第6.3节&lt;/a&gt;）现在，在101以外的响应中定义了升级标头字段的语义（这是从[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] 合并的）。此外，字段值中的排序现在很重要。 （&lt;a href=&quot;#section-6.7&quot;&gt;第6.7节&lt;/a&gt;）已弃用列表产生中的空列表元素（例如，包含&amp;ldquo;，&amp;rdquo;的列表头字段）。 （&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）现在需要IETF审核（&lt;a href=&quot;#section-8.4&quot;&gt;第8.4 &lt;/a&gt;节）的转移代码注册。此规范现在定义了升级令牌注册中心，该注册中心先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]的第7.2节中&lt;/a&gt;定义。（&lt;a href=&quot;#section-8.6&quot;&gt;第8.6节&lt;/a&gt;）已删除了支持HTTP / 0.9请求的要求。（附录A）指出了请求中的Keep-Alive和Proxy-Connection标头字段的问题，建议不要使用后者。（附录A.1.2）</target>
        </trans-unit>
        <trans-unit id="e75786a71ce66c44187c7d3570685182eb4f5400" translate="yes" xml:space="preserve">
          <source>HTTP-only cookies aren't accessible via JavaScript through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; API to mitigate attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">仅HTTP的cookie无法通过JavaScript通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt;属性，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; API访问，以减轻针对跨站点脚本（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）的攻击。</target>
        </trans-unit>
        <trans-unit id="645478239b71d9e2120cd5c5e2c81c2c7e39f857" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 &amp;ndash; The one-line protocol</source>
          <target state="translated">HTTP / 0.9 &amp;ndash;一线协议</target>
        </trans-unit>
        <trans-unit id="44cba524f054d5d6640a40b11e1c3c0dd2b2e81c" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 was very limited and both browsers and servers quickly extended it to be more versatile:</source>
          <target state="translated">HTTP/0.9的局限性很大,无论是浏览器还是服务器都很快将其扩展到了更多的用途。</target>
        </trans-unit>
        <trans-unit id="17104213d7caf462f808b5202b6b3bf53c6f9e5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 &amp;ndash; Building extensibility</source>
          <target state="translated">HTTP / 1.0 &amp;ndash;建筑扩展性</target>
        </trans-unit>
        <trans-unit id="8cfcb01eada0b8cfd065017e118d423b8f745b23" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 connections are not persistent by default. Setting &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; to anything other than &lt;code&gt;close&lt;/code&gt;, usually &lt;code&gt;retry-after&lt;/code&gt;, will make them persistent.</source>
          <target state="translated">默认情况下，HTTP / 1.0连接不是持久性的。将&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;close&lt;/code&gt; 以外的其他值（通常是 &lt;code&gt;retry-after&lt;/code&gt; ）将使它们持久化。</target>
        </trans-unit>
        <trans-unit id="c0e8fb29ae930b0d157a9f98acea4150c0686f37" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 opened a TCP connection for each request/response exchange, introducing two major flaws: opening a connection needs several round-trips of messages and therefore slow, but becomes more efficient when several messages are sent, and regularly sent: &lt;em&gt;warm&lt;/em&gt; connections are more efficient than &lt;em&gt;cold&lt;/em&gt; ones.</source>
          <target state="translated">HTTP / 1.0打开每个请求/响应交换的TCP连接，引入两个主要缺陷：打开连接需要的消息的几个往返，因此慢，但变得当几个消息发送更有效率，并定期发送：&lt;em&gt;温暖&lt;/em&gt;连接是比&lt;em&gt;冷&lt;/em&gt;的更有效率。</target>
        </trans-unit>
        <trans-unit id="0d0b58bbcdf0ad6dac8b90fb47db84cff63b6a65" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &amp;ndash; The standardized protocol</source>
          <target state="translated">HTTP / 1.1 &amp;ndash;标准化协议</target>
        </trans-unit>
        <trans-unit id="b6ed95efc2e54e41776e64eab2beb02be978d4fe" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 allows a client to request that only part (a range of) the
   response entity be included within the response. HTTP/1.1 uses range
   units in the Range (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;) and Content-Range (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;)
   header fields. An entity can be broken down into subranges according
   to various structural units.

      range-unit       = bytes-unit | other-range-unit
      bytes-unit       = &quot;bytes&quot;
      other-range-unit = token

   The only range unit defined by HTTP/1.1 is &quot;bytes&quot;. HTTP/1.1
   implementations MAY ignore ranges specified using other units. 

   HTTP/1.1 has been designed to allow implementations of applications
   that do not depend on knowledge of ranges.</source>
          <target state="translated">HTTP / 1.1允许客户端请求仅将一部分响应实体（一部分）包含在响应中。 HTTP / 1.1在Range（&lt;a href=&quot;#section-14.35&quot;&gt;第14.35节&lt;/a&gt;）和Content-Range（&lt;a href=&quot;#section-14.16&quot;&gt;第14.16节&lt;/a&gt;）标头字段中使用范围单位。可以根据各种结构单元将实体分解为子范围。范围单位=字节单位| other-range-unit bytes-unit =&amp;ldquo; bytes&amp;rdquo; other-range-unit =令牌HTTP / 1.1定义的唯一范围单位是&amp;ldquo; bytes&amp;rdquo;。 HTTP / 1.1实现可以忽略使用其他单位指定的范围。 HTTP / 1.1被设计为允许实现不依赖范围知识的应用程序。</target>
        </trans-unit>
        <trans-unit id="8cf11b6afbfe5a73402d4b60de58fb9f5e3c6400" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 and earlier HTTP messages are human-readable. In HTTP/2, these messages are embedded into a new binary structure, a frame, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP/1.1和更早的HTTP消息是可以被人类读取的。在HTTP/2中,这些消息被嵌入到一个新的二进制结构中,即一个框架中,允许对报头进行压缩和复用等优化。即使在这个版本的HTTP中只发送了原始HTTP消息的一部分,每个消息的语义是不变的,客户端重构了(实际上)原始的HTTP/1.1请求。因此,用HTTP/1.1格式来理解HTTP/2消息是很有用的。</target>
        </trans-unit>
        <trans-unit id="340b2a6e6c85c293b668779af15231ac0ac5f995" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 clarified ambiguities and introduced numerous improvements:</source>
          <target state="translated">HTTP/1.1 澄清了歧义,并引入了许多改进。</target>
        </trans-unit>
        <trans-unit id="aaede2afb4e2e830b4b4156c5fed71c83597729d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 defaults to the use of &quot;persistent connections&quot;, allowing
   multiple requests and responses to be carried over a single
   connection.  The &quot;close&quot; connection option is used to signal that a
   connection will not persist after the current request/response.  HTTP
   implementations SHOULD support persistent connections. 

   A recipient determines whether a connection is persistent or not
   based on the most recently received message's protocol version and
   Connection header field (if any):

   o  If the &quot;close&quot; connection option is present, the connection will
      not persist after the current response; else,

   o  If the received protocol is HTTP/1.1 (or later), the connection
      will persist after the current response; else,

   o  If the received protocol is HTTP/1.0, the &quot;keep-alive&quot; connection
      option is present, the recipient is not a proxy, and the recipient
      wishes to honor the HTTP/1.0 &quot;keep-alive&quot; mechanism, the
      connection will persist after the current response; otherwise,

   o  The connection will close after the current response.

   A client MAY send additional requests on a persistent connection
   until it sends or receives a &quot;close&quot; connection option or receives an
   HTTP/1.0 response without a &quot;keep-alive&quot; connection option.

   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A server MUST read
   the entire request message body or close the connection after sending
   its response, since otherwise the remaining data on a persistent
   connection would be misinterpreted as the next request.  Likewise, a
   client MUST read the entire response message body if it intends to
   reuse the same connection for a subsequent request.

   A proxy server MUST NOT maintain a persistent connection with an
   HTTP/1.0 client (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&amp;nbsp;19.7.1 of [RFC2068]&lt;/a&gt; for information and
   discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).

   See &lt;a href=&quot;#appendix-A.1.2&quot;&gt;Appendix A.1.2&lt;/a&gt; for more information on backwards compatibility
   with HTTP/1.0 clients.</source>
          <target state="translated">HTTP / 1.1默认使用&amp;ldquo;持久连接&amp;rdquo;，从而允许在单个连接上承载多个请求和响应。 &amp;ldquo;关闭&amp;rdquo;连接选项用于表示当前请求/响应之后连接将不会持久。 HTTP实现应支持持久连接。收件人根据最近接收到的消息的协议版本和连接头字段（如果有）来确定连接是否持久：o如果存在&amp;ldquo;关闭&amp;rdquo;连接选项，则在当前响应之后该连接将不会持久；否则，o如果收到的协议是HTTP / 1.1（或更高版本），则连接将在当前响应之后保持不变；否则，o如果收到的协议是HTTP / 1.0，则&amp;ldquo;存在&amp;ldquo;保持活动&amp;rdquo;连接选项，接收者不是代理，并且接收者希望采用HTTP / 1.0&amp;ldquo;保持活动&amp;rdquo;机制，该连接将在当前响应后保持不变；否则，该连接将在之后响应关闭客户端可以在持久连接上发送其他请求，直到它发送或接收&amp;ldquo;关闭&amp;rdquo;连接选项或接收到不带有&amp;ldquo;保持活动&amp;rdquo;连接选项的HTTP / 1.0响应为止。在连接上需要具有自定义的消息长度（即，不是由连接的关闭定义的），如机制，连接将在当前响应后保持不变；否则，o连接将在当前响应后关闭。客户端可以在持久连接上发送附加请求，直到它发送或接收&amp;ldquo;关闭&amp;rdquo;连接选项或接收不带&amp;ldquo;保持活动&amp;rdquo;连接选项的HTTP / 1.0响应。为了保持持久性，连接上的所有消息都必须具有自己定义的消息长度（即，未由连接的关闭定义的消息长度），如机制，连接将在当前响应后保持不变；否则，o连接将在当前响应后关闭。客户端可以在持久连接上发送附加请求，直到它发送或接收&amp;ldquo;关闭&amp;rdquo;连接选项或接收不带&amp;ldquo;保持活动&amp;rdquo;连接选项的HTTP / 1.0响应。为了保持持久性，连接上的所有消息都必须具有自己定义的消息长度（即，未由连接的关闭定义的消息长度），如没有&amp;ldquo; keep-alive&amp;rdquo;连接选项的0响应。为了保持持久性，连接上的所有消息都必须具有自己定义的消息长度（即，未由连接的关闭定义的消息长度），如没有&amp;ldquo; keep-alive&amp;rdquo;连接选项的0响应。为了保持持久性，连接上的所有消息都必须具有自己定义的消息长度（即，未由连接的关闭定义的消息长度），如&lt;a href=&quot;#section-3.3&quot;&gt;3.3节&lt;/a&gt;。服务器必须在发送其响应后读取整个请求消息主体或关闭连接，因为否则，持久连接上的剩余数据将被误解为下一个请求。同样，如果客户端打算将相同的连接重用于后续请求，则必须读取整个响应消息正文。代理服务器&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;不得&lt;/a&gt;维护与HTTP / 1.0客户端的持久连接（有关许多HTTP / 1.0客户端实现的Keep-Alive标头字段的信息和问题的讨论，请参阅[RFC2068]的19.7.1节）。有关与HTTP / 1.0客户端向后兼容的更多信息，请参见&lt;a href=&quot;#appendix-A.1.2&quot;&gt;附录A.1.2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b235442975ba302869396fe0ff4cdaebf53c2643" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field
   (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;).  Transfer codings need to be decoded prior to
   forwarding an HTTP message over a MIME-compliant protocol.</source>
          <target state="translated">HTTP / 1.1引入了Transfer-Encoding头字段（&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节&lt;/a&gt;）。在通过MIME兼容协议转发HTTP消息之前，需要对传输编码进行解码。</target>
        </trans-unit>
        <trans-unit id="b7bc6b9e5b12ebbdf628d83f676eae2e25277f50" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;). Proxies/gateways MUST remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.

   A process for decoding the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;)
   can be represented in pseudo-code as:

       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size &amp;gt; 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove &quot;chunked&quot; from Transfer-Encoding</source>
          <target state="translated">HTTP / 1.1引入了Transfer-Encoding头字段（&lt;a href=&quot;#section-14.41&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41 &lt;/a&gt;节）。代理/网关在通过MIME兼容协议转发消息之前，必须删除所有传输编码。解码&amp;ldquo;分块&amp;rdquo;传输编码的过程（&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节&lt;/a&gt;）可以用伪代码表示为：length：= 0读取块大小，块扩展（如果有）和CRLF，而（块大小&amp;gt; 0）{读取块数据和CRLF将块数据追加到实体-正文长度：=长度+块大小读取块大小和CRLF}读取实体标头，同时（实体标头不为空）{将实体标头附加到现有标头字段中读取实体标头} Content-Length：= length删除&amp;ldquo;分块&amp;rdquo;（来自传输编码）</target>
        </trans-unit>
        <trans-unit id="55f1d0e9c7b192d39b6bf47cece53fe18cddfa5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's
   flow control mechanisms to resolve temporary overloads, rather than
   terminating connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.</source>
          <target state="translated">HTTP/1.1服务器应该保持持久连接,并使用TCP的流量控制机制来解决暂时的过载问题,而不是终止连接,期望客户端重试。后一种技术会加剧网络拥堵。</target>
        </trans-unit>
        <trans-unit id="5bde47938358e96d6b78dd50b25535a7c82c1d43" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols SHOULD ensure that any Date header field present in a
   message conforms to one of the HTTP/1.1 formats and rewrite the date
   if necessary.</source>
          <target state="translated">HTTP / 1.1使用一组受限制的日期格式（&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节&lt;/a&gt;）来简化日期比较的过程。来自其他协议的代理和网关应确保消息中存在的任何Date头字段均符合HTTP / 1.1格式之一，并在必要时重写日期。</target>
        </trans-unit>
        <trans-unit id="f983729fa70af1e90d7ea6dbb4afb3d7c8f79cd6" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;) to
   simplify the process of date comparison.  Proxies and gateways from
   other protocols ought to ensure that any Date header field present in
   a message conforms to one of the HTTP/1.1 formats and rewrite the
   date if necessary.</source>
          <target state="translated">HTTP / 1.1使用一组受限制的日期格式（&lt;a href=&quot;#section-7.1.1.1&quot;&gt;第7.1.1.1节&lt;/a&gt;）来简化日期比较的过程。来自其他协议的代理和网关应确保消息中存在的任何Date头字段均符合HTTP / 1.1格式之一，并在必要时重写日期。</target>
        </trans-unit>
        <trans-unit id="87f9910f16689f67ad3946ec5476c5e20370823d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for Internet Mail (&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]) and the Multipurpose Internet Mail Extensions (MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechanisms. However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;
   discusses mail, and HTTP has a few features that are different from
   those described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways to strict MIME environments SHOULD be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.</source>
          <target state="translated">HTTP / 1.1使用为Internet邮件（&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]）和多用途Internet邮件扩展（MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]）定义的许多构造，以允许实体以开放的各种表示形式和可扩展的机制进行传输。但是，&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; 讨论了邮件，并且HTTP具有一些与&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045中&lt;/a&gt;描述的功能不同的功能。精心选择了这些差异，以优化二进制连接的性能，从而在使用新的媒体类型时拥有更大的自由度，使日期比较更加容易，并认可了某些早期HTTP服务器和客户端的做法。本附录描述了HTTP与&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;。到严格的MIME环境的代理和网关应了解这些差异，并在必要时提供适当的转换。从MIME环境到HTTP的代理和网关也需要注意这些差异，因为可能需要进行一些转换。</target>
        </trans-unit>
        <trans-unit id="7ba038961de66fab4bc0d4ca5f738bb4971581c5" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for the Internet Message
   Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose Internet Mail Extensions (MIME)
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] to allow a message body to be transmitted in an open
   variety of representations and with extensible header fields.
   However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; is focused only on email; applications of HTTP have
   many characteristics that differ from email; hence, HTTP has features
   that differ from MIME.  These differences were carefully chosen to
   optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.</source>
          <target state="translated">HTTP / 1.1使用为Internet消息格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ]和多用途Internet邮件扩展（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ] 定义的许多构造，以允许以开放的各种表示形式和可扩展的标头字段传输消息正文。但是，&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;仅专注于电子邮件；HTTP的应用程序具有许多不同于电子邮件的特征；因此，HTTP具有与MIME不同的功能。精心选择了这些差异，以优化二进制连接上的性能，从而在使用新媒体类型时拥有更大的自由度，使日期比较更加容易，并认可了某些早期HTTP服务器和客户端的做法。本附录描述了HTTP与MIME不同的特定区域。往返于严格的MIME环境的代理和网关需要了解这些差异，并在必要时提供适当的转换。</target>
        </trans-unit>
        <trans-unit id="26857a3eb014d1c446a022b99900a2e1fa1f388e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was first published as &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; in January 1997.</source>
          <target state="translated">HTTP / 1.1于1997年1月首次发布为&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5072f3723c431d48c51e0f349be99684fbc90ba" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains both concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd63c4dcb6457bcb6fd3cf072cc949e847bb34c1" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains these two concepts.</source>
          <target state="translated">HTTP/1.1是HTTP的第一个支持持久连接和管道化的版本。这篇文章解释了这两个概念。</target>
        </trans-unit>
        <trans-unit id="1503342ea4d0a3a7deec2528731a5bc064211705" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Authentication</source>
          <target state="translated">HTTP/1.1:认证</target>
        </trans-unit>
        <trans-unit id="0c4a2c0ccd4801b8e3ca9529c7a252503dccdf00" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Semantics and Content</source>
          <target state="translated">HTTP/1.1:语义和内容</target>
        </trans-unit>
        <trans-unit id="c0b298b6e63b8ce602677a51d4f1e6436079232f" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Status Code Definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21663f5aa54f6135626b598bc6ce1bf03ec7513b" translate="yes" xml:space="preserve">
          <source>HTTP/1.x messages have a few drawbacks for performance:</source>
          <target state="translated">HTTP/1.x消息在性能上有一些缺点。</target>
        </trans-unit>
        <trans-unit id="682ec4f8ae7cf90f4fab0685ba322176bdd4f593" translate="yes" xml:space="preserve">
          <source>HTTP/2 &amp;ndash; A protocol for greater performance</source>
          <target state="translated">HTTP / 2 &amp;ndash;更高性能的协议</target>
        </trans-unit>
        <trans-unit id="a9820b1d6f7a1eb33859fc438f4a30a55193154b" translate="yes" xml:space="preserve">
          <source>HTTP/2 Frames</source>
          <target state="translated">HTTP/2帧</target>
        </trans-unit>
        <trans-unit id="b9a1cc9ca8b3b857841ac45f6cab101cd76b0608" translate="yes" xml:space="preserve">
          <source>HTTP/2 adds additional models for connection management.</source>
          <target state="translated">HTTP/2增加了连接管理的附加模型。</target>
        </trans-unit>
        <trans-unit id="de5c597058c2601a65efadc88f948c586a1ffe49" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained. This article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d84f8ae615e7ecf29c3c866e9ab8e4f31fe842" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained: this article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP/2完全重新审视了连接的创建和维护方式:本文解释了HTTP帧如何允许复用,并解决了以前HTTP版本的 &quot;线头 &quot;阻塞问题。</target>
        </trans-unit>
        <trans-unit id="7f0a10f9ce0b6e8be8176a0d0cf459883c237676" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose and the way it is encoded.</source>
          <target state="translated">HTTP/2将HTTP/1.x消息封装并以二进制框架表示。这篇文章解释了框架结构、其目的和编码方式。</target>
        </trans-unit>
        <trans-unit id="8b89d94c6825e208193b0c3215145db1ad533fe7" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose, and the way it's encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6c2df4a46eb441a1cda15f98cf3c5243cca600" translate="yes" xml:space="preserve">
          <source>HTTP/2 introduces an extra step: it divides HTTP/1.x messages into frames which are embedded in a stream. Data and header frames are separated, this allows header compression. Several streams can be combined together, a process called &lt;em&gt;multiplexing&lt;/em&gt;, allowing more efficient underlying TCP connections.</source>
          <target state="translated">HTTP / 2引入了一个额外的步骤：它将HTTP / 1.x消息划分为嵌入在流中的帧。数据和标头帧是分开的，这允许标头压缩。几个流可以组合在一起，这个过程称为&lt;em&gt;多路复用&lt;/em&gt;，可以实现更有效的基础TCP连接。</target>
        </trans-unit>
        <trans-unit id="a496c90d2f1f8118ed8e04e7a7acf8027e245b96" translate="yes" xml:space="preserve">
          <source>HTTP/3 - HTTP over QUIC</source>
          <target state="translated">HTTP/3-QUIC上的HTTP</target>
        </trans-unit>
        <trans-unit id="2e6205295940162ec6f356951c335bcb251f4584" translate="yes" xml:space="preserve">
          <source>HTTPS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTPS &lt;em&gt;主机：端口&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b1b03288626a4932189c45619afd52b616640ff" translate="yes" xml:space="preserve">
          <source>Handling CORS on the server (Java example)</source>
          <target state="translated">在服务器上处理CORS(Java示例)</target>
        </trans-unit>
        <trans-unit id="76ccff916d0696e0db6e0e63211aa5d404b177bb" translate="yes" xml:space="preserve">
          <source>Handshake</source>
          <target state="translated">Handshake</target>
        </trans-unit>
        <trans-unit id="ef63c9de46b2633531f80d09b249c8177fb13159" translate="yes" xml:space="preserve">
          <source>Header field name:  SLUG

   Applicable protocol:  http [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]

   Status:  standard.

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force

   Specification document(s):  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Related information:  None.</source>
          <target state="translated">标头字段名称：SLUG适用协议：http [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]状态：标准。作者/变更控制者：IETF（iesg@ietf.org）互联网工程任务组规范文档： &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;。相关信息：无。</target>
        </trans-unit>
        <trans-unit id="16c88366423875ffcd832b0568164659af366f76" translate="yes" xml:space="preserve">
          <source>Header field name: DAV

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：DAV适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.1&quot;&gt;第10.1节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0a425ee275ccc8dc88e573145d9bc8f251db402b" translate="yes" xml:space="preserve">
          <source>Header field name: Depth

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：深度适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.2&quot;&gt;第10.2节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0b05ddbc40717bf61ebce12546f2a61a4a13a71f" translate="yes" xml:space="preserve">
          <source>Header field name: Destination

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.3&quot;&gt;Section 10.3&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：Destination适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.3&quot;&gt;第10.3节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="80f31a912be49327cab8cfb0f3ab988e1efad182" translate="yes" xml:space="preserve">
          <source>Header field name: If

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.4&quot;&gt;Section 10.4&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：如果适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.4&quot;&gt;第10.4节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="405cc2ed9285599fe7b4ed659f2f3efef397c235" translate="yes" xml:space="preserve">
          <source>Header field name: Lock-Token

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：Lock-Token适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.5&quot;&gt;第10.5节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0ef45169928c0bea57455212198061a9ab1aac96" translate="yes" xml:space="preserve">
          <source>Header field name: Overwrite

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.6&quot;&gt;Section 10.6&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：覆盖适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.6&quot;&gt;第10.6节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="ebc42438bb349fc70f9ce54ef8a83a2205114a92" translate="yes" xml:space="preserve">
          <source>Header field name: Timeout

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)</source>
          <target state="translated">标头字段名称：超时适用协议：http状态：标准作者/更改控制器：IETF规范文档：本规范（&lt;a href=&quot;#section-10.7&quot;&gt;第10.7节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4ab8eed7600b67916da46088b86ba4f2a325716b" translate="yes" xml:space="preserve">
          <source>Header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new
   semantics, nor on the number of header fields used in a given
   message.  Existing fields are defined in each part of this
   specification and in many other specifications outside this document
   set.

   New header fields can be defined such that, when they are understood
   by a recipient, they might override or enhance the interpretation of
   previously defined header fields, define preconditions on request
   evaluation, or refine the meaning of responses.

   A proxy MUST forward unrecognized header fields unless the field-name
   is listed in the Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) or the proxy
   is specifically configured to block, or otherwise transform, such
   fields.  Other recipients SHOULD ignore unrecognized header fields.
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.

   All defined header fields ought to be registered with IANA in the
   &quot;Message Headers&quot; registry, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;Section&amp;nbsp;8.3 of [RFC7231]&lt;/a&gt;.</source>
          <target state="translated">标头字段是完全可扩展的：对引入新的字段名（每个假定都定义了新的语义）没有限制，也没有对给定消息中使用的标头字段的数量的限制。在本规范的每个部分以及本文档集之外的许多其他规范中定义了现有字段。可以定义新的标头字段，以便当接收者理解它们时，它们可以覆盖或增强对先前定义的标头字段的解释，在请求评估时定义前提条件，或完善响应的含义。代理必须转发无法识别的头字段，除非在连接头字段中列出了字段名称（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节）&lt;/a&gt;）或代理专门配置为阻止或以其他方式转换此类字段。其他接收者应该忽略无法识别的头域。这些要求允许HTTP的功能得到增强，而无需事先更新已部署的中介程序。如&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;[RFC7231]的8.3节中&lt;/a&gt;所述，所有定义的标头字段都应在&amp;ldquo;消息标头&amp;rdquo;注册表中向IANA注册。</target>
        </trans-unit>
        <trans-unit id="a40e00de254d23c5e44ccdfe307162d5d4ecbef3" translate="yes" xml:space="preserve">
          <source>Header fields are key:value pairs that can be used to communicate
   data about the message, its payload, the target resource, or the
   connection (i.e., control data).  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt; for a
   general definition of header field syntax in HTTP messages.

   The requirements for header field names are defined in [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Authors of specifications defining new fields are advised to keep the
   name as short as practical and not to prefix the name with &quot;X-&quot;
   unless the header field will never be used on the Internet.  (The
   &quot;X-&quot; prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions
   inside proprietary software or intranet processing, since the prefix
   would ensure that private names never collide with a newly registered
   Internet name; see [&lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt;] for further information).

   New header field values typically have their syntax defined using
   ABNF ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;]), using the extension defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt; as necessary, and are usually constrained to the range of
   US-ASCII characters.  Header fields needing a greater range of
   characters can use an encoding such as the one defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt;].

   Leading and trailing whitespace in raw field values is removed upon
   field parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;Section&amp;nbsp;3.2.4 of [RFC7230]&lt;/a&gt;).  Field definitions where
   leading or trailing whitespace in values is significant will have to
   use a container syntax such as quoted-string (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;Section&amp;nbsp;3.2.6 of
   [RFC7230]&lt;/a&gt;).

   Because commas (&quot;,&quot;) are used as a generic delimiter between
   field-values, they need to be treated with care if they are allowed
   in the field-value.  Typically, components that might contain a comma
   are protected with double-quotes using the quoted-string ABNF
   production.

   For example, a textual date and a URI (either of which might contain
   a comma) could be safely carried in field-values like these:

     Example-URI-Field: &quot;http://example.com/a.html,foo&quot;,
                        &quot;http://without-a-comma.example.com/&quot;
     Example-Date-Field: &quot;Sat, 04 May 1996&quot;, &quot;Wed, 14 Sep 2005&quot;

   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside
   double-quotes will likely cause unnecessary confusion. 

   Many header fields use a format including (case-insensitively) named
   parameters (for instance, Content-Type, defined in &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;).
   Allowing both unquoted (token) and quoted (quoted-string) syntax for
   the parameter value enables recipients to use existing parser
   components.  When allowing both forms, the meaning of a parameter
   value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;).

   Authors of specifications defining new header fields are advised to
   consider documenting:

   o  Whether the field is a single value or whether it can be a list
      (delimited by commas; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;).

      If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would be
      to ignore the field, but this might not always be the right
      choice).

      Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax.  A robust format
      enables recipients to discover these situations (good example:
      &quot;Content-Type&quot;, as the comma can only appear inside quoted
      strings; bad example: &quot;Location&quot;, as a comma can occur inside a
      URI).

   o  Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.

   o  Whether the field should be stored by origin servers that
      understand it upon a PUT request.

   o  Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.

   o  Whether it is appropriate to list the field-name in the Connection
      header field (i.e., if the header field is to be hop-by-hop; see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;).

   o  Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value. 

   o  Whether it is appropriate to list the field-name in a Vary
      response header field (e.g., when the request header field is used
      by an origin server's content selection algorithm; see
      &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;).

   o  Whether the header field is useful or allowable in trailers (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt;).

   o  Whether the header field ought to be preserved across redirects.

   o  Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.</source>
          <target state="translated">标头字段是key：value对，可用于传达有关消息，其有效负载，目标资源或连接的数据（即控制数据）。有关HTTP消息&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;中标&lt;/a&gt;头字段语法的一般定义，请参见[RFC7230]的3.2节。标头字段名称的要求在[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]。建议定义新字段的规范作者将名称保持尽可能短，并且不要在名称前加上&amp;ldquo; X-&amp;rdquo;，除非标题字段永远不会在Internet上使用。 （&amp;ldquo; X-&amp;rdquo;前缀习语在实践中已被广泛使用；它仅用作避免专有软件或Intranet处理内部名称冲突的机制，因为该前缀将确保私人名称不会与新注册的域名冲突。互联网名称；有关更多信息，请参见[ &lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ]。通常，使用&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]第7节中&lt;/a&gt;定义的扩展名，使用ABNF（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ]）定义新的标头字段值的语法根据需要，通常限制在US-ASCII字符范围内。需要更大范围字符的标头字段可以使用一种编码，例如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt; ]中定义的编码。原始字段值中的前导和尾随空格在字段解析时被删除（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;[RFC7230]的第3.2.4节&lt;/a&gt;）。值的前导或尾随空格很重要的字段定义将必须使用容器语法，例如带引号的字符串（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230的第3.2.6节]&lt;/a&gt;）。由于逗号（&amp;ldquo;，&amp;rdquo;）用作字段值之间的通用定界符，因此，如果在字段值中允许使用逗号，则必须谨慎对待。通常，使用引号字符串ABNF生成用双引号保护可能包含逗号的组件。例如，可以在以下字段值中安全地携带文本日期和URI（两者中都可能包含逗号）：Example-URI-Field：&amp;ldquo; http://example.com/a.html,foo&amp;rdquo; ，&amp;ldquo; http://without-a-comma.example.com/&amp;rdquo; Example-Date-Field：&amp;ldquo; 1996年5月4日星期六&amp;rdquo;，&amp;ldquo; 2005年9月14日星期三&amp;rdquo;。请注意，双引号分隔符几乎总是与引号产生在双引号中使用其他语法可能会引起不必要的混乱。许多标头字段使用的格式包括（不区分大小写）命名参数（例如Content-Type，在&lt;a href=&quot;#section-3.1.1.5&quot;&gt;第3.1.1.5节&lt;/a&gt;）。同时允许参数值使用无引号（令牌）和带引号（字符串）的语法，使收件人可以使用现有的解析器组件。当允许两种形式时，参数值的含义应独立于其所使用的语法（例如，请参阅&lt;a href=&quot;#section-3.1.1.1&quot;&gt;第3.1.1.1节中&lt;/a&gt;有关媒体类型的参数处理的注释 ）。建议定义新标题字段的规范作者考虑编写文档：o该字段是单个值还是它可以是列表（以逗号分隔；请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]的3.2节）&lt;/a&gt;）。如果不使用列表语法，请记录如何处理该字段多次出现的消息（明智的默认选择是忽略该字段，但这并不总是正确的选择）。请注意，尽管字段的定义不允许使用列表语法，但中介程序和软件库可能会将多个标头字段实例组合为一个实例。健壮的格式使收件人能够发现这些情况（很好的例子：&amp;ldquo; Content-Type&amp;rdquo;，因为逗号只能出现在加引号的字符串内；不好的例子：&amp;ldquo; Location&amp;rdquo;，因为逗号可以出现在URI内）。 o在什么条件下可以使用标题字段；例如，仅在响应或请求中，在所有消息中，仅在对特定请求方法的响应中，等等。o是否应由理解PUT请求的原始服务器存储该字段。 o是否通过上下文（例如通过现有的请求方法或状态代码）进一步完善字段语义。 o在&amp;ldquo;连接&amp;rdquo;标题字段中列出字段名称是否合适（即，如果标题字段是逐跳的，请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]的6.1节&lt;/a&gt;）。 o在什么条件下允许中介插入，删除或修改字段的值。 o是否适合在Vary响应头字段中列出字段名称（例如，当源服务器的内容选择算法使用请求头字段时；请参见 &lt;a href=&quot;#section-7.1.4&quot;&gt;第7.1.4节&lt;/a&gt;）。 o标头字段在拖车中是有用的还是允许的（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;[RFC7230]的4.1节&lt;/a&gt;）。 o标头字段是否应在重定向中保留。 o是否引入了任何其他安全方面的考虑，例如与隐私相关的数据的披露。</target>
        </trans-unit>
        <trans-unit id="73ce89b0c8df0a7ed4d98060b2c7c611ac330135" translate="yes" xml:space="preserve">
          <source>Header fields that regulate the use of trailers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; (requests) and &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt; (responses).</source>
          <target state="translated">规范拖车使用的标头字段：&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;（请求）和&lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;（响应）。</target>
        </trans-unit>
        <trans-unit id="bf858dd7754f89623471d452d85365f43194c795" translate="yes" xml:space="preserve">
          <source>Header type</source>
          <target state="translated">标题类型</target>
        </trans-unit>
        <trans-unit id="2e31dbd5f484d5c1a3e787a044871e878213d50e" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">内容协商结果的标题：&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e46dedc85812b44c40eda61d963afafe6e17ec8" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">内容协商结果的标题：&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04db11046ac45baaf2858c147c0d0da0d83dfe2b" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">内容协商结果的标题：&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="d43cdd47172ebbec83d46dc0929904cbc0e5ba83" translate="yes" xml:space="preserve">
          <source>Headers are often very similar from one message to the next one, yet still repeated across connections.</source>
          <target state="translated">头部信息往往从一个信息到下一个信息非常相似,但在不同的连接中仍然重复。</target>
        </trans-unit>
        <trans-unit id="b9f5a636b75216c81304804a9a45004630234515" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt; handle them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953e087d7da0e93f2114e33931a9fff08ea7dde9" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how proxies handle them:</source>
          <target state="translated">标题也可以根据代理的处理方式进行分组。</target>
        </trans-unit>
        <trans-unit id="7e731d99aaf73e73a84db12018da22acb10f8eaf" translate="yes" xml:space="preserve">
          <source>Headers can be grouped according to their contexts:</source>
          <target state="translated">可以根据上下文对标题进行分组。</target>
        </trans-unit>
        <trans-unit id="62484b23e54725c71a2263f18277c31549662db4" translate="yes" xml:space="preserve">
          <source>Headers, unlike bodies, are uncompressed.</source>
          <target state="translated">头部与主体不同,是没有压缩的。</target>
        </trans-unit>
        <trans-unit id="5da9db7ae87281e3e1ab3c768b9be45ae8134d50" translate="yes" xml:space="preserve">
          <source>Helpful tools and resources for understanding and debugging HTTP.</source>
          <target state="translated">有助于理解和调试HTTP的工具和资源。</target>
        </trans-unit>
        <trans-unit id="2ed70bbb1a3a5c498b113f52c1548cee8ea9cc2d" translate="yes" xml:space="preserve">
          <source>Here again, be sure to take the right token for the browser you are looking for, as there is no guarantee that others will contain a valid number.</source>
          <target state="translated">这里再次强调一下,一定要拿对你要找的浏览器的令牌,因为不能保证其他的浏览器会包含一个有效的号码。</target>
        </trans-unit>
        <trans-unit id="d5227ab359118de929fda02e4ed8472790aeba2d" translate="yes" xml:space="preserve">
          <source>Here is a JavaScript regular expression that will detect all mobile devices, including devices with a device id in their UA string:</source>
          <target state="translated">这里是一个JavaScript正则表达式,它将检测所有移动设备,包括UA字符串中带有设备id的设备。</target>
        </trans-unit>
        <trans-unit id="4e3866c880875ee1ff8235362e89c76b5139a9ee" translate="yes" xml:space="preserve">
          <source>Here is a list of MIME types, associated by type of documents, ordered by their common extensions.</source>
          <target state="translated">这里是一个MIME类型的列表,按文档类型相关联,按其常用扩展名排序。</target>
        </trans-unit>
        <trans-unit id="d20b00cd2016c9a232dbd3f29c2f2897e9fcffac" translate="yes" xml:space="preserve">
          <source>Here is a list of common features controllable with HTTP.</source>
          <target state="translated">以下是HTTP可以控制的常见功能列表。</target>
        </trans-unit>
        <trans-unit id="5c9905f596ccef64e1269e49689d1a73c07dd5b6" translate="yes" xml:space="preserve">
          <source>Here is a sample exchange between client and server:</source>
          <target state="translated">下面是一个客户端和服务器之间的交流示例。</target>
        </trans-unit>
        <trans-unit id="9501e397bcbf8b4862fe537468cb6a0753bdae2b" translate="yes" xml:space="preserve">
          <source>Here is an example in PHP of handling a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;preflighted request&lt;/a&gt;:</source>
          <target state="translated">这是PHP中处理&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;预检请求&lt;/a&gt;的示例：</target>
        </trans-unit>
        <trans-unit id="75207f8e8ffefa8d462dd3fb2a1a65ea217d704b" translate="yes" xml:space="preserve">
          <source>Here is an example of the Slug header that uses percent-encoding to
   represent the Unicode character U+00E8 (LATIN SMALL LETTER E WITH
   GRAVE):

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Content-Type: image/png
       Slug: The Beach at S%C3%A8te
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   See &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt; for an example of the Slug header applied to the
   creation of an Entry Resource.</source>
          <target state="translated">以下是Slug标头的示例，该标头使用百分比编码来表示Unicode字符U + 00E8（带有GRAVE的拉丁文小写字母E）：POST / myblog / entries HTTP / 1.1主机：example.org内容类型：image / png Slug：位于S％C3％A8te的海滩授权：Basic ZGFmZnk6c2VjZXJldA == Content-Length：nnn ...二进制数据有关应用于创建条目资源的Slug标头的示例，请参见&lt;a href=&quot;#section-9.2.1&quot;&gt;第9.2.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2797fafb9211cc2c051dcda055704a3e4e30b8b0" translate="yes" xml:space="preserve">
          <source>Here is an example of this process with a shared cache proxy:</source>
          <target state="translated">下面是一个使用共享缓存代理的过程的例子。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5dd834bb2835bdbfb70e682c19ccc9767516af" translate="yes" xml:space="preserve">
          <source>Here is some PHP that handles credentialed requests:</source>
          <target state="translated">下面是一些处理凭证式请求的PHP。</target>
        </trans-unit>
        <trans-unit id="8ef8c73e17b07ff09f65fb9ccc55b532e81935c5" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21888f07518ae7a0759573f20d4642440f36a52" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;code&gt;Upgrade&lt;/code&gt; header.</source>
          <target state="translated">在这里，我们介绍了 &lt;code&gt;Upgrade&lt;/code&gt; 标头的最常用用例。</target>
        </trans-unit>
        <trans-unit id="9ab6627dc7da6cad243b3faca054a977b46dce0f" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server (in addition to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f377abe687f3f604805ed4c41cf044b1a5eecca7" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that in addition to the &quot;simple&quot; headers, a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server.</source>
          <target state="translated">这是一个 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 标头可能看起来的示例。它指示除了&amp;ldquo;简单&amp;rdquo;标头之外，对服务器的CORS请求还支持名为 &lt;code&gt;X-Custom-Header&lt;/code&gt; 的自定义标头。</target>
        </trans-unit>
        <trans-unit id="29ece426131fe65594c0f74862a88481dffe1b6d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is the authentication scheme (&quot;Basic&quot; is the most common scheme and &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;introduced below&lt;/a&gt;). The &lt;em&gt;realm&lt;/em&gt; is used to describe the protected area or to indicate the scope of protection. This could be a message like &quot;Access to the staging site&quot; or similar, so that the user knows to which space they are trying to get access to.</source>
          <target state="translated">在这里， &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 是身份验证方案（&amp;ldquo; Basic&amp;rdquo;是最常见的方案，&lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;下面介绍&lt;/a&gt;）。该&lt;em&gt;领域&lt;/em&gt;用于描述保护区域或指示保护范围。这可能是一条消息，例如&amp;ldquo;访问登台站点&amp;rdquo;或类似消息，以便用户知道他们试图访问的空间。</target>
        </trans-unit>
        <trans-unit id="eb29f0c2d2f88776ddd04a11566426842fc746ff" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;base64EncodedSettings&lt;/code&gt; is an HTTP/2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; frame's payload which has been base64url encoded and all trailing &lt;code&gt;&quot;=&quot;&lt;/code&gt; (equals) characters removed in order to safely include it in this textual header format.</source>
          <target state="translated">在这里， &lt;code&gt;base64EncodedSettings&lt;/code&gt; 是HTTP / 2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; 帧的有效负载，已经对其进行了base64url编码，并删除了所有尾随的 &lt;code&gt;&quot;=&quot;&lt;/code&gt; （等于）字符，以便将其安全地包含在此文本标头格式中。</target>
        </trans-unit>
        <trans-unit id="a17f358e1ad5338444563c68bbadc2878e955302" translate="yes" xml:space="preserve">
          <source>Here, &lt;em&gt;x.y&lt;/em&gt; is the version of Mac OS X (for instance, Mac OS X 10.6).</source>
          <target state="translated">在此，&lt;em&gt;xy&lt;/em&gt;是Mac OS X的版本（例如，Mac OS X 10.6）。</target>
        </trans-unit>
        <trans-unit id="ef77ad6909e7752d9aa6373842d49849209611c6" translate="yes" xml:space="preserve">
          <source>Here, by default, content is only permitted from the document's origin, with the following exceptions:</source>
          <target state="translated">在这里,默认情况下,只允许来自文档源头的内容,但有以下例外。</target>
        </trans-unit>
        <trans-unit id="fa2977eeb67774d5a0dd09ff4ec5ec0a36ef8155" translate="yes" xml:space="preserve">
          <source>Here, we present three scenarios that illustrate how Cross-Origin Resource Sharing works. All of these examples use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; object, which can be used to make cross-site invocations in any supporting browser.</source>
          <target state="translated">在这里，我们提出了三种方案，说明了跨域资源共享的工作方式。所有这些示例都使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;对象，该对象可用于在任何支持的浏览器中进行跨站点调用。</target>
        </trans-unit>
        <trans-unit id="b282bf1d7028f07f3c3e1a14dbfcb71697111c5d" translate="yes" xml:space="preserve">
          <source>Heroku's proxy library Vegur</source>
          <target state="translated">Heroku的代理库Vegur</target>
        </trans-unit>
        <trans-unit id="ddf9efd09112f93ec00fa54e8c4c84c765c17139" translate="yes" xml:space="preserve">
          <source>Heuristic Expiration</source>
          <target state="translated">启发式到期时间</target>
        </trans-unit>
        <trans-unit id="f2bddb211b435d77bdcd54be12a624bcbd764aed" translate="yes" xml:space="preserve">
          <source>Heuristic freshness checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1724e0bfe29683a06f3fb0d140956360664db86b" translate="yes" xml:space="preserve">
          <source>Historic specification of HTTP State Management Mechanism, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;</source>
          <target state="translated">HTTP状态管理机制的历史性规范，&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;已废弃</target>
        </trans-unit>
        <trans-unit id="d2fc15fa26334cc66ab95bf51b30e486fe93e127" translate="yes" xml:space="preserve">
          <source>History Lists (RFC 7234)</source>
          <target state="translated">历史列表(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="2b89425faff6de6dc314db782d45b8bad9965067" translate="yes" xml:space="preserve">
          <source>History and implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8224b406bb9fcf1d12ea7ebecf7258a153c52d79" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression</source>
          <target state="translated">逐跳压缩</target>
        </trans-unit>
        <trans-unit id="77f5c2d41f116e38295977a86465e5e9e801702a" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression, though similar to end-to-end compression, differs by one fundamental element: the compression doesn't happen on the resource in the server, creating a specific representation that is then transmitted, but on the body of the message between any two nodes on the path between the client and the server. Connections between successive intermediate nodes may apply a &lt;em&gt;different&lt;/em&gt; compression.</source>
          <target state="translated">逐跳压缩虽然与端到端压缩相似，但有一个基本元素的不同：压缩不会在服务器中的资源上发生，而是创建一种特定的表示形式，然后在主体上进行传输客户端和服务器之间路径上任何两个节点之间的消息。连续的中间节点之间的连接可以应用&lt;em&gt;不同的&lt;/em&gt;压缩。</target>
        </trans-unit>
        <trans-unit id="78458c6f2f912b6d6875b5a660931222e51353f1" translate="yes" xml:space="preserve">
          <source>Hop-by-hop headers</source>
          <target state="translated">逐跳标题</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="f3680c389a985b1c29ff7e674003c4ba66aee02b" translate="yes" xml:space="preserve">
          <source>Host (RFC 2616)</source>
          <target state="translated">主机(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="5406f06c65b376c58dac6bf71408ae1944750e32" translate="yes" xml:space="preserve">
          <source>Host names and ports of reverse proxies (load balancers, CDNs) may differ from the origin server handling the request, in that case the &lt;code&gt;X-Forwarded-Host&lt;/code&gt; header is useful to determine which Host was originally used.</source>
          <target state="translated">反向代理的主机名和端口（负载平衡器，CDN）可能与处理请求的原始服务器不同，在这种情况下， &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 标头可用于确定最初使用的主机。</target>
        </trans-unit>
        <trans-unit id="f4b4c2643126c467ddef65e6b67d5f8c8b5bdc1a" translate="yes" xml:space="preserve">
          <source>Host to which the cookie will be sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a6082579e4930c27da3887804287a2a53f1624" translate="yes" xml:space="preserve">
          <source>Host-specific file names</source>
          <target state="translated">主机专用文件名</target>
        </trans-unit>
        <trans-unit id="2ec76d41d987ae559f5e3a7f7fd514508f4dcf54" translate="yes" xml:space="preserve">
          <source>Hosted CSP reporting for HTTPS migrations</source>
          <target state="translated">托管的CSP报告,用于HTTPS迁移。</target>
        </trans-unit>
        <trans-unit id="1367a4331a65542cf39c8a9d5b8961997d49502b" translate="yes" xml:space="preserve">
          <source>Hostname based conditions</source>
          <target state="translated">基于主机名的条件</target>
        </trans-unit>
        <trans-unit id="39e32117a3b52cca1d492b875f026756fb25597f" translate="yes" xml:space="preserve">
          <source>How Browsers Work</source>
          <target state="translated">浏览器如何工作</target>
        </trans-unit>
        <trans-unit id="4c91ae122f1612df59f2a23941f9e79f1d970ecc" translate="yes" xml:space="preserve">
          <source>How cookies work is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;. When serving an HTTP request, a server can send a &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP header with the response. The client then returns the cookie's value with every request to the same server in the form of a &lt;code&gt;Cookie&lt;/code&gt; request header. The cookie can also be set to expire on a certain date, or restricted to a specific domain and path.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;定义了cookie的工作方式。在处理HTTP请求时，服务器可以发送带有响应的 &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP标头。然后，客户端将每个请求的Cookie值以 &lt;code&gt;Cookie&lt;/code&gt; 请求标头的形式返回给同一服务器。也可以将Cookie设置为在特定日期过期，或将其限制为特定的域和路径。</target>
        </trans-unit>
        <trans-unit id="326d6840506a3e0e685440ecd35aff457aa45373" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies and clients, about what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785a4091642b3107a87eb0510aa18c744ad3bd77" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies, and clients, what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">如何缓存文件可以通过HTTP来控制。服务器可以指示代理和客户端缓存什么以及缓存多长时间。客户端可以指示中间的缓存代理忽略存储的文档。</target>
        </trans-unit>
        <trans-unit id="9a92fcc6dda054aa8ba041f16e995c47ecf3e087" translate="yes" xml:space="preserve">
          <source>How much detail to include is an interesting balance to strike; exposing the OS version is probably a bad idea, as mentioned in the earlier warning about overly-detailed values. However, exposed Apache versions helped browsers work around a bug those versions had with &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; combined with &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a6840353bc46a78f9536e0c4ba600c96425f56" translate="yes" xml:space="preserve">
          <source>How the browser handles it</source>
          <target state="translated">浏览器如何处理</target>
        </trans-unit>
        <trans-unit id="68bee7ceae58ef9dd68bebd7e8624e01362fe458" translate="yes" xml:space="preserve">
          <source>How to Fix 405 Method Not Allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bbcaa9a058613fa1a50456a0aabfa3b3df0140" translate="yes" xml:space="preserve">
          <source>How to avoid the CORS preflight</source>
          <target state="translated">如何避免CORS预检</target>
        </trans-unit>
        <trans-unit id="778498eaac84dd627c8fe8e2869a7fc961933c44" translate="yes" xml:space="preserve">
          <source>How to fix &lt;em&gt;&amp;ldquo;Access-Control-Allow-Origin header must not be the wildcard&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">如何解决&lt;em&gt;&amp;ldquo; Access-Control-Allow-Origin标头不能为通配符&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc108c55cd0ff984c9ac45ce8cdb74f88f1a0654" translate="yes" xml:space="preserve">
          <source>How to fix CORS issue?</source>
          <target state="translated">如何解决CORS问题?</target>
        </trans-unit>
        <trans-unit id="c305fbaf8d1dd662dd884c22cf15416371345003" translate="yes" xml:space="preserve">
          <source>How to run Chrome browser without CORS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd427ecf132d3e2cc23ee42d32690dc605d28a0f" translate="yes" xml:space="preserve">
          <source>How to use a CORS proxy to get around &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">如何使用CORS代理避开&lt;em&gt;&amp;ldquo; No Access-Control-Allow-Origin标头&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f79e53c0a139eb96378c7ba89f9dd8fbfb330c0" translate="yes" xml:space="preserve">
          <source>However, if the request is one that triggers a preflight due to the presence of the &lt;code&gt;Authorization&lt;/code&gt; header in the request, you won&amp;rsquo;t be able to work around the limitation using the steps above. And you won&amp;rsquo;t be able to work around it at all unless you have control over the server the request is being made to.</source>
          <target state="translated">但是，如果请求是由于请求中存在 &lt;code&gt;Authorization&lt;/code&gt; 标头而触发预检的请求，则无法使用上述步骤来解决限制。除非您可以控制请求的服务器，否则您将根本无法解决它。</target>
        </trans-unit>
        <trans-unit id="aa3bacea776742f9f4ee0b04c2738bf1f2acd22e" translate="yes" xml:space="preserve">
          <source>However, scripts without integrity won't load anymore:</source>
          <target state="translated">但是,没有完整性的脚本将无法再加载。</target>
        </trans-unit>
        <trans-unit id="4784e9a56ee26ccc58e9b47e0384d44d80f5b536" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6363c2d9cd37774dbf6ea52a71d3cc4b1d69edf1" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via Javascript:</source>
          <target state="translated">但是，不会阻止直接在元素的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt;属性上设置的styles属性，从而允许用户通过Javascript安全地操作样式：</target>
        </trans-unit>
        <trans-unit id="712efc901d5948d1ddc85420dd7828b2c028e889" translate="yes" xml:space="preserve">
          <source>However, the above code is absolutely terrible and ill-conceived. What if Chrome removes this look behind feature? What if another browser implements look behind regexps? What if another browser uses &lt;em&gt;Chrome &lt;/em&gt;in their user agent string? The list goes on and on of things that could go terribly wrong. Thus, you should instead use feature detection like the following.</source>
          <target state="translated">但是，上面的代码绝对是糟糕透顶的。如果Chrome删除了此后视功能，该怎么办？如果另一个浏览器实现了正则表达式后面的东西怎么办？如果其他浏览&lt;em&gt;器&lt;/em&gt;在其用户代理字符串中使用&lt;em&gt;Chrome&lt;/em&gt;，该怎么办？清单不断地列出可能出错的事情。因此，您应该改为使用如下所示的特征检测。</target>
        </trans-unit>
        <trans-unit id="3e339ee7e7a8e7da017468304e92dc515e180b71" translate="yes" xml:space="preserve">
          <source>However, this won't wildcard the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header, so if you need to expose that, you will need to list it explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872b5517c0f6559afa3677ba893bb97024b2ecc2" translate="yes" xml:space="preserve">
          <source>HttpOnly Optional</source>
          <target state="translated">HttpOnly 可选</target>
        </trans-unit>
        <trans-unit id="abd954b086bab88cb87ec4cda040e14953ecce8f" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</source>
          <target state="translated">超文本咖啡壶控制协议(HTCPCP/1.0)</target>
        </trans-unit>
        <trans-unit id="9cb22c4629a969af0720c560a54790780d479542" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0): Semantics and Content</source>
          <target state="translated">超文本咖啡壶控制协议(HTCPCP/1.0)。语义和内容</target>
        </trans-unit>
        <trans-unit id="126116b4ff4ad54a45b5f2a945491694cc39450d" translate="yes" xml:space="preserve">
          <source>Hyper text transfer protocol (Secure)</source>
          <target state="translated">超文本传输协议(安全)</target>
        </trans-unit>
        <trans-unit id="a40ca5dd3664e7e5fbc9868906e198fe122b47b2" translate="yes" xml:space="preserve">
          <source>HyperText Markup Language (HTML)</source>
          <target state="translated">超文本标记语言</target>
        </trans-unit>
        <trans-unit id="3aabdc98f3e181618def85f1876081249a0e4138" translate="yes" xml:space="preserve">
          <source>HyperText Transport Protocol Keep-Alive Header</source>
          <target state="translated">超文本传输协议 Keep-Alive Header</target>
        </trans-unit>
        <trans-unit id="caec6dcaeb81aa6d4af95da6ddc9afca1f3451f8" translate="yes" xml:space="preserve">
          <source>Hypertext Preprocessor (&lt;strong&gt;Personal Home Page&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bf740d859a72ca5b146b5d3c7c57e9e44dbdab" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) Keep-Alive Header</source>
          <target state="translated">超文本传输协议(HTTP)Keep-Alive标头</target>
        </trans-unit>
        <trans-unit id="18c750541be3062c47621490bab7ee6a43ed0176" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) clients often encounter
   interrupted data transfers as a result of canceled requests or
   dropped connections.  When a client has stored a partial
   representation, it is desirable to request the remainder of that
   representation in a subsequent request rather than transfer the
   entire representation.  Likewise, devices with limited local storage
   might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or
   the dimensions of an embedded image.

   This document defines HTTP/1.1 range requests, partial responses, and
   the multipart/byteranges media type.  Range requests are an OPTIONAL
   feature of HTTP, designed so that recipients not implementing this
   feature (or not supporting it for the target resource) can respond as
   if it is a normal GET request without impacting interoperability.
   Partial responses are indicated by a distinct status code to not be
   mistaken for full responses by caches that might not implement the
   feature.

   Although the range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.</source>
          <target state="translated">超文本传输协议(HTTP)客户端经常会遇到因取消请求或掉线而导致数据传输中断的情况。当客户端存储了部分表示时,最好在后续请求中请求该表示的剩余部分,而不是传输整个表示。同样,本地存储有限的设备可能会受益于能够只请求一个较大的表示的子集,例如一个非常大的文档的单页,或者一个嵌入式图像的尺寸。本文档定义了HTTP/1.1范围请求、部分响应和multipart/byteranges媒体类型。范围请求是HTTP的一个OPTIONAL特性,目的是让没有实现这个特性(或者目标资源不支持这个特性)的接收者可以像正常的GET请求一样响应,而不影响互操作性。部分响应用一个不同的状态码来表示,以免被可能没有实现该功能的缓存误认为是完全响应。虽然范围请求机制被设计为允许可扩展的范围类型,但本规范只定义了字节范围的请求。</target>
        </trans-unit>
        <trans-unit id="eaebf91177666f1aaca9207bce21f241c2d6aa1c" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Authentication</source>
          <target state="translated">超文本传输协议(HTTP/1.1)。认证</target>
        </trans-unit>
        <trans-unit id="cf04e8c69e3ace21820abada8b4f0bf8440a50a6" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">超文本传输协议(HTTP/1.1):高速缓存。</target>
        </trans-unit>
        <trans-unit id="565eb02fb9f4c2b506e298c3e3bd17146e8b9b29" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</source>
          <target state="translated">超文本传输协议(HTTP/1.1)。有条件的请求</target>
        </trans-unit>
        <trans-unit id="5ffac3f427873675e5fda46ed9caffb674838583" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</source>
          <target state="translated">超文本传输协议(HTTP/1.1):消息语法和路由选择</target>
        </trans-unit>
        <trans-unit id="067dc1d00ea2a2c2813ac9db731d6b354882d326" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</source>
          <target state="translated">超文本传输协议(HTTP/1.1):范围请求。</target>
        </trans-unit>
        <trans-unit id="67726549543e0d1b42d751ebf670ca915f452bde" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</source>
          <target state="translated">超文本传输协议(HTTP/1.1)。语义和内容</target>
        </trans-unit>
        <trans-unit id="dadde9e82bc152463510002167edd8589458e39b" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Context</source>
          <target state="translated">超文本传输协议(HTTP/1.1)。语义和上下文</target>
        </trans-unit>
        <trans-unit id="0464d55671763178e4bb9bf689fd75c3b2bf90ee" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol -- HTTP/1.1</source>
          <target state="translated">超文本传输协议-HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="14001adc995acbe66bc7906c7030f074a23e21ec" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol Version 2 (HTTP/2)</source>
          <target state="translated">超文本传输协议第二版(HTTP/2)</target>
        </trans-unit>
        <trans-unit id="e0899b85bb34ecad597f88ef93fbf5180bd78fc6" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7230)</source>
          <target state="translated">IANA的考虑因素(RFC 7230)</target>
        </trans-unit>
        <trans-unit id="fb05bb988d2b3042dacb51c3209a976e89fd65b7" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7231)</source>
          <target state="translated">IANA的考虑因素(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="faddb1a82ba7e7645aff6b957bbe064fd752dd69" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7232)</source>
          <target state="translated">IANA的考虑因素(RFC 7232)</target>
        </trans-unit>
        <trans-unit id="4cbf2a520cf53d1cedf62323be093a069cfdcece" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7233)</source>
          <target state="translated">IANA的考虑因素(RFC 7233)</target>
        </trans-unit>
        <trans-unit id="2ce28868e82be3265aeb20b44d3fbb587c2a23ce" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7234)</source>
          <target state="translated">IANA的考虑因素(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="98a74c9cf29e82d02e581eb12c22dda292d5ee17" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7235)</source>
          <target state="translated">IANA的考虑因素(RFC 7235)</target>
        </trans-unit>
        <trans-unit id="4bb8022eff5067ab10c4c96ad85499b49bef742d" translate="yes" xml:space="preserve">
          <source>IANA HTTP Range Unit Registry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5904c4ee52524bdc80934ad4f9a7950c63e23ee8" translate="yes" xml:space="preserve">
          <source>IANA has added a reference to this specification in the
   'application/atom+xml' media type registration.</source>
          <target state="translated">IANA在'application/atom+xml'媒体类型注册中增加了对该规范的引用。</target>
        </trans-unit>
        <trans-unit id="69ea11543f5de3dd2cb43742c8f141e34bd0847d" translate="yes" xml:space="preserve">
          <source>IANA is the official registry of MIME media types and maintains a &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;list of all the official MIME types&lt;/a&gt;. This table lists some important MIME types for the Web:</source>
          <target state="translated">IANA是MIME媒体类型的正式注册表，并维护&lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;所有正式MIME类型&lt;/a&gt;的列表。下表列出了一些重要的Web MIME类型：</target>
        </trans-unit>
        <trans-unit id="89c07cdbd61e19ece57d06075ba79aecfe00c78b" translate="yes" xml:space="preserve">
          <source>IANA list of URI schemes</source>
          <target state="translated">IANA的URI方案清单</target>
        </trans-unit>
        <trans-unit id="78740b079f8a9346faaa07edbf050f52dc47fc13" translate="yes" xml:space="preserve">
          <source>IANA maintains the &quot;HTTP Content Coding Registry&quot; at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.

   The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">IANA在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护&amp;ldquo; HTTP内容编码注册表&amp;rdquo; 。 &amp;ldquo; HTTP内容编码注册表&amp;rdquo;已通过以下注册进行了更新：+ ------------ + --------------------- ----------------- + --------------- + |姓名|描述参考| + ------------ + ------------------------------------ -+ --------------- + |压缩| UNIX&amp;ldquo;压缩&amp;rdquo;数据格式[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; | |放气&amp;ldquo;压缩&amp;rdquo;压缩数据| &lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt; | | | （[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]）内的&amp;ldquo; zlib&amp;rdquo;数据| | | |格式（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]）| | | gzip | GZIP文件格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; | | x压缩| 不推荐使用（压缩别名）| &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; | | x-gzip | 不推荐使用（gzip的别名）| &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="2f3aef98e61cefd59e70d51a0d54a7f7880c7e4d" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media
   types &quot;message/http&quot; and &quot;application/http&quot;.  The following has been
   registered with IANA.</source>
          <target state="translated">IANA维护Internet媒体类型[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] 的注册表，网址为&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;。本文档用作Internet媒体类型&amp;ldquo; message / http&amp;rdquo;和&amp;ldquo; application / http&amp;rdquo;的规范。以下内容已在IANA上注册。</target>
        </trans-unit>
        <trans-unit id="57560e1f2062a0d9e41b59e9de0cd89dfc775402" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media type
   &quot;multipart/byteranges&quot;.  The following has been registered with IANA.</source>
          <target state="translated">IANA维护Internet媒体类型[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] 的注册表，网址为&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;。本文档用作Internet媒体类型&amp;ldquo; multipart / byteranges&amp;rdquo;的规范。以下内容已在IANA上注册。</target>
        </trans-unit>
        <trans-unit id="2f25bf5a2ef40ce000fcbfb953c618138d7e6d92" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of URI Schemes [&lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt;&amp;gt;.

   This document defines the following URI schemes, so the &quot;Permanent
   URI Schemes&quot; registry has been updated accordingly.

   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt; |
   | https      | Hypertext Transfer Protocol Secure | &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt; |
   +------------+------------------------------------+---------------+</source>
          <target state="translated">IANA 在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt; &amp;gt;上维护URI计划的注册中心[ &lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] 。本文档定义了以下URI方案，因此&amp;ldquo;永久URI方案&amp;rdquo;注册表已相应更新。 + ------------ + ------------------------------------ + --------------- + | URI方案|描述参考| + ------------ + ------------------------------------ + --------------- + | http |超文本传输​​协议| &lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节&lt;/a&gt; | | https |安全超文本传输​​协议| &lt;a href=&quot;#section-2.7.2&quot;&gt;第2.7.2节&lt;/a&gt; | + ------------ + ------------------------------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="70d5ce962c5520d83534599071460204e3f79a4c" translate="yes" xml:space="preserve">
          <source>IANA official registry of HTTP status codes</source>
          <target state="translated">IANA官方注册的HTTP状态码</target>
        </trans-unit>
        <trans-unit id="052ea052e8c19248acaf0e57ba16070d89e5f3f2" translate="yes" xml:space="preserve">
          <source>IANA registry</source>
          <target state="translated">IANA登记处</target>
        </trans-unit>
        <trans-unit id="3ec2a8d54523fcf678717117536e9db1ddb9d0ec" translate="yes" xml:space="preserve">
          <source>IANA registry of Authentication schemes</source>
          <target state="translated">IANA认证方案登记处</target>
        </trans-unit>
        <trans-unit id="433dbaf6332943984d6516e68b5f7fa26960c972" translate="yes" xml:space="preserve">
          <source>ICO</source>
          <target state="translated">ICO</target>
        </trans-unit>
        <trans-unit id="1c424db78d6168d4e4112d7ef44078d6e5cc90ef" translate="yes" xml:space="preserve">
          <source>IETF Draft</source>
          <target state="translated">IETF草案</target>
        </trans-unit>
        <trans-unit id="8017c92650b8189e940d94d4098c59d4b86b1c4b" translate="yes" xml:space="preserve">
          <source>IETF RFC</source>
          <target state="translated">IETF RFC</target>
        </trans-unit>
        <trans-unit id="8571cc2c4258545210a5b00473280039ad4b84d4" translate="yes" xml:space="preserve">
          <source>IIS</source>
          <target state="translated">IIS</target>
        </trans-unit>
        <trans-unit id="863b6ddbf8a4aa095ca888b978a73ba1efc7811f" translate="yes" xml:space="preserve">
          <source>Icon format</source>
          <target state="translated">图标格式</target>
        </trans-unit>
        <trans-unit id="ca9f65841299353702f59413c67b4d41e934a6e4" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for each resource. But there are reasons for alternative names for a resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc4507a76928b989abe5a6100c9511b38bd00d7" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for one resource. But there are reasons for wanting to have alternative names for a resource (several domains, like with and without the www prefix or shorter and easy to remember URLs, &amp;hellip;). In these cases, rather than duplicating the resource, it is useful to use a redirect to the one true (canonical) URL.</source>
          <target state="translated">理想情况下，一种资源只有一个位置，因此只有一个URL。但是，出于某些原因，我们希望为资源使用其他名称（多个域，例如带有和不带有www前缀的域名，或者更短且易于记忆的URL，等等）。在这些情况下，与其复制资源，不如使用重定向到一个真实（规范）URL的方法。</target>
        </trans-unit>
        <trans-unit id="f1df7d15a8112ad87203fcb0cb507f4b96b72bbd" translate="yes" xml:space="preserve">
          <source>Idempotent</source>
          <target state="translated">Idempotent</target>
        </trans-unit>
        <trans-unit id="b6a2413ad63489a62e13c1cef9ff703c77e3aa0f" translate="yes" xml:space="preserve">
          <source>Idempotent Methods (RFC 7231)</source>
          <target state="translated">幂等方法(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="526430255f19421715307947f2ff84df60c93896" translate="yes" xml:space="preserve">
          <source>Identifies the original host requested that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">识别客户端用于连接到代理或负载平衡器的原始主机请求。</target>
        </trans-unit>
        <trans-unit id="b108c524c313085aeda694b0f180ecea370efb15" translate="yes" xml:space="preserve">
          <source>Identifies the originating IP addresses of a client connecting to a web server through an HTTP proxy or a load balancer.</source>
          <target state="translated">识别通过HTTP代理或负载平衡器连接到Web服务器的客户端的原始IP地址。</target>
        </trans-unit>
        <trans-unit id="4728d359ae99afe818be6f9dc7667972f09461f4" translate="yes" xml:space="preserve">
          <source>Identifies the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b059dd235df4bbca4880938a5c1bb58a2acfaacc" translate="yes" xml:space="preserve">
          <source>Identifying allowed request methods</source>
          <target state="translated">识别允许的请求方法</target>
        </trans-unit>
        <trans-unit id="a11a4c57a7f8dccbb14cb41b82dc14540c9e4cbe" translate="yes" xml:space="preserve">
          <source>Identifying resources on the Web</source>
          <target state="translated">识别网络上的资源</target>
        </trans-unit>
        <trans-unit id="2ddba376a063bd16e86e27e7bafe3713c58a5850" translate="yes" xml:space="preserve">
          <source>Identifying the issue</source>
          <target state="translated">查明问题</target>
        </trans-unit>
        <trans-unit id="5411f86a7d04f9bc55dfc770d7c059832dab58c1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Also) responses always lead to the use of a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; (Temporary Redirect) and &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; (Permanent Redirect) don't change the method used in the original request;</source>
          <target state="translated">如果&lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（另请参见）响应始终导致使用&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法，则&lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt;（临时重定向）和&lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt;（永久重定向）不会更改原始请求中使用的方法；</target>
        </trans-unit>
        <trans-unit id="203f83a39c006e96b0372879695a48c384f5a98d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Viewport-Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e6f0a239dfb82509e36ca577925e74a83f28f9" translate="yes" xml:space="preserve">
          <source>If = &quot;If&quot; &quot;:&quot; ( 1*No-tag-list | 1*Tagged-list )

     No-tag-list = List
     Tagged-list = Resource-Tag 1*List

     List = &quot;(&quot; 1*Condition &quot;)&quot;
     Condition = [&quot;Not&quot;] (State-token | &quot;[&quot; entity-tag &quot;]&quot;)
     ; entity-tag: see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;
     ; No LWS allowed between &quot;[&quot;, entity-tag and &quot;]&quot; 

     State-token = Coded-URL

     Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;
     ; Simple-ref: see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;
     ; No LWS allowed in Resource-Tag

   The syntax distinguishes between untagged lists (&quot;No-tag-list&quot;) and
   tagged lists (&quot;Tagged-list&quot;).  Untagged lists apply to the resource
   identified by the Request-URI, while tagged lists apply to the
   resource identified by the preceding Resource-Tag.

   A Resource-Tag applies to all subsequent Lists, up to the next
   Resource-Tag.

   Note that the two list types cannot be mixed within an If header.
   This is not a functional restriction because the No-tag-list syntax
   is just a shorthand notation for a Tagged-list production with a
   Resource-Tag referring to the Request-URI.

   Each List consists of one or more Conditions.  Each Condition is
   defined in terms of an entity-tag or state-token, potentially negated
   by the prefix &quot;Not&quot;.

   Note that the If header syntax does not allow multiple instances of
   If headers in a single request.  However, the HTTP header syntax
   allows extending single header values across multiple lines, by
   inserting a line break followed by whitespace (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;).</source>
          <target state="translated">If =&amp;ldquo; If&amp;rdquo;&amp;ldquo;：&amp;rdquo;（1 *无标记列表| 1 *标记列表）无标记列表=列表标记列表=资源标记1 *列表列表=&amp;ldquo;（&amp;rdquo; 1 *条件&amp;ldquo;） &amp;ldquo; Condition = [&amp;rdquo; Not&amp;ldquo;]（状态令牌|&amp;rdquo; [&amp;ldquo;实体标签&amp;rdquo;]&amp;ldquo;））；实体标签：请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]第3.11节&lt;/a&gt; ； &amp;ldquo; [&amp;rdquo;，entity-tag和&amp;ldquo;]&amp;rdquo;之间不允许使用LWS状态令牌=编码URL资源标签=&amp;ldquo; &amp;lt;&amp;rdquo; Simple-ref&amp;ldquo;&amp;gt;&amp;rdquo;;简单引用：请参见&lt;a href=&quot;#section-8.3&quot;&gt;第8.3节&lt;/a&gt; ; Resource-Tag中不允许使用LWS语法区分未标记列表（&amp;ldquo; No-tag-list&amp;rdquo;）和标记列表（&amp;ldquo; Tagged-list&amp;rdquo;）。未标记的列表适用于由Request-URI标识的资源，而标记的列表适用于由先前的Resource-Tag标识的资源。资源标签适用于所有后续列表，直至下一个资源标签。请注意，两种列表类型不能混入If标题中。这不是功能上的限制，因为&amp;ldquo;无标签列表&amp;rdquo;语法只是&amp;ldquo;标签列表&amp;rdquo;产品的缩写符号，其中&amp;ldquo;资源标签&amp;rdquo;引用了&amp;ldquo; Request-URI&amp;rdquo;。每个列表由一个或多个条件组成。每个条件都是根据实体标签或状态令牌定义的，可能会被前缀&amp;ldquo; Not&amp;rdquo;否定。请注意，If标头语法不允许在单个请求中使用If标头的多个实例。但是，HTTP标头语法允许通过在换行符后插入空格来扩展多行中的单个标头值（请参见[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]，&lt;a href=&quot;#section-4.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2 &lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="00bde6a2609129ada06a88cb9a7d89333869670f" translate="yes" xml:space="preserve">
          <source>If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame.</source>
          <target state="translated">如果HTTP管道化被激活,则可以发送多个请求,而无需等待第一个响应被完全接收。事实证明,HTTP管道化在现有的网络中很难实现,因为在现有网络中,旧的软件与现代版本共存。在HTTP/2中,HTTP pipelining已经被更强大的帧内多路复用请求所取代。</target>
        </trans-unit>
        <trans-unit id="748bef436e961cb49a985af369e84e4c57fb5faa" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are inadequate to access a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2712ef523f505fe38f908ee1d8ecd4882dfa22c9" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are not adequate to gain access for a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">如果（代理）服务器收到的有效凭据不足以获得对给定资源的访问权限，则服务器应使用&lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; 状态代码进行响应。与&lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 或&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; 需要&lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 不同，此用户无法进行身份验证。</target>
        </trans-unit>
        <trans-unit id="9c01487d51a7abfed59147d7589b11bd17b56929" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Key&quot;&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/a&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326ac990ab0dffc2412d939867b01ccdcb920f4c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DELETE&lt;/code&gt; method is successfully applied, there are several response status codes possible:</source>
          <target state="translated">如果成功应用了 &lt;code&gt;DELETE&lt;/code&gt; 方法，则可能有几种响应状态代码：</target>
        </trans-unit>
        <trans-unit id="e0abfc5dd0ca6cc561a0c1e9018bd30b2988a7b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">如果提供了 &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; 标头，则通过获取键的值，并将字符串&amp;ldquo; 258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;rdquo;连接到其上，并采用&lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;哈希值来计算此标头的值串联的字符串，结果为20字节。然后对该值进行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt;编码以获得该属性的值。</target>
        </trans-unit>
        <trans-unit id="34536e055c95da8db601f072a295ac2e4e5c6957" translate="yes" xml:space="preserve">
          <source>If a COPY request has an Overwrite header with a value of &quot;F&quot;, and a
   resource exists at the Destination URL, the server MUST fail the
   request.

   When a server executes a COPY request and overwrites a destination
   resource, the exact behavior MAY depend on many factors, including
   WebDAV extension capabilities (see particularly [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  For 

   example, when an ordinary resource is overwritten, the server could
   delete the target resource before doing the copy, or could do an in-
   place overwrite to preserve live properties.

   When a collection is overwritten, the membership of the destination
   collection after the successful COPY request MUST be the same
   membership as the source collection immediately before the COPY.
   Thus, merging the membership of the source and destination
   collections together in the destination is not a compliant behavior.

   In general, if clients require the state of the destination URL to be
   wiped out prior to a COPY (e.g., to force live properties to be
   reset), then the client could send a DELETE to the destination before
   the COPY request to ensure this reset.</source>
          <target state="translated">如果COPY请求的Overhead标头值为&amp;ldquo; F&amp;rdquo;，并且目标URL上存在资源，则服务器务必使请求失败。当服务器执行COPY请求并覆盖目标资源时，确切的行为可能取决于许多因素，包括WebDAV扩展功能（尤其是[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]）。例如，当普通资源被覆盖时，服务器可以在进行复制之前删除目标资源，或者可以就地覆盖以保留活动属性。当集合被覆盖时，在成功进行COPY请求之后，目标集合的成员身份必须与在COPY之前的源集合的成员身份相同。因此，将源集合和目标集合的成员身份合并到目标中并不是一种合规行为。通常，如果客户端要求在COPY之前清除目标URL的状态（例如，强制重置活动属性），则客户端可以在COPY请求之前将DELETE发送到目标，以确保此重置。</target>
        </trans-unit>
        <trans-unit id="0fb0c405e8ed86db97633eff664cd93d6b990ee4" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.</source>
          <target state="translated">如果一个缓存收到的值大于它能表示的值,或者它的任何后续计算溢出,缓存将认为该值是2147483648(2^31)或它能方便表示的最大正整数。</target>
        </trans-unit>
        <trans-unit id="f48cab758bf32db6fab20e2d919807414feba7e5" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider this value to be either 2,147,483,648 (2&lt;sup&gt;31&lt;/sup&gt;) or the greatest positive integer it can represent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f89453dd62bad0eede5073e7bfa49271c65312" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of a representation and wishes to have
   an up-to-date copy of the entire representation, it could use the
   Range header field with a conditional GET (using either or both of
   If-Unmodified-Since and If-Match.)  However, if the precondition
   fails because the representation has been modified, the client would
   then have to make a second request to obtain the entire current
   representation.

   The &quot;If-Range&quot; header field allows a client to &quot;short-circuit&quot; the
   second request.  Informally, its meaning is as follows: if the
   representation is unchanged, send me the part(s) that I am requesting
   in Range; otherwise, send me the entire representation.

     If-Range = entity-tag / HTTP-date

   A client MUST NOT generate an If-Range header field in a request that
   does not contain a Range header field.  A server MUST ignore an
   If-Range header field received in a request that does not contain a
   Range header field.  An origin server MUST ignore an If-Range header
   field received in a request for a target resource that does not
   support Range requests.

   A client MUST NOT generate an If-Range header field containing an
   entity-tag that is marked as weak.  A client MUST NOT generate an
   If-Range header field containing an HTTP-date unless the client has
   no entity-tag for the corresponding representation and the date is a
   strong validator in the sense defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.

   A server that evaluates an If-Range precondition MUST use the strong
   comparison function when comparing entity-tags (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;Section&amp;nbsp;2.3.2 of
   [RFC7232]&lt;/a&gt;) and MUST evaluate the condition as false if an HTTP-date 

   validator is provided that is not a strong validator in the sense
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.  A valid entity-tag can be
   distinguished from a valid HTTP-date by examining the first two
   characters for a DQUOTE.

   If the validator given in the If-Range header field matches the
   current validator for the selected representation of the target
   resource, then the server SHOULD process the Range header field as
   requested.  If the validator does not match, the server MUST ignore
   the Range header field.  Note that this comparison by exact match,
   including when the validator is an HTTP-date, differs from the
   &quot;earlier than or equal to&quot; comparison used when evaluating an
   If-Unmodified-Since conditional.</source>
          <target state="translated">如果客户端具有表示的部分副本，并希望拥有整个表示的最新副本，则可以将Range标头字段与条件GET一起使用（使用If-Unmodified-Since和If中的一个或两个） -Match。）但是，如果前提条件由于表示已被修改而失败，则客户端将不得不再次请求获取整个当前表示。 &amp;ldquo; If-Range&amp;rdquo;标头字段允许客户端&amp;ldquo;短路&amp;rdquo;第二个请求。非正式地，它的含义如下：如果表示形式不变，请向我发送我在Range中要求的零件；否则，请将整个陈述寄给我。If-Range =实体标签/ HTTP日期客户端不得在不包含Range头字段的请求中生成If-Range头字段。服务器必须忽略在不包含Range头域的请求中接收到的If-Range头域。源服务器必须忽略在对不支持范围请求的目标资源的请求中收到的If-Range头字段。客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强验证器，否则客户端不得生成包含HTTP日期的If-Range头字段。服务器必须忽略在不包含Range头域的请求中接收到的If-Range头域。源服务器必须忽略在对不支持范围请求的目标资源的请求中收到的If-Range头字段。客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强校验器，否则客户端不得生成包含HTTP日期的If-Range头字段。服务器必须忽略在不包含Range头域的请求中接收到的If-Range头域。源服务器必须忽略在对不支持范围请求的目标资源的请求中收到的If-Range头字段。客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强验证器，否则客户端不得生成包含HTTP日期的If-Range头字段客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强验证器，否则客户端不得生成包含HTTP日期的If-Range头字段。客户端不得生成包含包含标记为弱的实体标签的If-Range标头字段。除非客户端没有对应表示的实体标签，并且该日期在以下方面定义为强验证器，否则客户端不得生成包含HTTP日期的If-Range头字段。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]的2.2.2节&lt;/a&gt;。评估If-Range前提条件的服务器在比较实体标签时必须使用强比较函数（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;[RFC7232]的2.3.2节&lt;/a&gt;），并且如果提供的HTTP日期验证器不强，则必须将条件评估为false。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]第2.2.2节&lt;/a&gt;定义的验证器。通过检查DQUOTE的前两个字符，可以将有效的实体标签与有效的HTTP日期区分开。如果If-Range头字段中给出的验证器与目标资源的所选表示形式的当前验证器匹配，则服务器应按要求处理Range头字段。如果验证者不匹配，则服务器必须忽略Range标头字段。请注意，这种完全匹配的比较（包括验证器为HTTP日期时）与评估If-Unmodified-Since条件时使用的&amp;ldquo;早于或等于&amp;rdquo;比较不同。</target>
        </trans-unit>
        <trans-unit id="9d82e70ce9faffba2758cddebc66060093cca8ab" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of an entity in its cache, and wishes
   to have an up-to-date copy of the entire entity in its cache, it
   could use the Range request-header with a conditional GET (using
   either or both of If-Unmodified-Since and If-Match.) However, if the
   condition fails because the entity has been modified, the client
   would then have to make a second request to obtain the entire current
   entity-body.

   The If-Range header allows a client to &quot;short-circuit&quot; the second
   request. Informally, its meaning is `if the entity is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   entity'.

        If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date ) 

   If the client has no entity tag for an entity, but does have a Last-
   Modified date, it MAY use that date in an If-Range header. (The
   server can distinguish between a valid HTTP-date and any form of
   entity-tag by examining no more than two characters.) The If-Range
   header SHOULD only be used together with a Range header, and MUST be
   ignored if the request does not include a Range header, or if the
   server does not support the sub-range operation.

   If the entity tag given in the If-Range header matches the current
   entity tag for the entity, then the server SHOULD provide the
   specified sub-range of the entity using a 206 (Partial content)
   response. If the entity tag does not match, then the server SHOULD
   return the entire entity using a 200 (OK) response.</source>
          <target state="translated">如果客户端在缓存中拥有一个实体的部分副本,并且希望在缓存中拥有整个实体的最新副本,它可以使用Range请求头来进行有条件的GET(使用If-Unmodified-Since和If-Match中的任何一个或两个)。If-Range头允许客户端 &quot;短路 &quot;第二次请求。非正式地,它的意思是 &quot;如果实体没有变化,就给我发送我丢失的部分;否则,就给我发送整个新实体&quot;。If-Range=&quot;If-Range&quot; &quot;:&quot;(entity-tag | HTTP-date)如果客户端对一个实体没有实体标签,但有最后修改日期,它可以在If-Range头中使用该日期。服务器可以通过检查不超过两个字符来区分有效的HTTP-date和任何形式的实体标签。If-Range头只能和Range头一起使用,如果请求中不包含Range头,或者服务器不支持子范围操作,则必须忽略。如果在If-Range头中给出的实体标签与实体的当前实体标签相匹配,那么服务器应该使用206(部分内容)响应提供实体的指定子范围。如果实体标签不匹配,那么服务器SHOULD使用200(OK)响应返回整个实体。</target>
        </trans-unit>
        <trans-unit id="3088b6387af36bd48fbfec162964786d9f1bdf8a" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is also marked with the &lt;code&gt;Secure&lt;/code&gt; attribute, was sent from a secure origin, does &lt;em&gt;not&lt;/em&gt; include a &lt;code&gt;Domain&lt;/code&gt; attribute, and has the &lt;code&gt;Path&lt;/code&gt; attribute set to &lt;code&gt;/&lt;/code&gt;. In this way, these cookies can be seen as &quot;domain-locked&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c034021e921f0e666de945c6149637ed216dc323" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is marked with the &lt;code&gt;Secure&lt;/code&gt; attribute and was sent from a secure origin. This is weaker than the &lt;code&gt;__Host-&lt;/code&gt; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c875512b44481b0aec708d6ca539f3bb79d246" translate="yes" xml:space="preserve">
          <source>If a new cacheable (see sections &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;, &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; and &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;)
   response is received from a resource while any existing responses for
   the same resource are cached, the cache SHOULD use the new response
   to reply to the current request. It MAY insert it into cache storage
   and MAY, if it meets all other requirements, use it to respond to any
   future requests that would previously have caused the old response to
   be returned. If it inserts the new response into cache storage  the
   rules in &lt;a href=&quot;#section-13.5.3&quot;&gt;section 13.5.3&lt;/a&gt; apply.

      Note: a new response that has an older Date header value than
      existing cached responses is not cacheable.</source>
          <target state="translated">如果一个新的缓存（见第&lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;，&lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;，&lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;和&lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;）响应从同时对同一资源的任何现有的响应缓存在资源接收，高速缓存应该使用新的响应回复当前请求。它可以将其插入缓存存储，如果满足所有其他要求，则可以使用它来响应将来可能导致旧响应返回的任何将来请求。如果它将新的响应插入缓存存储，则适用&lt;a href=&quot;#section-13.5.3&quot;&gt;第13.5.3节中&lt;/a&gt;的规则。注意：具有比现有缓存响应更早的Date标头值的新响应是不可缓存的。</target>
        </trans-unit>
        <trans-unit id="e58c73fa3ef27580bf7799dda53dd96a70453ff2" translate="yes" xml:space="preserve">
          <source>If a request goes through multiple proxies, the IP addresses of each successive proxy is listed. This means, the right-most IP address is the IP address of the most recent proxy and the left-most IP address is the IP address of the originating client.</source>
          <target state="translated">如果一个请求经过多个代理,则会列出每个连续代理的IP地址。也就是说,最右边的IP地址是最近的代理服务器的IP地址,最左边的IP地址是发起客户端的IP地址。</target>
        </trans-unit>
        <trans-unit id="e2c3c58894ac3aaacdbb37189725a1f26ce869ef" translate="yes" xml:space="preserve">
          <source>If a resource exists at the destination and the Overwrite header is
   &quot;T&quot;, then prior to performing the move, the server MUST perform a
   DELETE with &quot;Depth: infinity&quot; on the destination resource.  If the
   Overwrite header is set to &quot;F&quot;, then the operation will fail.</source>
          <target state="translated">如果在目的地存在资源,并且Overwrite头为 &quot;T&quot;,那么在执行移动之前,服务器必须对目的地资源进行 &quot;Depth:infinity &quot;的DELETE操作。如果将Overwrite头设置为 &quot;F&quot;,则操作会失败。</target>
        </trans-unit>
        <trans-unit id="22db687e87d90b4a5b61ae1c9f192564fbed5581" translate="yes" xml:space="preserve">
          <source>If a same-site cookie has this attribute, the browser will only send cookies if the request originated from the website that set the cookie. If the request originated from a different URL than the URL of the current location, none of the cookies tagged with the &lt;code&gt;strict&lt;/code&gt; attribute will be included.</source>
          <target state="translated">如果同一站点的cookie具有此属性，则仅当请求来自设置cookie的网站时，浏览器才会发送cookie。如果请求源自与当前位置的URL不同的URL，则不会包含标记为 &lt;code&gt;strict&lt;/code&gt; 属性的cookie 。</target>
        </trans-unit>
        <trans-unit id="a78f222e9151b20e3fa58d2b5922efdfbb1c1a0f" translate="yes" xml:space="preserve">
          <source>If a server returns such an error status, the body of the message should contain the list of the available representations of the resources, allowing the user to choose among them.</source>
          <target state="translated">如果服务器返回这样的错误状态,消息的主体应该包含资源的可用表示列表,允许用户在其中进行选择。</target>
        </trans-unit>
        <trans-unit id="acb751d12ffe14eea97f1844541379bb1e82d026" translate="yes" xml:space="preserve">
          <source>If a single server supports multiple organizations that do not trust
   one another, then it MUST check the values of Location and Content-
   Location headers in responses that are generated under control of
   said organizations to make sure that they do not attempt to
   invalidate resources over which they have no authority.</source>
          <target state="translated">如果一台服务器支持多个互不信任的组织,那么它必须检查在上述组织控制下生成的响应中的Location和Content-位置头的值,以确保它们不会试图使它们没有权限的资源无效。</target>
        </trans-unit>
        <trans-unit id="0034277126e29616d67034416858786a6bf01601" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header to the response of https://example.com/logout:</source>
          <target state="translated">如果用户退出您的网站或服务，则可能要删除本地存储的数据。您可以通过在https://example.com/logout的响应中添加 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 标头来实现：</target>
        </trans-unit>
        <trans-unit id="28708bd5ed063a05bc0c1ffae01007cff1ddad84" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header when sending the page confirming that logging out from the site has been accomplished successfully (https://example.com/logout, for example):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5c04bfd2a5924b2636ab2156504c08859b88e5" translate="yes" xml:space="preserve">
          <source>If a website accepts a connection through HTTP and redirects to HTTPS, visitors may initially communicate with the non-encrypted version of the site before being redirected, if, for example, the visitor types http://www.foo.com/ or even just foo.com. This creates an opportunity for a man-in-the-middle attack. The redirect could be exploited to direct visitors to a malicious site instead of the secure version of the original site.</source>
          <target state="translated">如果一个网站接受通过HTTP的连接,并重定向到HTTPS,访问者可能在重定向之前最初与非加密版本的网站进行通信,例如,如果访问者键入http://www.foo.com/,甚至只是foo.com。这就为中间人攻击创造了机会。重定向可以被利用,将访问者引导到一个恶意网站,而不是原始网站的安全版本。</target>
        </trans-unit>
        <trans-unit id="c5d743f58d38a06b0efb87624e4399a8e4fa3b88" translate="yes" xml:space="preserve">
          <source>If all proxies are down, and there was no DIRECT option specified, the browser will ask if proxies should be temporarily ignored, and direct connections attempted. After 20 minutes, the browser will ask if proxies should be retried, asking again after an additional 40 minutes. Queries will continue, always adding 20 minutes to the elapsed time between queries.</source>
          <target state="translated">如果所有的代理服务器都瘫痪了,而且没有指定DIRECT选项,浏览器会询问是否应该暂时忽略代理服务器,并尝试直接连接。20分钟后,浏览器会询问是否应该重新尝试代理,再过40分钟后再次询问。查询将继续进行,查询之间的时间总是增加20分钟。</target>
        </trans-unit>
        <trans-unit id="24f0c3aae5a8cb6b90479558f98a655abee38832" translate="yes" xml:space="preserve">
          <source>If an HTTP/1.1 client sends a request which includes a request body,
   but which does not include an Expect request-header field with the
   &quot;100-continue&quot; expectation, and if the client is not directly
   connected to an HTTP/1.1 origin server, and if the client sees the
   connection close before receiving any status from the server, the
   client SHOULD retry the request.  If the client does retry this
   request, it MAY use the following &quot;binary exponential backoff&quot;
   algorithm to be assured of obtaining a reliable response:

      1. Initiate a new connection to the server

      2. Transmit the request-headers

      3. Initialize a variable R to the estimated round-trip time to the
         server (e.g., based on the time it took to establish the
         connection), or to a constant value of 5 seconds if the round-
         trip time is not available.

      4. Compute T = R * (2**N), where N is the number of previous
         retries of this request.

      5. Wait either for an error response from the server, or for T
         seconds (whichever comes first)

      6. If no error response is received, after T seconds transmit the
         body of the request.

      7. If client sees that the connection is closed prematurely,
         repeat from step 1 until the request is accepted, an error
         response is received, or the user becomes impatient and
         terminates the retry process. 

   If at any point an error status is received, the client

      - SHOULD NOT continue and

      - SHOULD close the connection if it has not completed sending the
        request message.</source>
          <target state="translated">如果一个HTTP/1.1客户端发送了一个包含请求体的请求,但该请求不包含带有 &quot;100-continue &quot;期望值的Expect request-header字段,并且如果客户端没有直接连接到HTTP/1.1源服务器,并且如果客户端在收到服务器的任何状态之前看到连接关闭,客户端应该重试该请求。如果客户端确实重试了这个请求,它可以使用以下 &quot;二进制指数回退 &quot;算法来保证获得可靠的响应。1.启动一个新的连接到服务器 2.传送请求头 3.将一个变量R初始化为估计到服务器的往返时间(例如,基于建立连接所花费的时间),如果没有往返时间,则初始化为一个5秒的常量值。4.计算T=R*(2**N),其中N为该请求的前次重试次数。5.等待服务器的错误响应,或者等待T秒(以先到者为准)6.如果没有收到错误响应,在T秒后传输请求的主体。7.如果客户端认为连接过早关闭,则从第1步开始重复,直到请求被接受,收到错误响应,或者用户不耐烦而终止重试过程。如果在任何时候收到错误状态,客户端--不应该继续,--如果没有完成发送请求消息,应该关闭连接。</target>
        </trans-unit>
        <trans-unit id="787c64d4a2d625599ff698430e64f8f08ddeb6a2" translate="yes" xml:space="preserve">
          <source>If an origin server does not explicitly specify freshness (e.g. using &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header) then a heuristic approach may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf50575579d857df6c5f0e97dcbebb456e6ad37f" translate="yes" xml:space="preserve">
          <source>If another principal locks a resource that a principal wishes to
   access, it is useful for the second principal to be able to find out
   who the first principal is.  For this purpose the DAV:lockdiscovery
   property is provided.  This property lists all outstanding locks,
   describes their type, and MAY even provide the lock tokens.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:lockdiscovery property.</source>
          <target state="translated">如果另一个委托人锁定了一个委托人希望访问的资源,那么第二个委托人就可以知道第一个委托人是谁。为此,我们提供了 DAV:lockdiscovery 属性。这个属性列出了所有未完成的锁,描述了它们的类型,甚至可以提供锁的标记。任何支持 LOCK 方法的 DAV 兼容资源都必须支持 DAV:lockdiscovery 属性。</target>
        </trans-unit>
        <trans-unit id="4e1966a722bf8f31efed779517aa3c6a04a51ec9" translate="yes" xml:space="preserve">
          <source>If both &lt;strong&gt;wd1 &lt;/strong&gt;and &lt;strong&gt;wd1 &lt;/strong&gt;are defined, the condition is true if the current weekday is in between those two &lt;em&gt;ordered &lt;/em&gt;weekdays. Bounds are inclusive, &lt;em&gt;but the bounds are ordered&lt;/em&gt;. If the &quot;GMT&quot; parameter is specified, times are taken to be in GMT. Otherwise, the local timezone is used.</source>
          <target state="translated">如果同时定义了&lt;strong&gt;wd1&lt;/strong&gt;和&lt;strong&gt;wd1&lt;/strong&gt;，则当当前工作日在这两个&lt;em&gt;有序&lt;/em&gt;工作日之间时，条件为true 。边界是包容的，&lt;em&gt;但边界是有序的&lt;/em&gt;。如果指定了&amp;ldquo; GMT&amp;rdquo;参数，则时间以GMT为单位。否则，将使用本地时区。</target>
        </trans-unit>
        <trans-unit id="9452662d9180b8ba3efe3a780c450ae27e07209e" translate="yes" xml:space="preserve">
          <source>If both a &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header are present in the same response, both policies are honored. The policy specified in &lt;code&gt;Content-Security-Policy&lt;/code&gt; headers is enforced while the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; policy generates reports but is not enforced.</source>
          <target state="translated">如果在同一响应中同时存在&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;标头和&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;标头，则将遵循这两个策略。 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 标头中指定的策略被强制执行，而 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 策略仅生成报告，但不强制执行。</target>
        </trans-unit>
        <trans-unit id="d126e6f1349def738aa84d3d7ade4189f1674e03" translate="yes" xml:space="preserve">
          <source>If both this directive (i.e. via the &lt;code&gt;allow&lt;/code&gt; attribute) and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence. There was a bug whereby the &lt;code&gt;fullscreen&lt;/code&gt; directive didn't work unless the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute was also present, but this has been fixed as of Firefox 80 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1608358&quot;&gt;bug 1608358&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7feb971c53a1e3363d82fc1ef6da1a87db0cb6b" translate="yes" xml:space="preserve">
          <source>If both this directive and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 元素上同时存在此指令和 &lt;code&gt;allowfullscreen&lt;/code&gt; 属性，则该指令优先。</target>
        </trans-unit>
        <trans-unit id="62b0316637ce393c10dfd9b58aa37bf2f0a42cdc" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Content-Language&lt;/code&gt; is specified, the default is that the content is intended for all language audiences. Multiple language tags are also possible, as well as applying the &lt;code&gt;Content-Language&lt;/code&gt; header to various media types and not only to textual documents.</source>
          <target state="translated">如果未指定 &lt;code&gt;Content-Language&lt;/code&gt; ，则默认值为该内容适用于所有语言的受众。也可以使用多种语言标签，以及将 &lt;code&gt;Content-Language&lt;/code&gt; 标头应用于各种媒体类型，而不仅是文本文档。</target>
        </trans-unit>
        <trans-unit id="5f0faef3900e1d15f4d91c1fcfcd5a68d9578e75" translate="yes" xml:space="preserve">
          <source>If no URL scheme is specified for a &lt;code&gt;host-source&lt;/code&gt; and the iframe is loaded from an &lt;code&gt;https&lt;/code&gt; URL, the URL for the page loading the iframe must also be &lt;code&gt;https&lt;/code&gt;, per the W3C spec on &lt;a href=&quot;https://w3c.github.io/webappsec-csp/2/#match-source-expression&quot;&gt;matching source expressions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2432969974e0bf99b152d397b2c719d44cd0439e" translate="yes" xml:space="preserve">
          <source>If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">如果没有给定端口,则意味着请求服务的默认端口(例如,HTTP URL的 &quot;80&quot;)。</target>
        </trans-unit>
        <trans-unit id="9619fd8159a262a6e7f8b156f3e9ea6322194094" translate="yes" xml:space="preserve">
          <source>If no port is included, the default port for the service requested (e.g., &lt;code&gt;443&lt;/code&gt; for an HTTPS URL, and &lt;code&gt;80&lt;/code&gt; for an HTTP URL) is implied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e478b06858c696e70a28213656753916abc92ba3" translate="yes" xml:space="preserve">
          <source>If omitted, defaults to the host of the current document URL, not including subdomains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219c745dfe181251ec5c580abc0c14da79c6b291" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: day, month, year), the function returns a true value only on days that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">如果仅指定一个值（来自每个类别：日，月，年），则该函数仅在与该规范匹配的日期返回真值。如果同时指定了两个值，那么在这些时间（包括界限）之间，结果为true，&lt;em&gt;但是界限是有序的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ebc918364962297bbe2d03e861cdada5a4d5d17c" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: hour, minute, second), the function returns a true value only at times that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">如果仅指定单个值（来自每个类别：小时，分钟，秒），则该函数仅在与该规范匹配的时间返回真值。如果同时指定了两个值，那么在这些时间（包括界限）之间，结果为true，&lt;em&gt;但是界限是有序的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7ad3b8639eddeee4168cd5b47edae6dcb2df2c3c" translate="yes" xml:space="preserve">
          <source>If only one parameter is present, the function returns a value of true on the weekday that the parameter represents. If the string &quot;GMT&quot; is specified as a second parameter, times are taken to be in GMT. Otherwise, they are assumed to be in the local timezone.</source>
          <target state="translated">如果只有一个参数,函数在该参数所代表的工作日返回值为true。如果字符串 &quot;GMT &quot;被指定为第二个参数,时间将被视为GMT。否则,将假定为当地时区。</target>
        </trans-unit>
        <trans-unit id="b64b7edace3c1de8eea4e9f7cb502c7f66cbbfc3" translate="yes" xml:space="preserve">
          <source>If several ranges are sent back, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;multipart/byteranges&lt;/code&gt; and each fragment covers one range, with &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; describing it.</source>
          <target state="translated">如果发回多个范围，则将&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;multipart/byteranges&lt;/code&gt; ，每个片段覆盖一个范围，并用&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 对其进行&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="78a2139f59af3c201e14f90fe9cef770569b0d29" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support for partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">如果网站省略了 &lt;code&gt;Accept-Ranges&lt;/code&gt; 标头，则它们可能不支持部分请求。一些站点还显式发送&amp;ldquo; &lt;code&gt;none&lt;/code&gt; &amp;rdquo;作为值，表示不支持。在某些应用中，下载管理器会在这种情况下禁用其暂停按钮。</target>
        </trans-unit>
        <trans-unit id="c8a2e2bc49a74014d19dc3e20faf6d47f4b2c5fb" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091a0218219abd0cdbbefc8a401d17bce706512c" translate="yes" xml:space="preserve">
          <source>If that's not possible, then another way is to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7832c9e8ca11a0dc4da645bd06786210e575896b" translate="yes" xml:space="preserve">
          <source>If the &quot;Basic&quot; authentication scheme is used, the credentials are constructed like this:</source>
          <target state="translated">如果使用 &quot;基本 &quot;认证方案,则凭证的构造如下。</target>
        </trans-unit>
        <trans-unit id="f91174398d0cf4de63fc9e0993886a3f7ebd8264" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request and cURL, for example.</source>
          <target state="translated">如果HTTP响应中存在&amp;ldquo; &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt;（且其值不是&amp;ldquo; &lt;code&gt;none&lt;/code&gt; &amp;rdquo;），则服务器支持范围请求。例如，您可以通过发出&lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;请求和cURL进行检查。</target>
        </trans-unit>
        <trans-unit id="1e2bd82bb2d016fc76410dd12a3b0342a93316e7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request with cURL, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c9cc929b4bd0a174617d37fdb2ef2438aa90fc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; can't detect any value specified for this header&amp;mdash;even though the header is included in the response&amp;mdash;this error occurs.</source>
          <target state="translated">如果&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;无法检测到为此标头指定的任何值（即使标头包含在响应中），也会发生此错误。</target>
        </trans-unit>
        <trans-unit id="37fea5e541c03ceff1dd1b298e2c8a47aff43276" translate="yes" xml:space="preserve">
          <source>If the CORS configuration isn't setup correctly, the browser console will present an error like &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; indicating that the request was blocked due to violating the CORS security rules. This might not necessarily be a set-up mistake, though. It's possible that the request is in fact intentionally being disallowed by the user's web application and remote external service. However, If the endpoint is meant to be available, some debugging is needed to succeed.</source>
          <target state="translated">如果未正确设置CORS配置，则浏览器控制台将显示错误消息，例如 &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; 表明该请求由于违反了CORS安全性而被阻止规则。但是，这不一定是设置错误。实际上，用户的Web应用程序和远程外部服务实际上有意禁止了该请求。但是，如果要使端点可用，则需要进行一些调试才能成功。</target>
        </trans-unit>
        <trans-unit id="dc9c7b7249ed9c2cd26babda62bc7a605dd20286" translate="yes" xml:space="preserve">
          <source>If the CORS request indicated by the preflight request is authorized, the server will respond to the preflight request with a message that indicates the allowed origin, methods and headers. Below we see that &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; includes the headers that were requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ffab7457821dbf47b42281a4936c9c518bf014" translate="yes" xml:space="preserve">
          <source>If the attribute is set to lax, same-site cookies are withheld on cross-domain subrequests, such as calls to load images or frames, but will be sent when a user naviates to the URL from an external site, for example, by following a link.</source>
          <target state="translated">如果该属性被设置为宽松,那么在跨域子请求中,例如调用加载图像或框架时,同站cookie将被扣留,但当用户从外部网站导航到URL时,例如通过跟随一个链接,将被发送。</target>
        </trans-unit>
        <trans-unit id="5d7a35532093cac38ce9488b4579d2ba232c9fa7" translate="yes" xml:space="preserve">
          <source>If the client has performed a conditional GET request and access is
   allowed, but the document has not been modified, the server SHOULD
   respond with this status code. The 304 response MUST NOT contain a
   message-body, and thus is always terminated by the first empty line
   after the header fields.

   The response MUST include the following header fields:

      - Date, unless its omission is required by &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; 

   If a clockless origin server obeys these rules, and proxies and
   clients add their own Date to any response received without one (as
   already specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], section&amp;nbsp;14.19&lt;/a&gt;), caches will operate
   correctly.

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the conditional GET used a strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;), the response SHOULD NOT include other entity-headers.
   Otherwise (i.e., the conditional GET used a weak validator), the
   response MUST NOT include other entity-headers; this prevents
   inconsistencies between cached entity-bodies and updated headers.

   If a 304 response indicates an entity not currently cached, then the
   cache MUST disregard the response and repeat the request without the
   conditional.

   If a cache uses a received 304 response to update a cache entry, the
   cache MUST update the entry to reflect any new field values given in
   the response.</source>
          <target state="translated">如果客户端已经执行了有条件的GET请求，并且允许访问，但是文档没有被修改，则服务器应该以该状态码响应。 304响应必须不包含消息正文，因此始终由标头字段之后的第一个空行终止。响应必须包含以下标头字段：-日期，除非&lt;a href=&quot;#section-14.18.1&quot;&gt;第14.18.1节&lt;/a&gt;要求省略，否则， 如果无时钟源服务器遵守这些规则，并且代理和客户端将自己的日期添加到没有响应的任何响应中（如&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068]，第14.19节&lt;/a&gt;），缓存将正常运行。 -ETag和/或Content-Location（如果标头是在对同一请求的200响应中发送的）-Expires，Cache-Control和/或Vary（如果字段值可能与任何先前响应中发送的字段值不同）对于相同的变量，如果条件GET使用了强缓存验证器（请参见&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3 &lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;节）&lt;/a&gt;），则响应不应包含其他实体标题。否则（即，条件GET使用了弱验证器），响应必须不包括其他实体头；这可以防止缓存的实体与更新的标头之间的不一致。如果304响应指示当前未缓存的实体，则缓存必须忽略响应，并在没有条件的情况下重复请求。如果缓存使用收到的304响应来更新缓存条目，则缓存必须更新该条目以反映响应中给定的任何新字段值。</target>
        </trans-unit>
        <trans-unit id="1b16cb43ac59e1398b6bbb6871dcb2c0b0c8621f" translate="yes" xml:space="preserve">
          <source>If the client receiving the &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; response is willing and able to upgrade to TLS, it should then start the same process covered above under &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;Client-initiated upgrade to TLS&lt;/a&gt;.</source>
          <target state="translated">如果收到 &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; 响应的客户端愿意并且能够升级到TLS，则它应开始与&lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;客户端启动的升级到TLS&lt;/a&gt;所述相同的过程。</target>
        </trans-unit>
        <trans-unit id="280f043319dde7fe251e1850244792cbea213b6e" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data.</source>
          <target state="translated">如果数据是文本数据，则可以简单地嵌入文本（使用适当的实体或根据随附文档的类型进行转义）。否则，您可以指定 &lt;code&gt;base64&lt;/code&gt; 来嵌入base64编码的二进制数据。</target>
        </trans-unit>
        <trans-unit id="32b1f46a0b7b90a86ae9e9f167e9ef7cf8038c9c" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data. You can find more info on MIME types &lt;a href=&quot;mime_types&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;mime_types/complete_list_of_mime_types&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8559d1d219606090271c33a621201ee02497f80" translate="yes" xml:space="preserve">
          <source>If the desired resource width is not known at the time of the request or the resource does not have a display width, the &lt;code&gt;Width&lt;/code&gt; header field can be omitted. If &lt;code&gt;Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18b5decb40c51cfed52abf66cbdc2d7b99ae4e9" translate="yes" xml:space="preserve">
          <source>If the device is large enough that it's not marked with &amp;ldquo;Mobi&amp;rdquo;, you should serve your desktop site (which, as a best practice, should support touch input anyway, as more desktop machines are appearing with touchscreens).</source>
          <target state="translated">如果设备足够大，没有用&amp;ldquo; Mobi&amp;rdquo;标记，则应为台式机站点提供服务（作为最佳实践，无论如何，随着越来越多的台式机与触摸屏一起出现，该站点应始终支持触摸输入）。</target>
        </trans-unit>
        <trans-unit id="0bbaf264d9f0d932c54c0e04e65ebace7f115760" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">如果哈希值不匹配，则表示文档已在中间进行编辑，并引发&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Precondition Failed&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="277939955257bc43f4243fef87536e0654d15a25" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd651b3de41c4c0939b139c2bcd1ec691c3efd5" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bde6b2f02854c6b43c647e825f2d4a1429eb84b" translate="yes" xml:space="preserve">
          <source>If the request is being issued using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, make sure you're not setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;withCredentials&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;发出请求，请确保未将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;withCredentials&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f1a69e15b2780621067297dd234a0594b2b2ffc" translate="yes" xml:space="preserve">
          <source>If the requested method isn't supported, the server will respond with an error.</source>
          <target state="translated">如果请求的方法不被支持,服务器将以错误的方式响应。</target>
        </trans-unit>
        <trans-unit id="bd63754e6e7fd0ed5e66293b22c5760094fd4fcf" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value &lt;em&gt;must&lt;/em&gt; be generated. A comparison of them can determine whether two representations of a resource are the same. Etags are therefore similar to fingerprints, and might also be used for tracking purposes by some servers. They might also be set to persist indefinitely by a tracking server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618a8054c6dfe27daf59e1f19b56a3219ec450e" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">如果给定URL上的资源发生更改，则必须生成一个新的 &lt;code&gt;Etag&lt;/code&gt; 值。因此，Etag与指纹相似，某些服务器也可能将其用于跟踪目的。通过对它们的比较，可以快速确定资源的两种表示形式是否相同，但是也可以将它们设置为由跟踪服务器无限期地保留。</target>
        </trans-unit>
        <trans-unit id="6df0a809ea7c0e16c3b4c1d61decdfe31ac868f4" translate="yes" xml:space="preserve">
          <source>If the resource has changed, the server just sends back a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt; OK&lt;/code&gt; response, with the new version of the resource, like if the request wasn't conditional and the client uses this new resource (and caches it).</source>
          <target state="translated">如果资源已更改，则服务器仅使用新版本的资源发送回&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt; OK&lt;/code&gt; 响应，就像请求不是有条件的，并且客户端使用此新资源（并将其缓存）一样。</target>
        </trans-unit>
        <trans-unit id="28dabd823abd95eebd0c73b38250e390477657ad" translate="yes" xml:space="preserve">
          <source>If the resource has not changed, the server sends back a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response. This makes the cache fresh again, and the client uses the cached resource. Although there is a response/request round-trip that consumes some resources, this is more efficient than to transmit the whole resource over the wire again.</source>
          <target state="translated">如果资源没有更改，则服务器会发回&lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 响应。这将使缓存再次刷新，并且客户端将使用缓存的资源。尽管有一个往返的响应/请求消耗了一些资源，但是这比再次通过有线传输整个资源更有效。</target>
        </trans-unit>
        <trans-unit id="96d3b1fd891c66341051bdd2445935c9e27b47b5" translate="yes" xml:space="preserve">
          <source>If the resource in question is meant to be widely accessed (just like any HTTP resource accessed by GET), then sending back the &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: *&lt;/code&gt; header will be sufficient, &lt;strong&gt;unless&lt;/strong&gt; the resource needs credentials such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication information.</source>
          <target state="translated">如果有问题的资源打算被广泛访问（就像GET访问的任何HTTP资源一样），则发回&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: *&lt;/code&gt; 标头就足够了，&lt;strong&gt;除非&lt;/strong&gt;该资源需要&lt;a href=&quot;cookies&quot;&gt;Cookie&lt;/a&gt;和HTTP之类的凭据认证信息。</target>
        </trans-unit>
        <trans-unit id="5afbe977f3fe9a82606049c55808c60ca15cfb67" translate="yes" xml:space="preserve">
          <source>If the resource should be kept restricted based on requester domain, &lt;strong&gt;OR&lt;/strong&gt; if the resource needs to be accessed with credentials (or sets credentials), then filtering by the request's &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header may be necessary, or at least echoing back the requester's &lt;code&gt;Origin&lt;/code&gt; (e.g. &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;). Additionally, the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header will have to be sent. This is discussed in a &lt;a href=&quot;#Credentialed_Requests&quot;&gt;subsequent section&lt;/a&gt;.</source>
          <target state="translated">如果应该根据请求者的域来限制资源，&lt;strong&gt;或者&lt;/strong&gt;如果需要使用凭据（或设置凭据）来访问资源，则可能有必要通过请求的&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;头进行过滤，或者至少回显请求者的 &lt;code&gt;Origin&lt;/code&gt; （例如&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; : //arunranga.com）。此外，必须发送&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; 标头。这将在&lt;a href=&quot;#Credentialed_Requests&quot;&gt;后续部分中&lt;/a&gt;讨论。</target>
        </trans-unit>
        <trans-unit id="9c8e2ffc70a619ab233773bc1539c19cb10a2bc1" translate="yes" xml:space="preserve">
          <source>If the response to a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached URL response is now outdated, the cached copy is invalidated even if no &lt;code&gt;GET&lt;/code&gt; request was made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a622ab8c535a47b0b491a95d39cc072896a324" translate="yes" xml:space="preserve">
          <source>If the result of a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached resource after a &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request is now outdated, the cache is invalidated, even if no &lt;code&gt;GET&lt;/code&gt; request has been made.</source>
          <target state="translated">如果 &lt;code&gt;HEAD&lt;/code&gt; 请求的结果表明&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;请求后的缓存资源现在已过期，则即使没有发出 &lt;code&gt;GET&lt;/code&gt; 请求，该缓存也会无效。</target>
        </trans-unit>
        <trans-unit id="8883378b1d0c73e1288f1ade4a8139bb08b162fd" translate="yes" xml:space="preserve">
          <source>If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g. language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).

   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   &quot;best guess&quot; to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user). In order to improve the server's
   guess, the user agent MAY include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.

   Server-driven negotiation has disadvantages:

      1. It is impossible for the server to accurately determine what
         might be &quot;best&quot; for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).

      2. Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.

      3. It complicates the implementation of an origin server and the
         algorithms for generating responses to a request. 

      4. It may limit a public cache's ability to use the same response
         for multiple user's requests.

   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;), Accept-
   Charset (&lt;a href=&quot;#section-14.2&quot;&gt;section 14.2&lt;/a&gt;), Accept-Encoding (&lt;a href=&quot;#section-14.3&quot;&gt;section 14.3&lt;/a&gt;), Accept-
   Language (&lt;a href=&quot;#section-14.4&quot;&gt;section 14.4&lt;/a&gt;), and User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;). However, an
   origin server is not limited to these dimensions and MAY vary the
   response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.

   The Vary  header field can be used to express the parameters the
   server uses to select a representation that is subject to server-
   driven negotiation. See &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field
   by caches and &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header field by
   servers.</source>
          <target state="translated">如果通过服务器上的算法为响应选择最佳表示形式，则称为服务器驱动的协商。选择是基于响应的可用表示形式（其可以变化的维度；例如语言，内容编码等）以及请求消息中特定标头字段的内容或与请求有关的其他信息（例如作为客户端的网络地址）。当难以从可用表示中进行选择的算法难以描述给用户代理时，或者当服务器希望将其&amp;ldquo;最佳猜测&amp;rdquo;与第一个响应一起发送给客户端时，服务器驱动的协商会非常有利。如果&amp;ldquo;最佳猜测&amp;rdquo;，则后续请求的往返延迟对用户来说足够好）。为了改善服务器的猜测，用户代理可以包括请求报头字段（Accept，Accept-Language，Accept-Encoding等），它们描述了服务器对这种响应的偏好。服务器驱动的协商具有以下缺点：1.服务器无法准确确定对任何给定用户而言&amp;ldquo;最佳&amp;rdquo;的东西，因为这将需要完全了解用户代理的功能以及响应的预期用途（例如，用户是要在屏幕上查看还是在纸上打印？）。 2。让用户代理在每个请求中描述其功能可能会非常低效（假设只有一小部分响应具有多种表示形式），并且可能会侵犯用户的隐私。 3.它使源服务器的实现和用于生成对请求的响应的算法变得复杂。 4.这可能会限制公共缓存对多个用户请求使用相同响应的能力。 HTTP / 1.1包括以下请求标头字段，用于通过描述用户代理功能和用户首选项来启用服务器驱动的协商：接受（4.这可能会限制公共缓存对多个用户请求使用相同响应的能力。 HTTP / 1.1包括以下请求标头字段，用于通过描述用户代理功能和用户首选项来启用服务器驱动的协商：接受（4.这可能会限制公共缓存对多个用户请求使用相同响应的能力。 HTTP / 1.1包含以下请求标头字段，用于通过描述用户代理功能和用户首选项来启用服务器驱动的协商：接受（&lt;a href=&quot;#section-14.1&quot;&gt;第14.1节&lt;/a&gt;），接受字符集（&lt;a href=&quot;#section-14.2&quot;&gt;第14.2节&lt;/a&gt;），接受编码（&lt;a href=&quot;#section-14.3&quot;&gt;第14.3节&lt;/a&gt;），接受语言（&lt;a href=&quot;#section-14.4&quot;&gt;第14.4节&lt;/a&gt;）和用户代理（&lt;a href=&quot;#section-14.43&quot;&gt;第14.43节&lt;/a&gt;）。但是，源服务器不限于这些维度，并且可以基于请求的任何方面改变响应，包括请求标头字段之外或本规范未定义的扩展标头字段内的信息。Vary标头字段可用于表示服务器用来选择要经过服务器驱动的协商的表示形式的参数。有关高速缓存对Vary标头字段的使用，请参见&lt;a href=&quot;#section-13.6&quot;&gt;第13.6节&lt;/a&gt;，以及&lt;a href=&quot;#section-14.44&quot;&gt;第14.44节&lt;/a&gt; 供服务器使用Vary标头字段。</target>
        </trans-unit>
        <trans-unit id="a97009ed5a171d3f2d00627248f02de9b1bd4edb" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does not&lt;/em&gt; support TLS upgrade, or is unable to upgrade to TLS at the time, it responds with a standard HTTP/1.1 response, such as:</source>
          <target state="translated">如果服务器&lt;em&gt;不&lt;/em&gt;支持TLS升级，或者当时无法升级到TLS，则服务器将使用标准HTTP / 1.1响应进行响应，例如：</target>
        </trans-unit>
        <trans-unit id="2c4956e2baa89a364f68e36f2540d46e391032b0" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; recognize the method, but intentionally does not support it, the appropriate response is &lt;a href=&quot;405&quot;&gt;&lt;code&gt;405 Method Not Allowed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4ec0bc4d37ddaf3aac7f70b029b83445ca56f2" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; support TLS upgrade and wishes to permit the upgrade, it responds with the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; response code, like this:</source>
          <target state="translated">如果服务器&lt;em&gt;确实&lt;/em&gt;支持TLS升级并希望允许升级，则它将使用 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 响应代码进行响应，如下所示：</target>
        </trans-unit>
        <trans-unit id="a57f9acb3600d5372bf47b96b972a2c0b7a106b1" translate="yes" xml:space="preserve">
          <source>If the server allows CORS requests to use the &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; method, it responds with an &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; response header, which lists &lt;code&gt;DELETE&lt;/code&gt; along with the other methods it supports:</source>
          <target state="translated">如果服务器允许CORS请求使用&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;方法，它将以&lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;响应标头进行响应，该响应标头列出 &lt;code&gt;DELETE&lt;/code&gt; 及其支持的其他方法：</target>
        </trans-unit>
        <trans-unit id="be2369485a151abd59881e4ba1cc5463e20c789a" translate="yes" xml:space="preserve">
          <source>If the server can't communicate using the specified version of the WebSocket protocol, it will respond with an error (such as 426 Upgrade Required) that includes in its headers a &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header with a comma-separated list of the supported protocol versions. If the server does support the requested protocol version, no &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header is included in the response.</source>
          <target state="translated">如果服务器无法使用指定版本的WebSocket协议进行通信，它将以一个错误（例如426 Upgrade）来响应，该错误的标头中包含一个 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 标头，其中包含以逗号分隔的受支持列表。协议版本。如果服务器确实支持请求的协议版本，则响应中不包含 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="8bfc654fb667ab7a47e06dc70b7def2a7620c972" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any character encoding from this request header, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406 Not Acceptable&lt;/code&gt;&lt;/a&gt; error code. But for a better user experience, this is rarely done and the &lt;code&gt;Accept-Charset&lt;/code&gt; header is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae753ebfa7e739c1ebf4391f5ee391f4e94ee3ce" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching character set, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and the more common way is to ignore the &lt;code&gt;Accept-Charset&lt;/code&gt; header in this case.</source>
          <target state="translated">如果服务器不能提供任何匹配的字符集，则理论上它可以发送回&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受）错误代码。但是，为了获得更好的用户体验，很少这样做，更常见的方法是在这种情况下忽略 &lt;code&gt;Accept-Charset&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="d8ca646db299a164f8eaec324da4187a3dc7c934" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching language, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and more common way is to ignore the &lt;code&gt;Accept-Language&lt;/code&gt; header in this case.</source>
          <target state="translated">如果服务器不能提供任何匹配的语言，则理论上它可以发送回&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受）错误代码。但是，为了获得更好的用户体验，很少这样做，更常见的方法是在这种情况下忽略 &lt;code&gt;Accept-Language&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="5785d405909bd735e16eff8d00e42ade5e8499d9" translate="yes" xml:space="preserve">
          <source>If the server decides to upgrade the connection, it sends back a &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101 Switching Protocols&lt;/code&gt;&lt;/a&gt; response status with an Upgrade header that specifies the protocol(s) being switched to. If it does not (or cannot) upgrade the connection, it ignores the &lt;code&gt;Upgrade&lt;/code&gt; header and sends back a regular response (for example, a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200 OK&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3214eaff9a427b272921bccd27c1fd179422db" translate="yes" xml:space="preserve">
          <source>If the server has a preferred choice, it should generate a &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">如果服务器有首选选项，则应生成一个&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="e05c84402fda441286aba0b966f3789dbf6191c3" translate="yes" xml:space="preserve">
          <source>If the server is unable to switch to HTTP/2 for any reason, it will reply with a standard HTTP/1 reply after handling the request as normal. So if the request was to fetch a web page which does in fact exist, you would get a standard &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; response with the web page following the remainder of the header. If the server is able to switch to HTTP/2, a &quot;&lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; response is sent, which will look like this:</source>
          <target state="translated">如果服务器由于某种原因无法切换到HTTP / 2，则在正常处理请求后，它将以标准HTTP / 1答复进行答复。因此，如果请求是获取实际上存在的网页，您将在标头的其余部分之后得到标准的 &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; 响应。如果服务器能够切换到HTTP / 2，则将发送&amp;ldquo; &lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; 响应，如下所示：</target>
        </trans-unit>
        <trans-unit id="b5c0cece345dde55b15ad1ad49b64cab5f6ed8d2" translate="yes" xml:space="preserve">
          <source>If the server is under your control, add the origin of the requesting site to the set of domains permitted access by adding it to the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header's value.</source>
          <target state="translated">如果服务器在您的控制之下，则通过将请求站点的源添加到 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头的值中，将其添加到允许访问的域集中。</target>
        </trans-unit>
        <trans-unit id="62963ebedd2ff72d3bb4b415143d2ac0443881d2" translate="yes" xml:space="preserve">
          <source>If the server sends a response with an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value that is an explicit origin (rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard), then the response should also include a &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header with the value &lt;code&gt;Origin&lt;/code&gt; &amp;mdash; to indicate to browsers that server responses can differ based on the value of the &lt;code&gt;Origin&lt;/code&gt; request header.</source>
          <target state="translated">如果服务器发送的响应的 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 值是一个显式的起源（而不是&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;通配符），则该响应还应包括一个带有值 &lt;code&gt;Origin&lt;/code&gt; 的&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;响应头，以向浏览器指示服务器响应可以根据 &lt;code&gt;Origin&lt;/code&gt; 请求标头的值而有所不同。</target>
        </trans-unit>
        <trans-unit id="40ae9d31a1c63c02ebcd60debd2f8b97d5dd7ac9" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin (that may dynamically change based on the requesting origin as part of a white-list) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035b5ed82a9b1755b686239ae88f8e1ef4f77e51" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">如果服务器指定的是单个来源而不是通配符&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;，则服务器还应在&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;响应标头中包含 &lt;code&gt;Origin&lt;/code&gt; ，以向客户端指示服务器响应将基于&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;请求标头的值而有所不同。</target>
        </trans-unit>
        <trans-unit id="bdd4b87fdc6a81c461da6befd7c1928bb2e1a6e5" translate="yes" xml:space="preserve">
          <source>If the server supports range requests, you can issue such a request by using the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header. It indicates the part(s) of a document that the server should return.</source>
          <target state="translated">如果服务器支持范围请求，则可以使用&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;标头发出这样的请求。它指示服务器应返回的文档部分。</target>
        </trans-unit>
        <trans-unit id="6199750daad48ff639691648a086a49c0a3fd0a7" translate="yes" xml:space="preserve">
          <source>If the server wishes a faster Web site or application response, it is possible for the server to force the opening of more connections. For example, Instead of having all resources on the same domain, say &lt;code&gt;www.example.com&lt;/code&gt;, it could split over several domains, &lt;code&gt;www1.example.com&lt;/code&gt;, &lt;code&gt;www2.example.com&lt;/code&gt;, &lt;code&gt;www3.example.com&lt;/code&gt;. Each of these domains resolve to the &lt;em&gt;same&lt;/em&gt; server, and the Web browser will open 6 connections to each (in our example, boosting the connections to 18). This technique is called &lt;em&gt;domain sharding&lt;/em&gt;.</source>
          <target state="translated">如果服务器希望更快的网站或应用程序响应，则服务器可能会强制打开更多连接。例如，不是将所有资源都放在同一个域上，比如说 &lt;code&gt;www.example.com&lt;/code&gt; ，它可以拆分为多个域，分别是 &lt;code&gt;www1.example.com&lt;/code&gt; ， &lt;code&gt;www2.example.com&lt;/code&gt; ， &lt;code&gt;www3.example.com&lt;/code&gt; 。这些域中的每一个都解析到&lt;em&gt;同一台&lt;/em&gt;服务器，并且Web浏览器将打开每个域的6个连接（在我们的示例中，将连接增加到18个）。这种技术称为&lt;em&gt;域分片&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="633be8e65041e6f678ba0a69d47e73981a12258e" translate="yes" xml:space="preserve">
          <source>If the service your code is accessing using a CORS request is under your control, make sure that it's configured to include your origin in its &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, and that only one such header is included in responses. The header itself accepts a comma-delineated list of origins, so adding a new origin is not difficult.</source>
          <target state="translated">如果您的代码正在使用CORS请求访问的服务在您的控制之下，请确保已将其配置为在其 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头中包含您的来源，并且响应中仅包含一个此类标头。标头本身接受逗号分隔的来源列表，因此添加新来源并不困难。</target>
        </trans-unit>
        <trans-unit id="d5f87d2c5913a57c8787a092105a04dbd9842ee7" translate="yes" xml:space="preserve">
          <source>If the string is null, no proxies should be used</source>
          <target state="translated">如果该字符串为空,则不应该使用代理。</target>
        </trans-unit>
        <trans-unit id="ee70fc1642248dcddd5b4e8e2c3aa5e1fa8b3482" translate="yes" xml:space="preserve">
          <source>If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server must send either a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) or a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;No Content&lt;/code&gt;) response to indicate successful completion of the request.</source>
          <target state="translated">如果目标资源确实具有当前表示形式，并且该表示形式已根据所附表示形式的状态成功进行了修改，则原始服务器必须发送&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）或&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;No Content&lt;/code&gt; ）响应以指示成功完成了请求。</target>
        </trans-unit>
        <trans-unit id="2e56a40e542286dd3f5f24ab9d9b357b4b9363fa" translate="yes" xml:space="preserve">
          <source>If the target resource does not have a current representation and the &lt;code&gt;PUT&lt;/code&gt; request successfully creates one, then the origin server must inform the user agent by sending a &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Created&lt;/code&gt;) response.</source>
          <target state="translated">如果目标资源没有当前表示，并且 &lt;code&gt;PUT&lt;/code&gt; 请求成功创建了一个表示，则源服务器必须通过发送&lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;（已 &lt;code&gt;Created&lt;/code&gt; ）响应来通知用户代理。</target>
        </trans-unit>
        <trans-unit id="a21b80ceb96b8a7d43dede98629becf487c2e6a3" translate="yes" xml:space="preserve">
          <source>If the upgrade to TLS succeeds, the server will respond with &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; as described in the previous section. If the upgrade fails, the HTTP/1.1 connection will fail.</source>
          <target state="translated">如果升级到TLS成功，则服务器将按照上一节中的说明响应 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 。如果升级失败，则HTTP / 1.1连接将失败。</target>
        </trans-unit>
        <trans-unit id="27db56e6fbfb8552acb661ab2ec13d5567a5150c" translate="yes" xml:space="preserve">
          <source>If there are hosts (such as the main Web server) that belong to the local domain but are outside the firewall and are only reachable through the proxy server, those exceptions can be handled using the &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; function:</source>
          <target state="translated">如果存在属于本地域但在防火墙之外并且只能通过代理服务器访问的主机（例如主Web服务器），则可以使用 &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; 函数处理这些异常：</target>
        </trans-unit>
        <trans-unit id="d24ef4f84cb249bfa31f9902d7ae003a91952701" translate="yes" xml:space="preserve">
          <source>If there are multiple semicolon-separated settings, the left-most setting will be used, until Firefox fails to establish the connection to the proxy. In that case, the next value will be used, etc.</source>
          <target state="translated">如果有多个分号分隔的设置,将使用最左边的设置,直到 Firefox 无法建立与代理的连接。在这种情况下,将使用下一个值,等等。</target>
        </trans-unit>
        <trans-unit id="d35d9172db4121106bcca6f82d93219ec641178d" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header</source>
          <target state="translated">如果指定了其他指令，则 &lt;code&gt;default-src&lt;/code&gt; 不会影响它们。以下标题</target>
        </trans-unit>
        <trans-unit id="f3a3fb9e88e16c02dae3ebc873862c5294ca1f14" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ef483d4374adee5323181a48fbe2db2ede05c8" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &quot;max-age&quot; or &quot;s-maxage&quot; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">如果响应中存在带有&amp;ldquo; max-age&amp;rdquo;或&amp;ldquo; s-maxage&amp;rdquo;指令的&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;标头，则 &lt;code&gt;Expires&lt;/code&gt; 标头将被忽略。</target>
        </trans-unit>
        <trans-unit id="3dc7a417b9985cacb686b59815968d89411858de" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &lt;code&gt;max-age&lt;/code&gt; or &lt;code&gt;s-maxage&lt;/code&gt; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872be7b4525857f39211419c11efc3edbf6a5a96" translate="yes" xml:space="preserve">
          <source>If there is only one range, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the whole response is set to the type of the document, and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; is provided.</source>
          <target state="translated">如果只有一个范围，则将整个响应的&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;设置为文档的类型，并提供&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b03947840333522631fcad82cab8f29beea0376" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will first look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive, then the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, then finally for the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, when governing worker execution.</source>
          <target state="translated">如果不存在此伪指令，则在管理工作程序执行时，用户代理将首先查找&lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt;伪指令，然后是&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt;伪指令，最后是&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;伪指令。</target>
        </trans-unit>
        <trans-unit id="84255b47da2e8395f8cff0945ef69aa9944b73b4" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive (which falls back to the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive).</source>
          <target state="translated">如果不存在此指令，则用户代理将查找&lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt;指令（回退到&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;指令）。</target>
        </trans-unit>
        <trans-unit id="905e23650e04dd97cd87c8f1b4781aae080cf34e" translate="yes" xml:space="preserve">
          <source>If this header is delivered with the response at https://example.com/clear-cookies, all cookies on the same domain https://example.com and any subdomains (like https://stage.example.com, etc), will be cleared out.</source>
          <target state="translated">如果这个头与响应https://example.com/clear-cookies,同一域名https://example.com 和任何子域名(如https://stage.example.com 等)上的所有 cookie 将被清除。</target>
        </trans-unit>
        <trans-unit id="84639588f8530b0b81f649bf1306849d6885af93" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, pin validation failures are reported to the given URL.</source>
          <target state="translated">如果指定了这个可选参数,引脚验证失败会被报告给给定的URL。</target>
        </trans-unit>
        <trans-unit id="cf9ff6207f9f440fe5c66b863c0c644f87236017" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, this rule applies to all of the site's subdomains as well.</source>
          <target state="translated">如果指定了这个可选参数,这个规则也适用于网站的所有子域。</target>
        </trans-unit>
        <trans-unit id="bbeccd91304096ae1ada0d103a494be1d6ecd504" translate="yes" xml:space="preserve">
          <source>If unspecified, the cookie becomes a &lt;strong&gt;session cookie&lt;/strong&gt;. A session finishes when the client shuts down, and session cookies will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6baa688a2748366ccc3dde62ab07310d89508f6a" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt;&lt;code&gt;EventSource.withCredentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt; (it's the default value).</source>
          <target state="translated">如果使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;服务器发送的事件&lt;/a&gt;，请确保&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt; &lt;code&gt;EventSource.withCredentials&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;false&lt;/code&gt; （这是默认值）。</target>
        </trans-unit>
        <trans-unit id="bb9e740256ba82627b9a0ee6fa47dc9b15df8b15" translate="yes" xml:space="preserve">
          <source>If using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;omit&quot;&lt;/code&gt;.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;，请确保&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;&quot;omit&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da0002cfebb5073d0fedbf25422e03f2884be38b" translate="yes" xml:space="preserve">
          <source>If you are not disclosing third-party cookies, consumer trust might get harmed if cookie use is discovered. A clear disclosure (such as in a privacy policy) tends to eliminate any negative effects of a cookie discovery. Some countries also have legislation about cookies. See for example Wikimedia Foundation's &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie statement&lt;/a&gt;.</source>
          <target state="translated">如果您不公开第三方cookie，则如果发现使用cookie，可能会损害消费者信任。明确的披露（例如在隐私政策中）倾向于消除cookie发现的任何负面影响。一些国家也有关于cookie的立法。例如，参见Wikimedia Foundation的&lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bfae6e8214b89d3d41028b5ed5468c1096365497" translate="yes" xml:space="preserve">
          <source>If you are running a robotic user agent (e.g. a crawler), the &lt;code&gt;From&lt;/code&gt; header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.</source>
          <target state="translated">如果您正在运行机械手用户代理（例如，爬网程序），则应发送 &lt;code&gt;From&lt;/code&gt; 头，以便在服务器上发生问题（例如，机械手发送过多，不需要或无效的请求）时与您联系。</target>
        </trans-unit>
        <trans-unit id="9a96db39060f5e3f83ad7fb3b0569b07c25f59e0" translate="yes" xml:space="preserve">
          <source>If you don't know whether this condition is temporary or permanent, a &lt;a href=&quot;404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; status code should be used instead.</source>
          <target state="translated">如果您不知道此情况是暂时的还是永久的，则应使用&lt;a href=&quot;404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt;状态代码代替。</target>
        </trans-unit>
        <trans-unit id="b65a6981b33c89d11ed83bceadd2cf2695bfb77d" translate="yes" xml:space="preserve">
          <source>If you don't want a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104043725295eb7cc9f3df2d7c830d6c1a7855ab" translate="yes" xml:space="preserve">
          <source>If you don't want to set up a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">如果您不想设置临时重定向，则可以使用额外的参数（要使用的HTTP状态代码或 &lt;code&gt;permanent&lt;/code&gt; 关键字）来设置其他重定向：</target>
        </trans-unit>
        <trans-unit id="bbff3207b07c23fc192059f1baabdc3df63a21a1" translate="yes" xml:space="preserve">
          <source>If you have access to the server you can change your implementation to echo back an origin in the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header. You cannot send back a list of origins, because browsers only accept a value that is either a single origin or null</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e7b5fc4c6d4409c9fc727d5416d3a635b2f290" translate="yes" xml:space="preserve">
          <source>If you need to create a WebSocket connection from scratch, you'll have to handle the handshaking process yourself. After creating the initial HTTP/1.1 session, you need to request the upgrade by adding to a standard request the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, as follows:</source>
          <target state="translated">如果需要从头开始创建WebSocket连接，则必须自己处理握手过程。创建初始HTTP / 1.1会话后，您需要通过向标准请求中添加&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头来请求升级，如下所示：</target>
        </trans-unit>
        <trans-unit id="95ee0117fd829b54190ed2ff0616a236aeb84cf5" translate="yes" xml:space="preserve">
          <source>If you receive a response that is not in this list, it is a non-standard response, possibly custom to the server's software.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8f0fd26b3474ef31bc91624748a9e6528cbeb2" translate="yes" xml:space="preserve">
          <source>If you set your site to require SRI for script and styles using this directive:</source>
          <target state="translated">如果您使用此指令将您的网站设置为需要SRI的脚本和样式。</target>
        </trans-unit>
        <trans-unit id="4990c5b1cf1cb465433d28094a3e92abdf6422d0" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;DENY&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;SAMEORIGIN&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0907d966acc8c427e8ea343762038d9ac612b1e1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;deny&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;sameorigin&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">如果指定 &lt;code&gt;deny&lt;/code&gt; ，则从其他站点加载时，不仅尝试在框架中加载页面失败，而且从同一站点加载时，尝试也会失败。另一方面，如果指定 &lt;code&gt;sameorigin&lt;/code&gt; ，则只要框架中包含该页面的站点与服务该页面的站点相同，仍可以在框架中使用该页面。</target>
        </trans-unit>
        <trans-unit id="76a40e879843d64bc7dc4946b5e5671cdab0ec07" translate="yes" xml:space="preserve">
          <source>If you still want to receive reporting, but also want to enforce a policy, use the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header with the &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">如果您仍然想接收报告，但又想强制执行策略，请在&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;标头中使用&lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="6fa8f50d92b7325e18f060f06fa0a5d25f9ef058" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header.</source>
          <target state="translated">如果希望客户端能够访问其他标头，则必须使用 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 标头列出它们。</target>
        </trans-unit>
        <trans-unit id="ea06dd402f2e9e7e165d67b2c899ce9957d05866" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header. &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; was not part of the original set safelisted response headers [&lt;a href=&quot;https://github.com/whatwg/fetch/pull/626&quot;&gt;ref&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f7d5936f9e8e985a3e0dca82679038018eac65" translate="yes" xml:space="preserve">
          <source>If you want to avoid using user agent detection, you have options!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4dd6049dead6031953d458d3c0344045b4e4cbe" translate="yes" xml:space="preserve">
          <source>If you want to specify a fallback policy in any case the desired policy hasn't got wide enough browser support, use a comma-separated list with the desired policy specified last:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21412475687382be49c1ab666d1bf865da6de6a3" translate="yes" xml:space="preserve">
          <source>If you want to try to avoid using user agent detection, there are options in some cases!</source>
          <target state="translated">如果你想尽量避免使用用户代理检测,在某些情况下是有选择的!</target>
        </trans-unit>
        <trans-unit id="0a038ab727911ca95eaa7cfa94eb4a630d6d412b" translate="yes" xml:space="preserve">
          <source>If your application, server, or proxy supports the standardized &lt;code&gt;Forwarded&lt;/code&gt; header, the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt; header can be replaced. Note that IPv6 address are quoted and enclosed in square brackets in &lt;code&gt;Forwarded&lt;/code&gt;.</source>
          <target state="translated">如果您的应用程序，服务器或代理支持标准的 &lt;code&gt;Forwarded&lt;/code&gt; 标头，则可以替换&lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt;标头。请注意，IPv6地址在 &lt;code&gt;Forwarded&lt;/code&gt; 中用引号引起来并括在方括号中。</target>
        </trans-unit>
        <trans-unit id="90a08b947a2957fe434f390c98a9142e831d9a0f" translate="yes" xml:space="preserve">
          <source>If your site authenticates users, it should regenerate and resend session cookies, even ones that already exist, whenever the user authenticates. This technique helps prevent &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;session fixation attacks&lt;/a&gt;, where a third party can reuse a user's session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d1c453e83057e2df00a9ddb4d5028bf92c87b6" translate="yes" xml:space="preserve">
          <source>If, instead, you need to adjust the server's behavior, you'll need to change the value of &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to grant access to the origin from which the client is loaded.</source>
          <target state="translated">相反，如果您需要调整服务器的行为，则需要更改 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 的值以授予对客户端加载源的访问权限。</target>
        </trans-unit>
        <trans-unit id="c4eca4702bbd3334f2af696c9113056ad66a8d93" translate="yes" xml:space="preserve">
          <source>If-Match</source>
          <target state="translated">If-Match</target>
        </trans-unit>
        <trans-unit id="347825cb2f6b585363c705da713b0a01a89c0771" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 2616)</source>
          <target state="translated">If-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="258eadb23d36147c17ca65c583464f10d8beefd5" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 7232)</source>
          <target state="translated">If-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="de1338853da05e0b2ef334c6d2a1bd4efd32b464" translate="yes" xml:space="preserve">
          <source>If-Modified-Since</source>
          <target state="translated">If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="434516b07ea046bbb5c4ac151f7538b608531da2" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 2616)</source>
          <target state="translated">If-Modified-Since (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="33cf8486927b13aa3ae6d7b4b5c2ba9856f2354e" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 7232)</source>
          <target state="translated">If-Modified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2c743ca76b5ff26374732b33a172bc6386b3aab3" translate="yes" xml:space="preserve">
          <source>If-None-Match</source>
          <target state="translated">If-None-Match</target>
        </trans-unit>
        <trans-unit id="afb97058113ea8024c2b1e30396497276d9e7529" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 2616)</source>
          <target state="translated">If-None-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9d29af1e2a7a4f8c799fff50073e73e2ee90bbe7" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 7232)</source>
          <target state="translated">If-None-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="3e610a822745a7648a28ddc376bb31e9d961b787" translate="yes" xml:space="preserve">
          <source>If-Range</source>
          <target state="translated">If-Range</target>
        </trans-unit>
        <trans-unit id="0db4229b3fe70c3cd52654ba3a313677c557a2f3" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 2616)</source>
          <target state="translated">If-Range (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="63c9a90407687da95ffa628c724bc3b45d1f6b45" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7232)</source>
          <target state="translated">If-Range (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="d239314fe40c1036bb99b7c1a04ab1559ed5e25b" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7233)</source>
          <target state="translated">If-Range (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="f07ea20e44175d8597a0629b88839dc18660c130" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since</source>
          <target state="translated">If-Unmodified-Since</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
