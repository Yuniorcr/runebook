<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="b673c9e63e004b0100dfc535e9d853efdab058cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Minimum rowid&lt;/b&gt;. The smallest rowid value that the component table may contain.</source>
          <target state="translated">&lt;b&gt;最小rowid&lt;/b&gt;。组件表可能包含的最小rowid值。</target>
        </trans-unit>
        <trans-unit id="8854a71cda0085046b9147447cbd41e78a4e1177" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;More memory is required.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;需要更多的内存。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="adf6ecb6b32f577e6034acbe2733682fb3971d41" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Multi-thread&lt;/b&gt;. In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used simultaneously in two or more threads.</source>
          <target state="translated">&lt;b&gt;多线程&lt;/b&gt;。在这种模式下，只要两个或多个线程中没有同时使用单个数据库连接，SQLite可以安全地被多个线程使用。</target>
        </trans-unit>
        <trans-unit id="21e561077759c3b37ee660c8471d465edf7d23f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Multiple Programming Languages.&lt;/b&gt; Though SQLite is itself written in ANSI-C, interfaces exist for just about every other programming language you can think of: C++, C#, Objective-C, Java, Tcl, Perl, Python, Ruby, Erlang, JavaScript, and so forth. So programmers can develop in whatever language they are most comfortable with and which best matches the needs of the project.</source>
          <target state="translated">&lt;b&gt;多种编程语言。&lt;/b&gt;尽管SQLite本身是用ANSI-C编写的，但几乎所有您可以想到的其他编程语言都存在接口：C ++，C＃，Objective-C，Java，Tcl，Perl，Python，Ruby，Erlang，JavaScript等。因此，程序员可以使用他们最熟悉的语言以及最符合项目需求的语言进行开发。</target>
        </trans-unit>
        <trans-unit id="bbbccf371c0e234307bee4d30da38a5ab800fce8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NEAR queries&lt;/b&gt;. A NEAR query is a query that returns documents that contain a two or more nominated terms or phrases within a specified proximity of each other (by default with 10 or less intervening terms). A NEAR query is specified by putting the keyword &quot;NEAR&quot; between two phrase, token or token prefix queries. To specify a proximity other than the default, an operator of the form &quot;NEAR/</source>
          <target state="translated">&lt;b&gt;NEAR查询&lt;/b&gt;。NEAR查询是一种查询，该查询返回的文档包含彼此指定的接近范围内的两个或多个指定术语或短语（默认情况下，包含10个或更少的中间术语）。通过在两个短语，标记或标记前缀查询之间放置关键字&amp;ldquo; NEAR&amp;rdquo;来指定NEAR查询。要指定默认值以外的其他接近度，请使用&amp;ldquo; NEAR /</target>
        </trans-unit>
        <trans-unit id="dc6e2c1220d03e58ac2509cb68f476535ca76ad4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NEVER(X)&lt;/b&gt; &amp;rarr; The NEVER(X) function indicates that condition X is never true. This is the negative analog of the ALWAYS(X) function.</source>
          <target state="translated">&lt;b&gt;NEVER（X）&lt;/b&gt; &amp;rarr;NEVER（X）函数表示条件X从不成立。这是ALWAYS（X）函数的负模拟。</target>
        </trans-unit>
        <trans-unit id="487c11243d3fac95cee85c11a75c7074cf502311" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NO ACTION&lt;/b&gt;: Configuring &quot;NO ACTION&quot; means just that: when a parent key is modified or deleted from the database, no special action is taken.</source>
          <target state="translated">&lt;b&gt;NO ACTION&lt;/b&gt;：配置&amp;ldquo; NO ACTION&amp;rdquo;仅意味着：当修改或删除数据库中的父键时，不会执行任何特殊操作。</target>
        </trans-unit>
        <trans-unit id="8def40f09191841182ee8419c5a802169faf1176" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOCASE&lt;/b&gt; - Similar to binary, except that it uses &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; for the comparison. Hence the 26 upper case characters of ASCII are folded to their lower case equivalents before the comparison is performed. Note that only ASCII characters are case folded. SQLite does not attempt to do full UTF case folding due to the size of the tables required. Also note that any U+0000 characters in the string are considered string terminators for comparison purposes.</source>
          <target state="translated">&lt;b&gt;NOCASE-&lt;/b&gt;与二进制文件类似，不同之处在于它使用&lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;进行比较。因此，在执行比较之前，将ASCII的26个大写字母折叠为它们的小写字母。请注意，只有ASCII字符是大小写折叠的。由于所需表的大小，SQLite不会尝试进行完整的UTF大小写折叠。另请注意，出于比较目的，字符串中的任何U + 0000字符均被视为字符串终止符。</target>
        </trans-unit>
        <trans-unit id="73bf333ea09aa218cf78c2dd7bfb9dec4bd07bda" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOCASE&lt;/b&gt; - The same as binary, except the 26 upper case characters of ASCII are folded to their lower case equivalents before the comparison is performed. Note that only ASCII characters are case folded. SQLite does not attempt to do full UTF case folding due to the size of the tables required.</source>
          <target state="translated">&lt;b&gt;NOCASE-&lt;/b&gt;与二进制相同，除了在比较之前，将ASCII的26个大写字符折叠为它们的小写字母。请注意，只有ASCII字符是大小写折叠的。由于所需表的大小，SQLite不会尝试进行完整的UTF大小写折叠。</target>
        </trans-unit>
        <trans-unit id="73917940be12b8220f84e5b4e122d810efa37b48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NORMAL&lt;/b&gt; (1)</source>
          <target state="translated">&lt;b&gt;普通&lt;/b&gt;（1）</target>
        </trans-unit>
        <trans-unit id="3166160b441c48e36b2b91d3bbf403ed10e55a52" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOT NULL is enforced on every column of the PRIMARY KEY in a WITHOUT ROWID table.&lt;/b&gt; This is in accordance with the SQL standard. Each column of a PRIMARY KEY is supposed to be individually NOT NULL. However, NOT NULL was not enforced on PRIMARY KEY columns by early versions of SQLite due to a bug. By the time that this bug was discovered, so many SQLite databases were already in circulation that the decision was made not to fix this bug for fear of breaking compatibility. So, ordinary rowid tables in SQLite violate the SQL standard and allow NULL values in PRIMARY KEY fields. But WITHOUT ROWID tables do follow the standard and will throw an error on any attempt to insert a NULL into a PRIMARY KEY column.</source>
          <target state="translated">&lt;b&gt;NOT NULL在WITHOUT ROWID表中的PRIMARY KEY的每一列上强制执行。&lt;/b&gt;这符合SQL标准。应该将PRIMARY KEY的每一列分别设置为NOT NULL。但是，由于错误，早期版本的SQLite并未在PRIMARY KEY列上强制执行NOT NULL。到发现此错误时，已经有许多SQLite数据库在流通，以免由于担心破坏兼容性而决定不修复此错误。因此，SQLite中的普通rowid表违反了SQL标准，并在PRIMARY KEY字段中允许使用NULL值。但是WITHOUT ROWID表确实遵循标准，并且在将NULL插入PRIMARY KEY列的任何尝试中都会引发错误。</target>
        </trans-unit>
        <trans-unit id="bc95fb99938c21923a9788d0583a16ed520163ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOTE:&lt;/b&gt;&lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL avoids calls to fsync() during transaction commit and only invokes fsync() during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. The use of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; largely obviates the need for this asynchronous I/O module. Hence, this module is no longer supported. The source code continues to exist in the SQLite source tree, but it is not a part of any standard build and is no longer maintained. This documentation is retained for historical reference.</source>
          <target state="translated">&lt;b&gt;注：&lt;/b&gt;&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;与&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为正常交易避免了期间的fsync（）调用commit和唯一所调用的fsync（）在一个&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作。使用&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;在很大程度上消除了对该异步I / O模块的需求。因此，不再支持该模块。源代码继续存在于SQLite源树中，但是它不是任何标准构建的一部分，并且不再维护。本文档保留以供历史参考。</target>
        </trans-unit>
        <trans-unit id="fca578107aaae50ff26d325fed0b62080c6889c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NULL&lt;/b&gt;. The value is a NULL value.</source>
          <target state="translated">&lt;b&gt;NULL&lt;/b&gt;。该值为NULL值。</target>
        </trans-unit>
        <trans-unit id="e60921d575a23c23be358d8fdf5a97676ed11dc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Neo-Serverless:&lt;/b&gt; The database engine runs in a separate namespace from the application, probably on a separate machine, but the database is provided as a turn-key service by the hosting provider, requires no management or administration by the application owners, and is so easy to use that the developers can think of the database as being serverless even if it really does use a server under the covers.</source>
          <target state="translated">&lt;b&gt;Neo-Serverless：&lt;/b&gt;数据库引擎在与应用程序不同的名称空间中运行，可能在另一台计算机上，但是数据库由托管服务提供商作为交钥匙服务提供，不需要应用程序所有者的管理或管理，并且如此易于使用，以至于开发人员即使确实在后台使用服务器，也可以认为该数据库是无服务器的。</target>
        </trans-unit>
        <trans-unit id="909ffbf0ae97af25590d0beca9f09f95e1eb7f6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;New Features And Enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;新功能和增强功能：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4094fb73a2434b6f612129976d4358e6c63a97c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;New Features:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;新功能：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="87ec9bcc3d59100d87299b8acd1d29514ed4eae1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;New feature:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;新功能：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="52148d849517ab1764396005cd63ec9ff28d2ca7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;No memory leaks.&lt;/b&gt; The application is responsible for destroying any objects it allocates. (For example, the application must use &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; on every &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on every &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.) But as long as the application cooperates, SQLite will never leak memory. This is true even in the face of memory allocation failures or other system errors.</source>
          <target state="translated">&lt;b&gt;没有内存泄漏。&lt;/b&gt;该应用程序负责销毁它分配的所有对象。 （例如，应用程序必须使用&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;上的每一个&lt;a href=&quot;c3ref/stmt&quot;&gt;事先准备好的声明&lt;/a&gt;，并&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;每对&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;）。但只要应用合作，SQLite的决不会泄漏内存。即使面对内存分配失败或其他系统错误，也是如此。</target>
        </trans-unit>
        <trans-unit id="b2e8146a12b6e95ae9f367f65ae55cd056327016" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;No support for switching constraints between deferred and immediate mode.&lt;/b&gt; Many systems allow the user to toggle individual foreign key constraints between &lt;a href=&quot;#fk_deferred&quot;&gt;deferred&lt;/a&gt; and immediate mode at runtime (for example using the Oracle &quot;SET CONSTRAINT&quot; command). SQLite does not support this. In SQLite, a foreign key constraint is permanently marked as deferred or immediate when it is created.</source>
          <target state="translated">&lt;b&gt;不支持在延迟模式和立即模式之间切换约束。&lt;/b&gt;许多系统允许用户在运行时在&lt;a href=&quot;#fk_deferred&quot;&gt;延迟&lt;/a&gt;模式和立即模式之间切换各个外键约束（例如，使用Oracle&amp;ldquo; SET CONSTRAINT&amp;rdquo;命令）。 SQLite不支持此功能。在SQLite中，外键约束在创建时会永久标记为&amp;ldquo;延迟&amp;rdquo;或&amp;ldquo;立即&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="be87423d536436e28041d8e31466ad6f3ca43fc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;No support for the MATCH clause.&lt;/b&gt; According to SQL92, a MATCH clause may be attached to a composite foreign key definition to modify the way NULL values that occur in child keys are handled. If &quot;MATCH SIMPLE&quot; is specified, then a child key is not required to correspond to any row of the parent table if one or more of the child key values are NULL. If &quot;MATCH FULL&quot; is specified, then if any of the child key values is NULL, no corresponding row in the parent table is required, but all child key values must be NULL. Finally, if the foreign key constraint is declared as &quot;MATCH PARTIAL&quot; and one of the child key values is NULL, there must exist at least one row in the parent table for which the non-NULL child key values match the parent key values.</source>
          <target state="translated">&lt;b&gt;不支持MATCH子句。&lt;/b&gt;根据SQL92，可以将MATCH子句附加到复合外键定义，以修改处理子键中出现的NULL值的方式。如果指定了&amp;ldquo; MATCH SIMPLE&amp;rdquo;，则如果一个或多个子关键字值为NULL，则不需要子关键字与父表的任何行相对应。如果指定了&amp;ldquo; MATCH FULL&amp;rdquo;，则如果任何子键值是NULL，则父表中不需要相应的行，但是所有子键值都必须为NULL。最后，如果将外键约束声明为&amp;ldquo; MATCH PARTIAL&amp;rdquo;，并且子键值之一为NULL，则父表中必须至少存在一行，其非NULL子键值与父键值匹配。</target>
        </trans-unit>
        <trans-unit id="ff3423278c8d679f0e463fab7ceefdb8e87b547d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Nota Bene:&lt;/b&gt; We are not using terms &quot;alpha&quot; or &quot;beta&quot; on this release because the code is stable and because if we use those terms, nobody will upgrade. However, we still reserve the right to make incompatible changes to the new VFS interface in future releases.</source>
          <target state="translated">&lt;b&gt;Nota Bene：&lt;/b&gt;在此版本中，我们不使用术语&amp;ldquo; alpha&amp;rdquo;或&amp;ldquo; beta&amp;rdquo;，因为代码是稳定的，并且如果使用这些术语，则不会有人升级。但是，我们仍然保留在以后的版本中对新的VFS接口进行不兼容更改的权利。</target>
        </trans-unit>
        <trans-unit id="fc4af7cf88e9968ffacaf7a5e73935d76ee917e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note to Windows Runtime users:&lt;/b&gt; The temporary directory must be set prior to calling &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2&lt;/a&gt;. Otherwise, various features that require the use of temporary files may fail. Here is an example of how to do this using C++ with the Windows Runtime:</source>
          <target state="translated">&lt;b&gt;Windows运行时用户注意：&lt;/b&gt;必须在调用&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open&lt;/a&gt;或&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2&lt;/a&gt;之前设置临时目录。否则，要求使用临时文件的各种功能可能会失败。这是如何在Windows运行时中使用C ++进行此操作的示例：</target>
        </trans-unit>
        <trans-unit id="c0ded749e5fd3733acdedad822b087151eadbb0c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note to Windows Runtime users:&lt;/b&gt; The temporary directory must be set prior to calling &lt;a href=&quot;open&quot;&gt;sqlite3_open&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2&lt;/a&gt;. Otherwise, various features that require the use of temporary files may fail. Here is an example of how to do this using C++ with the Windows Runtime:</source>
          <target state="translated">&lt;b&gt;Windows运行时用户注意：&lt;/b&gt;必须在调用&lt;a href=&quot;open&quot;&gt;sqlite3_open&lt;/a&gt;或&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2&lt;/a&gt;之前设置临时目录。否则，要求使用临时文件的各种功能可能会失败。这是如何在Windows运行时中使用C ++进行此操作的示例：</target>
        </trans-unit>
        <trans-unit id="444b5de2baa7866b26c5c35eb4066557d970f9f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note to Windows Runtime users:&lt;/b&gt; The temporary directory must be set prior to calling sqlite3_open() or sqlite3_open_v2(). Otherwise, various features that require the use of temporary files may fail.</source>
          <target state="translated">&lt;b&gt;Windows运行时用户注意：&lt;/b&gt;必须在调用sqlite3_open（）或sqlite3_open_v2（）之前设置临时目录。否则，要求使用临时文件的各种功能可能会失败。</target>
        </trans-unit>
        <trans-unit id="748ba4196717e6b0faea9113baafb8df3689d540" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note to Windows users:&lt;/b&gt; The encoding used for the filename argument of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whatever codepage is currently defined. Filenames containing international characters must be converted to UTF-8 prior to passing them into sqlite3_open() or sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;Windows用户注意：&lt;/b&gt;用于sqlite3_open（）和sqlite3_open_v2（）的filename参数的编码必须为UTF-8，而不是当前定义的任何代码页。在将包含国际字符的文件名传递到sqlite3_open（）或sqlite3_open_v2（）之前，必须先将其转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="769f55a4b93dc322f7b3d455d8397df48f2f2d0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note: This command is experimental. It may be removed or the interface modified in incompatible ways at some point in the future. &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;注意：此命令是实验性的。将来某个时候可能会以不兼容的方式将其删除或修改接口。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b47027741958234097e78403aae1058c44d5b08b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note:&lt;/b&gt; This document was written in 2004 as a guide to helping programmers move from using SQLite version 2 to SQLite version 3. The information in this document is still essentially correct, however there have been many changes and enhancements over the years. We recommend that the following documents be used instead:</source>
          <target state="translated">&lt;b&gt;注意：&lt;/b&gt;本文档于2004年编写，旨在帮助程序员从使用SQLite版本2到SQLite版本3的指南。该文档中的信息本质上仍然正确，但是这些年来已经进行了许多更改和增强。我们建议改为使用以下文档：</target>
        </trans-unit>
        <trans-unit id="24750d4eb9662e4a4957cb5bb183a86e47a49973" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;OFF&lt;/b&gt; (0)</source>
          <target state="translated">&lt;b&gt;关&lt;/b&gt;（0）</target>
        </trans-unit>
        <trans-unit id="13a53904d88ef25254e29ff8b9c1d8fa9cd6298b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Old school&lt;/b&gt; &amp;rarr; Nobody is completely immune to trends and fads, but the SQLite developers work hard to avoid being sucked into the latest programming fashion. Our aim is to produce timeless code that will be readable, understandable, and maintainable by programmers who have not yet been born.</source>
          <target state="translated">&lt;b&gt;老派&lt;/b&gt; &amp;rarr;没有人能完全不受潮流和潮流的影响，但是SQLite开发人员努力工作，以免被最新的编程方式所吸引。我们的目标是产生永不过时的代码，使尚未出生的程序员可以读取，理解和维护它们。</target>
        </trans-unit>
        <trans-unit id="cd300fad70a8d19900bdcefb0940dc55c37c7edd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Open access.&lt;/b&gt; Pluggable SQLite extensions or even the application itself can access to the same underlying memory allocation routines used by SQLite through the &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;b&gt;开放存取。&lt;/b&gt;可插入的SQLite扩展甚至应用程序本身都可以通过&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;，&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;接口访问SQLite使用的相同基础内存分配例程。</target>
        </trans-unit>
        <trans-unit id="c71ee46b045a02f63debd958100626f5bab2581a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Optimization note:&lt;/b&gt; In the discussion above, statements like &quot;insert the row into the recursive table&quot; should be understood conceptually, not literally. It sounds as if SQLite is accumulating a huge table containing one million rows, then going back and scanning that table from top to bottom to generate the result. What really happens is that the query optimizer sees that values in the &quot;cnt&quot; recursive table are only used once. So as each row is added to the recursive table, that row is immediately returned as a result of the main SELECT statement and then discarded. SQLite does &lt;em&gt;not&lt;/em&gt; accumulate a temporary table containing a million rows. Very little memory is needed to run the above example. However, if the example had used UNION instead of UNION ALL, then SQLite would have had to keep around all previously generated content in order to check for duplicates. For this reason, programmers should strive to use UNION ALL instead of UNION when feasible.</source>
          <target state="translated">&lt;b&gt;优化说明：&lt;/b&gt;在上面的讨论中，应该从概念上而不是从字面上理解&amp;ldquo;将行插入到递归表中&amp;rdquo;之类的语句。听起来好像SQLite正在累积一个包含一百万行的巨大表，然后返回并从上到下扫描该表以生成结果。真正发生的是查询优化器发现&amp;ldquo; cnt&amp;rdquo;递归表中的值仅使用了一次。因此，当将每一行添加到递归表时，该行将作为主SELECT语句的结果立即返回，然后被丢弃。 SQLite的确实&lt;em&gt;不&lt;/em&gt;累积一个包含一百万行的临时表。运行上面的示例所需的内存很少。但是，如果该示例使用UNION而不是UNION ALL，则SQLite必须保留所有先前生成的内容，以检查重复项。因此，程序员应在可行的情况下努力使用UNION ALL代替UNION。</target>
        </trans-unit>
        <trans-unit id="651a8131253a7773af15b8271556354505a88d30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Other changes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;其他变化：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="836c9c79cbdb56ad11a3f7b8eb289c6fcd3b3e97" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Other miscellaneous bug fixes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;其他杂项错误修复：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b78f4234d48fb6b6bfa15c9a34247d7bdf65943f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Otherwise &amp;rarr; choose SQLite!&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;否则&amp;rarr;选择SQLite！&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7a4e6ea5132ac1b592b0a12cf67526ca006118c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1d211503a0488f6cdaff91b8def4b32d03cc924f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA analysis_limit; &lt;br/&gt;PRAGMA analysis_limit = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA analysis_limit; &lt;br/&gt;PRAGMA analysis_limit = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="83b30075940fcb452bed2180f81dc10eba7f6711" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA automatic_index; &lt;br/&gt;PRAGMA automatic_index = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA automatic_index; &lt;br/&gt;PRAGMA automatic_index =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="34bc85d6a4d45772aad879e55a7ac5e80222398c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA busy_timeout; &lt;br/&gt;PRAGMA busy_timeout = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA busy_timeout; &lt;br/&gt;PRAGMA busy_timeout =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ba56744c8180a6fc97f0a1a8617742a0585aaec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA cache_spill; &lt;br/&gt;PRAGMA cache_spill=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA cache_spill; &lt;br/&gt;PRAGMA cache_spill =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="046b46c5f39805112cd910d3ff11e39ab8424cce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA case_sensitive_like = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA case_sensitive_like = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="565bea357204f845f61325d13e5aa1cfcd799e07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA cell_size_check &lt;br/&gt;PRAGMA cell_size_check = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA cell_size_check &lt;br/&gt;PRAGMA cell_size_check =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9615bff993393e92f6f3ae3d404400a4b65a5687" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA checkpoint_fullfsync &lt;br/&gt;PRAGMA checkpoint_fullfsync = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA checkpoint_fullfsync &lt;br/&gt;PRAGMA checkpoint_fullfsync =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2e46aa40c6380c795a8260154cbaec7c9506c4d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA collation_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA collat​​ion_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6474234e180c118606d9cf5796987f9b1142da9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA compile_options;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA compile_options;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a23692d2499f7b3484cb758082a7deaf51e9cf7f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA count_changes; &lt;br/&gt;PRAGMA count_changes = &lt;/b&gt;boolean&lt;b&gt;;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA count_changes; &lt;br/&gt;PRAGMA count_changes =&lt;/b&gt;布尔值&lt;b&gt;；&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3657d382c17092acaa136470f8043718e1e91a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA data_store_directory; &lt;br/&gt;PRAGMA data_store_directory = '&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA data_store_directory; &lt;br/&gt;PRAGMA data_store_directory ='&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="450721fa2a666abef3200f3d173451ff5c7661af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA database_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA database_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="794ea8d4d27624136baf8c5ea0c9d9f3ac26ba94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA defer_foreign_keys &lt;br/&gt;PRAGMA defer_foreign_keys = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA defer_foreign_keys &lt;br/&gt;PRAGMA defer_foreign_keys =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="668dd102f6d9b948c3f5c70f4e29347d03f041b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA empty_result_callbacks; &lt;br/&gt;PRAGMA empty_result_callbacks = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA empty_result_callbacks; &lt;br/&gt;PRAGMA empty_result_callbacks =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e34407929970c720bcf37acb067c6d902cae8b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA encoding; &lt;br/&gt;PRAGMA encoding = 'UTF-8'; &lt;br/&gt;PRAGMA encoding = 'UTF-16'; &lt;br/&gt;PRAGMA encoding = 'UTF-16le'; &lt;br/&gt;PRAGMA encoding = 'UTF-16be';&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA编码；&lt;br/&gt;PRAGMA编码='UTF-8'; &lt;br/&gt;PRAGMA编码='UTF-16'; &lt;br/&gt;PRAGMA编码='UTF-16le'; &lt;br/&gt;PRAGMA编码='UTF-16be';&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68d7b463e4c3d04462621119087178aef2ea372a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA foreign_key_list(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA foreign_key_list（&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6f1a523f2bdc8d90e07205dea18552c1854287a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA foreign_keys; &lt;br/&gt;PRAGMA foreign_keys = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA外键；&lt;br/&gt;PRAGMA外键=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="069e90959dff0b0144700f439333db94c4234af0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA full_column_names; &lt;br/&gt;PRAGMA full_column_names = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA full_column_names; &lt;br/&gt;PRAGMA full_column_names =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c191dc47ff1ccf9e34d591b33df93a26965f6dce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA fullfsync &lt;br/&gt;PRAGMA fullfsync = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA fullfsync &lt;br/&gt;PRAGMA fullfsync =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ec6500e351a87577bfec53d117f2d532325eafc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA function_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA function_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ad0d71ecf039ad544f30455bcdbd3667f6f6bde" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA hard_heap_limit&lt;br/&gt; PRAGMA hard_heap_limit=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA hard_heap_limit&lt;br/&gt; PRAGMA hard_heap_limit=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d207d1a089498b74f456f544036449e4c0d7ca81" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA ignore_check_constraints = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA ignore_check_constraints = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c744529af3729b3db46137681b8a4149686477f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA legacy_alter_table; &lt;br/&gt;PRAGMA legacy_alter_table = &lt;i&gt;boolean&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA legacy_alter_table; &lt;br/&gt;PRAGMA legacy_alter_table = &lt;i&gt;布尔值&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="48e6cf340be98da512dd51fd9b58fa0495affa32" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA legacy_file_format; &lt;br/&gt;PRAGMA legacy_file_format = &lt;i&gt;boolean&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA legacy_file_format; &lt;br/&gt;PRAGMA legacy_file_format = &lt;i&gt;布尔值&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="741f68493d5092503375e88d0fed818d2414c935" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA legacy_file_format;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA legacy_file_format;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0f7d30a633b0f798cf089bd9af23c6222ddd0dab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA module_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA module_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b04f91057153bfe385a2ca682291b546a585a7cf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA optimize; &lt;br/&gt;PRAGMA optimize(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA优化；&lt;br/&gt;PRAGMA优化（&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68a98ab10e998a482c646076b2f2e29e38965f44" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA parser_trace = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA parser_trace = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5bc9c8c6ac16923ab9c3f0f704b3e9b2f909b480" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA pragma_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA pragma_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="36a70f23f79ebdba5909e7d79bedd59f47a5f025" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA query_only; &lt;br/&gt;PRAGMA query_only = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA query_only; &lt;br/&gt;PRAGMA query_only =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="077bcb499c2f1bcbd541b7d149710ac3780529ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA read_uncommitted; &lt;br/&gt;PRAGMA read_uncommitted = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA read_uncommitted; &lt;br/&gt;PRAGMA read_uncommitted =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc2ac8724db764e8cbbbf84aa7d8c0e1d82780a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA recursive_triggers; &lt;br/&gt;PRAGMA recursive_triggers = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA recursive_triggers; &lt;br/&gt;PRAGMA recursive_triggers =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f68cbf752672c0b1b34391729c4c9eced4aa618d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA reverse_unordered_selects; &lt;br/&gt;PRAGMA reverse_unordered_selects = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA reverse_unordered_selects; &lt;br/&gt;PRAGMA reverse_unordered_selects =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cf06b921c7f02a57d88e677cc690f4c67d4edfec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA short_column_names; &lt;br/&gt;PRAGMA short_column_names = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA short_column_names; &lt;br/&gt;PRAGMA short_column_names =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="825ba246cc1b1a97c03ffc7bff5ff770578b70ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA shrink_memory&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMArink_memory&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f581b3dd4770c7e81c9a4d70f0c732a0cb847aa5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA soft_heap_limit&lt;br/&gt; PRAGMA soft_heap_limit=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA soft_heap_limit &lt;br/&gt;PRAGMA soft_heap_limit =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="993cb0e48d44665f1a1fdde50480e34a4564b7e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA stats;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA统计；&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f3e58baf9ac87756f2ff64608cb4491760e167a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA temp_store; &lt;br/&gt;PRAGMA temp_store = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA temp_store; &lt;br/&gt;PRAGMA temp_store =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="70135cb7f05b7e917151aa514833c9748b5db620" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA temp_store_directory; &lt;br/&gt;PRAGMA temp_store_directory = '&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA temp_store_directory; &lt;br/&gt;PRAGMA temp_store_directory ='&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05825927b748ed604749ba6c5a353f57d9c33904" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA threads; &lt;br/&gt;PRAGMA threads = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA线程；&lt;br/&gt;PRAGMA线程=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a40aa0b9db146c81b934789b250b46fc78bac80f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA trusted_schema; &lt;br/&gt;PRAGMA trusted_schema = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA trust_schema; &lt;br/&gt;PRAGMA Trusted_schema =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d97a389f3a5dd4b156c1ff3a61d3ce94dae20880" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA vdbe_addoptrace = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA vdbe_addoptrace = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8957c1b89b58509b9ad2ededda1ea95812f93cb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA vdbe_debug = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA vdbe_debug = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf418203dd77144a23b6f4fd5e0373826f599d82" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA vdbe_listing = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA vdbe_listing = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2996e771be9c4129bca39778d9d000122105ece7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA vdbe_trace = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA vdbe_trace = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3372b23ddf217d83224ec50e4fe828229dc15429" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA wal_autocheckpoint;&lt;br/&gt; PRAGMA wal_autocheckpoint=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA wal_autocheckpoint; &lt;br/&gt;PRAGMA wal_autocheckpoint =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a2fdecfa5636d000c5d0c05b22630a29e3e0aef7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA writable_schema = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA writable_schema = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e3174396d4cc0cecbb14882932592933a55f4ab7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Performance Enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;性能增强：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d5bcadce029aa3c9c7af1fde80e52286840c575b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Performance enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;性能增强：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e6d8d853aa960d2241e2de78be03a3ec37df9aea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Performance.&lt;/b&gt; In many cases, an SQLite application file format will be &lt;a href=&quot;fasterthanfs&quot;&gt;faster than a pile-of-files format&lt;/a&gt; or a custom format. In addition to being faster for raw read and writes, SQLite can often dramatically improves start-up times because instead of having to read and parse the entire document into memory, the application can do queries to extract only the information needed for the initial screen. As the application progresses, it only needs to load as much material as is needed to draw the next screen, and can discard information from prior screens that is no longer in use. This helps keep the memory footprint of the application under control.</source>
          <target state="translated">&lt;b&gt;性能。&lt;/b&gt;在许多情况下，SQLite应用程序文件格式将比文件&lt;a href=&quot;fasterthanfs&quot;&gt;堆格式&lt;/a&gt;或自定义格式更快。除了可以更快地进行原始读写外，SQLite还可以大大缩短启动时间，因为该应用程序不必执行查询操作即可提取仅用于初始屏幕的信息，而不必将整个文档读取和解析到内存中。随着应用程序的进行，它仅需要加载绘制下一个屏幕所需的材料，并且可以丢弃不再使用的先前屏幕中的信息。这有助于控制应用程序的内存占用量。</target>
        </trans-unit>
        <trans-unit id="a13e3777e4274771f6f8ab0c2f57839a313e28e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Performance:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Performance:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46a6192a108d9e7b8cb029df33550613a9110a7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Phrase queries&lt;/b&gt;. A phrase query is a query that retrieves all documents that contain a nominated set of terms or term prefixes in a specified order with no intervening tokens. Phrase queries are specified by enclosing a space separated sequence of terms or term prefixes in double quotes (&quot;). For example:</source>
          <target state="translated">&lt;b&gt;词组查询&lt;/b&gt;。词组查询是一种查询，该查询检索所有包含指定术语集或术语前缀的指定顺序的文档集，而没有中间标记。短语查询是通过用双引号（&amp;ldquo;）括起来的用空格分隔的术语序列或术语前缀来指定的。例如：</target>
        </trans-unit>
        <trans-unit id="22d3e7c367a141aec26eeffb7c6081a38bc54795" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Pile-of-Files Formats.&lt;/b&gt; Sometimes the application state is stored as a hierarchy of files. Git is a prime example of this, though the phenomenon occurs frequently in one-off and bespoke applications. A pile-of-files format essentially uses the filesystem as a key/value database, storing small chunks of information into separate files. This gives the advantage of making the content more accessible to common utility programs such as text editors or &quot;awk&quot; or &quot;grep&quot;. But even if many of the files in a pile-of-files format are easily readable, there are usually some files that have their own custom format (example: Git &quot;Packfiles&quot;) and are hence &quot;opaque blobs&quot; that are not readable or writable without specialized tools. It is also much less convenient to move a pile-of-files from one place or machine to another, than it is to move a single file. And it is hard to make a pile-of-files document into an email attachment, for example. Finally, a pile-of-files format breaks the &quot;document metaphor&quot;: there is no one file that a user can point to that is &quot;the document&quot;.</source>
          <target state="translated">&lt;b&gt;一堆文件格式。&lt;/b&gt;有时，应用程序状态存储为文件层次结构。 Git是一个很好的例子，尽管这种现象在一次性定制应用中经常发生。文件堆格式本质上将文件系统用作键/值数据库，将一小部分信息存储到单独的文件中。这具有使内容更易于普通实用程序（例如文本编辑器或&amp;ldquo; awk&amp;rdquo;或&amp;ldquo; grep&amp;rdquo;）访问的优点。但是，即使许多文件格式的文件都易于阅读，但通常还是有些文件具有自己的自定义格式（例如，Git&amp;ldquo; Packfiles&amp;rdquo;），因此是不可读或不透明的&amp;ldquo;不透明斑点&amp;rdquo;无需专用工具即可写。将一堆文件从一个地方或机器移动到另一个地方也不太方便，而不是移动单个文件。例如，很难将一堆文件变成电子邮件附件。最后，一堆文件格式打破了&amp;ldquo;文档隐喻&amp;rdquo;：用户可以指向的文件就是&amp;ldquo;文档&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="06e1ef37e925aec595836f976814c7b5716fb8ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Plays well with memory debuggers.&lt;/b&gt; Memory allocation in SQLite is structured so that standard third-party memory debuggers (such as &lt;a href=&quot;http://dmalloc.com&quot;&gt;dmalloc&lt;/a&gt; or &lt;a href=&quot;http://valgrind.org&quot;&gt;valgrind&lt;/a&gt;) can be used to verify correct memory allocation behavior.</source>
          <target state="translated">&lt;b&gt;与内存调试器一起很好地玩。&lt;/b&gt;SQLite中的内存分配具有结构性，因此可以使用标准的第三方内存调试器（例如&lt;a href=&quot;http://dmalloc.com&quot;&gt;dmalloc&lt;/a&gt;或&lt;a href=&quot;http://valgrind.org&quot;&gt;valgrind&lt;/a&gt;）来验证正确的内存分配行为。</target>
        </trans-unit>
        <trans-unit id="39951f449e5ceec6f9a022225faab5c19101b3de" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Policy Changes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;政策变更：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e2863a854f7569042d7772c825bca3bf981195c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Portability enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;便携性增强：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="80049d6fbf18722eba9cb49ab1cc1bbd73558530" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Portability&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Portability&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4c96fb6c7dab84d62ed86f4a23baec2f8c0d10eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Possible Enhancements&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;可能的增强&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68538fd5cb8fea275b4992c2b729e378880943ad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Potentially Disruptive Change:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;潜在破坏性变化：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18f89a0b4c42a90efdb28e7e3e5ef1be9872e99b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Proof against breakdown and fragmentation.&lt;/b&gt; SQLite can be configured so that, subject to certain usage constraints detailed below, it is guaranteed to never fail a memory allocation or fragment the heap. This property is important to long-running, high-reliability embedded systems where a memory allocation error could contribute to an overall system failure.</source>
          <target state="translated">&lt;b&gt;防止故障和破碎的证明。&lt;/b&gt;可以对SQLite进行配置，以确保在遵守下面详细说明的某些使用限制的情况下，确保永远不会使内存分配失败或使堆碎片化。此属性对于长时间运行的高可靠性嵌入式系统很重要，在这种系统中，内存分配错误可能会导致整个系统故障。</target>
        </trans-unit>
        <trans-unit id="ac8f710182b5d046c627cafbd710d5a4b76712b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Public domain&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;公共区域&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5f4e98a2bc425605ca9ae67429cb81a244edf06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Query by rowid&lt;/b&gt;. If the WHERE clause of the SELECT statement contains a sub-clause of the form &quot;rowid = ?&quot;, where ? is an SQL expression, FTS is able to retrieve the requested row directly using the equivalent of an SQLite &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; index.</source>
          <target state="translated">&lt;b&gt;通过rowid查询&lt;/b&gt;。如果SELECT语句的WHERE子句包含形式为&amp;ldquo; rowid =？&amp;rdquo;的子句，则其中？是SQL表达式，FTS可以使用等效的SQLite &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;索引直接检索请求的行。</target>
        </trans-unit>
        <trans-unit id="4c87196f9621ee8cab25b7ddca397f6aebb7dd5e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RANGE &amp;rarr;&lt;/b&gt; For this form, the ORDER BY clause of the window-defn must have a single term. Call that ORDER BY term &quot;X&quot;. Let X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; be the value of the X expression for the i-th row in the partition and let X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; be the value of X for the current row. Informally, a RANGE bound is the first row for which X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; is within the &amp;lt;expr&amp;gt; of X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;. More precisely:</source>
          <target state="translated">&lt;b&gt;RANGE&amp;rarr;&lt;/b&gt;对于这种形式，window-defn的ORDER BY子句必须有一个术语。将该ORDER BY称为&amp;ldquo; X&amp;rdquo;。令X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;为分区中第i行的X表达式的值，令X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;为当前行中X的值。非正式地，RANGE边界是X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;在X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;的&amp;lt;expr&amp;gt;内的第一行。更确切地说：</target>
        </trans-unit>
        <trans-unit id="f148886a2921d230cf2a13f933e1a32a3ada6d4c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RANGE&lt;/b&gt;: The RANGE frame type requires that the ORDER BY clause of the window have exactly one term. Call that term &quot;X&quot;. With the RANGE frame type, the elements of the frame are determined by computing the value of expression X for all rows in the partition and framing those rows for which the value of X is within a certain range of the value of X for the current row. See the description in the &quot;&lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/a&gt;&quot; boundary specification below for details.</source>
          <target state="translated">&lt;b&gt;RANGE&lt;/b&gt;：RANGE帧类型要求窗口的ORDER BY子句仅具有一个术语。将该术语称为&amp;ldquo; X&amp;rdquo;。对于RANGE帧类型，通过计算分区中所有行的表达式X的值，并将那些X值在当前行的X值的一定范围内的行取景，来确定帧的元素。有关详细信息，请参见下面的&amp;ldquo; &lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/a&gt; &amp;rdquo;边界规范中的描述。</target>
        </trans-unit>
        <trans-unit id="80ac38949c365f3e6967f3b57e43c758b0bd0074" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU Update operations&lt;/b&gt;. An &lt;a href=&quot;rbu#rbu_updates&quot;&gt;RBU Update&lt;/a&gt; is a bulk update of a database file that may include many insert, update and delete operations on one or more tables.</source>
          <target state="translated">&lt;b&gt;RBU更新操作&lt;/b&gt;。一个&lt;a href=&quot;rbu#rbu_updates&quot;&gt;RBU更新&lt;/a&gt;是一个数据库文件，该文件可能包含许多INSERT，UPDATE和一个或多个表删除操作的批量更新。</target>
        </trans-unit>
        <trans-unit id="b3e90d620642f9f1b13a8d79ab7f5ebf814e1ee2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU Vacuum operations&lt;/b&gt;. An &lt;a href=&quot;rbu#rbu_vacuum&quot;&gt;RBU Vacuum&lt;/a&gt; optimizes and rebuilds an entire database file, with results similar to SQLite's native VACUUM command.</source>
          <target state="translated">&lt;b&gt;RBU真空操作&lt;/b&gt;。一个&lt;a href=&quot;rbu#rbu_vacuum&quot;&gt;RBU真空&lt;/a&gt;优化和重建整个数据库文件，用类似的SQLite的原生真空命令的结果。</target>
        </trans-unit>
        <trans-unit id="3fb84bb6a81a53e7beaf8eba1959d7978c9fa592" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU may be more efficient&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;RBU可能更有效&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="534b078b65236f5fb856d2b9635b23b17d44a80a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU runs in the background&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;RBU在后台运行&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="698e51407e465d0e304762b117a916981e0fecec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU runs incrementally&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;RBU逐步运行&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ba35125f15a716954fed100209c8e617a8adc611" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;REAL&lt;/b&gt; as Julian day numbers, the number of days since noon in Greenwich on November 24, 4714 B.C. according to the proleptic Gregorian calendar.</source>
          <target state="translated">&lt;b&gt;REAL&lt;/b&gt;为儒略日的数字，因为中午在格林威治11月24日的天数，4714根据proleptic公历BC。</target>
        </trans-unit>
        <trans-unit id="05e01e432f196ae91813f817e48ac2893edada51" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;REAL&lt;/b&gt;. The value is a floating point value, stored as an 8-byte IEEE floating point number.</source>
          <target state="translated">&lt;b&gt;真实的&lt;/b&gt;。该值是一个浮点值，存储为8字节IEEE浮点数。</target>
        </trans-unit>
        <trans-unit id="72a1aec4b000b724faf3e2dce2df47fdc044f0e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;REPLACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;REPLACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cea249bacf17bdcc200de4331dc5afa32b20686" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RESTRICT&lt;/b&gt;: The &quot;RESTRICT&quot; action means that the application is prohibited from deleting (for ON DELETE RESTRICT) or modifying (for ON UPDATE RESTRICT) a parent key when there exists one or more child keys mapped to it. The difference between the effect of a RESTRICT action and normal foreign key constraint enforcement is that the RESTRICT action processing happens as soon as the field is updated - not at the end of the current statement as it would with an immediate constraint, or at the end of the current transaction as it would with a deferred constraint. Even if the foreign key constraint it is attached to is deferred, configuring a RESTRICT action causes SQLite to return an error immediately if a parent key with dependent child keys is deleted or modified.</source>
          <target state="translated">&lt;b&gt;RESTRICT&lt;/b&gt;：&amp;ldquo; RESTRICT&amp;rdquo;操作表示禁止在存在一个或多个子键映射到父键的情况下删除（对于ON DELETE RESTRICT）或修改（对于ON UPDATE RESTRICT）父键。 RESTRICT动作与常规外键约束执行的效果之间的区别在于，RESTRICT动作处理在字段更新后立即进行-而不是像立即约束那样在当前语句的末尾或结尾处进行与延迟约束相同的当前交易额。即使推迟了附加的外键约束，如果删除或修改了具有相关子键的父键，配置RESTRICT操作也会导致SQLite立即返回错误。</target>
        </trans-unit>
        <trans-unit id="ff3caed40a2a7601b4cc8c41862c43dae15801b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ROLLBACK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ROLLBACK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6b6540ce45b70728693b5f961b3a0c4d151f4ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ROWS &amp;rarr;&lt;/b&gt; The frame boundary is the row that is &amp;lt;expr&amp;gt; rows before the current row, or the first row of the partition if there are fewer than &amp;lt;expr&amp;gt; rows before the current row. &amp;lt;expr&amp;gt; must be an integer.</source>
          <target state="translated">&lt;b&gt;ROWS&amp;rarr;&lt;/b&gt;帧边界是当前行之前&amp;lt;expr&amp;gt;行的行，如果当前行之前少于&amp;lt;expr&amp;gt;行，则为分区的第一行。&amp;lt;expr&amp;gt;必须为整数。</target>
        </trans-unit>
        <trans-unit id="7085652850f337f1292781b03c80d52166e2b0db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ROWS&lt;/b&gt;: The ROWS frame type means that the starting and ending boundaries for the frame are determined by counting individual rows relative to the current row.</source>
          <target state="translated">&lt;b&gt;ROWS&lt;/b&gt;：ROWS帧类型表示通过计算相对于当前行的各个行来确定帧的开始和结束边界。</target>
        </trans-unit>
        <trans-unit id="cfbbf924262e1a960882f1c8318fdffdb65fb290" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RTRIM&lt;/b&gt; - The same as binary, except that trailing space characters are ignored.</source>
          <target state="translated">&lt;b&gt;RTRIM-&lt;/b&gt;与二进制文件相同，只是忽略了尾随空格字符。</target>
        </trans-unit>
        <trans-unit id="c8987ec8d449abc8fe9709de818ab14d807212ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Read content from the database and WAL as part of a transaction&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;从数据库和WAL读取内容作为事务的一部分&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9f049da3ffd93dd209c35732fa0f0e1ebda56a14" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Readable source code&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;可读的源代码&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c292627528bb82684b411ccd58e38f7f789c1262" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Reconstruct the global shared WAL-index during &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;在&lt;a href=&quot;walformat#recovery&quot;&gt;恢复&lt;/a&gt;期间重建全局共享的WAL索引&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31363531301f2d3466de9930ba452b0df0dbb623" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Recursion limit on foreign key actions.&lt;/b&gt; The &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt; settings determine the maximum allowable depth of trigger program recursion. For the purposes of these limits, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are considered trigger programs. The &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; setting does not affect the operation of foreign key actions. It is not possible to disable recursive foreign key actions.</source>
          <target state="translated">&lt;b&gt;外键动作的递归限制。&lt;/b&gt;该&lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt;和&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;设置确定触发递归程序所允许的最大深度。出于这些限制的目的，&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外键动作&lt;/a&gt;被视为触发程序。该&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA RECURSIVE_TRIGGERS&lt;/a&gt;设置不影响外键操作的操作。无法禁用递归外键操作。</target>
        </trans-unit>
        <trans-unit id="294b87e6ed53158c02a9241c192d4bc0c7b5a44c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Reduced application cost and complexity&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;降低应用程序成本和复杂性&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1512b5f805325fc9a62b2f5f69951fc71245aa4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Reliability&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Reliability&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f2056282af938ba0160e81e148e7c1753145d69" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Replacement for &lt;i&gt;ad hoc&lt;/i&gt; disk files&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;i&gt;临时&lt;/i&gt;磁盘文件的替换&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c0e67e4fde91da154b9be4c31cb9cd64d6ded3e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Reset the WAL file&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;重置WAL文件&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96047c6ef3195ac1b96321749d11246af960cb46" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Robust against allocation failures.&lt;/b&gt; If a memory allocation ever fails (that is to say, if malloc() or realloc() ever return NULL) then SQLite will recover gracefully. SQLite will first attempt to free memory from unpinned cache pages then retry the allocation request. Failing that, SQLite will either stop what it is doing and return the &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error code back up to the application or it will make do without the requested memory.</source>
          <target state="translated">&lt;b&gt;坚固耐用，可防止分配失败。&lt;/b&gt;如果内存分配曾经失败（也就是说，如果malloc（）或realloc（）返回NULL），则SQLite将正常恢复。SQLite将首先尝试从未固定的缓存页释放内存，然后重试分配请求。失败的话，SQLite要么停止正在执行的操作，然后将&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;错误代码返回到应用程序，要么在没有请求的内存的情况下执行。</target>
        </trans-unit>
        <trans-unit id="a6079c1697e8a6442575a964d330a78ba38bec07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Run a checkpoint&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;运行检查点&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d8947ef2bec239716ae0db33a2b920924684d2b7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SET DEFAULT&lt;/b&gt;: The &quot;SET DEFAULT&quot; actions are similar to &quot;SET NULL&quot;, except that each of the child key columns is set to contain the columns default value instead of NULL. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details on how default values are assigned to table columns.</source>
          <target state="translated">&lt;b&gt;SET DEFAULT&lt;/b&gt;：&amp;ldquo; SET DEFAULT&amp;rdquo;操作与&amp;ldquo; SET NULL&amp;rdquo;类似，不同之处在于，每个子键列均设置为包含列的默认值而不是NULL。有关如何将默认值分配给表列的详细信息，请参考&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="33b91f3630ca4ab746765602396efa572d3094a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SET NULL&lt;/b&gt;: If the configured action is &quot;SET NULL&quot;, then when a parent key is deleted (for ON DELETE SET NULL) or modified (for ON UPDATE SET NULL), the child key columns of all rows in the child table that mapped to the parent key are set to contain SQL NULL values.</source>
          <target state="translated">&lt;b&gt;SET NULL&lt;/b&gt;：如果配置的操作为&amp;ldquo; SET NULL&amp;rdquo;，则当删除父键（对于ON DELETE SET NULL）或修改父键（对于ON UPDATE SET NULL）时，映射的子表中所有行的子键列设置为包含父键的SQL NULL值。</target>
        </trans-unit>
        <trans-unit id="76be85ce351bcd022dfc21628e13b422efb53a23" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQL language extensions&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQL语言扩展&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f4b14f80a5a266a69df239ded6632d913a87a00a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQL statements compile into virtual machine code&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQL语句编译成虚拟机代码&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="83c0c487d93dc334f8c302e295ed7938423066bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3aa723b4ca5a3e0f908a87dd06720f76499a803d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN = &lt;i&gt;&amp;lt;0或1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f93c111578aad97e0a49efe448bf05ad58e312b7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7115d3b8d179eabb10343181c396bb71e9528d1b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="87d2e963d002664b9641ea35fee9f4be4af1d3d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_APICALL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_APICALL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="45844421048f1fe03ce743ccddcc45d28b903411" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_BYTEORDER=&lt;i&gt;(0|1234|4321)&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_BYTEORDER=&lt;i&gt;(0|1234|4321)&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="81a33fa84c2772b37cd9cf1742e61a9b26cffebf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_CALLBACK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_CALLBACK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d487c4778cc7399d3ed400d70b24d3224d6c900" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ca8bc702a0ab56ee63a0f508cfed6679268a020f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_CDECL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_CDECL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="055d8a144a29467bf25fe8fd58a953d8d39a84e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEBUG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEBUG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99071bbb25358764662a16ba481391de6386a6ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX = &lt;i&gt;&amp;lt;0或1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b822ada3607d9e4a3417e9b6688f31eb62d742a3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_AUTOVACUUM=&lt;i&gt;&amp;lt;0 or 1 or 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_AUTOVACUUM = &lt;i&gt;&amp;lt;0或1或2&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="43ecdb65cd38b77a57c5c5315e9d3cb506b4d93e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_CACHE_SIZE=&lt;i&gt;&amp;lt;N&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_CACHE_SIZE=&lt;i&gt;&amp;lt;N&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d961c346273a9c1750541784f8ed1fcf52f30923" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_FILE_FORMAT=&lt;i&gt;&amp;lt;1 or 4&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_FILE_FORMAT = &lt;i&gt;&amp;lt;1或4&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c5c7318f455d9e86512b271a46ebc152f3cc07d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_FILE_PERMISSIONS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_FILE_PERMISSIONS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8854f3260e6de1c5bc538a21e49e7c4d6ecb1370" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_FOREIGN_KEYS=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_FOREIGN_KEYS = &lt;i&gt;&amp;lt;0或1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd62f813164104a4a8dace6a9fb8d384ba9a27a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT=&lt;i&gt;&amp;lt;bytes&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT=&lt;i&gt;&amp;lt;bytes&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7dc1ce2a4b2e8db810f32d21156412bbed8e0f7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_LOCKING_MODE=&lt;i&gt;&amp;lt;1 or 0&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_LOCKING_MODE = &lt;i&gt;&amp;lt;1或0&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="19cf7c4c2794ec95ba5fea9ffe72ae6d604f2189" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f47ddaa680cfc53714d3dc1be4264584592d7e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_MEMSTATUS=&lt;i&gt;&amp;lt;1 or 0&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_MEMSTATUS = &lt;i&gt;&amp;lt;1或0&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="36ce382183b4de0c5612dfcc98537f87d51f8cd9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2e65bc393f4fb1826409f09b5a3bd23eca3ed4a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_PAGE_SIZE=&lt;i&gt;&amp;lt;bytes&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_PAGE_SIZE=&lt;i&gt;&amp;lt;bytes&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="29c7e07d19c64c72d94c4234ebb35d0155c95b1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_PCACHE_INITSZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_PCACHE_INITSZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c2c797fd4625193c1b96565a3ef27f80da9bfec4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_SYNCHRONOUS=&lt;i&gt;&amp;lt;0-3&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_SYNCHRONOUS=&lt;i&gt;&amp;lt;0-3&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5f53a79ce09a0fb9d64e5120c32baaded6a35694" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT=&lt;i&gt;&amp;lt;pages&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT=&lt;i&gt;&amp;lt;pages&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="43fc152a5d74616e6bb14cdef7755867f249ffc1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS=&lt;i&gt;&amp;lt;0-3&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS=&lt;i&gt;&amp;lt;0-3&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="267fce3dc954776d41c9549141844c9525bd5ca0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0b0d6df2dfe3254fb8ada64ce2610060f996ebb5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe774070f0c5c60df1652e7a9bf25e55d43f9484" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_DIRSYNC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_DIRSYNC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad90c2cd9b3c9e9ad1923c1b58b05476f888e913" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_FTS3_UNICODE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_FTS3_UNICODE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3ac65ff44396720fbbe185ffa52b572404994c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7dbe88c8699c03655a129fb63f7f3c4fb866f908" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_INTRINSIC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_INTRINSIC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2cbe1ffe001595f46022d06cd2a027d53e0c08be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_LFS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_LFS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d3f52b1c42784d95687ae89d3a11bb3734220862" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="551b883f5de8b21941883d216c74ab7c3c05072a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_8_3_NAMES=&lt;i&gt;&amp;lt;1 or 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_8_3_NAMES = &lt;i&gt;&amp;lt;1或2&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a28faa4e4504f8ca28667e6ce37e99f30e6745b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_API_ARMOR&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_API_ARMOR&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bed29376ce20d920bb1b1133dec7a10be041cf6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="92b48ac312580ef48db8a01e6a99045ac0c33bd3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="845b28c3b90cdf3bd16b06fa3fa8b3eb290297d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_BYTECODE_VTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_BYTECODE_VTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c7b0d6431f49e6bf24765ed171474b60da4b6f7e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0b2e2dfbadc7daaf12dcf0f4ae9559406be61667" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="020fd35f0bf4b2316e6efd2b506ed67303cb238f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="17c8dc66408aa1c3909df52aca12f92605481017" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_DESERIALIZE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_DESERIALIZE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="973a36b7666be8ac3ec6d5a963ef55fe792299cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68b8eb9074c3cee849d29ae97e0ac1d8fef4b515" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS3&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS3&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="620b6f70b569c5c847648263e8bda1d1814eaaef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4033dbb6b68eede2da9ec9639dc59521855a2a40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fee3e2b47cd366e63b674ce5d8854685a0ee627" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fd7224abedc2d1f6de23bbe56e687f922a5e27bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS5&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS5&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46eb1c96aaf24b76dc4073d011dc991646d05843" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_GEOPOLY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_GEOPOLY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bcac5312082e20cee3c423c5e945a8fae19e4b96" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_ICU&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_ICU&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf9ed42c29ced5eb0918cd4f2526cca3b091e45f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_IOTRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_IOTRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cd26c6f3bcb6452d1761b1c3cde0b2e849b7b1b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_JSON1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_JSON1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4101cc723ca06d4f28f7f4af8fc174a289cc5a30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_LOCKING_STYLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_LOCKING_STYLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2c505a1f02c04aa3726f859aa9aab2d19a175d87" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="53de3c45119fbb85e6e306c8ef673329ce547bc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_MEMSYS3&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_MEMSYS3&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0dee81eafae0d4aea8e3a9e54e7f51d78c86aa2e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_MEMSYS5&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_MEMSYS5&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2500c9c2e2e28fafbb17a1137edf0b22c762f19" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_NULL_TRIM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_NULL_TRIM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="210b5c9d01b428603304b06ceb94d16df27f957c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ddb51545e0bebfa7340c6cac3885e03fbb94fa35" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e39e596eb481fbc8bc498aa1eb115a9dbd791bf4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_QPSG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_QPSG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aff785ec1400a7959c2d910171f7d36af168d741" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_RBU&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_RBU&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d7312a16f85346b92777f81548b126126f2a9ce9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_RTREE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_RTREE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf2789a3dfac2aec0ce73567ef591f88c395a4a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SESSION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SESSION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8abf674d55e555f734817a21ddcd5e21c3015707" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SNAPSHOT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SNAPSHOT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fbcbad5bbf055acd0b8cb0f65883a99e15403389" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="050fd9347aba0613e41edd6d9163428b913cee4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SQLLOG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SQLLOG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0204d4bbf2c54d3a1ed06e32f0d2fbfba810aaf2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc060831fa345f0a6eab149e614a038d39d92be3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT3&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT3&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aadb411eed6a3e5c2d4eea8759254437ad95f39e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="faf2c9cc0d944bfbdb7cc148d522d3051abfdcf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STMTVTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STMTVTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95df966b12c5979c6c37cfbb73acce4de4031b52" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8c43e0af9e63a24260b1237ffafa9382ffcb8eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="10ad0ef0211ad8e21498cf3f4662f8bcc6ba15cf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd992a7384df4b2049382d0b4180b642a115bd15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e01ddc96bb53d6b852d1690bde30ccdb2f85dafe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cedadab65ac150d458ca8e13ba1611fb33b07ce8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_EXTRA_DURABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_EXTRA_DURABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="253b5d9f8f32fa07fef6dbd123f4ce91b701c1d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_FTS3_MAX_EXPR_DEPTH=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_FTS3_MAX_EXPR_DEPTH=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6a286554137726a245c1b95b8192b6c3bbd3251" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_HAVE_ISNAN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_HAVE_ISNAN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9db0cb11222acab74db65c807eff63f7f55c2ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_HAVE_ZLIB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_HAVE_ZLIB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05591c0534904e32ca8cdac4b25cbb9d60a573b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_INTROSPECTION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_INTROSPECTION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9c352c0861967ddc2df753cc4bbcd4bcba3f2f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5ceb830bc9fd789f4fa5f7fcc0cabfaf48496306" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LOCK_EXCLUSIVE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LOCK_EXCLUSIVE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b03ae772584c2d2a9e11d0dc7338890a0357eb9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LOCK_SHARED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LOCK_SHARED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c99e4b045bc420fa97a94b4105d7f761fb24049c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_MEMORY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_MEMORY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9c354011c14318ca6d262f2573fba28199396470" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a401e4995f5551e362e32c54e2ba19071ea64e48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_SCHEMA_RETRY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_SCHEMA_RETRY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="acb2a8063accd6b8beb78cacc0a648a21d40a870" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b462c3d40d420240b9032bbae35bd514d016567b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99a1ffd86d48620ac9d92bbfacc8dd600f0161cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MEMDEBUG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MEMDEBUG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a4e92305244c1ce6fd0f4cd7269789b8529f373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3334e6a6da5c866bd89fe950d2c9b62e97f7ceb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ALTERTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ALTERTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d9ecdc843e92293dcb6abf6daf54b6c3b4881468" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ANALYZE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ANALYZE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bfe038e385667f427bfaba3d91a9af26eba94450" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ATTACH&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ATTACH&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d6d0848efb00b356cb9465d9f109e2147210b9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTHORIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTHORIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7fdef8c2a9c01031f943ed79f514a8156d673500" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOINCREMENT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOINCREMENT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2d8960215ae00abd7ebb1925d984e4b874f7c871" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOINIT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOINIT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aaf355948028ec514c8e85609b52d8ff903f1574" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3a1d498df4dd274ff01a03900ec4b34dda79009c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTORESET&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTORESET&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c6a54eaef40777e126f4002faabd672a7e9f7e91" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOVACUUM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOVACUUM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc2f291f887ee161ef88691303623ca2effb8629" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BETWEEN_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BETWEEN_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31a30cf46373dc5197f8e3344abb93ca02b039ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BLOB_LITERAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BLOB_LITERAL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7e8d3c023e1a4ccad20b87139d88b7081b6817b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BTREECOUNT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BTREECOUNT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cff423655eb39b2c748dff51e94300e8f28ba4e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b62e20033dec22257f890ac30be31c4cd927192f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a4c5907c936567c2b7b9fa6bc346c059d43fc957" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CAST&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CAST&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5633de952d476b5d96fee010583ad94474595fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CHECK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CHECK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6fc3ef0b372de46a78bc829d1b0ac42417cbe60e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d42dd6fec81e49f75f5ff85d610101a339b93346" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPLETE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPLETE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="52d61fa2500d572bc3c2f61bc09133f36d87d7a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPOUND_SELECT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPOUND_SELECT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffebea17346fc66899b100e42dde64847ae162ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CTE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CTE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="02a8ebfb8c51bfa8f5f04b211a7d7ff033ad0d12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="00568160f62e1e2f3c85a4ec68228a6d706532ce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DECLTYPE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DECLTYPE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d35796e3c6ab5d85720734a37998a6ce92535777" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DEPRECATED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DEPRECATED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="03eb1718823b671bd128fc3257e8b9065c569dd7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DISKIO&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DISKIO&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b059b5b58e6147c9da00dc4a5c50c89efee3912a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_EXPLAIN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_EXPLAIN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="389e2542bf1d776bda49aa816f7acb08834bd6cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FLAG_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FLAG_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="707057fed5f688f9208bf46ef4426a605d5f09df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FLOATING_POINT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FLOATING_POINT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bc82fd2191660ac807469076e0f7a404c356a0be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdf469011a3b01a769905c13c811e2aa6924e16e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_GENERATED_COLUMNS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_GENERATED_COLUMNS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0905065083397f185f42d644502785ba7c6069f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_GET_TABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_GET_TABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0da634636aa21dd63f86722f0b3d34ffade49316" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_HEX_INTEGER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_HEX_INTEGER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e27ca5135fcc6a84108dc0ffc11de226b7192e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INCRBLOB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INCRBLOB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e2d75578c65599befa260ca475b0a32c3620f002" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INTEGRITY_CHECK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INTEGRITY_CHECK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14ef2bd88a85199b30182a69235817a3b5204f1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="77f3d1be3901c085b4a5db58cfdd2f9aaa6ceeca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LIKE_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LIKE_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="136a7594d2f3c6161370dbd3a5755699a0f58d29" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a3dc23714e6733b26ba59900b7bd7b338d8e9f8e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOCALTIME&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOCALTIME&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5afb0b5eb77dd513826c4b386ca2f26d1f287909" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOOKASIDE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOOKASIDE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6bf04e411ffa329ca1466479098e23ff67d50730" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_MEMORYDB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_MEMORYDB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c059cfc62627b1886e1ca9f2629fb0b673e1d368" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_OR_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_OR_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ed3f9bfbb996093381267996d7d33c4f934eb7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PAGER_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PAGER_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d0281a47c9f5f4c349fb5ba928eb8bf37efa960" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PRAGMA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="be2660af6ab813539e2a8692aa5c050fd19d360c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="668be95a6a3f50c7a5a63db473a408745e328f6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_QUICKBALANCE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_QUICKBALANCE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f4eaaca938ecabc5c4dc11eaf9e065917dc70e26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_REINDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_REINDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="78dab73ee3da96b8c7ec1553d7f97a1d26d45cc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SCHEMA_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SCHEMA_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e59c47d4c6184784743e4358c78e436ed302c8d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f0e56325b2afaf6793e05912f440ee78e1e06f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SHARED_CACHE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SHARED_CACHE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6b5feca8b64e60e028e2dbdb4dce97b1428f8b10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SUBQUERY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SUBQUERY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="273973ea2fa452aa7255dd76283f67114dc7bc9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TCL_VARIABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TCL_VARIABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b844869cbb137b3f5aae65d9fc2124a7f75df280" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TEMPDB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TEMPDB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14def5836843dc064ff211faf4a1e5d1c19a5fc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8c7a3f7709d5ca48aa62de5b3a866714d6593cfb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRIGGER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRIGGER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bff9bf2bc1a52aebb220f94954f92e1545ac1446" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="abef01fc3e06b07aafa25fb3d9e477bfd22cef7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_UTF16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_UTF16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6336b6b7d8d57c2d7a777490e28348a06393d36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VACUUM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VACUUM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="059e2862fefd88c744b1377dc92f308d73cc50bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VIEW&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VIEW&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebb08208b1feeb2e4092b776ed5ddb8063c890ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6542f591162b1fac32afa54f47fc6731f33601c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_WAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_WAL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="04514e40f182ad456b5245a466634fbd7e92daf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_WSD&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_WSD&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3932897bd040e95c1eb9739b7659d68beda3ea49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_XFER_OPT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_XFER_OPT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2fad4f7fe54b95701a39ee8feb95777319a60e90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OS_OTHER=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OS_OTHER = &lt;i&gt;&amp;lt;0或1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56ee3d0e684b44b8675f52b13d0096d23504a7af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_POWERSAFE_OVERWRITE=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_POWERSAFE_OVERWRITE = &lt;i&gt;&amp;lt;0或1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="80c6ed8dbd133860dd6d357b4dc8c60c2b09f69b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_PRINTF_PRECISION_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_PRINTF_PRECISION_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6463226645ffe362c178bbe7f828d660c275a442" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6885cb8516f8377a9c28e855cb70b63504e6e435" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3a0235475a7827d68e0c1bb73ea4b44f4d323a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cec139681f0df7f780a39dbfc2f329845e7c650b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_RTREE_INT_ONLY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_RTREE_INT_ONLY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d94d24b874c2c537a6ea7780b2a6592350047905" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SECURE_DELETE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SECURE_DELETE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7713ed7ab2f2f1c55f8fdb3ab145f3b1b932345b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SORTER_PMASZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SORTER_PMASZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc3bed687fc846b37c550cd3cddfd9155cb90685" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SOUNDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SOUNDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d310d3f3bd739c56f040cc79192496e87ececfd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_STMTJRNL_SPILL=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_STMTJRNL_SPILL=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b8a23171b43aabf136109acb20d220b99d3e9da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SYSCALL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SYSCALL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0aba06a9fc72c1f03ecfc53abd7d244a52e61ce7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TCLAPI&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TCLAPI&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="857f1d4b039067e7938f0fbe3cd9dacc12a3cc3d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TEMP_STORE=&lt;i&gt;&amp;lt;0 through 3&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TEMP_STORE = &lt;i&gt;&amp;lt;0至3&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="763974a69da7c357391024b037f2ff65866c1c72" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_THREADSAFE=&lt;i&gt;&amp;lt;0 or 1 or 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_THREADSAFE = &lt;i&gt;&amp;lt;0或1或2&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db798c4c2b06b4515c31c3444478572466898eb9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TRACE_SIZE_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TRACE_SIZE_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a864ab43b658af57ffcc85d7075d94f4c0eb4a1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TRUSTED_SCHEMA=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TRUSTED_SCHEMA = &lt;i&gt;&amp;lt;0或1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="88ec24333763838d2b35e7775950f2196c7691af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_UNTESTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_UNTESTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08dfc4ddda00225d961592ced42dcb85aa2a6b68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_ALLOCA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_ALLOCA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b2c678e1824f51e764911d1d97afa9303106537c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_FCNTL_TRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_FCNTL_TRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f442370983bde912aeaa8688fb8696ae2e052aae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_URI&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_URI&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aa939f2dbd402ef231f0ab3788a92497d3d84650" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_HEAP_CREATE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_HEAP_CREATE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1343ce5771a0eb9359ec0df9e37c4cc2874c8ebd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="382b47f1f3b8cd49c3216efbc6c7a391dd57252d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="55cb4273e62d90804c53d091b40902649ec6153d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ZERO_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ZERO_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de509a166760f395e8d9ff623bc5c20f291203f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be disabled using the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法而不是此接口来禁用扩展加载，因此，&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数保持禁用状态。这将防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="77d070aba76c9c45f3f4dfb8cb2c0f7b57ceed06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be disabled using the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法而不是此接口来禁用扩展加载，因此，&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数保持禁用状态。这将防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="d719a3c99ca55bb1bc6c2bd4c61f4ad80e27b087" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be enabled using the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法而不是此接口启用扩展加载，因此&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数保持禁用状态。这将防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="fed85e3d24d294923ff9a94eb30c8ccf98e23751" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be enabled using the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法而不是此接口启用扩展加载，因此&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数保持禁用状态。这将防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="c39a9a8ee0c9f06fa3f477352418d833d84efb0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method be used to enable only this interface. The use of the &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface should be avoided. This will keep the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; disabled and prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法仅启用此接口。应该避免使用&lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;接口。这将使SQL函数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;保持禁用状态，并防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="85bcf242d91006a6e47ad703972cc780357bae6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method be used to enable only this interface. The use of the &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface should be avoided. This will keep the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; disabled and prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法仅启用此接口。应该避免使用&lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;接口。这将使SQL函数&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;保持禁用状态，并防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="cef37acd0e58d7484bc210c3874856e993d57c42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Self-documentation.&lt;/b&gt; Self-documenting digital objects contain basic descriptive, technical, and other administrative metadata.</source>
          <target state="translated">&lt;b&gt;自我证明。&lt;/b&gt;自记录数字对象包含基本的描述性，技术性和其他管理性元数据。</target>
        </trans-unit>
        <trans-unit id="67039928069e29c2b8fc9b97ed6661597211b7d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Serialized&lt;/b&gt;. In serialized mode, SQLite can be safely used by multiple threads with no restriction.</source>
          <target state="translated">&lt;b&gt;序列化&lt;/b&gt;。在序列化模式下，SQLite可以不受限制地被多个线程安全使用。</target>
        </trans-unit>
        <trans-unit id="e6c18085190b76c91a8135185e5040fe095bb489" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Server-side database&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;服务器端数据库&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a71e55c9e2165337c5f26b98320364c9a71fa32b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Serverless&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Serverless&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d28078da99c520e2ece9e2e044a1e465058479f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Side note: Bare columns in an aggregate queries.&lt;/b&gt; The usual case is that all column names in an aggregate query are either arguments to &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; or else appear in the GROUP BY clause. A result column which contains a column name that is not within an aggregate function and that does not appear in the GROUP BY clause (if one exists) is called a &quot;bare&quot; column. Example:</source>
          <target state="translated">&lt;b&gt;旁注：聚合查询中的裸列。&lt;/b&gt;通常的情况是，聚合查询中的所有列名称要么是&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合函数的&lt;/a&gt;参数，要么出现在GROUP BY子句中。结果列包含不在聚合函数中且未出现在GROUP BY子句中（如果存在的话）的列名，称为&amp;ldquo;裸&amp;rdquo;列。例：</target>
        </trans-unit>
        <trans-unit id="9a2bd3e845310e3146f075b7477b9a77fd861938" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Side note: Special handling of CROSS JOIN.&lt;/b&gt; There is no difference between the &quot;INNER JOIN&quot;, &quot;JOIN&quot; and &quot;,&quot; join operators. They are completely interchangeable in SQLite. The &quot;CROSS JOIN&quot; join operator produces the same result as the &quot;INNER JOIN&quot;, &quot;JOIN&quot; and &quot;,&quot; operators, but is &lt;a href=&quot;optoverview#crossjoin&quot;&gt;handled differently by the query optimizer&lt;/a&gt; in that it prevents the query optimizer from reordering the tables in the join. An application programmer can use the CROSS JOIN operator to directly influence the algorithm that is chosen to implement the SELECT statement. Avoid using CROSS JOIN except in specific situations where manual control of the query optimizer is desired. Avoid using CROSS JOIN early in the development of an application as doing so is a &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;premature optimization&lt;/a&gt;. The special handling of CROSS JOIN is an SQLite-specific feature and is not a part of standard SQL.</source>
          <target state="translated">&lt;b&gt;旁注：对CROSS JOIN的特殊处理。&lt;/b&gt; &amp;ldquo; INNER JOIN&amp;rdquo;，&amp;ldquo; JOIN&amp;rdquo;和&amp;ldquo;，&amp;rdquo;联接运算符之间没有区别。它们在SQLite中是完全可互换的。 &amp;ldquo; CROSS JOIN&amp;rdquo;联接运算符产生的结果与&amp;ldquo; INNER JOIN&amp;rdquo;，&amp;ldquo; JOIN&amp;rdquo;和&amp;ldquo;，&amp;rdquo;运算符相同，但是&lt;a href=&quot;optoverview#crossjoin&quot;&gt;查询优化器的处理方式不同&lt;/a&gt;，因为它阻止了查询优化器对联接中的表进行重新排序。应用程序程序员可以使用CROSS JOIN运算符直接影响为实现SELECT语句而选择的算法。避免使用CROSS JOIN，除非在特定情况下需要手动控制查询优化器。避免在应用程序开发的早期使用CROSS JOIN，因为这样做&lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;过早了&lt;/a&gt;。CROSS JOIN的特殊处理是SQLite特有的功能，不是标准SQL的一部分。</target>
        </trans-unit>
        <trans-unit id="ded659eb85771f35ee1281ea75f0b58206ff5892" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Simplified Application Development.&lt;/b&gt; No new code is needed for reading or writing the application file. One has merely to link against the SQLite library, or include the &lt;a href=&quot;amalgamation&quot;&gt;single &quot;sqlite3.c&quot; source file&lt;/a&gt; with the rest of the application C code, and SQLite will take care of all of the application file I/O. This can reduce application code size by many thousands of lines, with corresponding saving in development and maintenance costs.</source>
          <target state="translated">&lt;b&gt;简化的应用程序开发。&lt;/b&gt;读取或写入应用程序文件不需要任何新代码。只需链接到SQLite库，或将&lt;a href=&quot;amalgamation&quot;&gt;单个&amp;ldquo; sqlite3.c&amp;rdquo;源文件&lt;/a&gt;包含在其余应用程序C代码中，SQLite将负责所有应用程序文件I / O。这样可以减少数千行的应用程序代码大小，并相应节省开发和维护成本。</target>
        </trans-unit>
        <trans-unit id="1f1a07cced5f47f7259b19ba37568ce82cb769c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;单个数据库文件&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3366f819b02e356be2c09f8db154e11cec6006c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single-File Documents.&lt;/b&gt; An SQLite database is contained in a single file, which is easily copied or moved or attached. The &quot;document&quot; metaphor is preserved.</source>
          <target state="translated">&lt;b&gt;单文件文档。&lt;/b&gt;SQLite数据库包含在一个文件中，可以轻松地对其进行复制，移动或附加。&amp;ldquo;文档&amp;rdquo;隐喻被保留。</target>
        </trans-unit>
        <trans-unit id="68d21fce42cee774794d3e89752dc4c799a36e13" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single-thread&lt;/b&gt;. In this mode, all mutexes are disabled and SQLite is unsafe to use in more than a single thread at once.</source>
          <target state="translated">&lt;b&gt;单线程&lt;/b&gt;。在这种模式下，所有互斥锁都被禁用，SQLite不安全，不能一次在多个线程中使用。</target>
        </trans-unit>
        <trans-unit id="b814fcbadf45ac4a5e2cf73ad790b7ea7575388b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stable Cross-Platform Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;稳定的跨平台数据库文件&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d63c76d6f056bff7c1ab6bf58be4afa5f7344184" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stable, Cross-platform Database Files&lt;/b&gt; &amp;rarr; SQLite &lt;a href=&quot;fileformat2&quot;&gt;database files&lt;/a&gt; are bit-for-bit identical on 32-bit, 64-bit, big-endian, and little-endian platforms. You can copy an SQLite database file from one system to another without having to translate or convert the database. Furthermore, the file format is well documented and stable. Database files created today will be readable and writable by future versions of SQLite decades in the future.</source>
          <target state="translated">&lt;b&gt;稳定的跨平台数据库文件&lt;/b&gt;&amp;rarr;SQLite&lt;a href=&quot;fileformat2&quot;&gt;数据库文件&lt;/a&gt;在32位，64位，大端和小端平台上逐位相同。您可以将SQLite数据库文件从一个系统复制到另一个系统，而无需转换或转换数据库。此外，文件格式有据可查且稳定。今天创建的数据库文件将在未来几十年的SQLite的将来版本中可读和写。</target>
        </trans-unit>
        <trans-unit id="4b6d0729d61e68af9be12dd919ff6d4508e9058a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stand-in For An Enterprise RDBMS.&lt;/b&gt; SQLite is often used as a surrogate for an enterprise RDBMS for demonstration purposes or for testing. SQLite is fast and requires no setup, which takes a lot of the hassle out of testing and which makes demos perky and easy to launch.</source>
          <target state="translated">&lt;b&gt;企业RDBMS的替身。&lt;/b&gt;SQLite通常用作企业RDBMS的替代品，以进行演示或测试。SQLite速度很快，不需要任何设置，这消除了测试中的许多麻烦，并使演示活泼且易于启动。</target>
        </trans-unit>
        <trans-unit id="49211ca87490fc949777a3fa6df7da5023e3e641" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stand-in for an enterprise database during demos or testing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;在演示或测试期间替代企业数据库&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e613e33621af0e53400119bdd08e80a1c293ae5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Startup is slow.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;启动缓慢。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6f8a8cb97bdf26af3f7bcb45031e40198e438d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Summary:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Summary:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b838b6a7626f1106767937cfe090ef328a06b3c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;T&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;T&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cc92e1072d6f0803cf0720093c61b6114a74aff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TEXT&lt;/b&gt; as ISO8601 strings (&quot;YYYY-MM-DD HH:MM:SS.SSS&quot;).</source>
          <target state="translated">&lt;b&gt;文本&lt;/b&gt;为ISO8601字符串（&amp;ldquo; YYYY-MM-DD HH：MM：SS.SSS&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="51b499bb47a4b816c200573bc1654699b3396326" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TEXT&lt;/b&gt;. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).</source>
          <target state="translated">&lt;b&gt;文字&lt;/b&gt;。该值是一个文本字符串，使用数据库编码（UTF-8，UTF-16BE或UTF-16LE）存储。</target>
        </trans-unit>
        <trans-unit id="1175f4dc14e4a992c9182cfb85c0229a4412adea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Table name&lt;/b&gt;. The name of the component table within its database.</source>
          <target state="translated">&lt;b&gt;表名&lt;/b&gt;。数据库中组件表的名称。</target>
        </trans-unit>
        <trans-unit id="cce6f2ddbb90e75814b5925f282a337f2a6222d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Technical Protection Mechanisms.&lt;/b&gt; Implementation of mechanisms such as encryption that prevent the preservation of content by a trusted repository.</source>
          <target state="translated">&lt;b&gt;技术保护机制。&lt;/b&gt;诸如加密之类的机制的实现，这些机制阻止了受信任存储库保留内容。</target>
        </trans-unit>
        <trans-unit id="8b8491e1f95ab90350e3e533b25fcfd87b3e25b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Test, Debug, and Analysis Changes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;测试，调试和分析更改：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e053a51d81e6a2c72b1bc41555611b2f50e7a8c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &quot;DROP TABLE&quot; Exception&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;ldquo; DROP TABLE&amp;rdquo;异常&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7ee9ee9b8b34c217caeb5704b148f23d252d528" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental blob I/O&lt;/a&gt; mechanism does not work for WITHOUT ROWID tables.&lt;/b&gt; Incremental BLOB I/O uses the rowid to create an &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object for doing the direct I/O. However, WITHOUT ROWID tables do not have a rowid, and so there is no way to create an &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object for a WITHOUT ROWID table.</source>
          <target state="translated">&lt;b&gt;该&lt;a href=&quot;c3ref/blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;机制不为工作而ROWID表。&lt;/b&gt;增量BLOB I / O使用rowid创建一个&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;对象，以执行直接I / O。但是，WITHOUT ROWID表没有行号，因此无法为WITHOUT ROWID表创建&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="e9333e7627a2d8956128f8661c8ce6d0c01b3a38" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function does not work for WITHOUT ROWID tables.&lt;/b&gt; Inserts into a WITHOUT ROWID do not change the value returned by the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function. The &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; SQL function is also unaffected since it is just a wrapper around &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;该&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数不会对没有ROWID表工作。&lt;/b&gt;插入WITHOUT ROWID不会更改&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数返回的值。该&lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）&lt;/a&gt; SQL功能也丝毫不受影响，因为它仅仅是围绕着包装&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d83b61d9f4987dc0f941ad211863bc9aa49f3be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; interface does not fire callbacks for changes to a WITHOUT ROWID table.&lt;/b&gt; Part of the callback from &lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; is the rowid of the table row that has changed. However, WITHOUT ROWID tables do not have a rowid. Hence, the update hook is not invoked when a WITHOUT ROWID table changes.</source>
          <target state="translated">&lt;b&gt;该&lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook（）&lt;/a&gt;接口不火对于没有ROWID表变为回调。&lt;/b&gt;来自&lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook（）&lt;/a&gt;的回调的一部分是已更改的表行的rowid。但是，WITHOUT ROWID表没有行号。因此，当WITHOUT ROWID表更改时，不会调用更新挂钩。</target>
        </trans-unit>
        <trans-unit id="0d6305d6204c7fa058d43a6412f44de76568442f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The pthreads API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;pthreads API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2445d1d7779f00615aec27dcadb26e02eae2a0fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The special behaviors associated &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; do not apply on WITHOUT ROWID tables.&lt;/b&gt; In an ordinary table, &quot;INTEGER PRIMARY KEY&quot; means that the column is an alias for the rowid. But since there is no rowid in a WITHOUT ROWID table, that special meaning no longer applies. An &quot;INTEGER PRIMARY KEY&quot; column in a WITHOUT ROWID table works like an &quot;INT PRIMARY KEY&quot; column in an ordinary table: It is a PRIMARY KEY that has integer &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;与&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &amp;rdquo; 关联的特殊行为不适用于WITHOUT ROWID表。&lt;/b&gt;在普通表中，&amp;ldquo; INTEGER PRIMARY KEY&amp;rdquo;表示该列是rowid的别名。但是，由于WITHOUT ROWID表中没有rowid，因此该特殊含义不再适用。WITHOUT ROWID表中的&amp;ldquo; INTEGER PRIMARY KEY&amp;rdquo;列的作用类似于普通表中的&amp;ldquo; INT PRIMARY KEY&amp;rdquo;列：它是具有整数&lt;a href=&quot;datatype3#affinity&quot;&gt;亲和力&lt;/a&gt;的PRIMARY KEY 。</target>
        </trans-unit>
        <trans-unit id="dca5135672aa5896d1934aec89434fccdee88668" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The sqlite3_config() interface is not threadsafe. The application must ensure that no other SQLite interfaces are invoked by other threads while sqlite3_config() is running.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_config（）接口不是线程安全的。应用程序必须确保在运行sqlite3_config（）时，其他线程不会调用其他SQLite接口。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c710e5ea2792e8eded22905b82d87b3dcd213e68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The sqlite3_unlock_notify() API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_unlock_notify（）API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4617744409076bb539fa2b6bcbc61a76f81045ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This pragma is deprecated&lt;/b&gt; and exists for backwards compatibility only. New applications should avoid using this pragma. Older applications should discontinue use of this pragma at the earliest opportunity. This pragma may be omitted from the build when SQLite is compiled using &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;不建议使用此编译指示，&lt;/b&gt;并且仅为了向后兼容而存在。新的应用程序应避免使用此编译指示。较旧的应用程序应尽早停止使用该实用程序。使用&lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;编译SQLite时，可以从构建中省略此编译指示。</target>
        </trans-unit>
        <trans-unit id="58398df6716c7ad104ead532e8557ae487862fcd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Token or token prefix queries&lt;/b&gt;. An FTS table may be queried for all documents that contain a specified term (the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple case&lt;/a&gt; described above), or for all documents that contain a term with a specified prefix. As we have seen, the query expression for a specific term is simply the term itself. The query expression used to search for a term prefix is the prefix itself with a '*' character appended to it. For example:</source>
          <target state="translated">&lt;b&gt;令牌或令牌前缀查询&lt;/b&gt;。可以查询包含指定术语的所有文档的FTS表（上述&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;简单情况&lt;/a&gt;），或包含带有指定前缀的术语的所有文档。如我们所见，特定术语的查询表达式只是该术语本身。用于搜索术语前缀的查询表达式是前缀本身，后面带有&amp;ldquo; *&amp;rdquo;字符。例如：</target>
        </trans-unit>
        <trans-unit id="35470c2e36b5d89ec0e5e0b5a16713ad8751938f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Transition into and out of WAL-mode&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;进入和退出WAL模式&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e85cc4d69fe87371b922680953209fdf60a9693f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Transparency.&lt;/b&gt; Degree to which the digital representation is open to direct analysis with basic tools, such as human readability using a text-only editor.</source>
          <target state="translated">&lt;b&gt;透明度。&lt;/b&gt;可以使用基本工具直接分析数字表示形式的程度，例如使用纯文本编辑器的人类可读性。</target>
        </trans-unit>
        <trans-unit id="6a1fef7ef2345014e787011b548dc8376d0bc1e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Truncate file&lt;/b&gt; operations. SQLite may truncate existing files by invoking the xTruncate() method of the sqlite3_file object.</source>
          <target state="translated">&lt;b&gt;截断文件&lt;/b&gt;操作。SQLite可以通过调用sqlite3_file对象的xTruncate（）方法来截断现有文件。</target>
        </trans-unit>
        <trans-unit id="bb4145432e1ccc1ea44b70a3377b44f8258ea4c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;UNBOUNDED FOLLOWING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无限制跟随&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d68f4761ba65c695e8f710308c336949cdcf89a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;UNBOUNDED PRECEDING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无限制的先例&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6f890ba61b6934cda1714e413c59c0c5a42dc7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Ubuntu&lt;/b&gt;: Desktop built from Intel i7-4770K at 3.50GHz, 32GiB RAM, Ubuntu 16.04.2 LTS</source>
          <target state="translated">&lt;b&gt;Ubuntu&lt;/b&gt;：由Intel i7-4770K在3.50GHz，32GiB RAM，Ubuntu 16.04.2 LTS构建的桌面</target>
        </trans-unit>
        <trans-unit id="8085a5307e375e1a3cc4d8ecb812cae7fed22ef8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Uninitialized memory.&lt;/b&gt; The instrumented memory allocator initializes each memory allocation to a nonsense bit pattern to help ensure that the user makes no assumptions about the content of allocation memory.</source>
          <target state="translated">&lt;b&gt;未初始化的内存。&lt;/b&gt;插入的内存分配器将每个内存分配初始化为一个无意义的位模式，以帮助确保用户不对分配内存的内容做任何假设。</target>
        </trans-unit>
        <trans-unit id="285cdeb23d66de73ae8f199e36bc1eda95c8d681" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update on 2018-05-31:&lt;/b&gt; Our goal of supporting SQLite long-term have apparently come to the notice of the preservationist at the &lt;a href=&quot;https://www.loc.gov&quot;&gt;US Library Of Congress&lt;/a&gt; who have identified SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for the preservation of digital content.</source>
          <target state="translated">&lt;b&gt;2018年5月31日更新：&lt;/b&gt;我们长期支持SQLite的目标显然已经引起&lt;a href=&quot;https://www.loc.gov&quot;&gt;美国国会图书馆&lt;/a&gt;的保护主义者的注意，他们已经将SQLite确定为&lt;a href=&quot;locrsf&quot;&gt;推荐&lt;/a&gt;的数字内容存储格式。</target>
        </trans-unit>
        <trans-unit id="3925f9c7cd97c1b3f5e29f1be80c33e589fe5fd4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update on 2018-05-39:&lt;/b&gt; Our goal of supporting SQLite long-term have apparently come to the notice of the preservationist at the &lt;a href=&quot;https://www.loc.gov&quot;&gt;US Library Of Congress&lt;/a&gt; who have identified SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for the preservation of digital content.</source>
          <target state="translated">&lt;b&gt;2018年5月39日更新：&lt;/b&gt;&lt;a href=&quot;https://www.loc.gov&quot;&gt;美国国会图书馆&lt;/a&gt;的保护主义者显然已经注意到我们长期支持SQLite的目标，他们已将SQLite确定为&lt;a href=&quot;locrsf&quot;&gt;建议&lt;/a&gt;的数字内容存储格式。</target>
        </trans-unit>
        <trans-unit id="bd99662722847f47c9d95c77023462c53957fe12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update:&lt;/b&gt; As of SQLite version 3.7.0 (2010-07-21), all of SQLite memory allocation interfaces are considered stable and will be supported in future releases.</source>
          <target state="translated">&lt;b&gt;更新：&lt;/b&gt;从SQLite版本3.7.0（2010-07-21）开始，所有SQLite内存分配接口都被认为是稳定的，并且在将来的版本中将受支持。</target>
        </trans-unit>
        <trans-unit id="4a17f9a5725b7ea7266f7211279b754186bbd337" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions.&lt;/b&gt; SQLite normally assumes that terms in the WHERE clause that cannot be used by indexes have a strong probability of being true. If this assumption is incorrect, it could lead to a suboptimal query plan. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions can be used to provide hints to the query planner about WHERE clause terms that are probably not true, and thus aid the query planner in selecting the best possible plan.</source>
          <target state="translated">&lt;b&gt;使用&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不太可能（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;似然（）&lt;/a&gt; SQL函数。&lt;/b&gt;SQLite通常假定WHERE子句中的索引不能使用的术语很有可能为真。如果此假设不正确，则可能导致查询计划不理想。在&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不可能的（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;可能性（）&lt;/a&gt; SQL函数可用来提供线索约WHERE子句条件，也就是不正确的，从而帮助查询规划中选择最好的规划查询规划。</target>
        </trans-unit>
        <trans-unit id="eb5521088e750b2b0996ab4ac8d5d78ce99b3974" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use compile-time options to enable debugging features.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;使用编译时选项启用调试功能。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="624e8c505d78662928c531469f8c4839dcd31815" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use of memory after freeing.&lt;/b&gt; When each block of memory is freed, every byte is overwritten with a nonsense bit pattern. This helps to ensure that no memory is ever used after having been freed.</source>
          <target state="translated">&lt;b&gt;释放后使用内存。&lt;/b&gt;释放每个内存块后，每个字节都会被无意义的位模式覆盖。这有助于确保释放后不再使用任何内存。</target>
        </trans-unit>
        <trans-unit id="60df967df8dc96a687fd1c6e5298ea7d5de4825c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &quot;.eqp full&quot; option on the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;在&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;上使用&amp;ldquo; .eqp full&amp;rdquo;选项&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee77fa4780771a6f5280fc94a682c4c8900c4945" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; syntax to enforce the selection of particular indexes on problem queries.&lt;/b&gt; As with the previous two bullets, avoid this step if possible, and especially avoid doing this early in development as it is clearly a premature optimization.</source>
          <target state="translated">&lt;b&gt;使用&lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt;语法来强制选择问题查询中的特定索引。&lt;/b&gt;与前面的两个项目符号一样，请尽可能避免执行此步骤，尤其要避免在开发初期进行此操作，因为这显然是过早的优化。</target>
        </trans-unit>
        <trans-unit id="bba7254595e9a630fbbef9f9fef16a316097697a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &lt;a href=&quot;optoverview#crossjoin&quot;&gt;CROSS JOIN&lt;/a&gt; syntax to enforce a particular loop nesting order on queries that might use low-quality indexes in an unanalyzed database.&lt;/b&gt; SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;treats the CROSS JOIN operator specially&lt;/a&gt;, forcing the table to the left to be an outer loop relative to the table on the right.</source>
          <target state="translated">&lt;b&gt;使用&lt;a href=&quot;optoverview#crossjoin&quot;&gt;CROSS JOIN&lt;/a&gt;语法对可能在未分析的数据库中使用低质量索引的查询强制执行特定的循环嵌套顺序。&lt;/b&gt;SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;特别对待CROSS JOIN运算符&lt;/a&gt;，将左侧的表强制为相对于右侧的表的外循环。</target>
        </trans-unit>
        <trans-unit id="fa98b891b98a769270b4431b060723a6be69cc3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use unary &quot;+&quot; operators to disqualify WHERE clause terms.&lt;/b&gt; If the query planner insists on selecting a poor-quality index for a particular query when a much higher-quality index is available, then &lt;a href=&quot;optoverview#uplus&quot;&gt;careful use of unary &quot;+&quot; operators&lt;/a&gt; in the WHERE clause can force the query planner away from the poor-quality index. Avoid using this trick if at all possible, and especially avoid it early in the application development cycle. Beware that adding a unary &quot;+&quot; operator to an equality expression might change the result of that expression if &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is involved.</source>
          <target state="translated">&lt;b&gt;使用一元&amp;ldquo; +&amp;rdquo;运算符取消WHERE子句条款的资格。&lt;/b&gt;如果查询计划者在质量更高的索引可用时坚持为特定查询选择劣质索引，则在WHERE子句中&lt;a href=&quot;optoverview#uplus&quot;&gt;谨慎使用一元&amp;ldquo; +&amp;rdquo;运算符&lt;/a&gt;可迫使查询计划者摆脱劣质指数。尽可能避免使用此技巧，尤其是在应用程序开发周期的早期避免使用此技巧。请注意，如果涉及&lt;a href=&quot;datatype3#affinity&quot;&gt;类型相似性，&lt;/a&gt;则在相等表达式中添加一元&amp;ldquo; +&amp;rdquo;运算符可能会更改该表达式的结果。</target>
        </trans-unit>
        <trans-unit id="cca9bf8bd8b6e185263dc550b7207fcabdfc778b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Using the &quot;.breakpoint&quot; shell command&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;使用&amp;ldquo; .breakpoint&amp;rdquo; shell命令&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="185e070273e5254ad642967181d8c3d2a28284dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Using the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; shell commands&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;使用&amp;ldquo; .selecttrace&amp;rdquo;和&amp;ldquo; .wheretrace&amp;rdquo; shell命令&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f9397605fb07688bb69ea9f7536e70930b36524" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Variable-length records&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;可变长度记录&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5a6e556c10ec550463c045d14c122976ce8b5d00" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Very large datasets&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;大型数据集&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97000c025a0125f099ec23dce5e3ca08c6acd95e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Very large write transactions.&lt;/b&gt; A checkpoint can only complete when no other transactions are running, which means the WAL file cannot be reset in the middle of a write transaction. So a large change to a large database might result in a large WAL file. The WAL file will be checkpointed once the write transaction completes (assuming there are no other readers blocking it) but in the meantime, the file can grow very big.</source>
          <target state="translated">&lt;b&gt;非常大的写入事务。&lt;/b&gt;仅当没有其他事务在运行时，检查点才能完成，这意味着WAL文件无法在写事务中间重置。因此，对大型数据库进行的较大更改可能会导致产生较大的WAL文件。一旦写入事务完成（假设没有其他读者阻止它），WAL文件将被检查点，但是与此同时，该文件可能会变得很大。</target>
        </trans-unit>
        <trans-unit id="7d515fde87203051ec78c69e20ed524f4de5793a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_CKPT_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_CKPT_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad6d56d4428a77145ca6242e596a7fa2c1803531" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_READ_LOCK(N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_READ_LOCK(N)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5d110f0b82f62dd2f5a0794e764ea8169257175" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_RECOVER_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_RECOVER_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f158b1754a80661dff694e137aecc3b2f6efb345" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_WRITE_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_WRITE_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="888483948ca68cc0b0af34e4a9b2b453974882ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; Misuse of this pragma can result in &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;database corruption&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;滥用该编译指示可能会导致&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;数据库损坏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0030ed0fd53893377f5547815043278fa13ee8c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The data returned by the EXPLAIN QUERY PLAN command is intended for interactive debugging only. The output format may change between SQLite releases. Applications should not depend on the output format of the EXPLAIN QUERY PLAN command.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt; EXPLAIN QUERY PLAN命令返回的数据仅用于交互式调试。在SQLite版本之间，输出格式可能会有所不同。应用程序不应依赖于EXPLAIN QUERY PLAN命令的输出格式。</target>
        </trans-unit>
        <trans-unit id="3df3036875341edb9f8fc3a8acb1f8bcea071d37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的对象是&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象。在多线程环境中，未受保护的sqlite3_value对象只能与&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;安全使用。如果&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象以任何其他方式使用，包括调用诸如&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes（）之&lt;/a&gt;类的例程，则该行为不是线程安全的。因此，sqlite3_column_value（）接口通常仅在以下实现中有用&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;，不在顶级应用程序代码内。</target>
        </trans-unit>
        <trans-unit id="0e64773b994422fdf54e1035001ec5e582ab69ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的对象是&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象。在多线程环境中，未受保护的sqlite3_value对象只能与&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;安全使用。如果&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象以任何其他方式使用，包括调用诸如&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes（）之&lt;/a&gt;类的例程，则该行为不是线程安全的。因此，sqlite3_column_value（）接口通常仅在以下实现中有用&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;，不在顶级应用程序代码内。</target>
        </trans-unit>
        <trans-unit id="3d8f3551ffb881577fe6fa2ff6b699dbc1110b90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的对象是&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象。在多线程环境中，未受保护的sqlite3_value对象只能与&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;安全使用。如果&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象以任何其他方式使用，包括调用诸如&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int（）&lt;/a&gt;，&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;或&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes（）之&lt;/a&gt;类的例程，则该行为不是线程安全的。因此，sqlite3_column_value（）接口通常仅在以下实现中有用&lt;a href=&quot;../appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;，不在顶级应用程序代码内。</target>
        </trans-unit>
        <trans-unit id="e113677f8631906939d48925646a6301748cade3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的对象是&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象。在多线程环境中，未受保护的sqlite3_value对象只能与&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;安全使用。如果&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象以任何其他方式使用，包括调用诸如&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int（）&lt;/a&gt;，&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;或&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes（）之&lt;/a&gt;类的例程，则该行为不是线程安全的。因此，sqlite3_column_value（）接口通常仅在以下实现中有用&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;，不在顶级应用程序代码内。</target>
        </trans-unit>
        <trans-unit id="c159c6aeb388ae4e30b7b7f4145c9b703dbe4dfe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; writing to the SQLITE_DBPAGE virtual table can very easily cause unrecoverably database corruption. Do not allow untrusted components to access the SQLITE_DBPAGE table. Use appropriate care while using the SQLITE_DBPAGE table. Back up important data prior to experimenting with the SQLITE_DBPAGE table. Writes to the SQLITE_DBPAGE virtual table are disabled when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;写入SQLITE_DBPAGE虚拟表很容易导致数据库无法恢复。不允许不受信任的组件访问SQLITE_DBPAGE表。使用SQLITE_DBPAGE表时要格外小心。在尝试使用SQLITE_DBPAGE表之前，请备份重要数据。设置&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;标志后，将禁止写入SQLITE_DBPAGE虚拟表。</target>
        </trans-unit>
        <trans-unit id="4f374c63735201c6cdaca2e4426827ae4ba2ca2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Website Database.&lt;/b&gt; Because it requires no configuration and stores information in ordinary disk files, SQLite is a popular choice as the database to back small to medium-sized websites.</source>
          <target state="translated">&lt;b&gt;网站数据库。&lt;/b&gt;因为不需要配置，并且将信息存储在普通磁盘文件中，所以SQLite作为支持中小型网站的数据库是一种流行的选择。</target>
        </trans-unit>
        <trans-unit id="5e075eb30727f1c365f2bc04efc0a16da3a863f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Websites&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Websites&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="da1e82610dd7e1bffc89ad32ea03dfb074479e2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Win10&lt;/b&gt;: A 2016 Lenovo YOGA 910, Intel i7-7500 at 2.70GHz, 16GiB RAM, Windows10.</source>
          <target state="translated">&lt;b&gt;Win10&lt;/b&gt;：2016年的Lenovo YOGA 910、2.70GHz的Intel i7-7500、16GiB RAM，Windows10。</target>
        </trans-unit>
        <trans-unit id="ea8bed047d5529263f89a6ee40214f46592fa94e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Win7&lt;/b&gt;: A circa-2009 Dell Inspiron laptop, Pentium dual-core at 2.30GHz, 4GiB RAM, Windows7.</source>
          <target state="translated">&lt;b&gt;Win7&lt;/b&gt;：2009年左右的Dell Inspiron笔记本电脑，奔腾双核2.30GHz，4GiB RAM，Windows7。</target>
        </trans-unit>
        <trans-unit id="e68611734bd3e7ab106c3521f7c655f4756a046c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Wrapped Pile-of-Files Formats.&lt;/b&gt; Some applications use a Pile-of-Files that is then encapsulated into some kind of single-file container, usually a ZIP archive. EPUB, ODT,and ODP are examples of this approach. An EPUB book is really just a ZIP archive that contains various XHTML files for the text of book chapters, GIF and JPEG images for the artwork, and a specialized catalog file that tells the eBook reader how all the XML and image files fit together. OpenOffice documents (ODT and ODP) are also ZIP archives containing XML and images that represent their content as well as &quot;catalog&quot; files that show the interrelationships between the component parts.</source>
          <target state="translated">&lt;b&gt;包装文件堆格式。&lt;/b&gt;某些应用程序使用文件堆，然后将文件堆封装到某种单文件容器中，通常是ZIP存档。 EPUB，ODT和ODP是这种方法的示例。 EPUB图书实际上只是一个ZIP存档，其中包含书籍章节文本的各种XHTML文件，艺术品的GIF和JPEG图像，以及专门的目录文件，该文件告诉eBook阅读器所有XML和图像文件如何组合在一起。 OpenOffice文档（ODT和ODP）也是ZIP归档文件，其中包含表示其内容的XML和图像以及&amp;ldquo;目录&amp;rdquo;文件，这些文件显示了组成部分之间的相互关系。</target>
        </trans-unit>
        <trans-unit id="e80e6ef180f77a11e4ad718760489bfd6c1d3980" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Write file&lt;/b&gt; operations. SQLite may modify the contents and increase the size of a file by files by invoking the xWrite() method of the sqlite3_file object.</source>
          <target state="translated">&lt;b&gt;写入文件&lt;/b&gt;操作。SQLite可以通过调用sqlite3_file对象的xWrite（）方法来修改文件的内容并按文件增加文件的大小。</target>
        </trans-unit>
        <trans-unit id="e93a8e5c6820d5cb61b30e7580636cac841de035" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Writer Starvation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;作家饥饿&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d5d06edcd682d757dc164e732a60c0964a20210" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;YYSTACKDEPTH=&lt;i&gt;&amp;lt;max_depth&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;YYSTACKDEPTH=&lt;i&gt;&amp;lt;max_depth&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ccba30872e5a56e0c69301bb6c07bd4a14eedd1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;YYTRACKMAXSTACKDEPTH&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;YYTRACKMAXSTACKDEPTH&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d9774ec4279042a099a60de1ddc091ef4d042e40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Zero-Configuration&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Zero-Configuration&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d787411914cc50b14089e0d3d1dd388e2edc91a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Zero-malloc option.&lt;/b&gt; The application can optionally provide SQLite with several buffers of bulk memory at startup and SQLite will then use those provided buffers for all of its memory allocation needs and never call system malloc() or free().</source>
          <target state="translated">&lt;b&gt;零malloc选项。&lt;/b&gt;应用程序可以选择在启动时为SQLite提供大容量内存的几个缓冲区，然后SQLite将使用提供的缓冲区满足其所有内存分配需求，并且从不调用系统malloc（）或free（）。</target>
        </trans-unit>
        <trans-unit id="8f2b743bcbe285635e0463a315a493eb37176373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;_HAVE_SQLITE_CONFIG_H&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;_HAVE_SQLITE_CONFIG_H&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="33dcc6c87c822c07ebff240814a228ff607b0b40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;abs(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;abs(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe5e3b0d396d614226a54388a7b4de0441733b51" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;alignment&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;alignment&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="194ffe7cb502ded114f889082435f2c16c8b7359" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;application_id = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;application_id = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5443e0f7d9f275c31c0eb7151cf4ea53927946d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;application_id; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;application_id; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e52171e1f2ed13a70f81dde9b3a852059c3f9848" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;assert(X)&lt;/b&gt; &amp;rarr; The assert(X) statement indicates that the condition X is always true. In other words, X is an invariant. The assert(X) macro works like a procedure in that it has no return value.</source>
          <target state="translated">&lt;b&gt;assert（X）&lt;/b&gt; &amp;rarr;assert（X）语句指示条件X始终为true。换句话说，X是不变量。assert（X）宏的作用类似于过程，因为它没有返回值。</target>
        </trans-unit>
        <trans-unit id="e1d034110b826070c391f6a1b3222b94a181199d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;auto_vacuum = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;auto_vacuum = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d7cd7347cc987aab65acd4c17d0fb4f855e08cf4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;auto_vacuum;&lt;br/&gt; PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;auto_vacuum; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d128f6edd956bb72b334d983e9c173584d32d33a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;avg(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;avg(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eb7b6c83e75fbe3b054ea415310a7352288778a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;backup_remaining() and backup_pagecount()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;backup_remaining（）和backup_pagecount（）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="af51318f30245050461c25ceed50b0039299603f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;busy&lt;/b&gt;: This field is true if the prepared statement is currently running. In other words, this field is true if &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called on the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; at least once but &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; has not yet been called to reset it.</source>
          <target state="translated">&lt;b&gt;busy&lt;/b&gt;：如果准备好的语句当前正在运行，则此字段为true。换句话说，如果该字段为真&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;已经呼吁&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的声明中&lt;/a&gt;至少一次，但&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;尚未被称为重置。</target>
        </trans-unit>
        <trans-unit id="c07a69ddd20e31f1d596560030beac75f1ec41f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache&lt;/b&gt;: The cache parameter may be set to either &quot;shared&quot; or &quot;private&quot;. Setting it to &quot;shared&quot; is equivalent to setting the SQLITE_OPEN_SHAREDCACHE bit in the flags argument passed to sqlite3_open_v2(). Setting the cache parameter to &quot;private&quot; is equivalent to setting the SQLITE_OPEN_PRIVATECACHE bit. If sqlite3_open_v2() is used and the &quot;cache&quot; parameter is present in a URI filename, its value overrides any behavior requested by setting SQLITE_OPEN_PRIVATECACHE or SQLITE_OPEN_SHAREDCACHE flag.</source>
          <target state="translated">&lt;b&gt;cache&lt;/b&gt;：cache参数可以设置为&amp;ldquo; shared&amp;rdquo;或&amp;ldquo; private&amp;rdquo;。将其设置为&amp;ldquo;共享&amp;rdquo;等效于将传递给sqlite3_open_v2（）的flags参数中的SQLITE_OPEN_SHAREDCACHE位置1。将缓存参数设置为&amp;ldquo;专用&amp;rdquo;等同于将SQLITE_OPEN_PRIVATECACHE位置1。如果使用sqlite3_open_v2（）且URI文件名中包含&amp;ldquo; cache&amp;rdquo;参数，则其值将覆盖通过设置SQLITE_OPEN_PRIVATECACHE或SQLITE_OPEN_SHAREDCACHE标志所请求的任何行为。</target>
        </trans-unit>
        <trans-unit id="048afc3980c205fecc84abbd48f15a61272e10f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache=shared&lt;br/&gt;cache=private&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache=shared&lt;br/&gt;cache=private&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f187cf2b0d507dcac54b947ef4b4bb4548adec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size = -&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size =-&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="66a05bfa29a1d5ad78648c64ef4a1bc402a7ef7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8be0f4e9732fbef28f44a865ce5359d4c63e5ba3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4d813d1d4f13504bccfdec67887288aeb2c74bf6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_spill=&lt;i&gt;N&lt;/i&gt;;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_spill=&lt;i&gt;N&lt;/i&gt;;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee76635f943345e36eadd20f93c4b84d756cd424" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;changes()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;changes()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6e34c8fad0c61810b664b1fb208a7e152cbd2d8f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;char(&lt;i&gt;X1&lt;/i&gt;,&lt;i&gt;X2&lt;/i&gt;,...,&lt;i&gt;XN&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;char(&lt;i&gt;X1&lt;/i&gt;,&lt;i&gt;X2&lt;/i&gt;,...,&lt;i&gt;XN&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9abb03962a5dc4852aff5e36c48f45d6a4a3d77a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;close&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;close&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2d6e4e63ef7fd21c4175c425685a7ddb1ca2bea1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;coalesce(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;coalesce(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="35bbbb1bb66c64e00f2934f51b73b8e4f4056495" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;columns=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22b498af88a752c45b7e25f4181284d3db7afb1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;command&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;command&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad084040fb5ea49d3658d7989127f682b7f28c67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;count(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;count(*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;count(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;count(*)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39af06e9905a7448ee0b1defae9d454b6841f4d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cov.rc&lt;/b&gt; - Options for measuring test coverage</source>
          <target state="translated">&lt;b&gt;cov.rc-&lt;/b&gt;测量测试覆盖率的选项</target>
        </trans-unit>
        <trans-unit id="5cca5b66dc12bd7e7becb822abbebae01386bdb2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cume_dist()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cume_dist()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bce3e62d8a1b34b91114cf92fb902035b214587" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;data=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3783e6f7dc101319ad924bc9f09ae132e7c7f898" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data_version;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;data_version;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="389b2f8f724900f956d877a644e2e9603c0f26c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;date(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;date(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cbcb55ef3726cc2a71910590d0902f7faab4f9ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;datetime(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;datetime(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4a93f792625c9fb9a23c44fc7b35b053170939d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;db&lt;/b&gt; &amp;rarr; The 1st parameter is always a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; on which the custom SQL function will work. Custom SQL functions are created separately for each database connection. There is no short-hand mechanism for creating SQL functions that work across all database connections.</source>
          <target state="translated">&lt;b&gt;db&lt;/b&gt; &amp;rarr;第一个参数始终是指向自定义SQL函数将在其上运行的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。为每个数据库连接分别创建自定义SQL函数。没有创建可在所有数据库连接中使用的SQL函数的简便机制。</target>
        </trans-unit>
        <trans-unit id="aee590495d14ff2cf1c5cbc37042295e0d1f08cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;default_cache_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;default_cache_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="402ca1dacea0721ad239c1af6cb3f5819295774e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;default_cache_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;default_cache_size; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6313bf298d297088101bbaddb662c2c916679adf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;dense_rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;dense_rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2aac9f3db608b20d11947a5ae9700ebd62f45001" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;distance&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;distance&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="df0bd6212efcf47dc19d5092c1a16c3c5d5c1022" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;eTextRep&lt;/b&gt; &amp;rarr; The 4th parameter is a 32-bit integer flag whose bits convey various properties about the new function. The original purpose of this parameter was to specify the preferred text encoding for the function, using one of the following constants:</source>
          <target state="translated">&lt;b&gt;eTextRep&lt;/b&gt; &amp;rarr;第四个参数是一个32位整数标志，其位传达有关新功能的各种属性。该参数的原始目的是使用以下常量之一为函数指定首选的文本编码：</target>
        </trans-unit>
        <trans-unit id="b484c204986ea3c75fae52cefde5798b5dd4e4f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;editdist3(P,W)&lt;br/&gt;editdist3(P,W,L)&lt;br/&gt;editdist3(T)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;editdist3(P,W)&lt;br/&gt;editdist3(P,W,L)&lt;br/&gt;editdist3(T)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="70f1ae63992807b1cef27255763402cd1c0c70d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;extensions.rc&lt;/b&gt; - Options to enable &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;, and &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;STAT4&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;extensions.rc-&lt;/b&gt;启用&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;，&lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;和&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;STAT4的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dd31bb22c519a3244a9371c90073d27eba9fcff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;fast.rc&lt;/b&gt; - Run most tests, including those not needed for coverage, skipping only soak tests, using delivery compiler options (ex: -O3)</source>
          <target state="translated">&lt;b&gt;fast.rc-&lt;/b&gt;使用交付编译器选项（例如：-O3）运行大多数测试，包括不需要的测试，仅跳过浸泡测试</target>
        </trans-unit>
        <trans-unit id="7047224cc767c22276bcd97b8b93c32d6c6dd0c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;filename=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;filename=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d86f5b252ea2c3905e9317b675f86261fe647565" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;first_value(expr)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;first_value(expr)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f6c983beee928db863455a33eaeb9e6e8731e6e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;foreign_key_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;foreign_key_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="98b8402ef4aa6df707621ab3e1424480dcd1b470" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;foreign_key_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;foreign_key_check; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e17b9027ffda510fd8200ef5dd02defe76fb361b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;freelist_count;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;freelist_count;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="49c799144ac6e15128ed0f9aa7ec635a662a3d31" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;glob(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;glob(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d51045bdeca73ea8688c5521c40c4f76212598ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;group_concat(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;group_concat(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;group_concat(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;group_concat(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cbaa7085724de96292b616e3361c44f3e9990d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;header&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;header&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffde63e4ba8d63cb5d1bc14f06bfecda9f5dd8b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;header=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;header=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1cfef432e2caab9415a288e0d7ba9d174b173a01" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;hex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;hex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd48f9963329d57278b189812b34811095c6cdeb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;id&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;id&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c5a7a75e65828537df32db2f1ac3e8fbbb008fae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ifnull(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ifnull(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="59e394b44a6744677d3a72d0eb34c77ce86693ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;iif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;iif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cce521b193beb15f59295fefb696fd4ade983bb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable&lt;/b&gt;: The immutable parameter is a boolean query parameter that indicates that the database file is stored on read-only media. When immutable is set, SQLite assumes that the database file cannot be changed, even by a process with higher privilege, and so the database is opened read-only and all locking and change detection is disabled. Caution: Setting the immutable property on a database file that does in fact change can result in incorrect query results and/or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors. See also: &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;immutable&lt;/b&gt;：immutable参数是一个布尔查询参数，它指示数据库文件存储在只读介质上。设置不可变后，SQLite假定即使具有更高特权的进程也无法更改数据库文件，因此该数据库以只读方式打开，并且所有锁定和更改检测均被禁用。注意：在实际上发生更改的数据库文件上设置不可变属性可能会导致错误的查询结果和/或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;错误。另请参阅：&lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cf141062b07419b584f4c1883f6a203a2df6601" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable&lt;/b&gt;: The immutable parameter is a boolean query parameter that indicates that the database file is stored on read-only media. When immutable is set, SQLite assumes that the database file cannot be changed, even by a process with higher privilege, and so the database is opened read-only and all locking and change detection is disabled. Caution: Setting the immutable property on a database file that does in fact change can result in incorrect query results and/or &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors. See also: &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;immutable&lt;/b&gt;：immutable参数是一个布尔查询参数，它指示数据库文件存储在只读介质上。设置不可变后，SQLite假定即使具有更高特权的进程也无法更改数据库文件，因此该数据库以只读方式打开，并且所有锁定和更改检测均被禁用。注意：在实际上发生更改的数据库文件上设置不可变属性可能会导致错误的查询结果和/或&lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;错误。另请参阅：&lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed08b6b1d1f0a664ae0f81d71d8d7810b3165b6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;immutable=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cccabe1bc4519474ead8892d0cd69c8b0775ed4b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;incremental_vacuum;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;incremental_vacuum;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b5baf91e220e87719852feaa7184a098f41965b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;incremental_vacuum&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;incremental_vacuum&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f16d799bd7829150ce3e6604138fbebab20b5419" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_info(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_info(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7688cc1ff573d2bca1de629a8d2a79e927035298" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_list(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_list(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2dfeb29a44b8e71355e11dbd4cf0aebfdd351c06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_xinfo(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_xinfo(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="207535d3995e19d40dc08d055ca415f8028e650a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;instr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;instr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac72f17cc719eb38ab9ab57e1ac893c356c119eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnCount)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xColumnCount）（Fts5Context *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9750e0f760da519d8715d51c87874648a8fe67e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xColumnSize）（Fts5Context *，int iCol，int * pnToken）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d42b31da68a1e7f9ae5eecbab61aee9b43cb6b1b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xColumnText）（Fts5Context *，int iCol，const char ** pz，int * pn）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a7ce4bfbb6d268c0d1ef8670fc34f7a4b65bb387" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xColumnTotalSize）（Fts5Context *，int iCol，sqlite3_int64 * pnToken）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3190bda489a99715fd738757d80223d99cccdbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xInst）（Fts5Context *，int iIdx，int * piPhrase，int * piCol，int * piOff）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="892559d9568a1d87d97b14bc61079a34debf6b83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xInstCount)(Fts5Context*, int *pnInst)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xInstCount）（Fts5Context *，int * pnInst）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="100e77957aba25dbbb31de82532ca7bf291eb970" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseCount)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xPhraseCount）（Fts5Context *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fcdaa92e2b0fc49b2bf5da218bbca933cf5c296" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xPhraseFirst）（Fts5Context *，int iPhrase，Fts5PhraseIter *，int *，int *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="031f3306d8acf8f83f8963454a0457de1feea424" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xPhraseFirstColumn）（Fts5Context *，int iPhrase，Fts5PhraseIter *，int *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d49467cfac66b79b5909b3a249dfaa9d04d187b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseSize)(Fts5Context*, int iPhrase)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xPhraseSize）（Fts5Context *，int iPhrase）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e27ad327723310374823171bdbac767d224d4747" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData, int(*)(const Fts5ExtensionApi*,Fts5Context*,void*) )&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xQueryPhrase）（Fts5Context *，int iPhrase，void * pUserData，int（*）（const Fts5ExtensionApi *，Fts5Context *，void *）））&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8af65e8dd1bd43dd26a39f7927ec9a0e3fc20406" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xRowCount）（Fts5Context *，sqlite3_int64 * pnRow）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="028bae0525e377b198a0579de0698834b402ef0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*))&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xSetAuxdata）（Fts5Context *，void * pAux，void（* xDelete）（void *））&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96b299d4b01b17194f0bfab31185570b2a5b0e26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xTokenize)(Fts5Context*, const char *pText, int nText, void *pCtx, int (*xToken)(void*, int, const char*, int, int, int) )&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xTokenize）（Fts5Context *，const char * pText，int nText，void * pCtx，int（* xToken）（void *，int，const char *，int，int，int）））&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="71f951b67bdae3181e28bc99fbd1081f3db56229" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;integrity_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;integrity_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5f61e2b4f6af6827071e26ba0468c59f77f7382d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;integrity_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;完整性检查; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8dbcbd2f1b02531496228f6526096af9fa315739" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_mode = &lt;i&gt;DELETE | TRUNCATE | PERSIST | MEMORY | WAL | OFF&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_mode = &lt;i&gt;删除| 截断 持久性| 内存| 沃尔| 关&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f421c8ecbe88c2e594c771b7201c65eb77fcce60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_mode; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_mode; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="33e1050ba5c76fd251b389021a94f193300849d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_size_limit = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_size_limit = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6038a087fec5ff7e87d3be2a0c692b4c7d54bf7c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_size_limit&lt;br/&gt; PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_size_limit &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="27b030b978b02cc9207038086c7f2c60253ad04d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;julianday(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;julianday(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c43da3ded817719eb56f1590ebd527ae35875002" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;k1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;k1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d8481cc752e77e81f239fb8d49320bf2fa634efc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;k2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;k2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ede80f5c49ab1747c7f023b90de4537abacf288" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lag(expr)&lt;br/&gt;lag(expr, offset)&lt;br/&gt;lag(expr, offset, default)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;lag（expr）&lt;br/&gt;lag（expr，offset）&lt;br/&gt;滞后（expr，offset，default）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d9ce10c584a3ee6d960754c6357d4f20cf2de71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;langid&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;langid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f306288a791aefbb510d07825cdcbd178d873e42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;last_insert_rowid()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;last_insert_rowid()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cca2232f164d7c66d07ad3c034e6f4b6dda69dbd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;last_value(expr)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;last_value(expr)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="81ed8362f530c16dff1f7d9cc5b282b98b462fc2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lead(expr)&lt;br/&gt;lead(expr, offset)&lt;br/&gt;lead(expr, offset, default)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;lead（expr）&lt;br/&gt;lead（expr，偏移量）&lt;br/&gt;lead（expr，偏移量，默认值）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="43d2123909b0f5a819af3db1c1e94d06a3f8779f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;length(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;length(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dfc5b8f00ea873518dc12f8893f25bbc6c66ce67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;br/&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;br/&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07c7c73b4b3991211d36821e85de44d186de4969" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;likelihood(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;likelihood(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="811594ce0b6e61d3b980bd09f4d1c39bf30bbb95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;likely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;likely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cdbe6610ca98a28c81ac1d281754e9a5e02f6a4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;load_extension(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;load_extension(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;load_extension(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;load_extension(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9df7ac0e0e06da4f24921e24ffa4a99e384f1953" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locking_mode = &lt;i&gt;NORMAL | EXCLUSIVE&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;锁定模式=正常&lt;i&gt;| 独家&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dbd9cb7c00973c9cf4c02835fba7d46c4cd155b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locking_mode; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;锁定模式; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d97f3f643b48dea573d334c35e46808c117b3e16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lower(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;lower(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99d4e148947298901a28af9618a2edc72556c7ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ltrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;ltrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ltrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;ltrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="50ee49b847d1bd0b4c011677c606dfe46418f9b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;matchlen&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;matchlen&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="84700aab85d80dd19448c1aadba1ce06d6cac5e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dc1c91322cff028b6d2a6ae101916dba85e55305" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="86c668cbb57e22aa0c108185ae17175562403e88" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max_page_count = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max_page_count = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cca5fba8273357af3d23375f683db4ab915088e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max_page_count; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max_page_count; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46970ade90f97e0fcf3e0dcfc00dfcc8abf51125" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mem&lt;/b&gt;: This field is the number of bytes of heap storage used by the prepared statement. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;mem&lt;/b&gt;：此字段是prepared语句使用的堆存储的字节数。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="2323e80eea828e053d28f31a4b3c98243b0559a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;memdebug.rc&lt;/b&gt; - like test.rc but also enable &lt;a href=&quot;compile#memdebug&quot;&gt;-DSQLITE_MEMDEBUG&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;memdebug.rc&lt;/b&gt; -像test.rc也使&lt;a href=&quot;compile#memdebug&quot;&gt;-DSQLITE_MEMDEBUG&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2385b3a406fa9ea94dd4092a1e7ffc158d26ec6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fb8829a5160360e2352f3a4c213691d03f9ba3f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d8df04651e720bd40286ee83b4d6e48760a9ee7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min.rc&lt;/b&gt; - Run the minimum set of tests needed for 100% coverage.</source>
          <target state="translated">&lt;b&gt;min.rc-&lt;/b&gt;运行100％覆盖率所需的最小测试集。</target>
        </trans-unit>
        <trans-unit id="9b5e7d659f4cfe7edf20e886f624adf61dcf6fe6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mmap_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mmap_size; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2d0eb11df5451ce3b5760e53da3fa40b8b4daa6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mmap_size=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mmap_size=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ab2f639309419d347aca23f719e0b621afb92015" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode&lt;/b&gt;: The mode parameter may be set to either &quot;ro&quot;, &quot;rw&quot;, &quot;rwc&quot;, or &quot;memory&quot;. Attempting to set it to any other value is an error. If &quot;ro&quot; is specified, then the database is opened for read-only access, just as if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; flag had been set in the third argument to sqlite3_open_v2(). If the mode option is set to &quot;rw&quot;, then the database is opened for read-write (but not create) access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had been set. Value &quot;rwc&quot; is equivalent to setting both SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE. If the mode option is set to &quot;memory&quot; then a pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; that never reads or writes from disk is used. It is an error to specify a value for the mode parameter that is less restrictive than that specified by the flags passed in the third parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;mode&lt;/b&gt;：模式参数可以设置为&amp;ldquo; ro&amp;rdquo;，&amp;ldquo; rw&amp;rdquo;，&amp;ldquo; rwc&amp;rdquo;或&amp;ldquo; memory&amp;rdquo;。尝试将其设置为任何其他值是一个错误。如果指定&amp;ldquo; ro&amp;rdquo;，则打开数据库以进行只读访问，就像在sqlite3_open_v2（）的第三个参数中设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;标志一样。如果将模式选项设置为&amp;ldquo; rw&amp;rdquo;，则将打开数据库以进行读写（但不创建）访问，就好像已设置了SQLITE_OPEN_READWRITE（但未设置SQLITE_OPEN_CREATE）一样。值&amp;ldquo; rwc&amp;rdquo;等效于设置SQLITE_OPEN_READWRITE和SQLITE_OPEN_CREATE。如果将模式选项设置为&amp;ldquo;内存&amp;rdquo;，则为纯&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;从不读取或写入磁盘。为mode参数指定的值限制比第三个参数传递给sqlite3_open_v2（）的标志所指定的限制要小，这是错误的。</target>
        </trans-unit>
        <trans-unit id="09e6b105c2bf735792ce11591cbf9c2f8556c47d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode&lt;/b&gt;: The mode parameter may be set to either &quot;ro&quot;, &quot;rw&quot;, &quot;rwc&quot;, or &quot;memory&quot;. Attempting to set it to any other value is an error. If &quot;ro&quot; is specified, then the database is opened for read-only access, just as if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; flag had been set in the third argument to sqlite3_open_v2(). If the mode option is set to &quot;rw&quot;, then the database is opened for read-write (but not create) access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had been set. Value &quot;rwc&quot; is equivalent to setting both SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE. If the mode option is set to &quot;memory&quot; then a pure &lt;a href=&quot;../inmemorydb&quot;&gt;in-memory database&lt;/a&gt; that never reads or writes from disk is used. It is an error to specify a value for the mode parameter that is less restrictive than that specified by the flags passed in the third parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;mode&lt;/b&gt;：模式参数可以设置为&amp;ldquo; ro&amp;rdquo;，&amp;ldquo; rw&amp;rdquo;，&amp;ldquo; rwc&amp;rdquo;或&amp;ldquo; memory&amp;rdquo;。尝试将其设置为任何其他值是一个错误。如果指定&amp;ldquo; ro&amp;rdquo;，则打开数据库以进行只读访问，就像在sqlite3_open_v2（）的第三个参数中设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;标志一样。如果将模式选项设置为&amp;ldquo; rw&amp;rdquo;，则将打开数据库以进行读写（但不创建）访问，就好像已设置了SQLITE_OPEN_READWRITE（但未设置SQLITE_OPEN_CREATE）一样。值&amp;ldquo; rwc&amp;rdquo;等效于设置SQLITE_OPEN_READWRITE和SQLITE_OPEN_CREATE。如果将模式选项设置为&amp;ldquo;内存&amp;rdquo;，则为纯&lt;a href=&quot;../inmemorydb&quot;&gt;内存数据库&lt;/a&gt;从不读取或写入磁盘。为mode参数指定的值限制比第三个参数传递给sqlite3_open_v2（）的标志所指定的限制要小，这是错误的。</target>
        </trans-unit>
        <trans-unit id="c3e378c447b57b9647ef1790cbe9e8e0fd004c14" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode=ro&lt;br/&gt;mode=rw&lt;br/&gt;mode=rwc&lt;br/&gt;mode=memory&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mode=ro&lt;br/&gt;mode=rw&lt;br/&gt;mode=rwc&lt;br/&gt;mode=memory&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3bd7aa3ba452f8a404691484d3d1e2ea817d6231" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;modeof=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;modeof=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0de520c57a9efb57d19a0ca4a2583d52e49cfe8b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nArg&lt;/b&gt; &amp;rarr; The 3rd parameter is always the number of arguments that the function accepts. The value must be an integer between -1 and &lt;a href=&quot;limits#max_function_arg&quot;&gt;SQLITE_MAX_FUNCTION_ARG&lt;/a&gt; (default value: 127). A value of -1 means that the SQL function is a variadic function that can take any number of arguments between 0 and &lt;a href=&quot;limits#max_function_arg&quot;&gt;SQLITE_MAX_FUNCTION_ARG&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;nArg&lt;/b&gt; &amp;rarr;第3个参数始终是函数接受的参数数量。该值必须是介于-1和&lt;a href=&quot;limits#max_function_arg&quot;&gt;SQLITE_MAX_FUNCTION_ARG&lt;/a&gt;之间的整数（默认值：127）。值-1表示SQL函数是可变参数函数，可以接受0到&lt;a href=&quot;limits#max_function_arg&quot;&gt;SQLITE_MAX_FUNCTION_ARG&lt;/a&gt;之间的任意数量的参数。</target>
        </trans-unit>
        <trans-unit id="b94737558aa8e30aba81834f353e695e866e2607" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;naidx&lt;/b&gt;: This field is the number of rows that have been inserted into &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt;. A positive value in this field may indicate an opportunity to improve performance by adding a named index that take the place of the automatic index. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusautoindex&quot;&gt;SQLITE_STMTSTATUS_AUTOINDEX&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;naidx&lt;/b&gt;：此字段是已插入&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引中&lt;/a&gt;的行数。该字段中的正值可能表示有机会通过添加代替自动索引的命名索引来提高性能。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusautoindex&quot;&gt;SQLITE_STMTSTATUS_AUTOINDEX&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="5979a30183c99ffb81b7688cf4ba09f3b0adaca6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;name&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3d9da8f4524a8ed3ef4685d71af9262174a2c9c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt; &amp;rarr; The name of the table or index</source>
          <target state="translated">&lt;b&gt;名称&lt;/b&gt;&amp;rarr;表或索引的名称</target>
        </trans-unit>
        <trans-unit id="1dca50e56e569f3a137f02613f8e101412a6fd0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ncol&lt;/b&gt;: The number of columns in the result set of a query. For DML statements, this column has a value of 0.</source>
          <target state="translated">&lt;b&gt;ncol&lt;/b&gt;：查询结果集中的列数。对于DML语句，此列的值为0。</target>
        </trans-unit>
        <trans-unit id="9266cf0d1aa52a6c88fc7a9ce528569eaf218e98" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nolock&lt;/b&gt;: The nolock parameter is a boolean query parameter which if set disables file locking in rollback journal modes. This is useful for accessing a database on a filesystem that does not support locking. Caution: Database corruption might result if two or more processes write to the same database and any one of those processes uses nolock=1.</source>
          <target state="translated">&lt;b&gt;nolock&lt;/b&gt;：nolock参数是一个布尔查询参数，如果设置该参数将禁用回滚日志模式下的文件锁定。这对于访问不支持锁定的文件系统上的数据库很有用。警告：如果两个或多个进程写入同一数据库，并且其中任何一个进程使用nolock = 1，则可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="92049c4fa68e8dcb2a9ce5d1c47395f719ee2e59" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nolock=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nolock=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0821cde6d9d92bcfa8f51b791e202fe561c692f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;now&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;now&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c962d8bc64dcb99d96b34edfd80eef77b82d8960" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nscan&lt;/b&gt;: This field is the number of times that the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; has stepped through a table as part of a full-table scan. A large number if this field may indicate an opportunity to improve performance by adding an index. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nscan&lt;/b&gt;：此字段是&lt;a href=&quot;opcode&quot;&gt;字节码引擎&lt;/a&gt;作为全表扫描的一部分逐步通过表的次数。如果此字段可能表示通过添加索引来提高性能的机会，则为大量。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="793a688ba89916bc91e2948fcbbff88d939d50df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nsort&lt;/b&gt;: This field is the number of times that the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; had to sort. A positive value in this field may indicate an opportunity to improve performance by adding an index that will cause the query results to appear naturally in the desired order. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nsort&lt;/b&gt;：此字段是&lt;a href=&quot;opcode&quot;&gt;字节码引擎&lt;/a&gt;必须排序的次数。此字段中的正值可能表示有机会通过添加索引来提高性能，该索引将导致查询结果以所需顺序自然出现。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="bfe71888a18b09526c41d1b94956d1609d2df2a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nstep&lt;/b&gt;: This field is the number of &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; operations that have been performed for the prepared statement. This field can be used as a proxy for how much CPU time a statement has used. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusvmstep&quot;&gt;SQLITE_STMTSTATUS_VM_STEP&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nstep&lt;/b&gt;：此字段是为准备好的语句执行的&lt;a href=&quot;opcode&quot;&gt;字节码引擎&lt;/a&gt;操作的数量。该字段可以用作语句已使用多少CPU时间的代理。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusvmstep&quot;&gt;SQLITE_STMTSTATUS_VM_STEP&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="63815c843d590daa0dcf061c4721a9d5d4a2d517" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nth_value(expr, N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nth_value（expr，N）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d0c888098e8713ffd7470fb70089d0baee7e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ntile(N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ntile(N)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05286bde0bd001f85739e8fbad5157036721e2a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nullif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nullif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f17b6c64c0b9735971a6da68a406bd0f2a3e839" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;pApp&lt;/b&gt; &amp;rarr; The 5th parameter is an arbitrary pointer that is passed through into the callback routines. SQLite itself does nothing with this pointer, except to make it available to the callbacks, and to pass it into the destructor when the function is unregistered.</source>
          <target state="translated">&lt;b&gt;pApp&lt;/b&gt; &amp;rarr;第5个参数是传递给回调例程的任意指针。SQLite本身对此指针不执行任何操作，除了使它可用于回调，并在未注册函数时将其传递给析构函数。</target>
        </trans-unit>
        <trans-unit id="b025946bb0710a483f2eb1f6bb0f6acf583de102" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_count;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;page_count;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0acb36fa4cfdbd1af777924754ed8b90f92f80e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;page_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a41e038bc3ab6f9cb7c6c880a15dd5da22bca16a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;页面大小; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0f8fb606ccbf864fa90cbb5ee1a6f32cf556579f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;percent_rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;percent_rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7925229e75f9a5ddc4c6bcf1fce67735fed59f14" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;phonehash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;phonehash&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5499744b67dcd6206fb619427cb287b68fddad94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;printf(&lt;i&gt;FORMAT&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;printf(&lt;i&gt;FORMAT&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="173bb75d2eff480770bb8e83d250aaf82ef0042e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;profile&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;profile&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ab4d8dffa722a511d73e114b16c08dc6a537cb6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow&lt;/b&gt;: The psow parameter indicates whether or not the &lt;a href=&quot;../psow&quot;&gt;powersafe overwrite&lt;/a&gt; property does or does not apply to the storage media on which the database file resides.</source>
          <target state="translated">&lt;b&gt;psow&lt;/b&gt;：psow参数指示&lt;a href=&quot;../psow&quot;&gt;powersafe overwrite&lt;/a&gt;属性是否适用于数据库文件所在的存储介质。</target>
        </trans-unit>
        <trans-unit id="18dbe2a36203a00ce25e37c7598791b053afe0f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow&lt;/b&gt;: The psow parameter indicates whether or not the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property does or does not apply to the storage media on which the database file resides.</source>
          <target state="translated">&lt;b&gt;psow&lt;/b&gt;：psow参数指示&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;属性是否适用于数据库文件所在的存储介质。</target>
        </trans-unit>
        <trans-unit id="19672e769c27252099c41616a5a8161a4d6518d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow=0&lt;br/&gt;psow=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;psow=0&lt;br/&gt;psow=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2f260f1801a8e818b6ff06e8303be11d7451a10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick.rc&lt;/b&gt; - Run all tests required for 100% coverage tests using -Os and &lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;quick.rc-&lt;/b&gt;使用-Os和&lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt;运行100％覆盖率测试所需的所有测试。</target>
        </trans-unit>
        <trans-unit id="3fd4aa79ddd410cd9139a41d386311916ebe9d17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;quick_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="994a2c2443ac0da9003e00fe190aaa31db2160a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;快速检查; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b14e2eb2027ccd9a5fae3e53bbc6e949cbc94b70" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quote(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;quote(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="340804ccd9900156a5ee658749fc30933ec1cc6d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;random()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;random()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e582c145eb46045893175b9cad76026024fcc73" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;randomblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;randomblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d52d0687653f788c9a1d0b62c1ec148950ea4eb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c0dddfe101189ad9de03f6a2247d0074815decf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rank&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rank&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5642fd86cd16372a166c437b2acd799966efa693" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;replace(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;replace(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1387ead5a7eaf9239d995873793737440d057fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;reprep&lt;/b&gt;: This field is the number of times that the statement has had to be reprepared due to schema changes or changes to parameter bindings. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;reprep&lt;/b&gt;：此字段是由于架构更改或参数绑定更改而必须重新准备语句的次数。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="13892832e8f338f883dc9f1b67835b33d26f9407" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ro&lt;/b&gt;: The &quot;read only&quot; column. This column is true (non-zero) if the SQL statement is a query and false (zero) if it is a DML statement.</source>
          <target state="translated">&lt;b&gt;ro&lt;/b&gt;：&amp;ldquo;只读&amp;rdquo;列。如果SQL语句是查询，则此列为true（非零），如果是DML语句，则为false（零）。</target>
        </trans-unit>
        <trans-unit id="f3fdaa525b6f68779fd0aba1118212a2053d8c74" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rootpage&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rootpage&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="578448d770f3d2a1b5a91906bea2c63bf15fb132" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;round(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;round(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;round(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;round(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7c9a2c7f5f210b7436687e26513be6f97e02a2d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;row&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;row&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6bc595dec6582246906837ece99dd2d9d595c4be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;row_number()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;row_number()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5bb5815912a7a25828847a14d830afa81794e48c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid BETWEEN $lwr AND $upr&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;$ lwr和$ upr之间的rowid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="24cc6900b78e2dccfbf100ecdd22f5422feb3151" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid IN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;行ID IN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="194d8c92ba435bfeb5dddcca984211dc5c83f9f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rowid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc7bc59f8cdd1723aa19dd21067fb2173a1d966d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid=$id&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rowid=$id&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8b2e4bd1806543d782878e39a0464ee350a55bd2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rtrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;rtrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rtrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;rtrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1a01ed5e9b0f95f0e890796478ba1457e1d2012a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;run&lt;/b&gt;: This field is the number of times that the statement has been run. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;run&lt;/b&gt;：此字段是语句已运行的次数。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="fe6850372737e4a538a91283051291ccaa3b6d11" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema&lt;/b&gt; &amp;rarr; Which database file the btree is located in. This will be &quot;main&quot; for the main database (the usual case), or &quot;temp&quot; for TEMP tables and indexes, or the name assigned to &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases by the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement.</source>
          <target state="translated">&lt;b&gt;schema&lt;/b&gt; &amp;rarr;btree所在的数据库文件。对于主数据库，这将是&amp;ldquo; main&amp;rdquo;（通常情况）；对于TEMP表和索引，这将是&amp;ldquo; temp&amp;rdquo;；或者由&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句分配给&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;数据库的名称。</target>
        </trans-unit>
        <trans-unit id="6665c42d1931c0c11bc5fdb3f4263f62967dd63d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7581ff4e29fb81935f4ac0e64765167bccedcaf5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema_version = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema_version = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e88eb35aae7e462aa136a9cf07bcc20b9b1be9ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema_version; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema_version; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fd6a9f0cd2885d562989c04156ad40993a8ae646" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;scope&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;scope&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2741e4cf3f42be902ed8f4f9feeb47588d70ef90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;score&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;score&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c73b09e15d5fda473433a1b9ec4f9f86563ba45c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;secure_delete = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;secure_delete = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cf2ead5c4efff15afbf4a1d95f72bf4bcf3aaac9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;secure_delete; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;secure_delete; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e7bba61243050573065917c0d6af2442d5ad0e95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;shell.c&lt;/b&gt;: The command-line interface program itself. This is the C source code file that contains the definition of the &lt;b&gt;main()&lt;/b&gt; routine and the loop that prompts for user input and passes that input into the SQLite database engine for processing.</source>
          <target state="translated">&lt;b&gt;shell.c&lt;/b&gt;：命令行界面程序本身。这是C源代码文件，其中包含&lt;b&gt;main（）&lt;/b&gt;例程的定义和循环，该循环提示用户输入并将该输入传递到SQLite数据库引擎进行处理。</target>
        </trans-unit>
        <trans-unit id="605c53952422929c94c4ef797c0cae43610c5471" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;soundex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;soundex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd4f59d9802ac2b8b9ccdfced25c86d0a351f22a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;soundslike&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;soundslike&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="439148df042711bd9ba70bd7e598ffbca547afb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_editdist(P,W)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_editdist(P,W)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f1a6c0d38f6505697db2c498ea35b78ed9e5fc63" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_phonehash(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_phonehash(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ce4abdb98f5e793c14ba05e7c794774cec57a9e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_scriptcode(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_scriptcode(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="55372a1db28566500f11b9a322c8e23b33028121" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_translit(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_translit(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="28729d4fd616d37dddc414af30b2a754fd305dc6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sql&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sql&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="72513f2eaa33786572b541eb69611d8a91d32bd2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sql&lt;/b&gt;: The original SQL text of the prepared statement. If the prepared statement is compiled using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface, then the SQL text might not have been saved, in which case this column will be NULL.</source>
          <target state="translated">&lt;b&gt;sql&lt;/b&gt;：准备好的语句的原始SQL文本。如果准备好的语句是使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口编译的，则可能尚未保存SQL文本，在这种情况下，此列将为NULL。</target>
        </trans-unit>
        <trans-unit id="b98d7e7639e1091f7a9cc980b2fa80fcf072e758" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlar_compress(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlar_compress(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="40ef691312d4ca7479d76cbfc1797a518f374cc8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlar_uncompress(Y,SZ)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlar_uncompress(Y,SZ)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6cebe7a7b12fd950a74b5fba5575de4973ffb868" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3.c&lt;/b&gt;: The SQLite amalgamation source file</source>
          <target state="translated">&lt;b&gt;sqlite3.c&lt;/b&gt;：SQLite合并源文件</target>
        </trans-unit>
        <trans-unit id="5c09182d460b59bea381dbce17c0a713fbd32a19" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3.h&lt;/b&gt;: The header files that accompanies sqlite3.c and defines the C-language interfaces to SQLite.</source>
          <target state="translated">&lt;b&gt;sqlite3.h&lt;/b&gt;：&lt;b&gt;sqlite3.c&lt;/b&gt;附带的头文件，它定义SQLite的C语言接口。</target>
        </trans-unit>
        <trans-unit id="5bc4c2f9fd5dadcb7d70ecf5019b082922291e64" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_finish()&lt;/b&gt; is called to release all resources associated with the backup operation.</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;调用&lt;b&gt;sqlite3_backup_finish（）&lt;/b&gt;释放与备份操作关联的所有资源。</target>
        </trans-unit>
        <trans-unit id="7599f05bd7927f9fe0e7226e610b201a20fca5cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_init()&lt;/b&gt; is called once to initialize the backup,</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;调用一次&lt;b&gt;sqlite3_backup_init（）&lt;/b&gt;初始化备份，</target>
        </trans-unit>
        <trans-unit id="50049f9518772742b4f4d7a9638718fd332f558c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_step()&lt;/b&gt; is called one or more times to transfer the data between the two databases, and finally</source>
          <target state="translated">&lt;b&gt;sqlite3_backup_step（）&lt;/b&gt;被调用一次或多次以在两个数据库之间传输数据，最后</target>
        </trans-unit>
        <trans-unit id="36384ee5a830c16bb1e112e7d3a904e2090a6806" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_int64 (*xRowid)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_int64（* xRowid）（Fts5Context *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d84a20c3533b13fd8f3158014a02d324fdf73854" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_compileoption_get(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_compileoption_get(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f387f1d980ba1b6ac824b01c4502663c86db1b1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_compileoption_used(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_compileoption_used(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d6e44884028fa4a47b130aec37b250e2c69a0833" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_exec_printf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_exec_printf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ebcfeff700a28642ccb8dde6efb294b6168bbaf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_exec_vprintf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_exec_vprintf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3a04b66dabddcc301fcb52fd7ec612ccbabf6148" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_get_table_printf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_get_table_printf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f711405ae8eba472544d1aa5cfd209c541dc90a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_get_table_vprintf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_get_table_vprintf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8617cd19825488ab7fdd81fef2642bb7b5bd4e71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_offset(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_offset(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2efa54cd4a876a8b910e9958257c43e50054c08b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_source_id()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_source_id()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6332e2508f2d7603546d3bcc08b9be6340cd89c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_version()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_version()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="abde37706a46b7ca8874418dde8c8e57d75e9301" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;srchcnt&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;srchcnt&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="766dd6c9278d00bc9e2d900050adefb7e1ac80fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;statement&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;statement&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61469f9128c59549d8929ca8786e2516099564cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;strftime(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;strftime(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a19bbfd3a044735a65a2255097aafba5711da31e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;subprog&lt;/b&gt; &amp;rarr; The sub-program in which the object is accessed. NULL means the main body of the prepared statement. Otherwise this field is the name of a trigger or &quot;(FK)&quot; for a foreign key action.</source>
          <target state="translated">&lt;b&gt;subprog&lt;/b&gt; &amp;rarr;在其中访问对象的子程序。NULL表示准备好的语句的主体。否则，此字段是触发器的名称或外键操作的&amp;ldquo;（FK）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cae9927a2b3298dd39e25b370b34d3395edd5527" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fbdecbb8db2e7359deabd727dceb9ce1b745abb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;br/&gt;substring(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substring(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;br/&gt;substring(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substring(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e12c6d8c9e8a39f25add895e2c0bf8d194e1c45f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sum(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;total(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sum(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;total(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8a3492ae3d2a89485e206c4937164ed7d324c5a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;synchronous = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;同步= &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f085e6ee811e844fee162829f6334cdd145d4bca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;synchronous; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;同步; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f03ee139387146c590bdbb574bc081c350f09bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;table_info(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;table_info(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c6eefb15dd071e91029df39120e4adef6f09f67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;table_xinfo(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;table_xinfo(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="451275623a6a1ecb0ed4f79ea05ae28b45900795" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;tbl_name&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;tbl_name&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a7146ae989b40b504ed9566df150fba27db865a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test-ex.rc&lt;/b&gt; - long-running soak tests.</source>
          <target state="translated">&lt;b&gt;test-ex.rc-&lt;/b&gt;长时间浸泡测试。</target>
        </trans-unit>
        <trans-unit id="9082bc8530887269298fa6b758b7df0103f4afb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test.rc&lt;/b&gt; - Run the same tests as in fast.rc but without compiler optimization and enabling options like &lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt; and -DSQLITE_ENABLE_EXPENSIVE_ASSERT.</source>
          <target state="translated">&lt;b&gt;test.rc-&lt;/b&gt;运行与&lt;b&gt;fast.rc&lt;/b&gt;中相同的测试，但是没有编译器优化，也没有启用&lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt;和-DSQLITE_ENABLE_EXPENSIVE_ASSERT之类的选项。</target>
        </trans-unit>
        <trans-unit id="4ec47fe06e8fa40340ac7dc1a59a81c280b08d6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;testcase(X)&lt;/b&gt; &amp;rarr; The testcase(X) statement indicates that X is sometimes true and sometimes false. In other words, testcase(X) indicates that X is definitely not an invariant. Since SQLite uses 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC/DC testing&lt;/a&gt;, the presence of a testcase(X) macro indicates that not only is it possible for X to be either true or false, but there are test cases to demonstrate this.</source>
          <target state="translated">&lt;b&gt;testcase（X）&lt;/b&gt; &amp;rarr;testcase（X）语句指示X有时为true，有时为false。换句话说，testcase（X）表示X绝对不是不变的。由于SQLite使用100％&lt;a href=&quot;testing#mcdc&quot;&gt;MC / DC测试&lt;/a&gt;，因此testcase（X）宏的存在表明X不仅可能为true或false，而且有测试用例来证明这一点。</target>
        </trans-unit>
        <trans-unit id="387747815042252f6049ab6dffd4c9e618d3c9ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;time(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;time(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="751f81cbcc6744df5561e7226f36021bf2e3af36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;top&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;top&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e24cfa079085118e42e96d2a55a37a53557cd88e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;total_changes()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;total_changes()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="542f31e075ca05fd951176f4d597451afd1125ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;trim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;trim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;trim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;trim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c9896a47a6b00d8108eb1bffa5cb2a88fce66d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;type&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;type&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5029c699828723a5298deeaf83c9a3d0e8ee4406" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;type&lt;/b&gt; &amp;rarr; Either &quot;table&quot; or &quot;index&quot;, depending on what role the btree is serving.</source>
          <target state="translated">&lt;b&gt;类型&lt;/b&gt;&amp;rarr;&amp;ldquo;表&amp;rdquo;或&amp;ldquo;索引&amp;rdquo;，具体取决于btree所扮演的角色。</target>
        </trans-unit>
        <trans-unit id="b5adfeb6f8a74b81f3673d50c2e3be5461cb4506" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;typeof(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;typeof(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="564af250a086d4ca4862414f517487932362df50" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unicode(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;unicode(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a493d0d93cdad6d8063bb460480308af31d81af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-dotfile&lt;/b&gt; - uses dot-file locking rather than POSIX advisory locks.</source>
          <target state="translated">&lt;b&gt;unix-dotfile-&lt;/b&gt;使用点文件锁定而不是POSIX咨询锁定。</target>
        </trans-unit>
        <trans-unit id="7ee0b7222a0d2745b0960933b8554bb0b2cb0f36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-excl&lt;/b&gt; - obtains and holds an exclusive lock on database files, preventing other processes from accessing the database. Also keeps the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; in heap rather than in shared memory.</source>
          <target state="translated">&lt;b&gt;unix-excl-&lt;/b&gt;获取并持有对数据库文件的排他锁，以防止其他进程访问数据库。&lt;a href=&quot;walformat#shm&quot;&gt;还将wal-index&lt;/a&gt;保留在堆中，而不是共享内存中。</target>
        </trans-unit>
        <trans-unit id="171a40a565e91b5e38415639e5c0e1f0a1d0147f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-namedsem&lt;/b&gt; - uses named semaphores for file locking. VXWorks only.</source>
          <target state="translated">&lt;b&gt;unix-namedsem-&lt;/b&gt;使用命名信号量进行文件锁定。仅限于VXWorks。</target>
        </trans-unit>
        <trans-unit id="87aa888be05eec90be29a815beb11ebb61786bc9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-none&lt;/b&gt; - all file locking operations are no-ops.</source>
          <target state="translated">&lt;b&gt;unix-none-&lt;/b&gt;所有文件锁定操作均为无操作。</target>
        </trans-unit>
        <trans-unit id="d3e2ab215f74d535aecccce1746b0b6f8e4eee96" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unlikely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;unlikely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7abd3b06da2eeea0c8f757f2140032a74361ffdb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;upper(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;upper(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a630c6ced4b606f3e586eb856c79eca570d7b5d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;user_version = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;user_version = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25f14ee4f8a99c00c21229b1476cff5c7dcf693f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;user_version; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;user_version; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="088cf7d75ebd01b23e3aca416dca22a57dac9950" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;vfs&lt;/b&gt;: The &quot;vfs&quot; parameter may be used to specify the name of a VFS object that provides the operating system interface that should be used to access the database file on disk. If this option is set to an empty string the default VFS object is used. Specifying an unknown VFS is an error. If sqlite3_open_v2() is used and the vfs option is present, then the VFS specified by the option takes precedence over the value passed as the fourth parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;vfs&lt;/b&gt;：&amp;ldquo; vfs&amp;rdquo;参数可用于指定VFS对象的名称，该对象提供应用于访问磁盘上数据库文件的操作系统接口。如果将此选项设置为空字符串，则使用默认的VFS对象。指定未知的VFS是错误。如果使用sqlite3_open_v2（）并且存在vfs选项，则该选项指定的VFS优先于作为第四个参数传递给sqlite3_open_v2（）的值。</target>
        </trans-unit>
        <trans-unit id="2998c7ff661dc1402458997c40d904ae7019342d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;vfs=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;vfs=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6be0f1dac527f6a7a3a8b6d2e7324226055d9238" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无效（* xPhraseNext）（Fts5Context *，Fts5PhraseIter *，int * piCol，int * piOff）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bfac065939a7511e81786f4f00b434cd5618329" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无效（* xPhraseNextColumn）（Fts5Context *，Fts5PhraseIter *，int * piCol）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0f50db153cf3b9cc7e9e88b1554a9c5a044290b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void *(*xGetAuxdata)(Fts5Context*, int bClear)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无效*（* xGetAuxdata）（Fts5Context *，int bClear）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1dd96b486c80ce4df848a29698eba4d9200ba1cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void *(*xUserData)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无效*（* xUserData）（Fts5Context *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b126f269504e317361d82c9eb42ec77f3cb00678" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(FULL);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(FULL);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5c4d6723b1efc24a3f9e4546fac324515250a15f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(PASSIVE);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(PASSIVE);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="245179a0a4378112590955d1a1537df9f96e19d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(RESTART);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(RESTART);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf71d8462439fb51aa407e19229e4d9affee0e5f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(TRUNCATE);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(TRUNCATE);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7e49255e11543623b2c50370c1e1606794efe285" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0751bc3711d32d9aac3b755aa8669d93303b0272" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-longpath-none&lt;/b&gt; - combination of &quot;win32-longpath&quot; and &quot;win32-none&quot; - long pathnames are supported and all lock operations are no-ops.</source>
          <target state="translated">&lt;b&gt;win32-longpath-none-&lt;/b&gt; &amp;ldquo; win32-longpath&amp;rdquo;和&amp;ldquo; win32-none&amp;rdquo;的组合-支持长路径名，并且所有锁定操作均为无操作。</target>
        </trans-unit>
        <trans-unit id="4ad6725cafce35d815b8464dedebc92eb51ec573" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-longpath&lt;/b&gt; - like &quot;win32&quot; except that pathnames can be up to 65534 bytes in length, whereas pathnames max out at 1040 bytes in &quot;win32&quot;.</source>
          <target state="translated">&lt;b&gt;win32-longpath-&lt;/b&gt;类似于&amp;ldquo; win32&amp;rdquo;，除了路径名的最大长度为65534字节，而&amp;ldquo; win32&amp;rdquo;中的路径名最大为1040字节。</target>
        </trans-unit>
        <trans-unit id="beadca375c7cb43a64419f239d7bb81fa172a062" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-none&lt;/b&gt; - all file locking operations are no-ops.</source>
          <target state="translated">&lt;b&gt;win32-none-&lt;/b&gt;所有文件锁定操作均为无操作。</target>
        </trans-unit>
        <trans-unit id="c7f7df8b834c26f9670be7255e91884f981bbdf5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;word&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;word&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="939435b3e3bd0b57aa2f08626632174b89f77a0f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wr&lt;/b&gt; &amp;rarr; 0 if the object is read, 1 if the object is written</source>
          <target state="translated">&lt;b&gt;wr&lt;/b&gt; &amp;rarr;如果读取对象，则为0；如果写入对象，则为1</target>
        </trans-unit>
        <trans-unit id="ef6ccfe69e2ef2274904ba1b989763fe9daed749" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xCreate:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;xCreate:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d2513139e5b8b98f8591b754c3ae624f21972c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xFinal()&lt;/b&gt; - invoked to reclaim any allocated resources.</source>
          <target state="translated">&lt;b&gt;xFinal（）&lt;/b&gt; -调用以回收任何分配的资源。</target>
        </trans-unit>
        <trans-unit id="08ea35c5e28008270d3f794e11e6b29032f8b335" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(3)&lt;/b&gt; - remove value &quot;3&quot; from the window. The window now contains values 8 and 1 only.</source>
          <target state="translated">&lt;b&gt;xInverse（3）&lt;/b&gt; -从窗口中删除值&amp;ldquo; 3&amp;rdquo;。现在，该窗口仅包含值8和1。</target>
        </trans-unit>
        <trans-unit id="d06f04ca5de186ef308cf987a39acd62fa581efb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(4)&lt;/b&gt; - remove &quot;4&quot; from the window.</source>
          <target state="translated">&lt;b&gt;xInverse（4）&lt;/b&gt; -从窗口中删除&amp;ldquo; 4&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6ea3b2c9ac24752a4d124bf259358d12a4385ed1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(5)&lt;/b&gt; - remove value &quot;5&quot; from the window.</source>
          <target state="translated">&lt;b&gt;xInverse（5）&lt;/b&gt; -从窗口中删除值&amp;ldquo; 5&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c201bad931f8401061d806fb20a99e02f340ca75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(1)&lt;/b&gt; - add value &quot;1&quot; to the window.</source>
          <target state="translated">&lt;b&gt;xStep（1）&lt;/b&gt; -将值&amp;ldquo; 1&amp;rdquo;添加到窗口。</target>
        </trans-unit>
        <trans-unit id="552183d8347d4aa8b4ecd28963b82e0980c54d3f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(3)&lt;/b&gt; - add &quot;3&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep（3）&lt;/b&gt; -在当前窗口中添加&amp;ldquo; 3&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4686be269638aad4598d31d42b3f4f673d7fe4a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(4)&lt;/b&gt; - add &quot;4&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep（4）&lt;/b&gt; -在当前窗口中添加&amp;ldquo; 4&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d82113cc4bb37a3f6a26309f9a359011d7b90a67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(5)&lt;/b&gt; - add &quot;5&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep（5）&lt;/b&gt; -在当前窗口中添加&amp;ldquo; 5&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="26af953955c0fb0cb311f7c624b1676a7c454639" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(8)&lt;/b&gt; - add &quot;8&quot; to the current window. The window now consists of values 5, 3 and 8.</source>
          <target state="translated">&lt;b&gt;xStep（8）&lt;/b&gt; -在当前窗口中添加&amp;ldquo; 8&amp;rdquo;。窗口现在包含值5、3和8。</target>
        </trans-unit>
        <trans-unit id="cf072a5adae091a25691fa9f8a75085c48f93b90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoke xValue() to obtain the value of sumint() for the row with (x='a'). The window currently consists of values 4 and 5, and so the result is 9.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用xValue（）以获得具有（x ='a'）的行的sumint（）值。该窗口当前包含值4和5，因此结果为9。</target>
        </trans-unit>
        <trans-unit id="2c5dd79d383628751a86ee2ffb1fcdc34f1bd26e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoke xValue() to obtain the value of sumint() for the row with (x='b'). The window currently consists of values 4, 5 and 3, and so the result is 12.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用xValue（）以获取具有（x ='b'）的行的sumint（）值。该窗口当前包含值4、5和3，因此结果为12。</target>
        </trans-unit>
        <trans-unit id="a6e4b8f199ffe99bce9be789081aca11bd89a987" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for row (x='d').</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用以获得行（x ='d'）的值。</target>
        </trans-unit>
        <trans-unit id="1a08acb2172b97a134c2c8886902b63f79dd194d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for row (x='d'). 9.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用以获得行（x ='d'）的值。9。</target>
        </trans-unit>
        <trans-unit id="cc97921394b2259ffa98a9395516e9cb85973a54" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for row (x='e'). 9.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用以获得行（x ='e'）的值。9。</target>
        </trans-unit>
        <trans-unit id="5ff710f762c530458940d685a64c42fe7d5eb730" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for the row with (x='c'). In this case, 16.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用以获取具有（x ='c'）的行的值。在这种情况下，为16。</target>
        </trans-unit>
        <trans-unit id="1095dbf2de54ae2f1e5f798caef30945b907d26a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;zFunctionName&lt;/b&gt; &amp;rarr; The 2nd parameter is the name of the SQL function that is being created. The name is usually in UTF8, except that the name should be in UTF16 in the native byte order for &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;zFunctionName&lt;/b&gt; &amp;rarr;第2个参数是要创建的SQL函数的名称。该名称通常以UTF8表示，除了名称应以&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;的本机字节顺序以UTF16表示。</target>
        </trans-unit>
        <trans-unit id="c2de13f92fe4c6dae6ac8db9dacd9ccaae02dc07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;zeroblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;zeroblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9fa13734f5aacd4ab8879e00f3c9d12402784092" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Not yet implemented)&lt;/em&gt; Create indexes that might have been helpful to recent queries.</source>
          <target state="translated">&lt;em&gt;（尚未实现）&lt;/em&gt;创建可能对最近的查询有用的索引。</target>
        </trans-unit>
        <trans-unit id="b6e6228539f5984d272435f54680c919edca57b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Not yet implemented)&lt;/em&gt; Record usage and performance information from the current session in the database file so that it will be available to &quot;optimize&quot; pragmas run by future database connections.</source>
          <target state="translated">&lt;em&gt;（尚未实现）&lt;/em&gt;将当前会话的使用情况和性能信息记录在数据库文件中，以便可用于&amp;ldquo;优化&amp;rdquo;由将来的数据库连接运行的编译指示。</target>
        </trans-unit>
        <trans-unit id="6d4e8b1714f1b41237ba93ca2e5bf1b3d93408f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Making a change to the sqlite_master table like this will render the database corrupt and unreadable if the change contains a syntax error. It is suggested that careful testing of the UPDATE statement be done on a separate blank database prior to using it on a database containing important data.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;如果对sqlite_master表的更改包含语法错误，则以这种方式进行更改将使数据库损坏且不可读。建议在包含重要数据的数据库上使用UPDATE语句之前，先在单独的空白数据库上进行仔细的测试。</target>
        </trans-unit>
        <trans-unit id="51f3632551479a4241159ad77de3f62c093d8c27" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Making a change to the sqlite_schema table like this will render the database corrupt and unreadable if the change contains a syntax error. It is suggested that careful testing of the UPDATE statement be done on a separate blank database prior to using it on a database containing important data.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;如果对sqlite_schema表进行这样的更改，则该更改包含语法错误，将使数据库损坏且不可读。建议在包含重要数据的数据库上使用UPDATE语句之前，先在单独的空白数据库上进行仔细的测试。</target>
        </trans-unit>
        <trans-unit id="9e8d8331be552f1d9886147666d4d00355995833" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Once again, making changes to the sqlite_master table like this will render the database corrupt and unreadable if the change contains an error. Carefully test this entire procedure on a separate test database prior to using it on a database containing important data and/or make backup copies of important databases prior to running this procedure.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;再次对sqlite_master表进行这样的更改，如果更改包含错误，将使数据库损坏且不可读。在运行包含此重要数据的数据库之前，请先在单独的测试数据库上仔细测试整个过程，然后再执行此过程，然后对重要数据库进行备份。</target>
        </trans-unit>
        <trans-unit id="6d6c1135084f914bbdf80a671b4bb8717b33074e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Once again, making changes to the sqlite_schema table like this will render the database corrupt and unreadable if the change contains an error. Carefully test this entire procedure on a separate test database prior to using it on a database containing important data and/or make backup copies of important databases prior to running this procedure.</source>
          <target state="translated">&lt;em&gt;警告：&lt;/em&gt;再次对sqlite_schema表进行这样的更改，如果更改包含错误，将使数据库损坏且不可读。在运行包含此重要数据的数据库之前，请先在单独的测试数据库上仔细测试整个过程，然后再执行此过程，然后对重要数据库进行备份。</target>
        </trans-unit>
        <trans-unit id="80f6ba8783597d88987529bbf21585dc3045c297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nota Bene:&lt;/em&gt; In this rule, &quot;application&quot; means the code that issues SQL statements. If the &quot;application&quot; is an &lt;a href=&quot;whentouse#serversidedb&quot;&gt;application server&lt;/a&gt; and if the content resides on the same physical machine as the application server, then SQLite might still be appropriate even though the end user is another network hop away.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;在此规则中，&amp;ldquo;应用程序&amp;rdquo;表示发出SQL语句的代码。如果&amp;ldquo;应用程序&amp;rdquo;是&lt;a href=&quot;whentouse#serversidedb&quot;&gt;应用程序服务器，&lt;/a&gt;并且内容与应用程序服务器位于同一台物理计算机上，则即使最终用户离另一个网络跳远，SQLite仍可能适用。</target>
        </trans-unit>
        <trans-unit id="0a88a70f28eea7505a4745ef400e6ee503235e73" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;any&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;any&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9f86c02aa28130769f3916ecd58dfbb1c988d34" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;It is not possible to open &lt;a href=&quot;wal#readonly&quot;&gt;read-only WAL databases&lt;/a&gt;. The opening process must have write privileges for &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; shared memory file associated with the database, if that file exists, or else write access on the directory containing the database file if the &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; file does not exist.&lt;/s&gt; Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22), a read-only WAL-mode database file can be opened if the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists or those files can be created or the &lt;a href=&quot;uri#uriimmutable&quot;&gt;database is immutable&lt;/a&gt;.</source>
          <target state="translated">&lt;s&gt;无法打开&lt;a href=&quot;wal#readonly&quot;&gt;只读WAL数据库&lt;/a&gt;。开放进程必须具有写权限&amp;ldquo; &lt;code&gt;-shm&lt;/code&gt; &amp;rdquo; &lt;a href=&quot;walformat#shm&quot;&gt;WAL索引&lt;/a&gt;与数据库相关的共享内存文件，该文件是否存在，或者包含数据库文件，如果&amp;ldquo;目录其他的写访问 &lt;code&gt;-shm&lt;/code&gt; &amp;rdquo;文件不存在。&lt;/s&gt;从&lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;版本3.22.0&lt;/a&gt;（2018-01-22）开始，如果 &lt;code&gt;-shm&lt;/code&gt; 和 &lt;code&gt;-wal&lt;/code&gt; 文件已经存在或者可以创建这些文件或者&lt;a href=&quot;uri#uriimmutable&quot;&gt;数据库是不可变的，&lt;/a&gt;则可以打开只读的WAL模式数据库文件。</target>
        </trans-unit>
        <trans-unit id="4adae4e92d852fe832ed5d1eceb7319abc564534" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;The target database may not contain &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.&lt;/s&gt; Indexes on expressions are supported beginning with SQLite 3.30.0 (2019-10-04).</source>
          <target state="translated">&lt;s&gt;目标数据库可能不包含&lt;a href=&quot;expridx&quot;&gt;表达式的索引&lt;/a&gt;。&lt;/s&gt;从SQLite 3.30.0（2019-10-04）开始支持表达式索引。</target>
        </trans-unit>
        <trans-unit id="db395f459bbe4efd96a60570c6c0dc0d9de9b06f" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;WAL works best with smaller transactions. WAL does not work well for very large transactions. For transactions larger than about 100 megabytes, traditional rollback journal modes will likely be faster. For transactions in excess of a gigabyte, WAL mode may fail with an I/O or disk-full error. It is recommended that one of the rollback journal modes be used for transactions larger than a few dozen megabytes.&lt;/s&gt; Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), WAL mode works as efficiently with large transactions as does rollback mode.</source>
          <target state="translated">&lt;s&gt;WAL最适合较小的交易。WAL不适用于非常大的交易。对于大于约100 MB的事务，传统的回滚日志记录模式可能会更快。对于超过1 GB的事务，WAL模式可能会因I / O或磁盘已满错误而失败。建议将回滚日志模式之一用于大于几十兆字节的事务。&lt;/s&gt;从&lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;版本3.11.0&lt;/a&gt;（2016-02-15）开始，WAL模式与回滚模式一样有效地处理大型事务。</target>
        </trans-unit>
        <trans-unit id="89e3d94a9d9f3be8c533f30cf505fbbc9e619b12" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;count_changes&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;count_changes&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="2fe7dcf40a505cee3d2c9c220b0b032b337985ba" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;data_store_directory&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;data_store_directory&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="529e4c95946d239f6f7340a28f8c19b836131c18" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;default_cache_size&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;default_cache_size&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="1e40be7959fdcb27f689b1bd4b4c13f00f9648e7" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;empty_result_callbacks&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;empty_result_callbacks&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="37b8e45b75945b9a2ed1c6840780034aeaa96def" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;full_column_names&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;full_column_names&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="7ba50a54ae872e46e392d945fcfe8882528f779d" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;short_column_names&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;short_column_names&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="5cf9a92ecc51fe417c6554bfdf564ab70b6793e5" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_aggregate_count&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_aggregate_count&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="e04a1191ffe57ae4dc80fdf0b0d1302374a5223c" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_expired&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_expired&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="d4ae465dac3d471fb929f18f6459bc6fcd0ad5ac" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_global_recover&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_global_recover&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="c152f165bf4d682834190453559ca4079d4e3e8f" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_memory_alarm&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_memory_alarm&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="213d566c65b6e979c0b12b5cb2c6d769f7e68036" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_soft_heap_limit&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_soft_heap_limit&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="650653e2136ca438507f86226e9dd600546df2c7" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_thread_cleanup&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_thread_cleanup&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="9810cb85410d21ed25bad43b513e5d44434fc79b" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_transfer_bindings&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_transfer_bindings&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="c56e6ca2d9c7c42057a3d4b7225bd064062059b2" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;temp_store_directory&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;temp_store_directory&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="156219115afff08d45c71a04e60351afa6d72952" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; An R*Tree index does not normally provide the exact answer but merely reduces the set of potential answers from millions to dozens.</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt; R * Tree索引通常不提供确切答案，而只是将潜在答案的集合从数百万个减少到数十个。</target>
        </trans-unit>
        <trans-unit id="6049fd8bb72e0e6f1e8d8a417d9fe8b5a790ff5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Changes to compile-time options have the potential to affect makefiles in projects that do customized builds of SQLite. These changes should have zero impact on application code and for most projects which use a standard, default build of SQLite.</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt;更改编译时选项可能会影响执行定制SQLite构建的项目中的makefile。这些更改将对应用程序代码以及大多数使用标准默认SQLite构建的项目产生零影响。</target>
        </trans-unit>
        <trans-unit id="8fe0585022e152f67097fdd4ed2411a232e49da4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The change to the way NULL values are handled by the IN and NOT IN operators is technically a bug fix, not a design change. However, maintainers should check to ensure that applications do not depend on the older, buggy behavior prior to upgrading to version 3.6.0.</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt;更改IN和NOT IN运算符处理NULL值的方式从技术上讲是一个错误修复，而不是设计更改。但是，维护人员应检查以确保应用程序在升级到3.6.0版之前不依赖较旧的错误行为。</target>
        </trans-unit>
        <trans-unit id="ac582c2b4e7dacb497b4397bfa98eb62970fbb75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The incompatible changes in the SQLite operating-system interface for version 3.6.0 only affect the rare applications that make use of the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface or that supply an application-defined &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex implementation&lt;/a&gt; or that make use of other obscure compile-time options. The changes introduced by SQLite version 3.6.0 will have zero impact on the vast majority of SQLite applications that use the built-in interfaces to Unix, Windows, and OS/2 and that use the standard build configuration.</source>
          <target state="translated">&lt;strong&gt;重点：&lt;/strong&gt;版本3.6.0的SQLite操作系统接口中的不兼容更改仅影响使用&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;接口或提供应用程序定义的&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;互斥体实现&lt;/a&gt;或使用其他晦涩的编译功能的罕见应用程序- 时间选项。SQLite 3.6.0版引入的更改将对绝大多数使用Unix，Windows和OS / 2的内置接口并使用标准构建配置的SQLite应用程序产生零影响。</target>
        </trans-unit>
        <trans-unit id="fcc0502f968c401bb51d275b3d308a8f8dcc412b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Points:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="e3be666c416d3eeb09cb76c7b7abf3ac3e2ab55d" translate="yes" xml:space="preserve">
          <source>=0).</source>
          <target state="translated">=0).</target>
        </trans-unit>
        <trans-unit id="0f8eebb6cdfbace0c569728246016f04641f12f9" translate="yes" xml:space="preserve">
          <source>=1 and</source>
          <target state="translated">= 1并且</target>
        </trans-unit>
        <trans-unit id="5bab61eb53176449e25c2c82f172b82cb13ffb9d" translate="yes" xml:space="preserve">
          <source>?</source>
          <target state="translated">?</target>
        </trans-unit>
        <trans-unit id="3611d993bcfe075143e56843e7c942308dbe016c" translate="yes" xml:space="preserve">
          <source>?NNN</source>
          <target state="translated">?NNN</target>
        </trans-unit>
        <trans-unit id="1a2a6f3e69a4dab4720c5d9a3aae1f202d725e39" translate="yes" xml:space="preserve">
          <source>@VVV</source>
          <target state="translated">@VVV</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="83c828fc11c0e93226c89266f2e8a91c52ebb360" translate="yes" xml:space="preserve">
          <source>A &quot;CREATE TABLE ... AS SELECT&quot; statement creates and populates a database table based on the results of a SELECT statement. The table has the same number of columns as the rows returned by the SELECT statement. The name of each column is the same as the name of the corresponding column in the result set of the SELECT statement. The declared type of each column is determined by the &lt;a href=&quot;datatype3#expraff&quot;&gt;expression affinity&lt;/a&gt; of the corresponding expression in the result set of the SELECT statement, as follows:</source>
          <target state="translated">&amp;ldquo; CREATE TABLE ... AS SELECT&amp;rdquo;语句根据SELECT语句的结果创建并填充数据库表。该表的列数与SELECT语句返回的行数相同。每列的名称与SELECT语句的结果集中相应列的名称相同。每列的声明类型由SELECT语句的结果集中相应表达式的&lt;a href=&quot;datatype3#expraff&quot;&gt;表达式亲和力&lt;/a&gt;确定，如下所示：</target>
        </trans-unit>
        <trans-unit id="1591a1617a12bcdebc03ff048dd0aaab529e900a" translate="yes" xml:space="preserve">
          <source>A &quot;long int&quot; or &quot;long unsigned int&quot;. Also 32-bits on all modern systems.</source>
          <target state="translated">一个 &quot;long int &quot;或 &quot;long unsigned int&quot;。在所有现代系统上也是32位。</target>
        </trans-unit>
        <trans-unit id="7f3cd818abaaa9a0e6005a308275969363d99be5" translate="yes" xml:space="preserve">
          <source>A &quot;long long int&quot; or &quot;long long unsigned&quot; or an &quot;sqlite3_int64&quot; or &quot;sqlite3_uint64&quot; value. These are 64-bit integers on all modern systems.</source>
          <target state="translated">一个 &quot;long long int &quot;或 &quot;long long unsigned &quot;或 &quot;sqlite3_int64 &quot;或 &quot;sqlite3_uint64 &quot;的值。在所有现代系统中,这些都是64位整数。</target>
        </trans-unit>
        <trans-unit id="7f83dc95438f0748d2d21836359d9d250a9cf519" translate="yes" xml:space="preserve">
          <source>A &quot;row value&quot; is an ordered list of two or more scalar values. In other words, a &quot;row value&quot; is a vector.</source>
          <target state="translated">一个 &quot;行值 &quot;是两个或多个标量值的有序列表。换句话说,&quot;行值 &quot;是一个向量。</target>
        </trans-unit>
        <trans-unit id="283fddadbd97aab80b3f5c004c94712b610008ef" translate="yes" xml:space="preserve">
          <source>A &quot;rowid table&quot; is any table in an SQLite schema that</source>
          <target state="translated">一个 &quot;rowid表 &quot;是指在SQLite模式中的任何表,该表的功能是</target>
        </trans-unit>
        <trans-unit id="82ef35610d000dac934111c06adc58ba665e4eea" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; is a single number, string, BLOB or NULL. Sometimes the qualified name &quot;scalar value&quot; is used to emphasize that only a single quantity is involved.</source>
          <target state="translated">一个 &quot;值 &quot;是一个单一的数字、字符串、BLOB或NULL。有时使用限定名称 &quot;标量值 &quot;来强调只涉及一个数量。</target>
        </trans-unit>
        <trans-unit id="e595cea14982c806deb1a68df267f727d390b83d" translate="yes" xml:space="preserve">
          <source>A &quot;variable&quot; or &quot;parameter&quot; token specifies a placeholder in the expression for a value that is filled in at runtime using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; family of C/C++ interfaces. Parameters can take several forms:</source>
          <target state="translated">&amp;ldquo;变量&amp;rdquo;或&amp;ldquo;参数&amp;rdquo;标记在表达式中为占位符指定一个值，该值在运行时使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;系列C / C ++接口填充。参数可以采用几种形式：</target>
        </trans-unit>
        <trans-unit id="0650b7b535494da46a67e89f0076bd1eb000f596" translate="yes" xml:space="preserve">
          <source>A 4-byte big-endian integer page number for the first page of the overflow page list - omitted if all payload fits on the b-tree page.</source>
          <target state="translated">溢出页列表的第一页的4字节大英文整数页号--如果所有有效载荷都适合在b-tree页上,则省略。</target>
        </trans-unit>
        <trans-unit id="457dd24244954b2ed62ddd2400a48d0f00613b7e" translate="yes" xml:space="preserve">
          <source>A 4-byte big-endian page number which is the left child pointer.</source>
          <target state="translated">一个4字节的大字段页码,是左边的子指针。</target>
        </trans-unit>
        <trans-unit id="40fcda7469ad59852cc6bee2078ffd2e27a37099" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;datatype3#collation&quot;&gt;collating function&lt;/a&gt; for each column is necessary in order to compute the order of text fields. SQLite defines three built-in collating functions:</source>
          <target state="translated">甲&lt;a href=&quot;datatype3#collation&quot;&gt;核对函数&lt;/a&gt;为每一列是必要的，以便计算文本字段的顺序。SQLite定义了三个内置的整理功能：</target>
        </trans-unit>
        <trans-unit id="0941f09d0d99d3f4e14cafccc32de96df6f4ca23" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; means to rewind the WAL and start adding new frames at the beginning. This occurs while appending new frames to a WAL that has &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; equal to &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and which has no locks on WAL_READ_LOCK(1) through WAL_READ_LOCK(4). The WAL_WRITE_LOCK is held.</source>
          <target state="translated">一个&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL复位&lt;/a&gt;手段倒带WAL开始之初添加新的帧。在将新帧附加到&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;等于&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;并且在WAL_READ_LOCK（1）到WAL_READ_LOCK（4）上没有锁的WAL时，会发生这种情况。WAL_WRITE_LOCK被保持。</target>
        </trans-unit>
        <trans-unit id="d00aa28b4ba172b3e360c196f89dfcfc325f153e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; interface</source>
          <target state="translated">一个&lt;a href=&quot;fts3&quot;&gt;全文检索&lt;/a&gt;界面</target>
        </trans-unit>
        <trans-unit id="27fbe703a2a9d7026510938d0ef6d0e90ee4db6f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.sqlite.org/src/info/80ba201079&quot;&gt;very obscure bug&lt;/a&gt; associated with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;or optimization&lt;/a&gt; was fixed.</source>
          <target state="translated">与&lt;a href=&quot;optoverview#or_opt&quot;&gt;或优化&lt;/a&gt;相关的&lt;a href=&quot;http://www.sqlite.org/src/info/80ba201079&quot;&gt;非常模糊的错误&lt;/a&gt;已修复。</target>
        </trans-unit>
        <trans-unit id="e31e010d746a7a123704e529186007ff521c7865" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://www.sqlite.org/src/info/80ba201079&quot;&gt;very obscure bug&lt;/a&gt; associated with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;or optimization&lt;/a&gt; was fixed.</source>
          <target state="translated">与&lt;a href=&quot;optoverview#or_opt&quot;&gt;或优化&lt;/a&gt;相关的&lt;a href=&quot;https://www.sqlite.org/src/info/80ba201079&quot;&gt;非常模糊的错误&lt;/a&gt;已修复。</target>
        </trans-unit>
        <trans-unit id="8c246c5420b674d2441ed9c3d37319384c74b2e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; command operates the same whether or not &lt;a href=&quot;foreignkeys#fk_enable&quot;&gt;foreign key constraints are enabled&lt;/a&gt;. The parent key definitions of foreign key constraints are not checked when a table is created. There is nothing stopping the user from creating a foreign key definition that refers to a parent table that does not exist, or to parent key columns that do not exist or are not collectively bound by a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="translated">一个&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;命令操作相同与否&lt;a href=&quot;foreignkeys#fk_enable&quot;&gt;外键约束已启用&lt;/a&gt;。创建表时，不检查外键约束的父键定义。没有什么可以阻止用户创建一个外键定义，该外键定义引用一个不存在的父表，或者引用一个不存在的父键列，或者不由PRIMARY KEY或UNIQUE约束共同绑定的父键列。</target>
        </trans-unit>
        <trans-unit id="0e29b640b6e66681a005ec711b53b3e91c43098d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; may now reference undefined tables and functions when initially created. Missing tables and functions are reported when the VIEW is used in a query.</source>
          <target state="translated">甲&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;现在可以参考未定义表和函数最初创建时。在查询中使用VIEW时，将报告缺少的表和函数。</target>
        </trans-unit>
        <trans-unit id="84a46b4de837835c04612d05bdcd4565ff372f5f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoint&lt;/a&gt; transaction may be RELEASEd while the database is in a state that does not satisfy a deferred foreign key constraint. A transaction savepoint (a non-nested savepoint that was opened while there was not currently an open transaction), on the other hand, is subject to the same restrictions as a COMMIT - attempting to RELEASE it while the database is in such a state will fail.</source>
          <target state="translated">一个&lt;a href=&quot;lang_savepoint&quot;&gt;嵌套的保存点&lt;/a&gt;，而数据库是在不满足延期外键约束的状态事务可能被释放。另一方面，事务保存点（当前没有打开的事务时打开的非嵌套保存点）受与COMMIT相同的限制-在数据库处于这种状态时尝试释放它失败。</target>
        </trans-unit>
        <trans-unit id="5ac241bd5950cee76dd1c229b208c7ae5eeaa8f2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement enclosed in parentheses is a subquery. All types of SELECT statement, including aggregate and compound SELECT queries (queries with keywords like UNION or EXCEPT) are allowed as scalar subqueries. The value of a subquery expression is the first row of the result from the enclosed &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The value of a subquery expression is NULL if the enclosed &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement returns no rows.</source>
          <target state="translated">一个&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;括号括起来的语句是一个子查询。包括聚合查询和复合SELECT查询（带有UNION或EXCEPT之类的关键字的查询）在内的所有类型的SELECT语句都可以用作标量子查询。子查询表达式的值是附带的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句的结果的第一行。如果附带的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句不返回任何行，则子查询表达式的值为NULL 。</target>
        </trans-unit>
        <trans-unit id="20f43c4aca8f02e6e0cae74a1bfed1c05ee2754b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement used as either a scalar subquery or as the right-hand operand of an IN, NOT IN or EXISTS expression may contain references to columns in the outer query. Such a subquery is known as a correlated subquery. A correlated subquery is reevaluated each time its result is required. An uncorrelated subquery is evaluated only once and the result reused as necessary.</source>
          <target state="translated">甲&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句用作一个标量子查询或作为右边的操作数的IN的，NOT IN或EXISTS表达可以包含在外部查询到列的引用。这样的子查询被称为相关子查询。每当需要其结果时，都会重新评估相关的子查询。不相关的子查询仅被评估一次，结果将根据需要重新使用。</target>
        </trans-unit>
        <trans-unit id="024807a5ea9e932cf26bbf315bdeb3b063751ec8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause can be the first element in a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; that uses a &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause, but a &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; that consists of just a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause cannot be preceded by a &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause.</source>
          <target state="translated">甲&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;子句可以是在第一个元素&lt;a href=&quot;lang_select#compound&quot;&gt;化合物选择&lt;/a&gt;一种使用&lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt;子句，但一个&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单的SELECT&lt;/a&gt;，它由只是一个&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;子句不能由前面&lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt;子句。</target>
        </trans-unit>
        <trans-unit id="df491b521dc505e42bc3c6ecd099baa148547e6b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; can also be used to search and sort at the same time. Consider the following:</source>
          <target state="translated">一个&lt;a href=&quot;queryplanner#covidx&quot;&gt;覆盖索引&lt;/a&gt;也可用于在同一时间搜索和整理。考虑以下：</target>
        </trans-unit>
        <trans-unit id="871606b16605f413dc5599aac71b78fa3849a872" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; is an interface to an external storage or computation engine that appears to be a table but does not actually store information in the database file.</source>
          <target state="translated">一个&lt;a href=&quot;vtab&quot;&gt;虚表&lt;/a&gt;是，似乎是一个表，但实际上并不在数据库中存储文件信息的外部存储或计算引擎的接口。</target>
        </trans-unit>
        <trans-unit id="df4e6c14456215b9d0962cb62cb7b05235ec1b11" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; is an object that presents an SQL table interface but which is not stored in the database file, at least not directly. The virtual table mechanism is a feature of SQLite that allows SQLite to access and manipulate resources other than bits in the database file using the powerful SQL query language.</source>
          <target state="translated">甲&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;是一个对象，呈现SQL表接口，但没有存储在数据库中的文件，至少不能直接。虚拟表机制是SQLite的一项功能，它允许SQLite使用强大的SQL查询语言访问和操纵数据库文件中除位以外的资源。</target>
        </trans-unit>
        <trans-unit id="68d8302bde332ff69849e87aae361fdd6eed88bd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that contains &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; can be used like a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; in the FROM clause. The arguments to the table-valued function become constraints on the HIDDEN columns of the virtual table. Additional information can be found in the &lt;a href=&quot;vtab#tabfunc2&quot;&gt;virtual table documentation&lt;/a&gt;.</source>
          <target state="translated">甲&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;包含&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏的列&lt;/a&gt;可用于像一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;在FROM子句。表值函数的参数成为对虚拟表的HIDDEN列的约束。可以在&lt;a href=&quot;vtab#tabfunc2&quot;&gt;虚拟表文档中&lt;/a&gt;找到其他信息。</target>
        </trans-unit>
        <trans-unit id="d9a4d2f7abc06c64a3d373982c1067a695d076ac" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that contains &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; can be used like a table-valued function in the FROM clause of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The arguments to the table-valued function become constraints on the HIDDEN columns of the virtual table.</source>
          <target state="translated">一个&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;，其中包含&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏的列&lt;/a&gt;可用于像在从子句表值函数&lt;a href=&quot;lang_select&quot;&gt;的SELECT&lt;/a&gt;语句。表值函数的参数成为对虚拟表的HIDDEN列的约束。</target>
        </trans-unit>
        <trans-unit id="6f54a772ec3e29fda7795793266725eca1b672c5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; containing one row for each &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; associated with an open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，其中每个与打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备语句&lt;/a&gt;都包含一行。</target>
        </trans-unit>
        <trans-unit id="856349bba241130042131d7b4885683066e751c5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; for decomposing a JSON string.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数，&lt;/a&gt;用于分解JSON字符串。</target>
        </trans-unit>
        <trans-unit id="0582a0885ca700a90a04a8eff4c47df7102e8b08" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; returning a sequence of increasing integers, modeled after the table-valued function by the same name in PostgreSQL.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;返回一个递增的整数序列，该表值函数在表值函数之后以PostgreSQL中的相同名称建模。</target>
        </trans-unit>
        <trans-unit id="cb2741cf2cdf7ad64ce11cd345c855b98d1f85eb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; returning one row for each file in a selected file hierarchy of the host computer. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to help implement the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，为主机选择的文件层次结构中的每个文件返回一行。通过使用&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;帮助实施&lt;a href=&quot;cli#sqlar&quot;&gt;.ARCHIVE命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="373d830be5eb15d2da2a61288dc21f7719b3437c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; that allows a C-language array of integers, doubles, or strings to be used as table in a query.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，允许将C，整数，双精度或字符串数​​组用作查询中的表。</target>
        </trans-unit>
        <trans-unit id="c7e525a231144d654e7b02c354858c4739a1f24e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; which, in combination with a co-packaged &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; provides information on the number of system calls performed by SQLite.</source>
          <target state="translated">甲&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，其在具有共同封装的组合&lt;a href=&quot;vfs#shim&quot;&gt;VFS垫片&lt;/a&gt;提供了关于由SQLite的执行系统调用的次数的信息。</target>
        </trans-unit>
        <trans-unit id="1b6d070d5ecc711101d38eeaab3df0bef09ff2fd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; consists of a header followed by zero or more &quot;frames&quot;. Each frame records the revised content of a single page from the database file. All changes to the database are recorded by writing frames into the WAL. Transactions commit when a frame is written that contains a commit marker. A single WAL can and usually does record multiple transactions. Periodically, the content of the WAL is transferred back into the database file in an operation called a &quot;checkpoint&quot;.</source>
          <target state="translated">甲&lt;a href=&quot;wal#walfile&quot;&gt;WAL文件&lt;/a&gt;由一个标题，随后是零个或多个&amp;ldquo;帧&amp;rdquo;。每个框架记录数据库文件中单个页面的修订内容。通过将帧写入WAL记录对数据库的所有更改。写入包含提交标记的框架时，事务将提交。单个WAL可以并且通常确实记录多个事务。周期性地，WAL的内容通过称为&amp;ldquo;检查点&amp;rdquo;的操作被传输回数据库文件。</target>
        </trans-unit>
        <trans-unit id="0a26bbd25ee7f100819f3c23deb01a412e2b8ae6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;&lt;i&gt;clean page&lt;/i&gt;&lt;/b&gt; is one for which the cached data currently matches the contents of the corresponding page of the database file. The page has not been modified since it was loaded from the file.</source>
          <target state="translated">一个&lt;b&gt;&lt;i&gt;干净的页面&lt;/i&gt;&lt;/b&gt;是为其缓存的数据当前数据库文件的相应页面的内容相匹配。由于页面是从文件加载的，因此尚未修改。</target>
        </trans-unit>
        <trans-unit id="3149daa49a57f043076bca55d34c79bbf2a94c10" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;&lt;i&gt;dirty page&lt;/i&gt;&lt;/b&gt; is a</source>
          <target state="translated">一个&lt;b&gt;&lt;i&gt;脏页&lt;/i&gt;&lt;/b&gt;是一个</target>
        </trans-unit>
        <trans-unit id="a631580fd38df6770ba8186e0d9bd01ddb2b0586" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;CHECK&lt;/b&gt; constraint may be attached to a column definition or specified as a table constraint. In practice it makes no difference. Each time a new row is inserted into the table or an existing row is updated, the expression associated with each CHECK constraint is evaluated and cast to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. If the result is zero (integer value 0 or real value 0.0), then a constraint violation has occurred. If the CHECK expression evaluates to NULL, or any other non-zero value, it is not a constraint violation. The expression of a CHECK constraint may not contain a subquery.</source>
          <target state="translated">甲&lt;b&gt;CHECK&lt;/b&gt;约束可以被附接到一列定义或指定为表约束。实际上，这没有什么区别。每次将新行插入表中或更新现有行时，都会评估与每个CHECK约束关联的表达式，并将其转换为NUMERIC值，方法与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;相同。如果结果为零（整数值0或实数值0.0），则发生约束冲突。如果CHECK表达式的计算结果为NULL或任何其他非零值，则不是约束冲突。CHECK约束的表达式可能不包含子查询。</target>
        </trans-unit>
        <trans-unit id="b22b413028503aa499aa22dd5a425b910c462c65" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DELETE&lt;/b&gt;. A DELETE change represents a row, identified by its primary key values, to remove from a database table. The payload of a DELETE change consists of the values for all fields of the deleted row.</source>
          <target state="translated">一个&lt;b&gt;DELETE&lt;/b&gt;。DELETE更改表示由其主键值标识的要从数据库表中删除的行。DELETE更改的有效负载由已删除行的所有字段的值组成。</target>
        </trans-unit>
        <trans-unit id="dc432bfd116ade86c9a957fa16cdde115d0191b7" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;NOT NULL&lt;/b&gt; constraint may only be attached to a column definition, not specified as a table constraint. Not surprisingly, a NOT NULL constraint dictates that the associated column may not contain a NULL value. Attempting to set the column value to NULL when inserting a new row or updating an existing one causes a constraint violation.</source>
          <target state="translated">甲&lt;b&gt;NOT NULL&lt;/b&gt;约束可以仅被连接到一个列定义，没有被指定为表约束。毫不奇怪，NOT NULL约束指示关联的列可能不包含NULL值。在插入新行或更新现有行时尝试将列值设置为NULL会导致约束冲突。</target>
        </trans-unit>
        <trans-unit id="fdf1ca3328f33f13bfd67487e1be34ff9035a3f1" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;UNIQUE&lt;/b&gt; constraint is similar to a PRIMARY KEY constraint, except that a single table may have any number of UNIQUE constraints. For each UNIQUE constraint on the table, each row must contain a unique combination of values in the columns identified by the UNIQUE constraint. For the purposes of UNIQUE constraints, NULL values are considered distinct from all other values, including other NULLs. As with PRIMARY KEYs, a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; is not supported.</source>
          <target state="translated">甲&lt;b&gt;UNIQUE&lt;/b&gt;约束类似于PRIMARY KEY约束，不同的是一个单一的表可以具有任意数量的UNIQUE约束。对于表上的每个UNIQUE约束，每一行都必须在由UNIQUE约束标识的列中包含值的唯一组合。出于UNIQUE约束的目的，NULL值被认为与所有其他值（包括其他NULL）不同。与PRIMARY KEYs一样，UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;子句必须仅包含列名- 不支持在UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;的&lt;a href=&quot;syntax/indexed-column&quot;&gt;索引列&lt;/a&gt;中使用表达式。</target>
        </trans-unit>
        <trans-unit id="e32809ac84c6935c3f1d547f445c33b4edd8239b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;configuration option&lt;/b&gt; consists of an FTS5 bareword - the option name - followed by an &quot;=&quot; character, followed by the option value. The option value is specified using either a single FTS5 bareword or a string literal, again quoted in any manner acceptable to the SQLite core. For example:</source>
          <target state="translated">甲&lt;b&gt;配置选项&lt;/b&gt;包括一个FTS5裸词的-选项名称-后跟一个&amp;ldquo;=&amp;rdquo;字符，接着是选项值。使用单个FTS5裸字或字符串文字（通过SQLite核心可接受的任何方式再次引用）指定选项值。例如：</target>
        </trans-unit>
        <trans-unit id="a32195c7a6fc427bc8287dc1bfc7fa1047963781" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;delete file&lt;/b&gt; operation (invoked by a call to the VFS xDelete() method) is assumed to be an atomic and durable operation.</source>
          <target state="translated">甲&lt;b&gt;删除文件&lt;/b&gt;操作（通过向VFS xDelete（）方法的调用被调用）被假定为是一个原子和耐用操作。</target>
        </trans-unit>
        <trans-unit id="81eb114ea2af4078474a1cbfc4dcbef58bf150be" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;write file&lt;/b&gt; operation modifies the contents of an existing file within the file-system. It may also increase the size of the file. The effects of a</source>
          <target state="translated">甲&lt;b&gt;写文件&lt;/b&gt;操作修改所述文件系统内的现有文件的内容。它还可能会增加文件的大小。一个的影响</target>
        </trans-unit>
        <trans-unit id="837ab313b69fffe66bfeb6474a06eb42c1252970" translate="yes" xml:space="preserve">
          <source>A BLOB referenced by sqlite3_blob_open() may be read using the &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface and modified by using &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; can be moved to a different row of the same table using the &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. However, the column, table, or database of a &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; cannot be changed after the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is opened.</source>
          <target state="translated">通过sqlite3_blob_open引用的BLOB（）可以使用被读&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口，并通过使用改性&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（） &lt;/a&gt;。可以使用&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;接口将&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;移到同一表的另一行。但是，打开&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;后，不能更改&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;的列，表或数据库。</target>
        </trans-unit>
        <trans-unit id="ee0640d0645ccd75a4dc327263af24976feba6da" translate="yes" xml:space="preserve">
          <source>A BLOB referenced by sqlite3_blob_open() may be read using the &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface and modified by using &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;. The &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; can be moved to a different row of the same table using the &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. However, the column, table, or database of a &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; cannot be changed after the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is opened.</source>
          <target state="translated">通过sqlite3_blob_open引用的BLOB（）可以使用被读&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口，并通过使用改性&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（） &lt;/a&gt;。可以使用&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;接口将&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;移到同一表的另一行。但是，打开&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;后，不能更改&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;的列，表或数据库。</target>
        </trans-unit>
        <trans-unit id="13017a10bf35a23815a31249ff53b230bf8d7de4" translate="yes" xml:space="preserve">
          <source>A C99 compiler such as GCC (including MinGW variants for Windows), Clang, or MSVC</source>
          <target state="translated">C99编译器,如GCC(包括Windows的MinGW变体)、Clang或MSVC。</target>
        </trans-unit>
        <trans-unit id="e474401c2fb781e6f6b3a595d076e4ab1e391bd7" translate="yes" xml:space="preserve">
          <source>A CASE expression serves a role similar to IF-THEN-ELSE in other programming languages.</source>
          <target state="translated">CASE表达式的作用类似于其他编程语言中的IF-THEN-ELSE。</target>
        </trans-unit>
        <trans-unit id="6efc18580100345c76fd2798e95f8e107ce315e6" translate="yes" xml:space="preserve">
          <source>A CAST expression of the form &quot;CAST(</source>
          <target state="translated">CAST表达式为 &quot;CAST(</target>
        </trans-unit>
        <trans-unit id="691cb52a8521a0ce5d8225252c59ceffa19ac6f9" translate="yes" xml:space="preserve">
          <source>A CHECK constraint may be attached to a column definition or specified as a table constraint. In practice it makes no difference. Each time a new row is inserted into the table or an existing row is updated, the expression associated with each CHECK constraint is evaluated and cast to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. If the result is zero (integer value 0 or real value 0.0), then a constraint violation has occurred. If the CHECK expression evaluates to NULL, or any other non-zero value, it is not a constraint violation. The expression of a CHECK constraint may not contain a subquery.</source>
          <target state="translated">CHECK约束可以附加到列定义或指定为表约束。实际上，这没有什么区别。每次将新行插入表中或更新现有行时，都会评估与每个CHECK约束关联的表达式，并将其转换为NUMERIC值，方法与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;相同。如果结果为零（整数值0或实数值0.0），则发生约束冲突。如果CHECK表达式的计算结果为NULL或任何其他非零值，则不是约束冲突。 CHECK约束的表达式可能不包含子查询。</target>
        </trans-unit>
        <trans-unit id="e31c615e2a94e5252f4b80b762cba6c0141f5cde" translate="yes" xml:space="preserve">
          <source>A COLLATE operator has the same affinity as its left-hand side operand.</source>
          <target state="translated">COLLATE运算符与它的左手操作数具有相同的亲和力。</target>
        </trans-unit>
        <trans-unit id="636b65c339e5b4cff4c6abf3acf46d5d5c4067ad" translate="yes" xml:space="preserve">
          <source>A Frame object (Used by &lt;a href=&quot;opcode#subprog&quot;&gt;subprograms&lt;/a&gt; - see &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt;)</source>
          <target state="translated">一个Frame对象（由&lt;a href=&quot;opcode#subprog&quot;&gt;子程序使用&lt;/a&gt; -请参见&lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5dd1dbb7ef5708d18278d3388bedd2577e0b3815" translate="yes" xml:space="preserve">
          <source>A Handle To An Open BLOB</source>
          <target state="translated">一个打开BLOB的手柄</target>
        </trans-unit>
        <trans-unit id="ee4b6876d554bc64586717c25f1a6cf5fec63471" translate="yes" xml:space="preserve">
          <source>A LEFT JOIN can sometimes be converted into an ordinary JOIN if there are terms in the WHERE clause that guarantee that the two joins will give identical results. In particular, if any column in the right-hand table of the LEFT JOIN must be non-NULL in order for the WHERE clause to be true, then the LEFT JOIN is demoted to an ordinary JOIN.</source>
          <target state="translated">如果在WHERE子句中有条款保证两个联接的结果相同,那么有时可以将LEFT JOIN转换为普通JOIN。特别是,如果LEFT JOIN右侧表中的任何一列必须是非NULL才能使WHERE子句为真,那么LEFT JOIN就会降级为普通JOIN。</target>
        </trans-unit>
        <trans-unit id="5c5c40156ee6de3eca7fbc6151e6b7fa931030d3" translate="yes" xml:space="preserve">
          <source>A NOT NULL constraint may only be attached to a column definition, not specified as a table constraint. Not surprisingly, a NOT NULL constraint dictates that the associated column may not contain a NULL value. Attempting to set the column value to NULL when inserting a new row or updating an existing one causes a constraint violation.</source>
          <target state="translated">NOT NULL 约束只能附加在列定义上,而不能指定为表约束。不足为奇的是,NOT NULL约束要求关联的列不能包含一个NULL值。当插入新行或更新现有的行时,试图将列的值设置为NULL会导致违反约束条件。</target>
        </trans-unit>
        <trans-unit id="3401d49e10d9d0dae1ba0bfad0af249daa8b1e6a" translate="yes" xml:space="preserve">
          <source>A NULL result is considered untrue when evaluating WHEN terms.</source>
          <target state="translated">当评估WHEN术语时,NULL结果被认为是不真实的。</target>
        </trans-unit>
        <trans-unit id="f6e08d53bb50141ecc1637476fc883985d9f9ebb" translate="yes" xml:space="preserve">
          <source>A NULL value</source>
          <target state="translated">一个NULL值</target>
        </trans-unit>
        <trans-unit id="bffde3dc2b5165819167f5c21c867d724ac37b28" translate="yes" xml:space="preserve">
          <source>A NULL value is not changed by this routine. It remains NULL.</source>
          <target state="translated">NULL值不会被这个例程改变。它将保持为NULL。</target>
        </trans-unit>
        <trans-unit id="e254962b9e0cb1aea3bfd54acadf87214effe474" translate="yes" xml:space="preserve">
          <source>A PENDING lock means that the process holding the lock wants to write to the database as soon as possible and is just waiting on all current SHARED locks to clear so that it can get an EXCLUSIVE lock. No new SHARED locks are permitted against the database if a PENDING lock is active, though existing SHARED locks are allowed to continue.</source>
          <target state="translated">PENDING锁意味着持有该锁的进程希望尽快向数据库写入数据,只是在等待所有当前的SHARED锁清空,以便得到一个EXCLUSIVE锁。如果PENDING锁处于活动状态,则不允许对数据库产生新的SHARED锁,不过允许现有的SHARED锁继续存在。</target>
        </trans-unit>
        <trans-unit id="792513b3669ee7042166df65b3b518052dfec139" translate="yes" xml:space="preserve">
          <source>A RESERVED lock means that the process is planning on writing to the database file at some point in the future but that it is currently just reading from the file. Only a single RESERVED lock may be active at one time, though multiple SHARED locks can coexist with a single RESERVED lock. RESERVED differs from PENDING in that new SHARED locks can be acquired while there is a RESERVED lock.</source>
          <target state="translated">一个RESERVED锁意味着进程计划在未来的某个时刻向数据库文件写入,但目前只是从文件中读取。在同一时间内只能有一个RESERVED锁处于活动状态,尽管多个SHARED锁可以与一个RESERVED锁共存。RESERVED与PENDING的不同之处在于,在有RESERVED锁的情况下,可以获取新的SHARED锁。</target>
        </trans-unit>
        <trans-unit id="b7573b1578e511f894b8024c7cc3d97b302451de" translate="yes" xml:space="preserve">
          <source>A RowSet object (See the &lt;a href=&quot;opcode#RowSetAdd&quot;&gt;RowSetAdd&lt;/a&gt;, &lt;a href=&quot;opcode#RowSetRead&quot;&gt;RowSetRead&lt;/a&gt;, and &lt;a href=&quot;opcode#RowSetTest&quot;&gt;RowSetTest&lt;/a&gt; opcodes)</source>
          <target state="translated">RowSet对象（请参见&lt;a href=&quot;opcode#RowSetAdd&quot;&gt;RowSetAdd&lt;/a&gt;，&lt;a href=&quot;opcode#RowSetRead&quot;&gt;RowSetRead&lt;/a&gt;和&lt;a href=&quot;opcode#RowSetTest&quot;&gt;RowSetTest&lt;/a&gt;操作码）</target>
        </trans-unit>
        <trans-unit id="7145fed841f2e927e89061340853d861304c9e1a" translate="yes" xml:space="preserve">
          <source>A Slightly More Complex Query</source>
          <target state="translated">稍微复杂一点的查询</target>
        </trans-unit>
        <trans-unit id="be9ffde27510374ea69b59f34f53d3d90e8acc69" translate="yes" xml:space="preserve">
          <source>A TEXT value is less than a BLOB value. When two TEXT values are compared an appropriate collating sequence is used to determine the result.</source>
          <target state="translated">一个TEXT值小于一个BLOB值。当两个TEXT值进行比较时,会使用适当的整理序列来确定结果。</target>
        </trans-unit>
        <trans-unit id="46f405c1f7939c335f90c63056ef77e55a911955" translate="yes" xml:space="preserve">
          <source>A Template For SELECT Programs</source>
          <target state="translated">SELECT程序模板</target>
        </trans-unit>
        <trans-unit id="d9fc87b4657ba9032bc3c9439eec37292a4b8792" translate="yes" xml:space="preserve">
          <source>A UNIQUE constraint is similar to a PRIMARY KEY constraint, except that a single table may have any number of UNIQUE constraints. For each UNIQUE constraint on the table, each row must contain a unique combination of values in the columns identified by the UNIQUE constraint. For the purposes of UNIQUE constraints, NULL values are considered distinct from all other values, including other NULLs. As with PRIMARY KEYs, a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; is not supported.</source>
          <target state="translated">UNIQUE约束与PRIMARY KEY约束相似，不同之处在于单个表可以具有任意数量的UNIQUE约束。对于表上的每个UNIQUE约束，每一行都必须在由UNIQUE约束标识的列中包含值的唯一组合。出于UNIQUE约束的目的，NULL值被认为与所有其他值（包括其他NULL）不同。与PRIMARY KEYs一样，UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;子句必须仅包含列名-不支持在UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;的&lt;a href=&quot;syntax/indexed-column&quot;&gt;索引列&lt;/a&gt;中使用表达式。</target>
        </trans-unit>
        <trans-unit id="a236f9f7962be97b127c37048fd412e1478ca675" translate="yes" xml:space="preserve">
          <source>A URI filename can optionally be followed by a query string. The query string consists of text following the first &quot;&lt;code&gt;?&lt;/code&gt;&quot; character but excluding the optional fragment that begins with &quot;&lt;code&gt;#&lt;/code&gt;&quot;. The query string is divided into key/value pairs. We usually refer to these key/value pairs as &quot;query parameters&quot;. Key/value pairs are separated by a single &quot;&lt;code&gt;&amp;amp;&lt;/code&gt;&quot; character. The key comes first and is separated from the value by a single &quot;&lt;code&gt;=&lt;/code&gt;&quot; character. Both key and value may contain &lt;b&gt;%HH&lt;/b&gt; escape sequences.</source>
          <target state="translated">URI文件名可以选择后面跟一个查询字符串。查询字符串由第一个&amp;ldquo; &lt;code&gt;?&lt;/code&gt; &amp;rdquo;字符后的文本组成，但不包括以&amp;ldquo; &lt;code&gt;#&lt;/code&gt; &amp;rdquo; 开头的可选片段。查询字符串分为键/值对。我们通常将这些键/值对称为&amp;ldquo;查询参数&amp;rdquo;。键/值对由单个&amp;ldquo; &lt;code&gt;&amp;amp;&lt;/code&gt; &amp;rdquo;字符分隔。该键位于第一个位置，并且与值之间用单个&amp;ldquo; &lt;code&gt;=&lt;/code&gt; &amp;rdquo;字符分隔。键和值都可以包含&lt;b&gt;％HH&lt;/b&gt;转义序列。</target>
        </trans-unit>
        <trans-unit id="99cb44555e9b0216321b2979e33a8e1ad8600bba" translate="yes" xml:space="preserve">
          <source>A UTF-16 byte-order-mark (BOM) is embedded at the beginning of an SQL string literal value inserted into an FTS3 table. For example:</source>
          <target state="translated">一个UTF-16字节顺序标记(BOM)被嵌入到插入到FTS3表中的SQL字符串文字值的开头。例如:</target>
        </trans-unit>
        <trans-unit id="b929656e7ccea842d99a6cdd674c24cfe9ebde24" translate="yes" xml:space="preserve">
          <source>A VACUUM will fail if there is an open transaction on the database connection that is attempting to run the VACUUM. Unfinalized SQL statements typically hold a read transaction open, so the VACUUM might fail if there are unfinalized SQL statements on the same connection. VACUUM (but not VACUUM INTO) is a write operation and so if another database connection is holding a lock that prevents writes, then the VACUUM will fail.</source>
          <target state="translated">如果在试图运行VACUUM的数据库连接上有一个开放的事务,那么VACUUM将失败。未最终确定的SQL语句通常会打开一个读事务,所以如果在同一个连接上有未最终确定的SQL语句,那么VACUUM可能会失败。VACUUM(但不是VACUUM INTO)是一个写操作,所以如果另一个数据库连接持有一个阻止写的锁,那么VACUUM将失败。</target>
        </trans-unit>
        <trans-unit id="4b3d695cfd113fe761861c75383b2e044c2e7e2b" translate="yes" xml:space="preserve">
          <source>A VALUES clause cannot be followed by &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;.</source>
          <target state="translated">VALUES子句后不能跟&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ab21b8d4d0b0af0b5e16d3d9e8b9adc5cafa097" translate="yes" xml:space="preserve">
          <source>A VALUES clause cannot be followed by &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;.</source>
          <target state="translated">VALUES子句不能跟在&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY之后&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05d95a064571927a9a88c570d25a1e13033bf432" translate="yes" xml:space="preserve">
          <source>A VDBE program begins execution on instruction 0 and continues with successive instructions until it either (1) encounters a fatal error, (2) executes a Halt instruction, or (3) advances the program counter past the last instruction of the program. When the VDBE completes execution, all open database cursors are closed, all memory is freed, and everything is popped from the stack. So there are never any worries about memory leaks or undeallocated resources.</source>
          <target state="translated">VDBE程序从指令0开始执行,并继续执行连续的指令,直到(1)遇到致命错误,(2)执行Halt指令,或(3)将程序计数器推进到程序的最后一条指令之后。当VDBE完成执行后,所有打开的数据库游标都被关闭,所有的内存都被释放,所有的东西都从堆栈中弹出。因此,永远不会担心内存泄漏或未分配资源的问题。</target>
        </trans-unit>
        <trans-unit id="0432168769d5fe51afb6dbaedceaf1d86ce22932" translate="yes" xml:space="preserve">
          <source>A VFS object is an instance of the following structure:</source>
          <target state="translated">一个VFS对象是以下结构的实例。</target>
        </trans-unit>
        <trans-unit id="ebb27bb2698737a1c139441a44f3243078e096d2" translate="yes" xml:space="preserve">
          <source>A WHERE-clause term that uses the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator can sometimes be used with an index to do a range search, almost as if the LIKE or GLOB were an alternative to a &lt;a href=&quot;lang_expr#between&quot;&gt;BETWEEN&lt;/a&gt; operator. There are many conditions on this optimization:</source>
          <target state="translated">有时可以将使用&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的WHERE子句与索引一起使用以进行范围搜索，几乎就像LIKE或GLOB是&lt;a href=&quot;lang_expr#between&quot;&gt;BETWEEN&lt;/a&gt;运算符的替代方法一样。此优化有很多条件：</target>
        </trans-unit>
        <trans-unit id="df4f80b113ccea127e4d3021f3a4f02819b934ae" translate="yes" xml:space="preserve">
          <source>A WITH clause can contain ordinary common table expressions even if it includes the RECURSIVE keyword. The use of RECURSIVE does not force common table expressions to be recursive.</source>
          <target state="translated">一个WITH子句即使包含RECURSIVE关键字,也可以包含普通的普通表表达式。RECURSIVE的使用并不强制普通表表达式是递归的。</target>
        </trans-unit>
        <trans-unit id="f55340617c249beb5aa9dcbec3b3a452cd918cec" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table is a table that uses a &lt;a href=&quot;https://en.wikipedia.org/wiki/Database_index#Clustered&quot;&gt;Clustered Index&lt;/a&gt; as the primary key.</source>
          <target state="translated">WITHOUT ROWID表是使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Database_index#Clustered&quot;&gt;聚簇索引&lt;/a&gt;作为主键的表。</target>
        </trans-unit>
        <trans-unit id="fd8fd2213389a0089cdcbfb615d2045c57a83ef1" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table is an optimization that can reduce storage and processing requirements.</source>
          <target state="translated">WITHOUT ROWID表是一种优化,可以减少存储和处理需求。</target>
        </trans-unit>
        <trans-unit id="bfd83295099a678d051eac126141e86eda45f403" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table uses a different data design for the equivalent table.</source>
          <target state="translated">WITHOUT ROWID表对等价表采用不同的数据设计。</target>
        </trans-unit>
        <trans-unit id="cd77ad55fd4a01dbb8f0524dc072785f80da4f86" translate="yes" xml:space="preserve">
          <source>A ZIP archive appears to be a database containing a single table with the following schema:</source>
          <target state="translated">一个ZIP存档似乎是一个数据库,包含一个单一的表,其模式如下。</target>
        </trans-unit>
        <trans-unit id="8671aa0f63652c459215ac815d19beddc15e8e03" translate="yes" xml:space="preserve">
          <source>A ZIP archive is basically a key/value database, optimized for the case of write-once/read-many and for a relatively small number of distinct keys (a few hundred to a few thousand) each with a large BLOB as its value. A ZIP archive can be viewed as a &quot;pile-of-files&quot; database. This works, but it has some shortcomings relative to an SQLite database, as follows:</source>
          <target state="translated">一个ZIP归档基本上是一个键/值数据库,针对写一次/读多次的情况进行了优化,并且针对相对较少的不同键(几百到几千),每个键都有一个大的BLOB作为其值。一个ZIP归档文件可以被看作是一个 &quot;文件堆 &quot;数据库。这样做是可行的,但相对于SQLite数据库来说,它有一些不足之处,具体如下。</target>
        </trans-unit>
        <trans-unit id="31b75515041a194398c4ef9c7f4df42ebbf1ae1c" translate="yes" xml:space="preserve">
          <source>A b-tree page</source>
          <target state="translated">一个b-tree页面</target>
        </trans-unit>
        <trans-unit id="78e4a5662f4ab95c05c9b1089cf8d552e985bac1" translate="yes" xml:space="preserve">
          <source>A b-tree page is divided into regions in the following order:</source>
          <target state="translated">一个b-tree页面按以下顺序分为几个区域。</target>
        </trans-unit>
        <trans-unit id="50e24d6d35682efd44eaa4aca8795ead18d76998" translate="yes" xml:space="preserve">
          <source>A b-tree page is either a table b-tree page or an index b-tree page. All pages within each complete b-tree are of the same type: either table or index. There is one table b-trees in the database file for each rowid table in the database schema, including system tables such as &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;. There is one index b-tree in the database file for each index in the schema, including implied indexes created by uniqueness constraints. There are no b-trees associated with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Specific virtual table implementations might make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; for storage, but those shadow tables will have separate entries in the database schema. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables use index b-trees rather than a table b-trees, so there is one index b-tree in the database file for each &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The b-tree corresponding to the sqlite_schema table is always a table b-tree and always has a root page of 1. The sqlite_schema table contains the root page number for every other table and index in the database file.</source>
          <target state="translated">b树页面是表b树页面或索引b树页面。每个完整b树中的所有页面都属于同一类型：表或索引。对于数据库模式中的每个rowid表，数据库文件中都有一个表b树，其中包括诸如&lt;a href=&quot;schematab&quot;&gt;sqlite_schema之类的&lt;/a&gt;系统表。在数据库文件中，模式中的每个索引都有一个索引b树，包括由唯一性约束创建的隐式索引。没有与&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;关联的b树。特定的虚拟表实现可能会使用&lt;a href=&quot;vtab#xshadowname&quot;&gt;影子表&lt;/a&gt;进行存储，但是这些影子表在数据库架构中将具有单独的条目。&lt;a href=&quot;withoutrowid&quot;&gt;没有行&lt;/a&gt;表使用索引b树而不是表b树，因此数据库文件中的每个&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表都有一个索引b树。与sqlite_schema表相对应的b树始终是表b树，并且始终具有1的根页。sqlite_schema表包含数据库文件中所有其他表和索引的根页号。</target>
        </trans-unit>
        <trans-unit id="63a9edcac9a730619e0cfe51d4bfd7d8720cb6a9" translate="yes" xml:space="preserve">
          <source>A b-tree page is either a table b-tree page or an index b-tree page. All pages within each complete b-tree are of the same type: either table or index. There is one table b-trees in the database file for each rowid table in the database schema, including system tables such as sqlite_master. There is one index b-tree in the database file for each index in the schema, including implied indexes created by uniqueness constraints. There are no b-trees associated with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Specific virtual table implementations might make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; for storage, but those shadow tables will have separate entries in the database schema. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables use index b-trees rather than a table b-trees, so there is one index b-tree in the database file for each &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The b-tree corresponding to the sqlite_master table is always a table b-tree and always has a root page of 1. The sqlite_master table contains the root page number for every other table and index in the database file.</source>
          <target state="translated">b树页面是表b树页面或索引b树页面。每个完整b树中的所有页面都属于同一类型：表或索引。数据库文件中数据库模式中的每个rowid表（包括系统表，例如sqlite_master）都有一个表b树。在数据库文件中，对于模式中的每个索引都有一个索引b树，包括由唯一性约束创建的隐式索引。没有与&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;关联的b树。特定的虚拟表实现可能使用&lt;a href=&quot;vtab#xshadowname&quot;&gt;影子表&lt;/a&gt;进行存储，但是这些影子表在数据库架构中将具有单独的条目。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表使用索引b树而不是表b树，因此在数据库文件中每个索引树都有一个索引b树。&lt;a href=&quot;withoutrowid&quot;&gt;没有ROWID&lt;/a&gt;表。与sqlite_master表相对应的b树始终是表b树，并且始终具有1的根页。sqlite_master表包含数据库文件中所有其他表和索引的根页号。</target>
        </trans-unit>
        <trans-unit id="e8872d8050defbccbb334917b38d2ca8e1564dc7" translate="yes" xml:space="preserve">
          <source>A b-tree page is either an interior page or a leaf page. A leaf page contains keys and in the case of a table b-tree each key has associated data. An interior page contains K keys together with K+1 pointers to child b-tree pages. A &quot;pointer&quot; in an interior b-tree page is just the 31-bit integer page number of the child page.</source>
          <target state="translated">一个b树页是内页或叶页。叶页包含键,在表b树的情况下,每个键有相关的数据。一个内部页包含K个键以及K+1个指向子b树页的指针。内部b树页中的 &quot;指针 &quot;只是子页的31位整数页号。</target>
        </trans-unit>
        <trans-unit id="699cff296a83204dc98e7a48d9a107ba2249cdf6" translate="yes" xml:space="preserve">
          <source>A b-tree page is either an interior page or a leaf page. A leaf page contains keys and in the case of a table b-tree each key has associated data. An interior page contains K keys together with K+1 pointers to child b-tree pages. A &quot;pointer&quot; in an interior b-tree page is just the 32-bit unsigned integer page number of the child page.</source>
          <target state="translated">一个b树页是内页或叶页。叶页包含键,在表b树的情况下,每个键有相关的数据。一个内部页包含K个键以及K+1个指向子b树页的指针。内部b树页中的 &quot;指针 &quot;只是子页的32位无符号整数页号。</target>
        </trans-unit>
        <trans-unit id="3cfdea8b36cb23cd0493dd048fd3164b70e3686a" translate="yes" xml:space="preserve">
          <source>A b-tree root page. The page number should be zero.</source>
          <target state="translated">一个b树根页面。页码应该是零。</target>
        </trans-unit>
        <trans-unit id="928af6fa4be08c1c19873c470bbd5a2625ae1f46" translate="yes" xml:space="preserve">
          <source>A better user experience</source>
          <target state="translated">更好的用户体验</target>
        </trans-unit>
        <trans-unit id="e7bff53ba8dac51c9265761e2c2a4ff11158671e" translate="yes" xml:space="preserve">
          <source>A bug in SQLite versions prior to 3.6.0 (2008-07-16) caused the database to be reported as corrupt if any of the last 6 entries in the freelist trunk page array contained non-zero values. Newer versions of SQLite do not have this problem. However, newer versions of SQLite still avoid using the last six entries in the freelist trunk page array in order that database files created by newer versions of SQLite can be read by older versions of SQLite.</source>
          <target state="translated">在3.6.0(2008-07-16)之前的SQLite版本中,如果freelist trunk页数组中的最后6个条目中的任何一个都包含非零值,则会导致数据库被报告为损坏。较新版本的SQLite不会出现这个问题。但是,新版本的SQLite仍然避免使用freelist trunk页数组中的最后6个条目,以便旧版本的SQLite能够读取新版本的SQLite创建的数据库文件。</target>
        </trans-unit>
        <trans-unit id="89c8d4cd9f6ee835f0aa8d6326cf3bfa8b9da543" translate="yes" xml:space="preserve">
          <source>A build of the &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; requires three source files:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;命令行界面的&lt;/a&gt;构建需要三个源文件：</target>
        </trans-unit>
        <trans-unit id="df3827a0612890cae9712a71ec1095000e1430ec" translate="yes" xml:space="preserve">
          <source>A busy handler must not close the database connection or &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that invoked the busy handler.</source>
          <target state="translated">繁忙处理程序不得关闭调用繁忙处理程序的数据库连接或&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3ac4c495afe83c385509d9e3c6a5a309fa36de0" translate="yes" xml:space="preserve">
          <source>A busy handler must not close the database connection or &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that invoked the busy handler.</source>
          <target state="translated">繁忙处理程序不得关闭调用繁忙处理程序的数据库连接或&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="243759da16d869bd57d5e12d61c35e1be1f805d8" translate="yes" xml:space="preserve">
          <source>A bytecoded program in SQLite consists of one or more instructions. Each instruction has an opcode and five operands named P1, P2 P3, P4, and P5. The P1, P2, and P3 operands are 32-bit signed integers. These operands often refer to registers. For instructions that operate on b-tree cursors, the P1 operand is usually the cursor number. For jump instructions, P2 is usually the jump destination. P4 may be a 32-bit signed integer, a 64-bit signed integer, a 64-bit floating point value, a string literal, a Blob literal, a pointer to a collating sequence comparison function, or a pointer to the implementation of an application-defined SQL function, or various other things. P5 is an 16-bit unsigned integer normally used to hold flags. Bits of the P5 flag can sometimes affect the opcode in subtle ways. For example, if the SQLITE_NULLEQ (0x0080) bit of the P5 operand is set on the &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; opcode, then the NULL values compare equal to one another. Otherwise NULL values compare different from one another.</source>
          <target state="translated">SQLite中的字节编码程序由一个或多个指令组成。每个指令都有一个操作码和五个名为P1，P2，P3，P4和P5的操作数。 P1，P2和P3操作数是32位带符号整数。这些操作数通常引用寄存器。对于对b树游标进行操作的指令，P1操作数通常是游标编号。对于跳转指令，P2通常是跳转目标。 P4可以是32位带符号整数，64位带符号整数，64位浮点值，字符串文字，Blob文字，指向整理序列比较功能的指针或指向实现的指针。应用程序定义的SQL函数或其他各种东西。 P5是16位无符号整数，通常用于保存标志。 P5标志的位有时会以微妙的方式影响操作码。例如，如果P5操作数的SQLITE_NULLEQ（0x0080）位设置为&lt;a href=&quot;opcode#Eq&quot;&gt;式&lt;/a&gt;操作码，则NULL值比较彼此相等。否则，NULL值彼此比较不同。</target>
        </trans-unit>
        <trans-unit id="af46994da07ef61f25c2f526b23c9597924b8bf6" translate="yes" xml:space="preserve">
          <source>A cache spill causes the lock on the database file to escalate from reserved to exclusive. This reduces concurrency. A cache spill also causes extra disk flush or fsync operations to occur and these operations are slow, hence a cache spill can seriously reduce performance. For these reasons a cache spill is avoided whenever possible.</source>
          <target state="translated">缓存溢出会导致数据库文件上的锁从保留升级到独占。这降低了并发性。缓存溢出也会导致额外的磁盘刷新或fsync操作发生,这些操作很慢,因此缓存溢出会严重降低性能。基于这些原因,尽可能避免缓存溢出。</target>
        </trans-unit>
        <trans-unit id="952fa12450de75899de19565202a5c251a96a2d4" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; will fail if the database connection D does not know that the database file for schema S is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. A database connection might not know that the database file is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; if there has been no prior I/O on that database connection, or if the database entered &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; after the most recent I/O on the database connection. (Hint: Run &quot;&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;&quot; against a newly opened database connection in order to make it ready to use snapshots.)</source>
          <target state="translated">如果数据库连接D不知道模式S的数据库文件处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;，则&lt;/a&gt;对sqlite3_snapshot_open（D，S，P）的调用将失败。如果该数据库连接上没有先前的I / O，或者数据库在数据库连接上的最新I / O之后进入&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;，则数据库连接可能不知道该数据库文件处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;。（提示：针对新打开的数据库连接运行&amp;ldquo; &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; &amp;rdquo;，以使其准备好使用快照。）</target>
        </trans-unit>
        <trans-unit id="bbce2a7d14e5d524aa34fd10caef37f64f6407da" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; will fail if the database connection D does not know that the database file for schema S is in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. A database connection might not know that the database file is in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; if there has been no prior I/O on that database connection, or if the database entered &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; after the most recent I/O on the database connection. (Hint: Run &quot;&lt;a href=&quot;../pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;&quot; against a newly opened database connection in order to make it ready to use snapshots.)</source>
          <target state="translated">如果数据库连接D不知道模式S的数据库文件处于&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;&lt;a href=&quot;snapshot_open&quot;&gt;，则&lt;/a&gt;对sqlite3_snapshot_open（D，S，P）的调用将失败。如果该数据库连接上没有先前的I / O，或者数据库在数据库连接上的最新I / O之后进入&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;，则数据库连接可能不知道该数据库文件处于&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;。（提示：针对新打开的数据库连接运行&amp;ldquo; &lt;a href=&quot;../pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; &amp;rdquo;，以使其准备好使用快照。）</target>
        </trans-unit>
        <trans-unit id="0586f982e4b86cf9914eab1aee68b8462d61681f" translate="yes" xml:space="preserve">
          <source>A call to one of the above APIs creates a new SQL function named by the second parameter (zQueryFunc or zGeom). When that SQL function appears on the right-hand side of the MATCH operator and the left-hand side of the MATCH operator is any column in the R*Tree virtual table, then the callback defined by the third argument (xQueryFunc or xGeom) is invoked to determine if a particular object or subtree overlaps the desired region.</source>
          <target state="translated">对上述API之一的调用会创建一个由第二个参数(zQueryFunc或zGeom)命名的新SQL函数。当该SQL函数出现在MATCH操作符的右侧,而MATCH操作符的左侧是R*Tree虚拟表中的任意列时,就会调用第三个参数(xQueryFunc或xGeom)定义的回调,以确定特定对象或子树是否与所需区域重叠。</target>
        </trans-unit>
        <trans-unit id="c0c9d57a6c7577d82ae5958b8d5845cbdeb488ef" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_backup_init() will fail, returning NULL, if there is already a read or read-write transaction open on the destination database.</source>
          <target state="translated">如果目标数据库上已经打开了一个读写事务,那么对sqlite3_backup_init()的调用就会失败,返回NULL。</target>
        </trans-unit>
        <trans-unit id="4f76c2f91f4bc291282ba8411c90b19f5effe501" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_initialize() is an &quot;effective&quot; call if it is the first time sqlite3_initialize() is invoked during the lifetime of the process, or if it is the first time sqlite3_initialize() is invoked following a call to sqlite3_shutdown(). Only an effective call of sqlite3_initialize() does any initialization. All other calls are harmless no-ops.</source>
          <target state="translated">如果一个对sqlite3_initialize()的调用是在进程的生命周期内第一次调用sqlite3_initialize(),或者是在调用sqlite3_shutdown()之后第一次调用sqlite3_initialize(),那么这个调用就是一个 &quot;有效 &quot;调用。只有对sqlite3_initialize()的有效调用才会进行任何初始化。所有其他的调用都是无害的。</target>
        </trans-unit>
        <trans-unit id="f8e50509528b4aaa1911d41bfa12097644542f6c" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_serialize(D,S,P,F) might return NULL even if the SQLITE_SERIALIZE_NOCOPY bit is omitted from argument F if a memory allocation error occurs.</source>
          <target state="translated">如果发生内存分配错误,即使参数F中省略了SQLITE_SERIALIZE_NOCOPY位,对sqlite3_serialize(D,S,P,F)的调用也可能返回NULL。</target>
        </trans-unit>
        <trans-unit id="9f09c1e84942a3f4e19f6efa6988346dd1bf454a" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_shutdown() is an &quot;effective&quot; call if it is the first call to sqlite3_shutdown() since the last sqlite3_initialize(). Only an effective call to sqlite3_shutdown() does any deinitialization. All other valid calls to sqlite3_shutdown() are harmless no-ops.</source>
          <target state="translated">如果一个对sqlite3_shutdown()的调用是自上次sqlite3_initialize()之后第一次调用sqlite3_shutdown(),那么它就是一个 &quot;有效 &quot;的调用。只有对sqlite3_shutdown()的有效调用才会进行去初始化。所有其他对sqlite3_shutdown()的有效调用都是无害的无操作。</target>
        </trans-unit>
        <trans-unit id="99d86897005e13370bf2940a7d68c4f6212b3540" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_snapshot_open() will fail to open if the specified snapshot has been overwritten by a &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. In this case SQLITE_ERROR_SNAPSHOT is returned.</source>
          <target state="translated">如果指定的快照已被&lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;覆盖，则对sqlite3_snapshot_open（）的调用将无法打开。在这种情况下，将返回SQLITE_ERROR_SNAPSHOT。</target>
        </trans-unit>
        <trans-unit id="b123d9394215fb466274e78d5f37dcb5d1971345" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_snapshot_open() will fail to open if the specified snapshot has been overwritten by a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. In this case SQLITE_ERROR_SNAPSHOT is returned.</source>
          <target state="translated">如果指定的快照已被&lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;覆盖，则对sqlite3_snapshot_open（）的调用将无法打开。在这种情况下，将返回SQLITE_ERROR_SNAPSHOT。</target>
        </trans-unit>
        <trans-unit id="83087efdcf0ff814df49782ed7673c5bb32e0d3c" translate="yes" xml:space="preserve">
          <source>A call to this method always follows a prior call to &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; and &lt;a href=&quot;vtab#xsync&quot;&gt;xSync&lt;/a&gt;.</source>
          <target state="translated">始终在先前调用&lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;和&lt;a href=&quot;vtab#xsync&quot;&gt;xSync&lt;/a&gt;之后调用此方法。</target>
        </trans-unit>
        <trans-unit id="53bba7422e25acf22029d539a9c3e869ba9eebb8" translate="yes" xml:space="preserve">
          <source>A call to this method always follows a prior call to &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;.</source>
          <target state="translated">始终在先前调用&lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;之后调用此方法。</target>
        </trans-unit>
        <trans-unit id="63823dedf5b482128e2d0cda7c31f9b2e6a816fd" translate="yes" xml:space="preserve">
          <source>A call to this routine stores N bytes of randomness into buffer P. The P parameter can be a NULL pointer.</source>
          <target state="translated">调用这个例程可以将N个字节的随机性存储到缓冲区P中,P参数可以是一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="67b22fa4e435ba9bc17d0619fd2c72b0454f69b7" translate="yes" xml:space="preserve">
          <source>A cast of a REAL value into an INTEGER results in the integer between the REAL value and zero that is closest to the REAL value. If a REAL is greater than the greatest possible signed integer (+9223372036854775807) then the result is the greatest possible signed integer and if the REAL is less than the least possible signed integer (-9223372036854775808) then the result is the least possible signed integer.</source>
          <target state="translated">将REAL值投向INTEGER的结果是REAL值和零之间最接近REAL值的整数。如果REAL大于最大可能的有符号整数(+9223372036854775807),那么结果就是最大可能的有符号整数,如果REAL小于最小可能的有符号整数(-9223372036854775808),那么结果就是最小可能的有符号整数。</target>
        </trans-unit>
        <trans-unit id="e33e1dcf808eee9d2baa613dd62fa64f94613f9b" translate="yes" xml:space="preserve">
          <source>A changegroup is an object used to combine two or more &lt;a href=&quot;../sessionintro#changeset&quot;&gt;changesets&lt;/a&gt; or &lt;a href=&quot;../sessionintro#changeset&quot;&gt;patchsets&lt;/a&gt;</source>
          <target state="translated">变更组是用于组合两个或多个&lt;a href=&quot;../sessionintro#changeset&quot;&gt;变更集&lt;/a&gt;或&lt;a href=&quot;../sessionintro#changeset&quot;&gt;补丁集的对象&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75339bffdc37dce20eb97a829cfa5c7aa288c842" translate="yes" xml:space="preserve">
          <source>A changegroup is an object used to combine two or more &lt;a href=&quot;sessionintro#changeset&quot;&gt;changesets&lt;/a&gt; or &lt;a href=&quot;sessionintro#changeset&quot;&gt;patchsets&lt;/a&gt;</source>
          <target state="translated">变更组是用于组合两个或多个&lt;a href=&quot;sessionintro#changeset&quot;&gt;变更集&lt;/a&gt;或&lt;a href=&quot;sessionintro#changeset&quot;&gt;补丁集的对象&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a455c489be5e742a9b6a79c8fd17fd21034f9a" translate="yes" xml:space="preserve">
          <source>A changeset blob is extracted from the session object using a call to &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; (or, if using patchsets, a call to the &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; function).</source>
          <target state="translated">使用对&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;的调用（或者，如果使用补丁集，则对&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;函数的调用）从会话对象中提取变更集blob 。</target>
        </trans-unit>
        <trans-unit id="bca7cd75094117285613d3c27e6356cf37002d9b" translate="yes" xml:space="preserve">
          <source>A changeset consists of zero or more INSERT, UPDATE and/or DELETE changes, each representing a change to a single row of an attached table. An INSERT change contains the values of each field of a new database row. A DELETE contains the original values of each field of a deleted database row. An UPDATE change contains the original values of each field of an updated database row along with the updated values for each updated non-primary-key column. It is not possible for an UPDATE change to represent a change that modifies the values of primary key columns. If such a change is made, it is represented in a changeset as a DELETE followed by an INSERT.</source>
          <target state="translated">一个变更集由零个或多个INSERT、UPDATE和/或DELETE变更组成,每一个变更都代表对所附表的单行的变更。一个INSERT变更包含一个新数据库行的每个字段的值。DELETE包含了被删除的数据库行的每个字段的原始值。UPDATE更改包含更新数据库行的每个字段的原始值,以及每个更新的非主键列的更新值。UPDATE变更不可能表示修改主键列的值的变更。如果做了这样的改变,它在改变集中表示为一个DELETE,然后是一个INSERT。</target>
        </trans-unit>
        <trans-unit id="5b70e5afa0d3f4c5cf0dce236c8276c0465659ed" translate="yes" xml:space="preserve">
          <source>A changeset may be &quot;inverted&quot; using the &lt;a href=&quot;session/sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; API function. An inverted changeset undoes the changes made by the original. If changeset C&lt;sup&gt;+&lt;/sup&gt; is the inverse of changeset C, then applying C and then C&lt;sup&gt;+&lt;/sup&gt; to a database should leave the database unchanged.</source>
          <target state="translated">可以使用&lt;a href=&quot;session/sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert（）&lt;/a&gt; API函数&amp;ldquo;反转&amp;rdquo;变更集。反向变更集会撤消原始变更集。如果变更集C &lt;sup&gt;+&lt;/sup&gt;是变更集C 的逆，那么对数据库应用C然后再对数据库C &lt;sup&gt;+&lt;/sup&gt;应该会使数据库保持不变。</target>
        </trans-unit>
        <trans-unit id="9f32575cd3ae2a269f162fb8c8c71eb2f8f6d374" translate="yes" xml:space="preserve">
          <source>A checkpoint need not run to completion. It might be that some readers are still using older transactions with data that is contained in the database file. In that case, transferring content for newer transactions from the WAL file into the database would delete the content out from under readers still using the older transactions. To avoid that, checkpoints only run to completion if all reader are using the last transaction in the WAL.</source>
          <target state="translated">检查点不需要运行到完成。可能有些读者仍在使用数据库文件中包含的数据的旧事务。在这种情况下,将较新事务的内容从WAL文件中转移到数据库中,就会将仍在使用旧事务的读者的内容删除。为了避免这种情况,只有当所有读者都在使用WAL中的最后一个事务时,检查点才会运行到完成。</target>
        </trans-unit>
        <trans-unit id="c4b3764489da6b52009c87b8c15206abcd48df46" translate="yes" xml:space="preserve">
          <source>A checkpoint operation takes content from the WAL file and transfers it back into the original database file. A checkpoint can run concurrently with readers, however the checkpoint must stop when it reaches a page in the WAL that is past the end mark of any current reader. The checkpoint has to stop at that point because otherwise it might overwrite part of the database file that the reader is actively using. The checkpoint remembers (in the wal-index) how far it got and will resume transferring content from the WAL to the database from where it left off on the next invocation.</source>
          <target state="translated">检查点操作从WAL文件中提取内容并将其传输回原始数据库文件。一个检查点可以和阅读器同时运行,但是当检查点到达WAL中的一个页面时,必须停止,这个页面已经超过了当前任何阅读器的结束标记。检查点必须在这一点上停止,因为否则它可能会覆盖读者正在使用的数据库文件的一部分。检查点会记住(在wal-index中)它走了多远,并且会在下一次调用时从它离开的地方继续将内容从WAL传送到数据库。</target>
        </trans-unit>
        <trans-unit id="b96f1bd57862e095f823ff7f46e3b31f9d401ec4" translate="yes" xml:space="preserve">
          <source>A checksum over bytes 0 through 39 of this header.</source>
          <target state="translated">该头的0到39字节的校验和。</target>
        </trans-unit>
        <trans-unit id="65d66abdb2f9e568e194d84301cc7c1defdf138c" translate="yes" xml:space="preserve">
          <source>A co-routine is like a subroutine in that it runs in the same thread as the caller and eventually returns control back to the caller. The difference is that a co-routine also has the ability to return before it has finished, and then resume where it left off the next time it is called.</source>
          <target state="translated">协同程序就像子程序一样,它与调用者在同一个线程中运行,并最终将控制权返回给调用者。不同的是,协程还可以在完成之前返回,然后在下一次调用时继续执行。</target>
        </trans-unit>
        <trans-unit id="a3446ddc5c2704f78e209be503e073dd5871e32d" translate="yes" xml:space="preserve">
          <source>A collating sequence is implemented as a function that takes the two strings being compared as inputs and returns negative, zero, or positive if the first string is less than, equal to, or greater than the second. SQLite 3.0 comes with a single built-in collating sequence named &quot;BINARY&quot; which is implemented using the memcmp() routine from the standard C library. The BINARY collating sequence works well for English text. For other languages or locales, alternative collating sequences may be preferred.</source>
          <target state="translated">整理序列是作为一个函数来实现的,它将两个被比较的字符串作为输入,如果第一个字符串小于、等于或大于第二个字符串,则返回负数、零或正数。SQLite 3.0内置了一个名为 &quot;BINARY &quot;的整理序列,它是通过标准C库中的memcmp()例程实现的。BINARY整理序列对于英文文本效果很好。对于其他语言或地区,可能更倾向于使用其他整理序列。</target>
        </trans-unit>
        <trans-unit id="99502ad72180308e0c6e1dcbcacfcd00577dfed1" translate="yes" xml:space="preserve">
          <source>A collating sequence is just a defined order for text. When SQLite 3.0 sorts (or uses a comparison operator like &quot;&amp;lt;&quot; or &quot;&amp;gt;=&quot;) the sort order is first determined by the data type.</source>
          <target state="translated">整理顺序只是文本的已定义顺序。当SQLite 3.0排序（或使用比较运算符，例如&amp;ldquo; &amp;lt;&amp;rdquo;或&amp;ldquo;&amp;gt; =&amp;rdquo;）时，排序顺序首先由数据类型确定。</target>
        </trans-unit>
        <trans-unit id="5f87dfb8e180544c52ac50b7d5f03687e7a73db7" translate="yes" xml:space="preserve">
          <source>A column name can be any of the names defined in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement or one of the following special identifiers: &quot;&lt;b&gt;ROWID&lt;/b&gt;&quot;, &quot;&lt;b&gt;OID&lt;/b&gt;&quot;, or &quot;&lt;b&gt;_ROWID_&lt;/b&gt;&quot;. The three special identifiers describe the unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) associated with every row of every table and so are not available on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The special identifiers only refer to the row key if the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement does not define a real column with the same name. The rowid can be used anywhere a regular column can be used.</source>
          <target state="translated">列名可以是&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中定义的任何名称，也可以是以下特殊标识符之一：&amp;ldquo; &lt;b&gt;ROWID&lt;/b&gt; &amp;rdquo;，&amp;ldquo; &lt;b&gt;OID&lt;/b&gt; &amp;rdquo;或&amp;ldquo; &lt;b&gt;_ROWID_&lt;/b&gt; &amp;rdquo;。这三个特殊标识符描述了与每个表的每一行关联的唯一整数键（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;），因此在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中不可用。如果&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句未定义具有相同名称的实列，则特殊标识符仅引用行键。 rowid可以在可以使用常规列的任何地方使用。</target>
        </trans-unit>
        <trans-unit id="5b67ef6e85463cb42541d756505c5b2ae3565809" translate="yes" xml:space="preserve">
          <source>A column that includes a GENERATED ALWAY AS clause is a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;. Generated columns are supported beginning with SQLite verison 3.31.0 (2020-01-22). See the &lt;a href=&quot;gencol&quot;&gt;separate documentation&lt;/a&gt; for details on the capabilities and limitations of generated columns.</source>
          <target state="translated">包含GENERATED ALWAY AS子句的&lt;a href=&quot;gencol&quot;&gt;列&lt;/a&gt;是生成的列。从SQLite版本3.31.0（2020-01-22）开始支持生成的列。有关生成列的功能和限制的详细信息，请参见&lt;a href=&quot;gencol&quot;&gt;单独的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06f5bfc838f715cc006584587792787f6b98f6d0" translate="yes" xml:space="preserve">
          <source>A column that uses INTEGER affinity behaves the same as a column with NUMERIC affinity. The difference between INTEGER and NUMERIC affinity is only evident in a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;.</source>
          <target state="translated">使用INTEGER关联的列的行为与具有NUMERIC关联的列的行为相同。INTEGER和NUMERIC亲和力之间的区别仅在&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达中&lt;/a&gt;才明显。</target>
        </trans-unit>
        <trans-unit id="2bcbff786c0ce548e6eca5a9d9f066668ea13081" translate="yes" xml:space="preserve">
          <source>A column that uses INTEGER affinity behaves the same as a column with NUMERIC affinity. The difference between INTEGER and NUMERIC affinity is only evident in a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;: The expression &quot;CAST(4.0 AS INT)&quot; returns an integer 4, whereas &quot;CAST(4.0 AS NUMERIC)&quot; leaves the value as a floating-point 4.0.</source>
          <target state="translated">使用INTEGER关联的列的行为与具有NUMERIC关联的列的行为相同。 INTEGER和NUMERIC亲和力之间的区别仅在&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式中&lt;/a&gt;明显：表达式&amp;ldquo; CAST（4.0 AS INT）&amp;rdquo;返回整数4，而&amp;ldquo; CAST（4.0 AS NUMERIC）&amp;rdquo;将值保留为浮点4.0。</target>
        </trans-unit>
        <trans-unit id="7bec05409618ea12efea321b6ffb50468bbd6938" translate="yes" xml:space="preserve">
          <source>A column with NUMERIC affinity may contain values using all five storage classes. When text data is inserted into a NUMERIC column, the storage class of the text is converted to INTEGER or REAL (in order of preference) if such conversion is lossless and reversible. For conversions between TEXT and REAL storage classes, SQLite considers the conversion to be lossless and reversible if the first 15 significant decimal digits of the number are preserved. If the lossless conversion of TEXT to INTEGER or REAL is not possible then the value is stored using the TEXT storage class. No attempt is made to convert NULL or BLOB values.</source>
          <target state="translated">具有NUMERIC亲和力的列可以包含使用所有五个存储类别的值。当文本数据被插入到NUMERIC列中时,如果这种转换是无损和可逆的,那么文本的存储类将被转换为INTEGER或REAL(按优先级排序)。对于TEXT和REAL存储类之间的转换,如果保留了数字的前15位有意义的小数位,SQLite认为这种转换是无损和可逆的。如果TEXT到INTEGER或REAL的无损转换是不可能的,那么该值将使用TEXT存储类存储。不尝试转换NULL或BLOB值。</target>
        </trans-unit>
        <trans-unit id="083821da5969169ffed9e50eaaac1193cc7efba6" translate="yes" xml:space="preserve">
          <source>A column with NUMERIC affinity may contain values using all five storage classes. When text data is inserted into a NUMERIC column, the storage class of the text is converted to INTEGER or REAL (in order of preference) if the text is a well-formed integer or real literal, respectively. If the TEXT value is a well-formed integer literal that is too large to fit in a 64-bit signed integer, it is converted to REAL. For conversions between TEXT and REAL storage classes, only the first 15 significant decimal digits of the number are preserved. If the TEXT value is not a well-formed integer or real literal, then the value is stored as TEXT. For the purposes of this paragraph, hexadecimal integer literals are not considered well-formed and are stored as TEXT. (This is done for historical compatibility with versions of SQLite prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_6.html&quot;&gt;version 3.8.6&lt;/a&gt; 2014-08-15 where hexadecimal integer literals were first introduced into SQLite.) If a floating point value that can be represented exactly as an integer is inserted into a column with NUMERIC affinity, the value is converted into an integer. No attempt is made to convert NULL or BLOB values.</source>
          <target state="translated">具有NUMERIC关联性的列可能包含使用所有五个存储类的值。将文本数据插入NUMERIC列时，如果文本分别是格式正确的整数或实数文字，则文本的存储类将转换为INTEGER或REAL（按优先顺序）。如果TEXT值是格式正确的整数文字，且太大而无法容纳64位有符号整数，则将其转换为REAL。对于TEXT和REAL存储类之间的转换，仅保留该数字的前15个有效十进制数字。如果TEXT值不是格式正确的整数或实数文字，则该值将存储为TEXT。出于本段的目的，十六进制整数文字不被认为格式正确，而是存储为TEXT。 （这样做是为了与SQLite之前的版本保持历史兼容&lt;a href=&quot;https://sqlite.org/releaselog/3_8_6.html&quot;&gt;版本3.8.6&lt;/a&gt; 2014-08-15，其中十六进制整数文字首次引入SQLite。）如果将可以精确表示为整数的浮点值插入到具有NUMERIC亲和力的列中，则该值将转换为整数。没有尝试转换NULL或BLOB值。</target>
        </trans-unit>
        <trans-unit id="67992ebe6149e17ea7cdb1cdfe8c4235d6887281" translate="yes" xml:space="preserve">
          <source>A column with NUMERIC affinity may contain values using all five storage classes. When text data is inserted into a NUMERIC column, the storage class of the text is converted to INTEGER or REAL (in order of preference) if the text is a well-formed integer or real literal, respectively. If the TEXT value is a well-formed integer literal that is too large to fit in a 64-bit signed integer, it is converted to REAL. For conversions between TEXT and REAL storage classes, only the first 15 significant decimal digits of the number are preserved. If the TEXT value is not a well-formed integer or real literal, then the value is stored as TEXT. For the purposes of this paragraph, hexadecimal integer literals are not considered well-formed and are stored as TEXT. (This is done for historical compatibility with versions of SQLite prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_6.html&quot;&gt;version 3.8.6&lt;/a&gt; 2014-08-15 where hexadecimal integer literals were first introduced into SQLite.) No attempt is made to convert NULL or BLOB values.</source>
          <target state="translated">具有NUMERIC关联性的列可能包含使用所有五个存储类的值。将文本数据插入NUMERIC列时，如果文本分别是格式正确的整数或实数文字，则文本的存储类将转换为INTEGER或REAL（按优先顺序）。如果TEXT值是格式正确的整数文字，且太大而无法容纳64位有符号整数，则将其转换为REAL。对于TEXT和REAL存储类之间的转换，仅保留该数字的前15个有效十进制数字。如果TEXT值不是格式正确的整数或实数文字，则该值将存储为TEXT。出于本段的目的，十六进制整数文字不被认为格式正确，而是存储为TEXT。 （这样做是为了与SQLite之前的版本保持历史兼容&lt;a href=&quot;https://sqlite.org/releaselog/3_8_6.html&quot;&gt;版本3.8.6&lt;/a&gt; 2014-08-15，其中十六进制整数文字首次引入SQLite。）不尝试转换NULL或BLOB值。</target>
        </trans-unit>
        <trans-unit id="636834272fe49a104c8b0f637d91fe89b1a7c34e" translate="yes" xml:space="preserve">
          <source>A column with REAL affinity behaves like a column with NUMERIC affinity except that it forces integer values into floating point representation. (As an internal optimization, small floating point values with no fractional component and stored in columns with REAL affinity are written to disk as integers in order to take up less space and are automatically converted back into floating point as the value is read out. This optimization is completely invisible at the SQL level and can only be detected by examining the raw bits of the database file.)</source>
          <target state="translated">具有REAL亲和力的列的行为与具有NUMERIC亲和力的列类似,只是它将整数值强制转换成浮点表示。(作为一种内部优化,存储在具有REAL亲和力的列中的没有小数部分的小浮点值被作为整数写入磁盘,以减少占用空间,并在读出该值时自动转换回浮点。这种优化在SQL层面是完全看不到的,只能通过检查数据库文件的原始位来检测)。)</target>
        </trans-unit>
        <trans-unit id="e5c849785a5191658d60300de8d49f0749c36fe5" translate="yes" xml:space="preserve">
          <source>A column with TEXT affinity stores all data using storage classes NULL, TEXT or BLOB. If numerical data is inserted into a column with TEXT affinity it is converted into text form before being stored.</source>
          <target state="translated">具有TEXT亲和力的列使用存储类NULL、TEXT或BLOB来存储所有数据。如果数字数据被插入到具有TEXT亲和力的列中,则在存储之前会被转换成文本形式。</target>
        </trans-unit>
        <trans-unit id="331f0240bd92e0f60f02450a7696762f50b6d061" translate="yes" xml:space="preserve">
          <source>A column with affinity BLOB does not prefer one storage class over another and no attempt is made to coerce data from one storage class into another.</source>
          <target state="translated">具有亲和力BLOB的列不会优先选择一个存储类而不是另一个存储类,也不会试图强迫数据从一个存储类进入另一个存储类。</target>
        </trans-unit>
        <trans-unit id="a9b523c7ac2e4f6d2358ca3e1fc9c4bea3b0b218" translate="yes" xml:space="preserve">
          <source>A compile-time option (SQLITE_BUSY_RESERVED_LOCK) causes the busy handler to be called when there is contention for a RESERVED lock.</source>
          <target state="translated">编译时选项(SQLITE_BUSY_RESERVED_LOCK)会导致在争夺一个RESERVED锁时调用忙处理程序。</target>
        </trans-unit>
        <trans-unit id="b67fed388120bd5bc263b4502fa3722ec97dd3d6" translate="yes" xml:space="preserve">
          <source>A complete database is stored in a &lt;a href=&quot;onefile&quot;&gt;single cross-platform disk file&lt;/a&gt;. Great for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt;.</source>
          <target state="translated">完整的数据库存储在&lt;a href=&quot;onefile&quot;&gt;单个跨平台磁盘文件中&lt;/a&gt;。非常适合用作&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11f700eff4c65192a540e579b7e4f8ad1d2b1604" translate="yes" xml:space="preserve">
          <source>A complete release-test of SQLite requires additional software,</source>
          <target state="translated">SQLite的完整发布测试需要额外的软件。</target>
        </trans-unit>
        <trans-unit id="85cbfa4256773a63897f24495c59253a95e5dd50" translate="yes" xml:space="preserve">
          <source>A composite foreign key constraint is one where the child and parent keys are both composite keys. For example, consider the following database schema:</source>
          <target state="translated">复合外键约束是指子键和父键都是复合键。例如,考虑以下数据库模式。</target>
        </trans-unit>
        <trans-unit id="0bdd710506454d94afdc4228574e57b24f793bf2" translate="yes" xml:space="preserve">
          <source>A compound &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement is two or more SELECT statements connected by operators UNION, UNION ALL, EXCEPT, or INTERSECT. We call each individual SELECT statement within a compound SELECT a &quot;term&quot;.</source>
          <target state="translated">复合&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句是通过运算符UNION，UNION ALL，EXCEPT或INTERSECT连接的两个或多个SELECT语句。我们将复合SELECT中的每个单独的SELECT语句称为&amp;ldquo;项&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aff14af06eef38988e550d3bb6bb8834b81c2ab0" translate="yes" xml:space="preserve">
          <source>A compound SELECT created using UNION ALL operator returns all the rows from the SELECT to the left of the UNION ALL operator, and all the rows from the SELECT to the right of it. The UNION operator works the same way as UNION ALL, except that duplicate rows are removed from the final result set. The INTERSECT operator returns the intersection of the results of the left and right SELECTs. The EXCEPT operator returns the subset of rows returned by the left SELECT that are not also returned by the right-hand SELECT. Duplicate rows are removed from the results of INTERSECT and EXCEPT operators before the result set is returned.</source>
          <target state="translated">使用UNION ALL操作符创建的复合SELECT将返回UNION ALL操作符左边的SELECT中的所有记录,以及它右边的SELECT中的所有记录。UNION操作符的工作方式与UNION ALL操作符相同,只是重复的记录会从最终的结果集中删除。INTERSECT操作符返回左右SELECTs结果的交叉点。EXCEPT操作符返回由左SELECT返回的、没有被右SELECT返回的记录的子集。在返回结果集之前,会从INTERSECT和EXCEPT操作符的结果中删除重复的记录。</target>
        </trans-unit>
        <trans-unit id="56b1d09048efb4fd1fb06c9b9ddec9b21053649e" translate="yes" xml:space="preserve">
          <source>A conflict handler callback must return one of the following three values.</source>
          <target state="translated">冲突处理回调必须返回以下三个值之一。</target>
        </trans-unit>
        <trans-unit id="8d286e1793dce553da5e2fb27f69090f877b2aeb" translate="yes" xml:space="preserve">
          <source>A connection may not compile an SQL statement if any other connection is holding a write-lock on the</source>
          <target state="translated">如果有任何其他连接持有对</target>
        </trans-unit>
        <trans-unit id="4a47f7617f36f73967261be474fcf1ca9ab960be" translate="yes" xml:space="preserve">
          <source>A connection must obtain a read-lock on</source>
          <target state="translated">连接必须在</target>
        </trans-unit>
        <trans-unit id="ba1dcaac6e13d9eb13e548994e129aca79ff47b0" translate="yes" xml:space="preserve">
          <source>A contentless FTS5 table is created by setting the &quot;content&quot; option to an empty string. For example:</source>
          <target state="translated">通过将 &quot;content &quot;选项设置为空字符串,可以创建一个无内容的FTS5表。例如:</target>
        </trans-unit>
        <trans-unit id="a267c5dab66f5e34a45852cc32f71b97729d1b15" translate="yes" xml:space="preserve">
          <source>A copy of bytes 0 through 47 of this header.</source>
          <target state="translated">该头的字节0至47的副本。</target>
        </trans-unit>
        <trans-unit id="6bfcf4a271894a36753059f74bed2256dff4a758" translate="yes" xml:space="preserve">
          <source>A coverage testing build is used to validate the test suite, to confirm that the test suite provides 100% MC/DC.</source>
          <target state="translated">覆盖测试构建用于验证测试套件,以确认测试套件提供100%的MC/DC。</target>
        </trans-unit>
        <trans-unit id="94c5d9a042e6577c2dabc042ff092ff7fee14842" translate="yes" xml:space="preserve">
          <source>A database connection in read-uncommitted mode does not attempt to obtain read-locks before reading from database tables as described above. This can lead to inconsistent query results if another database connection modifies a table while it is being read, but it also means that a read-transaction opened by a connection in read-uncommitted mode can neither block nor be blocked by any other connection.</source>
          <target state="translated">在读取-未提交模式下的数据库连接不会像上面所说的那样,在读取数据库表之前试图获得读取锁定。如果另一个数据库连接在读表时修改了表,这可能会导致查询结果不一致,但这也意味着在读-未提交模式下的连接打开的读事务既不能阻止也不能被任何其他连接阻止。</target>
        </trans-unit>
        <trans-unit id="5f2be52de867ed0c8228dad137b9e9be0ede3dc9" translate="yes" xml:space="preserve">
          <source>A database file might contain one or more pages that are not in active use. Unused pages can come about, for example, when information is deleted from the database. Unused pages are stored on the freelist and are reused when additional pages are required.</source>
          <target state="translated">一个数据库文件可能包含一个或多个未使用的页面。例如,当信息从数据库中删除时,就会产生未使用的页面。未使用的页面存储在自由列表中,当需要更多的页面时,可以重新使用。</target>
        </trans-unit>
        <trans-unit id="e31bb0c648c1594ace271ab750089b7069eca230" translate="yes" xml:space="preserve">
          <source>A database filename pointer created by the SQLite core and passed into the xOpen() method of a VFS implemention, or</source>
          <target state="translated">由SQLite核心创建的数据库文件名指针,并传递到VFS实现的xOpen()方法中,或者是</target>
        </trans-unit>
        <trans-unit id="d0d2200c58a122988a36133f11d5ad81150a5964" translate="yes" xml:space="preserve">
          <source>A database handle may only have a single profile script registered at any time. If there is already a script registered when the profile method is invoked, the previous profile script is replaced by the new one. If the</source>
          <target state="translated">一个数据库句柄在任何时候只能注册一个配置文件脚本。如果在调用profile方法时已经注册了一个脚本,那么之前的profile脚本就会被新的脚本所取代。如果</target>
        </trans-unit>
        <trans-unit id="f7c56f6c25c0806c71336c6dfe79200c9d74d137" translate="yes" xml:space="preserve">
          <source>A database in SQLite is a single disk file&amp;amp;sup1. Furthermore, the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; is cross-platform. A database that is created on one machine can be copied and used on a different machine with a different architecture. SQLite databases are portable across 32-bit and 64-bit machines and between &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt; architectures.</source>
          <target state="translated">SQLite中的数据库是单个磁盘文件＆sup1。此外，&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;是跨平台的。可以复制在一台计算机上创建的数据库，并在具有不同体系结构的另一台计算机上使用。SQLite数据库可在32位和64位计算机之间以及在&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;大端&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;小端&lt;/a&gt;架构之间移植。</target>
        </trans-unit>
        <trans-unit id="a33a00bec56bc970089c19de104ce52c75222367" translate="yes" xml:space="preserve">
          <source>A database in SQLite is a single disk file&amp;sup1;. Furthermore, the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; is cross-platform. A database that is created on one machine can be copied and used on a different machine with a different architecture. SQLite databases are portable across 32-bit and 64-bit machines and between &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt; architectures.</source>
          <target state="translated">SQLite中的数据库是单个磁盘文件&amp;sup1;。此外，&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;是跨平台的。可以复制在一台计算机上创建的数据库，并在具有不同体系结构的另一台计算机上使用该数据库。SQLite数据库可在32位和64位计算机之间以及&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt;体系结构之间移植。</target>
        </trans-unit>
        <trans-unit id="f6859ecade8ff3bb28e1605ddecd851d49cda739" translate="yes" xml:space="preserve">
          <source>A database in SQLite is a single disk file&amp;sup1;. Furthermore, the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; is cross-platform. A database that is created on one machine can be copied and used on a different machine with a different architecture. SQLite databases are portable across 32-bit and 64-bit machines and between &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt; architectures.</source>
          <target state="translated">SQLite中的数据库是单个磁盘文件&amp;sup1;。此外，&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;是跨平台的。可以复制在一台计算机上创建的数据库，并在具有不同体系结构的另一台计算机上使用该数据库。SQLite数据库可在32位和64位计算机之间以及&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt;体系结构之间移植。</target>
        </trans-unit>
        <trans-unit id="58caf1944b94d1b1b9c822b0c5664121932f85cd" translate="yes" xml:space="preserve">
          <source>A database page number P is mapped into a hash value using the following hash function:</source>
          <target state="translated">使用以下哈希函数将数据库页码P映射成一个哈希值。</target>
        </trans-unit>
        <trans-unit id="ed3347e26b126664d224486fe7f1e3e439c82acd" translate="yes" xml:space="preserve">
          <source>A database page size of 8192 or 16384 gives the best performance for large BLOB I/O.</source>
          <target state="translated">数据库页面大小为8192或16384,可以为大型BLOB I/O提供最佳性能。</target>
        </trans-unit>
        <trans-unit id="103c49f4c460c42c7a0369b1a9d6281b2a84fdfe" translate="yes" xml:space="preserve">
          <source>A datatype to SQLite is any sequence of zero or more names optionally followed by a parenthesized lists of one or two signed integers. Notice in particular that a datatype may be &lt;em&gt;zero&lt;/em&gt; or more names. That means that an empty string is a valid datatype as far as SQLite is concerned. So you can declare tables where the datatype of each column is left unspecified, like this:</source>
          <target state="translated">SQLite的数据类型是零个或多个名称的任何序列，可以选择后面跟一个或两个带符号整数的括号列表。特别注意，数据类型可以是&lt;em&gt;零个&lt;/em&gt;或多个名称。这意味着就SQLite而言，空字符串是有效的数据类型。因此，您可以声明未指定每一列的数据类型的表，如下所示：</target>
        </trans-unit>
        <trans-unit id="de414f6a58ee8730c6b30d4d04397485a33b014d" translate="yes" xml:space="preserve">
          <source>A default build of SQLite, if a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statement has no WHERE clause and operates on a table with no triggers, an optimization occurs that causes the DELETE to occur by dropping and recreating the table. Dropping and recreating a table is usually much faster than deleting the table content row by row. This is the &quot;truncate optimization&quot;.</source>
          <target state="translated">如果没有&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句没有WHERE子句并且在没有触发器的表上运行，则SQLite的默认构建会发生优化，该优化会通过删除并重新创建表来导致DELETE发生。通常，删除和重新创建表比逐行删除表内容要快得多。这是&amp;ldquo;截断优化&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2702a604a55a621adb104d691b4fe3d29100cf61" translate="yes" xml:space="preserve">
          <source>A default collation sequence to use with each column.</source>
          <target state="translated">每个列使用的默认整理序列。</target>
        </trans-unit>
        <trans-unit id="547106accc42ee8c3be32b9edfc90679c871cd46" translate="yes" xml:space="preserve">
          <source>A default value or expression for each column in the table.</source>
          <target state="translated">表中每列的默认值或表达式。</target>
        </trans-unit>
        <trans-unit id="f9bafa0d6a619bf3ec9b0838fb3a083c9a68cbd8" translate="yes" xml:space="preserve">
          <source>A demonstration of how to use a virtual table to implement approximate string matching.</source>
          <target state="translated">演示如何使用虚拟表来实现近似字符串匹配。</target>
        </trans-unit>
        <trans-unit id="2c07573f063bff6f3b90762e19698056e9e8c100" translate="yes" xml:space="preserve">
          <source>A description of the available auxiliary functions, and more details regarding configuration of the special &quot;rank&quot; column, are &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;available below&lt;/a&gt;. &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;Custom auxiliary functions&lt;/a&gt; may also be implemented in C and registered with FTS5, just as custom SQL functions may be registered with the SQLite core.</source>
          <target state="translated">可用辅助功能，和更多的细节对于特殊的&amp;ldquo;等级&amp;rdquo;栏的结构的描述，都&lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;可用以下&lt;/a&gt;。&lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;自定义辅助功能&lt;/a&gt;也可以在C中实现并向FTS5注册，就像自定义SQL函数可以向SQLite核心注册一样。</target>
        </trans-unit>
        <trans-unit id="f9c23846cd545b2b63ddda813679cd4a49e68b63" translate="yes" xml:space="preserve">
          <source>A design flaw in the layout of indices required a file format change to correct. This change appeared in version 2.6.0.</source>
          <target state="translated">索引布局中的一个设计缺陷需要改变文件格式来纠正。这一变化出现在2.6.0版本中。</target>
        </trans-unit>
        <trans-unit id="a09b00a1870ec37c4a6711c6d9a83ee63caec494" translate="yes" xml:space="preserve">
          <source>A deterministic function always gives the same answer when it has the same inputs. Most built-in SQL functions in SQLite are deterministic. For example, the &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs(X)&lt;/a&gt; function always returns the same answer as long as its input X is the same.</source>
          <target state="translated">当确定性函数具有相同的输入时，总是给出相同的答案。SQLite中大多数内置的SQL函数都是确定性的。例如，&lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs（X）&lt;/a&gt;函数始终返回相同的答案，只要其输入X相同即可。</target>
        </trans-unit>
        <trans-unit id="f1d23588be86a8b0f51bcfc6d42620be9c04bdb9" translate="yes" xml:space="preserve">
          <source>A different interface is used to find statistics associated with a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;:</source>
          <target state="translated">使用不同的接口来查找与单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;相关的统计信息：</target>
        </trans-unit>
        <trans-unit id="2bab2383badd353faf6d58c28e00ad5e2dc43f7f" translate="yes" xml:space="preserve">
          <source>A different temporary file is created each time, so that just like as with the special &quot;:memory:&quot; string, two database connections to temporary databases each have their own private database. Temporary databases are automatically deleted when the connection that created them closes.</source>
          <target state="translated">每次都会创建一个不同的临时文件,这样就像使用特殊的&quot;:memory:&quot;字符串一样,两个数据库连接到临时数据库都有自己的私有数据库。当创建临时数据库的连接关闭时,临时数据库会被自动删除。</target>
        </trans-unit>
        <trans-unit id="616182c007ad6c0ef9a037faf15b8a4c7b4e27dc" translate="yes" xml:space="preserve">
          <source>A docid (document id), and</source>
          <target state="translated">一个docid(文档id),和</target>
        </trans-unit>
        <trans-unit id="ffa8c1978179e5d6594c307606a0c96c65d178b7" translate="yes" xml:space="preserve">
          <source>A doclist consists of an array of 64-bit signed integers, serialized using the FTS varint format. Each doclist entry is made up of a series of two or more integers, as follows:</source>
          <target state="translated">doclist由一个64位有符号的整数数组组成,使用FTS varint格式序列化。每个doclist条目由两个或多个整数组成,如下所示:</target>
        </trans-unit>
        <trans-unit id="70b611cc962affaff5bc25b34d8cf2a147e0cff8" translate="yes" xml:space="preserve">
          <source>A dot-command cannot occur in the middle of an ordinary SQL statement. In other words, a dot-command cannot occur at a continuation prompt.</source>
          <target state="translated">点号命令不能出现在普通SQL语句的中间。换句话说,点号不能出现在延续提示符中。</target>
        </trans-unit>
        <trans-unit id="ed3f86822b1bda8e466c4526bffa4f20cb3e5064" translate="yes" xml:space="preserve">
          <source>A dot-command must begin with the &quot;.&quot; at the left margin with no preceding whitespace.</source>
          <target state="translated">点号命令必须以&quot;.&quot;开头,并在左侧空白处没有空格。</target>
        </trans-unit>
        <trans-unit id="9419d21a9cdfce978f5cf3af5bf95604556793ad" translate="yes" xml:space="preserve">
          <source>A federation of programs, perhaps all written in different programming languages, can access the same application file with no compatibility concerns.</source>
          <target state="translated">一个程序的联盟,也许都是用不同的编程语言编写的,可以访问同一个应用程序文件,没有兼容性问题。</target>
        </trans-unit>
        <trans-unit id="d364c247d7037a579b6c9cd2b367d98adf71052d" translate="yes" xml:space="preserve">
          <source>A few SQLite extensions benefit from passing pointers:</source>
          <target state="translated">一些SQLite扩展从传递指针中获益。</target>
        </trans-unit>
        <trans-unit id="0c7d92f3a2f21a1e18ce4fbe8371145c26e275b4" translate="yes" xml:space="preserve">
          <source>A few applications do allow untrusted SQL scripts received from potentially hostile agents to be run direct in SQLite. The main example of this is the Chrome and Safari web browsers, which allow an anonymous web page to run SQL using the WebSQL feature of Javascript. This is done inside a sandbox with tightly controlled constraints on resources, lest the SQL script try to soak up all available memory or CPU cycles in a denial-of-service attack. Chrome and Safari have the infrastructure in place to allow a hostile agent to run code which does not harm or compromise the rest of the machine. They have to, as they also run Javascript which could, if not tightly controlled, do even more damage than unrestrained SQL. Apart from Chrome and Safari, no applications known to the SQLite developers deliberately allows an anonymous remote agent to run arbitrary SQL text.</source>
          <target state="translated">少数应用程序确实允许在SQLite中直接运行从潜在的敌对代理处收到的不受信任的SQL脚本。主要的例子是Chrome和Safari网络浏览器,它们允许匿名网页使用Javascript的WebSQL功能运行SQL。这是在一个沙箱内完成的,对资源有严格的控制约束,以免SQL脚本试图在拒绝服务攻击中占用所有可用的内存或CPU周期。Chrome浏览器和Safari浏览器的基础设施已经到位,允许敌对代理运行不会损害或危及机器其他部分的代码。它们必须这样做,因为它们还运行Javascript,如果不加以严格控制,其破坏力甚至比不受限制的SQL还要大。除了Chrome和Safari,SQLite开发者已知的任何应用程序都不会故意允许匿名远程代理运行任意SQL文本。</target>
        </trans-unit>
        <trans-unit id="62f7d6f4dcc5ba74ac0335fa025ccd8910f0c1e1" translate="yes" xml:space="preserve">
          <source>A few opcodes for &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method. The &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; value for the op parameter causes a pointer to the underlying &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object to be written into the space pointed to by the 4th parameter. The &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; works similarly except that it returns the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file instead of the main database. The &lt;a href=&quot;#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode returns a pointer to the underlying &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object for the file. The &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; returns the data version counter from the pager.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）的&lt;/a&gt;一些操作码由SQLite核心直接处理，从不调用sqlite3_io_methods.xFileControl方法。op参数的&lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;值导致将指向底层&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;对象的指针写入第4个参数所指向的空间。该&lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;工作，除了它返回同样&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;与日志文件而不是主数据库相关联的对象。所述&lt;a href=&quot;#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt;操作码将指针返回到底层&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的文件。该&lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; 从寻呼机返回数据版本计数器。</target>
        </trans-unit>
        <trans-unit id="15b71d02b16fcc797e9ca6b0c9b9270d384f8e61" translate="yes" xml:space="preserve">
          <source>A few opcodes for &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; value for the op parameter causes a pointer to the underlying &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object to be written into the space pointed to by the 4th parameter. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; works similarly except that it returns the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file instead of the main database. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode returns a pointer to the underlying &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object for the file. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; returns the data version counter from the pager.</source>
          <target state="translated">&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）的&lt;/a&gt;一些操作码由SQLite核心直接处理，从不调用sqlite3_io_methods.xFileControl方法。op参数的&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;值导致将指向底层&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;对象的指针写入第4个参数所指向的空间。该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;工作，除了它返回同样&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;与日志文件而不是主数据库相关联的对象。所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt;操作码将指针返回到底层&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的文件。该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; 从寻呼机返回数据版本计数器。</target>
        </trans-unit>
        <trans-unit id="5a30cb03f77194a1ffe9dcf2f61544ecd6effb5d" translate="yes" xml:space="preserve">
          <source>A file-handle is opened on the database file.</source>
          <target state="translated">在数据库文件上打开一个文件柄。</target>
        </trans-unit>
        <trans-unit id="a9388c7b2c5482cecf8486b9ae5cf08dcef6f978" translate="yes" xml:space="preserve">
          <source>A filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, or</source>
          <target state="translated">从&lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;获得的文件名，或</target>
        </trans-unit>
        <trans-unit id="a919b14072f3c1d12642ca7fcf434072aba372a6" translate="yes" xml:space="preserve">
          <source>A filename obtained from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, or</source>
          <target state="translated">从&lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;获得的文件名，或</target>
        </trans-unit>
        <trans-unit id="fa2d542371ac8e72fa484fee76e990ca0bf35dd8" translate="yes" xml:space="preserve">
          <source>A filename that is not a well-formed URI is interpreted as an ordinary filename.</source>
          <target state="translated">一个不是格式良好的URI的文件名会被解释为普通的文件名。</target>
        </trans-unit>
        <trans-unit id="925a1b52b051c06afa6e58e50e2b8bb4927090d1" translate="yes" xml:space="preserve">
          <source>A frame is considered valid if and only if the following conditions are true:</source>
          <target state="translated">如果且仅当以下条件为真时,一个框架被认为是有效的:</target>
        </trans-unit>
        <trans-unit id="9611de2f1872728925114c844500f9f8ef115f15" translate="yes" xml:space="preserve">
          <source>A frame type - either ROWS, RANGE or GROUPS,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b126bb6dbd1d7edb9b84085983a8045b613274" translate="yes" xml:space="preserve">
          <source>A freeblock is a structure used to identify unallocated space within a b-tree page. Freeblocks are organized as a chain. The first 2 bytes of a freeblock are a big-endian integer which is the offset in the b-tree page of the next freeblock in the chain, or zero if the freeblock is the last on the chain. The third and fourth bytes of each freeblock form a big-endian integer which is the size of the freeblock in bytes, including the 4-byte header. Freeblocks are always connected in order of increasing offset. The second field of the b-tree page header is the offset of the first freeblock, or zero if there are no freeblocks on the page. In a well-formed b-tree page, there will always be at least one cell before the first freeblock.</source>
          <target state="translated">自由块是一种结构,用于识别b-tree页面中未分配的空间。自由块是以链的形式组织的。一个自由块的前2个字节是一个大恩迪安整数,它是链中下一个自由块在b树页中的偏移量,如果自由块是链中最后一个,则为零。每个自由块的第三个和第四个字节形成一个大恩迪安整数,这是自由块的大小,以字节为单位,包括4字节的头。自由块总是按照偏移量增加的顺序连接。b-tree页面头的第二个字段是第一个自由块的偏移量,如果页面上没有自由块,则为零。在一个完整的b树页面中,第一个自由块之前总是至少有一个单元格。</target>
        </trans-unit>
        <trans-unit id="2acc382f3b34dd5d099262b455a40252f22e8680" translate="yes" xml:space="preserve">
          <source>A freeblock requires at least 4 bytes of space. If there is an isolated group of 1, 2, or 3 unused bytes within the cell content area, those bytes comprise a fragment. The total number of bytes in all fragments is stored in the fifth field of the b-tree page header. In a well-formed b-tree page, the total number of bytes in fragments may not exceed 60.</source>
          <target state="translated">一个自由块至少需要4个字节的空间。如果在单元内容区域内有一组孤立的1、2或3个未使用的字节,这些字节组成一个片段。所有片段中的字节总数存储在b树页头的第五个字段中。在一个成形良好的b树页中,片段中的字节总数不能超过60。</target>
        </trans-unit>
        <trans-unit id="b80d94705f8bf7c5e4c97f09c2fe3da9d04e1505" translate="yes" xml:space="preserve">
          <source>A freelist leaf page</source>
          <target state="translated">一个自由职业者页面</target>
        </trans-unit>
        <trans-unit id="c3220fe91d800548a519d55ab5c5896e3d8a1361" translate="yes" xml:space="preserve">
          <source>A freelist page</source>
          <target state="translated">自由职业者页面</target>
        </trans-unit>
        <trans-unit id="c408c3d929760cbe3bea5989823d3bcbc82cd883" translate="yes" xml:space="preserve">
          <source>A freelist page. The page number should be zero.</source>
          <target state="translated">一个自由职业者页面。页码应该是零。</target>
        </trans-unit>
        <trans-unit id="d4a249e10dcc6a39be18d8c2e3b23ef6d5feaebd" translate="yes" xml:space="preserve">
          <source>A freelist trunk page</source>
          <target state="translated">一个自由职业者主干页</target>
        </trans-unit>
        <trans-unit id="0db4fc71bebbc8176162f7cd595aa13edbeb12ed" translate="yes" xml:space="preserve">
          <source>A freelist trunk page consists of an array of 4-byte big-endian integers. The size of the array is as many integers as will fit in the usable space of a page. The minimum usable space is 480 bytes so the array will always be at least 120 entries in length. The first integer on a freelist trunk page is the page number of the next freelist trunk page in the list or zero if this is the last freelist trunk page. The second integer on a freelist trunk page is the number of leaf page pointers to follow. Call the second integer on a freelist trunk page L. If L is greater than zero then integers with array indexes between 2 and L+1 inclusive contain page numbers for freelist leaf pages.</source>
          <target state="translated">一个自由列表主干页由一个4字节的大字节整数数组组成。数组的大小是指页面可用空间中能容纳多少个整数。最小的可用空间是480字节,所以数组的长度至少是120个条目。自由列表主干页的第一个整数是列表中下一个自由列表主干页的页码,如果是最后一个自由列表主干页,则为零。自由列表主干页上的第二个整数是要跟随的叶页指针的数量。调用自由列表主干页上的第二个整数L,如果L大于零,那么数组索引在2和L+1(含)之间的整数包含自由列表叶页的页码。</target>
        </trans-unit>
        <trans-unit id="d9f9d805045a05b8c1c21a89d92690feac608128" translate="yes" xml:space="preserve">
          <source>A full disk drive will normally give an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error rather than an SQLITE_IOERR error.</source>
          <target state="translated">完整的磁盘驱动器通常会显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误，而不是SQLITE_IOERR错误。</target>
        </trans-unit>
        <trans-unit id="dd246aeb0987ce268dd63d7c5d7c659921acc423" translate="yes" xml:space="preserve">
          <source>A functionality testing build is used to validate the source code.</source>
          <target state="translated">功能测试构建是用来验证源代码的。</target>
        </trans-unit>
        <trans-unit id="69647f389c03a5fb55f353538995da652df9828c" translate="yes" xml:space="preserve">
          <source>A geopoly table is created as follows:</source>
          <target state="translated">创建地缘表如下:</target>
        </trans-unit>
        <trans-unit id="deba985c96e7599b149dd466acf4a33fd8b7d25a" translate="yes" xml:space="preserve">
          <source>A good rule of thumb is to avoid using SQLite in situations where the same database will be accessed directly (without an intervening application server) and simultaneously from many computers over a network.</source>
          <target state="translated">一个很好的经验法则是避免在以下情况下使用SQLite:在没有应用服务器介入的情况下,直接从多台计算机通过网络同时访问同一个数据库。</target>
        </trans-unit>
        <trans-unit id="47ce97c37cb3d63bea994c838fc3580d1c732993" translate="yes" xml:space="preserve">
          <source>A good rule of thumb seems to be to always set &quot;PRAGMA analysis_limit=N&quot; for N between 100 and 1000 prior to running either &quot;ANALYZE&quot; or &quot;&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt;&quot;. The results are not quite as precise, but they are precise enough, and the fact that the results are computed so much faster means that developers are more likely to compute them. An approximate ANALYZE is better than not running ANALYZE at all.</source>
          <target state="translated">一条好的经验法则是，在运行&amp;ldquo; ANALYZE&amp;rdquo;或&amp;ldquo; &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMAoptimize&lt;/a&gt; &amp;rdquo;之前，始终将N的&amp;ldquo; PRAGMA analysis_limit = N&amp;rdquo;设置为100到1000 。结果不是很精确，但是足够精确，而且结果计算速度如此之快的事实意味着开发人员更有可能计算它们。近似ANALYZE比根本不运行ANALYZE更好。</target>
        </trans-unit>
        <trans-unit id="504276fb27ab49d77f3fa65dc56539df4f20135a" translate="yes" xml:space="preserve">
          <source>A good way to make an archival copy of a database is this:</source>
          <target state="translated">制作数据库存档副本的好方法是这样的。</target>
        </trans-unit>
        <trans-unit id="9e3552536e0c3fc2b1a5c13a249c60fb3e232b20" translate="yes" xml:space="preserve">
          <source>A high-performance full-text search index.</source>
          <target state="translated">一个高性能的全文检索索引。</target>
        </trans-unit>
        <trans-unit id="f3fc66c121035cba95cdccd27eb5988b1d320b84" translate="yes" xml:space="preserve">
          <source>A higher-performance full-text search index</source>
          <target state="translated">更高性能的全文检索索引</target>
        </trans-unit>
        <trans-unit id="55bfdc0040ab9af19d73d70ad7d6c87f58f9b24f" translate="yes" xml:space="preserve">
          <source>A host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; is a place-holder in an SQL statement that is filled in using one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; interfaces. Many SQL programmers are familiar with using a question mark (&quot;?&quot;) as a host parameter. SQLite also supports named host parameters prefaced by &quot;:&quot;, &quot;$&quot;, or &quot;@&quot; and numbered host parameters of the form &quot;?123&quot;.</source>
          <target state="translated">主机&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;是使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX（）&lt;/a&gt;接口之一填充的SQL语句中的占位符。许多SQL程序员熟悉使用问号（&amp;ldquo;？&amp;rdquo;）作为主机参数。SQLite还支持以&amp;ldquo;：&amp;rdquo;，&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;开头的命名主机参数以及形式为&amp;ldquo;？123&amp;rdquo;的带编号主机参数。</target>
        </trans-unit>
        <trans-unit id="257267c1113a289e6b9feab4b089bb45cde287f6" translate="yes" xml:space="preserve">
          <source>A host computer with a 32-bit or 64-bit address space. The OS can be Linux, Mac, Windows, *BSD, Solaris, or some other.</source>
          <target state="translated">具有32位或64位地址空间的主机。操作系统可以是Linux、Mac、Windows、*BSD、Solaris或其他。</target>
        </trans-unit>
        <trans-unit id="e0b6a216d45c25e568110df32be35198581043b2" translate="yes" xml:space="preserve">
          <source>A journal file consists of one or more</source>
          <target state="translated">一个日志文件由一个或多个</target>
        </trans-unit>
        <trans-unit id="e29bbea10489e0962b8f547beacaa5c44b5643b7" translate="yes" xml:space="preserve">
          <source>A journal is hot if...</source>
          <target state="translated">一本杂志的热度,如果...</target>
        </trans-unit>
        <trans-unit id="bf4b3bcb8b3070bf8bd1c4dde82d2f44df71510d" translate="yes" xml:space="preserve">
          <source>A jump is made to P2 if the result set after filtering would be empty.</source>
          <target state="translated">如果过滤后的结果集为空,则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="97820ecb987f28847e95dbdef663725135bce0e0" translate="yes" xml:space="preserve">
          <source>A language keyword like &quot;SELECT&quot; or &quot;UPDATE&quot;.</source>
          <target state="translated">像 &quot;SELECT &quot;或 &quot;UPDATE &quot;这样的语言关键词。</target>
        </trans-unit>
        <trans-unit id="93a1f585c4bb54305bbad30d5d616a96cefe0475" translate="yes" xml:space="preserve">
          <source>A limited form of table-level locking is now also available in SQLite. If each table is stored in a separate database file, those separate files can be attached to the main database (using the ATTACH command) and the combined databases will function as one. But locks will only be acquired on individual files as needed. So if you redefine &quot;database&quot; to mean two or more database files, then it is entirely possible for two processes to be writing to the same database at the same time. To further support this capability, commits of transactions involving two or more ATTACHed database are now atomic.</source>
          <target state="translated">现在,SQLite中还提供了一种有限的表级锁定形式。如果每个表都存储在一个单独的数据库文件中,那么这些单独的文件可以附加到主数据库中(使用ATTACH命令),合并后的数据库将作为一个数据库运行。但是只有在需要的时候才会对各个文件获取锁。因此,如果重新定义 &quot;数据库 &quot;为两个或更多的数据库文件,那么完全可以让两个进程同时向同一个数据库写入。为了进一步支持这种能力,涉及两个或多个ATTACHed数据库的事务提交现在是原子的。</target>
        </trans-unit>
        <trans-unit id="759400fcd5974123ad0b1241cafe4f82c240d273" translate="yes" xml:space="preserve">
          <source>A list of term offsets, one for each occurrence of the term within the document. A term offset indicates the number of tokens (words) that occur before the term in question, not the number of characters or bytes. For example, the term offset of the term &quot;war&quot; in the phrase &quot;Ancestral voices prophesying war!&quot; is 3.</source>
          <target state="translated">术语偏移量列表,文档中每出现一个术语,就有一个偏移量。术语偏移量表示在有关术语之前出现的标记(词)数,而不是字符或字节数。例如,&quot;祖音预言战争!&quot;中 &quot;战争 &quot;一词的术语偏移量为3。</target>
        </trans-unit>
        <trans-unit id="b68d4ff4d7b33cd92deee3174c451fcde6f5c709" translate="yes" xml:space="preserve">
          <source>A list of term-offsets, sorted from smallest to largest. Instead of storing the term-offset value literally, each integer stored is the difference between the current term-offset and the previous one (or zero if the current term-offset is the first), plus 2.</source>
          <target state="translated">术语偏移量的列表,从最小到最大排序。不是按字面意思存储术语偏移值,而是存储的每个整数是当前术语偏移值和前一个术语偏移值之间的差值(如果当前术语偏移值是第一个术语偏移值,则为零),加上2。</target>
        </trans-unit>
        <trans-unit id="f2c5240a715ebac0343aac16762c04ccbb3c2e9c" translate="yes" xml:space="preserve">
          <source>A literal value can also be the token &quot;NULL&quot;.</source>
          <target state="translated">字面值也可以是标记 &quot;NULL&quot;。</target>
        </trans-unit>
        <trans-unit id="677dc4104adc8eb80a0bd3eedfbb0364028f37cc" translate="yes" xml:space="preserve">
          <source>A literal value represents a constant. Literal values may be integers, floating point numbers, strings, BLOBs, or NULLs.</source>
          <target state="translated">一个字面值代表一个常量,字面值可以是整数、浮点数、字符串、BLOB或NULL。字面值可以是整数、浮点数、字符串、BLOBs或NULLs。</target>
        </trans-unit>
        <trans-unit id="ec763a0eb37a9be20ccf4fd503223781cee5eb4c" translate="yes" xml:space="preserve">
          <source>A local change may be rebased against multiple remote changes simultaneously. If a single key is modified by multiple remote changesets, they are combined as follows before the local changeset is rebased:</source>
          <target state="translated">一个本地变更可以同时针对多个远程变更进行重基。如果一个密钥被多个远程变更集修改,那么在本地变更集被重新计算之前,它们会被按以下方式合并。</target>
        </trans-unit>
        <trans-unit id="b1f44fa8f0079eaf328b711da0c194b82f3bfca0" translate="yes" xml:space="preserve">
          <source>A maliciously crafted database might be able to inject SQL by defining new &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; in the schema that the application does not anticipate. There are multiple defenses:</source>
          <target state="translated">通过在应用程序无法预期的模式中定义新的&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;或&lt;a href=&quot;lang_createview&quot;&gt;视图&lt;/a&gt;，恶意制作的数据库可能能够注入SQL 。有多种防御措施：</target>
        </trans-unit>
        <trans-unit id="0169e2a34230a953484e9b48ea9bd77dd4f6ea97" translate="yes" xml:space="preserve">
          <source>A master journal is stale if no individual file journals are pointing to it. To figure out if a master journal is stale, we first read the master journal to obtain the names of all of its file journals. Then we check each of those file journals. If any of the file journals named in the master journal exists and points back to the master journal, then the master journal is not stale. If all file journals are either missing or refer to other master journals or no master journal at all, then the master journal we are testing is stale and can be safely deleted.</source>
          <target state="translated">如果一个主日志没有单个文件日志指向它,那么这个主日志就是陈旧的。要确定主日志是否失效,我们首先读取主日志,以获得其所有文件日志的名称。然后我们检查每一个文件期刊。如果主日志中命名的任何一个文件期刊存在,并且指向主日志,那么主日志就不是陈旧的。如果所有的文件日志要么缺失,要么指向其他主日志,要么根本没有主日志,那么我们正在测试的主日志是陈旧的,可以安全删除。</target>
        </trans-unit>
        <trans-unit id="2661539e5d017b557d9c14e5c75af338d27b4e59" translate="yes" xml:space="preserve">
          <source>A merge has already been started (perhaps by a 'merge' command that specified a negative parameter).</source>
          <target state="translated">合并已经开始了(可能是通过一个指定了负参数的 &quot;merge &quot;命令)。</target>
        </trans-unit>
        <trans-unit id="279ebae13f861bd71157c08bf29f5b4c651d6c5d" translate="yes" xml:space="preserve">
          <source>A minimal build of SQLite requires just these routines from the standard C library:</source>
          <target state="translated">SQLite的最小构建只需要标准C库中的这些例程。</target>
        </trans-unit>
        <trans-unit id="a5c466a87de63404dc0230e1abc285b23bb040a4" translate="yes" xml:space="preserve">
          <source>A minimum setup for compiling and testing SQLite from canonical sources is as follows:</source>
          <target state="translated">从规范源编译和测试SQLite的最低设置如下。</target>
        </trans-unit>
        <trans-unit id="ab3655d2734192b9504cea343051e8b9d73b7c75" translate="yes" xml:space="preserve">
          <source>A more compact format for database files.</source>
          <target state="translated">更紧凑的数据库文件格式。</target>
        </trans-unit>
        <trans-unit id="1330a0c8c8c0bac23fcad77a5abcbf9b765e263a" translate="yes" xml:space="preserve">
          <source>A more efficient approach is to remember the last entry currently displayed and then use a row value comparison in the WHERE clause:</source>
          <target state="translated">一个更有效的方法是记住当前显示的最后一个条目,然后在WHERE子句中使用行值比较。</target>
        </trans-unit>
        <trans-unit id="cfada028d3ce37e834b96c227e215c6f74539e9e" translate="yes" xml:space="preserve">
          <source>A multi-column index follows the same pattern as a single-column index; the indexed columns are added in front of the rowid. The only difference is that now multiple columns are added. The left-most column is the primary key used for ordering the rows in the index. The second column is used to break ties in the left-most column. If there were a third column, it would be used to break ties for the first two columns. And so forth for all columns in the index. Because rowid is guaranteed to be unique, every row of the index will be unique even if all of the content columns for two rows are the same. That case does not happen in our sample data, but there is one case (fruit='Orange') where there is a tie on the first column which must be broken by the second column.</source>
          <target state="translated">多列索引与单列索引的模式相同;索引列被添加在 rowid 的前面。唯一的区别是现在增加了多列。最左边的一列是主键,用于对索引中的行进行排序。第二列用来打破最左边列的束缚。如果有第三列,它将用于打破前两列的平局。以此类推,用于索引中的所有列。因为rowid是保证唯一的,所以即使两行的所有内容列都一样,索引的每一行都是唯一的。这种情况在我们的样本数据中并没有发生,但是有一种情况(fruit='Orange'),第一列上有一个并列,必须由第二列来打破。</target>
        </trans-unit>
        <trans-unit id="7f562249be7affb427174375ce85f9677d3d8ba0" translate="yes" xml:space="preserve">
          <source>A nearby diagram shows the main components of SQLite and how they interoperate. The text below explains the roles of the various components.</source>
          <target state="translated">附近的一张图显示了SQLite的主要组件以及它们是如何相互操作的。下面的文字解释了各种组件的作用。</target>
        </trans-unit>
        <trans-unit id="089a318d287cfcafbb763115d5d6b053c8d7bc38" translate="yes" xml:space="preserve">
          <source>A new R*Tree index is created as follows:</source>
          <target state="translated">新的R*Tree索引创建如下。</target>
        </trans-unit>
        <trans-unit id="64a48a9b58450b09d0cfb9d4aa090ba17af83a99" translate="yes" xml:space="preserve">
          <source>A new VFS is implemented by subclassing three objects:</source>
          <target state="translated">一个新的VFS是通过子类化三个对象来实现的。</target>
        </trans-unit>
        <trans-unit id="c89d2ee009f148a6ac5458e28252dd05648bb979" translate="yes" xml:space="preserve">
          <source>A new algorithm for statements of the form INSERT INTO</source>
          <target state="translated">一个新的算法,用于INSERT INTO形式的语句。</target>
        </trans-unit>
        <trans-unit id="0a719325f748bb1a27f330e6d9c663cf611a3f59" translate="yes" xml:space="preserve">
          <source>A new filename constructed using &lt;a href=&quot;#sqlite3_create_filename&quot;&gt;sqlite3_create_filename()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#sqlite3_create_filename&quot;&gt;sqlite3_create_filename（）&lt;/a&gt;构造的新文件名。</target>
        </trans-unit>
        <trans-unit id="fb1283a78c873d763b7bafe624f1c1082569445b" translate="yes" xml:space="preserve">
          <source>A new filename constructed using &lt;a href=&quot;create_filename&quot;&gt;sqlite3_create_filename()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;create_filename&quot;&gt;sqlite3_create_filename（）&lt;/a&gt;构造的新文件名。</target>
        </trans-unit>
        <trans-unit id="9387ece4f279e3ed8f65e6b38d71e87ff67c981e" translate="yes" xml:space="preserve">
          <source>A new flag &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; is made available to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface.</source>
          <target state="translated">新的标志&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;可用于&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="82571217188a60c8f7271b16be25afd37dc1bf34" translate="yes" xml:space="preserve">
          <source>A new interface has been added to provided additional control over the creation of new database connections: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The legacy interfaces of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; continue to be fully supported.</source>
          <target state="translated">添加了一个新接口，以提供对新数据库连接创建的其他控制：&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;。&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;的旧界面继续得到完全支持。</target>
        </trans-unit>
        <trans-unit id="ff7504ffc80677e48bad7daae529fd681b4630cb" translate="yes" xml:space="preserve">
          <source>A new union-vtab instance is created as follows:</source>
          <target state="translated">新的union-vtab实例创建如下。</target>
        </trans-unit>
        <trans-unit id="21f615460738794433e991ce2ff6b478badda600" translate="yes" xml:space="preserve">
          <source>A non-NULL text value must be specified for the name column. It is an error if the specified name already exists in the archive.</source>
          <target state="translated">必须为name列指定一个非null的文本值。如果指定的名称已经存在于档案中,则会出现错误。</target>
        </trans-unit>
        <trans-unit id="44ae7e61487d1800801d4d106af7abaadcf50460" translate="yes" xml:space="preserve">
          <source>A non-root b-tree page. The page number is the parent b-tree page.</source>
          <target state="translated">一个非根b-tree页面。页码是父b树页。</target>
        </trans-unit>
        <trans-unit id="f8e201e2c3e74fe126c7287d5626bd1b0950b6b8" translate="yes" xml:space="preserve">
          <source>A null-terminated string containing the text of one or more SQL statements and/or queries to be processed.</source>
          <target state="translated">一个空头字符串,包含一个或多个要处理的SQL语句和/或查询的文本。</target>
        </trans-unit>
        <trans-unit id="43fd742955a943f2d8d68ae03590be0ffb9da9fd" translate="yes" xml:space="preserve">
          <source>A page in an overflow chain other than the first page. The page number is the prior page of the overflow chain.</source>
          <target state="translated">溢出链中除第一页以外的页面。页码是溢出链的前一页。</target>
        </trans-unit>
        <trans-unit id="d92232575e7ddb99b286147d87a7eb37c112dd51" translate="yes" xml:space="preserve">
          <source>A page is journalled by adding a</source>
          <target state="translated">一个页面通过添加一个</target>
        </trans-unit>
        <trans-unit id="67d41f5dca0e121bb84e085c18fb28ea2c138474" translate="yes" xml:space="preserve">
          <source>A parenthesized, comma-separated list of scalar values.</source>
          <target state="translated">一个用小括号、逗号分隔的标量值列表。</target>
        </trans-unit>
        <trans-unit id="9ef2906548f6946959e71df0c261521f3831b983" translate="yes" xml:space="preserve">
          <source>A partial index definition may include the UNIQUE keyword. If it does, then SQLite requires every entry &lt;em&gt;in the index&lt;/em&gt; to be unique. This provides a mechanism for enforcing uniqueness across some subset of the rows in a table.</source>
          <target state="translated">部分索引定义可以包含UNIQUE关键字。如果是这样，则SQLite要求&lt;em&gt;索引中的&lt;/em&gt;每个条目都是唯一的。这提供了一种在表中的行的某些子集上强制唯一性的机制。</target>
        </trans-unit>
        <trans-unit id="1bf63cba8a9d42e2054c36a2ad3d1ea049c41b10" translate="yes" xml:space="preserve">
          <source>A partial index is an index over a subset of the rows of a table.</source>
          <target state="translated">部分索引是表的行的子集的索引。</target>
        </trans-unit>
        <trans-unit id="5d5173a741f61feaf55620d5f7f757f59051d29a" translate="yes" xml:space="preserve">
          <source>A patchset blob may be used with up to date versions of all sqlite3changeset_xxx API functions except for sqlite3changeset_invert(), which returns SQLITE_CORRUPT if it is passed a patchset. Similarly, attempting to use a patchset blob with old versions of the sqlite3changeset_xxx APIs also provokes an SQLITE_CORRUPT error.</source>
          <target state="translated">一个补丁集blob可以用于所有最新版本的sqlite3changeset_xxx API函数,除了sqlite3changeset_invert(),如果传递了一个补丁集,它会返回SQLITE_CORRUPT。同样,试图使用补丁集blob与旧版本的sqlite3changeset_xxx APIs一起使用也会引发SQLITE_CORRUPT错误。</target>
        </trans-unit>
        <trans-unit id="e65df542e5b2ab6d391d8808bfc9bfd9a42dd1c8" translate="yes" xml:space="preserve">
          <source>A patchset is similar to a changeset. It is slightly more compact than a changeset, but provides more limited conflict detection and resolution options (see the next section for details). The differences between a patchset and a changeset are that:</source>
          <target state="translated">修补集与变更集类似。它比变更集更紧凑,但提供的冲突检测和解决选项更有限(详见下一节)。修补集和变更集的区别在于:1:</target>
        </trans-unit>
        <trans-unit id="6c8a1598f2157bb3e660a70a2c1195f71bea8641" translate="yes" xml:space="preserve">
          <source>A payload overflow page</source>
          <target state="translated">一个有效载荷溢出页</target>
        </trans-unit>
        <trans-unit id="40fb2ed4e8bd2a3775c9d2eeb2d4e37e28a73a34" translate="yes" xml:space="preserve">
          <source>A pending lock allows other processes that already have a shared lock to continue reading the database file. But it prevents new shared locks from being established. The idea behind a pending lock is to prevent writer starvation caused by a large pool of readers. There might be dozens, even hundreds, of other processes trying to read the database file. Each process acquires a shared lock before it starts reading, reads what it needs, then releases the shared lock. If, however, there are many different processes all reading from the same database, it might happen that a new process always acquires its shared lock before the previous process releases its shared lock. And so there is never an instant when there are no shared locks on the database file and hence there is never an opportunity for the writer to seize the exclusive lock. A pending lock is designed to prevent that cycle by allowing existing shared locks to proceed but blocking new shared locks from being established. Eventually all shared locks will clear and the pending lock will then be able to escalate into an exclusive lock.</source>
          <target state="translated">待定锁允许已经有共享锁的其他进程继续读取数据库文件。但它阻止了新的共享锁的建立。待定锁背后的想法是为了防止由一个大的读者池引起的写手饥饿。可能会有几十个,甚至上百个其他进程试图读取数据库文件。每个进程在开始读取之前都会获得一个共享锁,读取它需要的内容,然后释放共享锁。然而,如果有许多不同的进程都从同一个数据库中读取,那么可能会发生这样的情况:一个新的进程总是在前一个进程释放其共享锁之前获得其共享锁。所以,数据库文件上永远没有共享锁的瞬间,因此,写作者永远没有机会夺取独占锁。挂锁就是为了防止这种循环,它允许现有的共享锁继续进行,但阻止新的共享锁建立。最终,所有共享锁将被清除,待定锁将能够升级为独占锁。</target>
        </trans-unit>
        <trans-unit id="cfdf078a1ad97afe7d10282a6193866f5d046f1b" translate="yes" xml:space="preserve">
          <source>A performance enhancement to the page-cache &quot;truncate&quot; operation reduces &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; time by dozens of milliseconds on systems with a large &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;page cache&lt;/a&gt;.</source>
          <target state="translated">页面高速缓存&amp;ldquo;截断&amp;rdquo;操作的性能增强在具有大&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;页面高速缓存的&lt;/a&gt;系统上将&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;时间减少了数十毫秒。</target>
        </trans-unit>
        <trans-unit id="d3934877796a31e3b44b08445cac9678ddebadf6" translate="yes" xml:space="preserve">
          <source>A phrase matches a document if the document contains at least one sub-sequence of tokens that matches the sequence of tokens that make up the phrase.</source>
          <target state="translated">如果文档中至少有一个子序列的标记与构成该短语的标记序列相匹配,则该短语与文档相匹配。</target>
        </trans-unit>
        <trans-unit id="aad9a1c432b5f54ebccf2d84436734289434a755" translate="yes" xml:space="preserve">
          <source>A pile-of-files encourages content to be stored in a few large chunks. In the case of ODP, there are just four XML files that define the layout off all slides in a presentation. An SQLite database allows storing information in a few large chunks, but SQLite is also adept and efficient at storing information in numerous smaller pieces.</source>
          <target state="translated">一堆文件鼓励将内容存储在几大块中。在ODP的情况下,只有四个XML文件定义了演示文稿中所有幻灯片的布局。SQLite数据库允许以几大块的形式存储信息,但SQLite也善于并有效地将信息存储在许多小块中。</target>
        </trans-unit>
        <trans-unit id="95a8394ec4ac0fe21d190c15e56ba33ddbedef33" translate="yes" xml:space="preserve">
          <source>A pile-of-files format can be read incrementally just like SQLite. But many developers are surprised to learn that SQLite can read and write smaller BLOBs (less than about 100KB in size) from its database faster than those same blobs can be read or written as separate files from the filesystem. (See &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; and &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; for further information.) There is overhead associated with operating a relational database engine, however one should not assume that direct file I/O is faster than SQLite database I/O, as often it is not.</source>
          <target state="translated">可以像SQLite一样增量读取文件堆格式。但是许多开发人员惊讶地发现，SQLite可以从其数据库读取和写入较小的BLOB（大小小于100KB）的速度快于那些相同的Blob可以作为独立于文件系统的文件进行读取或写入的速度。（有关更多信息，请参见&lt;a href=&quot;fasterthanfs&quot;&gt;比文件系统&lt;/a&gt;和&lt;a href=&quot;intern-v-extern-blob&quot;&gt;内部BLOB &lt;/a&gt;比内部BLOB 快35％。）与操作关系数据库引擎相关的开销很大，但是，不应假定直接文件I / O比SQLite数据库I / O快，因为通常不是。</target>
        </trans-unit>
        <trans-unit id="6baa78bd5928c61d383f2bef11579e65db7d21d3" translate="yes" xml:space="preserve">
          <source>A pile-of-files format can be viewed as a key/value database. A key/value database is better than no database at all. But without transactions or indices or a high-level query language or a proper schema, it is much harder and more error prone to use a key/value database than a relational database.</source>
          <target state="translated">文件堆格式可以看作是一个键/值数据库。一个键/值数据库总比没有数据库要好。但是,如果没有事务或索引或高级查询语言或适当的模式,使用键/值数据库比使用关系型数据库要难得多,也更容易出错。</target>
        </trans-unit>
        <trans-unit id="52eaf71372365322d7054ef987ab3062057c54cd" translate="yes" xml:space="preserve">
          <source>A pointer map page</source>
          <target state="translated">指针式地图页面</target>
        </trans-unit>
        <trans-unit id="3b58d729b79685a69c83a9e7290179a156089320" translate="yes" xml:space="preserve">
          <source>A pointer that is forwarded to become the first argument to the callback function.</source>
          <target state="translated">一个指针,被转发成为回调函数的第一个参数。</target>
        </trans-unit>
        <trans-unit id="7862edef6bec5bc1b7b5c7480359b6ac1ea3fe42" translate="yes" xml:space="preserve">
          <source>A pointer to a callback function which is invoked once for each row in the result of a query. This argument may be NULL, in which case no callbacks will ever be invoked.</source>
          <target state="translated">指向回调函数的指针,该函数对查询结果中的每一行都会被调用一次。这个参数可以是NULL,在这种情况下,不会调用回调函数。</target>
        </trans-unit>
        <trans-unit id="36a5146ef90ea88c9791d18d9b2f0b91bd10d7bf" translate="yes" xml:space="preserve">
          <source>A pointer to an error string. Error messages are written to space obtained from malloc() and the error string is made to point to the malloced space. The calling function is responsible for freeing this space when it has finished with it. This argument may be NULL, in which case error messages are not reported back to the calling function.</source>
          <target state="translated">一个指向错误字符串的指针。错误信息被写入从malloc()获得的空间,错误字符串被制作成指向malloced空间。调用函数负责在用完这个空间后释放它。这个参数可能是NULL,在这种情况下,错误信息不会返回给调用函数。</target>
        </trans-unit>
        <trans-unit id="0b85ea2771637242c212f75c32dcf4f1c99ff7a4" translate="yes" xml:space="preserve">
          <source>A pointer to the opaque sqlite3_api_routines structure is passed as the third parameter to entry points of &lt;a href=&quot;../loadext&quot;&gt;loadable extensions&lt;/a&gt;. This structure must be typedefed in order to work around compiler warnings on some platforms.</source>
          <target state="translated">指向不透明的sqlite3_api_routines结构的指针作为第三个参数传递到&lt;a href=&quot;../loadext&quot;&gt;可加载扩展的&lt;/a&gt;入口点。必须对这种结构进行类型定义，以便在某些平台上解决编译器警告。</target>
        </trans-unit>
        <trans-unit id="b2d07e71fb26035e20fdffa2af9f1c6c108edfd9" translate="yes" xml:space="preserve">
          <source>A pointer to the opaque sqlite3_api_routines structure is passed as the third parameter to entry points of &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. This structure must be typedefed in order to work around compiler warnings on some platforms.</source>
          <target state="translated">指向不透明的sqlite3_api_routines结构的指针作为第三个参数传递到&lt;a href=&quot;loadext&quot;&gt;可加载扩展的&lt;/a&gt;入口点。必须对这种结构进行类型定义，以便在某些平台上解决编译器警告。</target>
        </trans-unit>
        <trans-unit id="ec59a85cc0f126d0446beb84b628cc1897023e1d" translate="yes" xml:space="preserve">
          <source>A pointer to the sqlite structure obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="translated">指向从&lt;b&gt;sqlite_open&lt;/b&gt;的先前调用获得的sqlite结构的指针。</target>
        </trans-unit>
        <trans-unit id="a83e616cb2fe97cb47d6b546b005133e60c0010f" translate="yes" xml:space="preserve">
          <source>A pointer to the virtual machine is stored in a pointer which is passed in as the 4th parameter. Space to hold the virtual machine is dynamically allocated. To avoid a memory leak, the calling function must invoke &lt;b&gt;sqlite_finalize&lt;/b&gt; on the virtual machine after it has finished with it. The 4th parameter may be set to NULL if an error is encountered during compilation.</source>
          <target state="translated">指向虚拟机的指针存储在作为第4个参数传递的指针中。用于容纳虚拟机的空间是动态分配的。为避免内存泄漏，调用函数完成后必须在虚拟机上调用&lt;b&gt;sqlite_finalize&lt;/b&gt;。如果在编译过程中遇到错误，则可以将第4个参数设置为NULL。</target>
        </trans-unit>
        <trans-unit id="f4123ec647ffbea69c18e776fd8ad4e58f6d7bab" translate="yes" xml:space="preserve">
          <source>A polygon is defined by its vertexes. Each vertex is a JSON array of two numeric values which are the X and Y coordinates of the vertex. A polygon is a JSON array of at least four of these vertexes, and hence is an array of arrays. The first and last vertex in the array must be the same. The polygon follows the right-hand rule: When tracing a line from one vertex to the next, the area to the right of the line is outside of the polygon and the area to the left is inside the polygon. In other words, the net rotation of the vertexes is counter-clockwise.</source>
          <target state="translated">多边形是由它的顶点定义的。每个顶点是由两个数值组成的JSON数组,它们是顶点的X和Y坐标。一个多边形是由至少四个顶点组成的JSON数组,因此是一个数组。数组中的第一个和最后一个顶点必须是相同的。多边形遵循右手规则。当追踪一条从一个顶点到下一个顶点的直线时 线条右边的区域在多边形的外面 而左边的区域在多边形的内部。换句话说,顶点的净旋转是逆时针的。</target>
        </trans-unit>
        <trans-unit id="83be320cc6f7531e133a8fe75643df0ab1bd341d" translate="yes" xml:space="preserve">
          <source>A pragma can take either zero or one argument. The argument is may be either in parentheses or it may be separated from the pragma name by an equal sign. The two syntaxes yield identical results. In many pragmas, the argument is a boolean. The boolean can be one of:</source>
          <target state="translated">一个pragma可以接受零或一个参数。参数is可以放在括号中,也可以从pragma名称中用等号分开。这两种语法产生的结果是相同的。在许多实用名词中,参数是布尔值。布尔型参数可以是以下两种类型之一:</target>
        </trans-unit>
        <trans-unit id="1439b9f8c7100215a693725c95a80144f9686663" translate="yes" xml:space="preserve">
          <source>A pragma may have an optional schema-name before the pragma name. The schema-name is the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database or &quot;main&quot; or &quot;temp&quot; for the main and the TEMP databases. If the optional schema name is omitted, &quot;main&quot; is assumed. In some pragmas, the schema name is meaningless and is simply ignored. In the documentation below, pragmas for which the schema name is meaningful are shown with a &quot;</source>
          <target state="translated">编译指示可以在编译指示名称之前具有可选的架构名称。 schema-name是&lt;a href=&quot;lang_attach&quot;&gt;ATTACH编辑的&lt;/a&gt;数据库的名称，或者是main和TEMP数据库的&amp;ldquo; main&amp;rdquo;或&amp;ldquo; temp&amp;rdquo;名称。如果省略了可选的架构名称，则假定为&amp;ldquo; main&amp;rdquo;。在某些语用上，模式名称是没有意义的，只是被忽略。在下面的文档中，架构名称对其有意义的编译指示显示为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="86c8a11b948e6795af6a6ceb139ca3117a5cbdfe" translate="yes" xml:space="preserve">
          <source>A prefix index is a separate index that records the location of all instances of prefix tokens of a certain length in characters used to speed up queries for prefix tokens. For example, optimizing a query for prefix token &quot;abc*&quot; requires a prefix index of three-character prefixes.</source>
          <target state="translated">前缀索引是一个独立的索引,它记录了一定长度的前缀标记的所有实例的位置,以字符为单位,用于加快前缀标记的查询。例如,优化对前缀标记 &quot;abc*&quot;的查询,需要一个三字符前缀的前缀索引。</target>
        </trans-unit>
        <trans-unit id="b552ccb7eeae1cbc2221248d3b23583ca4696c9f" translate="yes" xml:space="preserve">
          <source>A prepared statement can have zero or more open cursors. Each cursor is identified by a small integer, which is usually the P1 parameter to the opcode that uses the cursor. There can be multiple cursors open on the same index or table. All cursors operate independently, even cursors pointing to the same indices or tables. The only way for the virtual machine to interact with a database file is through a cursor. Instructions in the virtual machine can create a new cursor (ex: &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; or &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;), read data from a cursor (&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;), advance the cursor to the next entry in the table (ex: &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;), and so forth. All cursors are automatically closed when the prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">一个准备好的语句可以有零个或多个打开的游标。每个游标都由一个小整数标识，该整数通常是使用游标的操作码的P1参数。在同一索引或表上可以打开多个游标。所有游标都独立运行，即使游标指向相同的索引或表也是如此。虚拟机与数据库文件交互的唯一方法是通过游标。虚拟机中的指令可以创建一个新的游标（例如：&lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;或&lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;），从游标中读取数据（&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;），将游标前进到表中的下一个条目（例如：&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;或&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;），等等。&lt;a href=&quot;c3ref/reset&quot;&gt;重置&lt;/a&gt;准备好的语句后，所有游标都会自动关闭或已&lt;a href=&quot;c3ref/finalize&quot;&gt;完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3128db754cafeec12014626682cba0f5822aef4d" translate="yes" xml:space="preserve">
          <source>A primer on &lt;a href=&quot;howitworks&quot;&gt;How SQLite Works&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;howitworks&quot;&gt;SQLite的工作原理&lt;/a&gt;入门。</target>
        </trans-unit>
        <trans-unit id="9e5a41eea2027bd1c81329dfc78cb1162a2b5985" translate="yes" xml:space="preserve">
          <source>A pseudo-table created by this opcode is used to hold a single row output from the sorter so that the row can be decomposed into individual columns using the &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode is the only cursor opcode that works with a pseudo-table.</source>
          <target state="translated">此操作码创建的伪表用于保存排序器的单行输出，以便可以使用&amp;ldquo; &lt;a href=&quot;opcode#Column&quot;&gt;列&amp;rdquo;&lt;/a&gt;操作码将行分解为单独的列。该&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;码是唯一的光标操作码与伪表的作品。</target>
        </trans-unit>
        <trans-unit id="5cfba3e1d0f3aba9e4771931b3f9186e0cfec67a" translate="yes" xml:space="preserve">
          <source>A query plan is represented as a tree. In raw form, as returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, each node of the tree consists of four fields: An integer node id, an integer parent id, an auxiliary integer field that is not currently used, and a description of the node. The entire tree is therefore a table with four columns and zero or more rows. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will usually intercept this table and renders it as an ASCII-art graph for more convenient viewing. To defeat the shells automatic graph rendering, simply include extra white space in between any of the &quot;EXPLAIN&quot;, &quot;QUERY&quot;, and/or &quot;PLAN&quot; keywords and the output will appear in a (less helpful) tabular format.</source>
          <target state="translated">查询计划表示为树。以原始格式显示&lt;a href=&quot;c3ref/step&quot;&gt;（&lt;/a&gt;由sqlite3_step（）返回），树的每个节点均包含四个字段：整数节点ID，整数父ID，当前未使用的辅助整数字段以及节点的描述。因此，整个树是一个具有四列和零个或更多行的表。该&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;通常会拦截该表并使得它作为一个ASCII艺术图表更方便观看。要击败shell自动图形渲染，只需在&amp;ldquo; EXPLAIN&amp;rdquo;，&amp;ldquo; QUERY&amp;rdquo;和/或&amp;ldquo; PLAN&amp;rdquo;关键字之间添加多余的空格，输出将以（不太有用的）表格格式显示。</target>
        </trans-unit>
        <trans-unit id="3aa6dc6aaac817be80debe7e4af4df4ff711024e" translate="yes" xml:space="preserve">
          <source>A query plan is represented as a tree. In raw form, as returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, each node of the tree consists of four fields: An integer node id, an integer parent id, an auxiliary integer field that is not currently used, and a description of the node. The entire tree is therefore a table with four columns and zero or more rows. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will usually intercept this table and renders it as an ASCII-art graph for more convenient viewing. To disable the shells automatic graph rendering and to display EXPLAIN QUERY PLAN output in its tabular format, run the command &quot;.explain off&quot; to set the &quot;EXPLAIN formatting mode&quot; to off. To restore automatic graph rendering, run &quot;.explain auto&quot;. You can see the current &quot;EXPLAIN formatting mode&quot; setting using the &quot;.show&quot; command.</source>
          <target state="translated">查询计划表示为树。以原始格式显示（如&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回的），树的每个节点均包含四个字段：整数节点ID，整数父ID，当前未使用的辅助整数字段以及节点的描述。因此，整个树是一个具有四列和零个或更多行的表。该&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;通常会拦截该表并使得它作为一个ASCII艺术图表更方便观看。要禁用Shell自动图形渲染并以表格格式显示EXPLAIN QUERY PLAN输出，请运行命令&amp;ldquo; .explain off&amp;rdquo;以将&amp;ldquo; EXPLAIN格式设置模式&amp;rdquo;设置为off。要恢复自动图形渲染，请运行&amp;ldquo; .explain auto&amp;rdquo;。您可以看到当前的&amp;ldquo; EXPLAIN格式化模式&amp;rdquo;使用&amp;ldquo; .show&amp;rdquo;命令进行设置。</target>
        </trans-unit>
        <trans-unit id="987ff31ff0ec375872e214a21f32922e046b143e" translate="yes" xml:space="preserve">
          <source>A query sees all changes that are completed on the same database connection prior to the start of the query, regardless of whether or not those changes have been committed.</source>
          <target state="translated">查询可以看到在查询开始之前,在同一个数据库连接上完成的所有更改,无论这些更改是否已经提交。</target>
        </trans-unit>
        <trans-unit id="91d5213dcc2c8331ce561f8806234820515ddce9" translate="yes" xml:space="preserve">
          <source>A quick enumeration of the changes in SQLite version 3.5.0 is provided here. Subsequent sections will describe these changes in more detail.</source>
          <target state="translated">这里提供了SQLite 3.5.0版本的快速列举。后面的章节将更详细地描述这些变化。</target>
        </trans-unit>
        <trans-unit id="f1276c60969bd19155a8ae4ef6b0cf70c5a9044f" translate="yes" xml:space="preserve">
          <source>A random nonce for the checksum</source>
          <target state="translated">校验和的随机非记号</target>
        </trans-unit>
        <trans-unit id="e714ea743566ecda01d0b9ba96c42399b2c76767" translate="yes" xml:space="preserve">
          <source>A read transaction is used for reading only. A write transaction allows both reading and writing. A read transaction is started by a SELECT statement, and a write transaction is started by statements like CREATE, DELETE, DROP, INSERT, or UPDATE (collectively &quot;write statements&quot;). If a write statement occurs while a read transaction is active, then the read transaction is upgraded to a write transaction if possible. If some other database connection has already modified the database or is already in the process of modifying the database, then upgrading to a write transaction is not possible and the write statement will fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">读事务仅用于读取。写入事务允许读取和写入。读事务由SELECT语句启动，写事务由CREATE，DELETE，DROP，INSERT或UPDATE之类的语句（统称为&amp;ldquo;写语句&amp;rdquo;）启动。如果在读事务处于活动状态时发生写语句，则在可能的情况下将读事务升级为写事务。如果某些其他数据库连接已经修改了数据库或正在修改数据库，则无法升级到写入事务，并且&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;会导致写入语句失败。</target>
        </trans-unit>
        <trans-unit id="b3bb741ebe526223297eaf9b1bcbc9817350f52d" translate="yes" xml:space="preserve">
          <source>A read transaction is used for reading only. A write transaction allows both reading and writing. A read transaction is started by a SELECT statement, and a write transaction is started by statements like CREATE, DELETE, DROP, INSERT, or UPDATE (collectively &quot;write statements&quot;). If a write statement occurs while a read transaction is active, then the read transaction is upgraded to write transaction if possible. If some other database connection has already modified the database or is already in the process of modifying the database, then upgrading to a write transaction is not possible and the write statement will fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">读事务仅用于读取。写入事务允许读取和写入。读事务由SELECT语句启动，写事务由CREATE，DELETE，DROP，INSERT或UPDATE之类的语句（统称为&amp;ldquo;写语句&amp;rdquo;）启动。如果在读事务处于活动状态时发生写语句，则在可能的情况下将读事务升级为写事务。如果某些其他数据库连接已经修改了数据库或正在修改数据库，则无法升级到写事务，并且&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;将导致写语句失败。</target>
        </trans-unit>
        <trans-unit id="d3e78c57da493fb53e9af08b8cbcf76787c9e57d" translate="yes" xml:space="preserve">
          <source>A read-only connection that is rebuilding its private heap-memory WAL-index does not hold this lock. (It cannot, since read-only connections are not allowed to hold any exclusive locks.) This lock is only held when rebuilding the global shared WAL-index contained in the memory-mapped SHM file.</source>
          <target state="translated">一个正在重建其私有堆内存WAL-index的只读连接不持有这个锁。不能,因为只读连接不允许持有任何专属锁)。只有在重建内存映射的SHM文件中包含的全局共享WAL-索引时,才会持有这个锁。</target>
        </trans-unit>
        <trans-unit id="4cbb00ca2a5b578f8c701ce299cc1bdaf023483d" translate="yes" xml:space="preserve">
          <source>A record contains a header and a body, in that order. The header begins with a single varint which determines the total number of bytes in the header. The varint value is the size of the header in bytes including the size varint itself. Following the size varint are one or more additional varints, one per column. These additional varints are called &quot;serial type&quot; numbers and determine the datatype of each column, according to the following chart:</source>
          <target state="translated">一条记录按顺序包含一个头和一个主体。头部以一个varint开始,它决定了头部的总字节数。varint的值是以字节为单位的头的大小,包括size varint本身。在size varint之后是一个或多个附加的varint,每列一个。这些附加的varint称为 &quot;序列类型 &quot;号,根据下图确定每列的数据类型。</target>
        </trans-unit>
        <trans-unit id="da56351fba5f53698fda54910e0c1f0207d7d3fd" translate="yes" xml:space="preserve">
          <source>A record might have fewer values than the number of columns in the corresponding table. This can happen, for example, after an &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; SQL statement has increased the number of columns in the table schema without modifying preexisting rows in the table. Missing values at the end of the record are filled in using the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; for the corresponding columns defined in the table schema.</source>
          <target state="translated">一条记录的值可能少于相应表中的列数。例如，在&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; SQL语句增加了表架构中的列数而不修改表中已有的行之后，可能会发生这种情况。记录末尾的缺失值使用表模式中定义的对应列的&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认值&lt;/a&gt;填充。</target>
        </trans-unit>
        <trans-unit id="217400d8125cae070ab923af39a99cd07148eec1" translate="yes" xml:space="preserve">
          <source>A recursive common table expression can be used to write a query that walks a tree or graph. A recursive common table expression has the same basic syntax as an ordinary common table expression, but with the following additional attributes:</source>
          <target state="translated">递归通用表表达式可以用来写一个走树或图的查询。递归通用表表达式的基本语法与普通通用表表达式相同,但具有以下附加属性。</target>
        </trans-unit>
        <trans-unit id="9e5c8169a30113a9ed52f687099166107e7b2523" translate="yes" xml:space="preserve">
          <source>A recursive common table expression can be used to write a query that walks a tree or graph. A recursive common table expression has the same basic syntax as an ordinary common table expression, but with the following additional features:</source>
          <target state="translated">递归通用表表达式可以用来写一个走树或图的查询。递归通用表表达式的基本语法与普通通用表表达式相同,但具有以下附加功能。</target>
        </trans-unit>
        <trans-unit id="176317ddd357b266ebf755cfa3f6bc813ff788c9" translate="yes" xml:space="preserve">
          <source>A reference to &lt;b&gt;the associated &lt;i&gt;database connection&lt;/i&gt;&lt;/b&gt;. Each entry in the</source>
          <target state="translated">&lt;b&gt;对关联&lt;i&gt;数据库连接的&lt;/i&gt;&lt;/b&gt;引用。中的每个条目</target>
        </trans-unit>
        <trans-unit id="e876211f841b1a5a0841faa539bd0f497224e5b7" translate="yes" xml:space="preserve">
          <source>A register can also be &quot;Undefined&quot; meaning that it holds no value at all. Undefined is different from NULL. Depending on compile-time options, an attempt to read an undefined register will usually cause a run-time error. If the code generator (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;) ever generates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that reads an Undefined register, that is a bug in the code generator.</source>
          <target state="translated">寄存器也可以是&amp;ldquo;未定义&amp;rdquo;的，这意味着它根本没有任何值。未定义与NULL不同。根据编译时选项，尝试读取未定义的寄存器通常会导致运行时错误。如果代码生成器（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;）生成了一条&lt;a href=&quot;c3ref/stmt&quot;&gt;准备就绪的语句&lt;/a&gt;来读取未定义的寄存器，则这是代码生成器中的错误。</target>
        </trans-unit>
        <trans-unit id="2a489dc4470d6b0b8e6fff51584f1f564a2e53cf" translate="yes" xml:space="preserve">
          <source>A result table is an array of pointers to zero-terminated UTF-8 strings. There are (N+1)*M elements in the array. The first M pointers point to zero-terminated strings that contain the names of the columns. The remaining entries all point to query results. NULL values result in NULL pointers. All other values are in their UTF-8 zero-terminated string representation as returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;.</source>
          <target state="translated">结果表是指向以零结尾的UTF-8字符串的指针的数组。数组中有（N + 1）* M个元素。前M个指针指向包含列名称的零终止字符串。其余条目均指向查询结果。NULL值导致NULL指针。所有其他值均以&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;返回的UTF-8零终止字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="5699300dbfc9bd124afc697b07363b109eb2de77" translate="yes" xml:space="preserve">
          <source>A result table is an array of pointers to zero-terminated UTF-8 strings. There are (N+1)*M elements in the array. The first M pointers point to zero-terminated strings that contain the names of the columns. The remaining entries all point to query results. NULL values result in NULL pointers. All other values are in their UTF-8 zero-terminated string representation as returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;.</source>
          <target state="translated">结果表是指向以零结尾的UTF-8字符串的指针的数组。数组中有（N + 1）* M个元素。前M个指针指向包含列名称的零终止字符串。其余条目均指向查询结果。NULL值导致NULL指针。所有其他值均以&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;返回的UTF-8零终止字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="0c7b119b5d4d81d6f920e05ce966ec036ccb516b" translate="yes" xml:space="preserve">
          <source>A result table might consist of one or more memory allocations. It is not safe to pass a result table directly to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. A result table should be deallocated using &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt;.</source>
          <target state="translated">结果表可能包含一个或多个内存分配。将结果表直接传递到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;是不安全的。应该使用&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table（）&lt;/a&gt;释放结果表。</target>
        </trans-unit>
        <trans-unit id="b9f7610b427ba3a5db84c1d578ca567b66e4baef" translate="yes" xml:space="preserve">
          <source>A result table might consist of one or more memory allocations. It is not safe to pass a result table directly to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. A result table should be deallocated using &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt;.</source>
          <target state="translated">结果表可能包含一个或多个内存分配。将结果表直接传递到&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;是不安全的。应该使用&lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table（）&lt;/a&gt;释放结果表。</target>
        </trans-unit>
        <trans-unit id="9c8be34ce66bc36d8a3f910227d25c082cf34040" translate="yes" xml:space="preserve">
          <source>A return of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; from sqlite3_backup_step() is not a permanent error and does not affect the return value of sqlite3_backup_finish().</source>
          <target state="translated">从sqlite3_backup_step（）返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;不是永久错误，并且不会影响sqlite3_backup_finish（）的返回值。</target>
        </trans-unit>
        <trans-unit id="d3ccc60d216c44abcc74c0cabe1a2c3a2883ce18" translate="yes" xml:space="preserve">
          <source>A return of &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; or &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; from sqlite3_backup_step() is not a permanent error and does not affect the return value of sqlite3_backup_finish().</source>
          <target state="translated">从sqlite3_backup_step（）返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;或&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;不是永久错误，并且不会影响sqlite3_backup_finish（）的返回值。</target>
        </trans-unit>
        <trans-unit id="79663f33ba3ea21585830534cfcf02f738ed2ade" translate="yes" xml:space="preserve">
          <source>A rich library of &lt;a href=&quot;lang_corefunc&quot;&gt;standard SQL functions&lt;/a&gt;</source>
          <target state="translated">丰富的&lt;a href=&quot;lang_corefunc&quot;&gt;标准SQL函数&lt;/a&gt;库</target>
        </trans-unit>
        <trans-unit id="5984037d329bed4e182dea84884ebbc957606423" translate="yes" xml:space="preserve">
          <source>A rollback journal header is padded with zeros out to the size of a single sector (as defined by the sector size integer at offset 20). The header is in a sector by itself so that if a power loss occurs while writing the sector, information that follows the header will be (hopefully) undamaged.</source>
          <target state="translated">回滚日志头用零填充到一个扇区的大小(由偏移量20的扇区大小整数定义)。页眉本身就在一个扇区中,因此,如果在写扇区时发生断电,页眉后面的信息将(希望)不会受到损坏。</target>
        </trans-unit>
        <trans-unit id="da825d373397b8ff214c898f7100fa92209fe481" translate="yes" xml:space="preserve">
          <source>A rollback journal is a &quot;hot&quot; journal if all of the following are true:</source>
          <target state="translated">如果以下情况全部为真,则回滚日志为 &quot;热 &quot;日志。</target>
        </trans-unit>
        <trans-unit id="93117b5d93400d4aff3d9fc5e17e1f968466bd65" translate="yes" xml:space="preserve">
          <source>A rollback journal is a temporary file used to implement atomic commit and rollback capabilities in SQLite. (For a detailed discussion of how this works, see the separate document titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt;.) The rollback journal is always located in the same directory as the database file and has the same name as the database file except with the 8 characters &quot;&lt;b&gt;-journal&lt;/b&gt;&quot; appended. The rollback journal is usually created when a transaction is first started and is usually deleted when a transaction commits or rolls back. The rollback journal file is essential for implementing the atomic commit and rollback capabilities of SQLite. Without a rollback journal, SQLite would be unable to rollback an incomplete transaction, and if a crash or power loss occurred in the middle of a transaction the entire database would likely go corrupt without a rollback journal.</source>
          <target state="translated">回滚日志是一个临时文件，用于在SQLite中实现原子提交和回滚功能。（有关其工作方式的详细讨论，请参见标题为&lt;a href=&quot;atomiccommit&quot;&gt;SQLite&lt;/a&gt;中的Atomic Commit的单独文档。）回滚日志始终与数据库文件位于同一目录中，并且与数据库文件具有相同的名称，但8个字符除外&amp;rdquo; &lt;b&gt;-日志&lt;/b&gt;&amp;rdquo;。回滚日志通常在首次启动事务时创建，并且通常在事务提交或回滚时被删除。回滚日志文件对于实现SQLite的原子提交和回滚功能至关重要。没有回滚日志，SQLite将无法回滚一个不完整的事务，并且如果在一个事务的中间发生崩溃或断电，整个数据库很可能在没有回滚日志的情况下损坏。</target>
        </trans-unit>
        <trans-unit id="b7f61ea74ecbbdde9b91ead35df3827efa60778b" translate="yes" xml:space="preserve">
          <source>A rollback journal is only considered to be valid if it exists and contains a valid header. Hence a transaction can be committed in one of three ways:</source>
          <target state="translated">只有当回滚日志存在并包含一个有效的头时,它才被认为是有效的。因此,一个事务可以通过三种方式之一来提交。</target>
        </trans-unit>
        <trans-unit id="7bbab471bf381ac51a7c14fe650ef7023a98cf57" translate="yes" xml:space="preserve">
          <source>A rollback journal is said to be &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot&lt;/a&gt; if it needs to be rolled back in order to restore the integrity of its database. A hot journal is created when a process is in the middle of a database update and a program or operating system crash or power failure prevents the update from completing. Hot journals are an exception condition. Hot journals exist to recover from crashes and power failures. If everything is working correctly (that is, if there are no crashes or power failures) you will never get a hot journal.</source>
          <target state="translated">如果需要回滚以恢复其数据库的完整性，则认为回滚日志&lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;很热&lt;/a&gt;。当进程在数据库更新过程中且程序或操作系统崩溃或断电导致更新无法完成时，将创建热日志。热门期刊是一个例外情况。存在热日志以从崩溃和电源故障中恢复。如果一切工作正常（也就是说，没有崩溃或电源故障），您将永远不会获得最新的日志。</target>
        </trans-unit>
        <trans-unit id="52857503386ca8187f9c97fd4ff05410c36c8f77" translate="yes" xml:space="preserve">
          <source>A running SELECT statement that lacks a FROM clause (or any other statement that never reads or writes from any database file) will not prevent a read transaction from closing.</source>
          <target state="translated">运行中的SELECT语句如果缺少FROM子句(或任何其他从不从任何数据库文件中读或写的语句),将不会阻止读事务的关闭。</target>
        </trans-unit>
        <trans-unit id="7cb07d260e238ef8be6278670ca8159f485f6d07" translate="yes" xml:space="preserve">
          <source>A separate document, &lt;a href=&quot;c3ref/intro&quot;&gt;The SQLite C/C++ Interface&lt;/a&gt;, provides detailed specifications for all C/C++ APIs for SQLite. Once the reader understands the basic principles of operation for SQLite, &lt;a href=&quot;c3ref/intro&quot;&gt;that document&lt;/a&gt; should be used as a reference guide. This article is intended as introduction only and is neither a complete nor authoritative reference for the SQLite API.</source>
          <target state="translated">单独的文档&lt;a href=&quot;c3ref/intro&quot;&gt;SQLite C / C ++接口&lt;/a&gt;，为SQLite的所有C / C ++ API提供了详细规范。一旦读者了解了SQLite的基本操作原理，&lt;a href=&quot;c3ref/intro&quot;&gt;就&lt;/a&gt;应将该文档用作参考指南。本文仅作为介绍之用，既不是SQLite API的完整参考也不是权威参考。</target>
        </trans-unit>
        <trans-unit id="baa6b5660e49902a9d6721951328be3eefc3b18e" translate="yes" xml:space="preserve">
          <source>A sequence number assigned to each index for internal tracking purposes.</source>
          <target state="translated">分配给每个索引的序列号,用于内部跟踪。</target>
        </trans-unit>
        <trans-unit id="1ac44a9b2150727d7d1aea70b509f77cbf75e147" translate="yes" xml:space="preserve">
          <source>A series of tests were run to measure the relative performance of SQLite 2.7.6, PostgreSQL 7.1.3, and MySQL 3.23.41. The following are general conclusions drawn from these experiments:</source>
          <target state="translated">我们进行了一系列测试,以测量SQLite 2.7.6、PostgreSQL 7.1.3和MySQL 3.23.41的相对性能。以下是从这些实验中得出的一般结论。</target>
        </trans-unit>
        <trans-unit id="b4faee13d5e4cc6ba30a1f6541864d69478d0a60" translate="yes" xml:space="preserve">
          <source>A serious bug fixed on Windows. Windows users should upgrade. No impact to Unix.</source>
          <target state="translated">在Windows上修复了一个严重的错误。Windows用户应该升级。对Unix没有影响。</target>
        </trans-unit>
        <trans-unit id="275829adb94b5831ffff4998c0fd3b6cdf2a2059" translate="yes" xml:space="preserve">
          <source>A serious problem with the manual imposter table approach described above is that after adding the new &quot;t2&quot; entry to the &quot;sqlite_master&quot; table, the database file will technically be corrupt. Both the &quot;t1bc&quot; index and the &quot;t2&quot; table will point to the same b-tree. This will not cause any immediate problems, though one should avoid running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">上面描述的手动冒名顶替者表方法的一个严重问题是，在将新的&amp;ldquo; t2&amp;rdquo;条目添加到&amp;ldquo; sqlite_master&amp;rdquo;表中之后，数据库文件在技术上将被破坏。&amp;ldquo; t1bc&amp;rdquo;索引和&amp;ldquo; t2&amp;rdquo;表都将指向相同的b树。尽管不会避免运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;，但这不会引起任何直接问题。</target>
        </trans-unit>
        <trans-unit id="b3a86e163a24ba3d737d0e6d5f37de76bb1d3304" translate="yes" xml:space="preserve">
          <source>A serious problem with the manual imposter table approach described above is that after adding the new &quot;t2&quot; entry to the &quot;sqlite_schema&quot; table, the database file will technically be corrupt. Both the &quot;t1bc&quot; index and the &quot;t2&quot; table will point to the same b-tree. This will not cause any immediate problems, though one should avoid running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">上述手动冒名顶替者表方法的一个严重问题是，在将新的&amp;ldquo; t2&amp;rdquo;条目添加到&amp;ldquo; sqlite_schema&amp;rdquo;表中之后，数据库文件在技术上将被破坏。&amp;ldquo; t1bc&amp;rdquo;索引和&amp;ldquo; t2&amp;rdquo;表都将指向相同的b树。尽管不会避免运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;，但这不会引起任何直接的问题。</target>
        </trans-unit>
        <trans-unit id="45dc320cdb9816a2a39a9f3943b5295b82ce63f3" translate="yes" xml:space="preserve">
          <source>A session object (type sqlite3_session*) is created by making a call to the &lt;a href=&quot;session/sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; API function.</source>
          <target state="translated">通过调用&lt;a href=&quot;session/sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt; API函数来创建会话对象（sqlite3_session *类型）。</target>
        </trans-unit>
        <trans-unit id="2fc199170ebe2ff874f6db2f5e7dced1a879c2ec" translate="yes" xml:space="preserve">
          <source>A set of SQL constraints for each table. SQLite supports UNIQUE, NOT NULL, CHECK and FOREIGN KEY constraints.</source>
          <target state="translated">每个表的一组SQL约束。SQLite支持UNIQUE,NOT NULL,CHECK和 FOREIGN KEY约束。</target>
        </trans-unit>
        <trans-unit id="b9ec162401bfb188342d12868912e1becc54935f" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer</source>
          <target state="translated">一个有符号的64位整数</target>
        </trans-unit>
        <trans-unit id="a7e9fa36fa007a2f469e4a4760e755754b6f4660" translate="yes" xml:space="preserve">
          <source>A simple example of a shim is the &quot;vfstrace&quot; VFS. This is a VFS (implemented in the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c&quot;&gt;test_vfstrace.c&lt;/a&gt; source file) that writes a message associated with each VFS method call into a log file, then passes control off to another VFS to do the actual work.</source>
          <target state="translated">填充程序的一个简单示例是&amp;ldquo; vfstrace&amp;rdquo; VFS。这是一个VFS（在&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c&quot;&gt;test_vfstrace.c&lt;/a&gt;源文件中实现），它将与每个VFS方法调用关联的消息写入日志文件，然后将控制权转交给另一个VFS进行实际工作。</target>
        </trans-unit>
        <trans-unit id="14d97416bb95683c97f4458f8f05517fedf237b4" translate="yes" xml:space="preserve">
          <source>A simple example of a shim is the &quot;vfstrace&quot; VFS. This is a VFS (implemented in the &lt;a href=&quot;https://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c&quot;&gt;test_vfstrace.c&lt;/a&gt; source file) that writes a message associated with each VFS method call into a log file, then passes control off to another VFS to do the actual work.</source>
          <target state="translated">填充程序的一个简单示例是&amp;ldquo; vfstrace&amp;rdquo; VFS。这是一个VFS（在&lt;a href=&quot;https://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c&quot;&gt;test_vfstrace.c&lt;/a&gt;源文件中实现），它将与每个VFS方法调用关联的消息写入日志文件，然后将控制权转交给另一个VFS进行实际工作。</target>
        </trans-unit>
        <trans-unit id="7006cbe04f6d24543c2da75c91c78320fed7444e" translate="yes" xml:space="preserve">
          <source>A single CREATE VIRTUAL TABLE statement may contain any number of SQL parameters.</source>
          <target state="translated">一个CREATE VIRTUAL TABLE语句可以包含任意数量的SQL参数。</target>
        </trans-unit>
        <trans-unit id="62311c4f8d538cb3c9b6fb7e004b99ac7cc9aab4" translate="yes" xml:space="preserve">
          <source>A single WAL file can be reused multiple times. In other words, the WAL can fill up with frames and then be checkpointed and then new frames can overwrite the old ones. A WAL always grows from beginning toward the end. Checksums and counters attached to each frame are used to determine which frames within the WAL are valid and which are leftovers from prior checkpoints.</source>
          <target state="translated">一个WAL文件可以多次重复使用。换句话说,WAL可以充满帧,然后被检查点,然后新的帧可以覆盖旧的帧。一个WAL总是从头到尾的增长。附在每个帧上的校验和和计数器用于确定WAL中哪些帧是有效的,哪些是之前校验点的剩余帧。</target>
        </trans-unit>
        <trans-unit id="8785683b4ed7102093caaeccc3a5196c51a5907f" translate="yes" xml:space="preserve">
          <source>A single changeset may contain changes that apply to more than one database table. For each table that the changeset includes at least one change for, it also encodes the following data:</source>
          <target state="translated">一个变化集可以包含适用于一个以上数据库表的变化。对于变化集包含至少一个变化的每个表,它还对以下数据进行编码:</target>
        </trans-unit>
        <trans-unit id="608ce0bf9e63bfc85403ac0271b130acd58c64d6" translate="yes" xml:space="preserve">
          <source>A single database handle may have at most a single write-ahead log callback registered at one time. Calling &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; replaces any previously registered write-ahead log callback. Note that the &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; interface and the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; both invoke &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; and will overwrite any prior &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; settings.</source>
          <target state="translated">一个数据库句柄最多可以同时注册一个预写日志回调。调用&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）会&lt;/a&gt;替换任何先前注册的预写日志回调。请注意，&lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt;接口和&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint编译指示&lt;/a&gt;都将调用&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;并将覆盖以前的所有&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="89206c073889a1c1170a0ebb7406a8fb98a4806a" translate="yes" xml:space="preserve">
          <source>A single database handle may have at most a single write-ahead log callback registered at one time. Calling &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; replaces any previously registered write-ahead log callback. Note that the &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; interface and the &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; both invoke &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; and will overwrite any prior &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; settings.</source>
          <target state="translated">一个数据库句柄最多可以同时注册一个预写日志回调。调用&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）会&lt;/a&gt;替换任何先前注册的预写日志回调。请注意，&lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt;接口和&lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint编译指示&lt;/a&gt;都将调用&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;并将覆盖以前的所有&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="bae717677f5ddab7e1611867390ac460d23c6cd8" translate="yes" xml:space="preserve">
          <source>A single function declaration should contain no more than one of the following: &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;, &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;, or &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;.</source>
          <target state="translated">单个函数声明&lt;a href=&quot;compile#apicall&quot;&gt;最多只能&lt;/a&gt;包含以下一项：SQLITE_APICALL，&lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;，&lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;或&lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e26df4d33430b6b34c4d91859f0ec1b63873b0b8" translate="yes" xml:space="preserve">
          <source>A single phrase or NEAR group may be restricted to matching text within a specified column of the FTS table by prefixing it with the column name followed by a colon character. Or to a set of columns by prefixing it with a whitespace separated list of column names enclosed in parenthesis (&quot;curly brackets&quot;) followed by a colon character. Column names may be specified using either of the two forms described for strings above. Unlike strings that are part of phrases, column names are not passed to the tokenizer module. Column names are case-insensitive in the usual way for SQLite column names - upper/lower case equivalence is understood for ASCII-range characters only.</source>
          <target state="translated">单个短语或NEAR组可以通过在列名前加上冒号,限制在FTS表的指定列内匹配文本。或者通过在列名前加上括号(&quot;大括号&quot;)和冒号字符,将其限制在一组列中。列名可以使用上面为字符串描述的两种形式中的任何一种来指定。与作为短语一部分的字符串不同,列名不会被传递给标记程序模块。列名与SQLite列名一样,不区分大小写--大写/小写等价,只适用于ASCII范围的字符。</target>
        </trans-unit>
        <trans-unit id="957ff29feb802c055a16b8a1e4c52a503d6ee8db" translate="yes" xml:space="preserve">
          <source>A single session object monitors changes made to a single database (i.e. &quot;main&quot;, &quot;temp&quot; or an attached database) via a single sqlite3* database handle.</source>
          <target state="translated">单一会话对象通过单一的sqlite3*数据库句柄监控对单一数据库(即 &quot;main&quot;、&quot;temp &quot;或附加数据库)的更改。</target>
        </trans-unit>
        <trans-unit id="1707c93eb5e5ee6c5b850e9748ead9054742daf0" translate="yes" xml:space="preserve">
          <source>A small patch to version 3.6.16 to fix &lt;a href=&quot;http://www.sqlite.org/src/info/6b00e0a34c&quot;&gt;the OP_If bug&lt;/a&gt;.</source>
          <target state="translated">3.6.16版的一个小补丁，用于修复&lt;a href=&quot;http://www.sqlite.org/src/info/6b00e0a34c&quot;&gt;OP_If bug&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e54c54688a3e7d32c2002a2f3b6233642f77030" translate="yes" xml:space="preserve">
          <source>A small patch to version 3.6.16 to fix &lt;a href=&quot;https://www.sqlite.org/src/info/6b00e0a34c&quot;&gt;the OP_If bug&lt;/a&gt;.</source>
          <target state="translated">3.6.16版的一个小补丁，用于修复&lt;a href=&quot;https://www.sqlite.org/src/info/6b00e0a34c&quot;&gt;OP_If bug&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d37282f44ff8f219293b2945eedcfa47898899c4" translate="yes" xml:space="preserve">
          <source>A smaller and faster implementation of text to floating-point conversion subroutine: sqlite3AtoF().</source>
          <target state="translated">一个更小更快的文本到浮点转换子程序的实现:sqlite3AtoF()。</target>
        </trans-unit>
        <trans-unit id="9e409edf566363994702e2aef11edf00e8d07606" translate="yes" xml:space="preserve">
          <source>A special SQL function RAISE() may be used within a trigger-program, with the following syntax</source>
          <target state="translated">一个特殊的SQL函数RAISE()可以在触发器程序中使用,其语法如下。</target>
        </trans-unit>
        <trans-unit id="68a6631c65b5f7328388f2b5ccd5678cd79d4fa1" translate="yes" xml:space="preserve">
          <source>A stale master journal is a master journal that is no longer being used for anything. There is no requirement that stale master journals be deleted. The only reason for doing so is to free up disk space.</source>
          <target state="translated">过时的主日志是指不再用于任何目的的主日志。没有要求删除过时的主日志。这样做的唯一原因是为了释放磁盘空间。</target>
        </trans-unit>
        <trans-unit id="2d496d822cbfbcef6fd2f26cb43721e4d7db1958" translate="yes" xml:space="preserve">
          <source>A stale super-journal is a super-journal that is no longer being used for anything. There is no requirement that stale super-journals be deleted. The only reason for doing so is to free up disk space.</source>
          <target state="translated">过时的超级期刊是指不再用于任何用途的超级期刊。没有要求删除过期的超级期刊。这样做的唯一原因是为了腾出磁盘空间。</target>
        </trans-unit>
        <trans-unit id="f7ebc788dee352b396a0729f45e60a8dfd65ce42" translate="yes" xml:space="preserve">
          <source>A standard SQLite build includes a small amount of logic associated with &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; to exercise parts of the SQLite core that are otherwise difficult to validate. This compile-time option omits that extra testing logic. This compile-time option was called &quot;SQLITE_OMIT_BUILTIN_TEST&quot; prior to SQLite version 3.16.0 (2017-01-02). The name was changed to better describe the implications of using it.</source>
          <target state="translated">标准的SQLite构建包含少量与&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;相关的逻辑，以执行SQLite核心中难以验证的部分。此编译时选项省略了额外的测试逻辑。在SQLite版本3.16.0（2017-01-02）之前，此编译时选项称为&amp;ldquo; SQLITE_OMIT_BUILTIN_TEST&amp;rdquo;。名称被更改以更好地描述使用它的含义。</target>
        </trans-unit>
        <trans-unit id="61a7a7e55f6d9bd17dba85ad11c8944fbcdc4459" translate="yes" xml:space="preserve">
          <source>A starting frame boundary,</source>
          <target state="translated">一个起始框架边界。</target>
        </trans-unit>
        <trans-unit id="37fb198dfcb0d142d377ce0e169267e9a1cdfccb" translate="yes" xml:space="preserve">
          <source>A statement journal file is used to rollback partial results of a single statement within a larger transaction. For example, suppose an UPDATE statement will attempt to modify 100 rows in the database. But after modifying the first 50 rows, the UPDATE hits a constraint violation which should block the entire statement. The statement journal is used to undo the first 50 row changes so that the database is restored to the state it was in at the start of the statement.</source>
          <target state="translated">语句日志文件用于回滚较大事务中的单个语句的部分结果。例如,假设一条UPDATE语句将尝试修改数据库中的100条记录。但是在修改了前50条记录之后,UPDATE语句遇到了一个约束违反,应该阻止整个语句。语句日志用来撤销前50行的修改,这样数据库就会恢复到语句开始时的状态。</target>
        </trans-unit>
        <trans-unit id="940c3a5de694a1d82ab455c32b9b6bed30de5212" translate="yes" xml:space="preserve">
          <source>A statement journal is only created for an UPDATE or INSERT statement that might change multiple rows of a database and which might hit a constraint or a RAISE exception within a trigger and thus need to undo partial results. If the UPDATE or INSERT is not contained within BEGIN...COMMIT and if there are no other active statements on the same database connection then no statement journal is created since the ordinary rollback journal can be used instead. The statement journal is also omitted if an alternative &lt;a href=&quot;lang_conflict&quot;&gt;conflict resolution algorithm&lt;/a&gt; is used. For example:</source>
          <target state="translated">仅为UPDATE或INSERT语句创建语句日志，该语句可能会更改数据库的多行，并且可能会在触发器内遇到约束或RAISE异常，因此需要撤消部分结果。如果UPDATE或INSERT不包含在BEGIN ... COMMIT中，并且同一数据库连接上没有其他活动语句，则不会创建任何语句日志，因为可以使用普通的回滚日志来代替。如果使用其他&lt;a href=&quot;lang_conflict&quot;&gt;冲突解决算法，&lt;/a&gt;则也将省略语句日志。例如：</target>
        </trans-unit>
        <trans-unit id="1d0a69ee154fd724c3f7e2b66c07110e679818fe" translate="yes" xml:space="preserve">
          <source>A statement such as the above can be run immediately prior to invoking &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; to confirm that all prepared statements have been &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; and to help identify and track down prepared statements that have &quot;leaked&quot; and missed finalization.</source>
          <target state="translated">可以在调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;之前立即运行诸如上述的语句，以确认所有准备好的语句已经&lt;a href=&quot;c3ref/finalize&quot;&gt;完成，&lt;/a&gt;并有助于识别和跟踪&amp;ldquo;泄漏&amp;rdquo;和错过了最终效果的准备好的语句。</target>
        </trans-unit>
        <trans-unit id="93e2d7eae4ab34999aac0e06cf630caa26eca256" translate="yes" xml:space="preserve">
          <source>A storage class is more general than a datatype. The INTEGER storage class, for example, includes 6 different integer datatypes of different lengths. This makes a difference on disk. But as soon as INTEGER values are read off of disk and into memory for processing, they are converted to the most general datatype (8-byte signed integer). And so for the most part, &quot;storage class&quot; is indistinguishable from &quot;datatype&quot; and the two terms can be used interchangeably.</source>
          <target state="translated">一个存储类比一个数据类型更通用。例如,INTEGER存储类包括6种不同长度的整数数据类型。这在磁盘上是有区别的。但是,当INTEGER值从磁盘上读出并进入内存进行处理时,它们就会被转换为最通用的数据类型(8字节有符号的整数)。所以在大多数情况下,&quot;存储类 &quot;和 &quot;数据类型 &quot;是没有区别的,这两个术语可以互换使用。</target>
        </trans-unit>
        <trans-unit id="7675d21b606912c9ad81d09f8bd030b6fb973bc2" translate="yes" xml:space="preserve">
          <source>A straightforward implementation of a spelling corrector would be to compare the search term against every word in the vocabulary and select the 20 with the lowest scores. However, there will typically be hundreds of thousands or millions of words in the vocabulary, and so this approach is not fast enough.</source>
          <target state="translated">拼写校正器的直接实现方式是将搜索词与词汇中的每一个词进行比较,然后选择得分最低的20个。然而,词汇中通常会有几十万或几百万个单词,因此这种方法不够快。</target>
        </trans-unit>
        <trans-unit id="eaf0250c67cab7be0dc1ee87f425a759227d1fab" translate="yes" xml:space="preserve">
          <source>A string constant is formed by enclosing the string in single quotes ('). A single quote within the string can be encoded by putting two single quotes in a row - as in Pascal. C-style escapes using the backslash character are not supported because they are not standard SQL.</source>
          <target state="translated">字符串常量是通过用单引号(')包围字符串而形成的。字符串中的单引号可以通过在一行中加入两个单引号来编码--就像在Pascal中一样。不支持使用反斜杠字符的C式转义,因为它们不是标准SQL。</target>
        </trans-unit>
        <trans-unit id="833d0cdbb5e0f11e62e7535fa2b560860c4b3b41" translate="yes" xml:space="preserve">
          <source>A string might look like a floating-point literal with a decimal point and/or exponent notation but as long as the value can be expressed as an integer, the NUMERIC affinity will convert it into an integer. Hence, the string '3.0e+5' is stored in a column with NUMERIC affinity as the integer 300000, not as the floating point value 300000.0.</source>
          <target state="translated">字符串可能看起来像一个带有小数点和/或指数符号的浮点文字,但只要该值可以用整数表示,NUMERIC亲和力就会将其转换为整数。因此,字符串 &quot;3.0e+5 &quot;在NUMERIC亲和力列中被存储为整数300000,而不是浮点值300000.0。</target>
        </trans-unit>
        <trans-unit id="8190afbd8c6bbd11bbd6c14f28a0172cbb480b3c" translate="yes" xml:space="preserve">
          <source>A subquery expression with two or more result columns.</source>
          <target state="translated">一个有两个或多个结果列的子查询表达式。</target>
        </trans-unit>
        <trans-unit id="5635ec05c69c3ce96a3233f42069b4904d399309" translate="yes" xml:space="preserve">
          <source>A subquery on the right-hand side of IN operator must often be materialized. For example:</source>
          <target state="translated">IN运算符右侧的子查询必须经常具体化。例如:</target>
        </trans-unit>
        <trans-unit id="7c0661a4bdbca6636faba7e3ce330659e6cc7c97" translate="yes" xml:space="preserve">
          <source>A subquery that returns a single column is a scalar subquery and can be used most anywhere. A subquery that returns two or more columns is a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; subquery and can only be used as the operand of a comparison operator.</source>
          <target state="translated">返回单列的子查询是标量子查询，可以在大多数地方使用。返回两列或更多列的子查询是&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;子查询，并且只能用作比较运算符的操作数。</target>
        </trans-unit>
        <trans-unit id="513c8fcc36f3dbb3fe1ba2919acd7ef31b0580f6" translate="yes" xml:space="preserve">
          <source>A successful invocation of this method will cause *pRowid to be filled with the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of row that the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; pCur is currently pointing at. This method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. It returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">成功调用此方法将导致* pRowid填充&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;虚拟表光标&lt;/a&gt; pCur当前指向的行的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。成功时此方法返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。失败时将返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e843c0218f6351825674391272a0db4bb8db636e" translate="yes" xml:space="preserve">
          <source>A super-journal is stale if no individual file journals are pointing to it. To figure out if a super-journal is stale, we first read the super-journal to obtain the names of all of its file journals. Then we check each of those file journals. If any of the file journals named in the super-journal exists and points back to the super-journal, then the super-journal is not stale. If all file journals are either missing or refer to other super-journals or no super-journal at all, then the super-journal we are testing is stale and can be safely deleted.</source>
          <target state="translated">如果一个超级期刊没有任何单独的文件期刊指向它,那么这个超级期刊就是陈旧的。为了确定超级期刊是否失效,我们首先读取超级期刊,以获得其所有文件期刊的名称。然后,我们对这些文件期刊逐一进行检查。如果超级期刊中的任何一个文件期刊存在,并且指向超级期刊,那么这个超级期刊就不是陈旧的。如果所有的文件期刊都没有,或者指向其他超级期刊,或者根本就没有超级期刊,那么我们测试的超级期刊就已经过时了,可以安全地删除。</target>
        </trans-unit>
        <trans-unit id="a876cbac258b205fceef1496fbc66fdbd28a83e7" translate="yes" xml:space="preserve">
          <source>A swarmvtab table has the same schema as each of its component tables.</source>
          <target state="translated">一个swarmvtab表与它的每个组件表具有相同的模式。</target>
        </trans-unit>
        <trans-unit id="24f9af565c085a8964740fe3fa13a54013369f70" translate="yes" xml:space="preserve">
          <source>A swarmvtab virtual table is created as follows:</source>
          <target state="translated">swarmvtab虚拟表的创建方法如下。</target>
        </trans-unit>
        <trans-unit id="c3b6e57942158b2ce08f2d6299decb29e664e48f" translate="yes" xml:space="preserve">
          <source>A table b-tree interior page</source>
          <target state="translated">A表b树内页</target>
        </trans-unit>
        <trans-unit id="bcb5ce26b9e5292874c4f103c523b7155ab1d3d5" translate="yes" xml:space="preserve">
          <source>A table b-tree leaf page</source>
          <target state="translated">A表b树叶页</target>
        </trans-unit>
        <trans-unit id="1e18698afc8eb8fd55a13d0d4739a4898ecead4e" translate="yes" xml:space="preserve">
          <source>A table created using CREATE TABLE AS has no PRIMARY KEY and no constraints of any kind. The default value of each column is NULL. The default collation sequence for each column of the new table is BINARY.</source>
          <target state="translated">使用CREATE TABLE AS创建的表没有PRIMARY KEY,也没有任何形式的约束。各列的默认值为NULL。新表的每一列的默认整理序列是BINARY。</target>
        </trans-unit>
        <trans-unit id="2722d24833adf5b38fd57107e3991ba2e3c139c1" translate="yes" xml:space="preserve">
          <source>A table of insertion, deletion, and substitution costs can be provided by the application.</source>
          <target state="translated">应用程序可以提供插入、删除和替换成本表。</target>
        </trans-unit>
        <trans-unit id="0d688ea9d1619e762c6e53a152855aec30c051d2" translate="yes" xml:space="preserve">
          <source>A table with the name &quot;sqlite_sequence&quot; that is used to keep track of the maximum historical &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for a table using &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;.</source>
          <target state="translated">名称为&amp;ldquo; sqlite_sequence&amp;rdquo; 的表，用于使用&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;跟踪表的最大历史&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
