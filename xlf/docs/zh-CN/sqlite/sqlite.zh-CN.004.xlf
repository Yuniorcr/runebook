<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="bf2789a3dfac2aec0ce73567ef591f88c395a4a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SESSION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SESSION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8abf674d55e555f734817a21ddcd5e21c3015707" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SNAPSHOT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SNAPSHOT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fbcbad5bbf055acd0b8cb0f65883a99e15403389" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="050fd9347aba0613e41edd6d9163428b913cee4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SQLLOG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SQLLOG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0204d4bbf2c54d3a1ed06e32f0d2fbfba810aaf2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc060831fa345f0a6eab149e614a038d39d92be3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT3&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT3&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aadb411eed6a3e5c2d4eea8759254437ad95f39e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="faf2c9cc0d944bfbdb7cc148d522d3051abfdcf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STMTVTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STMTVTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95df966b12c5979c6c37cfbb73acce4de4031b52" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8c43e0af9e63a24260b1237ffafa9382ffcb8eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="10ad0ef0211ad8e21498cf3f4662f8bcc6ba15cf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd992a7384df4b2049382d0b4180b642a115bd15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e01ddc96bb53d6b852d1690bde30ccdb2f85dafe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cedadab65ac150d458ca8e13ba1611fb33b07ce8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_EXTRA_DURABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_EXTRA_DURABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="253b5d9f8f32fa07fef6dbd123f4ce91b701c1d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_FTS3_MAX_EXPR_DEPTH=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_FTS3_MAX_EXPR_DEPTH=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6a286554137726a245c1b95b8192b6c3bbd3251" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_HAVE_ISNAN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_HAVE_ISNAN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9db0cb11222acab74db65c807eff63f7f55c2ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_HAVE_ZLIB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_HAVE_ZLIB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05591c0534904e32ca8cdac4b25cbb9d60a573b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_INTROSPECTION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_INTROSPECTION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9c352c0861967ddc2df753cc4bbcd4bcba3f2f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5ceb830bc9fd789f4fa5f7fcc0cabfaf48496306" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LOCK_EXCLUSIVE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LOCK_EXCLUSIVE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b03ae772584c2d2a9e11d0dc7338890a0357eb9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LOCK_SHARED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LOCK_SHARED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c99e4b045bc420fa97a94b4105d7f761fb24049c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_MEMORY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_MEMORY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9c354011c14318ca6d262f2573fba28199396470" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a401e4995f5551e362e32c54e2ba19071ea64e48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_SCHEMA_RETRY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_SCHEMA_RETRY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="acb2a8063accd6b8beb78cacc0a648a21d40a870" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b462c3d40d420240b9032bbae35bd514d016567b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99a1ffd86d48620ac9d92bbfacc8dd600f0161cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MEMDEBUG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MEMDEBUG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a4e92305244c1ce6fd0f4cd7269789b8529f373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3334e6a6da5c866bd89fe950d2c9b62e97f7ceb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ALTERTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ALTERTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d9ecdc843e92293dcb6abf6daf54b6c3b4881468" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ANALYZE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ANALYZE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bfe038e385667f427bfaba3d91a9af26eba94450" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ATTACH&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ATTACH&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d6d0848efb00b356cb9465d9f109e2147210b9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTHORIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTHORIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7fdef8c2a9c01031f943ed79f514a8156d673500" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOINCREMENT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOINCREMENT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2d8960215ae00abd7ebb1925d984e4b874f7c871" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOINIT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOINIT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aaf355948028ec514c8e85609b52d8ff903f1574" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3a1d498df4dd274ff01a03900ec4b34dda79009c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTORESET&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTORESET&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c6a54eaef40777e126f4002faabd672a7e9f7e91" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOVACUUM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOVACUUM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc2f291f887ee161ef88691303623ca2effb8629" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BETWEEN_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BETWEEN_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31a30cf46373dc5197f8e3344abb93ca02b039ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BLOB_LITERAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BLOB_LITERAL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7e8d3c023e1a4ccad20b87139d88b7081b6817b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BTREECOUNT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BTREECOUNT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cff423655eb39b2c748dff51e94300e8f28ba4e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b62e20033dec22257f890ac30be31c4cd927192f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a4c5907c936567c2b7b9fa6bc346c059d43fc957" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CAST&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CAST&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5633de952d476b5d96fee010583ad94474595fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CHECK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CHECK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6fc3ef0b372de46a78bc829d1b0ac42417cbe60e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d42dd6fec81e49f75f5ff85d610101a339b93346" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPLETE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPLETE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="52d61fa2500d572bc3c2f61bc09133f36d87d7a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPOUND_SELECT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPOUND_SELECT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffebea17346fc66899b100e42dde64847ae162ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CTE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CTE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="02a8ebfb8c51bfa8f5f04b211a7d7ff033ad0d12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="00568160f62e1e2f3c85a4ec68228a6d706532ce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DECLTYPE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DECLTYPE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d35796e3c6ab5d85720734a37998a6ce92535777" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DEPRECATED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DEPRECATED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="03eb1718823b671bd128fc3257e8b9065c569dd7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DISKIO&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DISKIO&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b059b5b58e6147c9da00dc4a5c50c89efee3912a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_EXPLAIN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_EXPLAIN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="389e2542bf1d776bda49aa816f7acb08834bd6cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FLAG_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FLAG_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="707057fed5f688f9208bf46ef4426a605d5f09df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FLOATING_POINT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FLOATING_POINT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bc82fd2191660ac807469076e0f7a404c356a0be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdf469011a3b01a769905c13c811e2aa6924e16e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_GENERATED_COLUMNS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_GENERATED_COLUMNS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0905065083397f185f42d644502785ba7c6069f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_GET_TABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_GET_TABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0da634636aa21dd63f86722f0b3d34ffade49316" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_HEX_INTEGER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_HEX_INTEGER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e27ca5135fcc6a84108dc0ffc11de226b7192e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INCRBLOB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INCRBLOB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e2d75578c65599befa260ca475b0a32c3620f002" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INTEGRITY_CHECK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INTEGRITY_CHECK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14ef2bd88a85199b30182a69235817a3b5204f1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="77f3d1be3901c085b4a5db58cfdd2f9aaa6ceeca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LIKE_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LIKE_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="136a7594d2f3c6161370dbd3a5755699a0f58d29" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a3dc23714e6733b26ba59900b7bd7b338d8e9f8e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOCALTIME&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOCALTIME&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5afb0b5eb77dd513826c4b386ca2f26d1f287909" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOOKASIDE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOOKASIDE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6bf04e411ffa329ca1466479098e23ff67d50730" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_MEMORYDB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_MEMORYDB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c059cfc62627b1886e1ca9f2629fb0b673e1d368" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_OR_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_OR_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ed3f9bfbb996093381267996d7d33c4f934eb7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PAGER_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PAGER_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d0281a47c9f5f4c349fb5ba928eb8bf37efa960" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PRAGMA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="be2660af6ab813539e2a8692aa5c050fd19d360c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="668be95a6a3f50c7a5a63db473a408745e328f6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_QUICKBALANCE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_QUICKBALANCE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f4eaaca938ecabc5c4dc11eaf9e065917dc70e26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_REINDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_REINDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="78dab73ee3da96b8c7ec1553d7f97a1d26d45cc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SCHEMA_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SCHEMA_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e59c47d4c6184784743e4358c78e436ed302c8d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f0e56325b2afaf6793e05912f440ee78e1e06f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SHARED_CACHE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SHARED_CACHE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6b5feca8b64e60e028e2dbdb4dce97b1428f8b10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SUBQUERY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SUBQUERY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="273973ea2fa452aa7255dd76283f67114dc7bc9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TCL_VARIABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TCL_VARIABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b844869cbb137b3f5aae65d9fc2124a7f75df280" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TEMPDB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TEMPDB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14def5836843dc064ff211faf4a1e5d1c19a5fc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8c7a3f7709d5ca48aa62de5b3a866714d6593cfb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRIGGER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRIGGER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bff9bf2bc1a52aebb220f94954f92e1545ac1446" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="abef01fc3e06b07aafa25fb3d9e477bfd22cef7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_UTF16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_UTF16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6336b6b7d8d57c2d7a777490e28348a06393d36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VACUUM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VACUUM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="059e2862fefd88c744b1377dc92f308d73cc50bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VIEW&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VIEW&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebb08208b1feeb2e4092b776ed5ddb8063c890ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6542f591162b1fac32afa54f47fc6731f33601c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_WAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_WAL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="04514e40f182ad456b5245a466634fbd7e92daf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_WSD&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_WSD&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3932897bd040e95c1eb9739b7659d68beda3ea49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_XFER_OPT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_XFER_OPT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2fad4f7fe54b95701a39ee8feb95777319a60e90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OS_OTHER=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OS_OTHER = &lt;i&gt;&amp;lt;0或1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56ee3d0e684b44b8675f52b13d0096d23504a7af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_POWERSAFE_OVERWRITE=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_POWERSAFE_OVERWRITE = &lt;i&gt;&amp;lt;0或1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="80c6ed8dbd133860dd6d357b4dc8c60c2b09f69b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_PRINTF_PRECISION_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_PRINTF_PRECISION_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6463226645ffe362c178bbe7f828d660c275a442" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6885cb8516f8377a9c28e855cb70b63504e6e435" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3a0235475a7827d68e0c1bb73ea4b44f4d323a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cec139681f0df7f780a39dbfc2f329845e7c650b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_RTREE_INT_ONLY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_RTREE_INT_ONLY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d94d24b874c2c537a6ea7780b2a6592350047905" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SECURE_DELETE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SECURE_DELETE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7713ed7ab2f2f1c55f8fdb3ab145f3b1b932345b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SORTER_PMASZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SORTER_PMASZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc3bed687fc846b37c550cd3cddfd9155cb90685" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SOUNDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SOUNDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d310d3f3bd739c56f040cc79192496e87ececfd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_STMTJRNL_SPILL=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_STMTJRNL_SPILL=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b8a23171b43aabf136109acb20d220b99d3e9da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SYSCALL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SYSCALL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0aba06a9fc72c1f03ecfc53abd7d244a52e61ce7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TCLAPI&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TCLAPI&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="857f1d4b039067e7938f0fbe3cd9dacc12a3cc3d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TEMP_STORE=&lt;i&gt;&amp;lt;0 through 3&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TEMP_STORE = &lt;i&gt;&amp;lt;0至3&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="763974a69da7c357391024b037f2ff65866c1c72" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_THREADSAFE=&lt;i&gt;&amp;lt;0 or 1 or 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_THREADSAFE = &lt;i&gt;&amp;lt;0或1或2&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db798c4c2b06b4515c31c3444478572466898eb9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TRACE_SIZE_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TRACE_SIZE_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a864ab43b658af57ffcc85d7075d94f4c0eb4a1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TRUSTED_SCHEMA=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ec24333763838d2b35e7775950f2196c7691af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_UNTESTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_UNTESTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08dfc4ddda00225d961592ced42dcb85aa2a6b68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_ALLOCA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_ALLOCA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b2c678e1824f51e764911d1d97afa9303106537c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_FCNTL_TRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_FCNTL_TRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f442370983bde912aeaa8688fb8696ae2e052aae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_URI&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_URI&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aa939f2dbd402ef231f0ab3788a92497d3d84650" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_HEAP_CREATE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_HEAP_CREATE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1343ce5771a0eb9359ec0df9e37c4cc2874c8ebd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="382b47f1f3b8cd49c3216efbc6c7a391dd57252d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="55cb4273e62d90804c53d091b40902649ec6153d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ZERO_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ZERO_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de509a166760f395e8d9ff623bc5c20f291203f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be disabled using the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法而不是此接口来禁用扩展加载，因此，&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数保持禁用状态。这将防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="77d070aba76c9c45f3f4dfb8cb2c0f7b57ceed06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be disabled using the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法而不是此接口来禁用扩展加载，因此，&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数保持禁用状态。这将防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="d719a3c99ca55bb1bc6c2bd4c61f4ad80e27b087" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be enabled using the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed85e3d24d294923ff9a94eb30c8ccf98e23751" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be enabled using the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39a9a8ee0c9f06fa3f477352418d833d84efb0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method be used to enable only this interface. The use of the &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface should be avoided. This will keep the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; disabled and prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法仅启用此接口。应该避免使用&lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;接口。这将使SQL函数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;保持禁用状态，并防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="85bcf242d91006a6e47ad703972cc780357bae6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method be used to enable only this interface. The use of the &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface should be avoided. This will keep the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; disabled and prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;安全警告：&lt;/b&gt;建议使用&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;方法仅启用此接口。应该避免使用&lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;接口。这将使SQL函数&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;保持禁用状态，并防止SQL注入使攻击者能够访问扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="cef37acd0e58d7484bc210c3874856e993d57c42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Self-documentation.&lt;/b&gt; Self-documenting digital objects contain basic descriptive, technical, and other administrative metadata.</source>
          <target state="translated">&lt;b&gt;自我证明。&lt;/b&gt;自记录数字对象包含基本的描述性，技术性和其他管理性元数据。</target>
        </trans-unit>
        <trans-unit id="67039928069e29c2b8fc9b97ed6661597211b7d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Serialized&lt;/b&gt;. In serialized mode, SQLite can be safely used by multiple threads with no restriction.</source>
          <target state="translated">&lt;b&gt;序列化&lt;/b&gt;。在序列化模式下，SQLite可以不受限制地被多个线程安全使用。</target>
        </trans-unit>
        <trans-unit id="e6c18085190b76c91a8135185e5040fe095bb489" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Server-side database&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;服务器端数据库&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a71e55c9e2165337c5f26b98320364c9a71fa32b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Serverless&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Serverless&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d28078da99c520e2ece9e2e044a1e465058479f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Side note: Bare columns in an aggregate queries.&lt;/b&gt; The usual case is that all column names in an aggregate query are either arguments to &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; or else appear in the GROUP BY clause. A result column which contains a column name that is not within an aggregate function and that does not appear in the GROUP BY clause (if one exists) is called a &quot;bare&quot; column. Example:</source>
          <target state="translated">&lt;b&gt;旁注：聚合查询中的裸列。&lt;/b&gt;通常的情况是，聚合查询中的所有列名称要么是&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合函数的&lt;/a&gt;参数，要么出现在GROUP BY子句中。结果列包含不在聚合函数中且未出现在GROUP BY子句中（如果存在的话）的列名，称为&amp;ldquo;裸&amp;rdquo;列。例：</target>
        </trans-unit>
        <trans-unit id="9a2bd3e845310e3146f075b7477b9a77fd861938" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Side note: Special handling of CROSS JOIN.&lt;/b&gt; There is no difference between the &quot;INNER JOIN&quot;, &quot;JOIN&quot; and &quot;,&quot; join operators. They are completely interchangeable in SQLite. The &quot;CROSS JOIN&quot; join operator produces the same result as the &quot;INNER JOIN&quot;, &quot;JOIN&quot; and &quot;,&quot; operators, but is &lt;a href=&quot;optoverview#crossjoin&quot;&gt;handled differently by the query optimizer&lt;/a&gt; in that it prevents the query optimizer from reordering the tables in the join. An application programmer can use the CROSS JOIN operator to directly influence the algorithm that is chosen to implement the SELECT statement. Avoid using CROSS JOIN except in specific situations where manual control of the query optimizer is desired. Avoid using CROSS JOIN early in the development of an application as doing so is a &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;premature optimization&lt;/a&gt;. The special handling of CROSS JOIN is an SQLite-specific feature and is not a part of standard SQL.</source>
          <target state="translated">&lt;b&gt;旁注：对CROSS JOIN的特殊处理。&lt;/b&gt; &amp;ldquo; INNER JOIN&amp;rdquo;，&amp;ldquo; JOIN&amp;rdquo;和&amp;ldquo;，&amp;rdquo;联接运算符之间没有区别。它们在SQLite中是完全可互换的。 &amp;ldquo; CROSS JOIN&amp;rdquo;联接运算符产生的结果与&amp;ldquo; INNER JOIN&amp;rdquo;，&amp;ldquo; JOIN&amp;rdquo;和&amp;ldquo;，&amp;rdquo;运算符相同，但是&lt;a href=&quot;optoverview#crossjoin&quot;&gt;查询优化器的处理方式不同&lt;/a&gt;，因为它阻止了查询优化器对联接中的表进行重新排序。应用程序程序员可以使用CROSS JOIN运算符直接影响为实现SELECT语句而选择的算法。避免使用CROSS JOIN，除非在特定情况下需要手动控制查询优化器。避免在应用程序开发的早期使用CROSS JOIN，因为这样做&lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;过早了&lt;/a&gt;。CROSS JOIN的特殊处理是SQLite特有的功能，不是标准SQL的一部分。</target>
        </trans-unit>
        <trans-unit id="ded659eb85771f35ee1281ea75f0b58206ff5892" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Simplified Application Development.&lt;/b&gt; No new code is needed for reading or writing the application file. One has merely to link against the SQLite library, or include the &lt;a href=&quot;amalgamation&quot;&gt;single &quot;sqlite3.c&quot; source file&lt;/a&gt; with the rest of the application C code, and SQLite will take care of all of the application file I/O. This can reduce application code size by many thousands of lines, with corresponding saving in development and maintenance costs.</source>
          <target state="translated">&lt;b&gt;简化的应用程序开发。&lt;/b&gt;读取或写入应用程序文件不需要任何新代码。只需链接到SQLite库，或将&lt;a href=&quot;amalgamation&quot;&gt;单个&amp;ldquo; sqlite3.c&amp;rdquo;源文件&lt;/a&gt;包含在其余应用程序C代码中，SQLite将负责所有应用程序文件I / O。这样可以减少数千行的应用程序代码大小，并相应节省开发和维护成本。</target>
        </trans-unit>
        <trans-unit id="1f1a07cced5f47f7259b19ba37568ce82cb769c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;单个数据库文件&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3366f819b02e356be2c09f8db154e11cec6006c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single-File Documents.&lt;/b&gt; An SQLite database is contained in a single file, which is easily copied or moved or attached. The &quot;document&quot; metaphor is preserved.</source>
          <target state="translated">&lt;b&gt;单文件文档。&lt;/b&gt;SQLite数据库包含在一个文件中，可以轻松地对其进行复制，移动或附加。&amp;ldquo;文档&amp;rdquo;隐喻被保留。</target>
        </trans-unit>
        <trans-unit id="68d21fce42cee774794d3e89752dc4c799a36e13" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single-thread&lt;/b&gt;. In this mode, all mutexes are disabled and SQLite is unsafe to use in more than a single thread at once.</source>
          <target state="translated">&lt;b&gt;单线程&lt;/b&gt;。在这种模式下，所有互斥锁都被禁用，SQLite不安全，不能一次在多个线程中使用。</target>
        </trans-unit>
        <trans-unit id="b814fcbadf45ac4a5e2cf73ad790b7ea7575388b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stable Cross-Platform Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;稳定的跨平台数据库文件&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4b6d0729d61e68af9be12dd919ff6d4508e9058a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stand-in For An Enterprise RDBMS.&lt;/b&gt; SQLite is often used as a surrogate for an enterprise RDBMS for demonstration purposes or for testing. SQLite is fast and requires no setup, which takes a lot of the hassle out of testing and which makes demos perky and easy to launch.</source>
          <target state="translated">&lt;b&gt;企业RDBMS的替身。&lt;/b&gt;SQLite通常用作企业RDBMS的替代品，以进行演示或测试。SQLite速度很快，不需要任何设置，这消除了测试中的许多麻烦，并使演示活泼且易于启动。</target>
        </trans-unit>
        <trans-unit id="49211ca87490fc949777a3fa6df7da5023e3e641" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stand-in for an enterprise database during demos or testing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;在演示或测试期间替代企业数据库&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e613e33621af0e53400119bdd08e80a1c293ae5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Startup is slow.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;启动缓慢。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6f8a8cb97bdf26af3f7bcb45031e40198e438d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Summary:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Summary:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b838b6a7626f1106767937cfe090ef328a06b3c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;T&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;T&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cc92e1072d6f0803cf0720093c61b6114a74aff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TEXT&lt;/b&gt; as ISO8601 strings (&quot;YYYY-MM-DD HH:MM:SS.SSS&quot;).</source>
          <target state="translated">&lt;b&gt;文本&lt;/b&gt;为ISO8601字符串（&amp;ldquo; YYYY-MM-DD HH：MM：SS.SSS&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="51b499bb47a4b816c200573bc1654699b3396326" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TEXT&lt;/b&gt;. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).</source>
          <target state="translated">&lt;b&gt;文字&lt;/b&gt;。该值是一个文本字符串，使用数据库编码（UTF-8，UTF-16BE或UTF-16LE）存储。</target>
        </trans-unit>
        <trans-unit id="1175f4dc14e4a992c9182cfb85c0229a4412adea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Table name&lt;/b&gt;. The name of the component table within its database.</source>
          <target state="translated">&lt;b&gt;表名&lt;/b&gt;。数据库中组件表的名称。</target>
        </trans-unit>
        <trans-unit id="cce6f2ddbb90e75814b5925f282a337f2a6222d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Technical Protection Mechanisms.&lt;/b&gt; Implementation of mechanisms such as encryption that prevent the preservation of content by a trusted repository.</source>
          <target state="translated">&lt;b&gt;技术保护机制。&lt;/b&gt;诸如加密之类的机制的实现，这些机制阻止了受信任存储库保留内容。</target>
        </trans-unit>
        <trans-unit id="8b8491e1f95ab90350e3e533b25fcfd87b3e25b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Test, Debug, and Analysis Changes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;测试，调试和分析更改：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e053a51d81e6a2c72b1bc41555611b2f50e7a8c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &quot;DROP TABLE&quot; Exception&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;ldquo; DROP TABLE&amp;rdquo;异常&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7ee9ee9b8b34c217caeb5704b148f23d252d528" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental blob I/O&lt;/a&gt; mechanism does not work for WITHOUT ROWID tables.&lt;/b&gt; Incremental BLOB I/O uses the rowid to create an &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object for doing the direct I/O. However, WITHOUT ROWID tables do not have a rowid, and so there is no way to create an &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object for a WITHOUT ROWID table.</source>
          <target state="translated">&lt;b&gt;该&lt;a href=&quot;c3ref/blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;机制不为工作而ROWID表。&lt;/b&gt;增量BLOB I / O使用rowid创建一个&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;对象，以执行直接I / O。但是，WITHOUT ROWID表没有行号，因此无法为WITHOUT ROWID表创建&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="e9333e7627a2d8956128f8661c8ce6d0c01b3a38" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function does not work for WITHOUT ROWID tables.&lt;/b&gt; Inserts into a WITHOUT ROWID do not change the value returned by the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function. The &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; SQL function is also unaffected since it is just a wrapper around &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;该&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数不会对没有ROWID表工作。&lt;/b&gt;插入WITHOUT ROWID不会更改&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数返回的值。该&lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）&lt;/a&gt; SQL功能也丝毫不受影响，因为它仅仅是围绕着包装&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d83b61d9f4987dc0f941ad211863bc9aa49f3be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; interface does not fire callbacks for changes to a WITHOUT ROWID table.&lt;/b&gt; Part of the callback from &lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; is the rowid of the table row that has changed. However, WITHOUT ROWID tables do not have a rowid. Hence, the update hook is not invoked when a WITHOUT ROWID table changes.</source>
          <target state="translated">&lt;b&gt;该&lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook（）&lt;/a&gt;接口不火对于没有ROWID表变为回调。&lt;/b&gt;来自&lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook（）&lt;/a&gt;的回调的一部分是已更改的表行的rowid。但是，WITHOUT ROWID表没有行号。因此，当WITHOUT ROWID表更改时，不会调用更新挂钩。</target>
        </trans-unit>
        <trans-unit id="0d6305d6204c7fa058d43a6412f44de76568442f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The pthreads API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;pthreads API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2445d1d7779f00615aec27dcadb26e02eae2a0fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The special behaviors associated &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; do not apply on WITHOUT ROWID tables.&lt;/b&gt; In an ordinary table, &quot;INTEGER PRIMARY KEY&quot; means that the column is an alias for the rowid. But since there is no rowid in a WITHOUT ROWID table, that special meaning no longer applies. An &quot;INTEGER PRIMARY KEY&quot; column in a WITHOUT ROWID table works like an &quot;INT PRIMARY KEY&quot; column in an ordinary table: It is a PRIMARY KEY that has integer &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;与&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &amp;rdquo; 关联的特殊行为不适用于WITHOUT ROWID表。&lt;/b&gt;在普通表中，&amp;ldquo; INTEGER PRIMARY KEY&amp;rdquo;表示该列是rowid的别名。但是，由于WITHOUT ROWID表中没有rowid，因此该特殊含义不再适用。WITHOUT ROWID表中的&amp;ldquo; INTEGER PRIMARY KEY&amp;rdquo;列的作用类似于普通表中的&amp;ldquo; INT PRIMARY KEY&amp;rdquo;列：它是具有整数&lt;a href=&quot;datatype3#affinity&quot;&gt;亲和力&lt;/a&gt;的PRIMARY KEY 。</target>
        </trans-unit>
        <trans-unit id="dca5135672aa5896d1934aec89434fccdee88668" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The sqlite3_config() interface is not threadsafe. The application must ensure that no other SQLite interfaces are invoked by other threads while sqlite3_config() is running.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_config（）接口不是线程安全的。应用程序必须确保在运行sqlite3_config（）时，其他线程不会调用其他SQLite接口。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c710e5ea2792e8eded22905b82d87b3dcd213e68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The sqlite3_unlock_notify() API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_unlock_notify（）API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4617744409076bb539fa2b6bcbc61a76f81045ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This pragma is deprecated&lt;/b&gt; and exists for backwards compatibility only. New applications should avoid using this pragma. Older applications should discontinue use of this pragma at the earliest opportunity. This pragma may be omitted from the build when SQLite is compiled using &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;不建议使用此编译指示，&lt;/b&gt;并且仅为了向后兼容而存在。新的应用程序应避免使用此编译指示。较旧的应用程序应尽早停止使用该实用程序。使用&lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;编译SQLite时，可以从构建中省略此编译指示。</target>
        </trans-unit>
        <trans-unit id="58398df6716c7ad104ead532e8557ae487862fcd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Token or token prefix queries&lt;/b&gt;. An FTS table may be queried for all documents that contain a specified term (the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple case&lt;/a&gt; described above), or for all documents that contain a term with a specified prefix. As we have seen, the query expression for a specific term is simply the term itself. The query expression used to search for a term prefix is the prefix itself with a '*' character appended to it. For example:</source>
          <target state="translated">&lt;b&gt;令牌或令牌前缀查询&lt;/b&gt;。可以查询包含指定术语的所有文档的FTS表（上述&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;简单情况&lt;/a&gt;），或包含带有指定前缀的术语的所有文档。如我们所见，特定术语的查询表达式只是该术语本身。用于搜索术语前缀的查询表达式是前缀本身，后面带有&amp;ldquo; *&amp;rdquo;字符。例如：</target>
        </trans-unit>
        <trans-unit id="35470c2e36b5d89ec0e5e0b5a16713ad8751938f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Transition into and out of WAL-mode&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;进入和退出WAL模式&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e85cc4d69fe87371b922680953209fdf60a9693f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Transparency.&lt;/b&gt; Degree to which the digital representation is open to direct analysis with basic tools, such as human readability using a text-only editor.</source>
          <target state="translated">&lt;b&gt;透明度。&lt;/b&gt;可以使用基本工具直接分析数字表示形式的程度，例如使用纯文本编辑器的人类可读性。</target>
        </trans-unit>
        <trans-unit id="6a1fef7ef2345014e787011b548dc8376d0bc1e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Truncate file&lt;/b&gt; operations. SQLite may truncate existing files by invoking the xTruncate() method of the sqlite3_file object.</source>
          <target state="translated">&lt;b&gt;截断文件&lt;/b&gt;操作。SQLite可以通过调用sqlite3_file对象的xTruncate（）方法来截断现有文件。</target>
        </trans-unit>
        <trans-unit id="bb4145432e1ccc1ea44b70a3377b44f8258ea4c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;UNBOUNDED FOLLOWING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无限制跟随&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d68f4761ba65c695e8f710308c336949cdcf89a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;UNBOUNDED PRECEDING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无限制的先例&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6f890ba61b6934cda1714e413c59c0c5a42dc7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Ubuntu&lt;/b&gt;: Desktop built from Intel i7-4770K at 3.50GHz, 32GiB RAM, Ubuntu 16.04.2 LTS</source>
          <target state="translated">&lt;b&gt;Ubuntu&lt;/b&gt;：由Intel i7-4770K在3.50GHz，32GiB RAM，Ubuntu 16.04.2 LTS构建的桌面</target>
        </trans-unit>
        <trans-unit id="8085a5307e375e1a3cc4d8ecb812cae7fed22ef8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Uninitialized memory.&lt;/b&gt; The instrumented memory allocator initializes each memory allocation to a nonsense bit pattern to help ensure that the user makes no assumptions about the content of allocation memory.</source>
          <target state="translated">&lt;b&gt;未初始化的内存。&lt;/b&gt;插入的内存分配器将每个内存分配初始化为一个无意义的位模式，以帮助确保用户不对分配内存的内容做任何假设。</target>
        </trans-unit>
        <trans-unit id="3925f9c7cd97c1b3f5e29f1be80c33e589fe5fd4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update on 2018-05-39:&lt;/b&gt; Our goal of supporting SQLite long-term have apparently come to the notice of the preservationist at the &lt;a href=&quot;https://www.loc.gov&quot;&gt;US Library Of Congress&lt;/a&gt; who have identified SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for the preservation of digital content.</source>
          <target state="translated">&lt;b&gt;2018年5月39日更新：&lt;/b&gt;&lt;a href=&quot;https://www.loc.gov&quot;&gt;美国国会图书馆&lt;/a&gt;的保护主义者显然已经注意到我们长期支持SQLite的目标，他们已将SQLite确定为&lt;a href=&quot;locrsf&quot;&gt;建议&lt;/a&gt;的数字内容存储格式。</target>
        </trans-unit>
        <trans-unit id="bd99662722847f47c9d95c77023462c53957fe12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update:&lt;/b&gt; As of SQLite version 3.7.0 (2010-07-21), all of SQLite memory allocation interfaces are considered stable and will be supported in future releases.</source>
          <target state="translated">&lt;b&gt;更新：&lt;/b&gt;从SQLite版本3.7.0（2010-07-21）开始，所有SQLite内存分配接口都被认为是稳定的，并且在将来的版本中将受支持。</target>
        </trans-unit>
        <trans-unit id="4a17f9a5725b7ea7266f7211279b754186bbd337" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions.&lt;/b&gt; SQLite normally assumes that terms in the WHERE clause that cannot be used by indexes have a strong probability of being true. If this assumption is incorrect, it could lead to a suboptimal query plan. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions can be used to provide hints to the query planner about WHERE clause terms that are probably not true, and thus aid the query planner in selecting the best possible plan.</source>
          <target state="translated">&lt;b&gt;使用&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不太可能（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;似然（）&lt;/a&gt; SQL函数。&lt;/b&gt;SQLite通常假定WHERE子句中的索引不能使用的术语很有可能为真。如果此假设不正确，则可能导致查询计划不理想。在&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不可能的（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;可能性（）&lt;/a&gt; SQL函数可用来提供线索约WHERE子句条件，也就是不正确的，从而帮助查询规划中选择最好的规划查询规划。</target>
        </trans-unit>
        <trans-unit id="eb5521088e750b2b0996ab4ac8d5d78ce99b3974" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use compile-time options to enable debugging features.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;使用编译时选项启用调试功能。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="624e8c505d78662928c531469f8c4839dcd31815" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use of memory after freeing.&lt;/b&gt; When each block of memory is freed, every byte is overwritten with a nonsense bit pattern. This helps to ensure that no memory is ever used after having been freed.</source>
          <target state="translated">&lt;b&gt;释放后使用内存。&lt;/b&gt;释放每个内存块后，每个字节都会被无意义的位模式覆盖。这有助于确保释放后不再使用任何内存。</target>
        </trans-unit>
        <trans-unit id="60df967df8dc96a687fd1c6e5298ea7d5de4825c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &quot;.eqp full&quot; option on the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;在&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;上使用&amp;ldquo; .eqp full&amp;rdquo;选项&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee77fa4780771a6f5280fc94a682c4c8900c4945" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; syntax to enforce the selection of particular indexes on problem queries.&lt;/b&gt; As with the previous two bullets, avoid this step if possible, and especially avoid doing this early in development as it is clearly a premature optimization.</source>
          <target state="translated">&lt;b&gt;使用&lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt;语法来强制选择问题查询中的特定索引。&lt;/b&gt;与前面的两个项目符号一样，请尽可能避免执行此步骤，尤其要避免在开发初期进行此操作，因为这显然是过早的优化。</target>
        </trans-unit>
        <trans-unit id="bba7254595e9a630fbbef9f9fef16a316097697a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &lt;a href=&quot;optoverview#crossjoin&quot;&gt;CROSS JOIN&lt;/a&gt; syntax to enforce a particular loop nesting order on queries that might use low-quality indexes in an unanalyzed database.&lt;/b&gt; SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;treats the CROSS JOIN operator specially&lt;/a&gt;, forcing the table to the left to be an outer loop relative to the table on the right.</source>
          <target state="translated">&lt;b&gt;使用&lt;a href=&quot;optoverview#crossjoin&quot;&gt;CROSS JOIN&lt;/a&gt;语法对可能在未分析的数据库中使用低质量索引的查询强制执行特定的循环嵌套顺序。&lt;/b&gt;SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;特别对待CROSS JOIN运算符&lt;/a&gt;，将左侧的表强制为相对于右侧的表的外循环。</target>
        </trans-unit>
        <trans-unit id="fa98b891b98a769270b4431b060723a6be69cc3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use unary &quot;+&quot; operators to disqualify WHERE clause terms.&lt;/b&gt; If the query planner insists on selecting a poor-quality index for a particular query when a much higher-quality index is available, then &lt;a href=&quot;optoverview#uplus&quot;&gt;careful use of unary &quot;+&quot; operators&lt;/a&gt; in the WHERE clause can force the query planner away from the poor-quality index. Avoid using this trick if at all possible, and especially avoid it early in the application development cycle. Beware that adding a unary &quot;+&quot; operator to an equality expression might change the result of that expression if &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is involved.</source>
          <target state="translated">&lt;b&gt;使用一元&amp;ldquo; +&amp;rdquo;运算符取消WHERE子句条款的资格。&lt;/b&gt;如果查询计划者在质量更高的索引可用时坚持为特定查询选择劣质索引，则在WHERE子句中&lt;a href=&quot;optoverview#uplus&quot;&gt;谨慎使用一元&amp;ldquo; +&amp;rdquo;运算符&lt;/a&gt;可迫使查询计划者摆脱劣质指数。尽可能避免使用此技巧，尤其是在应用程序开发周期的早期避免使用此技巧。请注意，如果涉及&lt;a href=&quot;datatype3#affinity&quot;&gt;类型相似性，&lt;/a&gt;则在相等表达式中添加一元&amp;ldquo; +&amp;rdquo;运算符可能会更改该表达式的结果。</target>
        </trans-unit>
        <trans-unit id="cca9bf8bd8b6e185263dc550b7207fcabdfc778b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Using the &quot;.breakpoint&quot; shell command&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;使用&amp;ldquo; .breakpoint&amp;rdquo; shell命令&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="185e070273e5254ad642967181d8c3d2a28284dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Using the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; shell commands&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;使用&amp;ldquo; .selecttrace&amp;rdquo;和&amp;ldquo; .wheretrace&amp;rdquo; shell命令&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f9397605fb07688bb69ea9f7536e70930b36524" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Variable-length records&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;可变长度记录&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5a6e556c10ec550463c045d14c122976ce8b5d00" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Very large datasets&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;大型数据集&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97000c025a0125f099ec23dce5e3ca08c6acd95e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Very large write transactions.&lt;/b&gt; A checkpoint can only complete when no other transactions are running, which means the WAL file cannot be reset in the middle of a write transaction. So a large change to a large database might result in a large WAL file. The WAL file will be checkpointed once the write transaction completes (assuming there are no other readers blocking it) but in the meantime, the file can grow very big.</source>
          <target state="translated">&lt;b&gt;非常大的写入事务。&lt;/b&gt;仅当没有其他事务在运行时，检查点才能完成，这意味着WAL文件无法在写事务中间重置。因此，对大型数据库进行的较大更改可能会导致产生较大的WAL文件。一旦写入事务完成（假设没有其他读者阻止它），WAL文件将被检查点，但是与此同时，该文件可能会变得很大。</target>
        </trans-unit>
        <trans-unit id="7d515fde87203051ec78c69e20ed524f4de5793a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_CKPT_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_CKPT_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad6d56d4428a77145ca6242e596a7fa2c1803531" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_READ_LOCK(N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_READ_LOCK(N)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5d110f0b82f62dd2f5a0794e764ea8169257175" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_RECOVER_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_RECOVER_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f158b1754a80661dff694e137aecc3b2f6efb345" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_WRITE_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_WRITE_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="888483948ca68cc0b0af34e4a9b2b453974882ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; Misuse of this pragma can result in &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;database corruption&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;滥用该编译指示可能会导致&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;数据库损坏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0030ed0fd53893377f5547815043278fa13ee8c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The data returned by the EXPLAIN QUERY PLAN command is intended for interactive debugging only. The output format may change between SQLite releases. Applications should not depend on the output format of the EXPLAIN QUERY PLAN command.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt; EXPLAIN QUERY PLAN命令返回的数据仅用于交互式调试。在SQLite版本之间，输出格式可能会有所不同。应用程序不应依赖于EXPLAIN QUERY PLAN命令的输出格式。</target>
        </trans-unit>
        <trans-unit id="3df3036875341edb9f8fc3a8acb1f8bcea071d37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的对象是&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象。在多线程环境中，未受保护的sqlite3_value对象只能与&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;安全使用。如果&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象以任何其他方式使用，包括调用诸如&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes（）之&lt;/a&gt;类的例程，则该行为不是线程安全的。因此，sqlite3_column_value（）接口通常仅在以下实现中有用&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;，不在顶级应用程序代码内。</target>
        </trans-unit>
        <trans-unit id="0e64773b994422fdf54e1035001ec5e582ab69ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8f3551ffb881577fe6fa2ff6b699dbc1110b90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e113677f8631906939d48925646a6301748cade3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的对象是&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象。在多线程环境中，未受保护的sqlite3_value对象只能与&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;安全使用。如果&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象以任何其他方式使用，包括调用诸如&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int（）&lt;/a&gt;，&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;或&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes（）之&lt;/a&gt;类的例程，则该行为不是线程安全的。因此，sqlite3_column_value（）接口通常仅在以下实现中有用&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;，不在顶级应用程序代码内。</target>
        </trans-unit>
        <trans-unit id="c159c6aeb388ae4e30b7b7f4145c9b703dbe4dfe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; writing to the SQLITE_DBPAGE virtual table can very easily cause unrecoverably database corruption. Do not allow untrusted components to access the SQLITE_DBPAGE table. Use appropriate care while using the SQLITE_DBPAGE table. Back up important data prior to experimenting with the SQLITE_DBPAGE table. Writes to the SQLITE_DBPAGE virtual table are disabled when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set.</source>
          <target state="translated">&lt;b&gt;警告：&lt;/b&gt;写入SQLITE_DBPAGE虚拟表很容易导致数据库无法恢复。不允许不受信任的组件访问SQLITE_DBPAGE表。使用SQLITE_DBPAGE表时要格外小心。在尝试使用SQLITE_DBPAGE表之前，请备份重要数据。设置&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;标志后，将禁止写入SQLITE_DBPAGE虚拟表。</target>
        </trans-unit>
        <trans-unit id="4f374c63735201c6cdaca2e4426827ae4ba2ca2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Website Database.&lt;/b&gt; Because it requires no configuration and stores information in ordinary disk files, SQLite is a popular choice as the database to back small to medium-sized websites.</source>
          <target state="translated">&lt;b&gt;网站数据库。&lt;/b&gt;因为不需要配置，并且将信息存储在普通磁盘文件中，所以SQLite作为支持中小型网站的数据库是一种流行的选择。</target>
        </trans-unit>
        <trans-unit id="5e075eb30727f1c365f2bc04efc0a16da3a863f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Websites&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Websites&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="da1e82610dd7e1bffc89ad32ea03dfb074479e2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Win10&lt;/b&gt;: A 2016 Lenovo YOGA 910, Intel i7-7500 at 2.70GHz, 16GiB RAM, Windows10.</source>
          <target state="translated">&lt;b&gt;Win10&lt;/b&gt;：2016年的Lenovo YOGA 910、2.70GHz的Intel i7-7500、16GiB RAM，Windows10。</target>
        </trans-unit>
        <trans-unit id="ea8bed047d5529263f89a6ee40214f46592fa94e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Win7&lt;/b&gt;: A circa-2009 Dell Inspiron laptop, Pentium dual-core at 2.30GHz, 4GiB RAM, Windows7.</source>
          <target state="translated">&lt;b&gt;Win7&lt;/b&gt;：2009年左右的Dell Inspiron笔记本电脑，奔腾双核2.30GHz，4GiB RAM，Windows7。</target>
        </trans-unit>
        <trans-unit id="e68611734bd3e7ab106c3521f7c655f4756a046c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Wrapped Pile-of-Files Formats.&lt;/b&gt; Some applications use a Pile-of-Files that is then encapsulated into some kind of single-file container, usually a ZIP archive. EPUB, ODT,and ODP are examples of this approach. An EPUB book is really just a ZIP archive that contains various XHTML files for the text of book chapters, GIF and JPEG images for the artwork, and a specialized catalog file that tells the eBook reader how all the XML and image files fit together. OpenOffice documents (ODT and ODP) are also ZIP archives containing XML and images that represent their content as well as &quot;catalog&quot; files that show the interrelationships between the component parts.</source>
          <target state="translated">&lt;b&gt;包装文件堆格式。&lt;/b&gt;某些应用程序使用文件堆，然后将文件堆封装到某种单文件容器中，通常是ZIP存档。 EPUB，ODT和ODP是这种方法的示例。 EPUB图书实际上只是一个ZIP存档，其中包含书籍章节文本的各种XHTML文件，艺术品的GIF和JPEG图像，以及专门的目录文件，该文件告诉eBook阅读器所有XML和图像文件如何组合在一起。 OpenOffice文档（ODT和ODP）也是ZIP归档文件，其中包含表示其内容的XML和图像以及&amp;ldquo;目录&amp;rdquo;文件，这些文件显示了组成部分之间的相互关系。</target>
        </trans-unit>
        <trans-unit id="e80e6ef180f77a11e4ad718760489bfd6c1d3980" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Write file&lt;/b&gt; operations. SQLite may modify the contents and increase the size of a file by files by invoking the xWrite() method of the sqlite3_file object.</source>
          <target state="translated">&lt;b&gt;写入文件&lt;/b&gt;操作。SQLite可以通过调用sqlite3_file对象的xWrite（）方法来修改文件的内容并按文件增加文件的大小。</target>
        </trans-unit>
        <trans-unit id="e93a8e5c6820d5cb61b30e7580636cac841de035" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Writer Starvation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;作家饥饿&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d5d06edcd682d757dc164e732a60c0964a20210" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;YYSTACKDEPTH=&lt;i&gt;&amp;lt;max_depth&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;YYSTACKDEPTH=&lt;i&gt;&amp;lt;max_depth&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ccba30872e5a56e0c69301bb6c07bd4a14eedd1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;YYTRACKMAXSTACKDEPTH&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;YYTRACKMAXSTACKDEPTH&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d9774ec4279042a099a60de1ddc091ef4d042e40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Zero-Configuration&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Zero-Configuration&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d787411914cc50b14089e0d3d1dd388e2edc91a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Zero-malloc option.&lt;/b&gt; The application can optionally provide SQLite with several buffers of bulk memory at startup and SQLite will then use those provided buffers for all of its memory allocation needs and never call system malloc() or free().</source>
          <target state="translated">&lt;b&gt;零malloc选项。&lt;/b&gt;应用程序可以选择在启动时为SQLite提供大容量内存的几个缓冲区，然后SQLite将使用提供的缓冲区满足其所有内存分配需求，并且从不调用系统malloc（）或free（）。</target>
        </trans-unit>
        <trans-unit id="8f2b743bcbe285635e0463a315a493eb37176373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;_HAVE_SQLITE_CONFIG_H&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;_HAVE_SQLITE_CONFIG_H&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="33dcc6c87c822c07ebff240814a228ff607b0b40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;abs(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;abs(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe5e3b0d396d614226a54388a7b4de0441733b51" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;alignment&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;alignment&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="194ffe7cb502ded114f889082435f2c16c8b7359" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;application_id = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;application_id = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5443e0f7d9f275c31c0eb7151cf4ea53927946d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;application_id; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;application_id; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e52171e1f2ed13a70f81dde9b3a852059c3f9848" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;assert(X)&lt;/b&gt; &amp;rarr; The assert(X) statement indicates that the condition X is always true. In other words, X is an invariant. The assert(X) macro works like a procedure in that it has no return value.</source>
          <target state="translated">&lt;b&gt;assert（X）&lt;/b&gt; &amp;rarr;assert（X）语句指示条件X始终为true。换句话说，X是不变量。assert（X）宏的作用类似于过程，因为它没有返回值。</target>
        </trans-unit>
        <trans-unit id="e1d034110b826070c391f6a1b3222b94a181199d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;auto_vacuum = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;auto_vacuum = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d7cd7347cc987aab65acd4c17d0fb4f855e08cf4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;auto_vacuum;&lt;br/&gt; PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;auto_vacuum; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d128f6edd956bb72b334d983e9c173584d32d33a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;avg(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;avg(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eb7b6c83e75fbe3b054ea415310a7352288778a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;backup_remaining() and backup_pagecount()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;backup_remaining（）和backup_pagecount（）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="af51318f30245050461c25ceed50b0039299603f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;busy&lt;/b&gt;: This field is true if the prepared statement is currently running. In other words, this field is true if &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called on the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; at least once but &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; has not yet been called to reset it.</source>
          <target state="translated">&lt;b&gt;busy&lt;/b&gt;：如果准备好的语句当前正在运行，则此字段为true。换句话说，如果该字段为真&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;已经呼吁&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的声明中&lt;/a&gt;至少一次，但&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;尚未被称为重置。</target>
        </trans-unit>
        <trans-unit id="c07a69ddd20e31f1d596560030beac75f1ec41f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache&lt;/b&gt;: The cache parameter may be set to either &quot;shared&quot; or &quot;private&quot;. Setting it to &quot;shared&quot; is equivalent to setting the SQLITE_OPEN_SHAREDCACHE bit in the flags argument passed to sqlite3_open_v2(). Setting the cache parameter to &quot;private&quot; is equivalent to setting the SQLITE_OPEN_PRIVATECACHE bit. If sqlite3_open_v2() is used and the &quot;cache&quot; parameter is present in a URI filename, its value overrides any behavior requested by setting SQLITE_OPEN_PRIVATECACHE or SQLITE_OPEN_SHAREDCACHE flag.</source>
          <target state="translated">&lt;b&gt;cache&lt;/b&gt;：cache参数可以设置为&amp;ldquo; shared&amp;rdquo;或&amp;ldquo; private&amp;rdquo;。将其设置为&amp;ldquo;共享&amp;rdquo;等效于将传递给sqlite3_open_v2（）的flags参数中的SQLITE_OPEN_SHAREDCACHE位置1。将缓存参数设置为&amp;ldquo;专用&amp;rdquo;等同于将SQLITE_OPEN_PRIVATECACHE位置1。如果使用sqlite3_open_v2（）且URI文件名中包含&amp;ldquo; cache&amp;rdquo;参数，则其值将覆盖通过设置SQLITE_OPEN_PRIVATECACHE或SQLITE_OPEN_SHAREDCACHE标志所请求的任何行为。</target>
        </trans-unit>
        <trans-unit id="048afc3980c205fecc84abbd48f15a61272e10f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache=shared&lt;br/&gt;cache=private&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache=shared&lt;br/&gt;cache=private&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f187cf2b0d507dcac54b947ef4b4bb4548adec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size = -&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size =-&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="66a05bfa29a1d5ad78648c64ef4a1bc402a7ef7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8be0f4e9732fbef28f44a865ce5359d4c63e5ba3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4d813d1d4f13504bccfdec67887288aeb2c74bf6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_spill=&lt;i&gt;N&lt;/i&gt;;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_spill=&lt;i&gt;N&lt;/i&gt;;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee76635f943345e36eadd20f93c4b84d756cd424" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;changes()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;changes()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6e34c8fad0c61810b664b1fb208a7e152cbd2d8f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;char(&lt;i&gt;X1&lt;/i&gt;,&lt;i&gt;X2&lt;/i&gt;,...,&lt;i&gt;XN&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;char(&lt;i&gt;X1&lt;/i&gt;,&lt;i&gt;X2&lt;/i&gt;,...,&lt;i&gt;XN&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9abb03962a5dc4852aff5e36c48f45d6a4a3d77a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;close&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;close&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2d6e4e63ef7fd21c4175c425685a7ddb1ca2bea1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;coalesce(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;coalesce(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="35bbbb1bb66c64e00f2934f51b73b8e4f4056495" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;columns=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22b498af88a752c45b7e25f4181284d3db7afb1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;command&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;command&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad084040fb5ea49d3658d7989127f682b7f28c67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;count(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;count(*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;count(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;count(*)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39af06e9905a7448ee0b1defae9d454b6841f4d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cov.rc&lt;/b&gt; - Options for measuring test coverage</source>
          <target state="translated">&lt;b&gt;cov.rc-&lt;/b&gt;测量测试覆盖率的选项</target>
        </trans-unit>
        <trans-unit id="5cca5b66dc12bd7e7becb822abbebae01386bdb2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cume_dist()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cume_dist()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bce3e62d8a1b34b91114cf92fb902035b214587" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;data=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3783e6f7dc101319ad924bc9f09ae132e7c7f898" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data_version;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;data_version;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="389b2f8f724900f956d877a644e2e9603c0f26c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;date(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;date(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cbcb55ef3726cc2a71910590d0902f7faab4f9ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;datetime(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;datetime(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aee590495d14ff2cf1c5cbc37042295e0d1f08cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;default_cache_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;default_cache_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="402ca1dacea0721ad239c1af6cb3f5819295774e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;default_cache_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;default_cache_size; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6313bf298d297088101bbaddb662c2c916679adf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;dense_rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;dense_rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2aac9f3db608b20d11947a5ae9700ebd62f45001" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;distance&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;distance&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b484c204986ea3c75fae52cefde5798b5dd4e4f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;editdist3(P,W)&lt;br/&gt;editdist3(P,W,L)&lt;br/&gt;editdist3(T)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;editdist3(P,W)&lt;br/&gt;editdist3(P,W,L)&lt;br/&gt;editdist3(T)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="70f1ae63992807b1cef27255763402cd1c0c70d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;extensions.rc&lt;/b&gt; - Options to enable &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;, and &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;STAT4&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;extensions.rc-&lt;/b&gt;启用&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;，&lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;和&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;STAT4的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dd31bb22c519a3244a9371c90073d27eba9fcff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;fast.rc&lt;/b&gt; - Run most tests, including those not needed for coverage, skipping only soak tests, using delivery compiler options (ex: -O3)</source>
          <target state="translated">&lt;b&gt;fast.rc-&lt;/b&gt;使用交付编译器选项（例如：-O3）运行大多数测试，包括不需要的测试，仅跳过浸泡测试</target>
        </trans-unit>
        <trans-unit id="7047224cc767c22276bcd97b8b93c32d6c6dd0c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;filename=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;filename=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d86f5b252ea2c3905e9317b675f86261fe647565" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;first_value(expr)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;first_value(expr)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f6c983beee928db863455a33eaeb9e6e8731e6e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;foreign_key_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;foreign_key_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="98b8402ef4aa6df707621ab3e1424480dcd1b470" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;foreign_key_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;foreign_key_check; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e17b9027ffda510fd8200ef5dd02defe76fb361b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;freelist_count;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;freelist_count;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="49c799144ac6e15128ed0f9aa7ec635a662a3d31" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;glob(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;glob(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d51045bdeca73ea8688c5521c40c4f76212598ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;group_concat(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;group_concat(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;group_concat(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;group_concat(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cbaa7085724de96292b616e3361c44f3e9990d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;header&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;header&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffde63e4ba8d63cb5d1bc14f06bfecda9f5dd8b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;header=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;header=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1cfef432e2caab9415a288e0d7ba9d174b173a01" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;hex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;hex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd48f9963329d57278b189812b34811095c6cdeb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;id&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;id&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c5a7a75e65828537df32db2f1ac3e8fbbb008fae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ifnull(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ifnull(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="59e394b44a6744677d3a72d0eb34c77ce86693ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;iif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;iif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cce521b193beb15f59295fefb696fd4ade983bb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable&lt;/b&gt;: The immutable parameter is a boolean query parameter that indicates that the database file is stored on read-only media. When immutable is set, SQLite assumes that the database file cannot be changed, even by a process with higher privilege, and so the database is opened read-only and all locking and change detection is disabled. Caution: Setting the immutable property on a database file that does in fact change can result in incorrect query results and/or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors. See also: &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;immutable&lt;/b&gt;：immutable参数是一个布尔查询参数，它指示数据库文件存储在只读介质上。设置不可变后，SQLite假定即使具有更高特权的进程也无法更改数据库文件，因此该数据库以只读方式打开，并且所有锁定和更改检测均被禁用。注意：在实际上发生更改的数据库文件上设置不可变属性可能会导致错误的查询结果和/或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;错误。另请参阅：&lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cf141062b07419b584f4c1883f6a203a2df6601" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable&lt;/b&gt;: The immutable parameter is a boolean query parameter that indicates that the database file is stored on read-only media. When immutable is set, SQLite assumes that the database file cannot be changed, even by a process with higher privilege, and so the database is opened read-only and all locking and change detection is disabled. Caution: Setting the immutable property on a database file that does in fact change can result in incorrect query results and/or &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors. See also: &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;immutable&lt;/b&gt;：immutable参数是一个布尔查询参数，它指示数据库文件存储在只读介质上。设置不可变后，SQLite假定即使具有更高特权的进程也无法更改数据库文件，因此该数据库以只读方式打开，并且所有锁定和更改检测均被禁用。注意：在实际上发生更改的数据库文件上设置不可变属性可能会导致错误的查询结果和/或&lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;错误。另请参阅：&lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed08b6b1d1f0a664ae0f81d71d8d7810b3165b6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;immutable=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cccabe1bc4519474ead8892d0cd69c8b0775ed4b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;incremental_vacuum;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;incremental_vacuum;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b5baf91e220e87719852feaa7184a098f41965b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;incremental_vacuum&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;incremental_vacuum&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f16d799bd7829150ce3e6604138fbebab20b5419" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_info(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_info(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7688cc1ff573d2bca1de629a8d2a79e927035298" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_list(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_list(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2dfeb29a44b8e71355e11dbd4cf0aebfdd351c06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_xinfo(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_xinfo(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="207535d3995e19d40dc08d055ca415f8028e650a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;instr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;instr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac72f17cc719eb38ab9ab57e1ac893c356c119eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnCount)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xColumnCount）（Fts5Context *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9750e0f760da519d8715d51c87874648a8fe67e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xColumnSize）（Fts5Context *，int iCol，int * pnToken）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d42b31da68a1e7f9ae5eecbab61aee9b43cb6b1b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xColumnText）（Fts5Context *，int iCol，const char ** pz，int * pn）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a7ce4bfbb6d268c0d1ef8670fc34f7a4b65bb387" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xColumnTotalSize）（Fts5Context *，int iCol，sqlite3_int64 * pnToken）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3190bda489a99715fd738757d80223d99cccdbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xInst）（Fts5Context *，int iIdx，int * piPhrase，int * piCol，int * piOff）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="892559d9568a1d87d97b14bc61079a34debf6b83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xInstCount)(Fts5Context*, int *pnInst)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xInstCount）（Fts5Context *，int * pnInst）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="100e77957aba25dbbb31de82532ca7bf291eb970" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseCount)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xPhraseCount）（Fts5Context *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fcdaa92e2b0fc49b2bf5da218bbca933cf5c296" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xPhraseFirst）（Fts5Context *，int iPhrase，Fts5PhraseIter *，int *，int *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="031f3306d8acf8f83f8963454a0457de1feea424" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xPhraseFirstColumn）（Fts5Context *，int iPhrase，Fts5PhraseIter *，int *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d49467cfac66b79b5909b3a249dfaa9d04d187b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseSize)(Fts5Context*, int iPhrase)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xPhraseSize）（Fts5Context *，int iPhrase）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e27ad327723310374823171bdbac767d224d4747" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData, int(*)(const Fts5ExtensionApi*,Fts5Context*,void*) )&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xQueryPhrase）（Fts5Context *，int iPhrase，void * pUserData，int（*）（const Fts5ExtensionApi *，Fts5Context *，void *）））&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8af65e8dd1bd43dd26a39f7927ec9a0e3fc20406" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xRowCount）（Fts5Context *，sqlite3_int64 * pnRow）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="028bae0525e377b198a0579de0698834b402ef0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*))&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xSetAuxdata）（Fts5Context *，void * pAux，void（* xDelete）（void *））&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96b299d4b01b17194f0bfab31185570b2a5b0e26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xTokenize)(Fts5Context*, const char *pText, int nText, void *pCtx, int (*xToken)(void*, int, const char*, int, int, int) )&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int（* xTokenize）（Fts5Context *，const char * pText，int nText，void * pCtx，int（* xToken）（void *，int，const char *，int，int，int）））&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="71f951b67bdae3181e28bc99fbd1081f3db56229" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;integrity_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;integrity_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5f61e2b4f6af6827071e26ba0468c59f77f7382d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;integrity_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;完整性检查; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8dbcbd2f1b02531496228f6526096af9fa315739" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_mode = &lt;i&gt;DELETE | TRUNCATE | PERSIST | MEMORY | WAL | OFF&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_mode = &lt;i&gt;删除| 截断 持久性| 内存| 沃尔| 关&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f421c8ecbe88c2e594c771b7201c65eb77fcce60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_mode; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_mode; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="33e1050ba5c76fd251b389021a94f193300849d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_size_limit = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_size_limit = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6038a087fec5ff7e87d3be2a0c692b4c7d54bf7c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_size_limit&lt;br/&gt; PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_size_limit &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="27b030b978b02cc9207038086c7f2c60253ad04d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;julianday(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;julianday(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c43da3ded817719eb56f1590ebd527ae35875002" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;k1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;k1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d8481cc752e77e81f239fb8d49320bf2fa634efc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;k2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;k2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ede80f5c49ab1747c7f023b90de4537abacf288" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lag(expr)&lt;br/&gt;lag(expr, offset)&lt;br/&gt;lag(expr, offset, default)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;lag（expr）&lt;br/&gt;lag（expr，offset）&lt;br/&gt;滞后（expr，offset，default）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d9ce10c584a3ee6d960754c6357d4f20cf2de71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;langid&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;langid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f306288a791aefbb510d07825cdcbd178d873e42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;last_insert_rowid()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;last_insert_rowid()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cca2232f164d7c66d07ad3c034e6f4b6dda69dbd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;last_value(expr)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;last_value(expr)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="81ed8362f530c16dff1f7d9cc5b282b98b462fc2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lead(expr)&lt;br/&gt;lead(expr, offset)&lt;br/&gt;lead(expr, offset, default)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;lead（expr）&lt;br/&gt;lead（expr，偏移量）&lt;br/&gt;lead（expr，偏移量，默认值）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="43d2123909b0f5a819af3db1c1e94d06a3f8779f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;length(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;length(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dfc5b8f00ea873518dc12f8893f25bbc6c66ce67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;br/&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;br/&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07c7c73b4b3991211d36821e85de44d186de4969" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;likelihood(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;likelihood(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="811594ce0b6e61d3b980bd09f4d1c39bf30bbb95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;likely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;likely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cdbe6610ca98a28c81ac1d281754e9a5e02f6a4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;load_extension(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;load_extension(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;load_extension(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;load_extension(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9df7ac0e0e06da4f24921e24ffa4a99e384f1953" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locking_mode = &lt;i&gt;NORMAL | EXCLUSIVE&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;锁定模式=正常&lt;i&gt;| 独家&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dbd9cb7c00973c9cf4c02835fba7d46c4cd155b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locking_mode; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;锁定模式; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d97f3f643b48dea573d334c35e46808c117b3e16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lower(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;lower(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99d4e148947298901a28af9618a2edc72556c7ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ltrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;ltrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ltrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;ltrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="50ee49b847d1bd0b4c011677c606dfe46418f9b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;matchlen&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;matchlen&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="84700aab85d80dd19448c1aadba1ce06d6cac5e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dc1c91322cff028b6d2a6ae101916dba85e55305" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="86c668cbb57e22aa0c108185ae17175562403e88" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max_page_count = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max_page_count = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cca5fba8273357af3d23375f683db4ab915088e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max_page_count; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max_page_count; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46970ade90f97e0fcf3e0dcfc00dfcc8abf51125" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mem&lt;/b&gt;: This field is the number of bytes of heap storage used by the prepared statement. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;mem&lt;/b&gt;：此字段是prepared语句使用的堆存储的字节数。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="2323e80eea828e053d28f31a4b3c98243b0559a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;memdebug.rc&lt;/b&gt; - like test.rc but also enable &lt;a href=&quot;compile#memdebug&quot;&gt;-DSQLITE_MEMDEBUG&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;memdebug.rc&lt;/b&gt; -像test.rc也使&lt;a href=&quot;compile#memdebug&quot;&gt;-DSQLITE_MEMDEBUG&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2385b3a406fa9ea94dd4092a1e7ffc158d26ec6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fb8829a5160360e2352f3a4c213691d03f9ba3f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d8df04651e720bd40286ee83b4d6e48760a9ee7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min.rc&lt;/b&gt; - Run the minimum set of tests needed for 100% coverage.</source>
          <target state="translated">&lt;b&gt;min.rc-&lt;/b&gt;运行100％覆盖率所需的最小测试集。</target>
        </trans-unit>
        <trans-unit id="9b5e7d659f4cfe7edf20e886f624adf61dcf6fe6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mmap_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mmap_size; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2d0eb11df5451ce3b5760e53da3fa40b8b4daa6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mmap_size=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mmap_size=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ab2f639309419d347aca23f719e0b621afb92015" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode&lt;/b&gt;: The mode parameter may be set to either &quot;ro&quot;, &quot;rw&quot;, &quot;rwc&quot;, or &quot;memory&quot;. Attempting to set it to any other value is an error. If &quot;ro&quot; is specified, then the database is opened for read-only access, just as if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; flag had been set in the third argument to sqlite3_open_v2(). If the mode option is set to &quot;rw&quot;, then the database is opened for read-write (but not create) access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had been set. Value &quot;rwc&quot; is equivalent to setting both SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE. If the mode option is set to &quot;memory&quot; then a pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; that never reads or writes from disk is used. It is an error to specify a value for the mode parameter that is less restrictive than that specified by the flags passed in the third parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;mode&lt;/b&gt;：模式参数可以设置为&amp;ldquo; ro&amp;rdquo;，&amp;ldquo; rw&amp;rdquo;，&amp;ldquo; rwc&amp;rdquo;或&amp;ldquo; memory&amp;rdquo;。尝试将其设置为任何其他值是一个错误。如果指定&amp;ldquo; ro&amp;rdquo;，则打开数据库以进行只读访问，就像在sqlite3_open_v2（）的第三个参数中设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;标志一样。如果将模式选项设置为&amp;ldquo; rw&amp;rdquo;，则将打开数据库以进行读写（但不创建）访问，就好像已设置了SQLITE_OPEN_READWRITE（但未设置SQLITE_OPEN_CREATE）一样。值&amp;ldquo; rwc&amp;rdquo;等效于设置SQLITE_OPEN_READWRITE和SQLITE_OPEN_CREATE。如果将模式选项设置为&amp;ldquo;内存&amp;rdquo;，则为纯&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;从不读取或写入磁盘。为mode参数指定的值限制比第三个参数传递给sqlite3_open_v2（）的标志所指定的限制要小，这是错误的。</target>
        </trans-unit>
        <trans-unit id="09e6b105c2bf735792ce11591cbf9c2f8556c47d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode&lt;/b&gt;: The mode parameter may be set to either &quot;ro&quot;, &quot;rw&quot;, &quot;rwc&quot;, or &quot;memory&quot;. Attempting to set it to any other value is an error. If &quot;ro&quot; is specified, then the database is opened for read-only access, just as if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; flag had been set in the third argument to sqlite3_open_v2(). If the mode option is set to &quot;rw&quot;, then the database is opened for read-write (but not create) access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had been set. Value &quot;rwc&quot; is equivalent to setting both SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE. If the mode option is set to &quot;memory&quot; then a pure &lt;a href=&quot;../inmemorydb&quot;&gt;in-memory database&lt;/a&gt; that never reads or writes from disk is used. It is an error to specify a value for the mode parameter that is less restrictive than that specified by the flags passed in the third parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;mode&lt;/b&gt;：模式参数可以设置为&amp;ldquo; ro&amp;rdquo;，&amp;ldquo; rw&amp;rdquo;，&amp;ldquo; rwc&amp;rdquo;或&amp;ldquo; memory&amp;rdquo;。尝试将其设置为任何其他值是一个错误。如果指定&amp;ldquo; ro&amp;rdquo;，则打开数据库以进行只读访问，就像在sqlite3_open_v2（）的第三个参数中设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;标志一样。如果将模式选项设置为&amp;ldquo; rw&amp;rdquo;，则将打开数据库以进行读写（但不创建）访问，就好像已设置了SQLITE_OPEN_READWRITE（但未设置SQLITE_OPEN_CREATE）一样。值&amp;ldquo; rwc&amp;rdquo;等效于设置SQLITE_OPEN_READWRITE和SQLITE_OPEN_CREATE。如果将模式选项设置为&amp;ldquo;内存&amp;rdquo;，则为纯&lt;a href=&quot;../inmemorydb&quot;&gt;内存数据库&lt;/a&gt;从不读取或写入磁盘。为mode参数指定的值限制比第三个参数传递给sqlite3_open_v2（）的标志所指定的限制要小，这是错误的。</target>
        </trans-unit>
        <trans-unit id="c3e378c447b57b9647ef1790cbe9e8e0fd004c14" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode=ro&lt;br/&gt;mode=rw&lt;br/&gt;mode=rwc&lt;br/&gt;mode=memory&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mode=ro&lt;br/&gt;mode=rw&lt;br/&gt;mode=rwc&lt;br/&gt;mode=memory&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3bd7aa3ba452f8a404691484d3d1e2ea817d6231" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;modeof=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;modeof=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b94737558aa8e30aba81834f353e695e866e2607" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;naidx&lt;/b&gt;: This field is the number of rows that have been inserted into &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt;. A positive value in this field may indicate an opportunity to improve performance by adding a named index that take the place of the automatic index. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusautoindex&quot;&gt;SQLITE_STMTSTATUS_AUTOINDEX&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;naidx&lt;/b&gt;：此字段是已插入&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引中&lt;/a&gt;的行数。该字段中的正值可能表示有机会通过添加代替自动索引的命名索引来提高性能。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusautoindex&quot;&gt;SQLITE_STMTSTATUS_AUTOINDEX&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="1dca50e56e569f3a137f02613f8e101412a6fd0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ncol&lt;/b&gt;: The number of columns in the result set of a query. For DML statements, this column has a value of 0.</source>
          <target state="translated">&lt;b&gt;ncol&lt;/b&gt;：查询结果集中的列数。对于DML语句，此列的值为0。</target>
        </trans-unit>
        <trans-unit id="9266cf0d1aa52a6c88fc7a9ce528569eaf218e98" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nolock&lt;/b&gt;: The nolock parameter is a boolean query parameter which if set disables file locking in rollback journal modes. This is useful for accessing a database on a filesystem that does not support locking. Caution: Database corruption might result if two or more processes write to the same database and any one of those processes uses nolock=1.</source>
          <target state="translated">&lt;b&gt;nolock&lt;/b&gt;：nolock参数是一个布尔查询参数，如果设置该参数将禁用回滚日志模式下的文件锁定。这对于访问不支持锁定的文件系统上的数据库很有用。警告：如果两个或多个进程写入同一数据库，并且其中任何一个进程使用nolock = 1，则可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="92049c4fa68e8dcb2a9ce5d1c47395f719ee2e59" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nolock=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nolock=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0821cde6d9d92bcfa8f51b791e202fe561c692f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;now&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;now&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c962d8bc64dcb99d96b34edfd80eef77b82d8960" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nscan&lt;/b&gt;: This field is the number of times that the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; has stepped through a table as part of a full-table scan. A large number if this field may indicate an opportunity to improve performance by adding an index. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nscan&lt;/b&gt;：此字段是&lt;a href=&quot;opcode&quot;&gt;字节码引擎&lt;/a&gt;作为全表扫描的一部分逐步通过表的次数。如果此字段可能表示通过添加索引来提高性能的机会，则为大量。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="793a688ba89916bc91e2948fcbbff88d939d50df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nsort&lt;/b&gt;: This field is the number of times that the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; had to sort. A positive value in this field may indicate an opportunity to improve performance by adding an index that will cause the query results to appear naturally in the desired order. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nsort&lt;/b&gt;：此字段是&lt;a href=&quot;opcode&quot;&gt;字节码引擎&lt;/a&gt;必须排序的次数。此字段中的正值可能表示有机会通过添加索引来提高性能，该索引将导致查询结果以所需顺序自然出现。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="bfe71888a18b09526c41d1b94956d1609d2df2a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nstep&lt;/b&gt;: This field is the number of &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; operations that have been performed for the prepared statement. This field can be used as a proxy for how much CPU time a statement has used. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusvmstep&quot;&gt;SQLITE_STMTSTATUS_VM_STEP&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nstep&lt;/b&gt;：此字段是为准备好的语句执行的&lt;a href=&quot;opcode&quot;&gt;字节码引擎&lt;/a&gt;操作的数量。该字段可以用作语句已使用多少CPU时间的代理。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusvmstep&quot;&gt;SQLITE_STMTSTATUS_VM_STEP&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="63815c843d590daa0dcf061c4721a9d5d4a2d517" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nth_value(expr, N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nth_value（expr，N）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d0c888098e8713ffd7470fb70089d0baee7e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ntile(N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ntile(N)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05286bde0bd001f85739e8fbad5157036721e2a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nullif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nullif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b025946bb0710a483f2eb1f6bb0f6acf583de102" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_count;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;page_count;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0acb36fa4cfdbd1af777924754ed8b90f92f80e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;page_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a41e038bc3ab6f9cb7c6c880a15dd5da22bca16a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;页面大小; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0f8fb606ccbf864fa90cbb5ee1a6f32cf556579f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;percent_rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;percent_rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7925229e75f9a5ddc4c6bcf1fce67735fed59f14" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;phonehash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;phonehash&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5499744b67dcd6206fb619427cb287b68fddad94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;printf(&lt;i&gt;FORMAT&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;printf(&lt;i&gt;FORMAT&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="173bb75d2eff480770bb8e83d250aaf82ef0042e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;profile&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;profile&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ab4d8dffa722a511d73e114b16c08dc6a537cb6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow&lt;/b&gt;: The psow parameter indicates whether or not the &lt;a href=&quot;../psow&quot;&gt;powersafe overwrite&lt;/a&gt; property does or does not apply to the storage media on which the database file resides.</source>
          <target state="translated">&lt;b&gt;psow&lt;/b&gt;：psow参数指示&lt;a href=&quot;../psow&quot;&gt;powersafe overwrite&lt;/a&gt;属性是否适用于数据库文件所在的存储介质。</target>
        </trans-unit>
        <trans-unit id="18dbe2a36203a00ce25e37c7598791b053afe0f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow&lt;/b&gt;: The psow parameter indicates whether or not the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property does or does not apply to the storage media on which the database file resides.</source>
          <target state="translated">&lt;b&gt;psow&lt;/b&gt;：psow参数指示&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;属性是否适用于数据库文件所在的存储介质。</target>
        </trans-unit>
        <trans-unit id="19672e769c27252099c41616a5a8161a4d6518d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow=0&lt;br/&gt;psow=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;psow=0&lt;br/&gt;psow=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2f260f1801a8e818b6ff06e8303be11d7451a10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick.rc&lt;/b&gt; - Run all tests required for 100% coverage tests using -Os and &lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;quick.rc-&lt;/b&gt;使用-Os和&lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt;运行100％覆盖率测试所需的所有测试。</target>
        </trans-unit>
        <trans-unit id="3fd4aa79ddd410cd9139a41d386311916ebe9d17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;quick_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="994a2c2443ac0da9003e00fe190aaa31db2160a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;快速检查; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b14e2eb2027ccd9a5fae3e53bbc6e949cbc94b70" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quote(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;quote(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="340804ccd9900156a5ee658749fc30933ec1cc6d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;random()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;random()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e582c145eb46045893175b9cad76026024fcc73" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;randomblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;randomblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d52d0687653f788c9a1d0b62c1ec148950ea4eb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c0dddfe101189ad9de03f6a2247d0074815decf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rank&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rank&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5642fd86cd16372a166c437b2acd799966efa693" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;replace(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;replace(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1387ead5a7eaf9239d995873793737440d057fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;reprep&lt;/b&gt;: This field is the number of times that the statement has had to be reprepared due to schema changes or changes to parameter bindings. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;reprep&lt;/b&gt;：此字段是由于架构更改或参数绑定更改而必须重新准备语句的次数。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="13892832e8f338f883dc9f1b67835b33d26f9407" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ro&lt;/b&gt;: The &quot;read only&quot; column. This column is true (non-zero) if the SQL statement is a query and false (zero) if it is a DML statement.</source>
          <target state="translated">&lt;b&gt;ro&lt;/b&gt;：&amp;ldquo;只读&amp;rdquo;列。如果SQL语句是查询，则此列为true（非零），如果是DML语句，则为false（零）。</target>
        </trans-unit>
        <trans-unit id="578448d770f3d2a1b5a91906bea2c63bf15fb132" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;round(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;round(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;round(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;round(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7c9a2c7f5f210b7436687e26513be6f97e02a2d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;row&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;row&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6bc595dec6582246906837ece99dd2d9d595c4be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;row_number()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;row_number()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5bb5815912a7a25828847a14d830afa81794e48c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid BETWEEN $lwr AND $upr&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;$ lwr和$ upr之间的rowid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="24cc6900b78e2dccfbf100ecdd22f5422feb3151" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid IN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;行ID IN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="194d8c92ba435bfeb5dddcca984211dc5c83f9f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rowid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc7bc59f8cdd1723aa19dd21067fb2173a1d966d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid=$id&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rowid=$id&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8b2e4bd1806543d782878e39a0464ee350a55bd2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rtrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;rtrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rtrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;rtrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1a01ed5e9b0f95f0e890796478ba1457e1d2012a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;run&lt;/b&gt;: This field is the number of times that the statement has been run. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;run&lt;/b&gt;：此字段是语句已运行的次数。该字段等效于&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="6665c42d1931c0c11bc5fdb3f4263f62967dd63d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7581ff4e29fb81935f4ac0e64765167bccedcaf5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema_version = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema_version = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e88eb35aae7e462aa136a9cf07bcc20b9b1be9ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema_version; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema_version; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fd6a9f0cd2885d562989c04156ad40993a8ae646" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;scope&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;scope&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2741e4cf3f42be902ed8f4f9feeb47588d70ef90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;score&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;score&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c73b09e15d5fda473433a1b9ec4f9f86563ba45c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;secure_delete = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;secure_delete = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cf2ead5c4efff15afbf4a1d95f72bf4bcf3aaac9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;secure_delete; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;secure_delete; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e7bba61243050573065917c0d6af2442d5ad0e95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;shell.c&lt;/b&gt;: The command-line interface program itself. This is the C source code file that contains the definition of the &lt;b&gt;main()&lt;/b&gt; routine and the loop that prompts for user input and passes that input into the SQLite database engine for processing.</source>
          <target state="translated">&lt;b&gt;shell.c&lt;/b&gt;：命令行界面程序本身。这是C源代码文件，其中包含&lt;b&gt;main（）&lt;/b&gt;例程的定义和循环，该循环提示用户输入并将该输入传递到SQLite数据库引擎进行处理。</target>
        </trans-unit>
        <trans-unit id="605c53952422929c94c4ef797c0cae43610c5471" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;soundex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;soundex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd4f59d9802ac2b8b9ccdfced25c86d0a351f22a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;soundslike&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;soundslike&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="439148df042711bd9ba70bd7e598ffbca547afb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_editdist(P,W)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_editdist(P,W)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f1a6c0d38f6505697db2c498ea35b78ed9e5fc63" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_phonehash(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_phonehash(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ce4abdb98f5e793c14ba05e7c794774cec57a9e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_scriptcode(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_scriptcode(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="55372a1db28566500f11b9a322c8e23b33028121" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_translit(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_translit(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="72513f2eaa33786572b541eb69611d8a91d32bd2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sql&lt;/b&gt;: The original SQL text of the prepared statement. If the prepared statement is compiled using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface, then the SQL text might not have been saved, in which case this column will be NULL.</source>
          <target state="translated">&lt;b&gt;sql&lt;/b&gt;：准备好的语句的原始SQL文本。如果准备好的语句是使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口编译的，则可能尚未保存SQL文本，在这种情况下，此列将为NULL。</target>
        </trans-unit>
        <trans-unit id="b98d7e7639e1091f7a9cc980b2fa80fcf072e758" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlar_compress(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlar_compress(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="40ef691312d4ca7479d76cbfc1797a518f374cc8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlar_uncompress(Y,SZ)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlar_uncompress(Y,SZ)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6cebe7a7b12fd950a74b5fba5575de4973ffb868" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3.c&lt;/b&gt;: The SQLite amalgamation source file</source>
          <target state="translated">&lt;b&gt;sqlite3.c&lt;/b&gt;：SQLite合并源文件</target>
        </trans-unit>
        <trans-unit id="5c09182d460b59bea381dbce17c0a713fbd32a19" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3.h&lt;/b&gt;: The header files that accompanies sqlite3.c and defines the C-language interfaces to SQLite.</source>
          <target state="translated">&lt;b&gt;sqlite3.h&lt;/b&gt;：&lt;b&gt;sqlite3.c&lt;/b&gt;附带的头文件，它定义SQLite的C语言接口。</target>
        </trans-unit>
        <trans-unit id="5bc4c2f9fd5dadcb7d70ecf5019b082922291e64" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_finish()&lt;/b&gt; is called to release all resources associated with the backup operation.</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;调用&lt;b&gt;sqlite3_backup_finish（）&lt;/b&gt;释放与备份操作关联的所有资源。</target>
        </trans-unit>
        <trans-unit id="7599f05bd7927f9fe0e7226e610b201a20fca5cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_init()&lt;/b&gt; is called once to initialize the backup,</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;调用一次&lt;b&gt;sqlite3_backup_init（）&lt;/b&gt;初始化备份，</target>
        </trans-unit>
        <trans-unit id="50049f9518772742b4f4d7a9638718fd332f558c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_step()&lt;/b&gt; is called one or more times to transfer the data between the two databases, and finally</source>
          <target state="translated">&lt;b&gt;sqlite3_backup_step（）&lt;/b&gt;被调用一次或多次以在两个数据库之间传输数据，最后</target>
        </trans-unit>
        <trans-unit id="36384ee5a830c16bb1e112e7d3a904e2090a6806" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_int64 (*xRowid)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_int64（* xRowid）（Fts5Context *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d84a20c3533b13fd8f3158014a02d324fdf73854" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_compileoption_get(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_compileoption_get(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f387f1d980ba1b6ac824b01c4502663c86db1b1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_compileoption_used(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_compileoption_used(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d6e44884028fa4a47b130aec37b250e2c69a0833" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_exec_printf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_exec_printf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ebcfeff700a28642ccb8dde6efb294b6168bbaf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_exec_vprintf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_exec_vprintf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3a04b66dabddcc301fcb52fd7ec612ccbabf6148" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_get_table_printf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_get_table_printf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f711405ae8eba472544d1aa5cfd209c541dc90a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_get_table_vprintf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_get_table_vprintf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8617cd19825488ab7fdd81fef2642bb7b5bd4e71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_offset(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_offset(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2efa54cd4a876a8b910e9958257c43e50054c08b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_source_id()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_source_id()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6332e2508f2d7603546d3bcc08b9be6340cd89c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_version()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_version()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="abde37706a46b7ca8874418dde8c8e57d75e9301" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;srchcnt&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;srchcnt&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="766dd6c9278d00bc9e2d900050adefb7e1ac80fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;statement&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;statement&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61469f9128c59549d8929ca8786e2516099564cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;strftime(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;strftime(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cae9927a2b3298dd39e25b370b34d3395edd5527" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e12c6d8c9e8a39f25add895e2c0bf8d194e1c45f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sum(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;total(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sum(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;total(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8a3492ae3d2a89485e206c4937164ed7d324c5a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;synchronous = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;同步= &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f085e6ee811e844fee162829f6334cdd145d4bca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;synchronous; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;同步; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f03ee139387146c590bdbb574bc081c350f09bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;table_info(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;table_info(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c6eefb15dd071e91029df39120e4adef6f09f67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;table_xinfo(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;table_xinfo(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a7146ae989b40b504ed9566df150fba27db865a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test-ex.rc&lt;/b&gt; - long-running soak tests.</source>
          <target state="translated">&lt;b&gt;test-ex.rc-&lt;/b&gt;长时间浸泡测试。</target>
        </trans-unit>
        <trans-unit id="9082bc8530887269298fa6b758b7df0103f4afb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test.rc&lt;/b&gt; - Run the same tests as in fast.rc but without compiler optimization and enabling options like &lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt; and -DSQLITE_ENABLE_EXPENSIVE_ASSERT.</source>
          <target state="translated">&lt;b&gt;test.rc-&lt;/b&gt;运行与&lt;b&gt;fast.rc&lt;/b&gt;中相同的测试，但是没有编译器优化，也没有启用&lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt;和-DSQLITE_ENABLE_EXPENSIVE_ASSERT之类的选项。</target>
        </trans-unit>
        <trans-unit id="4ec47fe06e8fa40340ac7dc1a59a81c280b08d6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;testcase(X)&lt;/b&gt; &amp;rarr; The testcase(X) statement indicates that X is sometimes true and sometimes false. In other words, testcase(X) indicates that X is definitely not an invariant. Since SQLite uses 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC/DC testing&lt;/a&gt;, the presence of a testcase(X) macro indicates that not only is it possible for X to be either true or false, but there are test cases to demonstrate this.</source>
          <target state="translated">&lt;b&gt;testcase（X）&lt;/b&gt; &amp;rarr;testcase（X）语句指示X有时为true，有时为false。换句话说，testcase（X）表示X绝对不是不变的。由于SQLite使用100％&lt;a href=&quot;testing#mcdc&quot;&gt;MC / DC测试&lt;/a&gt;，因此testcase（X）宏的存在表明X不仅可能为true或false，而且有测试用例来证明这一点。</target>
        </trans-unit>
        <trans-unit id="387747815042252f6049ab6dffd4c9e618d3c9ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;time(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;time(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="751f81cbcc6744df5561e7226f36021bf2e3af36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;top&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;top&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e24cfa079085118e42e96d2a55a37a53557cd88e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;total_changes()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;total_changes()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="542f31e075ca05fd951176f4d597451afd1125ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;trim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;trim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;trim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;trim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5adfeb6f8a74b81f3673d50c2e3be5461cb4506" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;typeof(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;typeof(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="564af250a086d4ca4862414f517487932362df50" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unicode(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;unicode(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a493d0d93cdad6d8063bb460480308af31d81af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-dotfile&lt;/b&gt; - uses dot-file locking rather than POSIX advisory locks.</source>
          <target state="translated">&lt;b&gt;unix-dotfile-&lt;/b&gt;使用点文件锁定而不是POSIX咨询锁定。</target>
        </trans-unit>
        <trans-unit id="7ee0b7222a0d2745b0960933b8554bb0b2cb0f36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-excl&lt;/b&gt; - obtains and holds an exclusive lock on database files, preventing other processes from accessing the database. Also keeps the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; in heap rather than in shared memory.</source>
          <target state="translated">&lt;b&gt;unix-excl-&lt;/b&gt;获取并持有对数据库文件的排他锁，以防止其他进程访问数据库。&lt;a href=&quot;walformat#shm&quot;&gt;还将wal-index&lt;/a&gt;保留在堆中，而不是共享内存中。</target>
        </trans-unit>
        <trans-unit id="171a40a565e91b5e38415639e5c0e1f0a1d0147f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-namedsem&lt;/b&gt; - uses named semaphores for file locking. VXWorks only.</source>
          <target state="translated">&lt;b&gt;unix-namedsem-&lt;/b&gt;使用命名信号量进行文件锁定。仅限于VXWorks。</target>
        </trans-unit>
        <trans-unit id="87aa888be05eec90be29a815beb11ebb61786bc9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-none&lt;/b&gt; - all file locking operations are no-ops.</source>
          <target state="translated">&lt;b&gt;unix-none-&lt;/b&gt;所有文件锁定操作均为无操作。</target>
        </trans-unit>
        <trans-unit id="d3e2ab215f74d535aecccce1746b0b6f8e4eee96" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unlikely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;unlikely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7abd3b06da2eeea0c8f757f2140032a74361ffdb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;upper(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;upper(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a630c6ced4b606f3e586eb856c79eca570d7b5d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;user_version = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;user_version = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25f14ee4f8a99c00c21229b1476cff5c7dcf693f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;user_version; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;user_version; &lt;br/&gt;普拉玛&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="088cf7d75ebd01b23e3aca416dca22a57dac9950" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;vfs&lt;/b&gt;: The &quot;vfs&quot; parameter may be used to specify the name of a VFS object that provides the operating system interface that should be used to access the database file on disk. If this option is set to an empty string the default VFS object is used. Specifying an unknown VFS is an error. If sqlite3_open_v2() is used and the vfs option is present, then the VFS specified by the option takes precedence over the value passed as the fourth parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;vfs&lt;/b&gt;：&amp;ldquo; vfs&amp;rdquo;参数可用于指定VFS对象的名称，该对象提供应用于访问磁盘上数据库文件的操作系统接口。如果将此选项设置为空字符串，则使用默认的VFS对象。指定未知的VFS是错误。如果使用sqlite3_open_v2（）并且存在vfs选项，则该选项指定的VFS优先于作为第四个参数传递给sqlite3_open_v2（）的值。</target>
        </trans-unit>
        <trans-unit id="2998c7ff661dc1402458997c40d904ae7019342d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;vfs=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;vfs=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6be0f1dac527f6a7a3a8b6d2e7324226055d9238" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无效（* xPhraseNext）（Fts5Context *，Fts5PhraseIter *，int * piCol，int * piOff）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bfac065939a7511e81786f4f00b434cd5618329" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无效（* xPhraseNextColumn）（Fts5Context *，Fts5PhraseIter *，int * piCol）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0f50db153cf3b9cc7e9e88b1554a9c5a044290b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void *(*xGetAuxdata)(Fts5Context*, int bClear)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无效*（* xGetAuxdata）（Fts5Context *，int bClear）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1dd96b486c80ce4df848a29698eba4d9200ba1cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void *(*xUserData)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;无效*（* xUserData）（Fts5Context *）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b126f269504e317361d82c9eb42ec77f3cb00678" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(FULL);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(FULL);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5c4d6723b1efc24a3f9e4546fac324515250a15f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(PASSIVE);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(PASSIVE);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="245179a0a4378112590955d1a1537df9f96e19d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(RESTART);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(RESTART);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf71d8462439fb51aa407e19229e4d9affee0e5f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(TRUNCATE);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(TRUNCATE);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7e49255e11543623b2c50370c1e1606794efe285" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0751bc3711d32d9aac3b755aa8669d93303b0272" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-longpath-none&lt;/b&gt; - combination of &quot;win32-longpath&quot; and &quot;win32-none&quot; - long pathnames are supported and all lock operations are no-ops.</source>
          <target state="translated">&lt;b&gt;win32-longpath-none-&lt;/b&gt; &amp;ldquo; win32-longpath&amp;rdquo;和&amp;ldquo; win32-none&amp;rdquo;的组合-支持长路径名，并且所有锁定操作均为无操作。</target>
        </trans-unit>
        <trans-unit id="4ad6725cafce35d815b8464dedebc92eb51ec573" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-longpath&lt;/b&gt; - like &quot;win32&quot; except that pathnames can be up to 65534 bytes in length, whereas pathnames max out at 1040 bytes in &quot;win32&quot;.</source>
          <target state="translated">&lt;b&gt;win32-longpath-&lt;/b&gt;类似于&amp;ldquo; win32&amp;rdquo;，除了路径名的最大长度为65534字节，而&amp;ldquo; win32&amp;rdquo;中的路径名最大为1040字节。</target>
        </trans-unit>
        <trans-unit id="beadca375c7cb43a64419f239d7bb81fa172a062" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-none&lt;/b&gt; - all file locking operations are no-ops.</source>
          <target state="translated">&lt;b&gt;win32-none-&lt;/b&gt;所有文件锁定操作均为无操作。</target>
        </trans-unit>
        <trans-unit id="c7f7df8b834c26f9670be7255e91884f981bbdf5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;word&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;word&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ef6ccfe69e2ef2274904ba1b989763fe9daed749" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xCreate:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;xCreate:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08ea35c5e28008270d3f794e11e6b29032f8b335" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(3)&lt;/b&gt; - remove value &quot;3&quot; from the window. The window now contains values 8 and 1 only.</source>
          <target state="translated">&lt;b&gt;xInverse（3）&lt;/b&gt; -从窗口中删除值&amp;ldquo; 3&amp;rdquo;。现在，该窗口仅包含值8和1。</target>
        </trans-unit>
        <trans-unit id="d06f04ca5de186ef308cf987a39acd62fa581efb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(4)&lt;/b&gt; - remove &quot;4&quot; from the window.</source>
          <target state="translated">&lt;b&gt;xInverse（4）&lt;/b&gt; -从窗口中删除&amp;ldquo; 4&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6ea3b2c9ac24752a4d124bf259358d12a4385ed1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(5)&lt;/b&gt; - remove value &quot;5&quot; from the window.</source>
          <target state="translated">&lt;b&gt;xInverse（5）&lt;/b&gt; -从窗口中删除值&amp;ldquo; 5&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c201bad931f8401061d806fb20a99e02f340ca75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(1)&lt;/b&gt; - add value &quot;1&quot; to the window.</source>
          <target state="translated">&lt;b&gt;xStep（1）&lt;/b&gt; -将值&amp;ldquo; 1&amp;rdquo;添加到窗口。</target>
        </trans-unit>
        <trans-unit id="552183d8347d4aa8b4ecd28963b82e0980c54d3f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(3)&lt;/b&gt; - add &quot;3&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep（3）&lt;/b&gt; -在当前窗口中添加&amp;ldquo; 3&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4686be269638aad4598d31d42b3f4f673d7fe4a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(4)&lt;/b&gt; - add &quot;4&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep（4）&lt;/b&gt; -在当前窗口中添加&amp;ldquo; 4&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d82113cc4bb37a3f6a26309f9a359011d7b90a67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(5)&lt;/b&gt; - add &quot;5&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep（5）&lt;/b&gt; -在当前窗口中添加&amp;ldquo; 5&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="26af953955c0fb0cb311f7c624b1676a7c454639" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(8)&lt;/b&gt; - add &quot;8&quot; to the current window. The window now consists of values 5, 3 and 8.</source>
          <target state="translated">&lt;b&gt;xStep（8）&lt;/b&gt; -在当前窗口中添加&amp;ldquo; 8&amp;rdquo;。窗口现在包含值5、3和8。</target>
        </trans-unit>
        <trans-unit id="cf072a5adae091a25691fa9f8a75085c48f93b90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoke xValue() to obtain the value of sumint() for the row with (x='a'). The window currently consists of values 4 and 5, and so the result is 9.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用xValue（）以获得具有（x ='a'）的行的sumint（）值。该窗口当前包含值4和5，因此结果为9。</target>
        </trans-unit>
        <trans-unit id="2c5dd79d383628751a86ee2ffb1fcdc34f1bd26e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoke xValue() to obtain the value of sumint() for the row with (x='b'). The window currently consists of values 4, 5 and 3, and so the result is 12.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用xValue（）以获取具有（x ='b'）的行的sumint（）值。该窗口当前包含值4、5和3，因此结果为12。</target>
        </trans-unit>
        <trans-unit id="a6e4b8f199ffe99bce9be789081aca11bd89a987" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for row (x='d').</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用以获得行（x ='d'）的值。</target>
        </trans-unit>
        <trans-unit id="1a08acb2172b97a134c2c8886902b63f79dd194d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for row (x='d'). 9.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用以获得行（x ='d'）的值。9。</target>
        </trans-unit>
        <trans-unit id="5ff710f762c530458940d685a64c42fe7d5eb730" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for the row with (x='c'). In this case, 16.</source>
          <target state="translated">&lt;b&gt;xValue（）&lt;/b&gt; -调用以获取具有（x ='c'）的行的值。在这种情况下，为16。</target>
        </trans-unit>
        <trans-unit id="c2de13f92fe4c6dae6ac8db9dacd9ccaae02dc07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;zeroblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;zeroblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9fa13734f5aacd4ab8879e00f3c9d12402784092" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Not yet implemented)&lt;/em&gt; Create indexes that might have been helpful to recent queries.</source>
          <target state="translated">&lt;em&gt;（尚未实现）&lt;/em&gt;创建可能对最近的查询有用的索引。</target>
        </trans-unit>
        <trans-unit id="b6e6228539f5984d272435f54680c919edca57b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Not yet implemented)&lt;/em&gt; Record usage and performance information from the current session in the database file so that it will be available to &quot;optimize&quot; pragmas run by future database connections.</source>
          <target state="translated">&lt;em&gt;（尚未实现）&lt;/em&gt;将当前会话的使用情况和性能信息记录在数据库文件中，以便可用于&amp;ldquo;优化&amp;rdquo;由将来的数据库连接运行的编译指示。</target>
        </trans-unit>
        <trans-unit id="6d4e8b1714f1b41237ba93ca2e5bf1b3d93408f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Making a change to the sqlite_master table like this will render the database corrupt and unreadable if the change contains a syntax error. It is suggested that careful testing of the UPDATE statement be done on a separate blank database prior to using it on a database containing important data.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;如果对sqlite_master表的更改包含语法错误，则以这种方式进行更改将使数据库损坏且不可读。建议在包含重要数据的数据库上使用UPDATE语句之前，先在单独的空白数据库上进行仔细的测试。</target>
        </trans-unit>
        <trans-unit id="51f3632551479a4241159ad77de3f62c093d8c27" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Making a change to the sqlite_schema table like this will render the database corrupt and unreadable if the change contains a syntax error. It is suggested that careful testing of the UPDATE statement be done on a separate blank database prior to using it on a database containing important data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8d8331be552f1d9886147666d4d00355995833" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Once again, making changes to the sqlite_master table like this will render the database corrupt and unreadable if the change contains an error. Carefully test this entire procedure on a separate test database prior to using it on a database containing important data and/or make backup copies of important databases prior to running this procedure.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;再次对sqlite_master表进行这样的更改，如果更改包含错误，将使数据库损坏且不可读。在运行包含此重要数据的数据库之前，请先在单独的测试数据库上仔细测试整个过程，然后再执行此过程，然后对重要数据库进行备份。</target>
        </trans-unit>
        <trans-unit id="6d6c1135084f914bbdf80a671b4bb8717b33074e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Once again, making changes to the sqlite_schema table like this will render the database corrupt and unreadable if the change contains an error. Carefully test this entire procedure on a separate test database prior to using it on a database containing important data and/or make backup copies of important databases prior to running this procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f6ba8783597d88987529bbf21585dc3045c297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nota Bene:&lt;/em&gt; In this rule, &quot;application&quot; means the code that issues SQL statements. If the &quot;application&quot; is an &lt;a href=&quot;whentouse#serversidedb&quot;&gt;application server&lt;/a&gt; and if the content resides on the same physical machine as the application server, then SQLite might still be appropriate even though the end user is another network hop away.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;在此规则中，&amp;ldquo;应用程序&amp;rdquo;表示发出SQL语句的代码。如果&amp;ldquo;应用程序&amp;rdquo;是&lt;a href=&quot;whentouse#serversidedb&quot;&gt;应用程序服务器，&lt;/a&gt;并且内容与应用程序服务器位于同一台物理计算机上，则即使最终用户离另一个网络跳远，SQLite仍可能适用。</target>
        </trans-unit>
        <trans-unit id="0a88a70f28eea7505a4745ef400e6ee503235e73" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;any&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;any&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9f86c02aa28130769f3916ecd58dfbb1c988d34" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;It is not possible to open &lt;a href=&quot;wal#readonly&quot;&gt;read-only WAL databases&lt;/a&gt;. The opening process must have write privileges for &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; shared memory file associated with the database, if that file exists, or else write access on the directory containing the database file if the &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; file does not exist.&lt;/s&gt; Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22), a read-only WAL-mode database file can be opened if the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists or those files can be created or the &lt;a href=&quot;uri#uriimmutable&quot;&gt;database is immutable&lt;/a&gt;.</source>
          <target state="translated">&lt;s&gt;无法打开&lt;a href=&quot;wal#readonly&quot;&gt;只读WAL数据库&lt;/a&gt;。开放进程必须具有写权限&amp;ldquo; &lt;code&gt;-shm&lt;/code&gt; &amp;rdquo; &lt;a href=&quot;walformat#shm&quot;&gt;WAL索引&lt;/a&gt;与数据库相关的共享内存文件，该文件是否存在，或者包含数据库文件，如果&amp;ldquo;目录其他的写访问 &lt;code&gt;-shm&lt;/code&gt; &amp;rdquo;文件不存在。&lt;/s&gt;从&lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;版本3.22.0&lt;/a&gt;（2018-01-22）开始，如果 &lt;code&gt;-shm&lt;/code&gt; 和 &lt;code&gt;-wal&lt;/code&gt; 文件已经存在或者可以创建这些文件或者&lt;a href=&quot;uri#uriimmutable&quot;&gt;数据库是不可变的，&lt;/a&gt;则可以打开只读的WAL模式数据库文件。</target>
        </trans-unit>
        <trans-unit id="4adae4e92d852fe832ed5d1eceb7319abc564534" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;The target database may not contain &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.&lt;/s&gt; Indexes on expressions are supported beginning with SQLite 3.30.0 (2019-10-04).</source>
          <target state="translated">&lt;s&gt;目标数据库可能不包含&lt;a href=&quot;expridx&quot;&gt;表达式的索引&lt;/a&gt;。&lt;/s&gt;从SQLite 3.30.0（2019-10-04）开始支持表达式索引。</target>
        </trans-unit>
        <trans-unit id="db395f459bbe4efd96a60570c6c0dc0d9de9b06f" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;WAL works best with smaller transactions. WAL does not work well for very large transactions. For transactions larger than about 100 megabytes, traditional rollback journal modes will likely be faster. For transactions in excess of a gigabyte, WAL mode may fail with an I/O or disk-full error. It is recommended that one of the rollback journal modes be used for transactions larger than a few dozen megabytes.&lt;/s&gt; Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), WAL mode works as efficiently with large transactions as does rollback mode.</source>
          <target state="translated">&lt;s&gt;WAL最适合较小的交易。WAL不适用于非常大的交易。对于大于约100 MB的事务，传统的回滚日志记录模式可能会更快。对于超过1 GB的事务，WAL模式可能会因I / O或磁盘已满错误而失败。建议将回滚日志模式之一用于大于几十兆字节的事务。&lt;/s&gt;从&lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;版本3.11.0&lt;/a&gt;（2016-02-15）开始，WAL模式与回滚模式一样有效地处理大型事务。</target>
        </trans-unit>
        <trans-unit id="89e3d94a9d9f3be8c533f30cf505fbbc9e619b12" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;count_changes&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;count_changes&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="2fe7dcf40a505cee3d2c9c220b0b032b337985ba" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;data_store_directory&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;data_store_directory&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="529e4c95946d239f6f7340a28f8c19b836131c18" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;default_cache_size&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;default_cache_size&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="1e40be7959fdcb27f689b1bd4b4c13f00f9648e7" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;empty_result_callbacks&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;empty_result_callbacks&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="37b8e45b75945b9a2ed1c6840780034aeaa96def" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;full_column_names&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;full_column_names&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="7ba50a54ae872e46e392d945fcfe8882528f779d" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;short_column_names&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;short_column_names&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="5cf9a92ecc51fe417c6554bfdf564ab70b6793e5" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_aggregate_count&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_aggregate_count&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="e04a1191ffe57ae4dc80fdf0b0d1302374a5223c" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_expired&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_expired&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="d4ae465dac3d471fb929f18f6459bc6fcd0ad5ac" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_global_recover&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_global_recover&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="c152f165bf4d682834190453559ca4079d4e3e8f" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_memory_alarm&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_memory_alarm&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="213d566c65b6e979c0b12b5cb2c6d769f7e68036" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_soft_heap_limit&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_soft_heap_limit&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="650653e2136ca438507f86226e9dd600546df2c7" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_thread_cleanup&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_thread_cleanup&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="9810cb85410d21ed25bad43b513e5d44434fc79b" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_transfer_bindings&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_transfer_bindings&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="c56e6ca2d9c7c42057a3d4b7225bd064062059b2" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;temp_store_directory&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;temp_store_directory&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="156219115afff08d45c71a04e60351afa6d72952" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; An R*Tree index does not normally provide the exact answer but merely reduces the set of potential answers from millions to dozens.</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt; R * Tree索引通常不提供确切答案，而只是将潜在答案的集合从数百万个减少到数十个。</target>
        </trans-unit>
        <trans-unit id="6049fd8bb72e0e6f1e8d8a417d9fe8b5a790ff5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Changes to compile-time options have the potential to affect makefiles in projects that do customized builds of SQLite. These changes should have zero impact on application code and for most projects which use a standard, default build of SQLite.</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt;更改编译时选项可能会影响执行定制SQLite构建的项目中的makefile。这些更改将对应用程序代码以及大多数使用标准默认SQLite构建的项目产生零影响。</target>
        </trans-unit>
        <trans-unit id="8fe0585022e152f67097fdd4ed2411a232e49da4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The change to the way NULL values are handled by the IN and NOT IN operators is technically a bug fix, not a design change. However, maintainers should check to ensure that applications do not depend on the older, buggy behavior prior to upgrading to version 3.6.0.</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt;更改IN和NOT IN运算符处理NULL值的方式从技术上讲是一个错误修复，而不是设计更改。但是，维护人员应检查以确保应用程序在升级到3.6.0版之前不依赖较旧的错误行为。</target>
        </trans-unit>
        <trans-unit id="ac582c2b4e7dacb497b4397bfa98eb62970fbb75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The incompatible changes in the SQLite operating-system interface for version 3.6.0 only affect the rare applications that make use of the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface or that supply an application-defined &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex implementation&lt;/a&gt; or that make use of other obscure compile-time options. The changes introduced by SQLite version 3.6.0 will have zero impact on the vast majority of SQLite applications that use the built-in interfaces to Unix, Windows, and OS/2 and that use the standard build configuration.</source>
          <target state="translated">&lt;strong&gt;重点：&lt;/strong&gt;版本3.6.0的SQLite操作系统接口中的不兼容更改仅影响使用&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;接口或提供应用程序定义的&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;互斥体实现&lt;/a&gt;或使用其他晦涩的编译功能的罕见应用程序- 时间选项。SQLite 3.6.0版引入的更改将对绝大多数使用Unix，Windows和OS / 2的内置接口并使用标准构建配置的SQLite应用程序产生零影响。</target>
        </trans-unit>
        <trans-unit id="fcc0502f968c401bb51d275b3d308a8f8dcc412b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Points:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="e3be666c416d3eeb09cb76c7b7abf3ac3e2ab55d" translate="yes" xml:space="preserve">
          <source>=0).</source>
          <target state="translated">=0).</target>
        </trans-unit>
        <trans-unit id="0f8eebb6cdfbace0c569728246016f04641f12f9" translate="yes" xml:space="preserve">
          <source>=1 and</source>
          <target state="translated">= 1并且</target>
        </trans-unit>
        <trans-unit id="5bab61eb53176449e25c2c82f172b82cb13ffb9d" translate="yes" xml:space="preserve">
          <source>?</source>
          <target state="translated">?</target>
        </trans-unit>
        <trans-unit id="3611d993bcfe075143e56843e7c942308dbe016c" translate="yes" xml:space="preserve">
          <source>?NNN</source>
          <target state="translated">?NNN</target>
        </trans-unit>
        <trans-unit id="1a2a6f3e69a4dab4720c5d9a3aae1f202d725e39" translate="yes" xml:space="preserve">
          <source>@VVV</source>
          <target state="translated">@VVV</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="83c828fc11c0e93226c89266f2e8a91c52ebb360" translate="yes" xml:space="preserve">
          <source>A &quot;CREATE TABLE ... AS SELECT&quot; statement creates and populates a database table based on the results of a SELECT statement. The table has the same number of columns as the rows returned by the SELECT statement. The name of each column is the same as the name of the corresponding column in the result set of the SELECT statement. The declared type of each column is determined by the &lt;a href=&quot;datatype3#expraff&quot;&gt;expression affinity&lt;/a&gt; of the corresponding expression in the result set of the SELECT statement, as follows:</source>
          <target state="translated">&amp;ldquo; CREATE TABLE ... AS SELECT&amp;rdquo;语句根据SELECT语句的结果创建并填充数据库表。该表的列数与SELECT语句返回的行数相同。每列的名称与SELECT语句的结果集中相应列的名称相同。每列的声明类型由SELECT语句的结果集中相应表达式的&lt;a href=&quot;datatype3#expraff&quot;&gt;表达式亲和力&lt;/a&gt;确定，如下所示：</target>
        </trans-unit>
        <trans-unit id="1591a1617a12bcdebc03ff048dd0aaab529e900a" translate="yes" xml:space="preserve">
          <source>A &quot;long int&quot; or &quot;long unsigned int&quot;. Also 32-bits on all modern systems.</source>
          <target state="translated">一个 &quot;long int &quot;或 &quot;long unsigned int&quot;。在所有现代系统上也是32位。</target>
        </trans-unit>
        <trans-unit id="7f3cd818abaaa9a0e6005a308275969363d99be5" translate="yes" xml:space="preserve">
          <source>A &quot;long long int&quot; or &quot;long long unsigned&quot; or an &quot;sqlite3_int64&quot; or &quot;sqlite3_uint64&quot; value. These are 64-bit integers on all modern systems.</source>
          <target state="translated">一个 &quot;long long int &quot;或 &quot;long long unsigned &quot;或 &quot;sqlite3_int64 &quot;或 &quot;sqlite3_uint64 &quot;的值。在所有现代系统中,这些都是64位整数。</target>
        </trans-unit>
        <trans-unit id="7f83dc95438f0748d2d21836359d9d250a9cf519" translate="yes" xml:space="preserve">
          <source>A &quot;row value&quot; is an ordered list of two or more scalar values. In other words, a &quot;row value&quot; is a vector.</source>
          <target state="translated">一个 &quot;行值 &quot;是两个或多个标量值的有序列表。换句话说,&quot;行值 &quot;是一个向量。</target>
        </trans-unit>
        <trans-unit id="283fddadbd97aab80b3f5c004c94712b610008ef" translate="yes" xml:space="preserve">
          <source>A &quot;rowid table&quot; is any table in an SQLite schema that</source>
          <target state="translated">一个 &quot;rowid表 &quot;是指在SQLite模式中的任何表,该表的功能是</target>
        </trans-unit>
        <trans-unit id="82ef35610d000dac934111c06adc58ba665e4eea" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; is a single number, string, BLOB or NULL. Sometimes the qualified name &quot;scalar value&quot; is used to emphasize that only a single quantity is involved.</source>
          <target state="translated">一个 &quot;值 &quot;是一个单一的数字、字符串、BLOB或NULL。有时使用限定名称 &quot;标量值 &quot;来强调只涉及一个数量。</target>
        </trans-unit>
        <trans-unit id="e595cea14982c806deb1a68df267f727d390b83d" translate="yes" xml:space="preserve">
          <source>A &quot;variable&quot; or &quot;parameter&quot; token specifies a placeholder in the expression for a value that is filled in at runtime using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; family of C/C++ interfaces. Parameters can take several forms:</source>
          <target state="translated">&amp;ldquo;变量&amp;rdquo;或&amp;ldquo;参数&amp;rdquo;标记在表达式中为占位符指定一个值，该值在运行时使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;系列C / C ++接口填充。参数可以采用几种形式：</target>
        </trans-unit>
        <trans-unit id="0650b7b535494da46a67e89f0076bd1eb000f596" translate="yes" xml:space="preserve">
          <source>A 4-byte big-endian integer page number for the first page of the overflow page list - omitted if all payload fits on the b-tree page.</source>
          <target state="translated">溢出页列表的第一页的4字节大英文整数页号--如果所有有效载荷都适合在b-tree页上,则省略。</target>
        </trans-unit>
        <trans-unit id="457dd24244954b2ed62ddd2400a48d0f00613b7e" translate="yes" xml:space="preserve">
          <source>A 4-byte big-endian page number which is the left child pointer.</source>
          <target state="translated">一个4字节的大字段页码,是左边的子指针。</target>
        </trans-unit>
        <trans-unit id="40fcda7469ad59852cc6bee2078ffd2e27a37099" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;datatype3#collation&quot;&gt;collating function&lt;/a&gt; for each column is necessary in order to compute the order of text fields. SQLite defines three built-in collating functions:</source>
          <target state="translated">甲&lt;a href=&quot;datatype3#collation&quot;&gt;核对函数&lt;/a&gt;为每一列是必要的，以便计算文本字段的顺序。SQLite定义了三个内置的整理功能：</target>
        </trans-unit>
        <trans-unit id="0941f09d0d99d3f4e14cafccc32de96df6f4ca23" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; means to rewind the WAL and start adding new frames at the beginning. This occurs while appending new frames to a WAL that has &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; equal to &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and which has no locks on WAL_READ_LOCK(1) through WAL_READ_LOCK(4). The WAL_WRITE_LOCK is held.</source>
          <target state="translated">一个&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL复位&lt;/a&gt;手段倒带WAL开始之初添加新的帧。在将新帧附加到&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;等于&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;并且在WAL_READ_LOCK（1）到WAL_READ_LOCK（4）上没有锁的WAL时，会发生这种情况。WAL_WRITE_LOCK被保持。</target>
        </trans-unit>
        <trans-unit id="d00aa28b4ba172b3e360c196f89dfcfc325f153e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; interface</source>
          <target state="translated">一个&lt;a href=&quot;fts3&quot;&gt;全文检索&lt;/a&gt;界面</target>
        </trans-unit>
        <trans-unit id="27fbe703a2a9d7026510938d0ef6d0e90ee4db6f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.sqlite.org/src/info/80ba201079&quot;&gt;very obscure bug&lt;/a&gt; associated with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;or optimization&lt;/a&gt; was fixed.</source>
          <target state="translated">与&lt;a href=&quot;optoverview#or_opt&quot;&gt;或优化&lt;/a&gt;相关的&lt;a href=&quot;http://www.sqlite.org/src/info/80ba201079&quot;&gt;非常模糊的错误&lt;/a&gt;已修复。</target>
        </trans-unit>
        <trans-unit id="8c246c5420b674d2441ed9c3d37319384c74b2e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; command operates the same whether or not &lt;a href=&quot;foreignkeys#fk_enable&quot;&gt;foreign key constraints are enabled&lt;/a&gt;. The parent key definitions of foreign key constraints are not checked when a table is created. There is nothing stopping the user from creating a foreign key definition that refers to a parent table that does not exist, or to parent key columns that do not exist or are not collectively bound by a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="translated">一个&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;命令操作相同与否&lt;a href=&quot;foreignkeys#fk_enable&quot;&gt;外键约束已启用&lt;/a&gt;。创建表时，不检查外键约束的父键定义。没有什么可以阻止用户创建一个外键定义，该外键定义引用一个不存在的父表，或者引用一个不存在的父键列，或者不由PRIMARY KEY或UNIQUE约束共同绑定的父键列。</target>
        </trans-unit>
        <trans-unit id="0e29b640b6e66681a005ec711b53b3e91c43098d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; may now reference undefined tables and functions when initially created. Missing tables and functions are reported when the VIEW is used in a query.</source>
          <target state="translated">甲&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;现在可以参考未定义表和函数最初创建时。在查询中使用VIEW时，将报告缺少的表和函数。</target>
        </trans-unit>
        <trans-unit id="84a46b4de837835c04612d05bdcd4565ff372f5f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoint&lt;/a&gt; transaction may be RELEASEd while the database is in a state that does not satisfy a deferred foreign key constraint. A transaction savepoint (a non-nested savepoint that was opened while there was not currently an open transaction), on the other hand, is subject to the same restrictions as a COMMIT - attempting to RELEASE it while the database is in such a state will fail.</source>
          <target state="translated">一个&lt;a href=&quot;lang_savepoint&quot;&gt;嵌套的保存点&lt;/a&gt;，而数据库是在不满足延期外键约束的状态事务可能被释放。另一方面，事务保存点（当前没有打开的事务时打开的非嵌套保存点）受与COMMIT相同的限制-在数据库处于这种状态时尝试释放它失败。</target>
        </trans-unit>
        <trans-unit id="5ac241bd5950cee76dd1c229b208c7ae5eeaa8f2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement enclosed in parentheses is a subquery. All types of SELECT statement, including aggregate and compound SELECT queries (queries with keywords like UNION or EXCEPT) are allowed as scalar subqueries. The value of a subquery expression is the first row of the result from the enclosed &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The value of a subquery expression is NULL if the enclosed &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement returns no rows.</source>
          <target state="translated">一个&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;括号括起来的语句是一个子查询。包括聚合查询和复合SELECT查询（带有UNION或EXCEPT之类的关键字的查询）在内的所有类型的SELECT语句都可以用作标量子查询。子查询表达式的值是附带的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句的结果的第一行。如果附带的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句不返回任何行，则子查询表达式的值为NULL 。</target>
        </trans-unit>
        <trans-unit id="20f43c4aca8f02e6e0cae74a1bfed1c05ee2754b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement used as either a scalar subquery or as the right-hand operand of an IN, NOT IN or EXISTS expression may contain references to columns in the outer query. Such a subquery is known as a correlated subquery. A correlated subquery is reevaluated each time its result is required. An uncorrelated subquery is evaluated only once and the result reused as necessary.</source>
          <target state="translated">甲&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句用作一个标量子查询或作为右边的操作数的IN的，NOT IN或EXISTS表达可以包含在外部查询到列的引用。这样的子查询被称为相关子查询。每当需要其结果时，都会重新评估相关的子查询。不相关的子查询仅被评估一次，结果将根据需要重新使用。</target>
        </trans-unit>
        <trans-unit id="024807a5ea9e932cf26bbf315bdeb3b063751ec8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause can be the first element in a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; that uses a &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause, but a &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; that consists of just a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause cannot be preceded by a &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause.</source>
          <target state="translated">甲&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;子句可以是在第一个元素&lt;a href=&quot;lang_select#compound&quot;&gt;化合物选择&lt;/a&gt;一种使用&lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt;子句，但一个&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单的SELECT&lt;/a&gt;，它由只是一个&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;子句不能由前面&lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt;子句。</target>
        </trans-unit>
        <trans-unit id="df491b521dc505e42bc3c6ecd099baa148547e6b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; can also be used to search and sort at the same time. Consider the following:</source>
          <target state="translated">一个&lt;a href=&quot;queryplanner#covidx&quot;&gt;覆盖索引&lt;/a&gt;也可用于在同一时间搜索和整理。考虑以下：</target>
        </trans-unit>
        <trans-unit id="871606b16605f413dc5599aac71b78fa3849a872" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; is an interface to an external storage or computation engine that appears to be a table but does not actually store information in the database file.</source>
          <target state="translated">一个&lt;a href=&quot;vtab&quot;&gt;虚表&lt;/a&gt;是，似乎是一个表，但实际上并不在数据库中存储文件信息的外部存储或计算引擎的接口。</target>
        </trans-unit>
        <trans-unit id="df4e6c14456215b9d0962cb62cb7b05235ec1b11" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; is an object that presents an SQL table interface but which is not stored in the database file, at least not directly. The virtual table mechanism is a feature of SQLite that allows SQLite to access and manipulate resources other than bits in the database file using the powerful SQL query language.</source>
          <target state="translated">甲&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;是一个对象，呈现SQL表接口，但没有存储在数据库中的文件，至少不能直接。虚拟表机制是SQLite的一项功能，它允许SQLite使用强大的SQL查询语言访问和操纵数据库文件中除位以外的资源。</target>
        </trans-unit>
        <trans-unit id="68d8302bde332ff69849e87aae361fdd6eed88bd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that contains &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; can be used like a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; in the FROM clause. The arguments to the table-valued function become constraints on the HIDDEN columns of the virtual table. Additional information can be found in the &lt;a href=&quot;vtab#tabfunc2&quot;&gt;virtual table documentation&lt;/a&gt;.</source>
          <target state="translated">甲&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;包含&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏的列&lt;/a&gt;可用于像一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;在FROM子句。表值函数的参数成为对虚拟表的HIDDEN列的约束。可以在&lt;a href=&quot;vtab#tabfunc2&quot;&gt;虚拟表文档中&lt;/a&gt;找到其他信息。</target>
        </trans-unit>
        <trans-unit id="d9a4d2f7abc06c64a3d373982c1067a695d076ac" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that contains &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; can be used like a table-valued function in the FROM clause of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The arguments to the table-valued function become constraints on the HIDDEN columns of the virtual table.</source>
          <target state="translated">一个&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;，其中包含&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏的列&lt;/a&gt;可用于像在从子句表值函数&lt;a href=&quot;lang_select&quot;&gt;的SELECT&lt;/a&gt;语句。表值函数的参数成为对虚拟表的HIDDEN列的约束。</target>
        </trans-unit>
        <trans-unit id="6f54a772ec3e29fda7795793266725eca1b672c5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; containing one row for each &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; associated with an open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，其中每个与打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备语句&lt;/a&gt;都包含一行。</target>
        </trans-unit>
        <trans-unit id="856349bba241130042131d7b4885683066e751c5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; for decomposing a JSON string.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数，&lt;/a&gt;用于分解JSON字符串。</target>
        </trans-unit>
        <trans-unit id="0582a0885ca700a90a04a8eff4c47df7102e8b08" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; returning a sequence of increasing integers, modeled after the table-valued function by the same name in PostgreSQL.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;返回一个递增的整数序列，该表值函数在表值函数之后以PostgreSQL中的相同名称建模。</target>
        </trans-unit>
        <trans-unit id="cb2741cf2cdf7ad64ce11cd345c855b98d1f85eb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; returning one row for each file in a selected file hierarchy of the host computer. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to help implement the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，为主机选择的文件层次结构中的每个文件返回一行。通过使用&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;帮助实施&lt;a href=&quot;cli#sqlar&quot;&gt;.ARCHIVE命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="373d830be5eb15d2da2a61288dc21f7719b3437c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; that allows a C-language array of integers, doubles, or strings to be used as table in a query.</source>
          <target state="translated">一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，允许将C，整数，双精度或字符串数​​组用作查询中的表。</target>
        </trans-unit>
        <trans-unit id="c7e525a231144d654e7b02c354858c4739a1f24e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; which, in combination with a co-packaged &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; provides information on the number of system calls performed by SQLite.</source>
          <target state="translated">甲&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，其在具有共同封装的组合&lt;a href=&quot;vfs#shim&quot;&gt;VFS垫片&lt;/a&gt;提供了关于由SQLite的执行系统调用的次数的信息。</target>
        </trans-unit>
        <trans-unit id="1b6d070d5ecc711101d38eeaab3df0bef09ff2fd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; consists of a header followed by zero or more &quot;frames&quot;. Each frame records the revised content of a single page from the database file. All changes to the database are recorded by writing frames into the WAL. Transactions commit when a frame is written that contains a commit marker. A single WAL can and usually does record multiple transactions. Periodically, the content of the WAL is transferred back into the database file in an operation called a &quot;checkpoint&quot;.</source>
          <target state="translated">甲&lt;a href=&quot;wal#walfile&quot;&gt;WAL文件&lt;/a&gt;由一个标题，随后是零个或多个&amp;ldquo;帧&amp;rdquo;。每个框架记录数据库文件中单个页面的修订内容。通过将帧写入WAL记录对数据库的所有更改。写入包含提交标记的框架时，事务将提交。单个WAL可以并且通常确实记录多个事务。周期性地，WAL的内容通过称为&amp;ldquo;检查点&amp;rdquo;的操作被传输回数据库文件。</target>
        </trans-unit>
        <trans-unit id="0a26bbd25ee7f100819f3c23deb01a412e2b8ae6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;&lt;i&gt;clean page&lt;/i&gt;&lt;/b&gt; is one for which the cached data currently matches the contents of the corresponding page of the database file. The page has not been modified since it was loaded from the file.</source>
          <target state="translated">一个&lt;b&gt;&lt;i&gt;干净的页面&lt;/i&gt;&lt;/b&gt;是为其缓存的数据当前数据库文件的相应页面的内容相匹配。由于页面是从文件加载的，因此尚未修改。</target>
        </trans-unit>
        <trans-unit id="3149daa49a57f043076bca55d34c79bbf2a94c10" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;&lt;i&gt;dirty page&lt;/i&gt;&lt;/b&gt; is a</source>
          <target state="translated">一个&lt;b&gt;&lt;i&gt;脏页&lt;/i&gt;&lt;/b&gt;是一个</target>
        </trans-unit>
        <trans-unit id="a631580fd38df6770ba8186e0d9bd01ddb2b0586" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;CHECK&lt;/b&gt; constraint may be attached to a column definition or specified as a table constraint. In practice it makes no difference. Each time a new row is inserted into the table or an existing row is updated, the expression associated with each CHECK constraint is evaluated and cast to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. If the result is zero (integer value 0 or real value 0.0), then a constraint violation has occurred. If the CHECK expression evaluates to NULL, or any other non-zero value, it is not a constraint violation. The expression of a CHECK constraint may not contain a subquery.</source>
          <target state="translated">甲&lt;b&gt;CHECK&lt;/b&gt;约束可以被附接到一列定义或指定为表约束。实际上，这没有什么区别。每次将新行插入表中或更新现有行时，都会评估与每个CHECK约束关联的表达式，并将其转换为NUMERIC值，方法与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;相同。如果结果为零（整数值0或实数值0.0），则发生约束冲突。如果CHECK表达式的计算结果为NULL或任何其他非零值，则不是约束冲突。CHECK约束的表达式可能不包含子查询。</target>
        </trans-unit>
        <trans-unit id="b22b413028503aa499aa22dd5a425b910c462c65" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DELETE&lt;/b&gt;. A DELETE change represents a row, identified by its primary key values, to remove from a database table. The payload of a DELETE change consists of the values for all fields of the deleted row.</source>
          <target state="translated">一个&lt;b&gt;DELETE&lt;/b&gt;。DELETE更改表示由其主键值标识的要从数据库表中删除的行。DELETE更改的有效负载由已删除行的所有字段的值组成。</target>
        </trans-unit>
        <trans-unit id="dc432bfd116ade86c9a957fa16cdde115d0191b7" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;NOT NULL&lt;/b&gt; constraint may only be attached to a column definition, not specified as a table constraint. Not surprisingly, a NOT NULL constraint dictates that the associated column may not contain a NULL value. Attempting to set the column value to NULL when inserting a new row or updating an existing one causes a constraint violation.</source>
          <target state="translated">甲&lt;b&gt;NOT NULL&lt;/b&gt;约束可以仅被连接到一个列定义，没有被指定为表约束。毫不奇怪，NOT NULL约束指示关联的列可能不包含NULL值。在插入新行或更新现有行时尝试将列值设置为NULL会导致约束冲突。</target>
        </trans-unit>
        <trans-unit id="fdf1ca3328f33f13bfd67487e1be34ff9035a3f1" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;UNIQUE&lt;/b&gt; constraint is similar to a PRIMARY KEY constraint, except that a single table may have any number of UNIQUE constraints. For each UNIQUE constraint on the table, each row must contain a unique combination of values in the columns identified by the UNIQUE constraint. For the purposes of UNIQUE constraints, NULL values are considered distinct from all other values, including other NULLs. As with PRIMARY KEYs, a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; is not supported.</source>
          <target state="translated">甲&lt;b&gt;UNIQUE&lt;/b&gt;约束类似于PRIMARY KEY约束，不同的是一个单一的表可以具有任意数量的UNIQUE约束。对于表上的每个UNIQUE约束，每一行都必须在由UNIQUE约束标识的列中包含值的唯一组合。出于UNIQUE约束的目的，NULL值被认为与所有其他值（包括其他NULL）不同。与PRIMARY KEYs一样，UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;子句必须仅包含列名- 不支持在UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;的&lt;a href=&quot;syntax/indexed-column&quot;&gt;索引列&lt;/a&gt;中使用表达式。</target>
        </trans-unit>
        <trans-unit id="e32809ac84c6935c3f1d547f445c33b4edd8239b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;configuration option&lt;/b&gt; consists of an FTS5 bareword - the option name - followed by an &quot;=&quot; character, followed by the option value. The option value is specified using either a single FTS5 bareword or a string literal, again quoted in any manner acceptable to the SQLite core. For example:</source>
          <target state="translated">甲&lt;b&gt;配置选项&lt;/b&gt;包括一个FTS5裸词的-选项名称-后跟一个&amp;ldquo;=&amp;rdquo;字符，接着是选项值。使用单个FTS5裸字或字符串文字（通过SQLite核心可接受的任何方式再次引用）指定选项值。例如：</target>
        </trans-unit>
        <trans-unit id="a32195c7a6fc427bc8287dc1bfc7fa1047963781" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;delete file&lt;/b&gt; operation (invoked by a call to the VFS xDelete() method) is assumed to be an atomic and durable operation.</source>
          <target state="translated">甲&lt;b&gt;删除文件&lt;/b&gt;操作（通过向VFS xDelete（）方法的调用被调用）被假定为是一个原子和耐用操作。</target>
        </trans-unit>
        <trans-unit id="81eb114ea2af4078474a1cbfc4dcbef58bf150be" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;write file&lt;/b&gt; operation modifies the contents of an existing file within the file-system. It may also increase the size of the file. The effects of a</source>
          <target state="translated">甲&lt;b&gt;写文件&lt;/b&gt;操作修改所述文件系统内的现有文件的内容。它还可能会增加文件的大小。一个的影响</target>
        </trans-unit>
        <trans-unit id="837ab313b69fffe66bfeb6474a06eb42c1252970" translate="yes" xml:space="preserve">
          <source>A BLOB referenced by sqlite3_blob_open() may be read using the &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface and modified by using &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; can be moved to a different row of the same table using the &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. However, the column, table, or database of a &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; cannot be changed after the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is opened.</source>
          <target state="translated">通过sqlite3_blob_open引用的BLOB（）可以使用被读&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口，并通过使用改性&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（） &lt;/a&gt;。可以使用&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;接口将&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;移到同一表的另一行。但是，打开&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;后，不能更改&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;的列，表或数据库。</target>
        </trans-unit>
        <trans-unit id="ee0640d0645ccd75a4dc327263af24976feba6da" translate="yes" xml:space="preserve">
          <source>A BLOB referenced by sqlite3_blob_open() may be read using the &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface and modified by using &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;. The &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; can be moved to a different row of the same table using the &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. However, the column, table, or database of a &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; cannot be changed after the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is opened.</source>
          <target state="translated">通过sqlite3_blob_open引用的BLOB（）可以使用被读&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口，并通过使用改性&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（） &lt;/a&gt;。可以使用&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;接口将&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;移到同一表的另一行。但是，打开&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;后，不能更改&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;的列，表或数据库。</target>
        </trans-unit>
        <trans-unit id="13017a10bf35a23815a31249ff53b230bf8d7de4" translate="yes" xml:space="preserve">
          <source>A C99 compiler such as GCC (including MinGW variants for Windows), Clang, or MSVC</source>
          <target state="translated">C99编译器,如GCC(包括Windows的MinGW变体)、Clang或MSVC。</target>
        </trans-unit>
        <trans-unit id="e474401c2fb781e6f6b3a595d076e4ab1e391bd7" translate="yes" xml:space="preserve">
          <source>A CASE expression serves a role similar to IF-THEN-ELSE in other programming languages.</source>
          <target state="translated">CASE表达式的作用类似于其他编程语言中的IF-THEN-ELSE。</target>
        </trans-unit>
        <trans-unit id="6efc18580100345c76fd2798e95f8e107ce315e6" translate="yes" xml:space="preserve">
          <source>A CAST expression of the form &quot;CAST(</source>
          <target state="translated">CAST表达式为 &quot;CAST(</target>
        </trans-unit>
        <trans-unit id="691cb52a8521a0ce5d8225252c59ceffa19ac6f9" translate="yes" xml:space="preserve">
          <source>A CHECK constraint may be attached to a column definition or specified as a table constraint. In practice it makes no difference. Each time a new row is inserted into the table or an existing row is updated, the expression associated with each CHECK constraint is evaluated and cast to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. If the result is zero (integer value 0 or real value 0.0), then a constraint violation has occurred. If the CHECK expression evaluates to NULL, or any other non-zero value, it is not a constraint violation. The expression of a CHECK constraint may not contain a subquery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31c615e2a94e5252f4b80b762cba6c0141f5cde" translate="yes" xml:space="preserve">
          <source>A COLLATE operator has the same affinity as its left-hand side operand.</source>
          <target state="translated">COLLATE运算符与它的左手操作数具有相同的亲和力。</target>
        </trans-unit>
        <trans-unit id="636b65c339e5b4cff4c6abf3acf46d5d5c4067ad" translate="yes" xml:space="preserve">
          <source>A Frame object (Used by &lt;a href=&quot;opcode#subprog&quot;&gt;subprograms&lt;/a&gt; - see &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt;)</source>
          <target state="translated">一个Frame对象（由&lt;a href=&quot;opcode#subprog&quot;&gt;子程序使用&lt;/a&gt; -请参见&lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5dd1dbb7ef5708d18278d3388bedd2577e0b3815" translate="yes" xml:space="preserve">
          <source>A Handle To An Open BLOB</source>
          <target state="translated">一个打开BLOB的手柄</target>
        </trans-unit>
        <trans-unit id="5c5c40156ee6de3eca7fbc6151e6b7fa931030d3" translate="yes" xml:space="preserve">
          <source>A NOT NULL constraint may only be attached to a column definition, not specified as a table constraint. Not surprisingly, a NOT NULL constraint dictates that the associated column may not contain a NULL value. Attempting to set the column value to NULL when inserting a new row or updating an existing one causes a constraint violation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3401d49e10d9d0dae1ba0bfad0af249daa8b1e6a" translate="yes" xml:space="preserve">
          <source>A NULL result is considered untrue when evaluating WHEN terms.</source>
          <target state="translated">当评估WHEN术语时,NULL结果被认为是不真实的。</target>
        </trans-unit>
        <trans-unit id="f6e08d53bb50141ecc1637476fc883985d9f9ebb" translate="yes" xml:space="preserve">
          <source>A NULL value</source>
          <target state="translated">一个NULL值</target>
        </trans-unit>
        <trans-unit id="bffde3dc2b5165819167f5c21c867d724ac37b28" translate="yes" xml:space="preserve">
          <source>A NULL value is not changed by this routine. It remains NULL.</source>
          <target state="translated">NULL值不会被这个例程改变。它将保持为NULL。</target>
        </trans-unit>
        <trans-unit id="e254962b9e0cb1aea3bfd54acadf87214effe474" translate="yes" xml:space="preserve">
          <source>A PENDING lock means that the process holding the lock wants to write to the database as soon as possible and is just waiting on all current SHARED locks to clear so that it can get an EXCLUSIVE lock. No new SHARED locks are permitted against the database if a PENDING lock is active, though existing SHARED locks are allowed to continue.</source>
          <target state="translated">PENDING锁意味着持有该锁的进程希望尽快向数据库写入数据,只是在等待所有当前的SHARED锁清空,以便得到一个EXCLUSIVE锁。如果PENDING锁处于活动状态,则不允许对数据库产生新的SHARED锁,不过允许现有的SHARED锁继续存在。</target>
        </trans-unit>
        <trans-unit id="792513b3669ee7042166df65b3b518052dfec139" translate="yes" xml:space="preserve">
          <source>A RESERVED lock means that the process is planning on writing to the database file at some point in the future but that it is currently just reading from the file. Only a single RESERVED lock may be active at one time, though multiple SHARED locks can coexist with a single RESERVED lock. RESERVED differs from PENDING in that new SHARED locks can be acquired while there is a RESERVED lock.</source>
          <target state="translated">一个RESERVED锁意味着进程计划在未来的某个时刻向数据库文件写入,但目前只是从文件中读取。在同一时间内只能有一个RESERVED锁处于活动状态,尽管多个SHARED锁可以与一个RESERVED锁共存。RESERVED与PENDING的不同之处在于,在有RESERVED锁的情况下,可以获取新的SHARED锁。</target>
        </trans-unit>
        <trans-unit id="b7573b1578e511f894b8024c7cc3d97b302451de" translate="yes" xml:space="preserve">
          <source>A RowSet object (See the &lt;a href=&quot;opcode#RowSetAdd&quot;&gt;RowSetAdd&lt;/a&gt;, &lt;a href=&quot;opcode#RowSetRead&quot;&gt;RowSetRead&lt;/a&gt;, and &lt;a href=&quot;opcode#RowSetTest&quot;&gt;RowSetTest&lt;/a&gt; opcodes)</source>
          <target state="translated">RowSet对象（请参见&lt;a href=&quot;opcode#RowSetAdd&quot;&gt;RowSetAdd&lt;/a&gt;，&lt;a href=&quot;opcode#RowSetRead&quot;&gt;RowSetRead&lt;/a&gt;和&lt;a href=&quot;opcode#RowSetTest&quot;&gt;RowSetTest&lt;/a&gt;操作码）</target>
        </trans-unit>
        <trans-unit id="7145fed841f2e927e89061340853d861304c9e1a" translate="yes" xml:space="preserve">
          <source>A Slightly More Complex Query</source>
          <target state="translated">稍微复杂一点的查询</target>
        </trans-unit>
        <trans-unit id="be9ffde27510374ea69b59f34f53d3d90e8acc69" translate="yes" xml:space="preserve">
          <source>A TEXT value is less than a BLOB value. When two TEXT values are compared an appropriate collating sequence is used to determine the result.</source>
          <target state="translated">一个TEXT值小于一个BLOB值。当两个TEXT值进行比较时,会使用适当的整理序列来确定结果。</target>
        </trans-unit>
        <trans-unit id="46f405c1f7939c335f90c63056ef77e55a911955" translate="yes" xml:space="preserve">
          <source>A Template For SELECT Programs</source>
          <target state="translated">SELECT程序模板</target>
        </trans-unit>
        <trans-unit id="d9fc87b4657ba9032bc3c9439eec37292a4b8792" translate="yes" xml:space="preserve">
          <source>A UNIQUE constraint is similar to a PRIMARY KEY constraint, except that a single table may have any number of UNIQUE constraints. For each UNIQUE constraint on the table, each row must contain a unique combination of values in the columns identified by the UNIQUE constraint. For the purposes of UNIQUE constraints, NULL values are considered distinct from all other values, including other NULLs. As with PRIMARY KEYs, a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a236f9f7962be97b127c37048fd412e1478ca675" translate="yes" xml:space="preserve">
          <source>A URI filename can optionally be followed by a query string. The query string consists of text following the first &quot;&lt;code&gt;?&lt;/code&gt;&quot; character but excluding the optional fragment that begins with &quot;&lt;code&gt;#&lt;/code&gt;&quot;. The query string is divided into key/value pairs. We usually refer to these key/value pairs as &quot;query parameters&quot;. Key/value pairs are separated by a single &quot;&lt;code&gt;&amp;amp;&lt;/code&gt;&quot; character. The key comes first and is separated from the value by a single &quot;&lt;code&gt;=&lt;/code&gt;&quot; character. Both key and value may contain &lt;b&gt;%HH&lt;/b&gt; escape sequences.</source>
          <target state="translated">URI文件名可以选择后面跟一个查询字符串。查询字符串由第一个&amp;ldquo; &lt;code&gt;?&lt;/code&gt; &amp;rdquo;字符后的文本组成，但不包括以&amp;ldquo; &lt;code&gt;#&lt;/code&gt; &amp;rdquo; 开头的可选片段。查询字符串分为键/值对。我们通常将这些键/值对称为&amp;ldquo;查询参数&amp;rdquo;。键/值对由单个&amp;ldquo; &lt;code&gt;&amp;amp;&lt;/code&gt; &amp;rdquo;字符分隔。该键位于第一个位置，并且与值之间用单个&amp;ldquo; &lt;code&gt;=&lt;/code&gt; &amp;rdquo;字符分隔。键和值都可以包含&lt;b&gt;％HH&lt;/b&gt;转义序列。</target>
        </trans-unit>
        <trans-unit id="99cb44555e9b0216321b2979e33a8e1ad8600bba" translate="yes" xml:space="preserve">
          <source>A UTF-16 byte-order-mark (BOM) is embedded at the beginning of an SQL string literal value inserted into an FTS3 table. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b929656e7ccea842d99a6cdd674c24cfe9ebde24" translate="yes" xml:space="preserve">
          <source>A VACUUM will fail if there is an open transaction on the database connection that is attempting to run the VACUUM. Unfinalized SQL statements typically hold a read transaction open, so the VACUUM might fail if there are unfinalized SQL statements on the same connection. VACUUM (but not VACUUM INTO) is a write operation and so if another database connection is holding a lock that prevents writes, then the VACUUM will fail.</source>
          <target state="translated">如果在试图运行VACUUM的数据库连接上有一个开放的事务,那么VACUUM将失败。未最终确定的SQL语句通常会打开一个读事务,所以如果在同一个连接上有未最终确定的SQL语句,那么VACUUM可能会失败。VACUUM(但不是VACUUM INTO)是一个写操作,所以如果另一个数据库连接持有一个阻止写的锁,那么VACUUM将失败。</target>
        </trans-unit>
        <trans-unit id="4b3d695cfd113fe761861c75383b2e044c2e7e2b" translate="yes" xml:space="preserve">
          <source>A VALUES clause cannot be followed by &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;.</source>
          <target state="translated">VALUES子句后不能跟&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ab21b8d4d0b0af0b5e16d3d9e8b9adc5cafa097" translate="yes" xml:space="preserve">
          <source>A VALUES clause cannot be followed by &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;.</source>
          <target state="translated">VALUES子句不能跟在&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY之后&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05d95a064571927a9a88c570d25a1e13033bf432" translate="yes" xml:space="preserve">
          <source>A VDBE program begins execution on instruction 0 and continues with successive instructions until it either (1) encounters a fatal error, (2) executes a Halt instruction, or (3) advances the program counter past the last instruction of the program. When the VDBE completes execution, all open database cursors are closed, all memory is freed, and everything is popped from the stack. So there are never any worries about memory leaks or undeallocated resources.</source>
          <target state="translated">VDBE程序从指令0开始执行,并继续执行连续的指令,直到(1)遇到致命错误,(2)执行Halt指令,或(3)将程序计数器推进到程序的最后一条指令之后。当VDBE完成执行后,所有打开的数据库游标都被关闭,所有的内存都被释放,所有的东西都从堆栈中弹出。因此,永远不会担心内存泄漏或未分配资源的问题。</target>
        </trans-unit>
        <trans-unit id="0432168769d5fe51afb6dbaedceaf1d86ce22932" translate="yes" xml:space="preserve">
          <source>A VFS object is an instance of the following structure:</source>
          <target state="translated">一个VFS对象是以下结构的实例。</target>
        </trans-unit>
        <trans-unit id="ebb27bb2698737a1c139441a44f3243078e096d2" translate="yes" xml:space="preserve">
          <source>A WHERE-clause term that uses the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator can sometimes be used with an index to do a range search, almost as if the LIKE or GLOB were an alternative to a &lt;a href=&quot;lang_expr#between&quot;&gt;BETWEEN&lt;/a&gt; operator. There are many conditions on this optimization:</source>
          <target state="translated">有时可以将使用&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的WHERE子句与索引一起使用以进行范围搜索，几乎就像LIKE或GLOB是&lt;a href=&quot;lang_expr#between&quot;&gt;BETWEEN&lt;/a&gt;运算符的替代方法一样。此优化有很多条件：</target>
        </trans-unit>
        <trans-unit id="df4f80b113ccea127e4d3021f3a4f02819b934ae" translate="yes" xml:space="preserve">
          <source>A WITH clause can contain ordinary common table expressions even if it includes the RECURSIVE keyword. The use of RECURSIVE does not force common table expressions to be recursive.</source>
          <target state="translated">一个WITH子句即使包含RECURSIVE关键字,也可以包含普通的普通表表达式。RECURSIVE的使用并不强制普通表表达式是递归的。</target>
        </trans-unit>
        <trans-unit id="f55340617c249beb5aa9dcbec3b3a452cd918cec" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table is a table that uses a &lt;a href=&quot;https://en.wikipedia.org/wiki/Database_index#Clustered&quot;&gt;Clustered Index&lt;/a&gt; as the primary key.</source>
          <target state="translated">WITHOUT ROWID表是使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Database_index#Clustered&quot;&gt;聚簇索引&lt;/a&gt;作为主键的表。</target>
        </trans-unit>
        <trans-unit id="fd8fd2213389a0089cdcbfb615d2045c57a83ef1" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table is an optimization that can reduce storage and processing requirements.</source>
          <target state="translated">WITHOUT ROWID表是一种优化,可以减少存储和处理需求。</target>
        </trans-unit>
        <trans-unit id="bfd83295099a678d051eac126141e86eda45f403" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table uses a different data design for the equivalent table.</source>
          <target state="translated">WITHOUT ROWID表对等价表采用不同的数据设计。</target>
        </trans-unit>
        <trans-unit id="cd77ad55fd4a01dbb8f0524dc072785f80da4f86" translate="yes" xml:space="preserve">
          <source>A ZIP archive appears to be a database containing a single table with the following schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8671aa0f63652c459215ac815d19beddc15e8e03" translate="yes" xml:space="preserve">
          <source>A ZIP archive is basically a key/value database, optimized for the case of write-once/read-many and for a relatively small number of distinct keys (a few hundred to a few thousand) each with a large BLOB as its value. A ZIP archive can be viewed as a &quot;pile-of-files&quot; database. This works, but it has some shortcomings relative to an SQLite database, as follows:</source>
          <target state="translated">一个ZIP归档基本上是一个键/值数据库,针对写一次/读多次的情况进行了优化,并且针对相对较少的不同键(几百到几千),每个键都有一个大的BLOB作为其值。一个ZIP归档文件可以被看作是一个 &quot;文件堆 &quot;数据库。这样做是可行的,但相对于SQLite数据库来说,它有一些不足之处,具体如下。</target>
        </trans-unit>
        <trans-unit id="31b75515041a194398c4ef9c7f4df42ebbf1ae1c" translate="yes" xml:space="preserve">
          <source>A b-tree page</source>
          <target state="translated">一个b-tree页面</target>
        </trans-unit>
        <trans-unit id="78e4a5662f4ab95c05c9b1089cf8d552e985bac1" translate="yes" xml:space="preserve">
          <source>A b-tree page is divided into regions in the following order:</source>
          <target state="translated">一个b-tree页面按以下顺序分为几个区域。</target>
        </trans-unit>
        <trans-unit id="50e24d6d35682efd44eaa4aca8795ead18d76998" translate="yes" xml:space="preserve">
          <source>A b-tree page is either a table b-tree page or an index b-tree page. All pages within each complete b-tree are of the same type: either table or index. There is one table b-trees in the database file for each rowid table in the database schema, including system tables such as &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;. There is one index b-tree in the database file for each index in the schema, including implied indexes created by uniqueness constraints. There are no b-trees associated with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Specific virtual table implementations might make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; for storage, but those shadow tables will have separate entries in the database schema. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables use index b-trees rather than a table b-trees, so there is one index b-tree in the database file for each &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The b-tree corresponding to the sqlite_schema table is always a table b-tree and always has a root page of 1. The sqlite_schema table contains the root page number for every other table and index in the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a9edcac9a730619e0cfe51d4bfd7d8720cb6a9" translate="yes" xml:space="preserve">
          <source>A b-tree page is either a table b-tree page or an index b-tree page. All pages within each complete b-tree are of the same type: either table or index. There is one table b-trees in the database file for each rowid table in the database schema, including system tables such as sqlite_master. There is one index b-tree in the database file for each index in the schema, including implied indexes created by uniqueness constraints. There are no b-trees associated with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Specific virtual table implementations might make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; for storage, but those shadow tables will have separate entries in the database schema. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables use index b-trees rather than a table b-trees, so there is one index b-tree in the database file for each &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The b-tree corresponding to the sqlite_master table is always a table b-tree and always has a root page of 1. The sqlite_master table contains the root page number for every other table and index in the database file.</source>
          <target state="translated">b树页面是表b树页面或索引b树页面。每个完整b树中的所有页面都属于同一类型：表或索引。数据库文件中数据库模式中的每个rowid表（包括系统表，例如sqlite_master）都有一个表b树。在数据库文件中，对于模式中的每个索引都有一个索引b树，包括由唯一性约束创建的隐式索引。没有与&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;关联的b树。特定的虚拟表实现可能使用&lt;a href=&quot;vtab#xshadowname&quot;&gt;影子表&lt;/a&gt;进行存储，但是这些影子表在数据库架构中将具有单独的条目。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表使用索引b树而不是表b树，因此在数据库文件中每个索引树都有一个索引b树。&lt;a href=&quot;withoutrowid&quot;&gt;没有ROWID&lt;/a&gt;表。与sqlite_master表相对应的b树始终是表b树，并且始终具有1的根页。sqlite_master表包含数据库文件中所有其他表和索引的根页号。</target>
        </trans-unit>
        <trans-unit id="e8872d8050defbccbb334917b38d2ca8e1564dc7" translate="yes" xml:space="preserve">
          <source>A b-tree page is either an interior page or a leaf page. A leaf page contains keys and in the case of a table b-tree each key has associated data. An interior page contains K keys together with K+1 pointers to child b-tree pages. A &quot;pointer&quot; in an interior b-tree page is just the 31-bit integer page number of the child page.</source>
          <target state="translated">一个b树页是内页或叶页。叶页包含键,在表b树的情况下,每个键有相关的数据。一个内部页包含K个键以及K+1个指向子b树页的指针。内部b树页中的 &quot;指针 &quot;只是子页的31位整数页号。</target>
        </trans-unit>
        <trans-unit id="3cfdea8b36cb23cd0493dd048fd3164b70e3686a" translate="yes" xml:space="preserve">
          <source>A b-tree root page. The page number should be zero.</source>
          <target state="translated">一个b树根页面。页码应该是零。</target>
        </trans-unit>
        <trans-unit id="928af6fa4be08c1c19873c470bbd5a2625ae1f46" translate="yes" xml:space="preserve">
          <source>A better user experience</source>
          <target state="translated">更好的用户体验</target>
        </trans-unit>
        <trans-unit id="e7bff53ba8dac51c9265761e2c2a4ff11158671e" translate="yes" xml:space="preserve">
          <source>A bug in SQLite versions prior to 3.6.0 (2008-07-16) caused the database to be reported as corrupt if any of the last 6 entries in the freelist trunk page array contained non-zero values. Newer versions of SQLite do not have this problem. However, newer versions of SQLite still avoid using the last six entries in the freelist trunk page array in order that database files created by newer versions of SQLite can be read by older versions of SQLite.</source>
          <target state="translated">在3.6.0(2008-07-16)之前的SQLite版本中,如果freelist trunk页数组中的最后6个条目中的任何一个都包含非零值,则会导致数据库被报告为损坏。较新版本的SQLite不会出现这个问题。但是,新版本的SQLite仍然避免使用freelist trunk页数组中的最后6个条目,以便旧版本的SQLite能够读取新版本的SQLite创建的数据库文件。</target>
        </trans-unit>
        <trans-unit id="89c8d4cd9f6ee835f0aa8d6326cf3bfa8b9da543" translate="yes" xml:space="preserve">
          <source>A build of the &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; requires three source files:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;命令行界面的&lt;/a&gt;构建需要三个源文件：</target>
        </trans-unit>
        <trans-unit id="df3827a0612890cae9712a71ec1095000e1430ec" translate="yes" xml:space="preserve">
          <source>A busy handler must not close the database connection or &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that invoked the busy handler.</source>
          <target state="translated">繁忙处理程序不得关闭调用繁忙处理程序的数据库连接或&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3ac4c495afe83c385509d9e3c6a5a309fa36de0" translate="yes" xml:space="preserve">
          <source>A busy handler must not close the database connection or &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that invoked the busy handler.</source>
          <target state="translated">繁忙处理程序不得关闭调用繁忙处理程序的数据库连接或&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="243759da16d869bd57d5e12d61c35e1be1f805d8" translate="yes" xml:space="preserve">
          <source>A bytecoded program in SQLite consists of one or more instructions. Each instruction has an opcode and five operands named P1, P2 P3, P4, and P5. The P1, P2, and P3 operands are 32-bit signed integers. These operands often refer to registers. For instructions that operate on b-tree cursors, the P1 operand is usually the cursor number. For jump instructions, P2 is usually the jump destination. P4 may be a 32-bit signed integer, a 64-bit signed integer, a 64-bit floating point value, a string literal, a Blob literal, a pointer to a collating sequence comparison function, or a pointer to the implementation of an application-defined SQL function, or various other things. P5 is an 16-bit unsigned integer normally used to hold flags. Bits of the P5 flag can sometimes affect the opcode in subtle ways. For example, if the SQLITE_NULLEQ (0x0080) bit of the P5 operand is set on the &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; opcode, then the NULL values compare equal to one another. Otherwise NULL values compare different from one another.</source>
          <target state="translated">SQLite中的字节编码程序由一个或多个指令组成。每个指令都有一个操作码和五个名为P1，P2，P3，P4和P5的操作数。 P1，P2和P3操作数是32位带符号整数。这些操作数通常引用寄存器。对于对b树游标进行操作的指令，P1操作数通常是游标编号。对于跳转指令，P2通常是跳转目标。 P4可以是32位带符号整数，64位带符号整数，64位浮点值，字符串文字，Blob文字，指向整理序列比较功能的指针或指向实现的指针。应用程序定义的SQL函数或其他各种东西。 P5是16位无符号整数，通常用于保存标志。 P5标志的位有时会以微妙的方式影响操作码。例如，如果P5操作数的SQLITE_NULLEQ（0x0080）位设置为&lt;a href=&quot;opcode#Eq&quot;&gt;式&lt;/a&gt;操作码，则NULL值比较彼此相等。否则，NULL值彼此比较不同。</target>
        </trans-unit>
        <trans-unit id="af46994da07ef61f25c2f526b23c9597924b8bf6" translate="yes" xml:space="preserve">
          <source>A cache spill causes the lock on the database file to escalate from reserved to exclusive. This reduces concurrency. A cache spill also causes extra disk flush or fsync operations to occur and these operations are slow, hence a cache spill can seriously reduce performance. For these reasons a cache spill is avoided whenever possible.</source>
          <target state="translated">缓存溢出会导致数据库文件上的锁从保留升级到独占。这降低了并发性。缓存溢出也会导致额外的磁盘刷新或fsync操作发生,这些操作很慢,因此缓存溢出会严重降低性能。基于这些原因,尽可能避免缓存溢出。</target>
        </trans-unit>
        <trans-unit id="952fa12450de75899de19565202a5c251a96a2d4" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; will fail if the database connection D does not know that the database file for schema S is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. A database connection might not know that the database file is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; if there has been no prior I/O on that database connection, or if the database entered &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; after the most recent I/O on the database connection. (Hint: Run &quot;&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;&quot; against a newly opened database connection in order to make it ready to use snapshots.)</source>
          <target state="translated">如果数据库连接D不知道模式S的数据库文件处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;，则&lt;/a&gt;对sqlite3_snapshot_open（D，S，P）的调用将失败。如果该数据库连接上没有先前的I / O，或者数据库在数据库连接上的最新I / O之后进入&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;，则数据库连接可能不知道该数据库文件处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;。（提示：针对新打开的数据库连接运行&amp;ldquo; &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; &amp;rdquo;，以使其准备好使用快照。）</target>
        </trans-unit>
        <trans-unit id="bbce2a7d14e5d524aa34fd10caef37f64f6407da" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; will fail if the database connection D does not know that the database file for schema S is in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. A database connection might not know that the database file is in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; if there has been no prior I/O on that database connection, or if the database entered &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; after the most recent I/O on the database connection. (Hint: Run &quot;&lt;a href=&quot;../pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;&quot; against a newly opened database connection in order to make it ready to use snapshots.)</source>
          <target state="translated">如果数据库连接D不知道模式S的数据库文件处于&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;&lt;a href=&quot;snapshot_open&quot;&gt;，则&lt;/a&gt;对sqlite3_snapshot_open（D，S，P）的调用将失败。如果该数据库连接上没有先前的I / O，或者数据库在数据库连接上的最新I / O之后进入&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;，则数据库连接可能不知道该数据库文件处于&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;。（提示：针对新打开的数据库连接运行&amp;ldquo; &lt;a href=&quot;../pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; &amp;rdquo;，以使其准备好使用快照。）</target>
        </trans-unit>
        <trans-unit id="0586f982e4b86cf9914eab1aee68b8462d61681f" translate="yes" xml:space="preserve">
          <source>A call to one of the above APIs creates a new SQL function named by the second parameter (zQueryFunc or zGeom). When that SQL function appears on the right-hand side of the MATCH operator and the left-hand side of the MATCH operator is any column in the R*Tree virtual table, then the callback defined by the third argument (xQueryFunc or xGeom) is invoked to determine if a particular object or subtree overlaps the desired region.</source>
          <target state="translated">对上述API之一的调用会创建一个由第二个参数(zQueryFunc或zGeom)命名的新SQL函数。当该SQL函数出现在MATCH操作符的右侧,而MATCH操作符的左侧是R*Tree虚拟表中的任意列时,就会调用第三个参数(xQueryFunc或xGeom)定义的回调,以确定特定对象或子树是否与所需区域重叠。</target>
        </trans-unit>
        <trans-unit id="c0c9d57a6c7577d82ae5958b8d5845cbdeb488ef" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_backup_init() will fail, returning NULL, if there is already a read or read-write transaction open on the destination database.</source>
          <target state="translated">如果目标数据库上已经打开了一个读写事务,那么对sqlite3_backup_init()的调用就会失败,返回NULL。</target>
        </trans-unit>
        <trans-unit id="4f76c2f91f4bc291282ba8411c90b19f5effe501" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_initialize() is an &quot;effective&quot; call if it is the first time sqlite3_initialize() is invoked during the lifetime of the process, or if it is the first time sqlite3_initialize() is invoked following a call to sqlite3_shutdown(). Only an effective call of sqlite3_initialize() does any initialization. All other calls are harmless no-ops.</source>
          <target state="translated">如果一个对sqlite3_initialize()的调用是在进程的生命周期内第一次调用sqlite3_initialize(),或者是在调用sqlite3_shutdown()之后第一次调用sqlite3_initialize(),那么这个调用就是一个 &quot;有效 &quot;调用。只有对sqlite3_initialize()的有效调用才会进行任何初始化。所有其他的调用都是无害的。</target>
        </trans-unit>
        <trans-unit id="f8e50509528b4aaa1911d41bfa12097644542f6c" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_serialize(D,S,P,F) might return NULL even if the SQLITE_SERIALIZE_NOCOPY bit is omitted from argument F if a memory allocation error occurs.</source>
          <target state="translated">如果发生内存分配错误,即使参数F中省略了SQLITE_SERIALIZE_NOCOPY位,对sqlite3_serialize(D,S,P,F)的调用也可能返回NULL。</target>
        </trans-unit>
        <trans-unit id="9f09c1e84942a3f4e19f6efa6988346dd1bf454a" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_shutdown() is an &quot;effective&quot; call if it is the first call to sqlite3_shutdown() since the last sqlite3_initialize(). Only an effective call to sqlite3_shutdown() does any deinitialization. All other valid calls to sqlite3_shutdown() are harmless no-ops.</source>
          <target state="translated">如果一个对sqlite3_shutdown()的调用是自上次sqlite3_initialize()之后第一次调用sqlite3_shutdown(),那么它就是一个 &quot;有效 &quot;的调用。只有对sqlite3_shutdown()的有效调用才会进行去初始化。所有其他对sqlite3_shutdown()的有效调用都是无害的无操作。</target>
        </trans-unit>
        <trans-unit id="99d86897005e13370bf2940a7d68c4f6212b3540" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_snapshot_open() will fail to open if the specified snapshot has been overwritten by a &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. In this case SQLITE_ERROR_SNAPSHOT is returned.</source>
          <target state="translated">如果指定的快照已被&lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;覆盖，则对sqlite3_snapshot_open（）的调用将无法打开。在这种情况下，将返回SQLITE_ERROR_SNAPSHOT。</target>
        </trans-unit>
        <trans-unit id="b123d9394215fb466274e78d5f37dcb5d1971345" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_snapshot_open() will fail to open if the specified snapshot has been overwritten by a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. In this case SQLITE_ERROR_SNAPSHOT is returned.</source>
          <target state="translated">如果指定的快照已被&lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;覆盖，则对sqlite3_snapshot_open（）的调用将无法打开。在这种情况下，将返回SQLITE_ERROR_SNAPSHOT。</target>
        </trans-unit>
        <trans-unit id="83087efdcf0ff814df49782ed7673c5bb32e0d3c" translate="yes" xml:space="preserve">
          <source>A call to this method always follows a prior call to &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; and &lt;a href=&quot;vtab#xsync&quot;&gt;xSync&lt;/a&gt;.</source>
          <target state="translated">始终在先前调用&lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;和&lt;a href=&quot;vtab#xsync&quot;&gt;xSync&lt;/a&gt;之后调用此方法。</target>
        </trans-unit>
        <trans-unit id="53bba7422e25acf22029d539a9c3e869ba9eebb8" translate="yes" xml:space="preserve">
          <source>A call to this method always follows a prior call to &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;.</source>
          <target state="translated">始终在先前调用&lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;之后调用此方法。</target>
        </trans-unit>
        <trans-unit id="63823dedf5b482128e2d0cda7c31f9b2e6a816fd" translate="yes" xml:space="preserve">
          <source>A call to this routine stores N bytes of randomness into buffer P. The P parameter can be a NULL pointer.</source>
          <target state="translated">调用这个例程可以将N个字节的随机性存储到缓冲区P中,P参数可以是一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="67b22fa4e435ba9bc17d0619fd2c72b0454f69b7" translate="yes" xml:space="preserve">
          <source>A cast of a REAL value into an INTEGER results in the integer between the REAL value and zero that is closest to the REAL value. If a REAL is greater than the greatest possible signed integer (+9223372036854775807) then the result is the greatest possible signed integer and if the REAL is less than the least possible signed integer (-9223372036854775808) then the result is the least possible signed integer.</source>
          <target state="translated">将REAL值投向INTEGER的结果是REAL值和零之间最接近REAL值的整数。如果REAL大于最大可能的有符号整数(+9223372036854775807),那么结果就是最大可能的有符号整数,如果REAL小于最小可能的有符号整数(-9223372036854775808),那么结果就是最小可能的有符号整数。</target>
        </trans-unit>
        <trans-unit id="e33e1dcf808eee9d2baa613dd62fa64f94613f9b" translate="yes" xml:space="preserve">
          <source>A changegroup is an object used to combine two or more &lt;a href=&quot;../sessionintro#changeset&quot;&gt;changesets&lt;/a&gt; or &lt;a href=&quot;../sessionintro#changeset&quot;&gt;patchsets&lt;/a&gt;</source>
          <target state="translated">变更组是用于组合两个或多个&lt;a href=&quot;../sessionintro#changeset&quot;&gt;变更集&lt;/a&gt;或&lt;a href=&quot;../sessionintro#changeset&quot;&gt;补丁集的对象&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75339bffdc37dce20eb97a829cfa5c7aa288c842" translate="yes" xml:space="preserve">
          <source>A changegroup is an object used to combine two or more &lt;a href=&quot;sessionintro#changeset&quot;&gt;changesets&lt;/a&gt; or &lt;a href=&quot;sessionintro#changeset&quot;&gt;patchsets&lt;/a&gt;</source>
          <target state="translated">变更组是用于组合两个或多个&lt;a href=&quot;sessionintro#changeset&quot;&gt;变更集&lt;/a&gt;或&lt;a href=&quot;sessionintro#changeset&quot;&gt;补丁集的对象&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a455c489be5e742a9b6a79c8fd17fd21034f9a" translate="yes" xml:space="preserve">
          <source>A changeset blob is extracted from the session object using a call to &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; (or, if using patchsets, a call to the &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; function).</source>
          <target state="translated">使用对&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;的调用（或者，如果使用补丁集，则对&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;函数的调用）从会话对象中提取变更集blob 。</target>
        </trans-unit>
        <trans-unit id="bca7cd75094117285613d3c27e6356cf37002d9b" translate="yes" xml:space="preserve">
          <source>A changeset consists of zero or more INSERT, UPDATE and/or DELETE changes, each representing a change to a single row of an attached table. An INSERT change contains the values of each field of a new database row. A DELETE contains the original values of each field of a deleted database row. An UPDATE change contains the original values of each field of an updated database row along with the updated values for each updated non-primary-key column. It is not possible for an UPDATE change to represent a change that modifies the values of primary key columns. If such a change is made, it is represented in a changeset as a DELETE followed by an INSERT.</source>
          <target state="translated">一个变更集由零个或多个INSERT、UPDATE和/或DELETE变更组成,每一个变更都代表对所附表的单行的变更。一个INSERT变更包含一个新数据库行的每个字段的值。DELETE包含了被删除的数据库行的每个字段的原始值。UPDATE更改包含更新数据库行的每个字段的原始值,以及每个更新的非主键列的更新值。UPDATE变更不可能表示修改主键列的值的变更。如果做了这样的改变,它在改变集中表示为一个DELETE,然后是一个INSERT。</target>
        </trans-unit>
        <trans-unit id="5b70e5afa0d3f4c5cf0dce236c8276c0465659ed" translate="yes" xml:space="preserve">
          <source>A changeset may be &quot;inverted&quot; using the &lt;a href=&quot;session/sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; API function. An inverted changeset undoes the changes made by the original. If changeset C&lt;sup&gt;+&lt;/sup&gt; is the inverse of changeset C, then applying C and then C&lt;sup&gt;+&lt;/sup&gt; to a database should leave the database unchanged.</source>
          <target state="translated">可以使用&lt;a href=&quot;session/sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert（）&lt;/a&gt; API函数&amp;ldquo;反转&amp;rdquo;变更集。反向变更集会撤消原始变更集。如果变更集C &lt;sup&gt;+&lt;/sup&gt;是变更集C 的逆，那么对数据库应用C然后再对数据库C &lt;sup&gt;+&lt;/sup&gt;应该会使数据库保持不变。</target>
        </trans-unit>
        <trans-unit id="9f32575cd3ae2a269f162fb8c8c71eb2f8f6d374" translate="yes" xml:space="preserve">
          <source>A checkpoint need not run to completion. It might be that some readers are still using older transactions with data that is contained in the database file. In that case, transferring content for newer transactions from the WAL file into the database would delete the content out from under readers still using the older transactions. To avoid that, checkpoints only run to completion if all reader are using the last transaction in the WAL.</source>
          <target state="translated">检查点不需要运行到完成。可能有些读者仍在使用数据库文件中包含的数据的旧事务。在这种情况下,将较新事务的内容从WAL文件中转移到数据库中,就会将仍在使用旧事务的读者的内容删除。为了避免这种情况,只有当所有读者都在使用WAL中的最后一个事务时,检查点才会运行到完成。</target>
        </trans-unit>
        <trans-unit id="c4b3764489da6b52009c87b8c15206abcd48df46" translate="yes" xml:space="preserve">
          <source>A checkpoint operation takes content from the WAL file and transfers it back into the original database file. A checkpoint can run concurrently with readers, however the checkpoint must stop when it reaches a page in the WAL that is past the end mark of any current reader. The checkpoint has to stop at that point because otherwise it might overwrite part of the database file that the reader is actively using. The checkpoint remembers (in the wal-index) how far it got and will resume transferring content from the WAL to the database from where it left off on the next invocation.</source>
          <target state="translated">检查点操作从WAL文件中提取内容并将其传输回原始数据库文件。一个检查点可以和阅读器同时运行,但是当检查点到达WAL中的一个页面时,必须停止,这个页面已经超过了当前任何阅读器的结束标记。检查点必须在这一点上停止,因为否则它可能会覆盖读者正在使用的数据库文件的一部分。检查点会记住(在wal-index中)它走了多远,并且会在下一次调用时从它离开的地方继续将内容从WAL传送到数据库。</target>
        </trans-unit>
        <trans-unit id="b96f1bd57862e095f823ff7f46e3b31f9d401ec4" translate="yes" xml:space="preserve">
          <source>A checksum over bytes 0 through 39 of this header.</source>
          <target state="translated">该头的0到39字节的校验和。</target>
        </trans-unit>
        <trans-unit id="65d66abdb2f9e568e194d84301cc7c1defdf138c" translate="yes" xml:space="preserve">
          <source>A co-routine is like a subroutine in that it runs in the same thread as the caller and eventually returns control back to the caller. The difference is that a co-routine also has the ability to return before it has finished, and then resume where it left off the next time it is called.</source>
          <target state="translated">协同程序就像子程序一样,它与调用者在同一个线程中运行,并最终将控制权返回给调用者。不同的是,协程还可以在完成之前返回,然后在下一次调用时继续执行。</target>
        </trans-unit>
        <trans-unit id="a3446ddc5c2704f78e209be503e073dd5871e32d" translate="yes" xml:space="preserve">
          <source>A collating sequence is implemented as a function that takes the two strings being compared as inputs and returns negative, zero, or positive if the first string is less than, equal to, or greater than the second. SQLite 3.0 comes with a single built-in collating sequence named &quot;BINARY&quot; which is implemented using the memcmp() routine from the standard C library. The BINARY collating sequence works well for English text. For other languages or locales, alternative collating sequences may be preferred.</source>
          <target state="translated">整理序列是作为一个函数来实现的,它将两个被比较的字符串作为输入,如果第一个字符串小于、等于或大于第二个字符串,则返回负数、零或正数。SQLite 3.0内置了一个名为 &quot;BINARY &quot;的整理序列,它是通过标准C库中的memcmp()例程实现的。BINARY整理序列对于英文文本效果很好。对于其他语言或地区,可能更倾向于使用其他整理序列。</target>
        </trans-unit>
        <trans-unit id="99502ad72180308e0c6e1dcbcacfcd00577dfed1" translate="yes" xml:space="preserve">
          <source>A collating sequence is just a defined order for text. When SQLite 3.0 sorts (or uses a comparison operator like &quot;&amp;lt;&quot; or &quot;&amp;gt;=&quot;) the sort order is first determined by the data type.</source>
          <target state="translated">整理顺序只是文本的已定义顺序。当SQLite 3.0排序（或使用比较运算符，例如&amp;ldquo; &amp;lt;&amp;rdquo;或&amp;ldquo;&amp;gt; =&amp;rdquo;）时，排序顺序首先由数据类型确定。</target>
        </trans-unit>
        <trans-unit id="5f87dfb8e180544c52ac50b7d5f03687e7a73db7" translate="yes" xml:space="preserve">
          <source>A column name can be any of the names defined in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement or one of the following special identifiers: &quot;&lt;b&gt;ROWID&lt;/b&gt;&quot;, &quot;&lt;b&gt;OID&lt;/b&gt;&quot;, or &quot;&lt;b&gt;_ROWID_&lt;/b&gt;&quot;. The three special identifiers describe the unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) associated with every row of every table and so are not available on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The special identifiers only refer to the row key if the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement does not define a real column with the same name. The rowid can be used anywhere a regular column can be used.</source>
          <target state="translated">列名可以是&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中定义的任何名称，也可以是以下特殊标识符之一：&amp;ldquo; &lt;b&gt;ROWID&lt;/b&gt; &amp;rdquo;，&amp;ldquo; &lt;b&gt;OID&lt;/b&gt; &amp;rdquo;或&amp;ldquo; &lt;b&gt;_ROWID_&lt;/b&gt; &amp;rdquo;。这三个特殊标识符描述了与每个表的每一行关联的唯一整数键（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;），因此在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中不可用。如果&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句未定义具有相同名称的实列，则特殊标识符仅引用行键。 rowid可以在可以使用常规列的任何地方使用。</target>
        </trans-unit>
        <trans-unit id="5b67ef6e85463cb42541d756505c5b2ae3565809" translate="yes" xml:space="preserve">
          <source>A column that includes a GENERATED ALWAY AS clause is a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;. Generated columns are supported beginning with SQLite verison 3.31.0 (2020-01-22). See the &lt;a href=&quot;gencol&quot;&gt;separate documentation&lt;/a&gt; for details on the capabilities and limitations of generated columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f5bfc838f715cc006584587792787f6b98f6d0" translate="yes" xml:space="preserve">
          <source>A column that uses INTEGER affinity behaves the same as a column with NUMERIC affinity. The difference between INTEGER and NUMERIC affinity is only evident in a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;.</source>
          <target state="translated">使用INTEGER关联的列的行为与具有NUMERIC关联的列的行为相同。INTEGER和NUMERIC亲和力之间的区别仅在&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达中&lt;/a&gt;才明显。</target>
        </trans-unit>
        <trans-unit id="7bec05409618ea12efea321b6ffb50468bbd6938" translate="yes" xml:space="preserve">
          <source>A column with NUMERIC affinity may contain values using all five storage classes. When text data is inserted into a NUMERIC column, the storage class of the text is converted to INTEGER or REAL (in order of preference) if such conversion is lossless and reversible. For conversions between TEXT and REAL storage classes, SQLite considers the conversion to be lossless and reversible if the first 15 significant decimal digits of the number are preserved. If the lossless conversion of TEXT to INTEGER or REAL is not possible then the value is stored using the TEXT storage class. No attempt is made to convert NULL or BLOB values.</source>
          <target state="translated">具有NUMERIC亲和力的列可以包含使用所有五个存储类别的值。当文本数据被插入到NUMERIC列中时,如果这种转换是无损和可逆的,那么文本的存储类将被转换为INTEGER或REAL(按优先级排序)。对于TEXT和REAL存储类之间的转换,如果保留了数字的前15位有意义的小数位,SQLite认为这种转换是无损和可逆的。如果TEXT到INTEGER或REAL的无损转换是不可能的,那么该值将使用TEXT存储类存储。不尝试转换NULL或BLOB值。</target>
        </trans-unit>
        <trans-unit id="67992ebe6149e17ea7cdb1cdfe8c4235d6887281" translate="yes" xml:space="preserve">
          <source>A column with NUMERIC affinity may contain values using all five storage classes. When text data is inserted into a NUMERIC column, the storage class of the text is converted to INTEGER or REAL (in order of preference) if the text is a well-formed integer or real literal, respectively. If the TEXT value is a well-formed integer literal that is too large to fit in a 64-bit signed integer, it is converted to REAL. For conversions between TEXT and REAL storage classes, only the first 15 significant decimal digits of the number are preserved. If the TEXT value is not a well-formed integer or real literal, then the value is stored as TEXT. For the purposes of this paragraph, hexadecimal integer literals are not considered well-formed and are stored as TEXT. (This is done for historical compatibility with versions of SQLite prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_6.html&quot;&gt;version 3.8.6&lt;/a&gt; 2014-08-15 where hexadecimal integer literals were first introduced into SQLite.) No attempt is made to convert NULL or BLOB values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636834272fe49a104c8b0f637d91fe89b1a7c34e" translate="yes" xml:space="preserve">
          <source>A column with REAL affinity behaves like a column with NUMERIC affinity except that it forces integer values into floating point representation. (As an internal optimization, small floating point values with no fractional component and stored in columns with REAL affinity are written to disk as integers in order to take up less space and are automatically converted back into floating point as the value is read out. This optimization is completely invisible at the SQL level and can only be detected by examining the raw bits of the database file.)</source>
          <target state="translated">具有REAL亲和力的列的行为与具有NUMERIC亲和力的列类似,只是它将整数值强制转换成浮点表示。(作为一种内部优化,存储在具有REAL亲和力的列中的没有小数部分的小浮点值被作为整数写入磁盘,以减少占用空间,并在读出该值时自动转换回浮点。这种优化在SQL层面是完全看不到的,只能通过检查数据库文件的原始位来检测)。)</target>
        </trans-unit>
        <trans-unit id="e5c849785a5191658d60300de8d49f0749c36fe5" translate="yes" xml:space="preserve">
          <source>A column with TEXT affinity stores all data using storage classes NULL, TEXT or BLOB. If numerical data is inserted into a column with TEXT affinity it is converted into text form before being stored.</source>
          <target state="translated">具有TEXT亲和力的列使用存储类NULL、TEXT或BLOB来存储所有数据。如果数字数据被插入到具有TEXT亲和力的列中,则在存储之前会被转换成文本形式。</target>
        </trans-unit>
        <trans-unit id="331f0240bd92e0f60f02450a7696762f50b6d061" translate="yes" xml:space="preserve">
          <source>A column with affinity BLOB does not prefer one storage class over another and no attempt is made to coerce data from one storage class into another.</source>
          <target state="translated">具有亲和力BLOB的列不会优先选择一个存储类而不是另一个存储类,也不会试图强迫数据从一个存储类进入另一个存储类。</target>
        </trans-unit>
        <trans-unit id="a9b523c7ac2e4f6d2358ca3e1fc9c4bea3b0b218" translate="yes" xml:space="preserve">
          <source>A compile-time option (SQLITE_BUSY_RESERVED_LOCK) causes the busy handler to be called when there is contention for a RESERVED lock.</source>
          <target state="translated">编译时选项(SQLITE_BUSY_RESERVED_LOCK)会导致在争夺一个RESERVED锁时调用忙处理程序。</target>
        </trans-unit>
        <trans-unit id="b67fed388120bd5bc263b4502fa3722ec97dd3d6" translate="yes" xml:space="preserve">
          <source>A complete database is stored in a &lt;a href=&quot;onefile&quot;&gt;single cross-platform disk file&lt;/a&gt;. Great for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt;.</source>
          <target state="translated">完整的数据库存储在&lt;a href=&quot;onefile&quot;&gt;单个跨平台磁盘文件中&lt;/a&gt;。非常适合用作&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11f700eff4c65192a540e579b7e4f8ad1d2b1604" translate="yes" xml:space="preserve">
          <source>A complete release-test of SQLite requires additional software,</source>
          <target state="translated">SQLite的完整发布测试需要额外的软件。</target>
        </trans-unit>
        <trans-unit id="85cbfa4256773a63897f24495c59253a95e5dd50" translate="yes" xml:space="preserve">
          <source>A composite foreign key constraint is one where the child and parent keys are both composite keys. For example, consider the following database schema:</source>
          <target state="translated">复合外键约束是指子键和父键都是复合键。例如,考虑以下数据库模式。</target>
        </trans-unit>
        <trans-unit id="0bdd710506454d94afdc4228574e57b24f793bf2" translate="yes" xml:space="preserve">
          <source>A compound &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement is two or more SELECT statements connected by operators UNION, UNION ALL, EXCEPT, or INTERSECT. We call each individual SELECT statement within a compound SELECT a &quot;term&quot;.</source>
          <target state="translated">复合&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句是通过运算符UNION，UNION ALL，EXCEPT或INTERSECT连接的两个或多个SELECT语句。我们将复合SELECT中的每个单独的SELECT语句称为&amp;ldquo;项&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aff14af06eef38988e550d3bb6bb8834b81c2ab0" translate="yes" xml:space="preserve">
          <source>A compound SELECT created using UNION ALL operator returns all the rows from the SELECT to the left of the UNION ALL operator, and all the rows from the SELECT to the right of it. The UNION operator works the same way as UNION ALL, except that duplicate rows are removed from the final result set. The INTERSECT operator returns the intersection of the results of the left and right SELECTs. The EXCEPT operator returns the subset of rows returned by the left SELECT that are not also returned by the right-hand SELECT. Duplicate rows are removed from the results of INTERSECT and EXCEPT operators before the result set is returned.</source>
          <target state="translated">使用UNION ALL操作符创建的复合SELECT将返回UNION ALL操作符左边的SELECT中的所有记录,以及它右边的SELECT中的所有记录。UNION操作符的工作方式与UNION ALL操作符相同,只是重复的记录会从最终的结果集中删除。INTERSECT操作符返回左右SELECTs结果的交叉点。EXCEPT操作符返回由左SELECT返回的、没有被右SELECT返回的记录的子集。在返回结果集之前,会从INTERSECT和EXCEPT操作符的结果中删除重复的记录。</target>
        </trans-unit>
        <trans-unit id="56b1d09048efb4fd1fb06c9b9ddec9b21053649e" translate="yes" xml:space="preserve">
          <source>A conflict handler callback must return one of the following three values.</source>
          <target state="translated">冲突处理回调必须返回以下三个值之一。</target>
        </trans-unit>
        <trans-unit id="8d286e1793dce553da5e2fb27f69090f877b2aeb" translate="yes" xml:space="preserve">
          <source>A connection may not compile an SQL statement if any other connection is holding a write-lock on the</source>
          <target state="translated">如果有任何其他连接持有对</target>
        </trans-unit>
        <trans-unit id="4a47f7617f36f73967261be474fcf1ca9ab960be" translate="yes" xml:space="preserve">
          <source>A connection must obtain a read-lock on</source>
          <target state="translated">连接必须在</target>
        </trans-unit>
        <trans-unit id="ba1dcaac6e13d9eb13e548994e129aca79ff47b0" translate="yes" xml:space="preserve">
          <source>A contentless FTS5 table is created by setting the &quot;content&quot; option to an empty string. For example:</source>
          <target state="translated">通过将 &quot;content &quot;选项设置为空字符串,可以创建一个无内容的FTS5表。例如:</target>
        </trans-unit>
        <trans-unit id="a267c5dab66f5e34a45852cc32f71b97729d1b15" translate="yes" xml:space="preserve">
          <source>A copy of bytes 0 through 47 of this header.</source>
          <target state="translated">该头的字节0至47的副本。</target>
        </trans-unit>
        <trans-unit id="6bfcf4a271894a36753059f74bed2256dff4a758" translate="yes" xml:space="preserve">
          <source>A coverage testing build is used to validate the test suite, to confirm that the test suite provides 100% MC/DC.</source>
          <target state="translated">覆盖测试构建用于验证测试套件,以确认测试套件提供100%的MC/DC。</target>
        </trans-unit>
        <trans-unit id="94c5d9a042e6577c2dabc042ff092ff7fee14842" translate="yes" xml:space="preserve">
          <source>A database connection in read-uncommitted mode does not attempt to obtain read-locks before reading from database tables as described above. This can lead to inconsistent query results if another database connection modifies a table while it is being read, but it also means that a read-transaction opened by a connection in read-uncommitted mode can neither block nor be blocked by any other connection.</source>
          <target state="translated">在读取-未提交模式下的数据库连接不会像上面所说的那样,在读取数据库表之前试图获得读取锁定。如果另一个数据库连接在读表时修改了表,这可能会导致查询结果不一致,但这也意味着在读-未提交模式下的连接打开的读事务既不能阻止也不能被任何其他连接阻止。</target>
        </trans-unit>
        <trans-unit id="5f2be52de867ed0c8228dad137b9e9be0ede3dc9" translate="yes" xml:space="preserve">
          <source>A database file might contain one or more pages that are not in active use. Unused pages can come about, for example, when information is deleted from the database. Unused pages are stored on the freelist and are reused when additional pages are required.</source>
          <target state="translated">一个数据库文件可能包含一个或多个未使用的页面。例如,当信息从数据库中删除时,就会产生未使用的页面。未使用的页面存储在自由列表中,当需要更多的页面时,可以重新使用。</target>
        </trans-unit>
        <trans-unit id="e31bb0c648c1594ace271ab750089b7069eca230" translate="yes" xml:space="preserve">
          <source>A database filename pointer created by the SQLite core and passed into the xOpen() method of a VFS implemention, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d2200c58a122988a36133f11d5ad81150a5964" translate="yes" xml:space="preserve">
          <source>A database handle may only have a single profile script registered at any time. If there is already a script registered when the profile method is invoked, the previous profile script is replaced by the new one. If the</source>
          <target state="translated">一个数据库句柄在任何时候只能注册一个配置文件脚本。如果在调用profile方法时已经注册了一个脚本,那么之前的profile脚本就会被新的脚本所取代。如果</target>
        </trans-unit>
        <trans-unit id="f7c56f6c25c0806c71336c6dfe79200c9d74d137" translate="yes" xml:space="preserve">
          <source>A database in SQLite is a single disk file&amp;amp;sup1. Furthermore, the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; is cross-platform. A database that is created on one machine can be copied and used on a different machine with a different architecture. SQLite databases are portable across 32-bit and 64-bit machines and between &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt; architectures.</source>
          <target state="translated">SQLite中的数据库是单个磁盘文件＆sup1。此外，&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;是跨平台的。可以复制在一台计算机上创建的数据库，并在具有不同体系结构的另一台计算机上使用。SQLite数据库可在32位和64位计算机之间以及在&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;大端&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;小端&lt;/a&gt;架构之间移植。</target>
        </trans-unit>
        <trans-unit id="a33a00bec56bc970089c19de104ce52c75222367" translate="yes" xml:space="preserve">
          <source>A database in SQLite is a single disk file&amp;sup1;. Furthermore, the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; is cross-platform. A database that is created on one machine can be copied and used on a different machine with a different architecture. SQLite databases are portable across 32-bit and 64-bit machines and between &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt; architectures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58caf1944b94d1b1b9c822b0c5664121932f85cd" translate="yes" xml:space="preserve">
          <source>A database page number P is mapped into a hash value using the following hash function:</source>
          <target state="translated">使用以下哈希函数将数据库页码P映射成一个哈希值。</target>
        </trans-unit>
        <trans-unit id="ed3347e26b126664d224486fe7f1e3e439c82acd" translate="yes" xml:space="preserve">
          <source>A database page size of 8192 or 16384 gives the best performance for large BLOB I/O.</source>
          <target state="translated">数据库页面大小为8192或16384,可以为大型BLOB I/O提供最佳性能。</target>
        </trans-unit>
        <trans-unit id="103c49f4c460c42c7a0369b1a9d6281b2a84fdfe" translate="yes" xml:space="preserve">
          <source>A datatype to SQLite is any sequence of zero or more names optionally followed by a parenthesized lists of one or two signed integers. Notice in particular that a datatype may be &lt;em&gt;zero&lt;/em&gt; or more names. That means that an empty string is a valid datatype as far as SQLite is concerned. So you can declare tables where the datatype of each column is left unspecified, like this:</source>
          <target state="translated">SQLite的数据类型是零个或多个名称的任何序列，可以选择后面跟一个或两个带符号整数的括号列表。特别注意，数据类型可以是&lt;em&gt;零个&lt;/em&gt;或多个名称。这意味着就SQLite而言，空字符串是有效的数据类型。因此，您可以声明未指定每一列的数据类型的表，如下所示：</target>
        </trans-unit>
        <trans-unit id="de414f6a58ee8730c6b30d4d04397485a33b014d" translate="yes" xml:space="preserve">
          <source>A default build of SQLite, if a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statement has no WHERE clause and operates on a table with no triggers, an optimization occurs that causes the DELETE to occur by dropping and recreating the table. Dropping and recreating a table is usually much faster than deleting the table content row by row. This is the &quot;truncate optimization&quot;.</source>
          <target state="translated">如果没有&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句没有WHERE子句并且在没有触发器的表上运行，则SQLite的默认构建会发生优化，该优化会通过删除并重新创建表来导致DELETE发生。通常，删除和重新创建表比逐行删除表内容要快得多。这是&amp;ldquo;截断优化&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2702a604a55a621adb104d691b4fe3d29100cf61" translate="yes" xml:space="preserve">
          <source>A default collation sequence to use with each column.</source>
          <target state="translated">每个列使用的默认整理序列。</target>
        </trans-unit>
        <trans-unit id="547106accc42ee8c3be32b9edfc90679c871cd46" translate="yes" xml:space="preserve">
          <source>A default value or expression for each column in the table.</source>
          <target state="translated">表中每列的默认值或表达式。</target>
        </trans-unit>
        <trans-unit id="f9bafa0d6a619bf3ec9b0838fb3a083c9a68cbd8" translate="yes" xml:space="preserve">
          <source>A demonstration of how to use a virtual table to implement approximate string matching.</source>
          <target state="translated">演示如何使用虚拟表来实现近似字符串匹配。</target>
        </trans-unit>
        <trans-unit id="2c07573f063bff6f3b90762e19698056e9e8c100" translate="yes" xml:space="preserve">
          <source>A description of the available auxiliary functions, and more details regarding configuration of the special &quot;rank&quot; column, are &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;available below&lt;/a&gt;. &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;Custom auxiliary functions&lt;/a&gt; may also be implemented in C and registered with FTS5, just as custom SQL functions may be registered with the SQLite core.</source>
          <target state="translated">可用辅助功能，和更多的细节对于特殊的&amp;ldquo;等级&amp;rdquo;栏的结构的描述，都&lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;可用以下&lt;/a&gt;。&lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;自定义辅助功能&lt;/a&gt;也可以在C中实现并向FTS5注册，就像自定义SQL函数可以向SQLite核心注册一样。</target>
        </trans-unit>
        <trans-unit id="f9c23846cd545b2b63ddda813679cd4a49e68b63" translate="yes" xml:space="preserve">
          <source>A design flaw in the layout of indices required a file format change to correct. This change appeared in version 2.6.0.</source>
          <target state="translated">索引布局中的一个设计缺陷需要改变文件格式来纠正。这一变化出现在2.6.0版本中。</target>
        </trans-unit>
        <trans-unit id="a09b00a1870ec37c4a6711c6d9a83ee63caec494" translate="yes" xml:space="preserve">
          <source>A deterministic function always gives the same answer when it has the same inputs. Most built-in SQL functions in SQLite are deterministic. For example, the &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs(X)&lt;/a&gt; function always returns the same answer as long as its input X is the same.</source>
          <target state="translated">当确定性函数具有相同的输入时，总是给出相同的答案。SQLite中大多数内置的SQL函数都是确定性的。例如，&lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs（X）&lt;/a&gt;函数始终返回相同的答案，只要其输入X相同即可。</target>
        </trans-unit>
        <trans-unit id="f1d23588be86a8b0f51bcfc6d42620be9c04bdb9" translate="yes" xml:space="preserve">
          <source>A different interface is used to find statistics associated with a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;:</source>
          <target state="translated">使用不同的接口来查找与单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;相关的统计信息：</target>
        </trans-unit>
        <trans-unit id="2bab2383badd353faf6d58c28e00ad5e2dc43f7f" translate="yes" xml:space="preserve">
          <source>A different temporary file is created each time, so that just like as with the special &quot;:memory:&quot; string, two database connections to temporary databases each have their own private database. Temporary databases are automatically deleted when the connection that created them closes.</source>
          <target state="translated">每次都会创建一个不同的临时文件,这样就像使用特殊的&quot;:memory:&quot;字符串一样,两个数据库连接到临时数据库都有自己的私有数据库。当创建临时数据库的连接关闭时,临时数据库会被自动删除。</target>
        </trans-unit>
        <trans-unit id="616182c007ad6c0ef9a037faf15b8a4c7b4e27dc" translate="yes" xml:space="preserve">
          <source>A docid (document id), and</source>
          <target state="translated">一个docid(文档id),和</target>
        </trans-unit>
        <trans-unit id="ffa8c1978179e5d6594c307606a0c96c65d178b7" translate="yes" xml:space="preserve">
          <source>A doclist consists of an array of 64-bit signed integers, serialized using the FTS varint format. Each doclist entry is made up of a series of two or more integers, as follows:</source>
          <target state="translated">doclist由一个64位有符号的整数数组组成,使用FTS varint格式序列化。每个doclist条目由两个或多个整数组成,如下所示:</target>
        </trans-unit>
        <trans-unit id="70b611cc962affaff5bc25b34d8cf2a147e0cff8" translate="yes" xml:space="preserve">
          <source>A dot-command cannot occur in the middle of an ordinary SQL statement. In other words, a dot-command cannot occur at a continuation prompt.</source>
          <target state="translated">点号命令不能出现在普通SQL语句的中间。换句话说,点号不能出现在延续提示符中。</target>
        </trans-unit>
        <trans-unit id="ed3f86822b1bda8e466c4526bffa4f20cb3e5064" translate="yes" xml:space="preserve">
          <source>A dot-command must begin with the &quot;.&quot; at the left margin with no preceding whitespace.</source>
          <target state="translated">点号命令必须以&quot;.&quot;开头,并在左侧空白处没有空格。</target>
        </trans-unit>
        <trans-unit id="9419d21a9cdfce978f5cf3af5bf95604556793ad" translate="yes" xml:space="preserve">
          <source>A federation of programs, perhaps all written in different programming languages, can access the same application file with no compatibility concerns.</source>
          <target state="translated">一个程序的联盟,也许都是用不同的编程语言编写的,可以访问同一个应用程序文件,没有兼容性问题。</target>
        </trans-unit>
        <trans-unit id="d364c247d7037a579b6c9cd2b367d98adf71052d" translate="yes" xml:space="preserve">
          <source>A few SQLite extensions benefit from passing pointers:</source>
          <target state="translated">一些SQLite扩展从传递指针中获益。</target>
        </trans-unit>
        <trans-unit id="62f7d6f4dcc5ba74ac0335fa025ccd8910f0c1e1" translate="yes" xml:space="preserve">
          <source>A few opcodes for &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method. The &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; value for the op parameter causes a pointer to the underlying &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object to be written into the space pointed to by the 4th parameter. The &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; works similarly except that it returns the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file instead of the main database. The &lt;a href=&quot;#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode returns a pointer to the underlying &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object for the file. The &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; returns the data version counter from the pager.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）的&lt;/a&gt;一些操作码由SQLite核心直接处理，从不调用sqlite3_io_methods.xFileControl方法。op参数的&lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;值导致将指向底层&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;对象的指针写入第4个参数所指向的空间。该&lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;工作，除了它返回同样&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;与日志文件而不是主数据库相关联的对象。所述&lt;a href=&quot;#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt;操作码将指针返回到底层&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的文件。该&lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; 从寻呼机返回数据版本计数器。</target>
        </trans-unit>
        <trans-unit id="15b71d02b16fcc797e9ca6b0c9b9270d384f8e61" translate="yes" xml:space="preserve">
          <source>A few opcodes for &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; value for the op parameter causes a pointer to the underlying &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object to be written into the space pointed to by the 4th parameter. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; works similarly except that it returns the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file instead of the main database. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode returns a pointer to the underlying &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object for the file. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; returns the data version counter from the pager.</source>
          <target state="translated">&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）的&lt;/a&gt;一些操作码由SQLite核心直接处理，从不调用sqlite3_io_methods.xFileControl方法。op参数的&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;值导致将指向底层&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;对象的指针写入第4个参数所指向的空间。该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;工作，除了它返回同样&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;与日志文件而不是主数据库相关联的对象。所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt;操作码将指针返回到底层&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的文件。该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; 从寻呼机返回数据版本计数器。</target>
        </trans-unit>
        <trans-unit id="5a30cb03f77194a1ffe9dcf2f61544ecd6effb5d" translate="yes" xml:space="preserve">
          <source>A file-handle is opened on the database file.</source>
          <target state="translated">在数据库文件上打开一个文件柄。</target>
        </trans-unit>
        <trans-unit id="a9388c7b2c5482cecf8486b9ae5cf08dcef6f978" translate="yes" xml:space="preserve">
          <source>A filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919b14072f3c1d12642ca7fcf434072aba372a6" translate="yes" xml:space="preserve">
          <source>A filename obtained from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2d542371ac8e72fa484fee76e990ca0bf35dd8" translate="yes" xml:space="preserve">
          <source>A filename that is not a well-formed URI is interpreted as an ordinary filename.</source>
          <target state="translated">一个不是格式良好的URI的文件名会被解释为普通的文件名。</target>
        </trans-unit>
        <trans-unit id="925a1b52b051c06afa6e58e50e2b8bb4927090d1" translate="yes" xml:space="preserve">
          <source>A frame is considered valid if and only if the following conditions are true:</source>
          <target state="translated">如果且仅当以下条件为真时,一个框架被认为是有效的:</target>
        </trans-unit>
        <trans-unit id="9611de2f1872728925114c844500f9f8ef115f15" translate="yes" xml:space="preserve">
          <source>A frame type - either ROWS, RANGE or GROUPS,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b126bb6dbd1d7edb9b84085983a8045b613274" translate="yes" xml:space="preserve">
          <source>A freeblock is a structure used to identify unallocated space within a b-tree page. Freeblocks are organized as a chain. The first 2 bytes of a freeblock are a big-endian integer which is the offset in the b-tree page of the next freeblock in the chain, or zero if the freeblock is the last on the chain. The third and fourth bytes of each freeblock form a big-endian integer which is the size of the freeblock in bytes, including the 4-byte header. Freeblocks are always connected in order of increasing offset. The second field of the b-tree page header is the offset of the first freeblock, or zero if there are no freeblocks on the page. In a well-formed b-tree page, there will always be at least one cell before the first freeblock.</source>
          <target state="translated">自由块是一种结构,用于识别b-tree页面中未分配的空间。自由块是以链的形式组织的。一个自由块的前2个字节是一个大恩迪安整数,它是链中下一个自由块在b树页中的偏移量,如果自由块是链中最后一个,则为零。每个自由块的第三个和第四个字节形成一个大恩迪安整数,这是自由块的大小,以字节为单位,包括4字节的头。自由块总是按照偏移量增加的顺序连接。b-tree页面头的第二个字段是第一个自由块的偏移量,如果页面上没有自由块,则为零。在一个完整的b树页面中,第一个自由块之前总是至少有一个单元格。</target>
        </trans-unit>
        <trans-unit id="2acc382f3b34dd5d099262b455a40252f22e8680" translate="yes" xml:space="preserve">
          <source>A freeblock requires at least 4 bytes of space. If there is an isolated group of 1, 2, or 3 unused bytes within the cell content area, those bytes comprise a fragment. The total number of bytes in all fragments is stored in the fifth field of the b-tree page header. In a well-formed b-tree page, the total number of bytes in fragments may not exceed 60.</source>
          <target state="translated">一个自由块至少需要4个字节的空间。如果在单元内容区域内有一组孤立的1、2或3个未使用的字节,这些字节组成一个片段。所有片段中的字节总数存储在b树页头的第五个字段中。在一个成形良好的b树页中,片段中的字节总数不能超过60。</target>
        </trans-unit>
        <trans-unit id="b80d94705f8bf7c5e4c97f09c2fe3da9d04e1505" translate="yes" xml:space="preserve">
          <source>A freelist leaf page</source>
          <target state="translated">一个自由职业者页面</target>
        </trans-unit>
        <trans-unit id="c3220fe91d800548a519d55ab5c5896e3d8a1361" translate="yes" xml:space="preserve">
          <source>A freelist page</source>
          <target state="translated">自由职业者页面</target>
        </trans-unit>
        <trans-unit id="c408c3d929760cbe3bea5989823d3bcbc82cd883" translate="yes" xml:space="preserve">
          <source>A freelist page. The page number should be zero.</source>
          <target state="translated">一个自由职业者页面。页码应该是零。</target>
        </trans-unit>
        <trans-unit id="d4a249e10dcc6a39be18d8c2e3b23ef6d5feaebd" translate="yes" xml:space="preserve">
          <source>A freelist trunk page</source>
          <target state="translated">一个自由职业者主干页</target>
        </trans-unit>
        <trans-unit id="0db4fc71bebbc8176162f7cd595aa13edbeb12ed" translate="yes" xml:space="preserve">
          <source>A freelist trunk page consists of an array of 4-byte big-endian integers. The size of the array is as many integers as will fit in the usable space of a page. The minimum usable space is 480 bytes so the array will always be at least 120 entries in length. The first integer on a freelist trunk page is the page number of the next freelist trunk page in the list or zero if this is the last freelist trunk page. The second integer on a freelist trunk page is the number of leaf page pointers to follow. Call the second integer on a freelist trunk page L. If L is greater than zero then integers with array indexes between 2 and L+1 inclusive contain page numbers for freelist leaf pages.</source>
          <target state="translated">一个自由列表主干页由一个4字节的大字节整数数组组成。数组的大小是指页面可用空间中能容纳多少个整数。最小的可用空间是480字节,所以数组的长度至少是120个条目。自由列表主干页的第一个整数是列表中下一个自由列表主干页的页码,如果是最后一个自由列表主干页,则为零。自由列表主干页上的第二个整数是要跟随的叶页指针的数量。调用自由列表主干页上的第二个整数L,如果L大于零,那么数组索引在2和L+1(含)之间的整数包含自由列表叶页的页码。</target>
        </trans-unit>
        <trans-unit id="d9f9d805045a05b8c1c21a89d92690feac608128" translate="yes" xml:space="preserve">
          <source>A full disk drive will normally give an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error rather than an SQLITE_IOERR error.</source>
          <target state="translated">完整的磁盘驱动器通常会显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误，而不是SQLITE_IOERR错误。</target>
        </trans-unit>
        <trans-unit id="dd246aeb0987ce268dd63d7c5d7c659921acc423" translate="yes" xml:space="preserve">
          <source>A functionality testing build is used to validate the source code.</source>
          <target state="translated">功能测试构建是用来验证源代码的。</target>
        </trans-unit>
        <trans-unit id="69647f389c03a5fb55f353538995da652df9828c" translate="yes" xml:space="preserve">
          <source>A geopoly table is created as follows:</source>
          <target state="translated">创建地缘表如下:</target>
        </trans-unit>
        <trans-unit id="deba985c96e7599b149dd466acf4a33fd8b7d25a" translate="yes" xml:space="preserve">
          <source>A good rule of thumb is to avoid using SQLite in situations where the same database will be accessed directly (without an intervening application server) and simultaneously from many computers over a network.</source>
          <target state="translated">一个很好的经验法则是避免在以下情况下使用SQLite:在没有应用服务器介入的情况下,直接从多台计算机通过网络同时访问同一个数据库。</target>
        </trans-unit>
        <trans-unit id="47ce97c37cb3d63bea994c838fc3580d1c732993" translate="yes" xml:space="preserve">
          <source>A good rule of thumb seems to be to always set &quot;PRAGMA analysis_limit=N&quot; for N between 100 and 1000 prior to running either &quot;ANALYZE&quot; or &quot;&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt;&quot;. The results are not quite as precise, but they are precise enough, and the fact that the results are computed so much faster means that developers are more likely to compute them. An approximate ANALYZE is better than not running ANALYZE at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504276fb27ab49d77f3fa65dc56539df4f20135a" translate="yes" xml:space="preserve">
          <source>A good way to make an archival copy of a database is this:</source>
          <target state="translated">制作数据库存档副本的好方法是这样的。</target>
        </trans-unit>
        <trans-unit id="9e3552536e0c3fc2b1a5c13a249c60fb3e232b20" translate="yes" xml:space="preserve">
          <source>A high-performance full-text search index.</source>
          <target state="translated">一个高性能的全文检索索引。</target>
        </trans-unit>
        <trans-unit id="f3fc66c121035cba95cdccd27eb5988b1d320b84" translate="yes" xml:space="preserve">
          <source>A higher-performance full-text search index</source>
          <target state="translated">更高性能的全文检索索引</target>
        </trans-unit>
        <trans-unit id="55bfdc0040ab9af19d73d70ad7d6c87f58f9b24f" translate="yes" xml:space="preserve">
          <source>A host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; is a place-holder in an SQL statement that is filled in using one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; interfaces. Many SQL programmers are familiar with using a question mark (&quot;?&quot;) as a host parameter. SQLite also supports named host parameters prefaced by &quot;:&quot;, &quot;$&quot;, or &quot;@&quot; and numbered host parameters of the form &quot;?123&quot;.</source>
          <target state="translated">主机&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;是使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX（）&lt;/a&gt;接口之一填充的SQL语句中的占位符。许多SQL程序员熟悉使用问号（&amp;ldquo;？&amp;rdquo;）作为主机参数。SQLite还支持以&amp;ldquo;：&amp;rdquo;，&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;开头的命名主机参数以及形式为&amp;ldquo;？123&amp;rdquo;的带编号主机参数。</target>
        </trans-unit>
        <trans-unit id="257267c1113a289e6b9feab4b089bb45cde287f6" translate="yes" xml:space="preserve">
          <source>A host computer with a 32-bit or 64-bit address space. The OS can be Linux, Mac, Windows, *BSD, Solaris, or some other.</source>
          <target state="translated">具有32位或64位地址空间的主机。操作系统可以是Linux、Mac、Windows、*BSD、Solaris或其他。</target>
        </trans-unit>
        <trans-unit id="e0b6a216d45c25e568110df32be35198581043b2" translate="yes" xml:space="preserve">
          <source>A journal file consists of one or more</source>
          <target state="translated">一个日志文件由一个或多个</target>
        </trans-unit>
        <trans-unit id="e29bbea10489e0962b8f547beacaa5c44b5643b7" translate="yes" xml:space="preserve">
          <source>A journal is hot if...</source>
          <target state="translated">一本杂志的热度,如果...</target>
        </trans-unit>
        <trans-unit id="bf4b3bcb8b3070bf8bd1c4dde82d2f44df71510d" translate="yes" xml:space="preserve">
          <source>A jump is made to P2 if the result set after filtering would be empty.</source>
          <target state="translated">如果过滤后的结果集为空,则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="93a1f585c4bb54305bbad30d5d616a96cefe0475" translate="yes" xml:space="preserve">
          <source>A limited form of table-level locking is now also available in SQLite. If each table is stored in a separate database file, those separate files can be attached to the main database (using the ATTACH command) and the combined databases will function as one. But locks will only be acquired on individual files as needed. So if you redefine &quot;database&quot; to mean two or more database files, then it is entirely possible for two processes to be writing to the same database at the same time. To further support this capability, commits of transactions involving two or more ATTACHed database are now atomic.</source>
          <target state="translated">现在,SQLite中还提供了一种有限的表级锁定形式。如果每个表都存储在一个单独的数据库文件中,那么这些单独的文件可以附加到主数据库中(使用ATTACH命令),合并后的数据库将作为一个数据库运行。但是只有在需要的时候才会对各个文件获取锁。因此,如果重新定义 &quot;数据库 &quot;为两个或更多的数据库文件,那么完全可以让两个进程同时向同一个数据库写入。为了进一步支持这种能力,涉及两个或多个ATTACHed数据库的事务提交现在是原子的。</target>
        </trans-unit>
        <trans-unit id="759400fcd5974123ad0b1241cafe4f82c240d273" translate="yes" xml:space="preserve">
          <source>A list of term offsets, one for each occurrence of the term within the document. A term offset indicates the number of tokens (words) that occur before the term in question, not the number of characters or bytes. For example, the term offset of the term &quot;war&quot; in the phrase &quot;Ancestral voices prophesying war!&quot; is 3.</source>
          <target state="translated">术语偏移量列表,文档中每出现一个术语,就有一个偏移量。术语偏移量表示在有关术语之前出现的标记(词)数,而不是字符或字节数。例如,&quot;祖音预言战争!&quot;中 &quot;战争 &quot;一词的术语偏移量为3。</target>
        </trans-unit>
        <trans-unit id="b68d4ff4d7b33cd92deee3174c451fcde6f5c709" translate="yes" xml:space="preserve">
          <source>A list of term-offsets, sorted from smallest to largest. Instead of storing the term-offset value literally, each integer stored is the difference between the current term-offset and the previous one (or zero if the current term-offset is the first), plus 2.</source>
          <target state="translated">术语偏移量的列表,从最小到最大排序。不是按字面意思存储术语偏移值,而是存储的每个整数是当前术语偏移值和前一个术语偏移值之间的差值(如果当前术语偏移值是第一个术语偏移值,则为零),加上2。</target>
        </trans-unit>
        <trans-unit id="f2c5240a715ebac0343aac16762c04ccbb3c2e9c" translate="yes" xml:space="preserve">
          <source>A literal value can also be the token &quot;NULL&quot;.</source>
          <target state="translated">字面值也可以是标记 &quot;NULL&quot;。</target>
        </trans-unit>
        <trans-unit id="677dc4104adc8eb80a0bd3eedfbb0364028f37cc" translate="yes" xml:space="preserve">
          <source>A literal value represents a constant. Literal values may be integers, floating point numbers, strings, BLOBs, or NULLs.</source>
          <target state="translated">一个字面值代表一个常量,字面值可以是整数、浮点数、字符串、BLOB或NULL。字面值可以是整数、浮点数、字符串、BLOBs或NULLs。</target>
        </trans-unit>
        <trans-unit id="ec763a0eb37a9be20ccf4fd503223781cee5eb4c" translate="yes" xml:space="preserve">
          <source>A local change may be rebased against multiple remote changes simultaneously. If a single key is modified by multiple remote changesets, they are combined as follows before the local changeset is rebased:</source>
          <target state="translated">一个本地变更可以同时针对多个远程变更进行重基。如果一个密钥被多个远程变更集修改,那么在本地变更集被重新计算之前,它们会被按以下方式合并。</target>
        </trans-unit>
        <trans-unit id="b1f44fa8f0079eaf328b711da0c194b82f3bfca0" translate="yes" xml:space="preserve">
          <source>A maliciously crafted database might be able to inject SQL by defining new &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; in the schema that the application does not anticipate. There are multiple defenses:</source>
          <target state="translated">通过在应用程序无法预期的模式中定义新的&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;或&lt;a href=&quot;lang_createview&quot;&gt;视图&lt;/a&gt;，恶意制作的数据库可能能够注入SQL 。有多种防御措施：</target>
        </trans-unit>
        <trans-unit id="0169e2a34230a953484e9b48ea9bd77dd4f6ea97" translate="yes" xml:space="preserve">
          <source>A master journal is stale if no individual file journals are pointing to it. To figure out if a master journal is stale, we first read the master journal to obtain the names of all of its file journals. Then we check each of those file journals. If any of the file journals named in the master journal exists and points back to the master journal, then the master journal is not stale. If all file journals are either missing or refer to other master journals or no master journal at all, then the master journal we are testing is stale and can be safely deleted.</source>
          <target state="translated">如果一个主日志没有单个文件日志指向它,那么这个主日志就是陈旧的。要确定主日志是否失效,我们首先读取主日志,以获得其所有文件日志的名称。然后我们检查每一个文件期刊。如果主日志中命名的任何一个文件期刊存在,并且指向主日志,那么主日志就不是陈旧的。如果所有的文件日志要么缺失,要么指向其他主日志,要么根本没有主日志,那么我们正在测试的主日志是陈旧的,可以安全删除。</target>
        </trans-unit>
        <trans-unit id="2661539e5d017b557d9c14e5c75af338d27b4e59" translate="yes" xml:space="preserve">
          <source>A merge has already been started (perhaps by a 'merge' command that specified a negative parameter).</source>
          <target state="translated">合并已经开始了(可能是通过一个指定了负参数的 &quot;merge &quot;命令)。</target>
        </trans-unit>
        <trans-unit id="279ebae13f861bd71157c08bf29f5b4c651d6c5d" translate="yes" xml:space="preserve">
          <source>A minimal build of SQLite requires just these routines from the standard C library:</source>
          <target state="translated">SQLite的最小构建只需要标准C库中的这些例程。</target>
        </trans-unit>
        <trans-unit id="a5c466a87de63404dc0230e1abc285b23bb040a4" translate="yes" xml:space="preserve">
          <source>A minimum setup for compiling and testing SQLite from canonical sources is as follows:</source>
          <target state="translated">从规范源编译和测试SQLite的最低设置如下。</target>
        </trans-unit>
        <trans-unit id="ab3655d2734192b9504cea343051e8b9d73b7c75" translate="yes" xml:space="preserve">
          <source>A more compact format for database files.</source>
          <target state="translated">更紧凑的数据库文件格式。</target>
        </trans-unit>
        <trans-unit id="1330a0c8c8c0bac23fcad77a5abcbf9b765e263a" translate="yes" xml:space="preserve">
          <source>A more efficient approach is to remember the last entry currently displayed and then use a row value comparison in the WHERE clause:</source>
          <target state="translated">一个更有效的方法是记住当前显示的最后一个条目,然后在WHERE子句中使用行值比较。</target>
        </trans-unit>
        <trans-unit id="cfada028d3ce37e834b96c227e215c6f74539e9e" translate="yes" xml:space="preserve">
          <source>A multi-column index follows the same pattern as a single-column index; the indexed columns are added in front of the rowid. The only difference is that now multiple columns are added. The left-most column is the primary key used for ordering the rows in the index. The second column is used to break ties in the left-most column. If there were a third column, it would be used to break ties for the first two columns. And so forth for all columns in the index. Because rowid is guaranteed to be unique, every row of the index will be unique even if all of the content columns for two rows are the same. That case does not happen in our sample data, but there is one case (fruit='Orange') where there is a tie on the first column which must be broken by the second column.</source>
          <target state="translated">多列索引与单列索引的模式相同;索引列被添加在 rowid 的前面。唯一的区别是现在增加了多列。最左边的一列是主键,用于对索引中的行进行排序。第二列用来打破最左边列的束缚。如果有第三列,它将用于打破前两列的平局。以此类推,用于索引中的所有列。因为rowid是保证唯一的,所以即使两行的所有内容列都一样,索引的每一行都是唯一的。这种情况在我们的样本数据中并没有发生,但是有一种情况(fruit='Orange'),第一列上有一个并列,必须由第二列来打破。</target>
        </trans-unit>
        <trans-unit id="7f562249be7affb427174375ce85f9677d3d8ba0" translate="yes" xml:space="preserve">
          <source>A nearby diagram shows the main components of SQLite and how they interoperate. The text below explains the roles of the various components.</source>
          <target state="translated">附近的一张图显示了SQLite的主要组件以及它们是如何相互操作的。下面的文字解释了各种组件的作用。</target>
        </trans-unit>
        <trans-unit id="089a318d287cfcafbb763115d5d6b053c8d7bc38" translate="yes" xml:space="preserve">
          <source>A new R*Tree index is created as follows:</source>
          <target state="translated">新的R*Tree索引创建如下。</target>
        </trans-unit>
        <trans-unit id="64a48a9b58450b09d0cfb9d4aa090ba17af83a99" translate="yes" xml:space="preserve">
          <source>A new VFS is implemented by subclassing three objects:</source>
          <target state="translated">一个新的VFS是通过子类化三个对象来实现的。</target>
        </trans-unit>
        <trans-unit id="c89d2ee009f148a6ac5458e28252dd05648bb979" translate="yes" xml:space="preserve">
          <source>A new algorithm for statements of the form INSERT INTO</source>
          <target state="translated">一个新的算法,用于INSERT INTO形式的语句。</target>
        </trans-unit>
        <trans-unit id="0a719325f748bb1a27f330e6d9c663cf611a3f59" translate="yes" xml:space="preserve">
          <source>A new filename constructed using &lt;a href=&quot;#sqlite3_create_filename&quot;&gt;sqlite3_create_filename()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1283a78c873d763b7bafe624f1c1082569445b" translate="yes" xml:space="preserve">
          <source>A new filename constructed using &lt;a href=&quot;create_filename&quot;&gt;sqlite3_create_filename()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9387ece4f279e3ed8f65e6b38d71e87ff67c981e" translate="yes" xml:space="preserve">
          <source>A new flag &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; is made available to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface.</source>
          <target state="translated">新的标志&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;可用于&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="82571217188a60c8f7271b16be25afd37dc1bf34" translate="yes" xml:space="preserve">
          <source>A new interface has been added to provided additional control over the creation of new database connections: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The legacy interfaces of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; continue to be fully supported.</source>
          <target state="translated">添加了一个新接口，以提供对新数据库连接创建的其他控制：&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;。&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;的旧界面继续得到完全支持。</target>
        </trans-unit>
        <trans-unit id="ff7504ffc80677e48bad7daae529fd681b4630cb" translate="yes" xml:space="preserve">
          <source>A new union-vtab instance is created as follows:</source>
          <target state="translated">新的union-vtab实例创建如下。</target>
        </trans-unit>
        <trans-unit id="21f615460738794433e991ce2ff6b478badda600" translate="yes" xml:space="preserve">
          <source>A non-NULL text value must be specified for the name column. It is an error if the specified name already exists in the archive.</source>
          <target state="translated">必须为name列指定一个非null的文本值。如果指定的名称已经存在于档案中,则会出现错误。</target>
        </trans-unit>
        <trans-unit id="44ae7e61487d1800801d4d106af7abaadcf50460" translate="yes" xml:space="preserve">
          <source>A non-root b-tree page. The page number is the parent b-tree page.</source>
          <target state="translated">一个非根b-tree页面。页码是父b树页。</target>
        </trans-unit>
        <trans-unit id="f8e201e2c3e74fe126c7287d5626bd1b0950b6b8" translate="yes" xml:space="preserve">
          <source>A null-terminated string containing the text of one or more SQL statements and/or queries to be processed.</source>
          <target state="translated">一个空头字符串,包含一个或多个要处理的SQL语句和/或查询的文本。</target>
        </trans-unit>
        <trans-unit id="43fd742955a943f2d8d68ae03590be0ffb9da9fd" translate="yes" xml:space="preserve">
          <source>A page in an overflow chain other than the first page. The page number is the prior page of the overflow chain.</source>
          <target state="translated">溢出链中除第一页以外的页面。页码是溢出链的前一页。</target>
        </trans-unit>
        <trans-unit id="d92232575e7ddb99b286147d87a7eb37c112dd51" translate="yes" xml:space="preserve">
          <source>A page is journalled by adding a</source>
          <target state="translated">一个页面通过添加一个</target>
        </trans-unit>
        <trans-unit id="67d41f5dca0e121bb84e085c18fb28ea2c138474" translate="yes" xml:space="preserve">
          <source>A parenthesized, comma-separated list of scalar values.</source>
          <target state="translated">一个用小括号、逗号分隔的标量值列表。</target>
        </trans-unit>
        <trans-unit id="9ef2906548f6946959e71df0c261521f3831b983" translate="yes" xml:space="preserve">
          <source>A partial index definition may include the UNIQUE keyword. If it does, then SQLite requires every entry &lt;em&gt;in the index&lt;/em&gt; to be unique. This provides a mechanism for enforcing uniqueness across some subset of the rows in a table.</source>
          <target state="translated">部分索引定义可以包含UNIQUE关键字。如果是这样，则SQLite要求&lt;em&gt;索引中的&lt;/em&gt;每个条目都是唯一的。这提供了一种在表中的行的某些子集上强制唯一性的机制。</target>
        </trans-unit>
        <trans-unit id="1bf63cba8a9d42e2054c36a2ad3d1ea049c41b10" translate="yes" xml:space="preserve">
          <source>A partial index is an index over a subset of the rows of a table.</source>
          <target state="translated">部分索引是表的行的子集的索引。</target>
        </trans-unit>
        <trans-unit id="5d5173a741f61feaf55620d5f7f757f59051d29a" translate="yes" xml:space="preserve">
          <source>A patchset blob may be used with up to date versions of all sqlite3changeset_xxx API functions except for sqlite3changeset_invert(), which returns SQLITE_CORRUPT if it is passed a patchset. Similarly, attempting to use a patchset blob with old versions of the sqlite3changeset_xxx APIs also provokes an SQLITE_CORRUPT error.</source>
          <target state="translated">一个补丁集blob可以用于所有最新版本的sqlite3changeset_xxx API函数,除了sqlite3changeset_invert(),如果传递了一个补丁集,它会返回SQLITE_CORRUPT。同样,试图使用补丁集blob与旧版本的sqlite3changeset_xxx APIs一起使用也会引发SQLITE_CORRUPT错误。</target>
        </trans-unit>
        <trans-unit id="e65df542e5b2ab6d391d8808bfc9bfd9a42dd1c8" translate="yes" xml:space="preserve">
          <source>A patchset is similar to a changeset. It is slightly more compact than a changeset, but provides more limited conflict detection and resolution options (see the next section for details). The differences between a patchset and a changeset are that:</source>
          <target state="translated">修补集与变更集类似。它比变更集更紧凑,但提供的冲突检测和解决选项更有限(详见下一节)。修补集和变更集的区别在于:1:</target>
        </trans-unit>
        <trans-unit id="6c8a1598f2157bb3e660a70a2c1195f71bea8641" translate="yes" xml:space="preserve">
          <source>A payload overflow page</source>
          <target state="translated">一个有效载荷溢出页</target>
        </trans-unit>
        <trans-unit id="40fb2ed4e8bd2a3775c9d2eeb2d4e37e28a73a34" translate="yes" xml:space="preserve">
          <source>A pending lock allows other processes that already have a shared lock to continue reading the database file. But it prevents new shared locks from being established. The idea behind a pending lock is to prevent writer starvation caused by a large pool of readers. There might be dozens, even hundreds, of other processes trying to read the database file. Each process acquires a shared lock before it starts reading, reads what it needs, then releases the shared lock. If, however, there are many different processes all reading from the same database, it might happen that a new process always acquires its shared lock before the previous process releases its shared lock. And so there is never an instant when there are no shared locks on the database file and hence there is never an opportunity for the writer to seize the exclusive lock. A pending lock is designed to prevent that cycle by allowing existing shared locks to proceed but blocking new shared locks from being established. Eventually all shared locks will clear and the pending lock will then be able to escalate into an exclusive lock.</source>
          <target state="translated">待定锁允许已经有共享锁的其他进程继续读取数据库文件。但它阻止了新的共享锁的建立。待定锁背后的想法是为了防止由一个大的读者池引起的写手饥饿。可能会有几十个,甚至上百个其他进程试图读取数据库文件。每个进程在开始读取之前都会获得一个共享锁,读取它需要的内容,然后释放共享锁。然而,如果有许多不同的进程都从同一个数据库中读取,那么可能会发生这样的情况:一个新的进程总是在前一个进程释放其共享锁之前获得其共享锁。所以,数据库文件上永远没有共享锁的瞬间,因此,写作者永远没有机会夺取独占锁。挂锁就是为了防止这种循环,它允许现有的共享锁继续进行,但阻止新的共享锁建立。最终,所有共享锁将被清除,待定锁将能够升级为独占锁。</target>
        </trans-unit>
        <trans-unit id="cfdf078a1ad97afe7d10282a6193866f5d046f1b" translate="yes" xml:space="preserve">
          <source>A performance enhancement to the page-cache &quot;truncate&quot; operation reduces &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; time by dozens of milliseconds on systems with a large &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;page cache&lt;/a&gt;.</source>
          <target state="translated">页面高速缓存&amp;ldquo;截断&amp;rdquo;操作的性能增强在具有大&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;页面高速缓存的&lt;/a&gt;系统上将&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;时间减少了数十毫秒。</target>
        </trans-unit>
        <trans-unit id="d3934877796a31e3b44b08445cac9678ddebadf6" translate="yes" xml:space="preserve">
          <source>A phrase matches a document if the document contains at least one sub-sequence of tokens that matches the sequence of tokens that make up the phrase.</source>
          <target state="translated">如果文档中至少有一个子序列的标记与构成该短语的标记序列相匹配,则该短语与文档相匹配。</target>
        </trans-unit>
        <trans-unit id="aad9a1c432b5f54ebccf2d84436734289434a755" translate="yes" xml:space="preserve">
          <source>A pile-of-files encourages content to be stored in a few large chunks. In the case of ODP, there are just four XML files that define the layout off all slides in a presentation. An SQLite database allows storing information in a few large chunks, but SQLite is also adept and efficient at storing information in numerous smaller pieces.</source>
          <target state="translated">一堆文件鼓励将内容存储在几大块中。在ODP的情况下,只有四个XML文件定义了演示文稿中所有幻灯片的布局。SQLite数据库允许以几大块的形式存储信息,但SQLite也善于并有效地将信息存储在许多小块中。</target>
        </trans-unit>
        <trans-unit id="95a8394ec4ac0fe21d190c15e56ba33ddbedef33" translate="yes" xml:space="preserve">
          <source>A pile-of-files format can be read incrementally just like SQLite. But many developers are surprised to learn that SQLite can read and write smaller BLOBs (less than about 100KB in size) from its database faster than those same blobs can be read or written as separate files from the filesystem. (See &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; and &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; for further information.) There is overhead associated with operating a relational database engine, however one should not assume that direct file I/O is faster than SQLite database I/O, as often it is not.</source>
          <target state="translated">可以像SQLite一样增量读取文件堆格式。但是许多开发人员惊讶地发现，SQLite可以从其数据库读取和写入较小的BLOB（大小小于100KB）的速度快于那些相同的Blob可以作为独立于文件系统的文件进行读取或写入的速度。（有关更多信息，请参见&lt;a href=&quot;fasterthanfs&quot;&gt;比文件系统&lt;/a&gt;和&lt;a href=&quot;intern-v-extern-blob&quot;&gt;内部BLOB &lt;/a&gt;比内部BLOB 快35％。）与操作关系数据库引擎相关的开销很大，但是，不应假定直接文件I / O比SQLite数据库I / O快，因为通常不是。</target>
        </trans-unit>
        <trans-unit id="6baa78bd5928c61d383f2bef11579e65db7d21d3" translate="yes" xml:space="preserve">
          <source>A pile-of-files format can be viewed as a key/value database. A key/value database is better than no database at all. But without transactions or indices or a high-level query language or a proper schema, it is much harder and more error prone to use a key/value database than a relational database.</source>
          <target state="translated">文件堆格式可以看作是一个键/值数据库。一个键/值数据库总比没有数据库要好。但是,如果没有事务或索引或高级查询语言或适当的模式,使用键/值数据库比使用关系型数据库要难得多,也更容易出错。</target>
        </trans-unit>
        <trans-unit id="52eaf71372365322d7054ef987ab3062057c54cd" translate="yes" xml:space="preserve">
          <source>A pointer map page</source>
          <target state="translated">指针式地图页面</target>
        </trans-unit>
        <trans-unit id="3b58d729b79685a69c83a9e7290179a156089320" translate="yes" xml:space="preserve">
          <source>A pointer that is forwarded to become the first argument to the callback function.</source>
          <target state="translated">一个指针,被转发成为回调函数的第一个参数。</target>
        </trans-unit>
        <trans-unit id="7862edef6bec5bc1b7b5c7480359b6ac1ea3fe42" translate="yes" xml:space="preserve">
          <source>A pointer to a callback function which is invoked once for each row in the result of a query. This argument may be NULL, in which case no callbacks will ever be invoked.</source>
          <target state="translated">指向回调函数的指针,该函数对查询结果中的每一行都会被调用一次。这个参数可以是NULL,在这种情况下,不会调用回调函数。</target>
        </trans-unit>
        <trans-unit id="36a5146ef90ea88c9791d18d9b2f0b91bd10d7bf" translate="yes" xml:space="preserve">
          <source>A pointer to an error string. Error messages are written to space obtained from malloc() and the error string is made to point to the malloced space. The calling function is responsible for freeing this space when it has finished with it. This argument may be NULL, in which case error messages are not reported back to the calling function.</source>
          <target state="translated">一个指向错误字符串的指针。错误信息被写入从malloc()获得的空间,错误字符串被制作成指向malloced空间。调用函数负责在用完这个空间后释放它。这个参数可能是NULL,在这种情况下,错误信息不会返回给调用函数。</target>
        </trans-unit>
        <trans-unit id="0b85ea2771637242c212f75c32dcf4f1c99ff7a4" translate="yes" xml:space="preserve">
          <source>A pointer to the opaque sqlite3_api_routines structure is passed as the third parameter to entry points of &lt;a href=&quot;../loadext&quot;&gt;loadable extensions&lt;/a&gt;. This structure must be typedefed in order to work around compiler warnings on some platforms.</source>
          <target state="translated">指向不透明的sqlite3_api_routines结构的指针作为第三个参数传递到&lt;a href=&quot;../loadext&quot;&gt;可加载扩展的&lt;/a&gt;入口点。必须对这种结构进行类型定义，以便在某些平台上解决编译器警告。</target>
        </trans-unit>
        <trans-unit id="b2d07e71fb26035e20fdffa2af9f1c6c108edfd9" translate="yes" xml:space="preserve">
          <source>A pointer to the opaque sqlite3_api_routines structure is passed as the third parameter to entry points of &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. This structure must be typedefed in order to work around compiler warnings on some platforms.</source>
          <target state="translated">指向不透明的sqlite3_api_routines结构的指针作为第三个参数传递到&lt;a href=&quot;loadext&quot;&gt;可加载扩展的&lt;/a&gt;入口点。必须对这种结构进行类型定义，以便在某些平台上解决编译器警告。</target>
        </trans-unit>
        <trans-unit id="ec59a85cc0f126d0446beb84b628cc1897023e1d" translate="yes" xml:space="preserve">
          <source>A pointer to the sqlite structure obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="translated">指向从&lt;b&gt;sqlite_open&lt;/b&gt;的先前调用获得的sqlite结构的指针。</target>
        </trans-unit>
        <trans-unit id="a83e616cb2fe97cb47d6b546b005133e60c0010f" translate="yes" xml:space="preserve">
          <source>A pointer to the virtual machine is stored in a pointer which is passed in as the 4th parameter. Space to hold the virtual machine is dynamically allocated. To avoid a memory leak, the calling function must invoke &lt;b&gt;sqlite_finalize&lt;/b&gt; on the virtual machine after it has finished with it. The 4th parameter may be set to NULL if an error is encountered during compilation.</source>
          <target state="translated">指向虚拟机的指针存储在作为第4个参数传递的指针中。用于容纳虚拟机的空间是动态分配的。为避免内存泄漏，调用函数完成后必须在虚拟机上调用&lt;b&gt;sqlite_finalize&lt;/b&gt;。如果在编译过程中遇到错误，则可以将第4个参数设置为NULL。</target>
        </trans-unit>
        <trans-unit id="f4123ec647ffbea69c18e776fd8ad4e58f6d7bab" translate="yes" xml:space="preserve">
          <source>A polygon is defined by its vertexes. Each vertex is a JSON array of two numeric values which are the X and Y coordinates of the vertex. A polygon is a JSON array of at least four of these vertexes, and hence is an array of arrays. The first and last vertex in the array must be the same. The polygon follows the right-hand rule: When tracing a line from one vertex to the next, the area to the right of the line is outside of the polygon and the area to the left is inside the polygon. In other words, the net rotation of the vertexes is counter-clockwise.</source>
          <target state="translated">多边形是由它的顶点定义的。每个顶点是由两个数值组成的JSON数组,它们是顶点的X和Y坐标。一个多边形是由至少四个顶点组成的JSON数组,因此是一个数组。数组中的第一个和最后一个顶点必须是相同的。多边形遵循右手规则。当追踪一条从一个顶点到下一个顶点的直线时 线条右边的区域在多边形的外面 而左边的区域在多边形的内部。换句话说,顶点的净旋转是逆时针的。</target>
        </trans-unit>
        <trans-unit id="83be320cc6f7531e133a8fe75643df0ab1bd341d" translate="yes" xml:space="preserve">
          <source>A pragma can take either zero or one argument. The argument is may be either in parentheses or it may be separated from the pragma name by an equal sign. The two syntaxes yield identical results. In many pragmas, the argument is a boolean. The boolean can be one of:</source>
          <target state="translated">一个pragma可以接受零或一个参数。参数is可以放在括号中,也可以从pragma名称中用等号分开。这两种语法产生的结果是相同的。在许多实用名词中,参数是布尔值。布尔型参数可以是以下两种类型之一:</target>
        </trans-unit>
        <trans-unit id="1439b9f8c7100215a693725c95a80144f9686663" translate="yes" xml:space="preserve">
          <source>A pragma may have an optional schema-name before the pragma name. The schema-name is the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database or &quot;main&quot; or &quot;temp&quot; for the main and the TEMP databases. If the optional schema name is omitted, &quot;main&quot; is assumed. In some pragmas, the schema name is meaningless and is simply ignored. In the documentation below, pragmas for which the schema name is meaningful are shown with a &quot;</source>
          <target state="translated">编译指示可以在编译指示名称之前具有可选的架构名称。 schema-name是&lt;a href=&quot;lang_attach&quot;&gt;ATTACH编辑的&lt;/a&gt;数据库的名称，或者是main和TEMP数据库的&amp;ldquo; main&amp;rdquo;或&amp;ldquo; temp&amp;rdquo;名称。如果省略了可选的架构名称，则假定为&amp;ldquo; main&amp;rdquo;。在某些语用上，模式名称是没有意义的，只是被忽略。在下面的文档中，架构名称对其有意义的编译指示显示为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="86c8a11b948e6795af6a6ceb139ca3117a5cbdfe" translate="yes" xml:space="preserve">
          <source>A prefix index is a separate index that records the location of all instances of prefix tokens of a certain length in characters used to speed up queries for prefix tokens. For example, optimizing a query for prefix token &quot;abc*&quot; requires a prefix index of three-character prefixes.</source>
          <target state="translated">前缀索引是一个独立的索引,它记录了一定长度的前缀标记的所有实例的位置,以字符为单位,用于加快前缀标记的查询。例如,优化对前缀标记 &quot;abc*&quot;的查询,需要一个三字符前缀的前缀索引。</target>
        </trans-unit>
        <trans-unit id="b552ccb7eeae1cbc2221248d3b23583ca4696c9f" translate="yes" xml:space="preserve">
          <source>A prepared statement can have zero or more open cursors. Each cursor is identified by a small integer, which is usually the P1 parameter to the opcode that uses the cursor. There can be multiple cursors open on the same index or table. All cursors operate independently, even cursors pointing to the same indices or tables. The only way for the virtual machine to interact with a database file is through a cursor. Instructions in the virtual machine can create a new cursor (ex: &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; or &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;), read data from a cursor (&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;), advance the cursor to the next entry in the table (ex: &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;), and so forth. All cursors are automatically closed when the prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">一个准备好的语句可以有零个或多个打开的游标。每个游标都由一个小整数标识，该整数通常是使用游标的操作码的P1参数。在同一索引或表上可以打开多个游标。所有游标都独立运行，即使游标指向相同的索引或表也是如此。虚拟机与数据库文件交互的唯一方法是通过游标。虚拟机中的指令可以创建一个新的游标（例如：&lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;或&lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;），从游标中读取数据（&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;），将游标前进到表中的下一个条目（例如：&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;或&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;），等等。&lt;a href=&quot;c3ref/reset&quot;&gt;重置&lt;/a&gt;准备好的语句后，所有游标都会自动关闭或已&lt;a href=&quot;c3ref/finalize&quot;&gt;完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3128db754cafeec12014626682cba0f5822aef4d" translate="yes" xml:space="preserve">
          <source>A primer on &lt;a href=&quot;howitworks&quot;&gt;How SQLite Works&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5a41eea2027bd1c81329dfc78cb1162a2b5985" translate="yes" xml:space="preserve">
          <source>A pseudo-table created by this opcode is used to hold a single row output from the sorter so that the row can be decomposed into individual columns using the &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode is the only cursor opcode that works with a pseudo-table.</source>
          <target state="translated">此操作码创建的伪表用于保存排序器的单行输出，以便可以使用&amp;ldquo; &lt;a href=&quot;opcode#Column&quot;&gt;列&amp;rdquo;&lt;/a&gt;操作码将行分解为单独的列。该&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;码是唯一的光标操作码与伪表的作品。</target>
        </trans-unit>
        <trans-unit id="5cfba3e1d0f3aba9e4771931b3f9186e0cfec67a" translate="yes" xml:space="preserve">
          <source>A query plan is represented as a tree. In raw form, as returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, each node of the tree consists of four fields: An integer node id, an integer parent id, an auxiliary integer field that is not currently used, and a description of the node. The entire tree is therefore a table with four columns and zero or more rows. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will usually intercept this table and renders it as an ASCII-art graph for more convenient viewing. To defeat the shells automatic graph rendering, simply include extra white space in between any of the &quot;EXPLAIN&quot;, &quot;QUERY&quot;, and/or &quot;PLAN&quot; keywords and the output will appear in a (less helpful) tabular format.</source>
          <target state="translated">查询计划表示为树。以原始格式显示&lt;a href=&quot;c3ref/step&quot;&gt;（&lt;/a&gt;由sqlite3_step（）返回），树的每个节点均包含四个字段：整数节点ID，整数父ID，当前未使用的辅助整数字段以及节点的描述。因此，整个树是一个具有四列和零个或更多行的表。该&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;通常会拦截该表并使得它作为一个ASCII艺术图表更方便观看。要击败shell自动图形渲染，只需在&amp;ldquo; EXPLAIN&amp;rdquo;，&amp;ldquo; QUERY&amp;rdquo;和/或&amp;ldquo; PLAN&amp;rdquo;关键字之间添加多余的空格，输出将以（不太有用的）表格格式显示。</target>
        </trans-unit>
        <trans-unit id="3aa6dc6aaac817be80debe7e4af4df4ff711024e" translate="yes" xml:space="preserve">
          <source>A query plan is represented as a tree. In raw form, as returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, each node of the tree consists of four fields: An integer node id, an integer parent id, an auxiliary integer field that is not currently used, and a description of the node. The entire tree is therefore a table with four columns and zero or more rows. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will usually intercept this table and renders it as an ASCII-art graph for more convenient viewing. To disable the shells automatic graph rendering and to display EXPLAIN QUERY PLAN output in its tabular format, run the command &quot;.explain off&quot; to set the &quot;EXPLAIN formatting mode&quot; to off. To restore automatic graph rendering, run &quot;.explain auto&quot;. You can see the current &quot;EXPLAIN formatting mode&quot; setting using the &quot;.show&quot; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987ff31ff0ec375872e214a21f32922e046b143e" translate="yes" xml:space="preserve">
          <source>A query sees all changes that are completed on the same database connection prior to the start of the query, regardless of whether or not those changes have been committed.</source>
          <target state="translated">查询可以看到在查询开始之前,在同一个数据库连接上完成的所有更改,无论这些更改是否已经提交。</target>
        </trans-unit>
        <trans-unit id="91d5213dcc2c8331ce561f8806234820515ddce9" translate="yes" xml:space="preserve">
          <source>A quick enumeration of the changes in SQLite version 3.5.0 is provided here. Subsequent sections will describe these changes in more detail.</source>
          <target state="translated">这里提供了SQLite 3.5.0版本的快速列举。后面的章节将更详细地描述这些变化。</target>
        </trans-unit>
        <trans-unit id="f1276c60969bd19155a8ae4ef6b0cf70c5a9044f" translate="yes" xml:space="preserve">
          <source>A random nonce for the checksum</source>
          <target state="translated">校验和的随机非记号</target>
        </trans-unit>
        <trans-unit id="e714ea743566ecda01d0b9ba96c42399b2c76767" translate="yes" xml:space="preserve">
          <source>A read transaction is used for reading only. A write transaction allows both reading and writing. A read transaction is started by a SELECT statement, and a write transaction is started by statements like CREATE, DELETE, DROP, INSERT, or UPDATE (collectively &quot;write statements&quot;). If a write statement occurs while a read transaction is active, then the read transaction is upgraded to a write transaction if possible. If some other database connection has already modified the database or is already in the process of modifying the database, then upgrading to a write transaction is not possible and the write statement will fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bb741ebe526223297eaf9b1bcbc9817350f52d" translate="yes" xml:space="preserve">
          <source>A read transaction is used for reading only. A write transaction allows both reading and writing. A read transaction is started by a SELECT statement, and a write transaction is started by statements like CREATE, DELETE, DROP, INSERT, or UPDATE (collectively &quot;write statements&quot;). If a write statement occurs while a read transaction is active, then the read transaction is upgraded to write transaction if possible. If some other database connection has already modified the database or is already in the process of modifying the database, then upgrading to a write transaction is not possible and the write statement will fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">读事务仅用于读取。写入事务允许读取和写入。读事务由SELECT语句启动，写事务由CREATE，DELETE，DROP，INSERT或UPDATE之类的语句（统称为&amp;ldquo;写语句&amp;rdquo;）启动。如果在读事务处于活动状态时发生写语句，则在可能的情况下将读事务升级为写事务。如果某些其他数据库连接已经修改了数据库或正在修改数据库，则无法升级到写事务，并且&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;将导致写语句失败。</target>
        </trans-unit>
        <trans-unit id="d3e78c57da493fb53e9af08b8cbcf76787c9e57d" translate="yes" xml:space="preserve">
          <source>A read-only connection that is rebuilding its private heap-memory WAL-index does not hold this lock. (It cannot, since read-only connections are not allowed to hold any exclusive locks.) This lock is only held when rebuilding the global shared WAL-index contained in the memory-mapped SHM file.</source>
          <target state="translated">一个正在重建其私有堆内存WAL-index的只读连接不持有这个锁。不能,因为只读连接不允许持有任何专属锁)。只有在重建内存映射的SHM文件中包含的全局共享WAL-索引时,才会持有这个锁。</target>
        </trans-unit>
        <trans-unit id="4cbb00ca2a5b578f8c701ce299cc1bdaf023483d" translate="yes" xml:space="preserve">
          <source>A record contains a header and a body, in that order. The header begins with a single varint which determines the total number of bytes in the header. The varint value is the size of the header in bytes including the size varint itself. Following the size varint are one or more additional varints, one per column. These additional varints are called &quot;serial type&quot; numbers and determine the datatype of each column, according to the following chart:</source>
          <target state="translated">一条记录按顺序包含一个头和一个主体。头部以一个varint开始,它决定了头部的总字节数。varint的值是以字节为单位的头的大小,包括size varint本身。在size varint之后是一个或多个附加的varint,每列一个。这些附加的varint称为 &quot;序列类型 &quot;号,根据下图确定每列的数据类型。</target>
        </trans-unit>
        <trans-unit id="da56351fba5f53698fda54910e0c1f0207d7d3fd" translate="yes" xml:space="preserve">
          <source>A record might have fewer values than the number of columns in the corresponding table. This can happen, for example, after an &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; SQL statement has increased the number of columns in the table schema without modifying preexisting rows in the table. Missing values at the end of the record are filled in using the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; for the corresponding columns defined in the table schema.</source>
          <target state="translated">一条记录的值可能少于相应表中的列数。例如，在&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; SQL语句增加了表架构中的列数而不修改表中已有的行之后，可能会发生这种情况。记录末尾的缺失值使用表模式中定义的对应列的&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认值&lt;/a&gt;填充。</target>
        </trans-unit>
        <trans-unit id="9e5c8169a30113a9ed52f687099166107e7b2523" translate="yes" xml:space="preserve">
          <source>A recursive common table expression can be used to write a query that walks a tree or graph. A recursive common table expression has the same basic syntax as an ordinary common table expression, but with the following additional features:</source>
          <target state="translated">递归通用表表达式可以用来写一个走树或图的查询。递归通用表表达式的基本语法与普通通用表表达式相同,但具有以下附加功能。</target>
        </trans-unit>
        <trans-unit id="176317ddd357b266ebf755cfa3f6bc813ff788c9" translate="yes" xml:space="preserve">
          <source>A reference to &lt;b&gt;the associated &lt;i&gt;database connection&lt;/i&gt;&lt;/b&gt;. Each entry in the</source>
          <target state="translated">&lt;b&gt;对关联&lt;i&gt;数据库连接的&lt;/i&gt;&lt;/b&gt;引用。中的每个条目</target>
        </trans-unit>
        <trans-unit id="e876211f841b1a5a0841faa539bd0f497224e5b7" translate="yes" xml:space="preserve">
          <source>A register can also be &quot;Undefined&quot; meaning that it holds no value at all. Undefined is different from NULL. Depending on compile-time options, an attempt to read an undefined register will usually cause a run-time error. If the code generator (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;) ever generates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that reads an Undefined register, that is a bug in the code generator.</source>
          <target state="translated">寄存器也可以是&amp;ldquo;未定义&amp;rdquo;的，这意味着它根本没有任何值。未定义与NULL不同。根据编译时选项，尝试读取未定义的寄存器通常会导致运行时错误。如果代码生成器（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;）生成了一条&lt;a href=&quot;c3ref/stmt&quot;&gt;准备就绪的语句&lt;/a&gt;来读取未定义的寄存器，则这是代码生成器中的错误。</target>
        </trans-unit>
        <trans-unit id="2a489dc4470d6b0b8e6fff51584f1f564a2e53cf" translate="yes" xml:space="preserve">
          <source>A result table is an array of pointers to zero-terminated UTF-8 strings. There are (N+1)*M elements in the array. The first M pointers point to zero-terminated strings that contain the names of the columns. The remaining entries all point to query results. NULL values result in NULL pointers. All other values are in their UTF-8 zero-terminated string representation as returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;.</source>
          <target state="translated">结果表是指向以零结尾的UTF-8字符串的指针的数组。数组中有（N + 1）* M个元素。前M个指针指向包含列名称的零终止字符串。其余条目均指向查询结果。NULL值导致NULL指针。所有其他值均以&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;返回的UTF-8零终止字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="5699300dbfc9bd124afc697b07363b109eb2de77" translate="yes" xml:space="preserve">
          <source>A result table is an array of pointers to zero-terminated UTF-8 strings. There are (N+1)*M elements in the array. The first M pointers point to zero-terminated strings that contain the names of the columns. The remaining entries all point to query results. NULL values result in NULL pointers. All other values are in their UTF-8 zero-terminated string representation as returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;.</source>
          <target state="translated">结果表是指向以零结尾的UTF-8字符串的指针的数组。数组中有（N + 1）* M个元素。前M个指针指向包含列名称的零终止字符串。其余条目均指向查询结果。NULL值导致NULL指针。所有其他值均以&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;返回的UTF-8零终止字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="0c7b119b5d4d81d6f920e05ce966ec036ccb516b" translate="yes" xml:space="preserve">
          <source>A result table might consist of one or more memory allocations. It is not safe to pass a result table directly to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. A result table should be deallocated using &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt;.</source>
          <target state="translated">结果表可能包含一个或多个内存分配。将结果表直接传递到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;是不安全的。应该使用&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table（）&lt;/a&gt;释放结果表。</target>
        </trans-unit>
        <trans-unit id="b9f7610b427ba3a5db84c1d578ca567b66e4baef" translate="yes" xml:space="preserve">
          <source>A result table might consist of one or more memory allocations. It is not safe to pass a result table directly to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. A result table should be deallocated using &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt;.</source>
          <target state="translated">结果表可能包含一个或多个内存分配。将结果表直接传递到&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;是不安全的。应该使用&lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table（）&lt;/a&gt;释放结果表。</target>
        </trans-unit>
        <trans-unit id="9c8be34ce66bc36d8a3f910227d25c082cf34040" translate="yes" xml:space="preserve">
          <source>A return of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; from sqlite3_backup_step() is not a permanent error and does not affect the return value of sqlite3_backup_finish().</source>
          <target state="translated">从sqlite3_backup_step（）返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;不是永久错误，并且不会影响sqlite3_backup_finish（）的返回值。</target>
        </trans-unit>
        <trans-unit id="d3ccc60d216c44abcc74c0cabe1a2c3a2883ce18" translate="yes" xml:space="preserve">
          <source>A return of &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; or &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; from sqlite3_backup_step() is not a permanent error and does not affect the return value of sqlite3_backup_finish().</source>
          <target state="translated">从sqlite3_backup_step（）返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;或&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;不是永久错误，并且不会影响sqlite3_backup_finish（）的返回值。</target>
        </trans-unit>
        <trans-unit id="79663f33ba3ea21585830534cfcf02f738ed2ade" translate="yes" xml:space="preserve">
          <source>A rich library of &lt;a href=&quot;lang_corefunc&quot;&gt;standard SQL functions&lt;/a&gt;</source>
          <target state="translated">丰富的&lt;a href=&quot;lang_corefunc&quot;&gt;标准SQL函数&lt;/a&gt;库</target>
        </trans-unit>
        <trans-unit id="5984037d329bed4e182dea84884ebbc957606423" translate="yes" xml:space="preserve">
          <source>A rollback journal header is padded with zeros out to the size of a single sector (as defined by the sector size integer at offset 20). The header is in a sector by itself so that if a power loss occurs while writing the sector, information that follows the header will be (hopefully) undamaged.</source>
          <target state="translated">回滚日志头用零填充到一个扇区的大小(由偏移量20的扇区大小整数定义)。页眉本身就在一个扇区中,因此,如果在写扇区时发生断电,页眉后面的信息将(希望)不会受到损坏。</target>
        </trans-unit>
        <trans-unit id="da825d373397b8ff214c898f7100fa92209fe481" translate="yes" xml:space="preserve">
          <source>A rollback journal is a &quot;hot&quot; journal if all of the following are true:</source>
          <target state="translated">如果以下情况全部为真,则回滚日志为 &quot;热 &quot;日志。</target>
        </trans-unit>
        <trans-unit id="93117b5d93400d4aff3d9fc5e17e1f968466bd65" translate="yes" xml:space="preserve">
          <source>A rollback journal is a temporary file used to implement atomic commit and rollback capabilities in SQLite. (For a detailed discussion of how this works, see the separate document titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt;.) The rollback journal is always located in the same directory as the database file and has the same name as the database file except with the 8 characters &quot;&lt;b&gt;-journal&lt;/b&gt;&quot; appended. The rollback journal is usually created when a transaction is first started and is usually deleted when a transaction commits or rolls back. The rollback journal file is essential for implementing the atomic commit and rollback capabilities of SQLite. Without a rollback journal, SQLite would be unable to rollback an incomplete transaction, and if a crash or power loss occurred in the middle of a transaction the entire database would likely go corrupt without a rollback journal.</source>
          <target state="translated">回滚日志是一个临时文件，用于在SQLite中实现原子提交和回滚功能。（有关其工作方式的详细讨论，请参见标题为&lt;a href=&quot;atomiccommit&quot;&gt;SQLite&lt;/a&gt;中的Atomic Commit的单独文档。）回滚日志始终与数据库文件位于同一目录中，并且与数据库文件具有相同的名称，但8个字符除外&amp;rdquo; &lt;b&gt;-日志&lt;/b&gt;&amp;rdquo;。回滚日志通常在首次启动事务时创建，并且通常在事务提交或回滚时被删除。回滚日志文件对于实现SQLite的原子提交和回滚功能至关重要。没有回滚日志，SQLite将无法回滚一个不完整的事务，并且如果在一个事务的中间发生崩溃或断电，整个数据库很可能在没有回滚日志的情况下损坏。</target>
        </trans-unit>
        <trans-unit id="b7f61ea74ecbbdde9b91ead35df3827efa60778b" translate="yes" xml:space="preserve">
          <source>A rollback journal is only considered to be valid if it exists and contains a valid header. Hence a transaction can be committed in one of three ways:</source>
          <target state="translated">只有当回滚日志存在并包含一个有效的头时,它才被认为是有效的。因此,一个事务可以通过三种方式之一来提交。</target>
        </trans-unit>
        <trans-unit id="7bbab471bf381ac51a7c14fe650ef7023a98cf57" translate="yes" xml:space="preserve">
          <source>A rollback journal is said to be &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot&lt;/a&gt; if it needs to be rolled back in order to restore the integrity of its database. A hot journal is created when a process is in the middle of a database update and a program or operating system crash or power failure prevents the update from completing. Hot journals are an exception condition. Hot journals exist to recover from crashes and power failures. If everything is working correctly (that is, if there are no crashes or power failures) you will never get a hot journal.</source>
          <target state="translated">如果需要回滚以恢复其数据库的完整性，则认为回滚日志&lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;很热&lt;/a&gt;。当进程在数据库更新过程中且程序或操作系统崩溃或断电导致更新无法完成时，将创建热日志。热门期刊是一个例外情况。存在热日志以从崩溃和电源故障中恢复。如果一切工作正常（也就是说，没有崩溃或电源故障），您将永远不会获得最新的日志。</target>
        </trans-unit>
        <trans-unit id="52857503386ca8187f9c97fd4ff05410c36c8f77" translate="yes" xml:space="preserve">
          <source>A running SELECT statement that lacks a FROM clause (or any other statement that never reads or writes from any database file) will not prevent a read transaction from closing.</source>
          <target state="translated">运行中的SELECT语句如果缺少FROM子句(或任何其他从不从任何数据库文件中读或写的语句),将不会阻止读事务的关闭。</target>
        </trans-unit>
        <trans-unit id="7cb07d260e238ef8be6278670ca8159f485f6d07" translate="yes" xml:space="preserve">
          <source>A separate document, &lt;a href=&quot;c3ref/intro&quot;&gt;The SQLite C/C++ Interface&lt;/a&gt;, provides detailed specifications for all C/C++ APIs for SQLite. Once the reader understands the basic principles of operation for SQLite, &lt;a href=&quot;c3ref/intro&quot;&gt;that document&lt;/a&gt; should be used as a reference guide. This article is intended as introduction only and is neither a complete nor authoritative reference for the SQLite API.</source>
          <target state="translated">单独的文档&lt;a href=&quot;c3ref/intro&quot;&gt;SQLite C / C ++接口&lt;/a&gt;，为SQLite的所有C / C ++ API提供了详细规范。一旦读者了解了SQLite的基本操作原理，&lt;a href=&quot;c3ref/intro&quot;&gt;就&lt;/a&gt;应将该文档用作参考指南。本文仅作为介绍之用，既不是SQLite API的完整参考也不是权威参考。</target>
        </trans-unit>
        <trans-unit id="baa6b5660e49902a9d6721951328be3eefc3b18e" translate="yes" xml:space="preserve">
          <source>A sequence number assigned to each index for internal tracking purposes.</source>
          <target state="translated">分配给每个索引的序列号,用于内部跟踪。</target>
        </trans-unit>
        <trans-unit id="1ac44a9b2150727d7d1aea70b509f77cbf75e147" translate="yes" xml:space="preserve">
          <source>A series of tests were run to measure the relative performance of SQLite 2.7.6, PostgreSQL 7.1.3, and MySQL 3.23.41. The following are general conclusions drawn from these experiments:</source>
          <target state="translated">我们进行了一系列测试,以测量SQLite 2.7.6、PostgreSQL 7.1.3和MySQL 3.23.41的相对性能。以下是从这些实验中得出的一般结论。</target>
        </trans-unit>
        <trans-unit id="b4faee13d5e4cc6ba30a1f6541864d69478d0a60" translate="yes" xml:space="preserve">
          <source>A serious bug fixed on Windows. Windows users should upgrade. No impact to Unix.</source>
          <target state="translated">在Windows上修复了一个严重的错误。Windows用户应该升级。对Unix没有影响。</target>
        </trans-unit>
        <trans-unit id="275829adb94b5831ffff4998c0fd3b6cdf2a2059" translate="yes" xml:space="preserve">
          <source>A serious problem with the manual imposter table approach described above is that after adding the new &quot;t2&quot; entry to the &quot;sqlite_master&quot; table, the database file will technically be corrupt. Both the &quot;t1bc&quot; index and the &quot;t2&quot; table will point to the same b-tree. This will not cause any immediate problems, though one should avoid running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">上面描述的手动冒名顶替者表方法的一个严重问题是，在将新的&amp;ldquo; t2&amp;rdquo;条目添加到&amp;ldquo; sqlite_master&amp;rdquo;表中之后，数据库文件在技术上将被破坏。&amp;ldquo; t1bc&amp;rdquo;索引和&amp;ldquo; t2&amp;rdquo;表都将指向相同的b树。尽管不会避免运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;，但这不会引起任何直接问题。</target>
        </trans-unit>
        <trans-unit id="b3a86e163a24ba3d737d0e6d5f37de76bb1d3304" translate="yes" xml:space="preserve">
          <source>A serious problem with the manual imposter table approach described above is that after adding the new &quot;t2&quot; entry to the &quot;sqlite_schema&quot; table, the database file will technically be corrupt. Both the &quot;t1bc&quot; index and the &quot;t2&quot; table will point to the same b-tree. This will not cause any immediate problems, though one should avoid running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45dc320cdb9816a2a39a9f3943b5295b82ce63f3" translate="yes" xml:space="preserve">
          <source>A session object (type sqlite3_session*) is created by making a call to the &lt;a href=&quot;session/sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; API function.</source>
          <target state="translated">通过调用&lt;a href=&quot;session/sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt; API函数来创建会话对象（sqlite3_session *类型）。</target>
        </trans-unit>
        <trans-unit id="2fc199170ebe2ff874f6db2f5e7dced1a879c2ec" translate="yes" xml:space="preserve">
          <source>A set of SQL constraints for each table. SQLite supports UNIQUE, NOT NULL, CHECK and FOREIGN KEY constraints.</source>
          <target state="translated">每个表的一组SQL约束。SQLite支持UNIQUE,NOT NULL,CHECK和 FOREIGN KEY约束。</target>
        </trans-unit>
        <trans-unit id="b9ec162401bfb188342d12868912e1becc54935f" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer</source>
          <target state="translated">一个有符号的64位整数</target>
        </trans-unit>
        <trans-unit id="a7e9fa36fa007a2f469e4a4760e755754b6f4660" translate="yes" xml:space="preserve">
          <source>A simple example of a shim is the &quot;vfstrace&quot; VFS. This is a VFS (implemented in the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c&quot;&gt;test_vfstrace.c&lt;/a&gt; source file) that writes a message associated with each VFS method call into a log file, then passes control off to another VFS to do the actual work.</source>
          <target state="translated">填充程序的一个简单示例是&amp;ldquo; vfstrace&amp;rdquo; VFS。这是一个VFS（在&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c&quot;&gt;test_vfstrace.c&lt;/a&gt;源文件中实现），它将与每个VFS方法调用关联的消息写入日志文件，然后将控制权转交给另一个VFS进行实际工作。</target>
        </trans-unit>
        <trans-unit id="7006cbe04f6d24543c2da75c91c78320fed7444e" translate="yes" xml:space="preserve">
          <source>A single CREATE VIRTUAL TABLE statement may contain any number of SQL parameters.</source>
          <target state="translated">一个CREATE VIRTUAL TABLE语句可以包含任意数量的SQL参数。</target>
        </trans-unit>
        <trans-unit id="62311c4f8d538cb3c9b6fb7e004b99ac7cc9aab4" translate="yes" xml:space="preserve">
          <source>A single WAL file can be reused multiple times. In other words, the WAL can fill up with frames and then be checkpointed and then new frames can overwrite the old ones. A WAL always grows from beginning toward the end. Checksums and counters attached to each frame are used to determine which frames within the WAL are valid and which are leftovers from prior checkpoints.</source>
          <target state="translated">一个WAL文件可以多次重复使用。换句话说,WAL可以充满帧,然后被检查点,然后新的帧可以覆盖旧的帧。一个WAL总是从头到尾的增长。附在每个帧上的校验和和计数器用于确定WAL中哪些帧是有效的,哪些是之前校验点的剩余帧。</target>
        </trans-unit>
        <trans-unit id="8785683b4ed7102093caaeccc3a5196c51a5907f" translate="yes" xml:space="preserve">
          <source>A single changeset may contain changes that apply to more than one database table. For each table that the changeset includes at least one change for, it also encodes the following data:</source>
          <target state="translated">一个变化集可以包含适用于一个以上数据库表的变化。对于变化集包含至少一个变化的每个表,它还对以下数据进行编码:</target>
        </trans-unit>
        <trans-unit id="608ce0bf9e63bfc85403ac0271b130acd58c64d6" translate="yes" xml:space="preserve">
          <source>A single database handle may have at most a single write-ahead log callback registered at one time. Calling &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; replaces any previously registered write-ahead log callback. Note that the &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; interface and the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; both invoke &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; and will overwrite any prior &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; settings.</source>
          <target state="translated">一个数据库句柄最多可以同时注册一个预写日志回调。调用&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）会&lt;/a&gt;替换任何先前注册的预写日志回调。请注意，&lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt;接口和&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint编译指示&lt;/a&gt;都将调用&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;并将覆盖以前的所有&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="89206c073889a1c1170a0ebb7406a8fb98a4806a" translate="yes" xml:space="preserve">
          <source>A single database handle may have at most a single write-ahead log callback registered at one time. Calling &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; replaces any previously registered write-ahead log callback. Note that the &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; interface and the &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; both invoke &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; and will overwrite any prior &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; settings.</source>
          <target state="translated">一个数据库句柄最多可以同时注册一个预写日志回调。调用&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）会&lt;/a&gt;替换任何先前注册的预写日志回调。请注意，&lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt;接口和&lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint编译指示&lt;/a&gt;都将调用&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;并将覆盖以前的所有&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="bae717677f5ddab7e1611867390ac460d23c6cd8" translate="yes" xml:space="preserve">
          <source>A single function declaration should contain no more than one of the following: &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;, &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;, or &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;.</source>
          <target state="translated">单个函数声明&lt;a href=&quot;compile#apicall&quot;&gt;最多只能&lt;/a&gt;包含以下一项：SQLITE_APICALL，&lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;，&lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;或&lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e26df4d33430b6b34c4d91859f0ec1b63873b0b8" translate="yes" xml:space="preserve">
          <source>A single phrase or NEAR group may be restricted to matching text within a specified column of the FTS table by prefixing it with the column name followed by a colon character. Or to a set of columns by prefixing it with a whitespace separated list of column names enclosed in parenthesis (&quot;curly brackets&quot;) followed by a colon character. Column names may be specified using either of the two forms described for strings above. Unlike strings that are part of phrases, column names are not passed to the tokenizer module. Column names are case-insensitive in the usual way for SQLite column names - upper/lower case equivalence is understood for ASCII-range characters only.</source>
          <target state="translated">单个短语或NEAR组可以通过在列名前加上冒号,限制在FTS表的指定列内匹配文本。或者通过在列名前加上括号(&quot;大括号&quot;)和冒号字符,将其限制在一组列中。列名可以使用上面为字符串描述的两种形式中的任何一种来指定。与作为短语一部分的字符串不同,列名不会被传递给标记程序模块。列名与SQLite列名一样,不区分大小写--大写/小写等价,只适用于ASCII范围的字符。</target>
        </trans-unit>
        <trans-unit id="957ff29feb802c055a16b8a1e4c52a503d6ee8db" translate="yes" xml:space="preserve">
          <source>A single session object monitors changes made to a single database (i.e. &quot;main&quot;, &quot;temp&quot; or an attached database) via a single sqlite3* database handle.</source>
          <target state="translated">单一会话对象通过单一的sqlite3*数据库句柄监控对单一数据库(即 &quot;main&quot;、&quot;temp &quot;或附加数据库)的更改。</target>
        </trans-unit>
        <trans-unit id="1707c93eb5e5ee6c5b850e9748ead9054742daf0" translate="yes" xml:space="preserve">
          <source>A small patch to version 3.6.16 to fix &lt;a href=&quot;http://www.sqlite.org/src/info/6b00e0a34c&quot;&gt;the OP_If bug&lt;/a&gt;.</source>
          <target state="translated">3.6.16版的一个小补丁，用于修复&lt;a href=&quot;http://www.sqlite.org/src/info/6b00e0a34c&quot;&gt;OP_If bug&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d37282f44ff8f219293b2945eedcfa47898899c4" translate="yes" xml:space="preserve">
          <source>A smaller and faster implementation of text to floating-point conversion subroutine: sqlite3AtoF().</source>
          <target state="translated">一个更小更快的文本到浮点转换子程序的实现:sqlite3AtoF()。</target>
        </trans-unit>
        <trans-unit id="9e409edf566363994702e2aef11edf00e8d07606" translate="yes" xml:space="preserve">
          <source>A special SQL function RAISE() may be used within a trigger-program, with the following syntax</source>
          <target state="translated">一个特殊的SQL函数RAISE()可以在触发器程序中使用,其语法如下。</target>
        </trans-unit>
        <trans-unit id="68a6631c65b5f7328388f2b5ccd5678cd79d4fa1" translate="yes" xml:space="preserve">
          <source>A stale master journal is a master journal that is no longer being used for anything. There is no requirement that stale master journals be deleted. The only reason for doing so is to free up disk space.</source>
          <target state="translated">过时的主日志是指不再用于任何目的的主日志。没有要求删除过时的主日志。这样做的唯一原因是为了释放磁盘空间。</target>
        </trans-unit>
        <trans-unit id="2d496d822cbfbcef6fd2f26cb43721e4d7db1958" translate="yes" xml:space="preserve">
          <source>A stale super-journal is a super-journal that is no longer being used for anything. There is no requirement that stale super-journals be deleted. The only reason for doing so is to free up disk space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ebc788dee352b396a0729f45e60a8dfd65ce42" translate="yes" xml:space="preserve">
          <source>A standard SQLite build includes a small amount of logic associated with &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; to exercise parts of the SQLite core that are otherwise difficult to validate. This compile-time option omits that extra testing logic. This compile-time option was called &quot;SQLITE_OMIT_BUILTIN_TEST&quot; prior to SQLite version 3.16.0 (2017-01-02). The name was changed to better describe the implications of using it.</source>
          <target state="translated">标准的SQLite构建包含少量与&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;相关的逻辑，以执行SQLite核心中难以验证的部分。此编译时选项省略了额外的测试逻辑。在SQLite版本3.16.0（2017-01-02）之前，此编译时选项称为&amp;ldquo; SQLITE_OMIT_BUILTIN_TEST&amp;rdquo;。名称被更改以更好地描述使用它的含义。</target>
        </trans-unit>
        <trans-unit id="61a7a7e55f6d9bd17dba85ad11c8944fbcdc4459" translate="yes" xml:space="preserve">
          <source>A starting frame boundary,</source>
          <target state="translated">一个起始框架边界。</target>
        </trans-unit>
        <trans-unit id="37fb198dfcb0d142d377ce0e169267e9a1cdfccb" translate="yes" xml:space="preserve">
          <source>A statement journal file is used to rollback partial results of a single statement within a larger transaction. For example, suppose an UPDATE statement will attempt to modify 100 rows in the database. But after modifying the first 50 rows, the UPDATE hits a constraint violation which should block the entire statement. The statement journal is used to undo the first 50 row changes so that the database is restored to the state it was in at the start of the statement.</source>
          <target state="translated">语句日志文件用于回滚较大事务中的单个语句的部分结果。例如,假设一条UPDATE语句将尝试修改数据库中的100条记录。但是在修改了前50条记录之后,UPDATE语句遇到了一个约束违反,应该阻止整个语句。语句日志用来撤销前50行的修改,这样数据库就会恢复到语句开始时的状态。</target>
        </trans-unit>
        <trans-unit id="940c3a5de694a1d82ab455c32b9b6bed30de5212" translate="yes" xml:space="preserve">
          <source>A statement journal is only created for an UPDATE or INSERT statement that might change multiple rows of a database and which might hit a constraint or a RAISE exception within a trigger and thus need to undo partial results. If the UPDATE or INSERT is not contained within BEGIN...COMMIT and if there are no other active statements on the same database connection then no statement journal is created since the ordinary rollback journal can be used instead. The statement journal is also omitted if an alternative &lt;a href=&quot;lang_conflict&quot;&gt;conflict resolution algorithm&lt;/a&gt; is used. For example:</source>
          <target state="translated">仅为UPDATE或INSERT语句创建语句日志，该语句可能会更改数据库的多行，并且可能会在触发器内遇到约束或RAISE异常，因此需要撤消部分结果。如果UPDATE或INSERT不包含在BEGIN ... COMMIT中，并且同一数据库连接上没有其他活动语句，则不会创建任何语句日志，因为可以使用普通的回滚日志来代替。如果使用其他&lt;a href=&quot;lang_conflict&quot;&gt;冲突解决算法，&lt;/a&gt;则也将省略语句日志。例如：</target>
        </trans-unit>
        <trans-unit id="1d0a69ee154fd724c3f7e2b66c07110e679818fe" translate="yes" xml:space="preserve">
          <source>A statement such as the above can be run immediately prior to invoking &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; to confirm that all prepared statements have been &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; and to help identify and track down prepared statements that have &quot;leaked&quot; and missed finalization.</source>
          <target state="translated">可以在调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;之前立即运行诸如上述的语句，以确认所有准备好的语句已经&lt;a href=&quot;c3ref/finalize&quot;&gt;完成，&lt;/a&gt;并有助于识别和跟踪&amp;ldquo;泄漏&amp;rdquo;和错过了最终效果的准备好的语句。</target>
        </trans-unit>
        <trans-unit id="93e2d7eae4ab34999aac0e06cf630caa26eca256" translate="yes" xml:space="preserve">
          <source>A storage class is more general than a datatype. The INTEGER storage class, for example, includes 6 different integer datatypes of different lengths. This makes a difference on disk. But as soon as INTEGER values are read off of disk and into memory for processing, they are converted to the most general datatype (8-byte signed integer). And so for the most part, &quot;storage class&quot; is indistinguishable from &quot;datatype&quot; and the two terms can be used interchangeably.</source>
          <target state="translated">一个存储类比一个数据类型更通用。例如,INTEGER存储类包括6种不同长度的整数数据类型。这在磁盘上是有区别的。但是,当INTEGER值从磁盘上读出并进入内存进行处理时,它们就会被转换为最通用的数据类型(8字节有符号的整数)。所以在大多数情况下,&quot;存储类 &quot;和 &quot;数据类型 &quot;是没有区别的,这两个术语可以互换使用。</target>
        </trans-unit>
        <trans-unit id="7675d21b606912c9ad81d09f8bd030b6fb973bc2" translate="yes" xml:space="preserve">
          <source>A straightforward implementation of a spelling corrector would be to compare the search term against every word in the vocabulary and select the 20 with the lowest scores. However, there will typically be hundreds of thousands or millions of words in the vocabulary, and so this approach is not fast enough.</source>
          <target state="translated">拼写校正器的直接实现方式是将搜索词与词汇中的每一个词进行比较,然后选择得分最低的20个。然而,词汇中通常会有几十万或几百万个单词,因此这种方法不够快。</target>
        </trans-unit>
        <trans-unit id="eaf0250c67cab7be0dc1ee87f425a759227d1fab" translate="yes" xml:space="preserve">
          <source>A string constant is formed by enclosing the string in single quotes ('). A single quote within the string can be encoded by putting two single quotes in a row - as in Pascal. C-style escapes using the backslash character are not supported because they are not standard SQL.</source>
          <target state="translated">字符串常量是通过用单引号(')包围字符串而形成的。字符串中的单引号可以通过在一行中加入两个单引号来编码--就像在Pascal中一样。不支持使用反斜杠字符的C式转义,因为它们不是标准SQL。</target>
        </trans-unit>
        <trans-unit id="833d0cdbb5e0f11e62e7535fa2b560860c4b3b41" translate="yes" xml:space="preserve">
          <source>A string might look like a floating-point literal with a decimal point and/or exponent notation but as long as the value can be expressed as an integer, the NUMERIC affinity will convert it into an integer. Hence, the string '3.0e+5' is stored in a column with NUMERIC affinity as the integer 300000, not as the floating point value 300000.0.</source>
          <target state="translated">字符串可能看起来像一个带有小数点和/或指数符号的浮点文字,但只要该值可以用整数表示,NUMERIC亲和力就会将其转换为整数。因此,字符串 &quot;3.0e+5 &quot;在NUMERIC亲和力列中被存储为整数300000,而不是浮点值300000.0。</target>
        </trans-unit>
        <trans-unit id="8190afbd8c6bbd11bbd6c14f28a0172cbb480b3c" translate="yes" xml:space="preserve">
          <source>A subquery expression with two or more result columns.</source>
          <target state="translated">一个有两个或多个结果列的子查询表达式。</target>
        </trans-unit>
        <trans-unit id="5635ec05c69c3ce96a3233f42069b4904d399309" translate="yes" xml:space="preserve">
          <source>A subquery on the right-hand side of IN operator must often be materialized. For example:</source>
          <target state="translated">IN运算符右侧的子查询必须经常具体化。例如:</target>
        </trans-unit>
        <trans-unit id="7c0661a4bdbca6636faba7e3ce330659e6cc7c97" translate="yes" xml:space="preserve">
          <source>A subquery that returns a single column is a scalar subquery and can be used most anywhere. A subquery that returns two or more columns is a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; subquery and can only be used as the operand of a comparison operator.</source>
          <target state="translated">返回单列的子查询是标量子查询，可以在大多数地方使用。返回两列或更多列的子查询是&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;子查询，并且只能用作比较运算符的操作数。</target>
        </trans-unit>
        <trans-unit id="513c8fcc36f3dbb3fe1ba2919acd7ef31b0580f6" translate="yes" xml:space="preserve">
          <source>A successful invocation of this method will cause *pRowid to be filled with the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of row that the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; pCur is currently pointing at. This method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. It returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">成功调用此方法将导致* pRowid填充&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;虚拟表光标&lt;/a&gt; pCur当前指向的行的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。成功时此方法返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。失败时将返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e843c0218f6351825674391272a0db4bb8db636e" translate="yes" xml:space="preserve">
          <source>A super-journal is stale if no individual file journals are pointing to it. To figure out if a super-journal is stale, we first read the super-journal to obtain the names of all of its file journals. Then we check each of those file journals. If any of the file journals named in the super-journal exists and points back to the super-journal, then the super-journal is not stale. If all file journals are either missing or refer to other super-journals or no super-journal at all, then the super-journal we are testing is stale and can be safely deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a876cbac258b205fceef1496fbc66fdbd28a83e7" translate="yes" xml:space="preserve">
          <source>A swarmvtab table has the same schema as each of its component tables.</source>
          <target state="translated">一个swarmvtab表与它的每个组件表具有相同的模式。</target>
        </trans-unit>
        <trans-unit id="24f9af565c085a8964740fe3fa13a54013369f70" translate="yes" xml:space="preserve">
          <source>A swarmvtab virtual table is created as follows:</source>
          <target state="translated">swarmvtab虚拟表的创建方法如下。</target>
        </trans-unit>
        <trans-unit id="c3b6e57942158b2ce08f2d6299decb29e664e48f" translate="yes" xml:space="preserve">
          <source>A table b-tree interior page</source>
          <target state="translated">A表b树内页</target>
        </trans-unit>
        <trans-unit id="bcb5ce26b9e5292874c4f103c523b7155ab1d3d5" translate="yes" xml:space="preserve">
          <source>A table b-tree leaf page</source>
          <target state="translated">A表b树叶页</target>
        </trans-unit>
        <trans-unit id="1e18698afc8eb8fd55a13d0d4739a4898ecead4e" translate="yes" xml:space="preserve">
          <source>A table created using CREATE TABLE AS has no PRIMARY KEY and no constraints of any kind. The default value of each column is NULL. The default collation sequence for each column of the new table is BINARY.</source>
          <target state="translated">使用CREATE TABLE AS创建的表没有PRIMARY KEY,也没有任何形式的约束。各列的默认值为NULL。新表的每一列的默认整理序列是BINARY。</target>
        </trans-unit>
        <trans-unit id="2722d24833adf5b38fd57107e3991ba2e3c139c1" translate="yes" xml:space="preserve">
          <source>A table of insertion, deletion, and substitution costs can be provided by the application.</source>
          <target state="translated">应用程序可以提供插入、删除和替换成本表。</target>
        </trans-unit>
        <trans-unit id="0d688ea9d1619e762c6e53a152855aec30c051d2" translate="yes" xml:space="preserve">
          <source>A table with the name &quot;sqlite_sequence&quot; that is used to keep track of the maximum historical &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for a table using &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;.</source>
          <target state="translated">名称为&amp;ldquo; sqlite_sequence&amp;rdquo; 的表，用于使用&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;跟踪表的最大历史&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a57714ccd156bf9e3f87fe308936736e98e591aa" translate="yes" xml:space="preserve">
          <source>A table-valued function, which provides read-only access to existing archives, either from the file-system or in-memory.</source>
          <target state="translated">一个表值函数,提供对现有档案的只读访问,可以从文件系统或内存中访问。</target>
        </trans-unit>
        <trans-unit id="a7fc019c02a91fed82d92a06336ce9b17ea402c2" translate="yes" xml:space="preserve">
          <source>A template loadable extension contains the following three elements:</source>
          <target state="translated">一个可加载的模板扩展包含以下三个元素。</target>
        </trans-unit>
        <trans-unit id="8ceeadc33088d54343486462a0c9aba5dbbc0128" translate="yes" xml:space="preserve">
          <source>A template virtual table implementation useful as a starting point for developers who want to write their own virtual tables</source>
          <target state="translated">一个模板虚拟表的实现,对于想要编写自己的虚拟表的开发者来说,可以作为一个起点。</target>
        </trans-unit>
        <trans-unit id="cab32d076f372c6b13570208a924360640dda14f" translate="yes" xml:space="preserve">
          <source>A temporary index is always used to hold the values of the right-hand side of an IN operator when that right-hand side is a list of values.</source>
          <target state="translated">当IN操作符的右侧是一个值的列表时,一个临时索引总是用来保存该右侧的值。</target>
        </trans-unit>
        <trans-unit id="ee92b6976c5d4721278b029adeafc2db008e6cdc" translate="yes" xml:space="preserve">
          <source>A term is a contiguous sequence of eligible characters, where eligible characters are all alphanumeric characters and all characters with Unicode codepoint values greater than or equal to 128. All other characters are discarded when splitting a document into terms. Their only contribution is to separate adjacent terms.</source>
          <target state="translated">一个术语是一个符合条件的字符的连续序列,其中符合条件的字符是所有字母数字字符和Unicode码点值大于或等于128的所有字符。当把一个文档分割成术语时,所有其他字符都会被丢弃。它们的唯一作用是分隔相邻的术语。</target>
        </trans-unit>
        <trans-unit id="bdd3e37ef65b6b87adc2cbe96c6048ce8be9f761" translate="yes" xml:space="preserve">
          <source>A text editor of the user's choice supporting UTF-8 text.</source>
          <target state="translated">用户选择的文本编辑器,支持UTF-8文本。</target>
        </trans-unit>
        <trans-unit id="739cfe03c5105216274ffacf61131b06ede6508f" translate="yes" xml:space="preserve">
          <source>A text value created by casting a blob that begins with the two bytes 0xFF and 0xFE, in either possible order, is inserted into an FTS3 table. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d6801cd3f12d6898833bf9ca6bab5539cfae7b" translate="yes" xml:space="preserve">
          <source>A time string can be in any of the following formats:</source>
          <target state="translated">时间字符串可以是以下任何一种格式。</target>
        </trans-unit>
        <trans-unit id="f8aa525971c9057cebec913efdec9452b2a87880" translate="yes" xml:space="preserve">
          <source>A tokenizer is used that recognizes byte-order-marks as whitespace. (The default &quot;simple&quot; tokenizer for FTS3/4 does not think that BOMs are whitespace, but the unicode tokenizer does.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d86f49b9040272a60a55ad61e8ad5131c63f59c" translate="yes" xml:space="preserve">
          <source>A torn page occurs when a database page is larger than a disk sector, the database page is written to disk, but a power loss occurs prior to all sectors of the database page being written. Then, upon recovery, part of the database page will have the old content while some other parts of the page will have the new content. Some database engines assume that page writes are atomic and hence a torn page is an unrecoverable error.</source>
          <target state="translated">当数据库页面大于磁盘扇区时,就会发生撕页,数据库页面被写入磁盘,但在数据库页面的所有扇区被写入之前,发生了断电。那么,在恢复后,数据库页面的一部分会有旧的内容,而页面的其他一些部分会有新的内容。有些数据库引擎认为页面写入是原子性的,因此页面撕裂是一个不可恢复的错误。</target>
        </trans-unit>
        <trans-unit id="321b99cb3ca22320bc4d4754f57c85325a5439b8" translate="yes" xml:space="preserve">
          <source>A trace callback has four arguments: xCallback(T,C,P,X). The T argument is one of the integer type codes above. The C argument is a copy of the context pointer passed in as the fourth argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt;. The P and X arguments are pointers whose meanings depend on T.</source>
          <target state="translated">跟踪回调具有四个参数：xCallback（T，C，P，X）。T参数是上面的整数类型代码之一。C参数是作为第四个参数传递给&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;的上下文指针的副本。P和X参数是指针，其含义取决于T。</target>
        </trans-unit>
        <trans-unit id="99f3aaaba3c5cbd27990154339c07e3ae8d754b2" translate="yes" xml:space="preserve">
          <source>A trace callback has four arguments: xCallback(T,C,P,X). The T argument is one of the integer type codes above. The C argument is a copy of the context pointer passed in as the fourth argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt;. The P and X arguments are pointers whose meanings depend on T.</source>
          <target state="translated">跟踪回调具有四个参数：xCallback（T，C，P，X）。T参数是上面的整数类型代码之一。C参数是作为第四个参数传递给&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;的上下文指针的副本。P和X参数是指针，其含义取决于T。</target>
        </trans-unit>
        <trans-unit id="f8bfcc86c34516e1fd4709998e44b1f12ab7abe6" translate="yes" xml:space="preserve">
          <source>A trace callback is invoked with four arguments: callback(T,C,P,X). The T argument is one of the &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants to indicate why the callback was invoked. The C argument is a copy of the context pointer. The P and X arguments are pointers whose meanings depend on T.</source>
          <target state="translated">使用四个参数调用跟踪回调：callback（T，C，P，X）。T参数是&lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt;常量之一，用于指示调用回调的原因。C参数是上下文指针的副本。P和X参数是指针，其含义取决于T。</target>
        </trans-unit>
        <trans-unit id="3391a0e081f93a34b14f66af9af68c43e3c9b43e" translate="yes" xml:space="preserve">
          <source>A trace callback is invoked with four arguments: callback(T,C,P,X). The T argument is one of the &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants to indicate why the callback was invoked. The C argument is a copy of the context pointer. The P and X arguments are pointers whose meanings depend on T.</source>
          <target state="translated">使用四个参数调用跟踪回调：callback（T，C，P，X）。T参数是&lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt;常量之一，用于指示调用回调的原因。C参数是上下文指针的副本。P和X参数是指针，其含义取决于T。</target>
        </trans-unit>
        <trans-unit id="6f406be63849f147005f5bd90bb0cfb01b00b5d0" translate="yes" xml:space="preserve">
          <source>A transaction must be started before executing this opcode.</source>
          <target state="translated">在执行这个操作码之前,必须先启动一个事务。</target>
        </trans-unit>
        <trans-unit id="d659782eaca92197beb5705e0198423f0973c8e4" translate="yes" xml:space="preserve">
          <source>A transactional database is one in which all changes and queries appear to be Atomic, Consistent, Isolated, and Durable (&lt;a href=&quot;http://en.wikipedia.org/wiki/ACID&quot;&gt;ACID&lt;/a&gt;). SQLite implements &lt;a href=&quot;http://en.wikipedia.org/wiki/Serializability&quot;&gt;serializable&lt;/a&gt; transactions that are atomic, consistent, isolated, and durable, even if the transaction is interrupted by a program crash, an operating system crash, or a power failure to the computer.</source>
          <target state="translated">事务数据库是其中所有更改和查询似乎都是原子的，一致的，隔离的和持久的（&lt;a href=&quot;http://en.wikipedia.org/wiki/ACID&quot;&gt;ACID&lt;/a&gt;）。即使事务因程序崩溃，操作系统崩溃或计算机电源故障而中断，SQLite 仍可实现原子，一致，隔离和持久的可&lt;a href=&quot;http://en.wikipedia.org/wiki/Serializability&quot;&gt;序列化&lt;/a&gt;事务。</target>
        </trans-unit>
        <trans-unit id="762f7ff34044b36794c45c18c95e9030f7e31400" translate="yes" xml:space="preserve">
          <source>A triangle has three vertexes, but the GeoJSON description of the triangle has 4 vertexes because the first and last vertex are duplicates.</source>
          <target state="translated">一个三角形有三个顶点,但GeoJSON描述的三角形有4个顶点,因为第一个和最后一个顶点是重复的。</target>
        </trans-unit>
        <trans-unit id="29b340a77213cb4d10ec115c1281733a8d75cde1" translate="yes" xml:space="preserve">
          <source>A trigger may be specified to fire whenever a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; of a particular database table occurs, or whenever an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; occurs on on one or more specified columns of a table.</source>
          <target state="translated">每当发生特定数据库表的&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;或&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或表的一个或多个指定列上发生&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;时，都可以指定触发触发器。</target>
        </trans-unit>
        <trans-unit id="fd2260f1e1f77326af7731e7d8239b68e8a9f11e" translate="yes" xml:space="preserve">
          <source>A trigger normally exists in the same database as the table named after the &quot;ON&quot; keyword in the CREATE TRIGGER statement. Except, it is possible to create a TEMP TRIGGER on a table in another database. Such a trigger will only fire when changes are made to the target table by the application that defined the trigger. Other applications that modify the database will not be able to see the TEMP trigger and hence cannot run the trigger.</source>
          <target state="translated">触发器通常与CREATE TRIGGER语句中以 &quot;ON &quot;关键字命名的表存在同一个数据库中。但是,可以在另一个数据库的表上创建一个TEMP TRIGGER。这样的触发器只有在定义触发器的应用程序对目标表进行修改时才会触发。其他修改数据库的应用程序将无法看到TEMP触发器,因此无法运行该触发器。</target>
        </trans-unit>
        <trans-unit id="9ae92c55b82f470eeeb4bba0b8d4309fbfff3525" translate="yes" xml:space="preserve">
          <source>A unique constraint is satisfied if and only if no two rows in a table have the same non-null values in the unique columns.</source>
          <target state="translated">如果且仅当表中的唯一列中没有两行具有相同的非空值时,则满足唯一约束。</target>
        </trans-unit>
        <trans-unit id="6ae94a52f226bc47de3ee1540f2d8d90e50fc05b" translate="yes" xml:space="preserve">
          <source>A unique constraint is satisfied if and only if no two rows in a table have the same values and have non-null values in the unique columns.</source>
          <target state="translated">如果且仅当表中没有两行的值相同,且唯一列的值非空,则满足唯一约束。</target>
        </trans-unit>
        <trans-unit id="dabcb6d549c13ce12ef42eaf48b0d41d8c3dfc2d" translate="yes" xml:space="preserve">
          <source>A unique constraint is satisfied if and only if no two rows in a table have the same values in the subset of unique columns that are not null.</source>
          <target state="translated">如果且仅当表中没有两行在非空的唯一列子集中具有相同的值,则满足唯一约束。</target>
        </trans-unit>
        <trans-unit id="952f4e6659d04ec5f193202b5fddffcc0087004e" translate="yes" xml:space="preserve">
          <source>A unique integer number associated with each vocabulary item in the table. This can be used as a foreign key on other tables in the database.</source>
          <target state="translated">一个与表中每个词汇项目相关联的唯一整数。这可以作为数据库中其他表的外键。</target>
        </trans-unit>
        <trans-unit id="0fe70411c725bc0721714f08714a5a3f518456c0" translate="yes" xml:space="preserve">
          <source>A valid rollback journal begins with a header in the following format:</source>
          <target state="translated">有效的回滚日志以下列格式的标题开始。</target>
        </trans-unit>
        <trans-unit id="9323ac27e089e4d34d2bcc6e9f8a53b215a87e94" translate="yes" xml:space="preserve">
          <source>A value of 10 (0x0a) means the page is a leaf index b-tree page.</source>
          <target state="translated">值为10(0x0a)表示该页是叶索引b树页。</target>
        </trans-unit>
        <trans-unit id="62e1a106666132bc7aa0c524ac57c51e9c1fa6f1" translate="yes" xml:space="preserve">
          <source>A value of 13 (0x0d) means the page is a leaf table b-tree page.</source>
          <target state="translated">值为13(0x0d)表示该页是叶表b树页。</target>
        </trans-unit>
        <trans-unit id="40f1a1f1a6aa95dae3ca3a5407b50cea28bcd1e7" translate="yes" xml:space="preserve">
          <source>A value of 2 (0x02) means the page is an interior index b-tree page.</source>
          <target state="translated">值为2(0x02)表示该页是内部索引b树页。</target>
        </trans-unit>
        <trans-unit id="63a906019a3e0d60d30d9b9306736264578b9862" translate="yes" xml:space="preserve">
          <source>A value of 5 (0x05) means the page is an interior table b-tree page.</source>
          <target state="translated">值为5(0x05)表示该页为内表b树页。</target>
        </trans-unit>
        <trans-unit id="98aefbc577505a102a4bdbd9d45da156baa1724a" translate="yes" xml:space="preserve">
          <source>A value with storage class NULL is considered less than any other value (including another value with storage class NULL).</source>
          <target state="translated">一个存储类为NULL的值被认为小于任何其他值(包括另一个存储类为NULL的值)。</target>
        </trans-unit>
        <trans-unit id="61966bda21e838b4a385c022331516a90f448e33" translate="yes" xml:space="preserve">
          <source>A variable-length integer or &quot;varint&quot; is a static Huffman encoding of 64-bit twos-complement integers that uses less space for small positive values. A varint is between 1 and 9 bytes in length. The varint consists of either zero or more bytes which have the high-order bit set followed by a single byte with the high-order bit clear, or nine bytes, whichever is shorter. The lower seven bits of each of the first eight bytes and all 8 bits of the ninth byte are used to reconstruct the 64-bit twos-complement integer. Varints are big-endian: bits taken from the earlier byte of the varint are more significant than bits taken from the later bytes.</source>
          <target state="translated">变长整数或 &quot;varint &quot;是64位双补整数的静态赫夫曼编码,对小的正值使用较少的空间。一个varint的长度在1到9个字节之间。varint由零或多个高阶位设置的字节组成,后面是一个高阶位清除的单字节,或者是九个字节,以较短者为准。前8个字节的低7位和第9个字节的全部8位被用来重建64位双补码整数。Varints是大字段的:从varint的前一个字节取的位比从后一个字节取的位更重要。</target>
        </trans-unit>
        <trans-unit id="39d2c41c22785c16d3ddf35c480bf3c0b5dd588a" translate="yes" xml:space="preserve">
          <source>A varint which is the integer key</source>
          <target state="translated">一个整数键的varint。</target>
        </trans-unit>
        <trans-unit id="8fee174cbc89434778acfe5a3e125ad5320c50ab" translate="yes" xml:space="preserve">
          <source>A varint which is the integer key, a.k.a. &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;&quot;</source>
          <target state="translated">varint是整数键，又名&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="7dcfb4fd379871a1c7b556422d5224ce7bad5762" translate="yes" xml:space="preserve">
          <source>A varint which is the total number of bytes of key payload, including any overflow</source>
          <target state="translated">一个varint,是密钥有效载荷的总字节数,包括任何溢出。</target>
        </trans-unit>
        <trans-unit id="a3d513baeec19bb3a29eb1d68e0c4ec488b8735e" translate="yes" xml:space="preserve">
          <source>A varint which is the total number of bytes of payload, including any overflow</source>
          <target state="translated">有效载荷的总字节数,包括任何溢出。</target>
        </trans-unit>
        <trans-unit id="da04ae498ca0dc39858789333261d6656f640502" translate="yes" xml:space="preserve">
          <source>A version control system (VCS) will typically store the evolving versions of a project as a directed acyclic graph (DAG). Call each version of the project a &quot;checkin&quot;. A single checkin can have zero or more parents. Most checkins (except the first) have a single parent, but in the case of a merge, a checkin might have two or three or more parents. A schema to keep track of checkins and the order in which they occur might look something like this:</source>
          <target state="translated">版本控制系统(VCS)通常会将一个项目的不断发展的版本存储为有向无环图(DAG)。将项目的每个版本称为 &quot;checkin&quot;。单个checkin可以有零个或多个父版本。大多数的checkin(除了第一个版本)都只有一个父版本,但是在合并的情况下,一个checkin可能有两个、三个或者更多的父版本。追踪签到和签到顺序的模式可能是这样的:</target>
        </trans-unit>
        <trans-unit id="881d501220206ee1c616806563f13fecfb51dbf6" translate="yes" xml:space="preserve">
          <source>A virtual filesystem (VFS) is an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that SQLite uses to interact with the underlying operating system. Most SQLite builds come with a single default VFS that is appropriate for the host computer. New VFSes can be registered and existing VFSes can be unregistered. The following interfaces are provided.</source>
          <target state="translated">虚拟文件系统（VFS）是SQLite用于与基础操作系统进行交互的&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象。大多数SQLite构建都带有适合主机的单个默认VFS。可以注册新的VFS，而可以注销现有的VFS。提供以下接口。</target>
        </trans-unit>
        <trans-unit id="1900bfd100646a0b3b036033184bd610a0f59cc1" translate="yes" xml:space="preserve">
          <source>A virtual filesystem (VFS) is an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that SQLite uses to interact with the underlying operating system. Most SQLite builds come with a single default VFS that is appropriate for the host computer. New VFSes can be registered and existing VFSes can be unregistered. The following interfaces are provided.</source>
          <target state="translated">虚拟文件系统（VFS）是SQLite用于与基础操作系统进行交互的&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象。大多数SQLite构建都带有适合主机的单个默认VFS。可以注册新的VFS，而可以注销现有的VFS。提供以下接口。</target>
        </trans-unit>
        <trans-unit id="97b11082572e398dba7e2062d48e57376c3d93de" translate="yes" xml:space="preserve">
          <source>A virtual table implementation must be able to support an arbitrary number of simultaneously open cursors.</source>
          <target state="translated">一个虚拟表的实现必须能够支持任意数量的同时打开的游标。</target>
        </trans-unit>
        <trans-unit id="56cb3efe7eb44df0ba67e5ea661e95ce4f842882" translate="yes" xml:space="preserve">
          <source>A virtual table is an object that is registered with an open SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. From the perspective of an SQL statement, the virtual table object looks like any other table or view. But behind the scenes, queries and updates on a virtual table invoke callback methods of the virtual table object instead of reading and writing on the database file.</source>
          <target state="translated">虚拟表是在打开的SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接中&lt;/a&gt;注册的对象。从SQL语句的角度来看，虚拟表对象看起来像任何其他表或视图。但是在后台，对虚拟表的查询和更新将调用虚拟表对象的回调方法，而不是对数据库文件进行读写。</target>
        </trans-unit>
        <trans-unit id="52af07e40184e006612d2e3054e64de5f1d7c832" translate="yes" xml:space="preserve">
          <source>A virtual table is created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句创建虚拟表。</target>
        </trans-unit>
        <trans-unit id="a893a3a1c0e0b537926a2530a012fcadd49c1a89" translate="yes" xml:space="preserve">
          <source>A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement. There is no DROP VIRTUAL TABLE statement.</source>
          <target state="translated">使用普通的&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;语句销毁虚拟表。没有DROP VIRTUAL TABLE语句。</target>
        </trans-unit>
        <trans-unit id="847101905322620243ed31c601c382674aa4a14b" translate="yes" xml:space="preserve">
          <source>A virtual table is eponymous if its &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is the exact same function as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, or if the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL. The &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is called when a virtual table is first created using the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method is invoked whenever a database connection attaches to or reparses a schema. When these two methods are the same, that indicates that the virtual table has no persistent state that needs to be created and destroyed.</source>
          <target state="translated">一个虚拟表是同名如果其&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法是完全相同的功能作为&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法，或者如果&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法是NULL。该&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;当使用第一次创建一个虚拟表方法被调用&lt;a href=&quot;lang_createvtab&quot;&gt;创建虚拟TABLE&lt;/a&gt;语句。该&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法被调用每当数据库连接附连到或重新解析的模式。当这两种方法相同时，表明虚拟表没有需要创建和销毁的持久状态。</target>
        </trans-unit>
        <trans-unit id="353f0b8410ad856bf5ebf8e7164ab137690e2e5f" translate="yes" xml:space="preserve">
          <source>A virtual table might represent an in-memory data structures. Or it might represent a view of data on disk that is not in the SQLite format. Or the application might compute the content of the virtual table on demand.</source>
          <target state="translated">一个虚拟表可能代表一个内存中的数据结构。或者它可能代表磁盘上的数据视图,但不是SQLite格式的。或者,应用程序可能会按需计算虚拟表的内容。</target>
        </trans-unit>
        <trans-unit id="a4f90d299472ce309a8e439b029daf5f8f8923b0" translate="yes" xml:space="preserve">
          <source>A virtual table module is created by filling in a persistent instance of this structure and passing a pointer to that instance to &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt;. The registration remains valid until it is replaced by a different module or until the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; closes. The content of this structure must not change while it is registered with any database connection.</source>
          <target state="translated">通过填充此结构的持久实例并将该实例的指针传递到&lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;来创建虚拟表模块。该注册将一直保持有效，直到被其他模块替换或&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;关闭为止。向任何数据库连接注册该结构时，其内容均不得更改。</target>
        </trans-unit>
        <trans-unit id="38351d643190ff2e0c5028a024cfec96116efe36" translate="yes" xml:space="preserve">
          <source>A virtual table module is created by filling in a persistent instance of this structure and passing a pointer to that instance to &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt;. The registration remains valid until it is replaced by a different module or until the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; closes. The content of this structure must not change while it is registered with any database connection.</source>
          <target state="translated">通过填充此结构的持久实例并将该实例的指针传递到&lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;或&lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;来创建虚拟表模块。该注册将一直保持有效，直到被其他模块替换或&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;关闭为止。向任何数据库连接注册该结构时，其内容均不得更改。</target>
        </trans-unit>
        <trans-unit id="94ab9a8c810266d9131b7dc3abfde1084e5a3827" translate="yes" xml:space="preserve">
          <source>A virtual table returns all integers between 1 and 4294967295.</source>
          <target state="translated">虚拟表返回1到4294967295之间的所有整数。</target>
        </trans-unit>
        <trans-unit id="9550c8ab6f8d693fb2f5399ce989472075011998" translate="yes" xml:space="preserve">
          <source>A virtual table that implements a spelling correction engine.</source>
          <target state="translated">一个实现拼写校正引擎的虚拟表。</target>
        </trans-unit>
        <trans-unit id="8d81c8273172f3de70ea8fa615e0e6a43a86ed85" translate="yes" xml:space="preserve">
          <source>A virtual table that prints diagnostic information on stdout when its key methods are invoked. Intended for interactive analysis and debugging of virtual table interfaces.</source>
          <target state="translated">一个虚拟表,当它的关键方法被调用时,会在stdout上打印诊断信息。用于虚拟表接口的交互式分析和调试。</target>
        </trans-unit>
        <trans-unit id="5e16ff1f72c104772393373b9711e80e90eaa372" translate="yes" xml:space="preserve">
          <source>A virtual table that represents a comma-separated-value or CSV file (&lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt;) as a read-only table so that it can be used as part of a larger query.</source>
          <target state="translated">一个虚拟表，将逗号分隔值或CSV文件（&lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt;）表示为只读表，以便可以将其用作较大查询的一部分。</target>
        </trans-unit>
        <trans-unit id="adf39798b9f95adc35fd6772c7cbfb7068e01df6" translate="yes" xml:space="preserve">
          <source>A virtual table, which provides read and write access to archives stored in the file-system.</source>
          <target state="translated">一个虚拟表,它提供对存储在文件系统中的档案的读写访问。</target>
        </trans-unit>
        <trans-unit id="0516d8f39a8906e53dce6da52e21c642d9370cf8" translate="yes" xml:space="preserve">
          <source>A well-written C program will typically contain some defensive conditionals which in practice are always true or always false. This leads to a programming dilemma: Does one remove defensive code in order to obtain 100% branch coverage?</source>
          <target state="translated">一个写得很好的C程序通常会包含一些防御性条件,这些条件在实践中总是真或总是假。这就导致了一个编程难题:是否要为了获得100%的分支覆盖率而删除防御性代码?</target>
        </trans-unit>
        <trans-unit id="a3522671a3a254f98c06c7d8eb6a707b7852ebea" translate="yes" xml:space="preserve">
          <source>A width of 0 means the column width is chosen automatically. Unspecified columns widths to go zero. Hence, the command &quot;.width&quot; with no arguments sets all columns widths to zero and hence causes all column widths to be determine automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f05d1eb22dd9a9ee6d24e61fd43de0311fb625" translate="yes" xml:space="preserve">
          <source>A window function is an SQL function where the input values are taken from a &quot;window&quot; of one or more rows in the results set of a SELECT statement.</source>
          <target state="translated">窗口函数是一个SQL函数,其中输入值是从SELECT语句结果集中的一个或多个行的 &quot;窗口 &quot;中提取的。</target>
        </trans-unit>
        <trans-unit id="95e1d6e7e3fb96b500c945c549b86f711da8262a" translate="yes" xml:space="preserve">
          <source>A working &lt;a href=&quot;https://zlib.net&quot;&gt;zlib compression library&lt;/a&gt; is needed in order for the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; to operate.</source>
          <target state="translated">为了使&lt;a href=&quot;cli#sqlar&quot;&gt;.archive命令&lt;/a&gt;运行，需要一个有效的&lt;a href=&quot;https://zlib.net&quot;&gt;zlib压缩库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12ba0d7954a4428935b75868db48e0376c9b0d38" translate="yes" xml:space="preserve">
          <source>A wrapped pile-of-files format is a compromise between a full custom file format and a pure pile-of-files format. A wrapped pile-of-files format is not an opaque blob in the same sense as a custom format, since the component parts can still be accessed using any common ZIP archiver, but the format is not quite as accessible as a pure pile-of-files format because one does still need the ZIP archiver, and one cannot normally use command-line tools like &quot;find&quot; on the file hierarchy without first un-zipping it. On the other hand, a wrapped pile-of-files format does preserve the document metaphor by putting all content into a single disk file. And because it is compressed, the wrapped pile-of-files format tends to be more compact.</source>
          <target state="translated">封装的文件堆格式是完全的自定义文件格式和纯粹的文件堆格式之间的折中。包裹式文件堆格式并不像自定义格式那样是一个不透明的小球,因为仍然可以使用任何常见的ZIP存档器来访问其组成部分,但这种格式并不像纯文件堆格式那样容易访问,因为我们仍然需要ZIP存档器,而且如果不先解压,通常不能在文件层次结构上使用 &quot;查找 &quot;等命令行工具。另一方面,包裹的文件堆格式确实保留了文件的隐喻,把所有的内容都放在一个磁盘文件中。而且由于它是压缩的,包裹式文件堆格式往往更紧凑。</target>
        </trans-unit>
        <trans-unit id="b0cb831fafd0869c861cfe72928b427adff2aa0c" translate="yes" xml:space="preserve">
          <source>A write-ahead log or WAL file is used in place of a rollback journal when SQLite is operating in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. As with the rollback journal, the purpose of the WAL file is to implement atomic commit and rollback. The WAL file is always located in the same directory as the database file and has the same name as the database file except with the 4 characters &quot;&lt;b&gt;-wal&lt;/b&gt;&quot; appended. The WAL file is created when the first connection to the database is opened and is normally removed when the last connection to the database closes. However, if the last connection does not shutdown cleanly, the WAL file will remain in the filesystem and will be automatically cleaned up the next time the database is opened.</source>
          <target state="translated">当SQLite在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;运行时，将使用预写日志或WAL文件代替回滚日志。与回滚日志一样，WAL文件的目的是实现原子提交和回滚。 WAL文件始终与数据库文件位于同一目录中，并且与数据库文件具有相同的名称，只是附加了4个字符&amp;ldquo; &lt;b&gt;-wal&lt;/b&gt; &amp;rdquo;。 WAL文件是在打开与数据库的第一个连接时创建的，通常在与数据库的最后一个连接关闭时会被删除。但是，如果最后一个连接没有彻底关闭，则WAL文件将保留在文件系统中，并在下次打开数据库时自动清除。</target>
        </trans-unit>
        <trans-unit id="7f97d795973bc84aa355c2feb5c3e28a10896757" translate="yes" xml:space="preserve">
          <source>A zero-terminated string containing the text of one or more SQL statements and/or queries to be processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606ec6e9bd8a8ff2ad14e5fade3f264471e82251" translate="yes" xml:space="preserve">
          <source>AAA</source>
          <target state="translated">AAA</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="dc1f44b95b4f44c4b87ebcf57cafc6780d0a90b6" translate="yes" xml:space="preserve">
          <source>ACID transactions using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;，&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;和&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK进行&lt;/a&gt; ACID事务</target>
        </trans-unit>
        <trans-unit id="2b9f1cf5c4d33807129af3dcb41af0a491f4cda7" translate="yes" xml:space="preserve">
          <source>ACTION</source>
          <target state="translated">ACTION</target>
        </trans-unit>
        <trans-unit id="f9460492306d4b99cd31848c3a99a26a7e978d96" translate="yes" xml:space="preserve">
          <source>ADD</source>
          <target state="translated">ADD</target>
        </trans-unit>
        <trans-unit id="ee5600b2ed97ece803d7f4350448a1f4928404a3" translate="yes" xml:space="preserve">
          <source>AFL has proven remarkably adept at finding arcane bugs in SQLite. Most of the findings have been assert() statements where the conditional was false under obscure circumstances. But AFL has also found a fair number of crash bugs in SQLite, and even a few cases where SQLite computed incorrect results.</source>
          <target state="translated">事实证明,AFL非常善于发现SQLite中的神秘错误。大多数发现都是assert()语句,其中条件在不明显的情况下是假的。但AFL也发现了相当多的SQLite中的崩溃bug,甚至还有一些SQLite计算出错误结果的情况。</target>
        </trans-unit>
        <trans-unit id="5d726e4e98d71e7677fc370d3c1ae46220f46b39" translate="yes" xml:space="preserve">
          <source>AFL proved adept at finding arcane bugs in SQLite. Most of the findings have been assert() statements where the conditional was false under obscure circumstances. But AFL has also found a fair number of crash bugs in SQLite, and even a few cases where SQLite computed incorrect results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63edc193e8cfcf6757dd5596309d5a764f92ace2" translate="yes" xml:space="preserve">
          <source>AFP locking style. This locking style is used for network file systems that use the AFP (Apple Filing Protocol) protocol. Locks are obtained by calling the library function _AFPFSSetLock().</source>
          <target state="translated">AFP锁定风格。这种锁定方式用于使用AFP(Apple Filing Protocol)协议的网络文件系统。通过调用库函数_AFPFSSetLock()获得锁。</target>
        </trans-unit>
        <trans-unit id="aedfd73052985c2f41211e623add2af653060807" translate="yes" xml:space="preserve">
          <source>AFTER</source>
          <target state="translated">AFTER</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="6e69e31990a7343ff088d4c32eea14ef655df385" translate="yes" xml:space="preserve">
          <source>ALTER</source>
          <target state="translated">ALTER</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">ALTER TABLE</target>
        </trans-unit>
        <trans-unit id="dc1fbac7d45ba56f622f7752b89525d62ceed128" translate="yes" xml:space="preserve">
          <source>ALTER TABLE ADD COLUMN</source>
          <target state="translated">ALTER TABLE ADD COLUMN</target>
        </trans-unit>
        <trans-unit id="094aafb4c8ae4eba399881e4d9b84c158bb3ff0a" translate="yes" xml:space="preserve">
          <source>ALTER TABLE RENAME</source>
          <target state="translated">ALTER TABLE RENAME</target>
        </trans-unit>
        <trans-unit id="b5b6c520c273175237f91ec319fe56f82283ec27" translate="yes" xml:space="preserve">
          <source>ALTER TABLE RENAME COLUMN</source>
          <target state="translated">ALTER TABLE RENAME COLUMN</target>
        </trans-unit>
        <trans-unit id="f9d0d0176fb0a7f55f27682b7d026c807b2a0515" translate="yes" xml:space="preserve">
          <source>ALTER TABLE uses double-quotes instead of single-quotes for quoting filenames.</source>
          <target state="translated">ALTER TABLE使用双引号代替单引号来引用文件名。</target>
        </trans-unit>
        <trans-unit id="ae0ecf3287dbfbb668b86fe771af6cf210ce9334" translate="yes" xml:space="preserve">
          <source>ALWAYS</source>
          <target state="translated">ALWAYS</target>
        </trans-unit>
        <trans-unit id="8ca598e81cf4b7eae20f25366c64a9099ce76a39" translate="yes" xml:space="preserve">
          <source>ALWAYS(X)</source>
          <target state="translated">ALWAYS(X)</target>
        </trans-unit>
        <trans-unit id="7b4e17353a4bd1a4f2d336a59d39168308ceecbc" translate="yes" xml:space="preserve">
          <source>ALWAYS(X) and NEVER(X) functions are used in places where we always want the test to occur even though the developers believe the value of X is always true or false. For example, the sqlite3BtreeCloseCursor() routine shown must remove the closing cursor from a linked list of all cursors. We know that the cursor is on the list, so that the loop must terminate by the &quot;break&quot; statement, but it is convenient to use the ALWAYS(X) test at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=4371&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=4371&lt;/a&gt; to prevent running off the end of the linked list in case there is an error in some other part of the code that has corrupted the linked list.</source>
          <target state="translated">即使开发人员认为X的值始终为true或false，也总是在我们总是希望进行测试的地方使用ALWAYS（X）和NEVER（X）函数。例如，显示的sqlite3BtreeCloseCursor（）例程必须从所有游标的链接列表中删除结束游标。我们知道游标在列表中，因此循环必须以&amp;ldquo; break&amp;rdquo;语句终止，但是在&lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=4371&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3&lt;/a&gt;上使用ALWAYS（X）测试很方便吗？ ln = 4371可以防止在链表损坏的代码的其他部分出现错误的情况下运行链表的末尾。</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="1a397ebb8cf61587cd521ec01e5c6b51276f91a4" translate="yes" xml:space="preserve">
          <source>ANSI Common Lisp</source>
          <target state="translated">ANSI通用语言</target>
        </trans-unit>
        <trans-unit id="d00bb3f3b7c7b8815b6dcf237dd16aab9744eca8" translate="yes" xml:space="preserve">
          <source>AS</source>
          <target state="translated">AS</target>
        </trans-unit>
        <trans-unit id="eaffec78401451424652480dc382235348ce1b66" translate="yes" xml:space="preserve">
          <source>ASC</source>
          <target state="translated">ASC</target>
        </trans-unit>
        <trans-unit id="166240989b0ab1b8695abcaef83da0a4918a2fb9" translate="yes" xml:space="preserve">
          <source>ASCII rendering of the float</source>
          <target state="translated">浮点数的ASCII渲染</target>
        </trans-unit>
        <trans-unit id="6b519334032a98f7c2594012c3b3e7e13014c677" translate="yes" xml:space="preserve">
          <source>ASCII rendering of the integer</source>
          <target state="translated">整数的ASCII渲染</target>
        </trans-unit>
        <trans-unit id="8a5ebc115bc75bb938a3838103c3725bf90efb01" translate="yes" xml:space="preserve">
          <source>ATTACH</source>
          <target state="translated">ATTACH</target>
        </trans-unit>
        <trans-unit id="33ca34fea5ce451e0bc66a6eadd28cb502c9e81b" translate="yes" xml:space="preserve">
          <source>ATTACH DATABASE</source>
          <target state="translated">附上数据库</target>
        </trans-unit>
        <trans-unit id="1ac676774c3a8c1551764b1d83b7d37f669fb5a0" translate="yes" xml:space="preserve">
          <source>ATTACH and DETACH as well as some other operations cause existing prepared statements to expire.</source>
          <target state="translated">ATTACH和DETACH以及其他一些操作会导致现有的已编制报表过期。</target>
        </trans-unit>
        <trans-unit id="21a7e17a976b425553bc577b3148824d2a1f1a44" translate="yes" xml:space="preserve">
          <source>AUTOINCREMENT</source>
          <target state="translated">AUTOINCREMENT</target>
        </trans-unit>
        <trans-unit id="5c70ef0cc48907c519166dce4b32226739e45e67" translate="yes" xml:space="preserve">
          <source>AUTOINCREMENT keyword supported on INTEGER PRIMARY KEY</source>
          <target state="translated">在INTEGER PRIMARY KEY上支持AUTOINCREMENT关键字。</target>
        </trans-unit>
        <trans-unit id="76bb2a7951c7bb2c965f22c9a57e2ce25974df9a" translate="yes" xml:space="preserve">
          <source>Abbreviations are applied in the multitest.tcl output so that each th3make invocation will fit on a single 80-column output line. The initial &quot;th3make&quot; verb is omitted. &quot;~&quot; is shorthand for &quot;-DSQLITE_&quot; and &quot;++&quot; is stands for &quot;-DSQLITE_ENABLE&quot;. Hence, multitest.tcl output line</source>
          <target state="translated">在 multitest.tcl 的输出中使用了缩写,这样每个 th3make 的调用都能在 80 列的输出行中找到合适的位置。最初的 &quot;th3make &quot;动词被省略。&quot;~&quot;是&quot;-DSQLITE_&quot;的简写,&quot;++&quot;代表&quot;-DSQLITE_ENABLE&quot;。因此,multitest.tcl的输出行是这样的</target>
        </trans-unit>
        <trans-unit id="aa097a59aa23d1ea05fcdf2e722330d9e25e4b14" translate="yes" xml:space="preserve">
          <source>Abortable</source>
          <target state="translated">Abortable</target>
        </trans-unit>
        <trans-unit id="a87b7bc256c5e187e5504df77ba712267f376ec4" translate="yes" xml:space="preserve">
          <source>About OpenDocument And OpenDocument Presentation</source>
          <target state="translated">关于OpenDocument和OpenDocument演示</target>
        </trans-unit>
        <trans-unit id="f32e574abd9aafdacaa9afd3405d7877d90e54cb" translate="yes" xml:space="preserve">
          <source>Accept &quot;Z&quot; as the zulu timezone at the end of date strings</source>
          <target state="translated">接受 &quot;Z &quot;作为日期字符串末尾的祖鲁时区。</target>
        </trans-unit>
        <trans-unit id="6ce752666b5e444987daa4b6966df37d55bde025" translate="yes" xml:space="preserve">
          <source>Accept column names in parentheses.</source>
          <target state="translated">接受括号中的列名。</target>
        </trans-unit>
        <trans-unit id="c0213d4fd54eabb051f311ba8f2befe3b9c69a5c" translate="yes" xml:space="preserve">
          <source>Access is coordinated in WAL mode using both the legacy DELETE-mode locks controlled by the xLock and xUnlock methods of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and the WAL locks controlled by the xShmLock method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">访问被同时使用由所述的XLOCK和xUnlock方法控制的遗留DELETE模式锁在WAL模式协调&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象和WAL锁具由的xShmLock方法控制&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="80d3ef128ce8adb3705e036419e075fdb4f48299" translate="yes" xml:space="preserve">
          <source>Access the filesystem of the host computer as if it were a database table</source>
          <target state="translated">像访问数据库表一样访问主机的文件系统。</target>
        </trans-unit>
        <trans-unit id="61521a7d6f538076f32bc9879102eb6d96388ec7" translate="yes" xml:space="preserve">
          <source>Access to records via &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is highly optimized and very fast.</source>
          <target state="translated">通过&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;对记录的访问已高度优化且非常快速。</target>
        </trans-unit>
        <trans-unit id="b0ba54a3a4413a8377f766e7307b65f628b16b98" translate="yes" xml:space="preserve">
          <source>Accessible Content</source>
          <target state="translated">可访问内容</target>
        </trans-unit>
        <trans-unit id="c17f44cb688221742030703d589c802bf0664eb2" translate="yes" xml:space="preserve">
          <source>Accommodation can be made for words that are not spelled as they sound by making additional entries into the virtual table for the same word, but adding an alternative spelling in the &quot;soundslike&quot; column. For example, the canonical entry for &quot;psalm&quot; would be this:</source>
          <target state="translated">可以通过在虚拟表格中为同一单词增加条目,但在 &quot;音似 &quot;栏中增加另一种拼法,来适应那些不按其发音拼写的单词。例如,&quot;psalm &quot;的规范条目是这样的:</target>
        </trans-unit>
        <trans-unit id="6705b13fdc28369e54f6bdd712ca9a4db4cbf219" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, a URI consists of a scheme, an authority, a path, a query string, and a fragment. The scheme is always required. One of either the authority or the path is also always required. The query string and fragment are optional.</source>
          <target state="translated">根据&lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;，URI由方案，授权，路径，查询字符串和片段组成。该方案始终是必需的。权限或路径之一也始终是必需的。查询字符串和片段是可选的。</target>
        </trans-unit>
        <trans-unit id="05b6d5d4d823df2e184aec7120d805247860b8ea" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, PRIMARY KEY should always imply NOT NULL. Unfortunately, due to a bug in some early versions, this is not the case in SQLite. Unless the column is an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; or the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or the column is declared NOT NULL, SQLite allows NULL values in a PRIMARY KEY column. SQLite could be fixed to conform to the standard, but doing so might break legacy applications. Hence, it has been decided to merely document the fact that SQLite allowing NULLs in most PRIMARY KEY columns.</source>
          <target state="translated">根据SQL标准，PRIMARY KEY应该始终暗示NOT NULL。不幸的是，由于某些早期版本中的错误，在SQLite中并非如此。除非该列是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;或表是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表或将该列声明为NOT NULL，否则SQLite允许在PRIMARY KEY列中使用NULL值。可以修复SQLite以使其符合标准，但是这样做可能会破坏旧版应用程序。因此，决定仅记录SQLite在大多数PRIMARY KEY列中允许NULL的事实。</target>
        </trans-unit>
        <trans-unit id="3dec6852ffb8757da75544af2803b809f2b130fe" translate="yes" xml:space="preserve">
          <source>Acquire a PENDING lock then an EXCLUSIVE lock on the database file. (Note: Do not acquire a RESERVED lock because that would make other processes think the journal was no longer hot.) If we fail to acquire these locks it means another process is already trying to do the rollback. In that case, drop all locks, close the database, and return SQLITE_BUSY.</source>
          <target state="translated">在数据库文件上获取一个PENDING锁,然后获取一个EXCLUSIVE锁。(注意:不要获取RESERVED锁,因为这样会让其他进程认为该日志不再是热的。)如果我们没有获得这些锁,就意味着另一个进程已经在尝试进行回滚。在这种情况下,放弃所有锁,关闭数据库,并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="1eb030a7cb15f50d9dc25d4f04078043f2675ff3" translate="yes" xml:space="preserve">
          <source>Activate schema editing using &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt;激活模式编辑。</target>
        </trans-unit>
        <trans-unit id="5c78b30e5c862affd42bb5f1c596df83d2545ece" translate="yes" xml:space="preserve">
          <source>Actually, SQLite will easily do 50,000 or more &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements per second on an average desktop computer. But it will only do a few dozen transactions per second. Transaction speed is limited by the rotational speed of your disk drive. A transaction normally requires two complete rotations of the disk platter, which on a 7200RPM disk drive limits you to about 60 transactions per second.</source>
          <target state="translated">实际上，在普通台式计算机上，SQLite 每秒可以轻松地执行50,000个或更多&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句。但是它每秒只能进行几十笔交易。事务处理速度受磁盘驱动器旋转速度的限制。一个事务通常需要磁盘盘完整旋转两次，而在7200RPM磁盘驱动器上，这会将您限制为每秒大约60个事务。</target>
        </trans-unit>
        <trans-unit id="5bc81cc5fb5822da9569ed8c4f8843257c8f59e9" translate="yes" xml:space="preserve">
          <source>Actually, if one is only concerned with atomic and consistent writes and is willing to forego durable writes, the sync operation does not need to wait until the content is completely stored on persistent media. Instead, the sync operation can be thought of as an I/O barrier. As long as all writes that occur before the sync are completed before any write that happens after the sync, no database corruption will occur. If sync is operating as an I/O barrier and not as a true sync, then a power failure or system crash might cause one or more previously committed transactions to roll back (in violation of the &quot;durable&quot; property of &quot;ACID&quot;) but the database will at least continue to be consistent, and that is what most people care about.</source>
          <target state="translated">实际上,如果只关心原子和一致的写入,并且愿意放弃持久的写入,同步操作就不需要等到内容完全存储在持久性介质上。相反,同步操作可以被认为是一个I/O屏障。只要在同步之前发生的所有写入都在同步之后发生的任何写入之前完成,就不会发生数据库损坏。如果同步操作是作为I/O屏障而不是真正的同步,那么断电或系统崩溃可能会导致之前提交的一个或多个事务回滚(违反了 &quot;ACID &quot;的 &quot;持久 &quot;属性),但数据库至少会继续保持一致,这也是大多数人关心的。</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="8ac6e880abe35cd3b7a1b0834fe47d4337bfddaa" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt;, &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt;, and &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt; options for the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface.</source>
          <target state="translated">为&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;接口添加&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt;，&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt;和&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="58cbb6e0f1775750062ac5669e49e04ab20b20ce" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;fts3#fts4&quot;&gt;full text search&lt;/a&gt; capabilities to the slide deck, or across multiple slide decks.</source>
          <target state="translated">将&lt;a href=&quot;fts3#fts4&quot;&gt;全文搜索&lt;/a&gt;功能添加到幻灯片组或跨多个幻灯片组。</target>
        </trans-unit>
        <trans-unit id="8dfeff2912792716526d37688fba56051d490d1d" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;rescode#readonly_dbmoved&quot;&gt;SQLITE_READONLY_DBMOVED&lt;/a&gt; error code, returned at the beginning of a transaction, to indicate that the underlying database file has been renamed or moved out from under SQLite.</source>
          <target state="translated">添加在事务开始时返回的&lt;a href=&quot;rescode#readonly_dbmoved&quot;&gt;SQLITE_READONLY_DBMOVED&lt;/a&gt;错误代码，以表明基础数据库文件已被重命名或已从SQLite下移出。</target>
        </trans-unit>
        <trans-unit id="1c3f88960217978a5bdd7bc25245b711a532a875" translate="yes" xml:space="preserve">
          <source>Add A Changeset To A Changegroup</source>
          <target state="translated">添加一个变更组到一个变更组</target>
        </trans-unit>
        <trans-unit id="9c66f22d5376c90e1654bc1561e3076b1f2090a2" translate="yes" xml:space="preserve">
          <source>Add C-language APIs for discovering SQL keywords used by SQLite: &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt;.</source>
          <target state="translated">添加用于发现SQLite使用的SQL关键字的C语言API：&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count（）&lt;/a&gt;，&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name（）&lt;/a&gt;和&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65ffcfc767739ad0ab5f4bd4c91e85118f99542a" translate="yes" xml:space="preserve">
          <source>Add C-language APIs for dynamic strings based on the &lt;a href=&quot;c3ref/str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">为基于&lt;a href=&quot;c3ref/str&quot;&gt;sqlite3_str&lt;/a&gt;对象的动态字符串添加C语言API 。</target>
        </trans-unit>
        <trans-unit id="2c5a3264f3bad4a3d08e2dbdc79dc6adf56d9043" translate="yes" xml:space="preserve">
          <source>Add Content To A Dynamic String</source>
          <target state="translated">添加内容到一个动态字符串</target>
        </trans-unit>
        <trans-unit id="6d839bba6e835d3e16ff5554d03f6b92e3f024d0" translate="yes" xml:space="preserve">
          <source>Add FD_CLOEXEC to all open files under Unix.</source>
          <target state="translated">将FD_CLOEXEC添加到Unix下所有打开的文件中。</target>
        </trans-unit>
        <trans-unit id="45653642fbaec798956daf72ef08f996b3b84141" translate="yes" xml:space="preserve">
          <source>Add VxWorks-7 as an officially supported and tested platform.</source>
          <target state="translated">增加VxWorks-7作为官方支持和测试的平台。</target>
        </trans-unit>
        <trans-unit id="e51c9c34fae46cbf2d267f197a36b3b0082c2414" translate="yes" xml:space="preserve">
          <source>Add a &quot;fragmentation&quot; measurement in the output of sqlite3_analyzer.</source>
          <target state="translated">在sqlite3_analyzer的输出中增加一个 &quot;碎片 &quot;测量。</target>
        </trans-unit>
        <trans-unit id="233e69a92bb5e64e50fa57ffccc06dceae5fcbce" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;http://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=7d539cedb1c&amp;amp;v2=ebad891b7494d&amp;amp;smhdr&quot;&gt;one-character fix&lt;/a&gt; for a problem that might cause incorrect query results on a query that mixes DISTINCT, GROUP BY in a subquery, and ORDER BY. &lt;a href=&quot;http://www.sqlite.org/src/info/98825a79ce1456863&quot;&gt;Ticket 98825a79ce14&lt;/a&gt;.</source>
          <target state="translated">为一个可能导致对混合DISTINCT，子查询中的GROUP BY和ORDER BY的查询产生不正确查询结果的问题添加一个&lt;a href=&quot;http://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=7d539cedb1c&amp;amp;v2=ebad891b7494d&amp;amp;smhdr&quot;&gt;字符修复&lt;/a&gt;。&lt;a href=&quot;http://www.sqlite.org/src/info/98825a79ce1456863&quot;&gt;机票98825a79ce14&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fef40390b6db6660e8fd5ac547942832b3f403b" translate="yes" xml:space="preserve">
          <source>Add a few #ifdef and build script changes to address compilation issues that appeared after the 3.9.0 release.</source>
          <target state="translated">增加一些#ifdef和构建脚本的修改,以解决3.9.0版本后出现的编译问题。</target>
        </trans-unit>
        <trans-unit id="30713a4bbbb832f4d4a12dd5d80665712406baac" translate="yes" xml:space="preserve">
          <source>Add a limit counter to the query planner to prevent excessive &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; times for certain pathological SQL inputs.</source>
          <target state="translated">向查询计划器添加一个限制计数器，以防止某些病理SQL输入出现过多的&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;时间。</target>
        </trans-unit>
        <trans-unit id="6b8f1d1e0ae5e1fa1781dadcf39fcd78b4b595c9" translate="yes" xml:space="preserve">
          <source>Add a makefile target &quot;sqlite3.c&quot; that builds an amalgamation containing the core SQLite library C code in a single file.</source>
          <target state="translated">增加一个makefile目标 &quot;sqlite3.c&quot;,在一个文件中建立一个包含核心SQLite库C代码的amalgamation。</target>
        </trans-unit>
        <trans-unit id="ad83f8f8177f2cca17785adb28404967ca258c75" translate="yes" xml:space="preserve">
          <source>Add a new test harness called &quot;mptester&quot; used to verify correct operation when multiple processes are using the same database file at the same time.</source>
          <target state="translated">增加一个名为 &quot;mptester &quot;的新测试线束,用于在多个进程同时使用同一个数据库文件时验证操作是否正确。</target>
        </trans-unit>
        <trans-unit id="e847129cbafc1b300962a09db16bffecab4a4530" translate="yes" xml:space="preserve">
          <source>Add a new type of fts5vocab virtual table - &quot;instance&quot; - that provides direct access to an FTS5 full-text index at the lowest possible level.</source>
          <target state="translated">增加一种新的fts5vocab虚拟表--&quot;实例&quot;--提供对最低级别的fts5全文索引的直接访问。</target>
        </trans-unit>
        <trans-unit id="feb097c7808e448486c05ee42c0ad6699287c273" translate="yes" xml:space="preserve">
          <source>Add a numeric version number to the sqlite3.h include file.</source>
          <target state="translated">在 sqlite3.h 包含的文件中添加一个数字版本号。</target>
        </trans-unit>
        <trans-unit id="192cfdedd0a31a6c0e19a0d0ffbfa19825b53d8b" translate="yes" xml:space="preserve">
          <source>Add a zero terminator if needed</source>
          <target state="translated">如有需要,可加一个零终止符</target>
        </trans-unit>
        <trans-unit id="d0f1497ef21ab12913bab71ba40d0af254e81913" translate="yes" xml:space="preserve">
          <source>Add additional forward compatibility to the future version 3.2 database file format.</source>
          <target state="translated">增加对未来3.2版数据库文件格式的前向兼容性。</target>
        </trans-unit>
        <trans-unit id="41a75e7708f6493171875bbdcb71d6c0d0c35512" translate="yes" xml:space="preserve">
          <source>Add all changes within the changeset (or patchset) in buffer pData (size nData bytes) to the changegroup.</source>
          <target state="translated">将缓冲区pData(大小为nData字节)中的所有变化添加到changegroup中。</target>
        </trans-unit>
        <trans-unit id="53df8d5802795502e64b884c78d43fbcd180d6bf" translate="yes" xml:space="preserve">
          <source>Add an extension loading entry point routine that looks like something the following:</source>
          <target state="translated">添加一个扩展加载切入点例程,看起来像下面的东西。</target>
        </trans-unit>
        <trans-unit id="99f1bd5a0f02484338a165c19358793d065e8df6" translate="yes" xml:space="preserve">
          <source>Add demonstration code showing how to build a VFS for a raw mass storage without a filesystem.</source>
          <target state="translated">增加演示代码,展示如何为一个没有文件系统的原始大容量存储建立一个VFS。</target>
        </trans-unit>
        <trans-unit id="074e15d829469130ecedfd553fe1780886ad13ec" translate="yes" xml:space="preserve">
          <source>Add extension functions &lt;a href=&quot;cli#fileio&quot;&gt;readfile(X) and writefile(X,Y)&lt;/a&gt; (using code copy/pasted from fileio.c in the previous bullet) to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">将扩展功能&lt;a href=&quot;cli#fileio&quot;&gt;readfile（X）和writefile（X，Y）&lt;/a&gt;（使用上一项目符号fileio.c中的代码复制/粘贴）添加到&lt;a href=&quot;cli&quot;&gt;命令行shell中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5609b29ef4b019538ab2911fb3b91dc194584696" translate="yes" xml:space="preserve">
          <source>Add files to existing archive &lt;em&gt;if&lt;/em&gt; they have changed.</source>
          <target state="translated">&lt;em&gt;如果&lt;/em&gt;文件已更改，&lt;em&gt;则将&lt;/em&gt;它们添加到现有存档中。</target>
        </trans-unit>
        <trans-unit id="3e66dc568f4c182e96e2de9065612a0db049a1a8" translate="yes" xml:space="preserve">
          <source>Add files to existing archive.</source>
          <target state="translated">将文件添加到现有档案中。</target>
        </trans-unit>
        <trans-unit id="acbd82da92201959c1e073134cea4dbf8415586f" translate="yes" xml:space="preserve">
          <source>Add forward compatibility to the future version 3.2 database file format.</source>
          <target state="translated">增加对未来3.2版数据库文件格式的前瞻性兼容性。</target>
        </trans-unit>
        <trans-unit id="dd1bef805d2eee9b43a065117a80304d349f0efa" translate="yes" xml:space="preserve">
          <source>Add functions prototypes for the database encryption API.</source>
          <target state="translated">增加数据库加密API的函数原型。</target>
        </trans-unit>
        <trans-unit id="ee62379e8314b790802298bb169ed3d7eef9f2d4" translate="yes" xml:space="preserve">
          <source>Add interfaces sqlite3_quota_ferror() and sqlite3_quota_file_available() to the test_quota.c module.</source>
          <target state="translated">在test_quota.c模块中添加接口sqlite3_quota_ferror()和sqlite3_quota_file_available()。</target>
        </trans-unit>
        <trans-unit id="d9994f198ea8554c8d135ebfa9e7a42a508d9f76" translate="yes" xml:space="preserve">
          <source>Add new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;.</source>
          <target state="translated">添加新的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c37dbbd1aba851a9c8e067c055285579f7ba5410" translate="yes" xml:space="preserve">
          <source>Add new verbs to &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; so that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method of virtual tables can declare the virtual table as &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6207d3440089bac343c8fc43288997a2214b79" translate="yes" xml:space="preserve">
          <source>Add option support for LIMIT and ORDER BY clauses on &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements. Only works if SQLite is compiled with &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;和&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句上添加对LIMIT和ORDER BY子句的选项支持。仅在使用&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;编译SQLite时有效。</target>
        </trans-unit>
        <trans-unit id="efbdccfa6f84dcf86953bb91270d5a08c92376ba" translate="yes" xml:space="preserve">
          <source>Add options &quot;--expanded&quot;, &quot;--normalized&quot;, &quot;--plain&quot;, &quot;--profile&quot;, &quot;--row&quot;, &quot;--stmt&quot;, and &quot;--close&quot; to the &quot;.trace&quot; command.</source>
          <target state="translated">在&quot;.trace &quot;命令中增加&quot;--expanded&quot;、&quot;--normalized&quot;、&quot;--plain&quot;、&quot;--profile&quot;、&quot;--row&quot;、&quot;--stmt &quot;和&quot;--close &quot;等选项。</target>
        </trans-unit>
        <trans-unit id="4cbca09144fd7e3e8b43bc8c2d286fd40deac6d2" translate="yes" xml:space="preserve">
          <source>Add options &lt;b&gt;-encoding&lt;/b&gt; and &lt;b&gt;-tcl-uses-utf&lt;/b&gt; to the &lt;b&gt;sqlite&lt;/b&gt; TCL command.</source>
          <target state="translated">添加选项&lt;b&gt;-编码&lt;/b&gt;和&lt;b&gt;-tcl用途，UTF&lt;/b&gt;到&lt;b&gt;sqlite的&lt;/b&gt; TCL命令。</target>
        </trans-unit>
        <trans-unit id="0c2f37fd7facad2de96bd5183bac5e1e1511c68e" translate="yes" xml:space="preserve">
          <source>Add options to the &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; command: --csv, --ascii, --skip</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d573825baf33d38c179e029681eca20a46ccd519" translate="yes" xml:space="preserve">
          <source>Add pluggable tokenizers and &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;ICU&lt;/a&gt; tokenization support to FTS2</source>
          <target state="translated">向FTS2 添加可插入标记器和&lt;a href=&quot;http://www.icu-project.org/&quot;&gt;ICU&lt;/a&gt;标记支持</target>
        </trans-unit>
        <trans-unit id="72c6bdab5b3258b6277e55104bb87d93b720f14a" translate="yes" xml:space="preserve">
          <source>Add support for &quot;.open --hexdb&quot;. The &quot;&lt;a href=&quot;https://sqlite.org/src/doc/trunk/tool/dbtotxt.md&quot;&gt;dbtotxt&lt;/a&gt;&quot; utility program used to generate the text for the &quot;hexdb&quot; is added to the source tree.</source>
          <target state="translated">添加对&amp;ldquo; .open --hexdb&amp;rdquo;的支持。用于生成&amp;ldquo; hexdb&amp;rdquo;文本的&amp;ldquo; &lt;a href=&quot;https://sqlite.org/src/doc/trunk/tool/dbtotxt.md&quot;&gt;dbtotxt&lt;/a&gt; &amp;rdquo;实用程序已添加到源树中。</target>
        </trans-unit>
        <trans-unit id="a0763ade3c8a449006c413b6f49449ce7b3a928a" translate="yes" xml:space="preserve">
          <source>Add support for &quot;&lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; FOLLOWING&lt;/a&gt;&quot; boundaries in RANGE &lt;a href=&quot;windowfunctions#framespec&quot;&gt;frames&lt;/a&gt;.</source>
          <target state="translated">添加对RANGE &lt;a href=&quot;windowfunctions#framespec&quot;&gt;帧中&lt;/a&gt; &amp;ldquo; &lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/a&gt; &amp;rdquo;和&amp;ldquo; &lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; FOLLOWING&lt;/a&gt; &amp;rdquo;边界的支持。</target>
        </trans-unit>
        <trans-unit id="e92f21bcec77d71c0f65f3070792505ed0c70690" translate="yes" xml:space="preserve">
          <source>Add support for &quot;PRAGMA page_size&quot; to adjust the page size of the database.</source>
          <target state="translated">增加对 &quot;PRAGMA page_size &quot;的支持,调整数据库的页面大小。</target>
        </trans-unit>
        <trans-unit id="aa2fb3ed1f060dfe837a3d960578d49b6bc22685" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3c5f5d30415f9f1977e35ba188ec9b5fcd474e" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;.</source>
          <target state="translated">添加对&lt;a href=&quot;mmap&quot;&gt;内存映射I / O的支持&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc4c8688bed6db9be32019244a2d807910dea0cc" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;</source>
          <target state="translated">添加对&lt;a href=&quot;partialindex&quot;&gt;部分索引的&lt;/a&gt;支持</target>
        </trans-unit>
        <trans-unit id="c5b2de4466aa197bc12dce31206322740e3db16d" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;rtree#auxcol&quot;&gt;auxiliary columns in r-tree tables&lt;/a&gt;.</source>
          <target state="translated">添加对&lt;a href=&quot;rtree#auxcol&quot;&gt;r-tree表中辅助列的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="f90c29b7cfc3c62f6507d98b86aed5242ee68ae7" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;</source>
          <target state="translated">添加对&lt;a href=&quot;uri&quot;&gt;URI文件名的&lt;/a&gt;支持</target>
        </trans-unit>
        <trans-unit id="af696b60eb69d945c8a46227c312eb8878086caa" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;</source>
          <target state="translated">添加对&lt;a href=&quot;windowfunctions&quot;&gt;窗口功能的&lt;/a&gt;支持</target>
        </trans-unit>
        <trans-unit id="136f3b0eed5bac09b5f3815f7575bda175da3514" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions#grouptype&quot;&gt;GROUPS frames&lt;/a&gt;.</source>
          <target state="translated">添加对&lt;a href=&quot;windowfunctions#grouptype&quot;&gt;GROUPS框架的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="e66dce38847e4f4f6cc41e4cccbb39be56c45c40" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions#wchaining&quot;&gt;window chaining&lt;/a&gt;.</source>
          <target state="translated">添加对&lt;a href=&quot;windowfunctions#wchaining&quot;&gt;窗口链接的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="212edd25833b5883700b116710f87eea867169b2" translate="yes" xml:space="preserve">
          <source>Add support for DEFERRED, IMMEDIATE, and EXCLUSIVE transactions.</source>
          <target state="translated">增加对DEFERRED、IMMEDIATE和EXCLUSIVE交易的支持。</target>
        </trans-unit>
        <trans-unit id="5fb939adf84fb0194534bbaf8a41088037bb5c1e" translate="yes" xml:space="preserve">
          <source>Add support for INSERT OR REPLACE, INSERT OR IGNORE, and UPDATE OR REPLACE in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表中&lt;/a&gt;添加对INSERT OR REPLACE，INSERT OR IGNORE和UPDATE OR REPLACE的支持。</target>
        </trans-unit>
        <trans-unit id="f2330e77a6f10374d78e1306109d17dffa46e862" translate="yes" xml:space="preserve">
          <source>Add support for PostgreSQL-style &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;.</source>
          <target state="translated">添加对PostgreSQL风格的&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="890cc871d57b4e2f53773580ef56c71b18a22739" translate="yes" xml:space="preserve">
          <source>Add support for coverage testing of VDBE programs using the &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_VDBE_COVERAGE&lt;/a&gt; verb of &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;的&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_VDBE_COVERAGE&lt;/a&gt;动词添加对VDBE程序的覆盖测试的支持。</target>
        </trans-unit>
        <trans-unit id="be6c363a6bf564dc52386b7db08ec41552cf1d89" translate="yes" xml:space="preserve">
          <source>Add support for handling &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt; virtual tables. &lt;a href=&quot;#vtab&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">添加对处理&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;，&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;和&lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt;虚拟表的支持。&lt;a href=&quot;#vtab&quot;&gt;有关&lt;/a&gt;详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="a526c3a38229774d8ba86548def1a8d12a36b235" translate="yes" xml:space="preserve">
          <source>Add support for renaming columns within a table using ALTER TABLE</source>
          <target state="translated">增加对表内使用ALTER TABLE重命名列的支持。</target>
        </trans-unit>
        <trans-unit id="d659c9c8cb6c1f04393b0fc5e63bbdac64002cf9" translate="yes" xml:space="preserve">
          <source>Add support for tab-completion using the &lt;a href=&quot;completion&quot;&gt;COMPLETION extension&lt;/a&gt;, for both readline and linenoise.</source>
          <target state="translated">使用&lt;a href=&quot;completion&quot;&gt;COMPLETION扩展名&lt;/a&gt;添加对制表符补全的支持，用于读取行和行噪声。</target>
        </trans-unit>
        <trans-unit id="f4eee573107dab889c4b93bbd22bffbdf1483817" translate="yes" xml:space="preserve">
          <source>Add support for the &quot;--maxsize N&quot; option on &quot;.open --deserialize&quot;.</source>
          <target state="translated">在&quot;.open --deserialize &quot;中增加对&quot;--maxsize N &quot;选项的支持。</target>
        </trans-unit>
        <trans-unit id="31f5d3e263c4687cf09a721220bb511aa4a69c6f" translate="yes" xml:space="preserve">
          <source>Add support for the &lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;FILTER clause on aggregate functions&lt;/a&gt;.</source>
          <target state="translated">增加&lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;对聚合函数FILTER子句的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="f217130627272aa13b670d0e6f0d5167655ce0bd" translate="yes" xml:space="preserve">
          <source>Add support for the &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS FIRST&lt;/a&gt; and &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS LAST&lt;/a&gt; syntax in &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; clauses.</source>
          <target state="translated">在&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;子句中添加对&lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS FIRST&lt;/a&gt;和&lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS LAST&lt;/a&gt;语法的支持。</target>
        </trans-unit>
        <trans-unit id="f4007f3ce6829066fa4409e2ecd136e62637d894" translate="yes" xml:space="preserve">
          <source>Add support for the full SQL-92 join syntax and LEFT OUTER JOINs.</source>
          <target state="translated">增加对完整的SQL-92连接语法和LEFT OUTER JOIN的支持。</target>
        </trans-unit>
        <trans-unit id="3a2eb33317dae4a033cc092362d492fb572cccd4" translate="yes" xml:space="preserve">
          <source>Add support for wildcard parameters of the form: &quot;?nnn&quot;</source>
          <target state="translated">增加对表单通配符参数的支持。&quot;?nnnn&quot;</target>
        </trans-unit>
        <trans-unit id="1eb80b8d534ca7c36dc1e214c6909a01fde00f37" translate="yes" xml:space="preserve">
          <source>Add support the &lt;a href=&quot;windowfunctions#wexcls&quot;&gt;EXCLUDE clause&lt;/a&gt;.</source>
          <target state="translated">添加对&lt;a href=&quot;windowfunctions#wexcls&quot;&gt;EXCLUDE子句的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="4ab8baa6625378dcd2fbc2b48fe42102792d59fe" translate="yes" xml:space="preserve">
          <source>Add tclsqlite.c to the libsqlite.a library</source>
          <target state="translated">将tclsqlite.c添加到libsqlite.a库中。</target>
        </trans-unit>
        <trans-unit id="936423dc9b571e197d4ed47a549d3e24bf5f5c1f" translate="yes" xml:space="preserve">
          <source>Add tests to make sure that tclsqlite was compiled using Tcl header files and libraries that match.</source>
          <target state="translated">增加测试以确保tclsqlite是使用Tcl头文件和匹配的库编译的。</target>
        </trans-unit>
        <trans-unit id="8e0200d4b2125e37622440b4e128b278c449eb8c" translate="yes" xml:space="preserve">
          <source>Add the &quot;%token_class&quot; directive to &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; and use it to simplify the grammar.</source>
          <target state="translated">将&amp;ldquo;％token_class&amp;rdquo;指令添加到&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器，&lt;/a&gt;并使用它来简化语法。</target>
        </trans-unit>
        <trans-unit id="283b2638c2b05ae208073cb37d46fd5320238943" translate="yes" xml:space="preserve">
          <source>Add the &quot;--async&quot; option to the &quot;.backup&quot; command.</source>
          <target state="translated">在&quot;.backup &quot;命令中增加&quot;--async &quot;选项。</target>
        </trans-unit>
        <trans-unit id="f6e8b7b2093500ea36f5f180a7347d1d5a53d8fe" translate="yes" xml:space="preserve">
          <source>Add the &quot;--memtrace&quot; command-line option, to show all memory allocations and deallocations.</source>
          <target state="translated">增加&quot;--memtrace &quot;命令行选项,以显示所有的内存分配和deallocations。</target>
        </trans-unit>
        <trans-unit id="216e54fa647db35fda70c92921d3229237ed92dd" translate="yes" xml:space="preserve">
          <source>Add the &quot;.binary&quot; and &quot;.limits&quot; commands to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">将&amp;ldquo; .binary&amp;rdquo;和&amp;ldquo; .limits&amp;rdquo;命令添加到&lt;a href=&quot;cli&quot;&gt;命令行shell中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d8da8fe6a9987104191ff2baa0e3404f2a667db" translate="yes" xml:space="preserve">
          <source>Add the &quot;.cd&quot; command.</source>
          <target state="translated">添加&quot;.cd &quot;命令。</target>
        </trans-unit>
        <trans-unit id="f2d55280d1b7b3a8bbfa8326a3e6f14a48e7308e" translate="yes" xml:space="preserve">
          <source>Add the &quot;.clone&quot; and &quot;.save&quot; commands to the command-line shell.</source>
          <target state="translated">在命令行shell中添加&quot;.clone &quot;和&quot;.save &quot;命令。</target>
        </trans-unit>
        <trans-unit id="c7d25cbe44023d988e7e9d81da8b1c5eafbc6826" translate="yes" xml:space="preserve">
          <source>Add the &quot;.eqp trace&quot; option on builds with SQLITE_DEBUG, to enable bytecode program listing with indentation and &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;PRAGMA vdbe_trace&lt;/a&gt; all in one step.</source>
          <target state="translated">在使用SQLITE_DEBUG的版本中添加&amp;ldquo; .eqp trace&amp;rdquo;选项，以一步一步启用带有缩进和&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;PRAGMA vdbe_trace的&lt;/a&gt;字节码程序列表。</target>
        </trans-unit>
        <trans-unit id="97816312767ca4a2c31df9a27f1fb491af457876" translate="yes" xml:space="preserve">
          <source>Add the &quot;.filectrl&quot; command useful for testing.</source>
          <target state="translated">增加对测试有用的&quot;.filectrl &quot;命令。</target>
        </trans-unit>
        <trans-unit id="762e62184ff88d2ac7f6d5e9106bb08dbc9e2cb4" translate="yes" xml:space="preserve">
          <source>Add the &quot;.import&quot; command to the command-line shell.</source>
          <target state="translated">在命令行shell中添加&quot;.import &quot;命令。</target>
        </trans-unit>
        <trans-unit id="cc49dc138146b590b8cff67298e595fca2d6f169" translate="yes" xml:space="preserve">
          <source>Add the &quot;.progress&quot; command for accessing the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface.</source>
          <target state="translated">添加&amp;ldquo; .progress&amp;rdquo;命令以访问&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="b7c0e14ee7666efcfedda1a8139570d6579e1c44" translate="yes" xml:space="preserve">
          <source>Add the &quot;.recover&quot; command which tries to recover as much content as possible from a corrupt database file.</source>
          <target state="translated">增加&quot;.recover &quot;命令,试图从损坏的数据库文件中恢复尽可能多的内容。</target>
        </trans-unit>
        <trans-unit id="1e8a4b92340d9f7a1f000bec88f280625487d118" translate="yes" xml:space="preserve">
          <source>Add the &quot;.system&quot; and &quot;.once&quot; commands to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">将&amp;ldquo; .system&amp;rdquo;和&amp;ldquo; .once&amp;rdquo;命令添加到&lt;a href=&quot;cli&quot;&gt;命令行shell中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88db3041288101d122dcba112957a35b89342c78" translate="yes" xml:space="preserve">
          <source>Add the &quot;.testcase&quot; and &quot;.check&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;dot-commands&lt;/a&gt;.</source>
          <target state="translated">添加&amp;ldquo; .testcase&amp;rdquo;和&amp;ldquo; .check&amp;rdquo; &lt;a href=&quot;cli#dotcmd&quot;&gt;点命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80eb0002e6ca30dbe7265165c28f78bf3c05f869" translate="yes" xml:space="preserve">
          <source>Add the &quot;.wheretrace&quot; command when compiled with SQLITE_DEBUG</source>
          <target state="translated">在使用SQLITE_DEBUG编译时增加&quot;.wheretrace &quot;命令。</target>
        </trans-unit>
        <trans-unit id="8804479c26e1da45bb9e3ed0888fbc0d4a08ae1c" translate="yes" xml:space="preserve">
          <source>Add the &quot;totype.c&quot; extension, implementing the tointeger() and toreal() SQL functions.</source>
          <target state="translated">增加 &quot;totype.c &quot;扩展,实现tointeger()和toreal()SQL函数。</target>
        </trans-unit>
        <trans-unit id="92a34239c6cf2de2a3fdbbe86a2b80a08fe2e86b" translate="yes" xml:space="preserve">
          <source>Add the --bom option to the &lt;a href=&quot;cli#dotexcel&quot;&gt;.excel&lt;/a&gt;, &lt;a href=&quot;cli#dotoutput&quot;&gt;.output&lt;/a&gt;, and &lt;a href=&quot;cli#dotoutput&quot;&gt;.once&lt;/a&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df81e72aa83e90414fe2ffd4c6cb48365750ab99" translate="yes" xml:space="preserve">
          <source>Add the -withoutnulls option to the &lt;a href=&quot;tclsqlite#eval&quot;&gt;TCL interface eval method&lt;/a&gt;.</source>
          <target state="translated">将-withoutnulls选项添加到&lt;a href=&quot;tclsqlite#eval&quot;&gt;TCL接口eval方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe5b9c333c6038520094761f864493e2e7097cc4" translate="yes" xml:space="preserve">
          <source>Add the .oom command in debugging builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f125709e724b34ac5ad47f8eda53803f5734890" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; option for &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;.</source>
          <target state="translated">为&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;添加&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="40592c218ccd34fab463deb3f03be7da30417f9c" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; verb for &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">为&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;添加&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;动词。</target>
        </trans-unit>
        <trans-unit id="e48cfd1c7357fb4864216d4d254e3beabe8b5a2d" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachewrite&quot;&gt;SQLITE_DBSTATUS_CACHE_WRITE&lt;/a&gt; option for &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">为&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;添加&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachewrite&quot;&gt;SQLITE_DBSTATUS_CACHE_WRITE&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="be8b97d6b9385048b55638f312823bb2eb008ce5" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; file control.</source>
          <target state="translated">添加&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;文件控件。</target>
        </trans-unit>
        <trans-unit id="081364f71e5fefa3da91ea51b10405c027faaabe" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt; for setting an upper bound on the size of the in-memory database created by sqlite3_deserialize. The default upper bound is 1GiB, or whatever alternative value is specified by &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;) and/or &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt;.</source>
          <target state="translated">添加&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;文件控件，&lt;/a&gt;以设置sqlite3_deserialize创建的内存数据库大小的上限。默认上限为1GiB，或者由&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;）和/或&lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt;指定的替代值。</target>
        </trans-unit>
        <trans-unit id="5d92af1fb4c4ac1e07a26f5836df488794b6bbdc" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface.</source>
          <target state="translated">添加&lt;a href=&quot;c3ref/cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="fe034b4f2512875ab8ea3e02c36867f516b685b5" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/drop_modules&quot;&gt;sqlite3_drop_modules()&lt;/a&gt; interface, allowing applications to disable automatically loaded virtual tables that they do not need.</source>
          <target state="translated">添加&lt;a href=&quot;c3ref/drop_modules&quot;&gt;sqlite3_drop_modules（）&lt;/a&gt;接口，使应用程序可以禁用不需要的自动加载的虚拟表。</target>
        </trans-unit>
        <trans-unit id="35fb0feea0a1d59c3a8842f9214443f77d92d83e" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface and the corresponding &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1930b99359d377b2cc8ba418ec5abbff446f6fae" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/open#opennofollow&quot;&gt;SQLITE_OPEN_NOFOLLOW&lt;/a&gt; option to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; that prevents SQLite from opening symbolic links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d27cce565db8490729a43e1af27acdeb1a1d96" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application-defined page cache&lt;/a&gt;</source>
          <target state="translated">添加&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;应用程序定义的页面缓存&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a4d7eada875b03c7029bca58ac2ddc67b6735f11" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interfaces when the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">使用&lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt;编译时选项时，添加&lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize（）&lt;/a&gt;和&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="065e4967252d67f2418c2b348070eac9ee82255f" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt; convenience interface.</source>
          <target state="translated">添加&lt;a href=&quot;c3ref/strglob&quot;&gt;sqlite3_strglob（）&lt;/a&gt;便捷接口。</target>
        </trans-unit>
        <trans-unit id="bb552cbe49d24f288fc511724cd559eb4a233c0e" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_key()&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52490b8c94f339853539d2cd7b35574401e395a9" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface in support of &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">添加&lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;接口以支持带有&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;子句。</target>
        </trans-unit>
        <trans-unit id="3e9c1c8302237fd30d6977796970b681fda7464c" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;cksumvfs&quot;&gt;checksum VFS shim&lt;/a&gt; to the set of run-time loadable extensions included in the source tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f5bebd726b497704665ee703792c5087bc4e88" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. Setting this option to 0 disables automatic indices by default.</source>
          <target state="translated">添加&lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt;编译时选项。将此选项设置为0会默认禁用自动索引。</target>
        </trans-unit>
        <trans-unit id="470112a79227f7c994e11abc7f3c3d991569cdaa" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#default_lookaside&quot;&gt;SQLITE_DEFAULT_LOOKASIDE&lt;/a&gt; compile-time option.</source>
          <target state="translated">添加&lt;a href=&quot;compile#default_lookaside&quot;&gt;SQLITE_DEFAULT_LOOKASIDE&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="85aebd6ee91874adb96cb2db93f6f4d317b58eb7" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option.</source>
          <target state="translated">添加&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="21a90d69aeda9911ff14bd96ba3dda734bfd8d53" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#rtree_int_only&quot;&gt;SQLITE_RTREE_INT_ONLY&lt;/a&gt; compile-time option to force the &lt;a href=&quot;rtree&quot;&gt;R*Tree Extension Module&lt;/a&gt; to use integer instead of floating point values for both storage and computation.</source>
          <target state="translated">添加&lt;a href=&quot;compile#rtree_int_only&quot;&gt;SQLITE_RTREE_INT_ONLY&lt;/a&gt;编译时选项，以强制&lt;a href=&quot;rtree&quot;&gt;R * Tree扩展模块&lt;/a&gt;对存储和计算使用整数而不是浮点值。</target>
        </trans-unit>
        <trans-unit id="e8f43e6254598c7b3221cade8d257bd4fa709b38" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;dbstat#dbstatagg&quot;&gt;aggregated mode&lt;/a&gt; feature to the &lt;a href=&quot;dbstat&quot;&gt;DBSTAT virtual table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e9f2fd2f640e3984cdc406903ee8672531ce05" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;FTS4 &quot;merge&quot; command&lt;/a&gt;, the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;FTS4 &quot;automerge&quot; command&lt;/a&gt;, and the &lt;a href=&quot;fts3#*fts4ickcmd&quot;&gt;FTS4 &quot;integrity-check&quot; command&lt;/a&gt;.</source>
          <target state="translated">添加&lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;FTS4&amp;ldquo;合并&amp;rdquo;命令&lt;/a&gt;，在&lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;FTS4&amp;ldquo;automerge&amp;rdquo;命令&lt;/a&gt;，和&lt;a href=&quot;fts3#*fts4ickcmd&quot;&gt;FTS4&amp;ldquo;诚信检查&amp;rdquo;命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98046a6bd29ea22d322eeeda3a2f3bdacd96dcab" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; loadable extension - a VFS shim that measures I/O together with an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that provides access to the measurements.</source>
          <target state="translated">添加&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt;可加载扩展-一个测量I / O的VFS填充程序以及一个提供访问测量结果的&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cd3c312e6d704d9ddb06fdac7e44b6ba43e781a" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause.</source>
          <target state="translated">添加&lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt;子句。</target>
        </trans-unit>
        <trans-unit id="93f9efcb02f9ffd6cbf45dbb655ea785d5db4c65" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt; that converts a LEFT JOIN into an ordinary JOIN if there exist terms in the WHERE clause that would prevent the extra all-NULL row of the LEFT JOIN from appearing in the output set.</source>
          <target state="translated">添加&lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN强度降低优化&lt;/a&gt;，如果WHERE子句中存在可以防止LEFT JOIN的多余全空行出现在输出集中的条件，则该优化将LEFT JOIN转换为普通JOIN。</target>
        </trans-unit>
        <trans-unit id="6294f954692677e23d4407af3d20a5f13384a9c1" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; command that causes the &quot;ALTER TABLE RENAME&quot; command to behave as it did in SQLite versions 3.24.0 and earlier: references to the renamed table inside the bodies of triggers and views are not updated. This new pragma provides a compatibility work around for older programs that expected the older, wonky behavior of ALTER TABLE RENAME.</source>
          <target state="translated">添加&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt;命令，该命令使&amp;ldquo; ALTER TABLE RENAME&amp;rdquo;命令的行为与SQLite 3.24.0及更早版本中的行为相同：触发器和视图主体内对重命名表的引用不会更新。这个新的实用程序为期望较旧的ALTER TABLE RENAME较旧行为的较旧程序提供了兼容性解决方案。</target>
        </trans-unit>
        <trans-unit id="b9e0bbc3322ff734087f22e70d84d21a6e7a30fe" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xSavepoint&lt;/a&gt;, &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRelease&lt;/a&gt; and &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRollbackTo&lt;/a&gt; methods in &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; in support of &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; for virtual tables.</source>
          <target state="translated">在&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;中添加&lt;a href=&quot;vtab#xsavepoint&quot;&gt;xSavepoint&lt;/a&gt;，&lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRelease&lt;/a&gt;和&lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRollbackTo&lt;/a&gt;方法以支持虚拟表的&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ed36cb9eb24ef6e4831d3cb6e75c5a505ce11d8" translate="yes" xml:space="preserve">
          <source>Add the &lt;b&gt;sqlite_version[]&lt;/b&gt; string constant to the library</source>
          <target state="translated">将&lt;b&gt;sqlite_version []&lt;/b&gt;字符串常量添加到库中</target>
        </trans-unit>
        <trans-unit id="1a77c4f39c42e3d8e465cea41bb54ff783957906" translate="yes" xml:space="preserve">
          <source>Add the COLLATE operator used to explicitly set the collating sequence used by an expression. This feature is considered experimental pending additional testing.</source>
          <target state="translated">增加 COLLATE 操作符,用于明确设置表达式使用的整理序列。这个功能被认为是试验性的,有待额外的测试。</target>
        </trans-unit>
        <trans-unit id="29546c6fbd4241b614f52b701e19fb42190f52db" translate="yes" xml:space="preserve">
          <source>Add the MEMORY option to the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">将MEMORY选项添加到&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08441390d486d4a704f4d3ebdd1c1a4095467616" translate="yes" xml:space="preserve">
          <source>Add the ability for INSERT and UPDATE statements to refer to the &quot;rowid&quot; (or &quot;_rowid_&quot; or &quot;oid&quot;) columns.</source>
          <target state="translated">增加INSERT和UPDATE语句引用 &quot;rowid&quot;(或&quot;_rowid_&quot;或 &quot;oid&quot;)列的功能。</target>
        </trans-unit>
        <trans-unit id="91d47c24f96a5ac57ed4cd528de551cd89df640b" translate="yes" xml:space="preserve">
          <source>Add the ability to change the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; status of a database by setting the auto_vaccum pragma and VACUUMing the database.</source>
          <target state="translated">通过设置auto_vaccum编译指示和对数据库进行VACUUM，可以更改数据库的&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;状态。</target>
        </trans-unit>
        <trans-unit id="90b4842e5d50e9cfd8c2600caa26cf77f6f838dc" translate="yes" xml:space="preserve">
          <source>Add the ability to do MSVC Windows builds from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;amalgamation tarball&lt;/a&gt;.</source>
          <target state="translated">添加从&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;合并tarball&lt;/a&gt;进行MSVC Windows构建的功能。</target>
        </trans-unit>
        <trans-unit id="b9cc0bb08d1187beca47dd9f85ca607d55ca39f7" translate="yes" xml:space="preserve">
          <source>Add the ability to find a full-index-scan query plan for queries using &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; which previously would fail with &quot;no query solution&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4db540a1419635a899fe1e123412560851c41e" translate="yes" xml:space="preserve">
          <source>Add the ability to implement FROM clause subqueries as coroutines rather that manifesting the subquery into a temporary table.</source>
          <target state="translated">增加了将FROM子句作为coroutine实现的能力,而不是将子查询表现为一个临时表。</target>
        </trans-unit>
        <trans-unit id="641284aafcb663d3733121dbe152ab06583bd76f" translate="yes" xml:space="preserve">
          <source>Add the ability to put TABLE.* in the column list of a SELECT statement.</source>
          <target state="translated">增加在SELECT语句的列列表中放入TABLE.*的功能。</target>
        </trans-unit>
        <trans-unit id="76eab5ccc29a6c69261726a47189c3c56c533ee9" translate="yes" xml:space="preserve">
          <source>Add the ability to put a single .command in the second argument of the sqlite shell</source>
          <target state="translated">在sqlite shell的第二个参数中增加一个.command的功能。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
