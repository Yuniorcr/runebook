<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="c4cf7b97c327f9d39106315e4a050c0b0f137cef" translate="yes" xml:space="preserve">
          <source>Hierarchical Query Examples</source>
          <target state="translated">层次化查询示例</target>
        </trans-unit>
        <trans-unit id="62ae978c372dd625e1ad5bee3c09efecd27ef87c" translate="yes" xml:space="preserve">
          <source>High Reliability</source>
          <target state="translated">高可靠性</target>
        </trans-unit>
        <trans-unit id="5b43fa59ed80a4a74e2345ca9a7be4d00498a5de" translate="yes" xml:space="preserve">
          <source>High-Level Query Language</source>
          <target state="translated">高级查询语言</target>
        </trans-unit>
        <trans-unit id="f0be6eee61b3f35036173bb461da267d072410b3" translate="yes" xml:space="preserve">
          <source>High-security Value</source>
          <target state="translated">高安全性价值</target>
        </trans-unit>
        <trans-unit id="d4e0f8e3d3d0dc08399c35d69b24eda9dfffeab6" translate="yes" xml:space="preserve">
          <source>Higher level logic within SQLite will normally intercept the error code and create a temporary in-memory shared memory region so that the current process can at least read the content of the database. This result code should not reach the application interface layer.</source>
          <target state="translated">SQLite内部的高层逻辑通常会拦截错误代码,并创建一个临时的内存共享区域,以便当前进程至少可以读取数据库的内容。这个结果代码不应该到达应用接口层。</target>
        </trans-unit>
        <trans-unit id="c3470dae18bb2ebd19bfc00c07871d83ad9669f4" translate="yes" xml:space="preserve">
          <source>Higher order bits of the mFlags parameter must all be zero for now, though they may be used in future enhancements. The definitions for the constants that specify the datatype and a prototype for the sqlite3_carray_bind() function are both available in the auxiliary header file &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/carray.h&quot;&gt;ext/misc/carray.h&lt;/a&gt;.</source>
          <target state="translated">尽管现在可以在将来的增强中使用它们，但mFlags参数的高阶位现在必须全部为零。辅助头文件&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/carray.h&quot;&gt;ext / misc / carray.h&lt;/a&gt;中都提供了用于指定数据类型的常量的定义以及sqlite3_carray_bind（）函数的原型。</target>
        </trans-unit>
        <trans-unit id="8ec8e6f8b27cff894766ae4e4215e6f333126ae8" translate="yes" xml:space="preserve">
          <source>Highest precedence (tightest grouping).</source>
          <target state="translated">最高优先级(最紧密的分组)。</target>
        </trans-unit>
        <trans-unit id="9d8bc8b9f1a6b46c231d4505eec0f99894497892" translate="yes" xml:space="preserve">
          <source>Hint: applications can generate globally unique identifiers using this function together with &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; and/or &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; like this:</source>
          <target state="translated">提示：应用程序可以使用此函数以及&lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex（）&lt;/a&gt;和/或&lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower（）&lt;/a&gt;来生成全局唯一标识符，如下所示：</target>
        </trans-unit>
        <trans-unit id="13895cc550db90756c2c44f981469cdd85261a1d" translate="yes" xml:space="preserve">
          <source>Hints for Debugging SQLite</source>
          <target state="translated">调试SQLite的提示</target>
        </trans-unit>
        <trans-unit id="6b205a779ffaeec5fb12feda7165de7c06e54bbe" translate="yes" xml:space="preserve">
          <source>Historical test cases from &lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;, &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;, and &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; are collected in a set of database files in the main SQLite source tree and then rerun by the &quot;fuzzcheck&quot; utility program whenever one runs &quot;make test&quot;. Fuzzcheck only runs a few thousand &quot;interesting&quot; cases out of the hundreds of millions of cases that the various fuzzers have examined over the years. &quot;Interesting&quot; cases are cases that exhibit previously unseen behavior. Actual bugs found by fuzzers are always included among the interesting test cases, but most of the cases run by fuzzcheck were never actual bugs.</source>
          <target state="translated">来自&lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;，&lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;和&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz的&lt;/a&gt;历史测试用例收集在主SQLite源树中的一组数据库文件中，然后每当运行&amp;ldquo; make test&amp;rdquo;时由&amp;ldquo; fuzzcheck&amp;rdquo;实用程序重新运行。多年来，各种模糊测试人员检查的亿万个案例中，Fuzzcheck仅运行了数千个&amp;ldquo;有趣&amp;rdquo;案例。 &amp;ldquo;有趣&amp;rdquo;的案例是表现出以前看不见的行为的案例。模糊测试人员发现的实际错误始终包含在有趣的测试用例中，但是fuzzcheck运行的大多数情况绝不是实际错误。</target>
        </trans-unit>
        <trans-unit id="67fec9a6d19b7573beec194f9c1e57c883f7bff1" translate="yes" xml:space="preserve">
          <source>Historically, backups (copies) of SQLite databases have been created using the following method:</source>
          <target state="translated">从历史上看,SQLite数据库的备份(副本)是通过以下方法创建的。</target>
        </trans-unit>
        <trans-unit id="a7796946d81b3e384b117135d383fc5e5877941f" translate="yes" xml:space="preserve">
          <source>Historically, the bytecode engine in SQLite is called the &quot;Virtual DataBase Engine&quot; or &quot;VDBE&quot;. This website uses the terms &quot;bytecode engine&quot;, &quot;VDBE&quot;, &quot;virtual machine&quot;, and &quot;bytecode virtual machine&quot; interchangeably, as they all mean the same thing.</source>
          <target state="translated">历史上,SQLite中的字节码引擎被称为 &quot;虚拟数据库引擎 &quot;或 &quot;VDBE&quot;。本网站交替使用术语 &quot;字节码引擎&quot;、&quot;VDBE&quot;、&quot;虚拟机 &quot;和 &quot;字节码虚拟机&quot;,因为它们的意思都一样。</target>
        </trans-unit>
        <trans-unit id="186352c9ed4b1d5538fac7c967930c7dfb52b78f" translate="yes" xml:space="preserve">
          <source>Historically, the return value from xFindFunction() was either zero or one. Zero means that the function is not overloaded and one means that it is overload. The ability to return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater, than means that the function takes two arguments and the function can be used as a boolean in the WHERE clause of a query and that the virtual table is able to exploit that function to speed up the query result. When xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, the value returned becomes the sqlite3_index_info.aConstraint.op value for one of the constraints passed into &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; and the second argument becomes the value corresponding to that constraint that is passed to &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter()&lt;/a&gt;. This enables the xBestIndex()/xFilter implementations to use the function to speed its search.</source>
          <target state="translated">从历史上看，xFindFunction（）的返回值是零或一。零表示该函数未过载，而一则表示该函数过载。在版本3.25.0（2018-09-15）中添加了返回&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;或更大值的功能。如果xFindFunction返回&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;或更大，则表示该函数带有两个参数，并且该函数可用作查询的WHERE子句中的布尔值，并且虚拟表能够利用该函数来加快查询结果。当xFindFunction返回&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;或更大值时，返回的值将成为传递给&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex（）&lt;/a&gt;的约束之一的sqlite3_index_info.aConstraint.op值。第二个参数成为与传递给&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter（）的&lt;/a&gt;约束相对应的值。这使xBestIndex（）/ xFilter实现可以使用该函数加快其搜索速度。</target>
        </trans-unit>
        <trans-unit id="48f87256a37f996b34f071b6b4ef5f1805966dbd" translate="yes" xml:space="preserve">
          <source>Historically, this was not considered a threat. The argument was that if a hostile agent is able to inject arbitrary SQL text into the application, then that agent is already in full control of the application, so letting the hostile agent forge a pointer does not give the agent any new capability.</source>
          <target state="translated">历史上,这并不被认为是一种威胁。其论点是,如果一个敌对代理能够将任意SQL文本注入到应用程序中,那么该代理已经完全控制了应用程序,所以让敌对代理伪造一个指针并不会给代理带来任何新的能力。</target>
        </trans-unit>
        <trans-unit id="edbba65b70f80d24828e3ecb61299d246e18a100" translate="yes" xml:space="preserve">
          <source>Honor all people.</source>
          <target state="translated">尊重所有的人。</target>
        </trans-unit>
        <trans-unit id="bfbddd574d4f950742d8e5d7a49607c23d347f95" translate="yes" xml:space="preserve">
          <source>Honor all.</source>
          <target state="translated">尊敬所有的人。</target>
        </trans-unit>
        <trans-unit id="645a5172c51f2105b78cb24101222af4c2581b31" translate="yes" xml:space="preserve">
          <source>Honor the &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt; flag, which was previously described in the documentation, but was previously a no-op.</source>
          <target state="translated">荣誉&lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt;标志，这是以前的文件中所描述的，但以前是一个空操作。</target>
        </trans-unit>
        <trans-unit id="2fff26aa56e0db9e63e42ae6a74896b210340408" translate="yes" xml:space="preserve">
          <source>Honor the ORDER BY and LIMIT clause of a SELECT even if the result set is used for an INSERT.</source>
          <target state="translated">即使结果集被用于INSERT,也要尊重SELECT的ORDER BY和LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="972205ef02943c809b85189066f29ea5a922b1d8" translate="yes" xml:space="preserve">
          <source>Host parameter names can begin with '@' for compatibility with SQL Server.</source>
          <target state="translated">主机参数名可以以'@'开头,以便与SQL Server兼容。</target>
        </trans-unit>
        <trans-unit id="2107ab6c47208816e9f85a68b6f666b821dd323b" translate="yes" xml:space="preserve">
          <source>Hot Journal Detection</source>
          <target state="translated">热门期刊检测</target>
        </trans-unit>
        <trans-unit id="387adc1437f284bb8f7d821272256c3791f7c532" translate="yes" xml:space="preserve">
          <source>Hot Journal Rollback</source>
          <target state="translated">热门期刊回滚</target>
        </trans-unit>
        <trans-unit id="51a2396551270d6b1b9b0daa06c843f02294bf7a" translate="yes" xml:space="preserve">
          <source>Hot journal files</source>
          <target state="translated">热门日志文件</target>
        </trans-unit>
        <trans-unit id="33f85488d44d0b31b265f227edf83b283232673c" translate="yes" xml:space="preserve">
          <source>Hot journal rollback</source>
          <target state="translated">热期刊回滚</target>
        </trans-unit>
        <trans-unit id="72b9d3b59a2cd3c6b5726c2ec8f20f5cbd8fc2c8" translate="yes" xml:space="preserve">
          <source>How &lt;a href=&quot;queryplanner&quot;&gt;indexing&lt;/a&gt; works.</source>
          <target state="translated">&lt;a href=&quot;queryplanner&quot;&gt;索引&lt;/a&gt;如何工作。</target>
        </trans-unit>
        <trans-unit id="de544e283cfebc5d70d3d7b590e023e13a9bf879" translate="yes" xml:space="preserve">
          <source>How Memory-Mapped I/O Works</source>
          <target state="translated">内存映射I/O如何工作</target>
        </trans-unit>
        <trans-unit id="56b803311ab7e3e616ef538b11ad7fad3dcd0741" translate="yes" xml:space="preserve">
          <source>How SQLite Is Tested</source>
          <target state="translated">SQLite是如何被测试的</target>
        </trans-unit>
        <trans-unit id="bc4f776f31c05645db10ae6924aaa639f110450f" translate="yes" xml:space="preserve">
          <source>How SQLite Works</source>
          <target state="translated">SQLite如何工作</target>
        </trans-unit>
        <trans-unit id="f0b874a1265664f2f8c8240dcb0a141334e57668" translate="yes" xml:space="preserve">
          <source>How To Compile SQLite</source>
          <target state="translated">如何编译SQLite</target>
        </trans-unit>
        <trans-unit id="bac0366a300ac4acaffdcf4c3d4ee83a4619271d" translate="yes" xml:space="preserve">
          <source>How To Corrupt</source>
          <target state="translated">如何腐败</target>
        </trans-unit>
        <trans-unit id="07961a03bdae1448ec20af2c6389f109c109cecd" translate="yes" xml:space="preserve">
          <source>How To Corrupt An SQLite Database File</source>
          <target state="translated">如何破坏一个SQLite数据库文件</target>
        </trans-unit>
        <trans-unit id="ac75035a65466ee12d9ad12dabe0ea72bf4078bd" translate="yes" xml:space="preserve">
          <source>How To Corrupt Your Database Files</source>
          <target state="translated">如何破坏你的数据库文件</target>
        </trans-unit>
        <trans-unit id="6c4dc04d73e3b62534455f3b1b128df4687ca99e" translate="yes" xml:space="preserve">
          <source>How To Download Canonical SQLite Source Code</source>
          <target state="translated">如何下载Canonical SQLite源码</target>
        </trans-unit>
        <trans-unit id="023a32566bba30a34815129fd5e3cc90c1e899ca" translate="yes" xml:space="preserve">
          <source>How VACUUM works</source>
          <target state="translated">VACUUM如何工作</target>
        </trans-unit>
        <trans-unit id="996ef93cbabdf3a445d79226e8fa6d9c24a881f0" translate="yes" xml:space="preserve">
          <source>How are the syntax diagrams (a.k.a. &quot;railroad&quot; diagrams) for SQLite generated?</source>
          <target state="translated">SQLite的语法图(也就是 &quot;铁路 &quot;图)是如何生成的?</target>
        </trans-unit>
        <trans-unit id="fc0899650d804dfcac8dc2104606bf9268efcf1e" translate="yes" xml:space="preserve">
          <source>How collation is determined</source>
          <target state="translated">如何确定整理</target>
        </trans-unit>
        <trans-unit id="9a3218133ebd28240c94b4e7364a4f7e2e221ee5" translate="yes" xml:space="preserve">
          <source>How do I add or delete columns from an existing table in SQLite.</source>
          <target state="translated">如何在SQLite中从现有的表中添加或删除列。</target>
        </trans-unit>
        <trans-unit id="30aeec19cd6396142e3416e018900e8041d11cdb" translate="yes" xml:space="preserve">
          <source>How do I create an AUTOINCREMENT field?</source>
          <target state="translated">如何创建一个AUTOINCREMENT字段?</target>
        </trans-unit>
        <trans-unit id="a6cedc80b4e8057201d930bd24da72e7284f5f18" translate="yes" xml:space="preserve">
          <source>How do I list all tables/indices contained in an SQLite database</source>
          <target state="translated">如何列出SQLite数据库中的所有表/索引?</target>
        </trans-unit>
        <trans-unit id="94a002c7d3ab3f319a7a958c2ffad735eae889c1" translate="yes" xml:space="preserve">
          <source>How do I use a string literal that contains an embedded single-quote (') character?</source>
          <target state="translated">如何使用包含嵌入式单引号(')字符的字符串文字?</target>
        </trans-unit>
        <trans-unit id="df2742c7cfd9e0aab79b47f5b91d0027a0daa0fc" translate="yes" xml:space="preserve">
          <source>How many executable files are in the archive?</source>
          <target state="translated">档案中有多少个可执行文件?</target>
        </trans-unit>
        <trans-unit id="463cdf2e00bc03ffb0a58ce75a36b28173bad1d1" translate="yes" xml:space="preserve">
          <source>How vacuum works</source>
          <target state="translated">真空如何工作</target>
        </trans-unit>
        <trans-unit id="c2ebee163b547a5e69c6b8f18b3ce7ade428f296" translate="yes" xml:space="preserve">
          <source>However, client/server database engines (such as PostgreSQL, MySQL, or Oracle) usually support a higher level of concurrency and allow multiple processes to be writing to the same database at the same time. This is possible in a client/server database because there is always a single well-controlled server process available to coordinate access. If your application has a need for a lot of concurrency, then you should consider using a client/server database. But experience suggests that most applications need much less concurrency than their designers imagine.</source>
          <target state="translated">然而,客户/服务器数据库引擎(如PostgreSQL、MySQL或Oracle)通常支持更高层次的并发性,并允许多个进程同时向同一数据库写入。这在客户/服务器数据库中是可能的,因为总是有一个控制良好的服务器进程来协调访问。如果你的应用程序有大量并发的需求,那么你应该考虑使用客户/服务器数据库。但经验表明,大多数应用程序所需要的并发性比其设计者所想象的要小得多。</target>
        </trans-unit>
        <trans-unit id="a6ddbe53650906819e58dd27910958633c3e2cfa" translate="yes" xml:space="preserve">
          <source>However, for a &quot;contained-within&quot; style query, rounding the bounding boxes outward might cause some entries to be excluded from the result set if the edge of the entry bounding box corresponds to the edge of the query bounding box. To guard against this, applications should expand their contained-within query boxes slightly (by 0.000012%) by rounding down the lower coordinates and rounding up the top coordinates, in each dimension.</source>
          <target state="translated">然而,对于 &quot;包含-包围 &quot;风格的查询,如果条目包围盒的边缘与查询包围盒的边缘相对应,那么向外舍入包围盒可能会导致一些条目被排除在结果集中。为了防止这种情况发生,应用程序应该在每个维度上,通过四舍五入下层坐标和四舍五入上层坐标的方式,稍微扩大其包含在其中的查询框(0.000012%)。</target>
        </trans-unit>
        <trans-unit id="036059da8b4b48b5c802bde550324a35ba2a35da" translate="yes" xml:space="preserve">
          <source>However, highly tuned and specialized applications may want or need to replace some of SQLite's built-in system interfaces with alternative implementations more suitable for the needs of the application. SQLite is designed to be easily reconfigured at compile-time to meet the specific needs of individual projects. Among the compile-time configuration options for SQLite are these:</source>
          <target state="translated">然而,高度调整和专业化的应用程序可能希望或需要用更适合应用程序需求的替代实现来替换SQLite的一些内置系统接口。SQLite被设计成可以在编译时轻松地重新配置,以满足各个项目的特定需求。在SQLite的编译时配置选项中,有这些。</target>
        </trans-unit>
        <trans-unit id="9070a26476fc8018912ec09ceeee6b8f4a55c4f3" translate="yes" xml:space="preserve">
          <source>However, if a</source>
          <target state="translated">然而,如果一个</target>
        </trans-unit>
        <trans-unit id="96aad563dbeff373bd60c0d93a4ac2c049bba808" translate="yes" xml:space="preserve">
          <source>However, if a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation creates real tables (sometimes referred to as &quot;shadow&quot; tables) within the database to store its data in, then sqldiff.exe does calculate the difference between these. This can have surprising effects if the resulting SQL script is then run on a database that is not</source>
          <target state="translated">但是，如果&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现在数据库中创建实际表（有时称为&amp;ldquo;影子&amp;rdquo;表）以存储其数据，则sqldiff.exe会计算两者之间的差。如果生成的SQL脚本随后在非SQL Server数据库上运行，则会产生令人惊讶的效果。</target>
        </trans-unit>
        <trans-unit id="90ac212208b638040cc57dde761531e1857cf547" translate="yes" xml:space="preserve">
          <source>However, if a database has many concurrent overlapping readers and there is always at least one active reader, then no checkpoints will be able to complete and hence the WAL file will grow without bound.</source>
          <target state="translated">但是,如果一个数据库有很多并发的重叠读者,而且总是有至少一个活跃的读者,那么就没有检查点能够完成,因此WAL文件将无限制地增长。</target>
        </trans-unit>
        <trans-unit id="908b33a654e5b5eaa50e924611f16debc0d52007" translate="yes" xml:space="preserve">
          <source>However, if in-memory database pInMemory has just been opened (and is therefore completely empty) before being passed to function loadOrSaveDb(), then it is still possible to change its page size using an SQLite &quot;PRAGMA page_size&quot; command. Function loadOrSaveDb() could detect this case, and attempt to set the page-size of the in-memory database to the page-size of database zFilename before invoking the online backup API functions.</source>
          <target state="translated">但是,如果内存数据库pInMemory在被传递给函数loadOrSaveDb()之前刚刚被打开(因此是完全空的),那么仍然可以使用SQLite &quot;PRAGMA page_size &quot;命令改变其页面大小。函数loadOrSaveDb()可以检测到这种情况,并试图在调用在线备份API函数之前,将内存数据库的页面大小设置为数据库zFilename的页面大小。</target>
        </trans-unit>
        <trans-unit id="c8346bf2feca974b5d3d774b0dd2cf9e7396c3aa" translate="yes" xml:space="preserve">
          <source>However, most CVEs written against SQLite flippantly assume that an attacker is free to run any arbitrary SQL in the database engine. So to a good approximation, this means most CVEs written against SQLite really only apply to SQLite as it is used in Chrome and Safari. Or, in other words, most CVEs for SQLite do not apply to you unless you are one of the developers of Chrome or Safari.</source>
          <target state="translated">然而,大多数针对 SQLite 编写的 CVE 都轻率地假设攻击者可以在数据库引擎中自由运行任何任意 SQL。因此,近似而言,这意味着大多数针对SQLite编写的CVE实际上只适用于在Chrome和Safari中使用的SQLite。或者换句话说,大多数针对SQLite的CVE并不适用于你,除非你是Chrome或Safari的开发者之一。</target>
        </trans-unit>
        <trans-unit id="39757386af6ee77e7f7c27742f0c4303b1680cd5" translate="yes" xml:space="preserve">
          <source>However, the SQLite developers do not track CVEs. There are various reasons for this:</source>
          <target state="translated">然而,SQLite开发人员并没有跟踪CVEs。这有多种原因。</target>
        </trans-unit>
        <trans-unit id="9282d84ef089a46651581dc23d9984a0b853a197" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">但是，应用程序必须确保在调用sqlite3_backup_init（）之后和对sqlite3_backup_finish（）的相应调用之前，不会将目标&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;传递给任何其他API（通过任何线程）。SQLite当前不检查应用程序是否错误地访问了目标&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;，因此未报告任何错误代码，但是操作仍然可能会出错。在备份过程中使用目标数据库连接也可能会导致互斥锁死锁。</target>
        </trans-unit>
        <trans-unit id="6bd67d83c5ac9c5a6146085621d60822aa5f256c" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">但是，应用程序必须确保在调用sqlite3_backup_init（）之后和对sqlite3_backup_finish（）的相应调用之前，不会将目标&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;传递给任何其他API（通过任何线程）。SQLite当前不检查应用程序是否错误地访问了目标&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;，因此未报告任何错误代码，但是操作仍然可能会出错。在备份过程中使用目标数据库连接也可能会导致互斥锁死锁。</target>
        </trans-unit>
        <trans-unit id="2051ec90af96c4dbbb12c8a2bb3921b04fb0a7f2" translate="yes" xml:space="preserve">
          <source>However, the b-tree for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table is in the same format as an index b-tree. Thus, an index b-tree can be accessed as if it were a WITHOUT ROWID table.</source>
          <target state="translated">但是，&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的b树与索引b树的格式相同。因此，索引b树可以像是WITHOUT ROWID表一样被访问。</target>
        </trans-unit>
        <trans-unit id="587a4ce8c5eaeede93486cce8a7a8544b112f279" translate="yes" xml:space="preserve">
          <source>However, there are some occasions where an application does need to be able to safely run untrusted SQL. The SQLite developers work hard to make SQLite safe for this purpose, though there are occasional slip-ups. It is good to keep up-to-date with the latest patches in this case. The separate &lt;a href=&quot;security&quot;&gt;defense against dark arts&lt;/a&gt; document contains additional suggestions that can help prevent zero-day attacks in cases where SQLite is given inputs that come directly from untrusted sources.</source>
          <target state="translated">但是，在某些情况下，应用程序确实需要能够安全地运行不受信任的SQL。尽管偶尔会有一些失误，但SQLite开发人员为确保SQLite的安全而努力工作。在这种情况下，最好保持最新的补丁程序。单独的&lt;a href=&quot;security&quot;&gt;针对黑暗艺术的防御&lt;/a&gt;文档包含其他建议，这些建议可以帮助防止在零日攻击中，如果SQLite的输入直接来自不受信任的来源。</target>
        </trans-unit>
        <trans-unit id="bdab598cbadf7cd7b2bb8bc0bda2ecbe3c4ceb3a" translate="yes" xml:space="preserve">
          <source>Hundreds of virtual tables that publish various aspects of the host computer, such as the process table, user lists, active network connections, and so forth. OsQuery is a separate project, started by Facebook, hosted on &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt;, and intended for security analysis and intrusion detection OsQuery is not a part of the SQLite project, but is included in this list because it demonstrates how the SQL language and the SQLite virtual table mechanism can be leveraged to provide elegant solutions to important real-world problems.</source>
          <target state="translated">数百个虚拟表发布了主机的各个方面，例如进程表，用户列表，活动的网络连接等。 OsQuery是一个单独的项目，由Facebook启动，托管在&lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub上&lt;/a&gt;，用于安全分析和入侵检测OsQuery不是SQLite项目的一部分，但包含在此列表中，因为它演示了SQL语言和SQLite虚拟表的方式。可以利用该机制为重要的现实问题提供完善的解决方案。</target>
        </trans-unit>
        <trans-unit id="6d245e7140689124e74b20cb072465076d95b006" translate="yes" xml:space="preserve">
          <source>I accidentally deleted some important information from my SQLite database. How can I recover it?</source>
          <target state="translated">我不小心删除了SQLite数据库中的一些重要信息。如何恢复?</target>
        </trans-unit>
        <trans-unit id="dc9c3207dff5659b4c310cd90f15260ed36f68c7" translate="yes" xml:space="preserve">
          <source>I am told that Git users commonly install third-party graphical viewers for Git, many of which do a better job of showing recent activity on the project. That is great, but these are still more third-party applications that must be installed and managed separately. Many are platform-specific. (One of the better ones, &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt;, only works on Mac, for example.) All require that you first sync your local repository then bring up their graphical interface on your desktop. And even with all that, I still cannot see what I typically want to see without multiple clicks. Checking on project status from a phone while away from the office is not an option.</source>
          <target state="translated">有人告诉我，Git用户通常会为Git安装第三方图形查看器，其中许多在显示项目近期活动方面做得更好。很好，但是这些仍然是更多第三方应用程序，必须分别安装和管理。许多是特定于平台的。 （例如，更好的&lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp之一&lt;/a&gt;仅适用于Mac。）所有这些都要求您首先同步本地存储库，然后在桌面上启动其图形界面。即使有所有这些，如果没有多次单击，我仍然看不到我通常希望看到的内容。不在办公室时，无法通过电话检查项目状态。</target>
        </trans-unit>
        <trans-unit id="a5d8bfaba744d8865014e1b5776daef69b8ba64a" translate="yes" xml:space="preserve">
          <source>I am told that the default PostgreSQL configuration in RedHat 7.3 is unnecessarily conservative (it is designed to work on a machine with 8MB of RAM) and that PostgreSQL could be made to run a lot faster with some knowledgeable configuration tuning. Matt Sergeant reports that he has tuned his PostgreSQL installation and rerun the tests shown below. His results show that PostgreSQL and MySQL run at about the same speed. For Matt's results, visit</source>
          <target state="translated">我被告知,RedHat 7.3中默认的PostgreSQL配置是不必要的保守(它被设计为工作在一台内存为8MB的机器上),PostgreSQL可以通过一些知识性的配置调整来使其运行得更快。Matt Sergeant报告说,他已经调整了PostgreSQL的安装,并重新运行了下面的测试。他的结果显示,PostgreSQL和MySQL的运行速度差不多。关于Matt的结果,请访问</target>
        </trans-unit>
        <trans-unit id="c4b4aed72c495e6b69cc90a12c1002093ba09a73" translate="yes" xml:space="preserve">
          <source>I deleted a lot of data but the database file did not get any smaller. Is this a bug?</source>
          <target state="translated">我删除了很多数据,但是数据库文件并没有变小。这是一个错误吗?</target>
        </trans-unit>
        <trans-unit id="30c131b4d60b85b44b7c7e76894246c9eeed47f8" translate="yes" xml:space="preserve">
          <source>I get a compiler error if I use the SQLITE_OMIT_... compile-time options when building SQLite.</source>
          <target state="translated">如果我在构建SQLite时使用SQLITE_OMIT_...编译时的选项,我得到一个编译器错误。</target>
        </trans-unit>
        <trans-unit id="96380689d1c266e443557fac220e162eb248fe7f" translate="yes" xml:space="preserve">
          <source>I get some compiler warnings when I compile SQLite. Isn't this a problem? Doesn't it indicate poor code quality?</source>
          <target state="translated">我在编译SQLite的时候收到一些编译器警告。这难道不是一个问题吗?是不是说明代码质量不好?</target>
        </trans-unit>
        <trans-unit id="b0631d514fcfd330a2105540a0b813b7c7b65c3f" translate="yes" xml:space="preserve">
          <source>I/O error testing is similar in concept to OOM testing; I/O errors are simulated and checks are made to verify that SQLite responds correctly to the simulated errors. I/O errors are simulated in both the TCL and TH3 test harnesses by inserting a new &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System object&lt;/a&gt; that is specially rigged to simulate an I/O error after a set number of I/O operations. As with OOM error testing, the I/O error simulators can be set to fail just once, or to fail continuously after the first failure. Tests are run in a loop, slowly increasing the point of failure until the test case runs to completion without error. The loop is run twice, once with the I/O error simulator set to simulate only a single failure and a second time with it set to fail all I/O operations after the first failure.</source>
          <target state="translated">I / O错误测试的概念与OOM测试类似；模拟I / O错误，并进行检查以验证SQLite对模拟错误是否正确响应。通过插入一个新的&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统对象&lt;/a&gt;（在经过一定数量的I / O操作后专门模拟I / O错误），可以在TCL和TH3测试工具中模拟I / O错误。与OOM错误测试一样，可以将I / O错误模拟器设置为仅失败一次，或在首次失败后连续失败。测试以循环方式运行，缓慢增加故障点，直到测试用例运行无误为止。该循环运行两次，一次将I / O错误模拟器设置为仅模拟单个故障，第二次将循环设置为在第一次故障后使所有I / O操作失败。</target>
        </trans-unit>
        <trans-unit id="7e39c1a666c2fd143f11a87457de9e9888317484" translate="yes" xml:space="preserve">
          <source>I/O error testing seeks to verify that SQLite responds sanely to failed I/O operations. I/O errors might result from a full disk drive, malfunctioning disk hardware, network outages when using a network file system, system configuration or permission changes that occur in the middle of an SQL operation, or other hardware or operating system malfunctions. Whatever the cause, it is important that SQLite be able to respond correctly to these errors and I/O error testing seeks to verify that it does.</source>
          <target state="translated">I/O错误测试旨在验证SQLite是否对失败的I/O操作做出了理智的响应。I/O错误可能是由于磁盘驱动器满载、磁盘硬件故障、使用网络文件系统时的网络中断、在SQL操作中间发生的系统配置或权限更改,或其他硬件或操作系统故障造成的。不管是什么原因,重要的是SQLite能够正确地响应这些错误,I/O错误测试旨在验证它是否正确。</target>
        </trans-unit>
        <trans-unit id="8d8651647c9490ad914b1a9a6e6d44929ce46c04" translate="yes" xml:space="preserve">
          <source>I/O error tests</source>
          <target state="translated">I/O错误测试</target>
        </trans-unit>
        <trans-unit id="35d92e9f60aece05bafa666d5e6093c27b070d38" translate="yes" xml:space="preserve">
          <source>I/O errors in the OS-interface generate error logging events. The message to these events gives the line number in the source code where the error originated and the filename associated with the event when there is a corresponding file.</source>
          <target state="translated">OS-接口中的I/O错误会产生错误日志事件。这些事件的信息给出了源代码中错误起源的行号,以及在有相应文件时与事件相关联的文件名。</target>
        </trans-unit>
        <trans-unit id="d998ed8c49ae368254ded62fce1c76a6c0d44f30" translate="yes" xml:space="preserve">
          <source>I/O performance is measured using the &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; program from the SQLite source tree. To compile this test program, first gather the kvtest.c source file into a directory with the &lt;a href=&quot;amalgamation&quot;&gt;SQLite amalgamation&lt;/a&gt; source files &quot;sqlite3.c&quot; and &quot;sqlite3.h&quot;. Then on unix, run a command like the following:</source>
          <target state="translated">使用SQLite源代码树中的&lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt;程序测量I / O性能。要编译此测试程序，请首先将kvtest.c源文件收集到包含&lt;a href=&quot;amalgamation&quot;&gt;SQLite合并&lt;/a&gt;源文件&amp;ldquo; sqlite3.c&amp;rdquo;和&amp;ldquo; sqlite3.h&amp;rdquo;的目录中。然后在UNIX上，运行如下命令：</target>
        </trans-unit>
        <trans-unit id="e779dca751c9ced361a0eadbe7916be59d02dc09" translate="yes" xml:space="preserve">
          <source>I/O performance varies widely depending on operating system and hardware. Make your own measurements before drawing conclusions.</source>
          <target state="translated">I/O性能因操作系统和硬件不同而有很大差异。在得出结论之前,请自己进行测量。</target>
        </trans-unit>
        <trans-unit id="267e452e4d048aacef682e30a9d368c22e7501e4" translate="yes" xml:space="preserve">
          <source>IDF(q&lt;sub&gt;i&lt;/sub&gt;)</source>
          <target state="translated">IDF(q&lt;sub&gt;i&lt;/sub&gt;)</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="235cae5b9c97fbc3364fb92af44d64b71392dbb2" translate="yes" xml:space="preserve">
          <source>IF EXISTS and IF NOT EXISTS clauses on CREATE/DROP TABLE/INDEX.</source>
          <target state="translated">关于CREATE/DROP TABLE/INDEX的IF EXISTS和IF NOT EXISTS子句。</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="3b63a4da1415c242da17f132d0e00d086153fa66" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a write statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="translated">IMMEDIATE导致数据库连接立即开始新的写操作，而无需等待写语句。如果另一个写连接在另一个数据库连接上已经处于活动状态，则BEGIN IMMEDIATE可能会失败并显示&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f94ea3de1605903ae5123660f5457eb8bd32e9f" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a writes statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="translated">IMMEDIATE使数据库连接立即开始新的写操作，而无需等待writes语句。如果另一个写连接在另一个数据库连接上已经处于活动状态，则BEGIN IMMEDIATE可能会失败并显示&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4db76ad8831e1ebbbc52031b1ae484c99975878" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">重要信息：SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;版本3.8.2&lt;/a&gt;（2013-12-06）的EstimatedRows字段已添加到sqlite3_index_info结构中。如果将虚拟表扩展名与3.8.2之前的SQLite版本一起使用，则尝试读取或写入estimatedRows字段的结果是不确定的（但可能会导致应用程序崩溃）。因此，仅当&lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值大于或等于3008002时，才应使用estimatedRows字段。类似地，为&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）添加了idxFlags字段。因此，只有在sqlite3_libversion_number（）返回的值大于或等于3009000时，才可以使用它。</target>
        </trans-unit>
        <trans-unit id="0f10a7701656ba82f20f9690db33f263b9944c35" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">重要信息：SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;版本3.8.2&lt;/a&gt;（2013-12-06）的EstimatedRows字段已添加到sqlite3_index_info结构中。如果将虚拟表扩展名与3.8.2之前的SQLite版本一起使用，则尝试读取或写入estimatedRows字段的结果是不确定的（但可能会导致应用程序崩溃）。因此，仅当&lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值大于或等于3008002时，才应使用estimatedRows字段。类似地，为&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）添加了idxFlags字段。因此，只有在sqlite3_libversion_number（）返回的值大于或等于3009000时，才可以使用它。</target>
        </trans-unit>
        <trans-unit id="ac8fb933cd53d38ff3f25855409c3725df641570" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">重要说明：SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;版本3.8.2&lt;/a&gt;（2013-12-06）的EstimatedRows字段已添加到sqlite3_index_info结构中。如果将虚拟表扩展名与3.8.2之前的SQLite版本一起使用，则尝试读取或写入estimatedRows字段的结果是不确定的（但可能会导致应用程序崩溃）。因此，仅当&lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值大于或等于3008002时，才应使用estimatedRows字段。类似地，为&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）添加了idxFlags字段。因此，只有在sqlite3_libversion_number（）返回的值大于或等于3009000时，才可以使用它。</target>
        </trans-unit>
        <trans-unit id="f7788b148a07ca2844906ea43293afae622f959f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">重要说明：SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;版本3.8.2&lt;/a&gt;（2013-12-06）的EstimatedRows字段已添加到sqlite3_index_info结构中。如果将虚拟表扩展名与3.8.2之前的SQLite版本一起使用，则尝试读取或写入estimatedRows字段的结果是不确定的（但可能会导致应用程序崩溃）。因此，仅当&lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值大于或等于3008002时，才应使用estimatedRows字段。类似地，为&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）添加了idxFlags字段。因此，只有在sqlite3_libversion_number（）返回的值大于或等于3009000时，才可以使用它。</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="9e93d8e547641024337c9f88c37aeeb56b09cfd4" translate="yes" xml:space="preserve">
          <source>IN operator</source>
          <target state="translated">IN操作员</target>
        </trans-unit>
        <trans-unit id="2704c1d8c3fc215c38ee176f6cc30e434a22b7d7" translate="yes" xml:space="preserve">
          <source>INDEX</source>
          <target state="translated">INDEX</target>
        </trans-unit>
        <trans-unit id="d34941b7cef935d2b4b0705a24e87fad9ef16cef" translate="yes" xml:space="preserve">
          <source>INDEXED</source>
          <target state="translated">INDEXED</target>
        </trans-unit>
        <trans-unit id="0a477a77f065212096e980b210eda0227cabf37c" translate="yes" xml:space="preserve">
          <source>INDEXED BY</source>
          <target state="translated">INDEXED BY</target>
        </trans-unit>
        <trans-unit id="fd4d2f0d5aa850e30c0830c19e27d0fa4c65c7a7" translate="yes" xml:space="preserve">
          <source>INITIALLY</source>
          <target state="translated">INITIALLY</target>
        </trans-unit>
        <trans-unit id="88d86d54436967d4b4599d22d53c2a3db38390e6" translate="yes" xml:space="preserve">
          <source>INNER</source>
          <target state="translated">INNER</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="06c4e866c3ade62ba74b04b1ef54dce90603c067" translate="yes" xml:space="preserve">
          <source>INSERT Changes</source>
          <target state="translated">INSERT 更改</target>
        </trans-unit>
        <trans-unit id="4e7c6a59e9c103dd735d95fe84726b20fe104acf" translate="yes" xml:space="preserve">
          <source>INSERT INTO demo2(command) VALUES(&quot;reset&quot;);</source>
          <target state="translated">INSERT INTO demo2(command)VALUES(&quot;reset&quot;)。</target>
        </trans-unit>
        <trans-unit id="ed9844477a7bb01e976b863376804eb769331989" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 SELECT b,a,c FROM t2;</source>
          <target state="translated">INSERT INTO t1 SELECT b,a,c FROM t2;</target>
        </trans-unit>
        <trans-unit id="767dcfed1e7a66d267a3220fbe439232373351ee" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,10719,'ten thousand seven hundred nineteen');</source>
          <target state="translated">INSERT INTO t1 VALUES(1,10719,'ten thousand seven hundred nineteen')。</target>
        </trans-unit>
        <trans-unit id="a30ee5b0b970fc276bf5d3453cfa994508fd0177" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,13153,'thirteen thousand one hundred fifty three');</source>
          <target state="translated">INSERT INTO t1 VALUES(1,13153,'一万三千一百五十三')。</target>
        </trans-unit>
        <trans-unit id="4bc6de27aceadc240c8dd43059a82f9a9561379b" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1000,94142,'ninety four thousand one hundred forty two');</source>
          <target state="translated">INSERT INTO t1 VALUES(1000,94142,'九万四千一百四十二')。</target>
        </trans-unit>
        <trans-unit id="62d9636f68aa675dabacb22b938d9f2be06b55e0" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(11999,72836,'seventy two thousand eight hundred thirty six');</source>
          <target state="translated">INSERT INTO t1 VALUES(11999,72836,'七万二千八百三十六')。</target>
        </trans-unit>
        <trans-unit id="f0fbe2df8c33450eafb90fd96d71291641e02aa4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(12000,64231,'sixty four thousand two hundred thirty one');</source>
          <target state="translated">INSERT INTO t1 VALUES(12000,64231,'六万四千二百三十一')。</target>
        </trans-unit>
        <trans-unit id="31a76630ad88d2e05dde2c415d8576db8ec6caf9" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(2,75560,'seventy five thousand five hundred sixty');</source>
          <target state="translated">INSERT INTO t1 VALUES(2,75560,'七万五千五百六十')。</target>
        </trans-unit>
        <trans-unit id="215d5732ce27fd223582c712aaa4660a83a173d4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(998,66289,'sixty six thousand two hundred eighty nine');</source>
          <target state="translated">INSERT INTO t1 VALUES(998,66289,'六万六千二百八十九')。</target>
        </trans-unit>
        <trans-unit id="4b533e1d2a14d2013c249801c64abee1873ad0e7" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(999,24322,'twenty four thousand three hundred twenty two');</source>
          <target state="translated">INSERT INTO t1 VALUES(999,24322,'二十四万三千二百二')。</target>
        </trans-unit>
        <trans-unit id="c97d31d96ba9608129ccb018853e9ea9cb6076d1" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT * FROM t1;</source>
          <target state="translated">INSERT INTO t2 SELECT*FROM t1;</target>
        </trans-unit>
        <trans-unit id="18573be7d634b7266c9f3fabe6799c0e9de399b2" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT b,a,c FROM t1;</source>
          <target state="translated">INSERT INTO t2 SELECT b,a,c FROM t1;</target>
        </trans-unit>
        <trans-unit id="6654bc4310d1eef443b5f0f2c1641262634e1e66" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(1,59672,'fifty nine thousand six hundred seventy two');</source>
          <target state="translated">INSERT INTO t2 VALUES(1,59672,'五万九千六百七十二')。</target>
        </trans-unit>
        <trans-unit id="94d1d27ed943c864c7cfd96715bf162e7beab100" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(24999,89569,'eighty nine thousand five hundred sixty nine');</source>
          <target state="translated">INSERT INTO t2 VALUES(24999,89569,'八万九千五百六十九')。</target>
        </trans-unit>
        <trans-unit id="253860cdd49bceb80fa941fa6a7a8aa222a2af3e" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(25000,94666,'ninety four thousand six hundred sixty six');</source>
          <target state="translated">INSERT INTO t2 VALUES(25000,94666,'九万四千六百六十六')。</target>
        </trans-unit>
        <trans-unit id="0e8f253b1b555988f2df4dcb60865d19307f1b0c" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(24999,88509,'eighty eight thousand five hundred nine');</source>
          <target state="translated">INSERT INTO t3 VALUES(24999,88509,'八万八千五百九')。</target>
        </trans-unit>
        <trans-unit id="00be643bf7f738dedf700c9b2a35f10694c7941a" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(25000,84791,'eighty four thousand seven hundred ninety one');</source>
          <target state="translated">INSERT INTO t3 VALUES(25000,84791,'八万四千七百九十一')。</target>
        </trans-unit>
        <trans-unit id="eb2365c71aa4f9cd4a1bfec486fd83fcbdda7977" translate="yes" xml:space="preserve">
          <source>INSERT INTO tab1 VALUES(?,?,?);</source>
          <target state="translated">INSERT INTO tab1 VALUES(?,?,?)。</target>
        </trans-unit>
        <trans-unit id="0666a7f2affc6b3653a4c2bdf54c9b4bb98361ed" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('automerge=N');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('automerge=N')。</target>
        </trans-unit>
        <trans-unit id="4e8b9a8e297bede64cc05b119a6cea847e694a59" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('integrity-check');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('完整性检查')。</target>
        </trans-unit>
        <trans-unit id="f5e0d229ccc9b20df140de91fa55ac169f3840fe" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('merge=X,Y');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('merge=X,Y')。</target>
        </trans-unit>
        <trans-unit id="5af88d4a59ba50ff893198ed67ae451d74a117e2" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('optimize');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('优化')。</target>
        </trans-unit>
        <trans-unit id="13f47444da210de43c60aab402a316dfe2becb56" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('rebuild');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('rebuild')。</target>
        </trans-unit>
        <trans-unit id="631e931c19e40aa3da1ce6f0902d43d9a508af25" translate="yes" xml:space="preserve">
          <source>INSERT and UPDATE statements now always apply &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; before computing &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;. This bug fix could, in theory, cause problems for legacy databases with unorthodox CHECK constraints the require the input type for an INSERT is different from the declared column type. See ticket &lt;a href=&quot;https://sqlite.org/src/info/86ba67afafded936&quot;&gt;86ba67afafded936&lt;/a&gt; for more information.</source>
          <target state="translated">INSERT和UPDATE语句现在始终在计算&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;之前应用&lt;a href=&quot;datatype3#affinity&quot;&gt;列亲和力&lt;/a&gt;。从理论上讲，此错误修复可能会导致具有非常规CHECK约束的旧数据库出现问题，这要求INSERT的输入类型与声明的列类型不同。有关更多信息，请参见票号&lt;a href=&quot;https://sqlite.org/src/info/86ba67afafded936&quot;&gt;86ba67afafded936&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f103f7920401a2a0647c3f2159a7c89eabff571" translate="yes" xml:space="preserve">
          <source>INSERT is really slow - I can only do few dozen INSERTs per second</source>
          <target state="translated">INSERT真的很慢--我每秒钟只能做几十个INSERT。</target>
        </trans-unit>
        <trans-unit id="62d1399645f66158b7511abeddf89f395dea5fde" translate="yes" xml:space="preserve">
          <source>INSERT runs a little faster when the source is a SELECT statement.</source>
          <target state="translated">当源是SELECT语句时,INSERT的运行速度会更快一些。</target>
        </trans-unit>
        <trans-unit id="aeb597e62b4ad26deac5b62c60062c710ea90371" translate="yes" xml:space="preserve">
          <source>INSTEAD</source>
          <target state="translated">INSTEAD</target>
        </trans-unit>
        <trans-unit id="2300ac39d09a99728ae682403c03797ee8da658b" translate="yes" xml:space="preserve">
          <source>INSTEAD OF trigger</source>
          <target state="translated">而不是触发</target>
        </trans-unit>
        <trans-unit id="d8374d53c837e126cb6abc0132fba2a1f9a3a9c8" translate="yes" xml:space="preserve">
          <source>INSTEAD OF triggers</source>
          <target state="translated">而不是触发器</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="a3a0ec55e3e26ee54417c786dfad5d709ecb7c40" translate="yes" xml:space="preserve">
          <source>INT2</source>
          <target state="translated">INT2</target>
        </trans-unit>
        <trans-unit id="021a30ffe1ce8750cb57ce941d7fb3d04090b37c" translate="yes" xml:space="preserve">
          <source>INT8</source>
          <target state="translated">INT8</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="e3752510d6a9d0fb8f3974168ca6bea1a562a9ac" translate="yes" xml:space="preserve">
          <source>INTEGER PRIMARY KEY columns can be used to implement the equivalent of AUTOINCREMENT. If you try to insert a NULL into an INTEGER PRIMARY KEY column, the column will actually be filled with an integer that is one greater than the largest key already in the table. Or if the largest key is 2147483647, then the column will be filled with a random integer. Either way, the INTEGER PRIMARY KEY column will be assigned a unique integer. You can retrieve this integer using the &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function or using the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function in a subsequent SELECT statement.</source>
          <target state="translated">INTEGER PRIMARY KEY列可用于实现等效的AUTOINCREMENT。如果您尝试将NULL插入INTEGER PRIMARY KEY列，则该列实际上将填充一个整数，该整数比表中已有的最大键大1。或者，如果最大键为2147483647，则该列将填充一个随机整数。无论哪种方式，都将为INTEGER PRIMARY KEY列分配一个唯一的整数。您可以使用&lt;b&gt;sqlite_last_insert_rowid（）&lt;/b&gt; API函数或在后续的SELECT语句中使用&lt;b&gt;last_insert_rowid（）&lt;/b&gt; SQL函数来检索此整数。</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="3230de938114213aa9c2d1e95f291cad51ede171" translate="yes" xml:space="preserve">
          <source>INTERSECT</source>
          <target state="translated">INTERSECT</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="819809f7649d3da66fd65a40dff83509ed2b98d0" translate="yes" xml:space="preserve">
          <source>IS NOT</source>
          <target state="translated">是不</target>
        </trans-unit>
        <trans-unit id="437390c0773d23a0b0e272480ef7204b356f23ad" translate="yes" xml:space="preserve">
          <source>IS operator</source>
          <target state="translated">IS运营商</target>
        </trans-unit>
        <trans-unit id="4e93120a53b25e7642cc15924ececcc7c79ac693" translate="yes" xml:space="preserve">
          <source>ISNULL</source>
          <target state="translated">ISNULL</target>
        </trans-unit>
        <trans-unit id="c8c6b6fe3176986c9e57f2648e139dfd273d0908" translate="yes" xml:space="preserve">
          <source>Ideally, all changes for an entire write transaction are buffered in the page cache until the end of the transaction. When the user commits the transaction, all changes are applied to the database file in the most efficient way possible, taking into account the assumptions enumerated in section</source>
          <target state="translated">理想情况下,整个写事务的所有变化都会被缓冲在页面缓存中,直到事务结束。当用户提交事务时,所有的更改都会以最有效的方式应用到数据库文件中,同时考虑到第3节中列举的假设。</target>
        </trans-unit>
        <trans-unit id="3aa28748de853653631eccc0d256aed420f0eed1" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">理想情况下，应用程序应该在尝试关闭对象之前，&lt;a href=&quot;#sqlite3_finalize&quot;&gt;完成&lt;/a&gt;所有&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;关闭&lt;/a&gt;所有&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;并&lt;a href=&quot;#sqlite3backupfinish&quot;&gt;完成&lt;/a&gt;与&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象关联的所有&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象。如果数据库连接与未完成的准备语句，BLOB处理程序和/或未完成的sqlite3_backup对象相关联，则sqlite3_close（）将使数据库连接保持打开状态并返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果使用未完成的准备语句，未关闭的BLOB处理程序和/或未完成的sqlite3_backups调用sqlite3_close_v2（），则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;无论如何，而是将数据库连接标记为不可使用的&amp;ldquo;僵尸&amp;rdquo;，而不是立即取消分配数据库连接，并安排在所有准备好的语句完成，所有BLOB句柄关闭且所有备份完成之后自动取消分配数据库连接。 sqlite3_close_v2（）接口旨在用于垃圾收集的宿主语言，并且调用析构函数的顺序是任意的。</target>
        </trans-unit>
        <trans-unit id="c6a04cc62fe27e532be18f141495602f090fc2e2" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">理想情况下，应用程序应该在尝试关闭对象之前，&lt;a href=&quot;finalize&quot;&gt;完成&lt;/a&gt;所有&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;，&lt;a href=&quot;blob_close&quot;&gt;关闭&lt;/a&gt;所有&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;并&lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;完成&lt;/a&gt;与&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象关联的所有&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象。如果数据库连接与未完成的准备语句，BLOB处理程序和/或未完成的sqlite3_backup对象相关联，则sqlite3_close（）将使数据库连接保持打开状态并返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果使用未完成的准备语句，未关闭的BLOB处理程序和/或未完成的sqlite3_backups调用sqlite3_close_v2（），则返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;无论如何，而是将数据库连接标记为不可使用的&amp;ldquo;僵尸&amp;rdquo;，而不是立即取消分配数据库连接，并安排在所有准备好的语句完成，所有BLOB句柄关闭且所有备份完成之后自动取消分配数据库连接。 sqlite3_close_v2（）接口旨在用于垃圾收集的宿主语言，并且调用析构函数的顺序是任意的。</target>
        </trans-unit>
        <trans-unit id="6acc0ba610f36525f417357719583f041f6f89df" translate="yes" xml:space="preserve">
          <source>Identify all methods for important objects in the interface documentation. (&lt;a href=&quot;c3ref/context&quot;&gt;example&lt;/a&gt;)</source>
          <target state="translated">在接口文档中标识重要对象的所有方法。（&lt;a href=&quot;c3ref/context&quot;&gt;示例&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="b22904746b6da6e6da1cdf65a007a3a92ddeb189" translate="yes" xml:space="preserve">
          <source>IdxDelete</source>
          <target state="translated">IdxDelete</target>
        </trans-unit>
        <trans-unit id="366f895979adef772b50f0a751ee770dc166bab5" translate="yes" xml:space="preserve">
          <source>IdxGE</source>
          <target state="translated">IdxGE</target>
        </trans-unit>
        <trans-unit id="267d8b7b66c2e63c7420b46c7edd1ef118e13442" translate="yes" xml:space="preserve">
          <source>IdxGT</source>
          <target state="translated">IdxGT</target>
        </trans-unit>
        <trans-unit id="bdc0a8ea07737acbd00822ec9e49840776244c14" translate="yes" xml:space="preserve">
          <source>IdxInsert</source>
          <target state="translated">IdxInsert</target>
        </trans-unit>
        <trans-unit id="ba9bc003fbf28927e55ed674e6312a7b981c1435" translate="yes" xml:space="preserve">
          <source>IdxLE</source>
          <target state="translated">IdxLE</target>
        </trans-unit>
        <trans-unit id="11ede54300baae62726a3150e6c2f825098c4577" translate="yes" xml:space="preserve">
          <source>IdxLT</source>
          <target state="translated">IdxLT</target>
        </trans-unit>
        <trans-unit id="c82f35a450e8e6ba85d6a5ba639866e8424ba8d9" translate="yes" xml:space="preserve">
          <source>IdxRowid</source>
          <target state="translated">IdxRowid</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7194c23292e4ec0e7bfbbaa15bc21cc90107f2f5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象V是使用&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer（S，I，P，X，D）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer（C，P，X，D）&lt;/a&gt;初始化的，并且X和Y是根据strcmp（X，Y）比较相等的字符串，则sqlite3_value_pointer（V，Y）将返回指针P。否则，sqlite3_value_pointer（V，Y）返回NULL。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="6f26b5b5b34df807b99862702ef8a28042e009ca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;../uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">如果启用了&lt;a href=&quot;../uri&quot;&gt;URI文件名&lt;/a&gt;解释，并且filename参数以&amp;ldquo; file：&amp;rdquo;开头，则文件名将解释为URI。如果在sqlite3_open_v2（）的第三个参数中设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志，或者已使用带有&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;方法的&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;选项或通过&lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt;编译时选项全局启用了URI文件名解释，则启用URI文件名解释。 URI文件名解释默认情况下处于关闭状态，但是SQLite的未来版本可能默认情况下启用URI文件名解释。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;../uri&quot;&gt;URI文件名&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="05071756ec11a7890791b184fe1e16795132ff77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;enabled&lt;/a&gt; and a column with a &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES clause&lt;/a&gt; is added, the column must have a default value of NULL.</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;启用&lt;/a&gt;了&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;，并且添加了带有&lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES子句&lt;/a&gt;的列，则该列的默认值必须为NULL。</target>
        </trans-unit>
        <trans-unit id="4f1ff78b03ab38bd9d7bc0c0b70bf71a047d9c7f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are enabled, a DROP TABLE command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt; command before removing the table from the database schema. Any triggers attached to the table are dropped from the database schema before the implicit DELETE FROM is executed, so this cannot cause any triggers to fire. By contrast, an implicit DELETE FROM does cause any configured &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; to take place. If the implicit DELETE FROM executed as part of a DROP TABLE command violates any immediate foreign key constraints, an error is returned and the table is not dropped. If the implicit DELETE FROM causes any deferred foreign key constraints to be violated, and the violations still exist when the transaction is committed, an error is returned at the time of commit.</source>
          <target state="translated">如果启用了&lt;a href=&quot;foreignkeys&quot;&gt;外键约束，&lt;/a&gt;则DROP TABLE命令会在从数据库模式中删除表之前执行隐式的&lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt;命令。在执行隐式DELETE FROM之前，将从数据库架构中删除任何附加到表的触发器，因此这不会导致触发任何触发器。相比之下，隐式DELETE FROM确实会导致任何已配置的&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外键动作&lt;/a&gt;发生。如果作为DROP TABLE命令的一部分执行的隐式DELETE FROM违反任何立即外键约束，则将返回错误，并且不会删除该表。如果隐式DELETE FROM导致违反了任何延迟的外键约束，并且在提交事务时仍然存在冲突，则在提交时返回错误。</target>
        </trans-unit>
        <trans-unit id="5f1e27999e2bb2ba42de86bd45d31998c0603f29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is set to OFF (thus disabling the rollback journal file) then the behavior of the ROLLBACK command is undefined.</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt;设置为OFF（从而禁用回滚日志文件），则ROLLBACK命令的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="ff29cd60491f93076673fb75bedc0744960c9309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;EXCLUSIVE locking mode&lt;/a&gt; is set prior to the first WAL-mode database access, then SQLite never attempts to call any of the shared-memory methods and hence no shared-memory wal-index is ever created. In that case, the database connection remains in EXCLUSIVE mode as long as the journal mode is WAL; attempts to change the locking mode using &quot;&lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt;&quot; are no-ops. The only way to change out of EXCLUSIVE locking mode is to first change out of WAL journal mode.</source>
          <target state="translated">如果在第一次WAL模式数据库访问之前设置了&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;EXCLUSIVE锁定模式&lt;/a&gt;，则SQLite绝不会尝试调用任何共享内存方法，因此将永远不会创建共享内存wal-index。在这种情况下，只要日志模式为WAL，数据库连接就保持为EXCLUSIVE模式。尝试使用&amp;ldquo; &lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt; &amp;rdquo; 更改锁定模式是无操作。退出EXCLUSIVE锁定模式的唯一方法是首先退出WAL日志模式。</target>
        </trans-unit>
        <trans-unit id="53ecc95d367e022d4f668ded862caf4b37a61a3f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">如果启用了&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;解释，并且filename参数以&amp;ldquo; file：&amp;rdquo;开头，则文件名将解释为URI。如果在sqlite3_open_v2（）的第三个参数中设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志，或者已使用带有&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;方法的&lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;选项或通过&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt;编译时选项全局启用了URI文件名解释，则启用URI文件名解释。 URI文件名解释默认情况下处于关闭状态，但是SQLite的未来版本可能默认情况下启用URI文件名解释。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0b1cbecea1bfc84769a23d468c11c6578d2f04c8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">如果&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象V是使用&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer（S，I，P，X，D）&lt;/a&gt;或&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer（C，P，X，D）&lt;/a&gt;初始化的，并且X和Y是根据strcmp（X，Y）比较相等的字符串，则sqlite3_value_pointer（V，Y）将返回指针P。否则，sqlite3_value_pointer（V，Y）返回NULL。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="efa51497a7f80ea6cb0e82aee000934c754a4257" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B THEN B&amp;gt;A.</source>
          <target state="translated">如果A &amp;lt;B然后B&amp;gt; A。</target>
        </trans-unit>
        <trans-unit id="af85ab5198e03592c9a1e93f75055ff7f7b4d432" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B and B&amp;lt;C then A&amp;lt;C.</source>
          <target state="translated">如果A &amp;lt;B且B &amp;lt;C，则A &amp;lt;C。</target>
        </trans-unit>
        <trans-unit id="ee7bb0a19c51474ba2d6ea010cd538d977b0b7a6" translate="yes" xml:space="preserve">
          <source>If A==B and B==C then A==C.</source>
          <target state="translated">如果A==B,B==C,那么A==C。</target>
        </trans-unit>
        <trans-unit id="ad62f244096def890ab26a681e8f0120126f5af5" translate="yes" xml:space="preserve">
          <source>If A==B then B==A.</source>
          <target state="translated">如果A==B,那么B==A。</target>
        </trans-unit>
        <trans-unit id="215c914a1a9a516e367b5ac91682005ac659922c" translate="yes" xml:space="preserve">
          <source>If AUTOVACUUM is enabled then it is possible that another root page might be moved into the newly deleted root page in order to keep all root pages contiguous at the beginning of the database. The former value of the root page that moved - its value before the move occurred - is stored in register P2. If no page movement was required (because the table being dropped was already the last one in the database) then a zero is stored in register P2. If AUTOVACUUM is disabled then a zero is stored in register P2.</source>
          <target state="translated">如果启用了AUTOVACUUM,那么就有可能将另一个根页移动到新删除的根页中,以便在数据库开始时保持所有根页的连续。移动的根页的前值--移动发生前的值--存储在寄存器P2中。如果不需要移动页面(因为被删除的表已经是数据库中的最后一个表),那么在寄存器P2中存储一个零。如果AUTOVACUUM被禁用,那么在寄存器P2中存储一个零。</target>
        </trans-unit>
        <trans-unit id="ed950ba22e4eb6cfb3232df6ec7b67b59a4df463" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflict handler, then the conflicting row is removed from the database and a second attempt to apply the change is made. If this second attempt fails, the original row is restored to the database before continuing.</source>
          <target state="translated">如果CHANGESET_REPLACE被SQLITE_CHANGESET_CONFLICT冲突处理程序返回,那么冲突的记录将被从数据库中删除,并进行第二次尝试应用更改。如果第二次尝试失败,那么在继续应用之前,会将原来的记录恢复到数据库中。</target>
        </trans-unit>
        <trans-unit id="30467096b4dd78c0d45cf667e992ae71e7009c64" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflict handler, then the conflicting row is either updated or deleted, depending on the type of change.</source>
          <target state="translated">如果CHANGESET_REPLACE被SQLITE_CHANGESET_DATA冲突处理程序返回,那么根据变化的类型,冲突的记录将被更新或删除。</target>
        </trans-unit>
        <trans-unit id="1a6c0fd79d5064239e68ae7d0df720319dab8e2b" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="translated">如果F是一个NULL指针,那么sqlite3_uri_parameter(F,P)返回NULL,sqlite3_uri_boolean(F,P,B)返回B.如果F不是一个NULL指针,也不是SQLite传递到xOpen VFS方法中的数据库文件路径名指针,那么这个例程的行为是没有定义的,可能是不可取的。</target>
        </trans-unit>
        <trans-unit id="7f60624c5c0f9adef9d93c9ed8179bc298264376" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that the SQLite core passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="translated">如果F是一个NULL指针,那么sqlite3_uri_parameter(F,P)返回NULL,sqlite3_uri_boolean(F,P,B)返回B.如果F不是一个NULL指针,也不是SQLite核心传递到xOpen VFS方法中的数据库文件路径名指针,那么这个例程的行为是未定义的,可能是不可取的。</target>
        </trans-unit>
        <trans-unit id="4646f7a7f8236532256725ec4112b997f511c7d6" translate="yes" xml:space="preserve">
          <source>If F is a suitable filename (as described in the previous paragraph) and if P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F and it has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">如果F是一个合适的文件名(如前一段所述),如果P是查询参数的名称,那么sqlite3_uri_parameter(F,P)返回P参数的值,如果P没有作为F上的查询参数出现,则返回一个NULL指针;如果P是F的一个查询参数,并且它没有显式的值,那么sqlite3_uri_parameter(F,P)返回一个指向空字符串的指针。</target>
        </trans-unit>
        <trans-unit id="9276605b0b0a889bb4c7aa5fcec85c6fc6240625" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">如果F是在xOpen（）的flags参数设置了一个或多个&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;或&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt;位且P是查询参数的名称时传递给VFS实现的xOpen（）方法的数据库文件名指针，则P为查询参数的名称，则sqlite3_uri_parameter（ F，P）返回P参数的值（如果存在）或NULL指针（如果P没有作为F的查询参数出现）。如果P是F的查询参数没有显式值，则sqlite3_uri_parameter（F，P）返回一个指向空字符串的指针。</target>
        </trans-unit>
        <trans-unit id="8ba138ee3e59443a69735dbcd87f0f8269dd9564" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">如果F是在xOpen（）的flags参数设置了一个或多个&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;或&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt;位且P是查询参数的名称时传递给VFS实现的xOpen（）方法的数据库文件名指针，则P为查询参数的名称，则sqlite3_uri_parameter（ F，P）返回P参数的值（如果存在）或NULL指针（如果P没有作为F的查询参数出现）。如果P是F的查询参数没有显式值，则sqlite3_uri_parameter（F，P）返回一个指向空字符串的指针。</target>
        </trans-unit>
        <trans-unit id="96db4246a2920821a0342bd0eb3ee7ac297124f4" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_journal(F) returns the name of the corresponding rollback journal file.</source>
          <target state="translated">如果F是SQLite内核传递到VFS的sqlite数据库文件，日志文件或WAL文件的名称，或者F是从&lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;获得的数据库文件名，则sqlite3_filename_journal（F）返回相应名称。回滚日志文件。</target>
        </trans-unit>
        <trans-unit id="de9e2b4e3e6dbb59da8102c1398e68c7ec62ce69" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_journal(F) returns the name of the corresponding rollback journal file.</source>
          <target state="translated">如果F是SQLite内核传递到VFS的sqlite数据库文件，日志文件或WAL文件的名称，或者F是从&lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;获得的数据库文件名，则sqlite3_filename_journal（F）返回相应名称。回滚日志文件。</target>
        </trans-unit>
        <trans-unit id="c5222d2f3de406b301b9d249247c656c5b47394f" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, then sqlite3_filename_database(F) returns the name of the corresponding database file.</source>
          <target state="translated">如果F是SQLite核心传递到VFS中的sqlite数据库文件、日志文件或WAL文件的名称,那么sqlite3_filename_database(F)返回相应数据库文件的名称。</target>
        </trans-unit>
        <trans-unit id="dbbd8f58db83b28c968f4a1fd0df5ad504ea9fa0" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file that was passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_wal(F) returns the name of the corresponding WAL file.</source>
          <target state="translated">如果F是SQLite内核传递到VFS的sqlite数据库文件，日志文件或WAL文件的名称，或者F是从&lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;获得的数据库文件名，则sqlite3_filename_wal（F）返回以下名称：相应的WAL文件。</target>
        </trans-unit>
        <trans-unit id="c242ec5d087c241619851f20f12670680d93e197" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file that was passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_wal(F) returns the name of the corresponding WAL file.</source>
          <target state="translated">如果F是SQLite内核传递到VFS的sqlite数据库文件，日志文件或WAL文件的名称，或者F是从&lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;获得的数据库文件名，则sqlite3_filename_wal（F）返回以下名称：相应的WAL文件。</target>
        </trans-unit>
        <trans-unit id="298246b211caead4a1410b71d74279a5d314bec4" translate="yes" xml:space="preserve">
          <source>If FILE is a ZIP archive rather than an SQLite Archive, the &quot;.archive&quot; command and the &quot;-A&quot; command-line option still work. This is accomplished using of the &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt; extension. Hence, the following commands are roughly equivalent, differing only in output formatting:</source>
          <target state="translated">如果FILE是ZIP存档而不是SQLite存档，则&amp;ldquo; .archive&amp;rdquo;命令和&amp;ldquo; -A&amp;rdquo;命令行选项仍然有效。这是使用&lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;扩展名完成的。因此，以下命令大致等效，仅在输出格式上有所不同：</target>
        </trans-unit>
        <trans-unit id="d860543f88997bfbcee9b4b76e89b05bba6e3e47" translate="yes" xml:space="preserve">
          <source>If M is -1 in the initial journal header, then the number of page records that follow is computed by computing how many page records will fit in the available space of the remainder of the journal file.</source>
          <target state="translated">如果初始日记头中的M为-1,那么接下来的页记录数是通过计算日记文件剩余的可用空间能容纳多少页记录来计算的。</target>
        </trans-unit>
        <trans-unit id="9d3a57a4870ed12272e250deed6ea841c224df1b" translate="yes" xml:space="preserve">
          <source>If NORMAL locking mode is in effect for the first WAL-mode database access, then the shared-memory wal-index is created. This means that the underlying VFS must support the &quot;version 2&quot; shared-memory. If the VFS does not support shared-memory methods, then the attempt to open a database that is already in WAL mode, or the attempt convert a database into WAL mode, will fail. As long as exactly one connection is using a shared-memory wal-index, the locking mode can be changed freely between NORMAL and EXCLUSIVE. It is only when the shared-memory wal-index is omitted, when the locking mode is EXCLUSIVE prior to the first WAL-mode database access, that the locking mode is stuck in EXCLUSIVE.</source>
          <target state="translated">如果第一次WAL模式的数据库访问采用NORMAL锁定模式,那么就会创建共享内存wal-index,这意味着底层VFS必须支持 &quot;版本2 &quot;共享内存。这意味着底层VFS必须支持 &quot;版本2 &quot;的共享内存。如果VFS不支持共享内存方法,那么尝试打开一个已经处于WAL模式的数据库,或者尝试将一个数据库转换为WAL模式,都会失败。只要正好有一个连接在使用共享内存wal-index,锁定模式就可以在normal和exclusive之间自由切换。只有当省略了共享内存wal-index,在第一次WAL模式数据库访问之前锁定模式为EXCLUSIVE时,锁定模式才会停留在EXCLUSIVE。</target>
        </trans-unit>
        <trans-unit id="084a98d24eb789b16e0f410999491d6ca6f68655" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mode column, then the mode of the new archive entry is automatically set to either 33188 (-rw-r--r--) or 16877 (drwxr-xr-x), depending on whether or not the values specified for columns &quot;sz&quot;, &quot;data&quot; and &quot;rawdata&quot; indicate that the new entry is a directory.</source>
          <target state="translated">如果在模式列中插入 NULL,那么新归档条目的模式将自动设置为 33188 (-rw-r--r--)或 16877 (drwxr-xr-x),这取决于为 &quot;sz&quot;、&quot;data &quot;和 &quot;rawdata &quot;列指定的值是否表明新条目是一个目录。</target>
        </trans-unit>
        <trans-unit id="4101f8cb88698edd15d7c951de1289b2d8eaa71c" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mtime column, then the timestamp of the new entry is set to the current time. Otherwise, the specified value is interpreted as an integer and used as is.</source>
          <target state="translated">如果在mtime列中插入NULL,那么新条目的时间戳将被设置为当前时间。否则,指定的值被解释为整数,并按原样使用。</target>
        </trans-unit>
        <trans-unit id="43806989f629698fba47d7f7a7bc8a167120b2e8" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_area(P) returns the area enclosed by that polygon. If P is not a polygon, geopoly_area(P) returns NULL.</source>
          <target state="translated">如果P是一个多边形,那么geopoly_area(P)返回该多边形所包围的面积。如果P不是多边形,geopoly_area(P)返回NULL。</target>
        </trans-unit>
        <trans-unit id="7923fadf3f55cd9b6d47a16ad18e97575f464043" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_bbox(P) returns a new polygon that is the smallest (axis-aligned) rectangle completely enclosing P. If P is not a polygon, geopoly_bbox(P) returns NULL.</source>
          <target state="translated">如果 P 是一个多边形,那么 geopoly_bbox(P)返回一个新的多边形,这个多边形是完全包围 P 的最小(轴对齐)的矩形。</target>
        </trans-unit>
        <trans-unit id="231cf86fd88561789cf32053e3b5a58ac30a1c90" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_blob(P) returns the binary encoding of that polygon as a BLOB. If P is not a polygon, geopoly_blob(P) returns NULL.</source>
          <target state="translated">如果P是一个多边形,那么geopoly_blob(P)返回该多边形的二进制编码为BLOB。如果P不是多边形,geopoly_blob(P)返回NULL。</target>
        </trans-unit>
        <trans-unit id="85466629c4fd74bf6816a1cb264ff5557384a47f" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_contains_point(P,X,Y) returns a non-zero integer if and only if the coordinate X,Y is inside or on the boundary of the polygon P. If P is not a polygon, geopoly_contains_point(P,X,Y) returns NULL.</source>
          <target state="translated">如果P是一个多边形,那么geopoly_contains_point(P,X,Y)返回一个非零整数,前提是坐标X,Y在多边形P的内部或边界上。如果P不是多边形,geopoly_contains_point(P,X,Y)返回NULL。</target>
        </trans-unit>
        <trans-unit id="01d01cedd541548c033da5a76ae2b943d566e364" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_json(P) returns the GeoJSON representation of that polygon as a TEXT string. If P is not a polygon, geopoly_json(P) returns NULL.</source>
          <target state="translated">如果P是一个多边形,那么geopoly_json(P)以TEXT字符串的形式返回该多边形的GeoJSON表示。如果P不是多边形,geopoly_json(P)返回NULL。</target>
        </trans-unit>
        <trans-unit id="4d96f5fac84b02e3eed71829015c2301166a1102" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_svg(P,...) returns a text string which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;Scalable Vector Graphics (SVG)&lt;/a&gt; representation of that polygon. If there is more one argument, then second and subsequent arguments are added as attributes to each SVG glyph. For example:</source>
          <target state="translated">如果P是多边形，则geopoly_svg（P，...）返回一个文本字符串，该字符串是该多边形的&lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;可缩放矢量图形（SVG）&lt;/a&gt;表示形式。如果有多个自变量，则将第二个和后续自变量作为属性添加到每个SVG字形。例如：</target>
        </trans-unit>
        <trans-unit id="8bf89c8791c7886430f52d199af4522be0892c2c" translate="yes" xml:space="preserve">
          <source>If P is not a polygon, geopoly_svg(P,...) returns NULL.</source>
          <target state="translated">如果P不是多边形,geopoly_svg(P,...)返回NULL。</target>
        </trans-unit>
        <trans-unit id="8d6c1d000f406140de377a0a6166c3f4f4ee6ecf" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;gt;X then the first M bytes of P are stored on the btree page and the remaining P-M bytes are stored on overflow pages.</source>
          <target state="translated">如果P&amp;gt; X和K&amp;gt; X，则P的前M个字节存储在btree页上，其余PM个字节存储在溢出页上。</target>
        </trans-unit>
        <trans-unit id="40c35ab59089c6d8a3b822955c4be859755a9e2b" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;lt;=X then the first K bytes of P are stored on the btree page and the remaining P-K bytes are stored on overflow pages.</source>
          <target state="translated">如果P&amp;gt; X并且K &amp;lt;= X，则P的前K个字节存储在btree页上，其余PK字节存储在溢出页上。</target>
        </trans-unit>
        <trans-unit id="fa33ffa92f81891eff9dffa21d7e8d38e3faa786" translate="yes" xml:space="preserve">
          <source>If P&amp;lt;=X then all P bytes of payload are stored directly on the btree page without overflow.</source>
          <target state="translated">如果P &amp;lt;= X，则所有有效载荷的P个字节均直接存储在btree页上，而不会发生溢出。</target>
        </trans-unit>
        <trans-unit id="a69350651a4faef3f95c007babd7352f8f77d85e" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_overlap(P1,P2) function returns a non-zero integer if there is any overlap between P1 and P2, or it returns zero if P1 and P2 completely disjoint. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">如果P1和P2都是多边形,那么geopoly_overlap(P1,P2)函数在P1和P2之间有任何重叠时返回一个非零的整数,或者在P1和P2完全不相交时返回零。如果P1或P2不是多边形,这个例程返回NULL。</target>
        </trans-unit>
        <trans-unit id="3222b98590b837273b0d4239ca32f6bb0d30ac83" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P1 is completely contained within P2, or it returns zero if any part of P1 is outside of P2. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">如果P1和P2都是多边形,那么如果P1完全包含在P2中,那么函数geopoly_within(P1,P2)返回一个非零整数,如果P1的任何部分在P2之外,则返回零。如果P1和P2是同一个多边形,这个例程返回非零。如果P1或P2不是一个多边形,这个例程返回NULL。</target>
        </trans-unit>
        <trans-unit id="dd9f5db9ef38463d2501fa9dc6b70e3f4750a4f2" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P2 is completely contained within P1, or it returns zero if any part of P2 is outside of P1. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">如果P1和P2都是多边形,那么如果P2完全包含在P1内,geopoly_within(P1,P2)函数返回一个非零整数,如果P2的任何部分在P1之外,则返回零。如果P1和P2是同一个多边形,这个例程返回非零。如果P1或P2不是一个多边形,这个例程返回NULL。</target>
        </trans-unit>
        <trans-unit id="4157b5ffd90247cfe9008c1ae67666efa84d2bdb" translate="yes" xml:space="preserve">
          <source>If P1 is 0, then all SQL statements become expired. If P1 is non-zero, then only the currently executing statement is expired.</source>
          <target state="translated">如果P1为0,那么所有的SQL语句都会过期。如果P1为非零,那么只有当前执行的语句过期。</target>
        </trans-unit>
        <trans-unit id="7196e8103cc1b57f49e64f9cffafd04bf56cea94" translate="yes" xml:space="preserve">
          <source>If P1 is non-zero, then the jump is taken if the database constraint-counter is zero (the one that counts deferred constraint violations). If P1 is zero, the jump is taken if the statement constraint-counter is zero (immediate foreign key constraint violations).</source>
          <target state="translated">如果P1为非零,那么如果数据库约束计数器为零(计算延迟约束违反的那个),就会进行跳转。如果P1为零,那么如果语句约束计数器为零(即时外键约束违反),则进行跳转。</target>
        </trans-unit>
        <trans-unit id="e76da0aa98d442426a710c17ffdd5c83f500e5de" translate="yes" xml:space="preserve">
          <source>If P1 is not zero, then it is a register that a subsequent min() or max() aggregate will set to 1 if the current row is not the minimum or maximum. The P1 register is initialized to 0 by this instruction.</source>
          <target state="translated">如果P1不为0,那么它是一个寄存器,如果当前行不是最小行或最大行,那么后续的min()或max()集合将设置为1。该指令将P1寄存器初始化为0。</target>
        </trans-unit>
        <trans-unit id="12e05de4c2b1f6e3dffb8fed2e435034a63c1753" translate="yes" xml:space="preserve">
          <source>If P2 is 0, then SQL statements are expired immediately. If P2 is 1, then running SQL statements are allowed to continue to run to completion. The P2==1 case occurs when a CREATE INDEX or similar schema change happens that might help the statement run faster but which does not affect the correctness of operation.</source>
          <target state="translated">如果P2为0,则SQL语句立即过期。如果P2为1,则允许正在运行的SQL语句继续运行至完成。P2==1的情况发生在发生CREATE INDEX或类似的模式变化时,这种变化可能会帮助语句运行得更快,但并不影响操作的正确性。</target>
        </trans-unit>
        <trans-unit id="b95c82eece8cdb232cd3c969e9f714560a3483ed" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, jump to instruction P2.</source>
          <target state="translated">如果P2不为零,则跳转到指令P2。</target>
        </trans-unit>
        <trans-unit id="624ae34f34a46b97a6ede8c6928e2854d808cc50" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, then it is a register holding a string which is the file into which the result of vacuum should be written. When P2 is zero, the vacuum overwrites the original database.</source>
          <target state="translated">如果P2不为零,那么它是一个持有字符串的寄存器,这个字符串是真空结果应该写入的文件。当P2为零时,真空会覆盖原来的数据库。</target>
        </trans-unit>
        <trans-unit id="7f685a86b5e506b77efdf72c9ec8070a39f8b40d" translate="yes" xml:space="preserve">
          <source>If P2 is the SCHEMA_VERSION cookie (cookie number 1) then the internal schema version is set to P3-P5. The &quot;PRAGMA schema_version=N&quot; statement has P5 set to 1, so that the internal schema version will be different from the database schema version, resulting in a schema reset.</source>
          <target state="translated">如果P2是SCHEMA_VERSION cookie(cookie号为1),那么内部模式版本就设置为P3-P5。&quot;PRAGMA schema_version=N &quot;语句中,P5设置为1,这样内部模式版本将与数据库模式版本不同,导致模式重置。</target>
        </trans-unit>
        <trans-unit id="4101c4124c3fe6e483990efc85814b11a364af14" translate="yes" xml:space="preserve">
          <source>If P2!=0 then the coroutine implementation immediately follows this opcode. So jump over the coroutine implementation to address P2.</source>
          <target state="translated">如果P2!=0,那么coroutine实现紧接着这个操作码。所以跳过coroutine实现来寻址P2。</target>
        </trans-unit>
        <trans-unit id="95acd6cd81e68312a7b3f200adb71394407e2187" translate="yes" xml:space="preserve">
          <source>If P2==1 then no insert is performed. argv[0] is the rowid of a row to delete.</source>
          <target state="translated">如果P2==1,则不执行插入操作。 argv[0]是要删除的记录的rowid。</target>
        </trans-unit>
        <trans-unit id="4b3305a3179f27393cd2b3c6dff28468fd2e27f2" translate="yes" xml:space="preserve">
          <source>If P3 is not zero and the content of register P3 is equal to P5, then the datatype of the register P2 is converted to BLOB. The content is the same sequence of bytes, it is merely interpreted as a BLOB instead of a string, as if it had been CAST. In other words:</source>
          <target state="translated">如果P3不为零,并且寄存器P3的内容等于P5,那么寄存器P2的数据类型就被转换为BLOB。内容是相同的字节序列,只是被解释为BLOB而不是字符串,就像被CAST一样。换句话说。</target>
        </trans-unit>
        <trans-unit id="7b12a88585bcaf8799451da77eaddd8eae80e136" translate="yes" xml:space="preserve">
          <source>If P3 is not zero, then it is an address to jump to if an SQLITE_CORRUPT error is encountered.</source>
          <target state="translated">如果P3不为零,那么它是遇到SQLITE_CORRUPT错误时跳转的地址。</target>
        </trans-unit>
        <trans-unit id="fb1bf816dbb55169e5b2d71bf5d2b1c16bfeaa50" translate="yes" xml:space="preserve">
          <source>If P3 is positive, then reg[P3] is modified slightly so that it can be used as zero-length data for &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;. This is an optimization that avoids an extra &lt;a href=&quot;opcode#Blob&quot;&gt;Blob&lt;/a&gt; opcode to initialize that register.</source>
          <target state="translated">如果P3为正，则对reg [P3]进行一些修改，以便可以将其用作&lt;a href=&quot;opcode#Insert&quot;&gt;Insert的&lt;/a&gt;零长度数据。这种优化避免了额外的&lt;a href=&quot;opcode#Blob&quot;&gt;Blob&lt;/a&gt;操作码来初始化该寄存器。</target>
        </trans-unit>
        <trans-unit id="c8b8a297f15c969bf51cec7bd085ee38d68f8af2" translate="yes" xml:space="preserve">
          <source>If P3!=0 then the content of the P2 register is unsuitable for use in OP_Result and any OP_Result will invalidate the P2 register content. The P2 register content is invalidated by opcodes like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; or by any use of another cursor pointing to the same table.</source>
          <target state="translated">如果P3！= 0，则P2寄存器的内容不适合在OP_Result中使用，任何OP_Result都会使P2寄存器的内容无效。P2寄存器的内容会被&lt;a href=&quot;opcode#Function&quot;&gt;功能&lt;/a&gt;（如Function）之类的操作码或指向该表的另一个游标的任何使用所无效。</target>
        </trans-unit>
        <trans-unit id="f0e377e900f9f81e14b13484040277f239153040" translate="yes" xml:space="preserve">
          <source>If P3!=0 then this opcode is allowed to make an ephemeral pointer into the database page. That means that the content of the output register will be invalidated as soon as the cursor moves - including moves caused by other cursors that &quot;save&quot; the current cursors position in order that they can write to the same table. If P3==0 then a copy of the data is made into memory. P3!=0 is faster, but P3==0 is safer.</source>
          <target state="translated">如果P3!=0,那么这个操作码被允许做一个短暂的指针进入数据库页面。这意味着一旦光标移动,输出寄存器的内容就会失效--包括其他光标引起的移动,这些光标 &quot;保存 &quot;了当前光标的位置,以便它们能够写入同一个表。如果P3==0,那么就会将数据复制到内存中。P3!=0更快,但P3==0更安全。</target>
        </trans-unit>
        <trans-unit id="261dff5d4c60a753fca80ceb7a30b1ccde835d53" translate="yes" xml:space="preserve">
          <source>If P3&amp;gt;0 then P3 is a register in the root frame of this VDBE that holds the largest previously generated record number. No new record numbers are allowed to be less than this value. When this value reaches its maximum, an SQLITE_FULL error is generated. The P3 register is updated with the ' generated record number. This P3 mechanism is used to help implement the AUTOINCREMENT feature.</source>
          <target state="translated">如果P3&amp;gt; 0，则P3是此VDBE根帧中的一个寄存器，该寄存器保存了以前最大的记录编号。不允许新的记录号小于该值。当该值达到最大值时，将生成SQLITE_FULL错误。用生成的记录号更新P3寄存器。此P3机制用于帮助实现AUTOINCREMENT功能。</target>
        </trans-unit>
        <trans-unit id="b537aafa079e151774c7dbac498d69a9800ce496" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==0 then r[P2] := r[P1] IS TRUE</source>
          <target state="translated">如果P3==0,P4==0,则r[P2]:=r[P1]IS TRUE。</target>
        </trans-unit>
        <trans-unit id="4abb01d048e9054de1718b2c97d7bca8f72ca3fd" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==1 then r[P2] := r[P1] IS NOT TRUE</source>
          <target state="translated">如果P3==0,P4==1,则r[P2]:=r[P1]IS NOT TRUE。</target>
        </trans-unit>
        <trans-unit id="dffd9f3f7dcda52e1f25f401261075e7728503f3" translate="yes" xml:space="preserve">
          <source>If P3==0, then an exact count is obtained, which involves visiting every btree page of the table. But if P3 is non-zero, an estimate is returned based on the current cursor position.</source>
          <target state="translated">如果P3==0,则会得到一个精确的计数,这需要访问表的每一个btree页。但如果P3是非零,则根据当前光标位置返回一个估计值。</target>
        </trans-unit>
        <trans-unit id="e0f5592c3dfac53b5b17bcf906b1b3d9b28a160a" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==0 then r[P2] := r[P1] IS NOT FALSE</source>
          <target state="translated">如果P3==1,P4==0,那么r[P2]:=r[P1]IS NOT FALSE。</target>
        </trans-unit>
        <trans-unit id="ec92d66dd345ec321132b256dce88d1a72413c5f" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==1 then r[P2] := r[P1] IS FALSE</source>
          <target state="translated">如果P3==1,P4==1,那么r[P2]:=r[P1]IS FALSE。</target>
        </trans-unit>
        <trans-unit id="ec8063043e0a9cad56cc57c55e1e58a5f2b9e719" translate="yes" xml:space="preserve">
          <source>If P4 is NULL then all index fields have the affinity BLOB.</source>
          <target state="translated">如果P4为NULL,那么所有的索引字段都有亲和力BLOB。</target>
        </trans-unit>
        <trans-unit id="0409d4d0ae010acb4eb82b5c67e7d26a4e78a377" translate="yes" xml:space="preserve">
          <source>If P4 is not NULL then it points to a Table object. In this case either the update or pre-update hook, or both, may be invoked. The P1 cursor must have been positioned using &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; prior to invoking this opcode in this case. Specifically, if one is configured, the pre-update hook is invoked if P4 is not NULL. The update-hook is invoked if one is configured, P4 is not NULL, and the OPFLAG_NCHANGE flag is set in P2.</source>
          <target state="translated">如果P4不为NULL，则它指向Table对象。在这种情况下，可以调用更新钩子或更新钩子，或两者都被调用。在这种情况下，在调用此操作码之前，必须已使用&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;定位了P1光标。具体来说，如果配置了一个，则如果P4不为NULL，则调用更新前挂钩。如果配置了一个，P4不为NULL，并且在P2中设置了OPFLAG_NCHANGE标志，则调用更新挂钩。</target>
        </trans-unit>
        <trans-unit id="833039fcfc9ba1341a8bac648d6011bebc9ef640" translate="yes" xml:space="preserve">
          <source>If P4 is not null then it is an error message string.</source>
          <target state="translated">如果P4不为空,那么它就是一个错误信息字符串。</target>
        </trans-unit>
        <trans-unit id="323b07c0a29678efca20be714e85be9034012831" translate="yes" xml:space="preserve">
          <source>If P4 is not zero, then it is the number of values in the unpacked key of reg(P2). In that case, P3 is the index of the first register for the unpacked key. The availability of the unpacked key can sometimes be an optimization.</source>
          <target state="translated">如果P4不为零,那么它就是reg(P2)的解包键的值数。在这种情况下,P3是解包键的第一个寄存器的索引。解包键的可用性有时也是一种优化。</target>
        </trans-unit>
        <trans-unit id="7f6b94d7be2c05fd8f0bc6b7de40e344824f8d5b" translate="yes" xml:space="preserve">
          <source>If P4==0 then register P3 holds a blob constructed by &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;. If P4&amp;gt;0 then register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">如果P4 == 0，则寄存器P3包含由&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;构造的blob。如果P4&amp;gt; 0，则寄存器P3是构成未打包记录的P4寄存器中的第一个。</target>
        </trans-unit>
        <trans-unit id="ea0d786e8193b3191b8e71dcd7cd40efa9daf92e" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_APPEND bit set, that is a hint to the b-tree layer that this insert is likely to be an append.</source>
          <target state="translated">如果P5设置了OPFLAG_APPEND位,那就是提示b树层,这个插入很可能是一个追加。</target>
        </trans-unit>
        <trans-unit id="b63e95392a3322ead1cda4df48bfef1df78fcfb5" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_NCHANGE bit set, then the change counter is incremented by this instruction. If the OPFLAG_NCHANGE bit is clear, then the change counter is unchanged.</source>
          <target state="translated">如果P5的OPFLAG_NCHANGE位被设置,那么变化计数器就会被该指令递增。如果OPFLAG_NCHANGE位被清除,那么变化计数器不变。</target>
        </trans-unit>
        <trans-unit id="1ea732c0486f9121ffc851f241dea7753a429516" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_PERMUTE bit set, then the order of comparison is determined by the most recent &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; operator. If the OPFLAG_PERMUTE bit is clear, then register are compared in sequential order.</source>
          <target state="translated">如果P5的OPFLAG_PERMUTE位置1，则比较顺序由最新的&lt;a href=&quot;opcode#Permutation&quot;&gt;置换&lt;/a&gt;运算符确定。如果OPFLAG_PERMUTE位清零，则按顺序比较寄存器。</target>
        </trans-unit>
        <trans-unit id="d566e20d0304652ba9b826870e3331951b73f1a1" translate="yes" xml:space="preserve">
          <source>If P5 is non-zero, then recursive program invocation is enabled.</source>
          <target state="translated">如果P5为非零,则启用递归程序调用。</target>
        </trans-unit>
        <trans-unit id="8cc4989073012226802ebb0b0b0287d0ebbc4c24" translate="yes" xml:space="preserve">
          <source>If P5 is not zero and P4 is NULL, then everything after the &quot;:&quot; is omitted.</source>
          <target state="translated">如果P5不为零,且P4为NULL,则省略&quot;:&quot;后的所有内容。</target>
        </trans-unit>
        <trans-unit id="6140b6bc786ef6328163c583ea74afbbf1b0203f" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, the check is done on the auxiliary database file, not the main database file.</source>
          <target state="translated">如果P5不为零,则对辅助数据库文件进行检查,而不是主数据库文件。</target>
        </trans-unit>
        <trans-unit id="4031180a3fa926570f402abdb205aa9088ecbac2" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, then raise an SQLITE_CORRUPT_INDEX error if no matching index entry is found. This happens when running an UPDATE or DELETE statement and the index entry to be updated or deleted is not found. For some uses of &lt;a href=&quot;opcode#IdxDelete&quot;&gt;IdxDelete&lt;/a&gt; (example: the EXCEPT operator) it does not matter that no matching entry is found. For those cases, P5 is zero.</source>
          <target state="translated">如果P5不为零，则在找不到匹配的索引条目的情况下引发SQLITE_CORRUPT_INDEX错误。当运行UPDATE或DELETE语句并且找不到要更新或删除的索引条目时，会发生这种情况。对于&lt;a href=&quot;opcode#IdxDelete&quot;&gt;IdxDelete的&lt;/a&gt;某些用法（例如：EXCEPT运算符），没有匹配的条目都没关系。对于这些情况，P5为零。</target>
        </trans-unit>
        <trans-unit id="6f3d5e8ef0f60d316b59356518575a2f176eb4d7" translate="yes" xml:space="preserve">
          <source>If P5 is positive and the jump is taken, then event counter number P5-1 in the prepared statement is incremented.</source>
          <target state="translated">如果P5为正值,并且采取了跳转,那么准备好的语句中的事件计数器号P5-1就会递增。</target>
        </trans-unit>
        <trans-unit id="e77300f272721b16413737d1f5909b28a7b7a6ee" translate="yes" xml:space="preserve">
          <source>If P5 is set, then all released registers have their type set to MEM_Undefined so that any subsequent attempt to read the released register (before it is reinitialized) will generate an assertion fault.</source>
          <target state="translated">如果设置了P5,那么所有被释放的寄存器的类型都被设置为MEM_Undefined,这样任何后续的读取被释放的寄存器的尝试(在它被重新初始化之前)都会产生一个断言故障。</target>
        </trans-unit>
        <trans-unit id="6d64a234f707179617701bb23c32b6ab90539344" translate="yes" xml:space="preserve">
          <source>If P5!=0 then this opcode also checks the schema cookie against P3 and the schema generation counter against P4. The cookie changes its value whenever the database schema changes. This operation is used to detect when that the cookie has changed and that the current process needs to reread the schema. If the schema cookie in P3 differs from the schema cookie in the database header or if the schema generation counter in P4 differs from the current generation counter, then an SQLITE_SCHEMA error is raised and execution halts. The sqlite3_step() wrapper function might then reprepare the statement and rerun it from the beginning.</source>
          <target state="translated">如果P5!=0,那么这个操作码也会对照P3检查schema cookie,对照P4检查schema生成计数器。每当数据库模式发生变化时,cookie就会改变其值。这个操作是用来检测什么时候该cookie已经改变,当前进程需要重新读取模式。如果P3中的模式cookie与数据库头中的模式cookie不同,或者P4中的模式生成计数器与当前的生成计数器不同,那么就会引发SQLITE_SCHEMA错误,并停止执行。sqlite3_step()封装函数可能会重新准备语句,并从头开始重新运行。</target>
        </trans-unit>
        <trans-unit id="79b8df381ad1ae2bdf21bac462376aead762296f" translate="yes" xml:space="preserve">
          <source>If RBU is used to update a large BLOB value within a target database, it may be more efficient to store a patch or delta that can be used to modify the existing BLOB instead of an entirely new value within the RBU database. RBU allows deltas to be specified in two ways:</source>
          <target state="translated">如果在目标数据库中使用 RBU 更新一个大的 BLOB 值,那么在 RBU 数据库中存储一个可用于修改现有 BLOB 的补丁或 delta 而不是一个全新的值可能会更有效。RBU允许以两种方式指定delta。</target>
        </trans-unit>
        <trans-unit id="f32404d913415ab312a2d32bca5267050dc55433" translate="yes" xml:space="preserve">
          <source>If SQLITE_DEFAULT_WAL_SYNCHRONOUS differs from SQLITE_DEFAULT_SYNCHRONOUS, and if the application has not modified the synchronous setting for the database file using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; statement, then the synchronous setting is changed to value defined by SQLITE_DEFAULT_WAL_SYNCHRONOUS when the database connection switches into WAL mode for the first time. If the SQLITE_DEFAULT_WAL_SYNCHRONOUS value is not overridden at compile-time, then it will always be the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and so no automatic synchronous setting changes will ever occur.</source>
          <target state="translated">如果SQLITE_DEFAULT_WAL_SYNCHRONOUS与SQLITE_DEFAULT_SYNCHRONOUS不同，并且如果应用程序未使用&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;语句修改数据库文件的同步设置，则当数据库连接首次切换到WAL模式时，同步设置将更改为SQLITE_DEFAULT_WAL_SYNCHRONOUS定义的值。如果在编译时未覆盖SQLITE_DEFAULT_WAL_SYNCHRONOUS值，则它将始终与&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;相同，因此将不会发生自动同步设置更改。</target>
        </trans-unit>
        <trans-unit id="35daf76480440bed2a0456819e4a2256b8e77c1e" translate="yes" xml:space="preserve">
          <source>If SQLITE_NULLEQ is set in P5 then the result of comparison is always either true or false and is never NULL. If both operands are NULL then the result of comparison is true. If either operand is NULL then the result is false. If neither operand is NULL the result is the same as it would be if the SQLITE_NULLEQ flag were omitted from P5.</source>
          <target state="translated">如果在P5中设置了SQLITE_NULLEQ,那么比较的结果总是true或false,永远不会是NULL。如果两个操作数都是NULL,那么比较的结果是true。如果两个操作数都是NULL,那么比较的结果是false。如果两个操作数都不是NULL,那么结果和P5中省略SQLITE_NULLEQ标志的结果是一样的。</target>
        </trans-unit>
        <trans-unit id="b5e1e68a469214facd1d655d6dbff18739ace55a" translate="yes" xml:space="preserve">
          <source>If SQLite discovers that the sqlite_sequence table has any other format, it returns the SQLITE_CORRUPT_SEQUENCE error.</source>
          <target state="translated">如果SQLite发现sqlite_sequence表有任何其他格式,就会返回SQLITE_CORRUPT_SEQUENCE错误。</target>
        </trans-unit>
        <trans-unit id="015569a0e55d69ecf2d3dec3d6ece8f0bde61846" translate="yes" xml:space="preserve">
          <source>If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.</source>
          <target state="translated">如果SQLite曾经从任何接口返回SQLITE_MISUSE,这意味着该应用程序的编码不正确,需要修复。不要发布一个有时从标准SQLite接口返回SQLITE_MISUSE的应用程序,因为该应用程序包含潜在的严重错误。</target>
        </trans-unit>
        <trans-unit id="60b69a270887c8a40e3999f62767f4e29079be3d" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the parser_trace pragma can be used to turn on tracing for the SQL parser used internally by SQLite. This feature is used for debugging SQLite itself.</source>
          <target state="translated">如果已使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则可以使用parser_trace编译指示为SQLite内部使用的SQL解析器打开跟踪。此功能用于调试SQLite本身。</target>
        </trans-unit>
        <trans-unit id="3e93855bd0fdb13d2772a4cf88fefeb516093bf0" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_addoptrace pragma can be used to cause a complete VDBE opcodes to be displayed as they are created during code generation. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则可以使用vdbe_addoptrace编译指示在代码生成期间创建完整的VDBE操作码时显示它们。此功能用于调试SQLite本身。有关更多信息，请参见&lt;a href=&quot;vdbe#trace&quot;&gt;VDBE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed1cfc408ef29e4c5084ed94c91a1453ae1e7d68" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_debug pragma is a shorthand for three other debug-only pragmas: vdbe_addoptrace, vdbe_listing, and vdbe_trace. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则vdbe_debug编译指示是其他三个仅调试编译指示的简写：vdbe_addoptrace，vdbe_listing和vdbe_trace。此功能用于调试SQLite本身。有关更多信息，请参见&lt;a href=&quot;vdbe#trace&quot;&gt;VDBE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e32eb3dd2a790d29e0b70974d295922571079df" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_listing pragma can be used to cause a complete listing of the virtual machine opcodes to appear on standard output as each statement is evaluated. With listing is on, the entire content of a program is printed just prior to beginning execution. The statement executes normally after the listing is printed. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果已经使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则可以使用vdbe_listing编译指示使虚拟机操作码的完整列表出现在标准输出中，并评估每个语句。启用清单后，程序的全部内容就在开始执行之前被打印出来。列表打印后，该语句正常执行。此功能用于调试SQLite本身。有关更多信息，请参见&lt;a href=&quot;vdbe#trace&quot;&gt;VDBE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cefc8fedb890f68ef15ff1358f045bdc3b72901b" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_trace pragma can be used to cause virtual machine opcodes to be printed on standard output as they are evaluated. This feature is used for debugging SQLite. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果已使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则可以使用vdbe_trace编译指示在评估虚拟机操作码时将其打印在标准输出上。此功能用于调试SQLite。有关更多信息，请参见&lt;a href=&quot;vdbe#trace&quot;&gt;VDBE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5153e53873f4aff61d1f8d367f68545fed69c0e7" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">如果在调用&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_complete16（）&lt;/a&gt;之前未使用sqlite3_initialize（）初始化SQLite，则sqlite3_complete16（）将自动调用sqlite3_initialize（）。如果该初始化失败，则无论输入SQL是否完成，sqlite3_complete16（）的返回值都将为非零。</target>
        </trans-unit>
        <trans-unit id="3c965f677e7c54456f9a69dea9325df1caaec3d9" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">如果在调用&lt;a href=&quot;initialize&quot;&gt;sqlite3_complete16（）&lt;/a&gt;之前未使用sqlite3_initialize（）初始化SQLite，则sqlite3_complete16（）将自动调用sqlite3_initialize（）。如果该初始化失败，则无论输入SQL是否完成，sqlite3_complete16（）的返回值都将为非零。</target>
        </trans-unit>
        <trans-unit id="6d6bbb3059e334920732ba9450708b663008dcc7" translate="yes" xml:space="preserve">
          <source>If SQLite is built with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option then the syntax of the UPDATE statement is extended with optional ORDER BY and LIMIT clauses as follows:</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;编译时选项构建SQLite ，则UPDATE语句的语法将通过可选的ORDER BY和LIMIT子句进行扩展，如下所示：</target>
        </trans-unit>
        <trans-unit id="44ff2e47de1d4a52252bdf0898ff4b68826c3d7a" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; compile-time option, then a different, thin wrapper is used around HeapAlloc(), HeapReAlloc(), and HeapFree(). The thin wrapper uses the configured SQLite heap, which will be different from the default process heap if the &lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt; compile-time option is used. In addition, when an allocation is made or freed, HeapValidate() will be called if SQLite is compiled with assert() enabled and the &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt; compile-time option.</source>
          <target state="translated">如果使用Windows &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLite_WIN32_MALLOC&lt;/a&gt;编译时选项为Windows编译了SQLite ，则在HeapAlloc（），HeapReAlloc（）和HeapFree（）周围使用不同的瘦包装器。精简包装使用配置的SQLite堆，如果使用&lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt;编译时选项，则它将与默认进程堆不同。另外，在分配或释放分配时，如果在启用assert（）和&lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt;编译时选项的情况下编译SQLite，则将调用HeapValidate（）。</target>
        </trans-unit>
        <trans-unit id="517e1af932491e30c32e06c4fd9e534300edd652" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; then another zero-malloc memory allocator, similar to memsys5, is included in the source tree. The memsys3 allocator, like memsys5, must be activated by a call to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). Memsys3 uses the memory buffer supplied as its source for all memory allocations. The difference between memsys3 and memsys5 is that memsys3 uses a different memory allocation algorithm that seems to work well in practice, but which does not provide mathematical guarantees against memory fragmentation and breakdown. Memsys3 was a predecessor to memsys5. The SQLite developers now believe that memsys5 is superior to memsys3 and that all applications that need a zero-malloc memory allocator should use memsys5 in preference to memsys3. Memsys3 is considered both experimental and deprecated and will likely be removed from the source tree in a future release of SQLite.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt;编译SQLite ，则源树中将包含另一个类似于memsys5的零malloc内存分配器。与memsys5一样，memsys3分配器必须通过调用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;，...）。 Memsys3使用提供的内存缓冲区作为所有内存分配的源。 memsys3和memsys5之间的区别在于memsys3使用了一种不同的内存分配算法，该算法在实践中似乎可以很好地工作，但是不能为防止内存碎片和崩溃提供数学保证。 Memsys3是memsys5的前身。现在，SQLite开发人员认为memsys5优于memsys3，并且所有需要零malloc内存分配器的应用程序都应优先使用memsys5而不是memsys3。 Memsys3被认为是实验性的，不建议使用，在将来的SQLite版本中可能会从源树中删除。</target>
        </trans-unit>
        <trans-unit id="a20ff9c15584045a4ca98d16d24d41c5ba218767" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option, then the syntax of the DELETE statement is extended by the addition of optional ORDER BY and LIMIT clauses:</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;编译时选项编译SQLite ，则通过添加可选的ORDER BY和LIMIT子句来扩展DELETE语句的语法：</target>
        </trans-unit>
        <trans-unit id="0e66b56024c7560826b0783e73206c696c2fa3db" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; compile-time option, then a different, heavy wrapper is used around system malloc(), realloc(), and free(). The heavy wrapper allocates around 100 bytes of extra space with each allocation. The extra space is used to place sentinel values at both ends of the allocation returned to the SQLite core. When an allocation is freed, these sentinels are checked to make sure the SQLite core did not overrun the buffer in either direction. When the system library is GLIBC, the heavy wrapper also makes use of the GNU backtrace() function to examine the stack and record the ancestor functions of the malloc() call. When running the SQLite test suite, the heavy wrapper also records the name of the current test case. These latter two features are useful for tracking down the source of memory leaks detected by the test suite.</source>
          <target state="translated">如果SQLite是使用&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;编译的编译时选项，然后在系统malloc（），realloc（）和free（）周围使用不同的繁重包装器。繁重的包装器每次分配都会分配大约100个字节的额外空间。多余的空间用于将哨兵值放置在返回到SQLite核心的分配的两端。释放分配后，将检查这些标记以确保SQLite内核没有在任一方向上溢出缓冲区。当系统库为GLIBC时，繁重的包装器还利用GNU backtrace（）函数检查堆栈并记录malloc（）调用的祖先函数。当运行SQLite测试套件时，繁重的包装器还会记录当前测试用例的名称。后两个功能对于跟踪测试套件检测到的内存泄漏源很有用。</target>
        </trans-unit>
        <trans-unit id="bdb5f255b340a7c8ea5f9ec1a27271eaa4afef49" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; option, then the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; is omitted and replaced by a stub memory allocator that never allocates any memory. Any calls to the stub memory allocator will report back that no memory is available.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt;选项编译SQLite ，则&lt;a href=&quot;malloc#defaultalloc&quot;&gt;默认内存分配器将&lt;/a&gt;被省略，并由一个从不分配任何内存的存根内存分配器代替。对存根内存分配器的任何调用都将报告没有可用的内存。</target>
        </trans-unit>
        <trans-unit id="a81969949fdea82f85b5652d9dfeed54c87f7d37" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">如果使用定义的SQLITE_MUTEX_APPDEF预处理程序宏（&amp;ldquo; -DSQLITE_MUTEX_APPDEF = 1&amp;rdquo;）编译SQLite，则该库不包含互斥量实现。在这种情况下，应用程序必须在调用sqlite3_initialize（）或任何其他调用sqlite3_initialize（）的公共sqlite3_函数之前，使用sqlite3_config（）函数的&lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;选项提供自定义互斥体实现。</target>
        </trans-unit>
        <trans-unit id="3612fbeb4e5912d3519c058afb830d2ca96819e8" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">如果使用定义的SQLITE_MUTEX_APPDEF预处理程序宏（&amp;ldquo; -DSQLITE_MUTEX_APPDEF = 1&amp;rdquo;）编译SQLite，则该库不包含互斥量实现。在这种情况下，应用程序必须在调用sqlite3_initialize（）或任何其他调用sqlite3_initialize（）的公共sqlite3_函数之前，使用sqlite3_config（）函数的&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;选项提供自定义互斥体实现。</target>
        </trans-unit>
        <trans-unit id="3e4d7ea4d24bcad6503f112a75cb8cf3b594762c" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the THREADSAFE preprocessor macro set to 1, then it is safe to use SQLite from two or more threads of the same process at the same time. But each thread should have its own &lt;b&gt;sqlite*&lt;/b&gt; pointer returned from &lt;b&gt;sqlite_open&lt;/b&gt;. It is never safe for two or more threads to access the same &lt;b&gt;sqlite*&lt;/b&gt; pointer at the same time.</source>
          <target state="translated">如果在THREADSAFE预处理器宏设置为1的情况下编译SQLite，则可以安全地从同一进程的两个或多个线程中同时使用SQLite。但是每个线程都应该从&lt;b&gt;sqlite_open&lt;/b&gt;返回自己的&lt;b&gt;sqlite *&lt;/b&gt;指针。两个或多个线程同时访问同一&lt;b&gt;sqlite *&lt;/b&gt;指针永远是不安全的。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="710dfc358000c04c6f29b5a8b9d1e58f09170c01" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;master journal&lt;/em&gt;. The master journal does not contain page data used for rolling back changes. Instead the master journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the master journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no master journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the master journal.</source>
          <target state="translated">如果SQLite同时使用多个数据库（使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令），则每个数据库都有其自己的回滚日志。但是，还有一个单独的汇总日志称为&lt;em&gt;主日志&lt;/em&gt;。主日志不包含用于回滚更改的页面数据。而是，主日志包含每个ATTACHed数据库的各个数据库回滚日志的名称。每个单独的数据库回滚日志还包含主日志的名称。如果没有ATTACHed数据库（或者没有ATTACHed数据库参与当前事务），则不会创建主日志，并且正常回滚日志在通常保留用于记录主日志名称的位置包含一个空字符串。</target>
        </trans-unit>
        <trans-unit id="e3d682297850435cbed4a4f23333530d1946cfd2" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;super-journal&lt;/em&gt;. The super-journal does not contain page data used for rolling back changes. Instead the super-journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the super-journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no super-journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the super-journal.</source>
          <target state="translated">如果SQLite同时使用多个数据库（使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令），则每个数据库都有其自己的回滚日志。但是，还有一个单独的综合期刊，称为&amp;ldquo;&lt;em&gt;超级期刊&amp;rdquo;&lt;/em&gt;。超级期刊不包含用于回滚更改的页面数据。相反，超级期刊包含每个ATTACHed数据库的各个数据库回滚日志的名称。每个单独的数据库回滚日志还包含超级期刊的名称。如果没有ATTACHed数据库（或者没有ATTACHed数据库参与当前事务），则不会创建超级期刊，并且常规回滚日志在通常保留用于记录超级期刊名称的位置包含一个空字符串。 。</target>
        </trans-unit>
        <trans-unit id="5896c61835dd6f9792c99d8e8f334dcf5e7f29e5" translate="yes" xml:space="preserve">
          <source>If SQLite needs a page-cache entry that is larger than &quot;sz&quot; bytes or if it needs more than N entries, it falls back to using the general-purpose memory allocator.</source>
          <target state="translated">如果SQLite需要一个大于 &quot;sz &quot;字节的页缓存条目,或者需要超过N个条目,它就会退回到使用通用内存分配器。</target>
        </trans-unit>
        <trans-unit id="4aa68767277ee1001967243f3227f1d8f761e4eb" translate="yes" xml:space="preserve">
          <source>If SQLite recognizes a table as a shadow table, and if the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set, then the shadow table is read-only for ordinary SQL statements. The shadow table can still be written, but only by SQL that is invoked from within one of the methods of some virtual table implementation.</source>
          <target state="translated">如果SQLite将表识别为影子表，并且设置了&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;标志，则影子表对于普通SQL语句是只读的。影子表仍然可以写入，但是只能由从某些虚拟表实现的方法之一中调用的SQL编写。</target>
        </trans-unit>
        <trans-unit id="c334cbe953204cf334f3f0300d4576308ac4cfdc" translate="yes" xml:space="preserve">
          <source>If URI filenames are recognized when the database connection is originally opened, then URI filenames will also be recognized on &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. Similarly, if URI filenames are not recognized when the database connection is first opened, they will not be recognized by &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="translated">如果最初打开数据库连接时识别URI文件名，则URI文件名也将在&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中识别。同样，如果首次打开数据库连接时未识别URI文件名，那么&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;不会识别它们。</target>
        </trans-unit>
        <trans-unit id="20f2ccdd4e7b5b66dd50ba0f757be7113d0c9526" translate="yes" xml:space="preserve">
          <source>If W is AND-connected terms and X is OR-connected terms and if any term of W appears as a term of X, then the partial index is usable.</source>
          <target state="translated">如果W是AND连接项,X是OR连接项,如果W的任何项出现在X的项中,那么部分索引是可用的。</target>
        </trans-unit>
        <trans-unit id="5ee5624c5ac84e77c145fe142470f12976a4d91a" translate="yes" xml:space="preserve">
          <source>If X is a memory allocation previously obtained from sqlite3_malloc(), sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), then sqlite3_msize(X) returns the size of that memory allocation in bytes. The value returned by sqlite3_msize(X) might be larger than the number of bytes requested when X was allocated. If X is a NULL pointer then sqlite3_msize(X) returns zero. If X points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize(X) is undefined and possibly harmful.</source>
          <target state="translated">如果X是之前从sqlite3_malloc()、sqlite3_malloc64()、sqlite3_realloc()或sqlite3_realloc64()获得的内存分配,那么sqlite3_msize(X)以字节为单位返回该内存分配的大小。sqlite3_msize(X)返回的值可能大于X被分配时请求的字节数。如果X是一个NULL指针,那么sqlite3_msize(X)返回0。如果X指向的不是内存分配的开始,或者指向一个以前有效的内存分配,但现在已经被释放,那么sqlite3_msize(X)的行为是未定义的,可能是有害的。</target>
        </trans-unit>
        <trans-unit id="b1b66964d31ddb28c71bf027a0d38468bda02bb0" translate="yes" xml:space="preserve">
          <source>If X is greater than or equal to zero, go back to step 3.</source>
          <target state="translated">如果X大于或等于零,则回到步骤3。</target>
        </trans-unit>
        <trans-unit id="b3fb68847c867d6e5aec8b5513dabb7e57278079" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">如果X为非零值，则虚拟表实现将保证，如果&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;返回&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，它将在对内部或持久数据结构进行任何修改之前这样做。如果&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式为ABORT，FAIL，IGNORE或ROLLBACK，则SQLite可以回滚语句或数据库事务，并根据需要放弃或继续处理当前SQL语句。如果ON CONFLICT模式为REPLACE，并且&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法返回&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，则SQLite 会将其处理为ON CONFLICT模式为ABORT。</target>
        </trans-unit>
        <trans-unit id="c0b29678a870c29e379cb0f8c76e93d5c6f694fd" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">如果X为非零值，则虚拟表实现将保证，如果&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，它将在对内部或持久数据结构进行任何修改之前这样做。如果&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式为ABORT，FAIL，IGNORE或ROLLBACK，则SQLite可以回滚语句或数据库事务，并根据需要放弃或继续处理当前SQL语句。如果ON CONFLICT模式为REPLACE，并且&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，则SQLite 会将其处理为ON CONFLICT模式为ABORT。</target>
        </trans-unit>
        <trans-unit id="30772a96ac944f5d807fde7afed09facbb4c72a3" translate="yes" xml:space="preserve">
          <source>If X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, then sqlite3_database_file_object(X) returns a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object that represents the main database file.</source>
          <target state="translated">如果X是传递到&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的xOpen方法中的回滚或WAL模式日志文件的名称，则sqlite3_database_file_object（X）返回一个指向&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;对象的指针，该对象代表主数据库文件。</target>
        </trans-unit>
        <trans-unit id="9128fc14e46c56850f1f42883590144b2c54fddf" translate="yes" xml:space="preserve">
          <source>If X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, then sqlite3_database_file_object(X) returns a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object that represents the main database file.</source>
          <target state="translated">如果X是传递到&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的xOpen方法中的回滚或WAL模式日志文件的名称，则sqlite3_database_file_object（X）返回一个指向&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;对象的指针，该对象代表主数据库文件。</target>
        </trans-unit>
        <trans-unit id="90405f680f9fd6c0b9fd6e8fd54aba076154778a" translate="yes" xml:space="preserve">
          <source>If X starts a transaction that will initially only read but X knows it will eventually want to write and does not want to be troubled with possible SQLITE_BUSY_SNAPSHOT errors that arise because another connection jumped ahead of it in line, then X can issue &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; to start its transaction instead of just an ordinary BEGIN. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command goes ahead and starts a write transaction, and thus blocks all other writers. If the &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; operation succeeds, then no subsequent operations in that transaction will ever fail with an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">如果X启动的事务最初只读取，但X知道它最终将要写入并且不希望由于另一个连接跳到该行之前而引起的SQLITE_BUSY_SNAPSHOT错误，则X可以发出&lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;来启动它的交易，而不仅仅是普通的BEGIN。将&lt;a href=&quot;lang_transaction#immediate&quot;&gt;立即开始&lt;/a&gt;命令前进并开始写事务，从而阻止所有其他作家。如果&lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;操作成功，则该事务中的任何后续操作都不会因&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误而失败。</target>
        </trans-unit>
        <trans-unit id="0eea241e4d0bdc37c50e93c325fbb23bd791a257" translate="yes" xml:space="preserve">
          <source>If a &quot;*&quot; character follows a string within an FTS expression, then the final token extracted from the string is marked as a &lt;b&gt;prefix token&lt;/b&gt;. As you might expect, a prefix token matches any document token of which it is a prefix. For example, the first two queries in the following block will match any document that contains the token &quot;one&quot; immediately followed by the token &quot;two&quot; and then any token that begins with &quot;thr&quot;.</source>
          <target state="translated">如果FTS表达式中的字符串&lt;b&gt;后面&lt;/b&gt;跟随&amp;ldquo; *&amp;rdquo;字符，则将从字符串中提取的最终标记标记为&lt;b&gt;前缀标记&lt;/b&gt;。如您所料，前缀标记会匹配任何以其为前缀的文档标记。例如，以下块中的前两个查询将匹配包含令牌&amp;ldquo; one&amp;rdquo;的任何文档，紧随其后的是令牌&amp;ldquo; two&amp;rdquo;，然后是任何以&amp;ldquo; thr&amp;rdquo;开头的令牌。</target>
        </trans-unit>
        <trans-unit id="3fc71a5654e7dbcda099553445308929a409041e" translate="yes" xml:space="preserve">
          <source>If a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; SQL command is executed, and the same database connection currently has one or more actively executing SELECT statements, then SQLITE_LOCKED is returned. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called in this case, then the specified callback will be invoked immediately. Re-attempting the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement will return another SQLITE_LOCKED error. In the implementation of sqlite3_blocking_step() shown to the left, this could cause an infinite loop.</source>
          <target state="translated">如果执行了&amp;ldquo; DROP TABLE&amp;rdquo;或&amp;ldquo; DROP INDEX&amp;rdquo; SQL命令，并且当前同一数据库连接中有一个或多个正在主动执行的SELECT语句，则返回SQLITE_LOCKED。如果在这种情况下调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;，则将立即调用指定的回调。重新尝试&amp;ldquo; DROP TABLE&amp;rdquo;或&amp;ldquo; DROP INDEX&amp;rdquo;语句将返回另一个SQLITE_LOCKED错误。在左侧所示的sqlite3_blocking_step（）的实现中，这可能会导致无限循环。</target>
        </trans-unit>
        <trans-unit id="12bc34a5236123febe1cd1188da174890c26f97b" translate="yes" xml:space="preserve">
          <source>If a &quot;^&quot; character appears immediately before a phrase that is not part of a NEAR query, then that phrase only matches a document only if it starts at the first token in a column. The &quot;^&quot; syntax may be combined with a &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filter&lt;/a&gt;, but may not be inserted into the middle of a phrase.</source>
          <target state="translated">如果不属于NEAR查询的短语之前出现&amp;ldquo; ^&amp;rdquo;字符，则仅当该短语从列中的第一个标记开始时，该短语才与文档匹配。 &amp;ldquo; ^&amp;rdquo;语法可以与&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;列过滤器&lt;/a&gt;结合使用，但不能插入短语的中间。</target>
        </trans-unit>
        <trans-unit id="73147d85cef7d3f5b1649d52c7fae3bdc6d30054" translate="yes" xml:space="preserve">
          <source>If a &quot;create file&quot; operation is executed by SQLite, and then the created file</source>
          <target state="translated">如果SQLite执行了 &quot;创建文件 &quot;操作,那么所创建的文件</target>
        </trans-unit>
        <trans-unit id="84d99b586ac4808874504752037c1f68b1dc681c" translate="yes" xml:space="preserve">
          <source>If a &quot;truncate file&quot; operation is executed by SQLite, and then the truncated file</source>
          <target state="translated">如果SQLite执行了 &quot;截断文件 &quot;操作,那么截断后的文件</target>
        </trans-unit>
        <trans-unit id="a177cd3b97251df1bda061d91a729d6e25be393e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">如果&lt;a href=&quot;../wal#walfile&quot;&gt;WAL文件&lt;/a&gt;在所有数据库连接关闭后仍保留在磁盘上（通过使用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;文件控件，&lt;/a&gt;或者因为退出打开数据库的最后一个过程而未调用&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;退出），并且随后在该数据库上打开了新连接，并且&lt;a href=&quot;../wal#walfile&quot;&gt;WAL文件&lt;/a&gt;，&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;接口将仅能打开添加到WAL文件中的最后一个事务，即使WAL文件包含其他有效事务也是如此。</target>
        </trans-unit>
        <trans-unit id="ce5e78d94d5947b9e328c1516e3f265b0f48637a" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is generated from &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; then the statement is automatically re-prepared if the schema changes, up to &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; times (default: 50). The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.</source>
          <target state="translated">如果从&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;生成了一条&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句，&lt;/a&gt;则如果架构发生更改，该语句将自动重新准备，最多&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt;次（默认值：50）。在&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口将只返回SQLITE_SCHEMA返回给应用程序，如果这些多次重试后故障仍然存在。</target>
        </trans-unit>
        <trans-unit id="3249186023e31b2ef81a917670edb42184c4e1e6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; operation occurs on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error.</source>
          <target state="translated">如果在与未完成的读取或写入相同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上发生&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;操作，则未完成的读取或写入可能会失败，并显示SQLITE_ABORT或&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="a092e1c1463db0502720c4f04f6df73156ddbd46" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">如果&lt;a href=&quot;wal#walfile&quot;&gt;WAL文件&lt;/a&gt;在所有数据库连接关闭后仍保留在磁盘上（通过使用&lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;文件控件，&lt;/a&gt;或者因为退出打开数据库的最后一个过程而未调用&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;退出），并且随后在该数据库上打开了新连接，并且&lt;a href=&quot;wal#walfile&quot;&gt;WAL文件&lt;/a&gt;，&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;接口将仅能打开添加到WAL文件中的最后一个事务，即使WAL文件包含其他有效事务也是如此。</target>
        </trans-unit>
        <trans-unit id="fa0658f406309a7c36c783a199e98aa7bfe2c3be" translate="yes" xml:space="preserve">
          <source>If a BEFORE UPDATE or BEFORE DELETE trigger modifies or deletes a row that was to have been updated or deleted, then the result of the subsequent update or delete operation is undefined. Furthermore, if a BEFORE trigger modifies or deletes a row, then it is undefined whether or not AFTER triggers that would have otherwise run on those rows will in fact run.</source>
          <target state="translated">如果一个BEFORE UPDATE或BEFORE DELETE触发器修改或删除了一条本来要更新或删除的记录,那么后续的更新或删除操作的结果就没有定义。此外,如果一个BEFORE触发器修改或删除了一条记录,那么本应在这些记录上运行的AFTER触发器是否会实际运行是未定义的。</target>
        </trans-unit>
        <trans-unit id="a3ab52a71f2c1fab71f9f4f7d4dd870ab7b02c55" translate="yes" xml:space="preserve">
          <source>If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails because the database is currently in a state that violates a deferred foreign key constraint and there are currently &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoints&lt;/a&gt;, the nested savepoints remain open.</source>
          <target state="translated">如果COMMIT语句（或事务SAVEPOINT的RELEASE）由于数据库当前处于违反延迟的外键约束的状态而失败，并且当前存在&lt;a href=&quot;lang_savepoint&quot;&gt;嵌套保存点&lt;/a&gt;，则该嵌套保存点保持打开状态。</target>
        </trans-unit>
        <trans-unit id="4862567128635ae0bf91b3eee8827f7e081e0187" translate="yes" xml:space="preserve">
          <source>If a DELETE statement has a LIMIT clause, the maximum number of rows that will be deleted is found by evaluating the accompanying expression and casting it to an integer value. If the result of the evaluating the LIMIT clause cannot be losslessly converted to an integer value, it is an error. A negative LIMIT value is interpreted as &quot;no limit&quot;. If the DELETE statement also has an OFFSET clause, then it is similarly evaluated and cast to an integer value. Again, it is an error if the value cannot be losslessly converted to an integer. If there is no OFFSET clause, or the calculated integer value is negative, the effective OFFSET value is zero.</source>
          <target state="translated">如果一个DELETE语句有一个LIMIT子句,那么通过评估附带的表达式并将其转换为一个整数值,就可以找到将被删除的最大行数。如果评估LIMIT子句的结果不能无损地转换为一个整数值,则是一个错误。LIMIT负值被解释为 &quot;没有限制&quot;。如果DELETE语句也有一个OFFSET子句,那么它同样会被评估并投向一个整数值。同样,如果该值不能无损地转换为一个整数,则是一个错误。如果没有OFFSET子句,或者计算出的整数值为负值,那么有效的OFFSET值为零。</target>
        </trans-unit>
        <trans-unit id="a8ebe41fb4265f7abee56db5ee7b5c4f78f4ea2f" translate="yes" xml:space="preserve">
          <source>If a FILTER clause is provided, then only rows for which the</source>
          <target state="translated">如果提供了一个FILTER子句,那么,只有符合以下条件的记录才可以使用</target>
        </trans-unit>
        <trans-unit id="94816fac33b04eac89bfe331f82f9493ef356c93" translate="yes" xml:space="preserve">
          <source>If a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the &lt;a href=&quot;datatype3#collation&quot;&gt;collation sequence&lt;/a&gt; and &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the corresponding expression in the subquery statement.</source>
          <target state="translated">如果指定了FROM子句，则执行简单SELECT查询的数据来自在FROM关键字之后指定的一个或多个表或子查询（括号中的SELECT语句）。在简单的SELECT语句中，在FROM子句之后的表或子查询中指定的子查询，将被视为是包含执行子查询语句所返回的数据的表。子查询的每一列都具有子查询语句中相应表达式的&lt;a href=&quot;datatype3#collation&quot;&gt;排序规则序列&lt;/a&gt;和&lt;a href=&quot;datatype3#affinity&quot;&gt;相似性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="257e2a863a3526135a72b7350cb70ec4620d0ce5" translate="yes" xml:space="preserve">
          <source>If a HAVING clause is specified, it is evaluated once for each group of rows as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result.</source>
          <target state="translated">如果指定了HAVING子句，则将它作为&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式&lt;/a&gt;对每组行求值一次。如果评估HAVING子句的结果为false，则丢弃该组。如果HAVING子句是一个聚合表达式，则会在组中的所有行中对其求值。如果HAVING子句是非聚合表达式，则针对该组中任意选择的行对其求值。 HAVING表达式可以引用不在结果中的值，甚至是聚合函数。</target>
        </trans-unit>
        <trans-unit id="30445e74b001ab802719baf4ad36071ade7519f0" translate="yes" xml:space="preserve">
          <source>If a LIMIT clause is present, it might be possible to avoid scanning the entire table.</source>
          <target state="translated">如果存在LIMIT子句,可能会避免扫描整个表。</target>
        </trans-unit>
        <trans-unit id="948b4ac14d2baa3362d0ca28f059b73564c6f3e7" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">如果在&lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/ etc / fstab中&lt;/a&gt;不带&amp;ldquo; barrier = 1&amp;rdquo;选项的情况下挂载Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt;文件系统，并且启用了磁盘驱动器写缓存，则在断电或操作系统崩溃后，文件系统可能会损坏。是否会发生损坏取决于磁盘控制硬件的详细信息。廉价的消费级磁盘更容易造成损坏，而对于具有高级功能（如非易失性写缓存）的企业级存储设备而言，问题就更少了。各种ext3专家都&lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt;证实了这种现象&lt;/a&gt;。我们被告知，大多数Linux发行版不使用barrier = 1，并且不禁用写缓存，因此大多数Linux发行版都容易受到此问题的影响。请注意，这是一个操作系统和硬件问题，SQLite无法解决该问题。&lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;其他数据库引擎&lt;/a&gt;也遇到了同样的问题。</target>
        </trans-unit>
        <trans-unit id="c69858b8bc714b172e45bdd876c3722d08c7a16a" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;https://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;https://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;https://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;https://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">如果在&lt;a href=&quot;https://en.wikipedia.org/wiki/fstab&quot;&gt;/ etc / fstab中&lt;/a&gt;不带&amp;ldquo; barrier = 1&amp;rdquo;选项的情况下挂载Linux &lt;a href=&quot;https://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt;文件系统，并且启用了磁盘驱动器写缓存，则在断电或操作系统崩溃后，文件系统可能会损坏。是否会发生损坏取决于磁盘控制硬件的详细信息。廉价的消费级磁盘更容易造成损坏，而对于具有高级功能（如非易失性写缓存）的企业级存储设备而言，问题就更少了。各种ext3专家都&lt;a href=&quot;https://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt;证实了这种现象&lt;/a&gt;。我们被告知，大多数Linux发行版不使用barrier = 1，并且不禁用写缓存，因此大多数Linux发行版都容易受到此问题的影响。请注意，这是一个操作系统和硬件问题，SQLite无法解决该问题。&lt;a href=&quot;https://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;其他数据库引擎&lt;/a&gt;也遇到了同样的问题。</target>
        </trans-unit>
        <trans-unit id="99b0a8e8602a0a06983153315092cfd9796ad41e" translate="yes" xml:space="preserve">
          <source>If a NOT NULL constraint is specified, then the column must have a default value other than NULL.</source>
          <target state="translated">如果指定了NOT NULL约束,那么列的默认值必须是NULL以外的值。</target>
        </trans-unit>
        <trans-unit id="55be5a331b8cf28f9f746d3f7eb6341aa17eff02" translate="yes" xml:space="preserve">
          <source>If a SELECT query contains an ORDER BY, GROUP BY or DISTINCT clause, SQLite may need to use a temporary b-tree structure to sort the output rows. Or, it might &lt;a href=&quot;queryplanner#sorting&quot;&gt;use an index&lt;/a&gt;. Using an index is almost always much more efficient than performing a sort. If a temporary b-tree is required, a record is added to the EXPLAIN QUERY PLAN output with the &quot;detail&quot; field set to a string value of the form &quot;USE TEMP B-TREE FOR xxx&quot;, where xxx is one of &quot;ORDER BY&quot;, &quot;GROUP BY&quot; or &quot;DISTINCT&quot;. For example:</source>
          <target state="translated">如果SELECT查询包含ORDER BY，GROUP BY或DISTINCT子句，则SQLite可能需要使用临时的b树结构对输出行进行排序。或者，它可能&lt;a href=&quot;queryplanner#sorting&quot;&gt;使用index&lt;/a&gt;。使用索引几乎总是比执行排序更有效率。如果需要临时b树，则将记录添加到EXPLAIN QUERY PLAN输出中，并将&amp;ldquo;详细信息&amp;rdquo;字段设置为形式为&amp;ldquo; USE TEMP B-TREE FOR xxx&amp;rdquo;的字符串值，其中xxx是&amp;ldquo; ORDER&amp;rdquo;之一BY&amp;rdquo;，&amp;ldquo; GROUP BY&amp;rdquo;或&amp;ldquo; DISTINCT&amp;rdquo;。例如：</target>
        </trans-unit>
        <trans-unit id="5b44dbe4fb9e1c6ef0606b8af702048ca0e438cc" translate="yes" xml:space="preserve">
          <source>If a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.</source>
          <target state="translated">如果一个返回多条记录的SELECT语句没有ORDER BY子句,那么返回记录的顺序就没有定义。或者,如果一个SELECT语句确实有一个ORDER BY子句,那么附加在ORDER BY上的表达式列表决定了返回给用户的行的顺序。</target>
        </trans-unit>
        <trans-unit id="1b3cef981ef6c33ad4faa712cdaf3b903f15861f" translate="yes" xml:space="preserve">
          <source>If a UNION operator connects the initial-select with the recursive-select, then only add rows to the queue if no identical row has been previously added to the queue. Repeated rows are discarded before being added to the queue even if the repeated rows have already been extracted from the queue by the recursion step. If the operator is UNION ALL, then all rows generated by both the initial-select and the recursive-select are always added to the queue even if they are repeats. When determining if a row is repeated, NULL values compare equal to one another and not equal to any other value.</source>
          <target state="translated">如果一个UNION操作符将初始选择和递归选择连接起来,那么只有当之前没有相同的行被添加到队列中时,才会将行添加到队列中。即使重复的记录已经被递归步骤从队列中提取出来,重复的记录也会在被添加到队列之前被丢弃。如果操作符是UNION ALL,那么所有由初始选择和递归选择产生的记录总是被添加到队列中,即使它们是重复的。在确定某行是否重复时,NULL值相互比较相等,而不等于任何其他值。</target>
        </trans-unit>
        <trans-unit id="56d92b47e4081e5a6e548ebb6f898e186d052899" translate="yes" xml:space="preserve">
          <source>If a WHEN clause is supplied, the SQL statements specified are only executed if the WHEN clause is true. If no WHEN clause is supplied, the SQL statements are executed every time the trigger fires.</source>
          <target state="translated">如果提供了WHEN子句,那么只有当WHEN子句为真时才会执行指定的SQL语句。如果没有提供WHEN子句,则每次触发器触发时都会执行SQL语句。</target>
        </trans-unit>
        <trans-unit id="85a070271019d9b24039a7b30649256cb4c49fd9" translate="yes" xml:space="preserve">
          <source>If a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.</source>
          <target state="translated">如果指定了WHERE子句，则对输入数据中的每一行都将WHERE表达式作为&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式求值&lt;/a&gt;。在继续之前，数据集中仅包含WHERE子句表达式的评估结果为true的行。如果WHERE子句的计算结果为false或NULL，则从结果中排除行。</target>
        </trans-unit>
        <trans-unit id="99314068471e46954e8f897765afda682981e6bc" translate="yes" xml:space="preserve">
          <source>If a build of SQLite does not include the FTS modules, then any attempt to prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access an existing FTS table in any way will fail. The error message returned will be similar to &quot;no such module: ftsN&quot; (where N is either 3 or 4).</source>
          <target state="translated">如果构建的SQLite不包括FTS模块,那么任何试图编写SQL语句来创建FTS3或FTS4表或以任何方式删除或访问现有FTS表的尝试都将失败。返回的错误信息将类似于 &quot;no such module:ftsN&quot;(其中N是3或4)。</target>
        </trans-unit>
        <trans-unit id="c07dc39ee71e6a6e8537165278b706aabd6e81bd" translate="yes" xml:space="preserve">
          <source>If a call to sqlite3_step() that attempts to write to a database table returns SQLITE_LOCKED, then more than one other connection may be holding a read-lock on the database table in question. In this case SQLite simply selects one of those other connections arbitrarily and issues the unlock-notify callback when that connection's transaction is finished. Whether the call to sqlite3_step() was blocked by one or many connections, when the corresponding unlock-notify callback is issued it is not guaranteed that the required lock is available, only that it may be.</source>
          <target state="translated">如果调用sqlite3_step()试图对数据库表进行写入,并返回SQLITE_LOCKED,那么可能会有多个其他连接对相关数据库表持有读锁。在这种情况下,SQLite只需任意选择其中一个连接,并在该连接的事务完成后发出解锁通知回调。无论对sqlite3_step()的调用是被一个或多个连接所阻挡,当相应的解锁-通知回调被发出时,并不能保证所需的锁是可用的,只能保证它可能是可用的。</target>
        </trans-unit>
        <trans-unit id="12e866adc40a794d5a50cd7647771628a0fe472b" translate="yes" xml:space="preserve">
          <source>If a character specified as part of the argument to &quot;tokenchars=&quot; is considered to be a token character by default, it is ignored. This is true even if it has been marked as a separator by an earlier &quot;separators=&quot; option. Similarly, if a character specified as part of a &quot;separators=&quot; option is treated as a separator character by default, it is ignored. If multiple &quot;tokenchars=&quot; or &quot;separators=&quot; options are specified, all are processed. For example:</source>
          <target state="translated">如果作为 &quot;tokenchars=&quot;参数的一部分而指定的字符,默认情况下被认为是标记字符,则会被忽略。即使它已经被之前的 &quot;separators=&quot;选项标记为分隔符,也会被忽略。同样地,如果 &quot;separators=&quot;选项中指定的字符默认被视为分隔符,则会被忽略。如果指定了多个 &quot;tokenchars=&quot;或 &quot;separators=&quot;选项,则会处理所有的选项。例如</target>
        </trans-unit>
        <trans-unit id="4047a69992390b90bb1e651abb363899dad3ce20" translate="yes" xml:space="preserve">
          <source>If a collating function fails any of the above constraints and that collating function is registered and used, then the behavior of SQLite is undefined.</source>
          <target state="translated">如果一个整理函数没有通过上述任何一个约束条件,并且该整理函数被注册和使用,那么SQLite的行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="4a25d30fe6f01a94e32b9a3c4b8ab96f2806f18f" translate="yes" xml:space="preserve">
          <source>If a column datatype contains the special keyword &quot;HIDDEN&quot; (in any combination of upper and lower case letters) then that keyword it is omitted from the column datatype name and the column is marked as a hidden column internally. A hidden column differs from a normal column in three respects:</source>
          <target state="translated">如果一个列数据类型包含特殊的关键字 &quot;HIDDEN&quot;(大写和小写字母的任意组合),那么该关键字就会从列数据类型名称中省略,该列在内部被标记为隐藏列。隐藏列与普通列有三个方面的不同。</target>
        </trans-unit>
        <trans-unit id="4a3060f5f06633a8fd81221c196cda03a0efe5c5" translate="yes" xml:space="preserve">
          <source>If a column filter specification is preceded by a &quot;-&quot; character, then it is interpreted as a list of column not to match against. For example:</source>
          <target state="translated">如果列过滤规范前面有一个&quot;-&quot;字符,那么它将被解释为一个不匹配的列列表。例如:&quot;-&quot;字头,则解释为不与之匹配的列列表。</target>
        </trans-unit>
        <trans-unit id="4784be250e1d29a9c62d93440a67186e8f2d433e" translate="yes" xml:space="preserve">
          <source>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the largest possible ROWID has previously been inserted, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error. Only ROWID values from previous transactions that were committed are considered. ROWID values that were rolled back are ignored and can be reused.</source>
          <target state="translated">如果一列的类型是INTEGER PRIMARY KEY AUTOINCREMENT,那么就会使用稍微不同的ROWID选择算法。新行所选择的ROWID至少要比同一表中以前存在的最大ROWID大一个。如果该表之前从未包含过任何数据,那么就使用1的ROWID。如果之前已经插入了最大的ROWID,那么不允许插入新的INSERT,任何插入新行的尝试都会以SQLITE_FULL错误失败。只考虑以前提交的事务中的ROWID值。被回滚的ROWID值会被忽略,并且可以重复使用。</target>
        </trans-unit>
        <trans-unit id="85779fa11fd249fc0a9433b1c9e912b143d1abd7" translate="yes" xml:space="preserve">
          <source>If a column-name list follows the view-name, then that list determines the names of the columns for the view. If the column-name list is omitted, then the names of the columns in the view are derived from the names of the result-set columns in the &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;. The use of column-name list is recommended. Or, if column-name list is omitted, then the result columns in the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that defines the view should have well-defined names using the &quot;&lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt;&quot; syntax. SQLite allows you to create views that depend on automatically generated column names, but you should avoid using them since the rules used to generate column names are not a defined part of the interface and might change in future releases of SQLite.</source>
          <target state="translated">如果列名称列表紧随视图名称，则该列表将确定视图的列名称。如果省略了列名列表，则视图中的列名是从&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt中&lt;/a&gt;结果集列的名称派生的。建议使用列名列表。或者，如果省略了列名列表，那么使用&amp;ldquo; &lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt; &amp;rdquo;语法，定义视图的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句中的结果列应具有定义明确的名称。 SQLite允许您创建依赖于自动生成的列名的视图，但是您应避免使用它们，因为用于生成列名的规则不是接口的已定义部分，并且在将来的SQLite版本中可能会更改。</target>
        </trans-unit>
        <trans-unit id="7f7aaafed42977493a2413f4303512821df4e3b2" translate="yes" xml:space="preserve">
          <source>If a conflict handler returns this value no special action is taken. The change that caused the conflict is not applied. The session module continues to the next change in the changeset.</source>
          <target state="translated">如果冲突处理程序返回这个值,则不会采取任何特殊行动。引起冲突的变更不会被应用。会话模块将继续进行更改集中的下一个更改。</target>
        </trans-unit>
        <trans-unit id="a40b2d39f56dad1b134a26af2fe2ae696281adc1" translate="yes" xml:space="preserve">
          <source>If a covering index can be used for a query, then the multiple rowid lookups can be avoided and the cost of the query drops dramatically.</source>
          <target state="translated">如果可以使用覆盖索引进行查询,那么就可以避免多次的rowid查找,查询的成本就会大幅下降。</target>
        </trans-unit>
        <trans-unit id="653b4381ff1ad3607fbc3061d7b4f5d80ed74deb" translate="yes" xml:space="preserve">
          <source>If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state. Rollback journals might be deleted for any number of reasons:</source>
          <target state="translated">如果发生崩溃或断电,并导致热日志,但该日志被删除,下一个打开数据库的进程将不知道它包含需要回滚的更改。回滚将不会发生,数据库将处于不一致的状态。回滚日记可能因为任何原因被删除。</target>
        </trans-unit>
        <trans-unit id="dbc53ced19579b45a05b723b3063167292a44232" translate="yes" xml:space="preserve">
          <source>If a crash or power loss does occur and a hot journal is left on the disk, it is essential that the original database file and the hot journal remain on disk with their original names until the database file is opened by another SQLite process and rolled back. During recovery at &lt;a href=&quot;#section_4_2&quot;&gt;step 4.2&lt;/a&gt; SQLite locates the hot journal by looking for a file in the same directory as the database being opened and whose name is derived from the name of the file being opened. If either the original database file or the hot journal have been moved or renamed, then the hot journal will not be seen and the database will not be rolled back.</source>
          <target state="translated">如果确实发生崩溃或断电，并且磁盘上保留有热日志，则必须将原始数据库文件和热日志以其原始名称保留在磁盘上，直到该数据库文件被另一个SQLite进程打开并回滚为止。 。在&lt;a href=&quot;#section_4_2&quot;&gt;步骤4.2的&lt;/a&gt;恢复过程中，SQLite通过在与要打开的数据库相同的目录中查找文件来查找热日志，并且该文件的名称源自要打开的文件的名称。如果原始数据库文件或热日志已被移动或重命名，则将不会看到热日志，并且不会回滚数据库。</target>
        </trans-unit>
        <trans-unit id="fb8183919d1fc07417b2707b8092ba7a7a08090d" translate="yes" xml:space="preserve">
          <source>If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a &quot;hot journal&quot; in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction. This is how SQLite implements atomic commit.</source>
          <target state="translated">如果在交易过程中发生崩溃或断电,那么回滚日志文件就会被留在磁盘上。下一次当另一个应用程序试图打开数据库文件时,它就会注意到被遗弃的回滚日志的存在(在这种情况下,我们称它为 &quot;热日志&quot;),并使用日志中的信息将数据库恢复到未完成事务开始前的状态。这就是SQLite实现原子提交的方式。</target>
        </trans-unit>
        <trans-unit id="ac9f0e2592a2df4c51e939a4b5d49b41b7d7ebcb" translate="yes" xml:space="preserve">
          <source>If a database connection is opened with the &quot;-uri 1&quot; option, then &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are honored by the &quot;backup&quot; and &quot;restore&quot; commands.</source>
          <target state="translated">如果使用&amp;ldquo; -uri 1&amp;rdquo;选项打开了数据库连接，则&amp;ldquo;备份&amp;rdquo;和&amp;ldquo;恢复&amp;rdquo;命令将使用&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5923feff2a2aef8fc7abf4f600aff34fc785066" translate="yes" xml:space="preserve">
          <source>If a database connection is operating in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; or in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; (PRAGMA journal_mode=persist) then after committing a transaction the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file may remain in the file-system. This increases performance for subsequent transactions since overwriting an existing file is faster than append to a file, but it also consumes file-system space. After a large transaction (e.g. a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), the rollback journal file may consume a very large amount of space.</source>
          <target state="translated">如果数据库连接以&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他锁定模式&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;持久日志模式&lt;/a&gt;（PRAGMA journal_mode = persist）运行，则在提交事务后，&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;文件可能会保留在文件系统中。由于覆盖现有文件比添加到文件要快，因此可以提高后续事务的性能，但同时也会占用文件系统空间。在进行大量事务（例如&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;）之后，回滚日志文件可能会占用大量空间。</target>
        </trans-unit>
        <trans-unit id="5f55f04439258c2d344a35f29269aa9db3e5202b" translate="yes" xml:space="preserve">
          <source>If a database file is accessed using 8+3 naming rather than the default long filename, then it must be consistently accessed using 8+3 naming by every database connection every time it is opened, or else there is a risk of database corruption. The auxiliary &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; and &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; files are essential to SQLite for being about to recover from a crash. If an application is using 8+3 names and crashes, then the information needed to safely recover from the crash is stored in files with the &quot;&lt;code&gt;.nal&lt;/code&gt;&quot; or &quot;&lt;code&gt;.wal&lt;/code&gt;&quot; extension. If the next application to open the database does not specify the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; URI parameter, then SQLite will use the long filenames to try to locate the rollback journal or write-ahead log files. It will not find them, since they were saved using 8+3 names by the application that crashed, and hence the database will not be properly recovered and will likely go corrupt.</source>
          <target state="translated">如果使用8 + 3命名而不是默认的长文件名来访问数据库文件，则每次打开数据库时，每个数据库连接都必须使用8 + 3命名来一致地访问该文件，否则存在数据库损坏的风险。辅助&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;和&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;文件对于要从崩溃中恢复的SQLite至关重要。如果应用程序使用8 + 3名称且崩溃，则从崩溃中安全恢复所需的信息将存储在扩展名为&amp;ldquo; &lt;code&gt;.nal&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;.wal&lt;/code&gt; &amp;rdquo;的文件中。如果下一个打开数据库的应用程序未指定&amp;ldquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &amp;ldquo; URI参数，然后SQLite将使用长文件名来尝试查找回滚日志或预写日志文件。找不到它们，因为崩溃的应用程序使用8 + 3名称保存了它们，因此数据库将无法正确恢复，并且可能会损坏。</target>
        </trans-unit>
        <trans-unit id="bd70a20b8f5f47bbbe011a3bee3a583fecc50caa" translate="yes" xml:space="preserve">
          <source>If a database is written by SQLite version 3.7.0 or later and then written again by SQLite version 3.6.23 or earlier in such a way as to make the size of the database file decrease, then the next time that SQLite version 3.7.0 access the database file, it might report that the database file is corrupt. The database file is not really corrupt, however. Version 3.7.0 was simply being overly zealous in its corruption detection.</source>
          <target state="translated">如果一个数据库是由SQLite 3.7.0或更高版本编写的,然后再由SQLite 3.6.23或更早版本编写,这样使数据库文件的大小减小,那么下次SQLite 3.7.0版本访问数据库文件时,可能会报告数据库文件损坏。但是,数据库文件并不是真的损坏了。3.7.0版本只是在检测损坏时过于热心。</target>
        </trans-unit>
        <trans-unit id="c0e8b12ff7ad15986137c5d5f01f4e0ef949a4a6" translate="yes" xml:space="preserve">
          <source>If a database were originally created using SQLite version 3.7.0, then written by SQLite version 3.6.23.1 such that the size of the database file increased, then written again by SQLite version 3.7.0, the database file could go corrupt.</source>
          <target state="translated">如果一个数据库最初是用SQLite 3.7.0版本创建的,然后用SQLite 3.6.23.1版本写入,使数据库文件的大小增加,然后再用SQLite 3.7.0版本写入,数据库文件可能会损坏。</target>
        </trans-unit>
        <trans-unit id="f7f861f58b781638426cc97ad65bbe6addfa6a62" translate="yes" xml:space="preserve">
          <source>If a keyword in double quotes (ex: &lt;b&gt;&quot;key&quot;&lt;/b&gt; or &lt;b&gt;&quot;glob&quot;&lt;/b&gt;) is used in a context where it cannot be resolved to an identifier but where a string literal is allowed, then the token is understood to be a string literal instead of an identifier.</source>
          <target state="translated">如果在无法将其解析为标识符但允许使用字符串文字的情况下使用双引号引起来的关键字（例如：&lt;b&gt;&amp;ldquo; key&amp;rdquo;&lt;/b&gt;或&lt;b&gt;&amp;ldquo; glob&amp;rdquo;&lt;/b&gt;），则该令牌应理解为字符串文字，而不是标识符。</target>
        </trans-unit>
        <trans-unit id="ff734731d1dd61e745b8c19a93e379fd051ea7fb" translate="yes" xml:space="preserve">
          <source>If a keyword in single quotes (ex: &lt;b&gt;'key'&lt;/b&gt; or &lt;b&gt;'glob'&lt;/b&gt;) is used in a context where an identifier is allowed but where a string literal is not allowed, then the token is understood to be an identifier instead of a string literal.</source>
          <target state="translated">如果在允许标识符但不允许使用字符串文字的上下文中使用单引号引起来的关键字（例如：&lt;b&gt;'key'&lt;/b&gt;或&lt;b&gt;'glob'&lt;/b&gt;），则将令牌理解为标识符而不是字符串文字。</target>
        </trans-unit>
        <trans-unit id="fd8582b07f28c43cf6305e6462fb4a6db23b8ea7" translate="yes" xml:space="preserve">
          <source>If a matchable phrase is part of a series of phrases connected by NEAR operators in the FTS query expression, then each phrase match must be sufficiently close to other phrase matches of the relevant types to satisfy the NEAR condition.</source>
          <target state="translated">如果一个可匹配的短语是FTS查询表达式中由NEAR运算符连接的一系列短语的一部分,那么每个短语匹配必须与相关类型的其他短语匹配足够接近,以满足NEAR条件。</target>
        </trans-unit>
        <trans-unit id="a2a6d03cae632eedbf962d2919113c9e0642d81c" translate="yes" xml:space="preserve">
          <source>If a memory allocation error occurs, sqlite3_create_filename() might return a NULL pointer. The memory obtained from sqlite3_create_filename(X) must be released by a corresponding call to sqlite3_free_filename(Y).</source>
          <target state="translated">如果发生内存分配错误,sqlite3_create_filename()可能返回一个NULL指针。从 sqlite3_create_filename(X)获得的内存必须通过调用 sqlite3_free_filename(Y)来释放。</target>
        </trans-unit>
        <trans-unit id="16ba62507a795aad87688bd7a66b598560ff99c0" translate="yes" xml:space="preserve">
          <source>If a named virtual table that uses the dbstat module is desired, then the recommended way to create an instance of the dbstat virtual table is as follows:</source>
          <target state="translated">如果需要使用dbstat模块的命名虚拟表,那么推荐的创建dbstat虚拟表实例的方法如下。</target>
        </trans-unit>
        <trans-unit id="f0a2ba4a4cc7d08c018b4dbe8137dc10439214b7" translate="yes" xml:space="preserve">
          <source>If a numeric literal has a decimal point or an exponentiation clause or if its magnitude is less than -9223372036854775808 or greater than 9223372036854775807, then it is a floating point literal. Otherwise is it is an integer literal. The &quot;E&quot; character that begins the exponentiation clause of a floating point literal can be either upper or lower case. The &quot;.&quot; character is always used as the decimal point even if the locale setting specifies &quot;,&quot; for this role - the use of &quot;,&quot; for the decimal point would result in syntactic ambiguity.</source>
          <target state="translated">如果一个数字文字有小数点或指数子句,或者如果它的大小小于-9223372036854775808或大于9223372036854775807,那么它就是一个浮点文字。否则就是一个整数文字。浮点文字的指数子句开头的 &quot;E &quot;字符可以是大写或小写。&quot;.&quot;字符总是被用作小数点,即使locale设置指定了&quot;,&quot;--使用&quot;,&quot;来表示小数点会导致语法上的歧义。</target>
        </trans-unit>
        <trans-unit id="8cf3813aebca15b6b5e1583aeffa06f6925412e6" translate="yes" xml:space="preserve">
          <source>If a page contains no cells (which is only possible for a root page of a table that contains no rows) then the offset to the cell content area will equal the page size minus the bytes of reserved space. If the database uses a 65536-byte page size and the reserved space is zero (the usual value for reserved space) then the cell content offset of an empty page wants to be 65536. However, that integer is too large to be stored in a 2-byte unsigned integer, so a value of 0 is used in its place.</source>
          <target state="translated">如果一个页面不包含任何单元格(只有对于一个不包含行的表的根页面才有可能),那么单元格内容区域的偏移量将等于页面大小减去保留空间的字节。如果数据库使用65536字节的页面大小,而预留空间为零(预留空间的通常值),那么空页面的单元格内容偏移量想为65536。但是,这个整数太大,无法存储在2字节的无符号整数中,所以用0的值来代替。</target>
        </trans-unit>
        <trans-unit id="c99e07bc95c7e7eeb5ce8d8ce056128a45cab0ab" translate="yes" xml:space="preserve">
          <source>If a parameter name begins with a &quot;:&quot;, then it is assumed to be a value to bind to the SQL statement before executing it. The value is always bound as text. It is an error if the specified SQL parameter does not exist. For example:</source>
          <target state="translated">如果一个参数名以&quot;:&quot;开头,那么它被认为是一个值,要在执行SQL语句之前绑定到它。该值总是被绑定为文本。如果指定的SQL参数不存在,则是一个错误。例如:&quot;:&quot;。</target>
        </trans-unit>
        <trans-unit id="a3a6677c34d1c31ace005a4fa6f3930c2040066e" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the master journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no master journal filename in the header (which is the case for a single-file commit) or if the master journal file still exists on disk.</source>
          <target state="translated">如果此时发生断电或操作系统崩溃,即使有回滚日记存在,系统重启时事务也不会回滚。不同的是回滚日记头中的主日记路径名。重启后,SQLite只认为日志是热的,只有当头中没有主日志文件名时(单文件提交时是这样),或者主日志文件在磁盘上仍然存在时,才会回滚日志。</target>
        </trans-unit>
        <trans-unit id="df0966ae095afce680bcbe564721893f2e27c89b" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the super-journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no super-journal filename in the header (which is the case for a single-file commit) or if the super-journal file still exists on disk.</source>
          <target state="translated">如果此时发生断电或操作系统崩溃,即使有回滚日记存在,但系统重启后,事务也不会回滚。区别在于回滚日记头中的超级日记路径名。重启后,SQLite只认为日志是热的,只有在头中没有超级日志文件名(单文件提交时就是如此)或超级日志文件在磁盘上仍然存在时,才会回滚日志。</target>
        </trans-unit>
        <trans-unit id="f031e4113363c1780559d56fb503c736f7031cb4" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system failure occurs while copying the database file the backup database may be corrupted following system recovery.</source>
          <target state="translated">如果在复制数据库文件时发生断电或操作系统故障,系统恢复后,备份数据库可能会损坏。</target>
        </trans-unit>
        <trans-unit id="1e430e1109b182ad5e2d81ffc690ca581b0a1b35" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indexes to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. Event bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">如果一个查询中包含有多个术语的ORDER BY子句,可能是SQLite可以使用索引使行按照ORDER BY中术语的某个前缀的顺序出来,但是ORDER BY中后面的术语不满足。在这种情况下,SQLite就会进行阻塞排序。假设ORDER BY子句有四个术语,而查询的自然顺序导致行按前两个术语的顺序出现。当每一条行被查询引擎输出并进入排序器时,当前行中对应ORDER BY前两个术语的输出与前一行进行比较。如果它们发生了变化,则当前排序结束并输出,开始新的排序。这样,排序的速度就会稍快一些。事件更大的优点是,需要在内存中保存的行少了很多,减少了对内存的要求,而且在核心查询运行完成之前就可以开始出现输出。</target>
        </trans-unit>
        <trans-unit id="d63fd60747c59caf947d214389cf965d0e528d08" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indices to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. But the bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">如果一个查询中包含有多个术语的ORDER BY子句,可能是SQLite可以使用索引使行按照ORDER BY中术语的某个前缀的顺序出来,但是ORDER BY中后面的术语不满足。在这种情况下,SQLite会进行阻塞排序。假设ORDER BY子句有四个术语,而查询的自然顺序导致行按前两个术语的顺序出现。当每一条行被查询引擎输出并进入排序器时,当前行中对应ORDER BY前两个术语的输出与前一行进行比较。如果它们发生了变化,则当前排序结束并输出,开始新的排序。这样一来,排序的速度会稍快一些。但更大的优点是,需要在内存中保存的行少了很多,减少了对内存的要求,而且在核心查询运行完成之前就可以开始出现输出。</target>
        </trans-unit>
        <trans-unit id="ec318f6e2d2904b05a3f02946f0559cc8fefaa28" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute for the DISTINCT ON clause. In other words, output rows are filtered so that only one row is shown for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily. (SQLite supports DISTINCT but not DISTINCT ON, whose functionality is provided instead by GROUP BY.)</source>
          <target state="translated">如果一个查询根本不包含聚合函数,那么可以添加一个GROUP BY子句来替代DISTINCT ON子句。换句话说,输出行会被过滤,因此GROUP BY子句中的每一个不同的值集只显示一条行。如果两条或更多的输出行本来有相同的GROUP BY列的值集,那么任意选择其中一条行。(SQLite支持DISTINCT但不支持DISTINCT ON,其功能由GROUP BY代替提供)。</target>
        </trans-unit>
        <trans-unit id="bdf63c23188158127b26cd2c4807de45ccf6dea6" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute of DISTINCT ON clause. In other words, output rows are filtered so that only one row is shows for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily.</source>
          <target state="translated">如果一个查询完全不包含聚合函数,那么可以添加一个GROUP BY子句来代替DISTINCT ON子句。换句话说,输出行会被过滤,因此GROUP BY子句中的每一个不同的值集只显示一条行。如果两条或两条以上的输出行在GROUP BY子句中的值是相同的,那么任意选择其中一条行。</target>
        </trans-unit>
        <trans-unit id="cab66c0bca9a377eb02b4b0ac5090404c2d874c0" translate="yes" xml:space="preserve">
          <source>If a read/write client invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) prior to shutdown, then at shutdown a checkpoint is still run, but the shm file and wal file are not deleted. This allows subsequent read-only clients to connect to and read the database.</source>
          <target state="translated">如果读/写客户端在关闭之前调用&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;），则在关闭时仍会运行检查点，但不会删除shm文件和wal文件。这使后续的只读客户端可以连接并读取数据库。</target>
        </trans-unit>
        <trans-unit id="337133b7d09a387cf87665a4c7d79ff39c533386" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">如果找到具有匹配的主键值的行，但是一个或多个修改后的非主键字段包含的值与存储在变更集中的原始行值不同，则使用&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;作为第二个参数来调用冲突处理程序函数。由于UPDATE更改仅包含要修改的非主键字段的值，因此只有那些字段需要与原始值匹配，以避免SQLITE_CHANGESET_DATA冲突处理程序回调。</target>
        </trans-unit>
        <trans-unit id="35c7138a2b7260bc49d6f60cf430df710c00202b" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">如果找到具有匹配的主键值的行，但是一个或多个修改后的非主键字段包含的值与存储在变更集中的原始行值不同，则使用&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;作为第二个参数来调用冲突处理程序函数。由于UPDATE更改仅包含要修改的非主键字段的值，因此只有那些字段需要与原始值匹配，以避免SQLITE_CHANGESET_DATA冲突处理程序回调。</target>
        </trans-unit>
        <trans-unit id="1b234b4b89cfdd9943a23340845cb2723771c58a" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">如果找到具有匹配的主键值的行，但是一个或多个非主键字段包含的值与存储在变更集中的原始行值不同，则使用&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;作为第二个参数来调用冲突处理程序函数。如果数据库表中的列数多于更改集中记录的列数，则仅将那些非主键字段的值与当前数据库内容进行比较-忽略任何尾随的数据库表列。</target>
        </trans-unit>
        <trans-unit id="ca3b8d6b7470e9a00b63341bcac487b0076109fe" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">如果找到具有匹配的主键值的行，但是一个或多个非主键字段包含的值与存储在变更集中的原始行值不同，则使用&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;作为第二个参数来调用冲突处理程序函数。如果数据库表中的列数多于更改集中记录的列数，则仅将那些非主键字段的值与当前数据库内容进行比较-忽略任何尾随的数据库表列。</target>
        </trans-unit>
        <trans-unit id="e400ae567f256dbdcc0abe528516e66e2c791942" translate="yes" xml:space="preserve">
          <source>If a schema name is specified as part of an object reference, it must be either &quot;main&quot;, or &quot;temp&quot; or the schema-name of an attached database. Like other SQL identifiers, schema names are case-insensitive. If a schema name is specified, then only that one schema is searched for the named object.</source>
          <target state="translated">如果模式名被指定为对象引用的一部分,那么它必须是 &quot;main&quot;,或者 &quot;temp&quot;,或者是附加数据库的模式名。像其他SQL标识符一样,模式名是不区分大小写的。如果指定了一个模式名,那么只有那个模式会被搜索到。</target>
        </trans-unit>
        <trans-unit id="a287d9b64545db85e7dfa26422162809454f183b" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, it must be either &quot;main&quot;, &quot;temp&quot;, or the name of an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;. In this case the new table is created in the named database. If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs between the &quot;CREATE&quot; and &quot;TABLE&quot; then the new table is created in the temp database. It is an error to specify both a schema-name and the TEMP or TEMPORARY keyword, unless the schema-name is &quot;temp&quot;. If no schema name is specified and the TEMP keyword is not present then the table is created in the main database.</source>
          <target state="translated">如果指定了架构名称，则它必须是&amp;ldquo; main&amp;rdquo;，&amp;ldquo; temp&amp;rdquo;或&lt;a href=&quot;lang_attach&quot;&gt;附加数据库&lt;/a&gt;的名称。在这种情况下，新表将在命名数据库中创建。如果在&amp;ldquo; CREATE&amp;rdquo;和&amp;ldquo; TABLE&amp;rdquo;之间出现&amp;ldquo; TEMP&amp;rdquo;或&amp;ldquo; TEMPORARY&amp;rdquo;关键字，则将在temp数据库中创建新表。同时指定架构名称和TEMP或TEMPORARY关键字是错误的，除非架构名称为&amp;ldquo; temp&amp;rdquo;。如果未指定架构名称且TEMP关键字不存在，则会在主数据库中创建表。</target>
        </trans-unit>
        <trans-unit id="d186fac3c43b0ebe9fb52f2e0bcd9b8dc9321942" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, then the view is created in the specified database. It is an error to specify both a schema-name and the TEMP keyword on a VIEW, unless the schema-name is &quot;temp&quot;. If no schema name is specified, and the TEMP keyword is not present, the VIEW is created in the main database.</source>
          <target state="translated">如果指定了schema-name,那么视图就会在指定的数据库中创建。如果在VIEW上同时指定了模式名和TEMP关键字,则是错误的,除非模式名是 &quot;temp&quot;。如果没有指定模式名,也没有使用TEMP关键字,则在主数据库中创建VIEW。</target>
        </trans-unit>
        <trans-unit id="5a3b25f9ef77a5c2a55ede994e4212a6c3bae634" translate="yes" xml:space="preserve">
          <source>If a search token (on the right-hand side of the MATCH operator) in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; begins with &quot;^&quot; then that token must be the first in its field of the document. &lt;b&gt;** Potentially Incompatible Change **&lt;/b&gt;</source>
          <target state="translated">如果&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4中&lt;/a&gt;的搜索令牌（在MATCH运算符的右侧）以&amp;ldquo; ^&amp;rdquo;开头，则该令牌必须是其文档字段中的第一个。&lt;b&gt;**可能不兼容的更改**&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e0b0e745b5660b6e63d47617f06b59c6fe2aec60" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">如果在运行&lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes（）时，&lt;/a&gt;一个单独的线程在同一数据库连接上进行了更改，则返回的值是不可预测的，并且没有意义。</target>
        </trans-unit>
        <trans-unit id="e161385bf705ff3ca3325998e8904218252e0a24" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">如果在运行&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）时，&lt;/a&gt;一个单独的线程在同一数据库连接上进行了更改，则返回的值是不可预测的，并且没有意义。</target>
        </trans-unit>
        <trans-unit id="48949b30f7cc8dfe518df452770028dcf8268e04" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">如果在运行&lt;a href=&quot;changes&quot;&gt;sqlite3_changes（）时，&lt;/a&gt;一个单独的线程在同一数据库连接上进行了更改，则返回的值是不可预测的，并且没有意义。</target>
        </trans-unit>
        <trans-unit id="e69017ebf8db42f4c918537142f058b4e1e4b99c" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">如果在运行&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）时，&lt;/a&gt;一个单独的线程在同一数据库连接上进行了更改，则返回的值是不可预测的，并且没有意义。</target>
        </trans-unit>
        <trans-unit id="67e0dff317f2ea719a9272889d4afc4730b1b5fc" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">如果在运行&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数时一个单独的线程在同一数据库连接上执行新的&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;，从而更改了最后一个插入&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;返回的值是不可预测的，并且可能不等于旧的或新的last插入&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8a05ae1d1d14adcdf537d4865ddc934cf60a0a4" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">如果在运行&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数时一个单独的线程在同一数据库连接上执行新的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，从而更改了最后一个插入&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;返回的值是不可预测的，并且可能不等于旧的或新的last插入&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c0a40f4902327b395568a304aa57a5c4039b9e5" translate="yes" xml:space="preserve">
          <source>If a single database file has multiple links (either hard or soft links) then that is just another way of saying that the file has multiple names. If two or more processes open the database using different names, then they will use different rollback journals and WAL files. That means that if one process crashes, the other process will be unable to recover the transaction in progress because it will be looking in the wrong place for the appropriate journal.</source>
          <target state="translated">如果一个数据库文件有多个链接(无论是硬链接还是软链接),那么这只是文件有多个名字的另一种说法。如果两个或多个进程使用不同的名称打开数据库,那么它们将使用不同的回滚日记和WAL文件。这意味着,如果一个进程崩溃,另一个进程将无法恢复正在进行的事务,因为它将在错误的地方寻找合适的日志。</target>
        </trans-unit>
        <trans-unit id="54992194ecdfbf1a36948d0111a0401fc51b1ec9" translate="yes" xml:space="preserve">
          <source>If a single row is affected by more than one operation within a session, then the change is considered indirect if all operations meet the criteria for an indirect change above, or direct otherwise.</source>
          <target state="translated">如果一条记录在一个会话中受到一个以上操作的影响,那么如果所有的操作都符合上述间接更改的标准,那么该更改被认为是间接的,否则就是直接的。</target>
        </trans-unit>
        <trans-unit id="8aed35bc8fc658c89e5539bc9b828e9558656314" translate="yes" xml:space="preserve">
          <source>If a statement modifies the contents of the database so that an immediate foreign key constraint is in violation at the conclusion the statement, an exception is thrown and the effects of the statement are reverted. By contrast, if a statement modifies the contents of the database such that a deferred foreign key constraint is violated, the violation is not reported immediately. Deferred foreign key constraints are not checked until the transaction tries to &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. For as long as the user has an open transaction, the database is allowed to exist in a state that violates any number of deferred foreign key constraints. However, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will fail as long as foreign key constraints remain in violation.</source>
          <target state="translated">如果一条语句修改了数据库的内容，从而在该语句结束时违反了立即外键约束，则将引发异常，并还原该语句的作用。相反，如果一条语句修改了数据库的内容，从而违反了延迟的外键约束，则不会立即报告该违反。在事务尝试&lt;a href=&quot;lang_transaction&quot;&gt;提交&lt;/a&gt;之前，不检查延迟的外键约束。只要用户有未清交易，就允许数据库以违反任何数量的延迟外键约束的状态存在。但是，只要仍然违反外键约束，&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;就会失败。</target>
        </trans-unit>
        <trans-unit id="4a9fe68ac2f3c48ea32a43f2c5cf9be89d342ee4" translate="yes" xml:space="preserve">
          <source>If a subquery cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; into the outer query, it might still be possible to enhance performance by &quot;pushing down&quot; WHERE clause terms from the outer query into the subquery. Consider an example:</source>
          <target state="translated">如果不能将子查询展&lt;a href=&quot;optoverview#flattening&quot;&gt;平&lt;/a&gt;到外部查询中，则仍然有可能通过将WHERE子句项从外部查询&amp;ldquo;推入&amp;rdquo;子查询中来提高性能。考虑一个例子：</target>
        </trans-unit>
        <trans-unit id="cfbdc72faddc3dd92eaf2d66d72d9166e0ce65e3" translate="yes" xml:space="preserve">
          <source>If a system failure occurs at any time after a &quot;delete file&quot; operation (call to the VFS xDelete() method) returns successfully, it is assumed that the file-system will not contain the deleted file following system recovery.</source>
          <target state="translated">如果在 &quot;删除文件 &quot;操作(调用VFS xDelete()方法)成功返回后的任何时候发生系统故障,则假设在系统恢复后,文件系统将不包含删除的文件。</target>
        </trans-unit>
        <trans-unit id="c32e1e0b557aefde59c28d931cf3e5d6733099fd" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during a &quot;delete file&quot; operation, it is assumed that following system recovery the file-system will either contain the file being deleted in the state it was in before the operation was attempted, or not contain the file at all. It is assumed that it is not possible for the file to have become corrupted purely as a result of a failure occurring during a &quot;delete file&quot; operation.</source>
          <target state="translated">如果在 &quot;删除文件 &quot;操作中发生系统故障,假定在系统恢复后,文件系统将以尝试操作前的状态包含被删除的文件,或者根本不包含该文件。假设文件不可能纯粹由于 &quot;删除文件 &quot;操作期间发生的故障而损坏。</target>
        </trans-unit>
        <trans-unit id="91f96ef24748138cdd82c09ceabe7f648ae9cf43" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;create file&quot; operation, but before the created file has been</source>
          <target state="translated">如果在 &quot;创建文件 &quot;操作期间或之后,但在所创建的文件尚未被</target>
        </trans-unit>
        <trans-unit id="1fcfee495c57582bc4c6e63019680717056464ec" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;truncate file&quot; operation, but before the truncated file has been</source>
          <target state="translated">如果在 &quot;截断文件 &quot;操作期间或之后,但在截断的文件被截断之前,发生系统故障。</target>
        </trans-unit>
        <trans-unit id="e3c60bc044d7ebf2be0e926e292ed7263d6ed54a" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation that causes the file to grow, but before the corresponding file has been</source>
          <target state="translated">如果在 &quot;写文件 &quot;操作期间或之后发生系统故障,导致文件增长,但在相应的文件被</target>
        </trans-unit>
        <trans-unit id="0de8e98595413448f2b535870f8da207b8048237" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation, but before the corresponding file has been</source>
          <target state="translated">如果在 &quot;写文件 &quot;操作期间或之后,但在相应的文件被写入之前,发生系统故障。</target>
        </trans-unit>
        <trans-unit id="12d84c274c03171c71b26275c99f75f3392362a6" translate="yes" xml:space="preserve">
          <source>If a system failure occurs on a system that supports the</source>
          <target state="translated">如果支持该系统的系统发生系统故障。</target>
        </trans-unit>
        <trans-unit id="70f739b455c168080412690c97f5940222b8f766" translate="yes" xml:space="preserve">
          <source>If a system supports</source>
          <target state="translated">如果一个系统支持</target>
        </trans-unit>
        <trans-unit id="ec9800aa0fd4fbf6e94d5e57566c8304e2f2782b" translate="yes" xml:space="preserve">
          <source>If a system supports the</source>
          <target state="translated">如果一个系统支持</target>
        </trans-unit>
        <trans-unit id="16f55a3959edd0a92c0395b9cf4c3468da074f4f" translate="yes" xml:space="preserve">
          <source>If a table contains a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then that column becomes an alias for the ROWID. You can then access the ROWID using any of four different names, the original three names described above or the name given to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column. All these names are aliases for one another and work equally well in any context.</source>
          <target state="translated">如果表包含&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;类型的列，则该列将成为ROWID的别名。然后，您可以使用以下四个不同的名称中的任何一个来访问ROWID，上述三个原始名称或为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列指定的名称。所有这些名称都是彼此的别名，并且在任何情况下都可以很好地工作。</target>
        </trans-unit>
        <trans-unit id="a73b6736040e74c7d625fd213eca9757c75eee19" translate="yes" xml:space="preserve">
          <source>If a table has a single column primary key and the declared type of that column is &quot;INTEGER&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, then the column is known as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. See &lt;a href=&quot;lang_createtable#rowid&quot;&gt;below&lt;/a&gt; for a description of the special properties and behaviors associated with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">如果表具有单个列主键，并且该列的声明类型为&amp;ldquo; INTEGER&amp;rdquo;，并且该表不是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，则该列称为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;。有关与&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;关联的特殊属性和行为的说明，请参见&lt;a href=&quot;lang_createtable#rowid&quot;&gt;下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e353db8a7a970978b864076f23349bbe29b3cd1" translate="yes" xml:space="preserve">
          <source>If a term in X is of the form &quot;z IS NOT NULL&quot; and if a term in W is a comparison operator on &quot;z&quot; other than &quot;IS&quot;, then those terms match.</source>
          <target state="translated">如果X中的术语是 &quot;z IS NOT NULL &quot;的形式,如果W中的术语是 &quot;IS &quot;以外的 &quot;z &quot;的比较运算符,那么这些术语是匹配的。</target>
        </trans-unit>
        <trans-unit id="d7704041f8ff8a11a4c662eef3d671025a3e5ebe" translate="yes" xml:space="preserve">
          <source>If a term of the WHERE clause is of the following form:</source>
          <target state="translated">如果WHERE子句的术语是以下形式:</target>
        </trans-unit>
        <trans-unit id="e5d671a1040d0448cbcd3997833359da102571a4" translate="yes" xml:space="preserve">
          <source>If a transaction involves multiple databases, then a more complex commit sequence is used, as follows:</source>
          <target state="translated">如果一个事务涉及多个数据库,那么就会使用更复杂的提交序列,如下所示。</target>
        </trans-unit>
        <trans-unit id="1b08d45fd51c4591fce14d3b424e9dccc579bef5" translate="yes" xml:space="preserve">
          <source>If a transaction is aborted due to an application crash, an operating system crash, or a hardware power failure or crash, then the database may be left in an inconsistent state. The next time SQLite attempts to open the database file, the presence of the rollback journal file will be detected and the journal will be automatically played back to restore the database to its state at the start of the incomplete transaction.</source>
          <target state="translated">如果由于应用程序崩溃、操作系统崩溃或硬件电源故障或崩溃而导致事务中止,那么数据库可能会处于不一致的状态。下次SQLite试图打开数据库文件时,将检测到回滚日志文件的存在,并自动回放日志,将数据库恢复到未完成事务开始时的状态。</target>
        </trans-unit>
        <trans-unit id="b139c7ece8944c0ce3ad448cfb0c14ea14a36c67" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">如果在调用&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;接口时在&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上打开了写入事务，则分页器高速缓存中当前未使用的所有脏页都将写到磁盘中。如果正在读取活动SQL语句创建的数据库游标，或者它是数据库文件的第1页（第1页始终为&amp;ldquo;使用中&amp;rdquo;），则可能正在使用脏页。所述&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（d）&lt;/a&gt;接口刷新用于所有模式的高速缓存- &amp;ldquo;主&amp;rdquo;，&amp;ldquo;TEMP&amp;rdquo;，以及任何&lt;a href=&quot;lang_attach&quot;&gt;附接&lt;/a&gt;的数据库。</target>
        </trans-unit>
        <trans-unit id="94598ac271e5cdca4a0d9c950ece2e2fde3c85ae" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">如果在调用&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;接口时在&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上打开了写入事务，则分页器高速缓存中当前未使用的所有脏页都将写到磁盘中。如果正在读取活动SQL语句创建的数据库游标，或者它是数据库文件的第1页（第1页始终为&amp;ldquo;使用中&amp;rdquo;），则可能正在使用脏页。所述&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（d）&lt;/a&gt;接口刷新用于所有模式的高速缓存- &amp;ldquo;主&amp;rdquo;，&amp;ldquo;TEMP&amp;rdquo;，以及任何&lt;a href=&quot;../lang_attach&quot;&gt;附接&lt;/a&gt;的数据库。</target>
        </trans-unit>
        <trans-unit id="9d687ea67d2673f11d5b429c0195a169c2caa77a" translate="yes" xml:space="preserve">
          <source>If a write-transaction is started and the Vdbe.usesStmtJournal flag is true (this flag is set if the Vdbe may modify more than one row and may throw an ABORT exception), a statement transaction may also be opened. More specifically, a statement transaction is opened iff the database connection is currently not in autocommit mode, or if there are other active statements. A statement transaction allows the changes made by this VDBE to be rolled back after an error without having to roll back the entire transaction. If no error is encountered, the statement transaction will automatically commit when the VDBE halts.</source>
          <target state="translated">如果一个写事务被启动,并且Vdbe.usesStmtJournal标志为真(如果Vdbe可能修改多条记录,并且可能抛出ABORT异常,则设置该标志),一个语句事务也可能被打开。更具体地说,如果数据库连接当前没有处于自动提交模式,或者有其他活动的语句,语句事务就会被打开。语句事务允许在出错后回滚该VDBE所做的更改,而不必回滚整个事务。如果没有遇到错误,当VDBE停止时,语句事务将自动提交。</target>
        </trans-unit>
        <trans-unit id="b5fbd175e5cd25d62d623adf09f78e07d2af672b" translate="yes" xml:space="preserve">
          <source>If after This.P1 steps, the cursor is still point to a place that is earlier in the btree than the target row, then fall through into the subsquence &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; opcode.</source>
          <target state="translated">如果在This.P1步骤之后，光标仍然指向btree中比目标行更早的位置，则进入子队列&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;操作码。</target>
        </trans-unit>
        <trans-unit id="7e874d6b40d57619d9fa5fb8dd75a92de53ed059" translate="yes" xml:space="preserve">
          <source>If all three of the steps enumerated above are executed successfully, then it is safe to modify the content of the</source>
          <target state="translated">如果上面列举的三个步骤都能成功执行,那么就可以安全地对</target>
        </trans-unit>
        <trans-unit id="8a9cfb8256efd43eaa74ef64ff226cfbf427865f" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</source>
          <target state="translated">如果使用&amp;ldquo; ALTER TABLE ... RENAME TO&amp;rdquo;命令重命名一个或多个外键约束的父表的表，则外键约束的定义将修改为以其新名称引用父表。修改了子CREATE TABLE语句或存储在&lt;a href=&quot;schematab&quot;&gt;sqlite_schema表&lt;/a&gt;中的语句的文本，以反映新的父表名称。</target>
        </trans-unit>
        <trans-unit id="76124bb023821e31ac6f5cbf1f8b54083a3ec643" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the sqlite_master table are modified to reflect the new parent table name.</source>
          <target state="translated">如果使用 &quot;ALTER TABLE ...RENAME TO &quot;命令用来重命名一个表,而这个表是一个或多个外键约束条件的父表,那么外键约束条件的定义就会被修改为用它的新名称来引用父表。子CREATE TABLE语句或存储在sqlite_master表中的语句的文本被修改为反映新的父表名。</target>
        </trans-unit>
        <trans-unit id="7603e9a69b7a72c62bbc679327133633953ff9aa" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">如果在打开事务时销毁了&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象，则该事务将自动回滚。</target>
        </trans-unit>
        <trans-unit id="53a3481d0fa9e30b2f0d27a6044ee94e1a62bb9b" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">如果在触发器内发生&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;，则只要触发器正在运行，此例程将返回插入行的&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。触发器程序结束后，此例程返回的值将还原为触发触发器之前的值。</target>
        </trans-unit>
        <trans-unit id="877e1b4a7430ba11b48b32c5598ad0c65dc34442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">如果在触发器内发生&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，则只要触发器正在运行，此例程将返回插入行的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。触发器程序结束后，此例程返回的值将还原为触发触发器之前的值。</target>
        </trans-unit>
        <trans-unit id="b95cb40fc8352b696796b3bff79e2f006b1ce07a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">如果在打开事务时销毁了&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象，则该事务将自动回滚。</target>
        </trans-unit>
        <trans-unit id="9f62d9384e44621989efc3c00f1a3ba721b2e39d" translate="yes" xml:space="preserve">
          <source>If an FTS5 table is configured with columnsize=0 but is not a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the xColumnSize API function still works, but runs much more slowly. In this case, instead of reading the value to return directly from the database, it reads the text value itself and count the tokens within it on demand.</source>
          <target state="translated">如果FTS5表配置为columnize = 0，但不是无内容&lt;a href=&quot;fts5#contentless_tables&quot;&gt;表&lt;/a&gt;，则xColumnSize API函数仍然有效，但运行速度要慢得多。在这种情况下，它不是读取值直接从数据库返回，而是读取文本值本身并根据需要对其中的令牌进行计数。</target>
        </trans-unit>
        <trans-unit id="54d66d7577e86e2b88484e46218701181acd86ca" translate="yes" xml:space="preserve">
          <source>If an FTS5 trigram tokenizer is created with the case_sensitive option set to 1, it may only index GLOB queries, not LIKE.</source>
          <target state="translated">如果创建的FTS5三角记号器的大小写敏感选项设置为1,那么它可能只会索引GLOB查询,而不会索引LIKE。</target>
        </trans-unit>
        <trans-unit id="a593df8166351f80d07eb58cb262614d9dbc8634" translate="yes" xml:space="preserve">
          <source>If an INSERT statement attempts to insert a NULL value into a rowid or integer primary key column, the system chooses an integer value to use as the rowid automatically. A detailed description of how this is done is provided &lt;a href=&quot;autoinc&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">如果INSERT语句尝试将NULL值插入到rowid或整数主键列中，则系统会自动选择一个整数值用作rowid。&lt;a href=&quot;autoinc&quot;&gt;单独&lt;/a&gt;提供了有关此操作的详细说明。</target>
        </trans-unit>
        <trans-unit id="ba4158b1467dce3a1f2ceab9abb8de00b0fe4463" translate="yes" xml:space="preserve">
          <source>If an ORDER BY clause is present, it determines the order in which rows are extracted from the queue in step 2a. If there is no ORDER BY clause, then the order in which rows are extracted is undefined. (In the current implementation, the queue becomes a FIFO if the ORDER BY clause is omitted, but applications should not depend on that fact since it might change.)</source>
          <target state="translated">如果存在ORDER BY子句,它决定了在步骤2a中从队列中提取行的顺序。如果没有ORDER BY子句,那么提取行的顺序是没有定义的。(在当前的实现中,如果省略了ORDER BY子句,队列就会变成一个FIFO,但是应用程序不应该依赖于这个事实,因为它可能会改变。)</target>
        </trans-unit>
        <trans-unit id="22141c686821647d4155d6b151a8d8fa154cd1a8" translate="yes" xml:space="preserve">
          <source>If an SQL operation is very nearly finished at the time when sqlite3_interrupt() is called, then it might not have an opportunity to be interrupted and might continue to completion.</source>
          <target state="translated">如果一个SQL操作在调用sqlite3_interrupt()时已经非常接近完成,那么它可能没有机会被中断,可能会继续完成。</target>
        </trans-unit>
        <trans-unit id="923eabd2cf996c975383b0dccd3e5fb8dc063dde" translate="yes" xml:space="preserve">
          <source>If an SQL statement is limited to be a million bytes in length, then obviously you will not be able to insert multi-million byte strings by embedding them as literals inside of INSERT statements. But you should not do that anyway. Use host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; for your data. Prepare short SQL statements like this:</source>
          <target state="translated">如果一个SQL语句的长度限制为一百万个字节，那么很显然，您无法通过将它们作为文字嵌入到INSERT语句中来插入数百万个字节的字符串。但是无论如何，您都不应这样做。对数据使用主机&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。准备像这样的简短SQL语句：</target>
        </trans-unit>
        <trans-unit id="a519000750401db43c985f6fefc862d71c74bede" translate="yes" xml:space="preserve">
          <source>If an SQL table is created using the &quot;WITHOUT ROWID&quot; clause at the end of its CREATE TABLE statement, then that table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and uses a different on-disk representation. A WITHOUT ROWID table uses an index b-tree rather than a table b-tree for storage. The key for each entry in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY KEY followed by all remaining columns of the table. The primary key columns appear in the order they they were declared in the PRIMARY KEY clause and the remaining columns appear in the order they occur in the CREATE TABLE statement.</source>
          <target state="translated">如果在其CREATE TABLE语句的末尾使用&amp;ldquo; WITHOUT ROWID&amp;rdquo;子句创建了SQL表，则该表是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，并使用不同的磁盘表示形式。WITHOUT ROWID表使用索引b树而不是表b树进行存储。WITHOUT ROWID b树中每个条目的键都是一条记录，该记录由PRIMARY KEY的各列组成，后面是表的所有其余列。主键列按它们在PRIMARY KEY子句中声明的顺序显示，其余列按它们在CREATE TABLE语句中出现的顺序显示。</target>
        </trans-unit>
        <trans-unit id="7a1f15ef308e23ec2fc80a29e25882265ebf0786" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement attempts to set an integer primary key or rowid column to a NULL or blob value, or to a string or real value that cannot be losslessly converted to an integer, a &quot;datatype mismatch&quot; error occurs and the statement is aborted. If an INSERT statement attempts to insert a blob value, or a string or real value that cannot be losslessly converted to an integer into an integer primary key or rowid column, a &quot;datatype mismatch&quot; error occurs and the statement is aborted.</source>
          <target state="translated">如果一条UPDATE语句试图将一个整数主键或rowid列设置为NULL或blob值,或者设置为一个无法无损转换为整数的字符串或实值,那么就会发生 &quot;数据类型不匹配 &quot;错误,并中止该语句。如果INSERT语句试图将一个blob值,或者一个不能无损转换为整数的字符串或实值插入到一个整数主键或rowid列中,就会发生 &quot;数据类型不匹配 &quot;错误,语句被中止。</target>
        </trans-unit>
        <trans-unit id="284b34da69fbf9cd89926df318af7634184253b9" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement has a LIMIT clause, the maximum number of rows that will be updated is found by evaluating the accompanying expression and casting it to an integer value. A negative value is interpreted as &quot;no limit&quot;.</source>
          <target state="translated">如果UPDATE语句有一个LIMIT子句,则通过评估所附的表达式并将其转换为一个整数值来找到将被更新的最大行数。负值被解释为 &quot;没有限制&quot;。</target>
        </trans-unit>
        <trans-unit id="35654cca0e06875d8f71c06cdb825a502007ac27" translate="yes" xml:space="preserve">
          <source>If an application issues a SELECT statement on a single table like &quot;</source>
          <target state="translated">如果一个应用程序在单个表上发出一个SELECT语句,如&quot;</target>
        </trans-unit>
        <trans-unit id="3c9847a3fc8345f21ef2aae877b6da29936db6dc" translate="yes" xml:space="preserve">
          <source>If an application puts SQLite in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; using the pragma:</source>
          <target state="translated">如果应用程序使用编译指示将SQLite置于&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;独占锁定模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="16930c87a89e5aa4dacec21b97a534c286412312" translate="yes" xml:space="preserve">
          <source>If an application using asynchronous IO executes transactions in quick succession, other database users may be effectively locked out of the database. This is because when a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; is executed, a database lock is established immediately. But when the corresponding COMMIT or ROLLBACK occurs, the lock is not released until the relevant part of the write-queue has been flushed through. As a result, if a COMMIT is followed by a BEGIN before the write-queue is flushed through, the database is never unlocked,preventing other processes from accessing the database.</source>
          <target state="translated">如果使用异步IO的应用程序快速连续执行事务，则可能会将其他数据库用户有效地锁定在数据库之外。这是因为执行&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN时&lt;/a&gt;会立即建立数据库锁定。但是，当发生相应的COMMIT或ROLLBACK时，直到刷新了写入队列的相关部分，该锁才会释放。因此，如果在刷新写入队列之前在COMMIT之后跟随BEGIN，则数据库永远不会解锁，从而防止了其他进程访问数据库。</target>
        </trans-unit>
        <trans-unit id="dec67a679cc10b4fb4ca0df679f1b42a8a809bf0" translate="yes" xml:space="preserve">
          <source>If an attempt to acquire a</source>
          <target state="translated">如果试图获得</target>
        </trans-unit>
        <trans-unit id="ae2dad7a2ac6f9639d4f707a82a9b585c9a56bd8" translate="yes" xml:space="preserve">
          <source>If an attempt to upgrade to an</source>
          <target state="translated">如果试图升级到一个</target>
        </trans-unit>
        <trans-unit id="0f4ee50fd2b5b886cf93345554e2cb331273f09d" translate="yes" xml:space="preserve">
          <source>If an error (e.g. an OOM condition) occurs within this function, the auxiliary data is set to NULL and an error code returned. If the xDelete parameter was not NULL, it is invoked on the auxiliary data pointer before returning.</source>
          <target state="translated">如果该函数内发生错误(如OOM条件),则将辅助数据设为NULL,并返回错误代码。如果xDelete参数不是NULL,则在返回前对辅助数据指针进行调用。</target>
        </trans-unit>
        <trans-unit id="8045cc0ef3fd13ca44d5e4369a94674b9f7300cd" translate="yes" xml:space="preserve">
          <source>If an error occurs in any of the three main backup API routines then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and &lt;a href=&quot;c3ref/errcode&quot;&gt;message&lt;/a&gt; are attached to the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Additionally, if &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; encounters an error, then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned by both the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; call itself, and by the subsequent call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;. So a call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; does not overwrite an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; stored in the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This feature is used in the example code to reduce amount of error handling required. The return values of the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; calls are ignored and the error code indicating the success or failure of the copy operation collected from the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; afterward.</source>
          <target state="translated">如果这三个主要备份API例程中的任何一个发生错误，则&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;和&lt;a href=&quot;c3ref/errcode&quot;&gt;消息&lt;/a&gt;将附加到目标&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。此外，如果&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;遇到一个错误，则该&lt;a href=&quot;rescode&quot;&gt;错误码&lt;/a&gt;是由两个返回&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;调用自身通过到后续呼叫，并&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。因此，调用&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;不会覆盖由&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;存储在目标&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接中&lt;/a&gt;的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。。示例代码中使用了此功能，以减少所需的错误处理量。&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;和&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;调用的返回值将被忽略，并且此后指示从目标&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;收集的复制操作成功或失败的错误代码。</target>
        </trans-unit>
        <trans-unit id="e8416d9f169797cd1d1df3d689a0f3981d1e1914" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">如果在评估传递给sqlite3_exec（）的SQL语句时发生错误，则当前语句的执行将停止，随后的语句将被跳过。如果sqlite3_exec（）的第5个参数不为NULL，则任何错误消息都会写入从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的内存中，并通过第5个参数传递回去。为避免内存泄漏，应用程序应在不再需要错误消息字符串之后，对通过sqlite3_exec（）的第5个参数返回的错误消息字符串调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;。如果sqlite3_exec（）的第5个参数不为NULL并且没有错误发生，则sqlite3_exec（）将其第5个参数中的指针设置为NULL，然后再返回。</target>
        </trans-unit>
        <trans-unit id="67c739deca1fc659fe9011cffdf430f71e9a737b" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">如果在评估传递给sqlite3_exec（）的SQL语句时发生错误，则当前语句的执行将停止，随后的语句将被跳过。如果sqlite3_exec（）的第5个参数不为NULL，则任何错误消息都会写入从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的内存中，并通过第5个参数传递回去。为避免内存泄漏，应用程序应在不再需要错误消息字符串之后，对通过sqlite3_exec（）的第5个参数返回的错误消息字符串调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;。如果sqlite3_exec（）的第5个参数不为NULL并且没有错误发生，则sqlite3_exec（）将其第5个参数中的指针设置为NULL，然后再返回。</target>
        </trans-unit>
        <trans-unit id="194a0b44e46a56e474b265407cd79a961ab1ee3b" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">如果在sqlite3_backup_init（D，N，S，M）中发生错误，则返回NULL，并且错误代码和错误消息存储在目标&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D中。失败调用sqlite3_backup_init（）的错误代码和消息可以可以使用&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;和/或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;函数进行检索。成功调用sqlite3_backup_init（）会返回一个指向&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象的指针。所述&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象可以与sqlite3_backup_step（）和sqlite3_backup_finish（）函数被用于执行指定的备份操作。</target>
        </trans-unit>
        <trans-unit id="1200818faf5a8fe2f6854c6a6851d33b2f623b3d" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">如果在sqlite3_backup_init（D，N，S，M）中发生错误，则返回NULL，并且错误代码和错误消息存储在目标&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D中。失败调用sqlite3_backup_init（）的错误代码和消息可以可以使用&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;，&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;和/或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;函数进行检索。成功调用sqlite3_backup_init（）会返回一个指向&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象的指针。所述&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象可以与sqlite3_backup_step（）和sqlite3_backup_finish（）函数被用于执行指定的备份操作。</target>
        </trans-unit>
        <trans-unit id="100ded69e0a780b44961df68d1032c0e7c075797" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned and the output variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK is returned and the output variables are set to the size of and a pointer to the output buffer, respectively. In this case it is the responsibility of the caller to eventually free the buffer using a call to sqlite3_free().</source>
          <target state="translated">如果发生错误,返回SQLite错误代码,并将输出变量(*pnData)和(*ppData)设置为0,否则返回SQLITE_OK,并将输出变量分别设置为输出缓冲区的大小和指针。在这种情况下,调用者有责任使用对sqlite3_free()的调用最终释放缓冲区。</target>
        </trans-unit>
        <trans-unit id="622e26e115262f02ac7f60da2462323cdc540b9f" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned. Possible error codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or SQLITE_NOMEM.</source>
          <target state="translated">如果发生错误,将返回一个SQLite错误代码。可能的错误代码包括SQLITE_CORRUPT(如果变化集缓冲区损坏)或SQLITE_NOMEM。</target>
        </trans-unit>
        <trans-unit id="e455ebdd54ae8a16893e6de74ee6f1db7c5e35d7" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">如果已到sqlite3changeset_xxx（）函数的调用（例如一个内遇到一个错误&lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;在&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;或&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;在&lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new（） &lt;/a&gt;），则对应于该错误的错误代码由该函数返回。否则，返回SQLITE_OK。这是为了允许以下模式（伪代码）：</target>
        </trans-unit>
        <trans-unit id="1bc5bca387ff960fe9687401573a47507a4fa49f" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">如果已到sqlite3changeset_xxx（）函数的调用（例如一个内遇到一个错误&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;在&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;或&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;在&lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new（） &lt;/a&gt;），则对应于该错误的错误代码由该函数返回。否则，返回SQLITE_OK。这是为了允许以下模式（伪代码）：</target>
        </trans-unit>
        <trans-unit id="1b680ceb7d64040ce2b6564485c5ca5b1c9689a0" translate="yes" xml:space="preserve">
          <source>If an fts5vocab table is created in the temp database, it may be associated with an FTS5 table in any attached database. In order to attach the fts5vocab table to an FTS5 table located in a database other than &quot;temp&quot;, the name of the database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments. For example:</source>
          <target state="translated">如果在临时数据库中创建了fts5vocab表,那么它可以与任何附加数据库中的FTS5表相关联。为了将fts5vocab表关联到位于 &quot;temp &quot;以外的数据库中的FTS5表,在CREATE VIRTUAL TABLE参数中的FTS5表名之前插入数据库的名称。例如</target>
        </trans-unit>
        <trans-unit id="3334fd5a8f49d3b3b23387e0ded39340f08eab83" translate="yes" xml:space="preserve">
          <source>If an index is available on the ORDER BY column, that index can be used for sorting. Consider the request for all items sorted by &quot;fruit&quot;:</source>
          <target state="translated">如果ORDER BY列上有一个索引,那么该索引就可以用于排序。考虑要求对所有物品按 &quot;水果 &quot;排序。</target>
        </trans-unit>
        <trans-unit id="7ff3ecb138d9749f1bf1bb734a03098e601b851c" translate="yes" xml:space="preserve">
          <source>If an index is created using a statement like this:</source>
          <target state="translated">如果使用这样的语句创建一个索引。</target>
        </trans-unit>
        <trans-unit id="19ed5776fff64746115879da20e80724a2114442" translate="yes" xml:space="preserve">
          <source>If an instance-list grows so large that it exceeds the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.</source>
          <target state="translated">如果实例列表太大而超过了&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;限制，则FTS3 / 4无法处理它。FTS5没有此问题。</target>
        </trans-unit>
        <trans-unit id="e669868d5fcfe552cb1dbbc9c2998f5505f629e6" translate="yes" xml:space="preserve">
          <source>If an interface fails with SQLITE_MISUSE, that means the interface was invoked incorrectly by the application. In that case, the error code and message may or may not be set.</source>
          <target state="translated">如果一个接口出现SQLITE_MISUSE失败,这意味着该接口被应用程序错误地调用。在这种情况下,错误代码和消息可能会被设置,也可能不会。</target>
        </trans-unit>
        <trans-unit id="582fb0780f4838faf9f9c1524bd108b2fc64370c" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">如果发生内存不足错误，则这些例程的返回值与列包含SQL NULL值的返回值相同。通过在获取可疑返回值之后并且在同一&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;上调用任何其他SQLite接口之前立即调用&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（），&lt;/a&gt;可以将有效的SQL NULL返回与内存不足错误区分开。</target>
        </trans-unit>
        <trans-unit id="5851016a3fb15ec26147b80722e832005884d3e4" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">如果发生内存不足错误，则这些例程的返回值与列包含SQL NULL值的返回值相同。通过在获取可疑返回值之后并且在同一&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;上调用任何其他SQLite接口之前立即调用&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（），&lt;/a&gt;可以将有效的SQL NULL返回与内存不足错误区分开。</target>
        </trans-unit>
        <trans-unit id="53a860ff4ceaa780f514879a263f3e2bd7a64b45" translate="yes" xml:space="preserve">
          <source>If an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.</source>
          <target state="translated">如果一个sqlite3_exec()回调返回非零,sqlite3_exec()例程将返回SQLITE_ABORT,而不会再次调用回调,也不会运行任何后续的SQL语句。</target>
        </trans-unit>
        <trans-unit id="86f2a1856f49f287cef6815b989e3bcfc9f7c019" translate="yes" xml:space="preserve">
          <source>If an update is only partially applied to the target database by the time sqlite3rbu_close() is called, state information is saved within the state database if it exists, or otherwise in the RBU database. This allows subsequent processes to automatically resume the RBU update from where it left off. If state information is stored in the RBU database, it can be removed by dropping all tables whose names begin with &quot;rbu_&quot;.</source>
          <target state="translated">如果在调用sqlite3rbu_close()时,更新只是部分应用到目标数据库,那么状态信息会被保存在状态数据库中(如果它存在的话),或者保存在 RBU 数据库中。这使得后续的进程可以自动地从它离开的地方重新开始 RBU 更新。如果状态信息保存在 RBU 数据库中,可以通过删除所有名称以 &quot;rbu_&quot;开头的表来删除。</target>
        </trans-unit>
        <trans-unit id="bd175412c5f187514ee87168844f1bedfa975635" translate="yes" xml:space="preserve">
          <source>If an xToken() callback returns any value other than SQLITE_OK, then the tokenization should be abandoned and the xTokenize() method should immediately return a copy of the xToken() return value. Or, if the input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation itself, it may abandon the tokenization and return any error code other than SQLITE_OK or SQLITE_DONE.</source>
          <target state="translated">如果xToken()回调返回SQLITE_OK以外的任何值,那么应该放弃token化,xTokenize()方法应该立即返回xToken()返回值的副本。或者,如果输入缓冲区已经用完,xTokenize()应该返回SQLITE_OK。最后,如果xTokenize()实现本身发生错误,它可能会放弃token化,并返回SQLITE_OK或SQLITE_DONE以外的任何错误代码。</target>
        </trans-unit>
        <trans-unit id="0be452758cf5838f411f1a08b26770962254070e" translate="yes" xml:space="preserve">
          <source>If and only if the previously described conversion of OR to an IN operator does not work, the second OR-clause optimization is attempted. Suppose the OR clause consists of multiple subterms as follows:</source>
          <target state="translated">如果且仅当前面描述的OR转换为IN操作符不起作用时,才会尝试第二个OR子句优化。假设OR子句由以下多个子项组成。</target>
        </trans-unit>
        <trans-unit id="1d92fd7f31be8d1f3061a17050b41ab1479f4bcd" translate="yes" xml:space="preserve">
          <source>If another database connection has the database mode open in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; then all queries against the database will return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Both Chrome and Firefox open their database files in exclusive locking mode, so attempts to read Chrome or Firefox databases while the applications are running will run into this problem, for example.</source>
          <target state="translated">如果另一个数据库连接以&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;独占锁定&lt;/a&gt;模式打开了数据库模式，则对数据库的所有查询都将返回&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。Chrome和Firefox均以独占锁定模式打开其数据库文件，因此，例如，在应用程序运行时尝试读取Chrome或Firefox数据库的尝试将遇到此问题。</target>
        </trans-unit>
        <trans-unit id="52c07a908a81f106b3dd1bc1b1492081c7a35d47" translate="yes" xml:space="preserve">
          <source>If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.</source>
          <target state="translated">如果在这个例程运行时,另一个线程改变了数据库连接的自动提交状态,那么返回值是未定义的。</target>
        </trans-unit>
        <trans-unit id="8503a498072091f7cabc2db6a10e976de9bc12b1" translate="yes" xml:space="preserve">
          <source>If another thread or process writes to the source database while this function is sleeping, then SQLite detects this and usually restarts the backup process when sqlite3_backup_step() is next called. There is one exception to this rule: If the source database is not an in-memory database, and the write is performed from within the same process as the backup operation and uses the same database handle (pDb), then the destination database (the one opened using connection pFile) is automatically updated along with the source. The backup process may then be continued after the sqlite3_sleep() call returns as if nothing had happened.</source>
          <target state="translated">如果另一个线程或进程在该函数睡眠时向源数据库写入,那么SQLite会检测到这一点,通常会在下一次调用sqlite3_backup_step()时重新启动备份进程。这个规则有一个例外:如果源数据库不是内存数据库,并且写入是在与备份操作相同的进程中进行的,并且使用了相同的数据库句柄(pDb),那么目标数据库(使用连接pFile打开的数据库)将与源数据库一起自动更新。在调用sqlite3_sleep()返回后,备份过程可以继续进行,就像什么都没有发生一样。</target>
        </trans-unit>
        <trans-unit id="6abf22da0f107c51712228d5db063535c6a4d21a" translate="yes" xml:space="preserve">
          <source>If any application-defined SQL functions have potentially dangerous side-effects, or if they could potentially leak sensitive information to an attacker if misused, then tag those functions using the &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; option on the &quot;enc&quot; parameter. This means that the function can never be run from schema-code even if the trusted-schema option is on.</source>
          <target state="translated">如果任何应用程序定义的SQL函数具有潜在的危险副作用，或者如果滥用它们有可能将敏感信息泄露给攻击者，则可以使用&amp;ldquo; enc&amp;rdquo;参数上的&lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;选项标记这些函数。这意味着即使打开trust-schema选项，也永远无法从模式代码运行该功能。</target>
        </trans-unit>
        <trans-unit id="452fe80b19e0f85e5121496bd6edf4647e872526" translate="yes" xml:space="preserve">
          <source>If any checksum is incorrect, the &quot;PRAGMA quick_check&quot; command will find it. To verify that checksums are actually enabled and running, use SQL like the following:</source>
          <target state="translated">如果任何校验和不正确,&quot;PRAGMA quick_check &quot;命令会发现它。要验证校验码是否真正启用并运行,请使用如下SQL。</target>
        </trans-unit>
        <trans-unit id="b9f8be087686590dab771595e5bd54b7d246dba5" translate="yes" xml:space="preserve">
          <source>If any errors are encountered during compilation, an error message is written into memory obtained from &lt;b&gt;malloc&lt;/b&gt; and the 5th parameter is made to point to that memory. If the 5th parameter is NULL, then no error message is generated. If the 5th parameter is not NULL, then the calling function should dispose of the memory containing the error message by calling &lt;b&gt;sqlite_freemem&lt;/b&gt;.</source>
          <target state="translated">如果在编译过程中遇到任何错误，则会将错误消息写入从&lt;b&gt;malloc&lt;/b&gt;获得的&lt;b&gt;内存中&lt;/b&gt;，并使第5个参数指向该内存。如果第5个参数为NULL，则不会生成任何错误消息。如果第5个参数不为NULL，则调用函数应通过调用&lt;b&gt;sqlite_freemem&lt;/b&gt;处置包含错误消息的&lt;b&gt;内存&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="83125f64332cc16259858298cfafac27aca598bf" translate="yes" xml:space="preserve">
          <source>If any of the special-case entries shows above are omitted, then the value of 100 is used for insertion and deletion and 150 is used for substitution. To disable the default insertion, deletion, and/or substitution set their respective cost to 10000 or more.</source>
          <target state="translated">如果省略了上述任何一个特殊大小写条目,那么插入和删除时使用100的值,替换时使用150的值。如果要禁用默认的插入、删除和/或替换,请将它们各自的成本设置为10000或更多。</target>
        </trans-unit>
        <trans-unit id="8b09289d91105f4036d96455156f97ad8f84efdf" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">如果使用sqlite3_bind _ *（）例程中的任何一个调用了带预&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt;的NULL指针，或者使用了比&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;最近调用了&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）的预&lt;/a&gt;准备语句，则该调用将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。如果将任何sqlite3_bind_（）例程传递给已完成的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;，则结果是不确定的，可能有害。</target>
        </trans-unit>
        <trans-unit id="4d6ffdf1dd2e882d0d92b18297a217958bf3b943" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">如果使用sqlite3_bind _ *（）例程中的任何一个调用了带预&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt;的NULL指针，或者使用了比&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;最近调用了&lt;a href=&quot;step&quot;&gt;sqlite3_step（）的预&lt;/a&gt;准备语句，则该调用将返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。如果将任何sqlite3_bind_（）例程传递给已完成的&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;，则结果是不确定的，可能有害。</target>
        </trans-unit>
        <trans-unit id="ecc451199e804c2d9bbaab7eeb8ae7260c861c03" translate="yes" xml:space="preserve">
          <source>If any of these options are defined, then the same set of SQLITE_OMIT_* options must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate the parse.c file and when compiling the 'mkkeywordhash' tool which generates the keywordhash.h file. Because of this, these options may only be used when the library is built from canonical source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Some SQLITE_OMIT_* options might work, or appear to work, when used with the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. But this is not guaranteed. In general, always compile from canonical sources in order to take advantage of SQLITE_OMIT_* options.</source>
          <target state="translated">如果定义了这些选项中的任何一个，则在使用&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器&lt;/a&gt;工具生成parse.c文件时，以及在编译用于生成keywordhash.h文件的&amp;ldquo; mkkeywordhash&amp;rdquo;工具时，也必须定义相同的SQLITE_OMIT_ *选项集。因此，仅当从规范来源（而不是从&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;）构建库时，才可以使用这些选项。有些SQLITE_OMIT_ *选项可能会奏效，或者出现工作，与使用时&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;。但这不能保证。通常，为了利用SQLITE_OMIT_ *选项，请始终从规范源进行编译。</target>
        </trans-unit>
        <trans-unit id="066af8ac5653f5f78e3e77b86a9535152f8106eb" translate="yes" xml:space="preserve">
          <source>If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument.</source>
          <target state="translated">如果在应用变更时发生任何其他约束的违反(例如UNIQUE、CHECK或NOT NULL约束),冲突处理程序会被调用,第二个参数是CHANGESET_CONSTRAINT。</target>
        </trans-unit>
        <trans-unit id="c1ffcbd8edc1e59c920bc1e42ef8ae6a08f1c489" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">如果在将脏页刷新到磁盘时发生任何其他错误（例如IO错误或内存不足的情况），则将放弃处理并将SQLite &lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;立即返回给调用者。</target>
        </trans-unit>
        <trans-unit id="547159ba42f3dd194cd2ac6c73df9dfb51226b89" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">如果在将脏页刷新到磁盘时发生任何其他错误（例如IO错误或内存不足的情况），则将放弃处理并将SQLite &lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;立即返回给调用者。</target>
        </trans-unit>
        <trans-unit id="ed9a42f661215804821abb386ff5f31ffa1294e2" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">如果在sqlite3_str X中构造动态字符串时发生任何先前的错误，则&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;方法将返回适当的错误代码。所述&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;方法返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;以下存储器外的任何误差，或者&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果动态字符串的大小超过&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;，或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;如果出现了任何错误。</target>
        </trans-unit>
        <trans-unit id="2797997123bd9f48d4b03d213989316f5ee2db3a" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">如果在sqlite3_str X中构造动态字符串时发生任何先前的错误，则&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;方法将返回适当的错误代码。所述&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;方法返回&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;以下存储器外的任何误差，或者&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果动态字符串的大小超过&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;，或&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;如果出现了任何错误。</target>
        </trans-unit>
        <trans-unit id="8cf62e1e5822970ab1a0772544bba1f6a9886bdb" translate="yes" xml:space="preserve">
          <source>If any views refer to table X in a way that is affected by the schema change, then drop those views using &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; and recreate them with whatever changes are necessary to accommodate the schema change using &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">如果有任何视图以受架构更改影响的方式引用表X，则使用&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;删除这些视图，并使用&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;进行必要的更改以重新创建它们以适应架构更改。</target>
        </trans-unit>
        <trans-unit id="f4bcba20e82a98be0954f7a995f190f8be3b9e76" translate="yes" xml:space="preserve">
          <source>If argument P3 is non-zero, then it indicates that the sorter may assume that a stable sort considering the first P3 fields of each key is sufficient to produce the required results.</source>
          <target state="translated">如果参数P3为非零,则表示排序器可以假设考虑每个键的前P3字段的稳定排序足以产生所需结果。</target>
        </trans-unit>
        <trans-unit id="35693c95846989c47eb6a922b6389598e5e5c2ef" translate="yes" xml:space="preserve">
          <source>If argument pnCol is not NULL, then *pnCol is set to the number of columns in the table.</source>
          <target state="translated">如果参数pnCol不是NULL,那么*pnCol被设置为表中的列数。</target>
        </trans-unit>
        <trans-unit id="6eebf7ee5a909998cdac6e1af93d8bf0c4b9e6a9" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">如果参数pzTab不为NULL，则* pzTab设置为指向以nul终止的utf-8编码的字符串，该字符串包含受当前更改影响的表的名称。缓冲区保持有效，直到在迭代器上调用sqlite3changeset_next（）或冲突处理程序函数返回为止。如果pnCol不为NULL，则* pnCol设置为表中受更改影响的列数。如果pbIndirect不为NULL，则如果更改是间接更改，则* pbIndirect设置为true（1），否则设置为false（0）。有关直接和间接更改的说明，请参见&lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect（）&lt;/a&gt;的文档。最后，如果pOp不为NULL，则* pOp设置为&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于迭代器当前指向的更改类型。</target>
        </trans-unit>
        <trans-unit id="eeb423ada7e3f3af8ece536280a90cde13ccf0f0" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">如果参数pzTab不为NULL，则* pzTab设置为指向以nul终止的utf-8编码的字符串，该字符串包含受当前更改影响的表的名称。缓冲区保持有效，直到在迭代器上调用sqlite3changeset_next（）或冲突处理程序函数返回为止。如果pnCol不为NULL，则* pnCol设置为表中受更改影响的列数。如果pbIndirect不为NULL，则如果更改是间接更改，则* pbIndirect设置为true（1），否则设置为false（0）。有关直接和间接更改的说明，请参见&lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect（）&lt;/a&gt;的文档。最后，如果pOp不为NULL，则* pOp设置为&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于迭代器当前指向的更改类型。</target>
        </trans-unit>
        <trans-unit id="012db9d404feeb7b242a5f104e807e9ebcf5e6cc" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">如果参数zTab不为NULL，则它是要附加到作为第一个参数传递的会话对象上的表的名称。启用会话对象后，对该表所做的所有后续更改将被记录。有关更多详细信息，请参见&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1874355cfa55a648a95d55d6cc4ad4d5d5a5435f" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">如果参数zTab不为NULL，则它是要附加到作为第一个参数传递的会话对象上的表的名称。启用会话对象后，对该表所做的所有后续更改将被记录。有关更多详细信息，请参见&lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="21fcaf7a804fb18a6bdf460073dabd9a55d816ad" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 0 (false). In other words, a prior r[P2] value will not be overwritten by 1 (true).</source>
          <target state="translated">如果同时设置了SQLITE_STOREP2和SQLITE_KEEPNULL标志,那么只有当新的值是NULL或0(false)时,r[P2]的内容才会改变。换句话说,之前的r[P2]值不会被1(true)覆盖。</target>
        </trans-unit>
        <trans-unit id="f091230c98fc9fb42f84687fff668e2e8782487e" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 1 (true). In other words, a prior r[P2] value will not be overwritten by 0 (false).</source>
          <target state="translated">如果同时设置了SQLITE_STOREP2和SQLITE_KEEPNULL标志,那么r[P2]的内容只有在新的值是NULL或1(true)时才会被改变。换句话说,之前的r[P2]值不会被0(false)覆盖。</target>
        </trans-unit>
        <trans-unit id="b35b42f8226135f60e30979149548acecdb3cd9a" translate="yes" xml:space="preserve">
          <source>If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</source>
          <target state="translated">如果编译指示&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt;均为OFF，则情况（2）适用。</target>
        </trans-unit>
        <trans-unit id="c1ea5de7bdcea197233ed39232910d2d33159cd2" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">如果多语句事务中的语句上发生某些类型的错误（包括&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;和&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT的错误&lt;/a&gt;），则该事务可能会自动回滚。找出错误后SQLite是否自动回滚事务的唯一方法是使用此功能。</target>
        </trans-unit>
        <trans-unit id="063cf3d6b1f8d89a285c8317271a90d08b9bd66c" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">如果多语句事务中的语句上发生某些类型的错误（包括&lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;，&lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;，&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;，&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;和&lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT的错误&lt;/a&gt;），则该事务可能会自动回滚。找出错误后SQLite是否自动回滚事务的唯一方法是使用此功能。</target>
        </trans-unit>
        <trans-unit id="65b57925e204e3ebe11c23e15127d898a0e33ca6" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur within a transaction, the transaction may or may not be rolled back automatically. The errors that can cause an automatic rollback include:</source>
          <target state="translated">如果在一个交易中发生了某些类型的错误,该交易可能会或不会自动回滚。可能导致自动回滚的错误包括:</target>
        </trans-unit>
        <trans-unit id="debbf4ee0f449f15f2b2fad59057f8a4eccd847a" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then it is undefined whether or not the query will see those changes.</source>
          <target state="translated">如果在查询开始运行后,但在查询完成之前,同一个数据库连接上发生了变化,那么查询是否会看到这些变化是没有定义的。</target>
        </trans-unit>
        <trans-unit id="92abf58210ebaa6ec510b645429d6e91e6ca04d8" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then the query might return a changed row more than once, or it might return a row that was previously deleted.</source>
          <target state="translated">如果在查询开始运行后,但在查询完成之前,同一数据库连接上发生了变化,那么查询可能会不止一次地返回一条已更改的记录,或者可能会返回一条之前被删除的记录。</target>
        </trans-unit>
        <trans-unit id="437112dad4bafb7626f6351c41b7b34b2abfaca6" translate="yes" xml:space="preserve">
          <source>If changing into or out of WAL mode the procedure is more complicated.</source>
          <target state="translated">如果进入或退出WAL模式,程序就比较复杂。</target>
        </trans-unit>
        <trans-unit id="f754396c33d700ad2fd9dbdfe823fd9ae27672f4" translate="yes" xml:space="preserve">
          <source>If column names are explicitly provided for the FTS table as part of the CREATE VIRTUAL TABLE statement, then a datatype name may be optionally specified for each column. This is pure syntactic sugar, the supplied typenames are not used by FTS or the SQLite core for any purpose. The same applies to any constraints specified along with an FTS column name - they are parsed but not used or recorded by the system in any way.</source>
          <target state="translated">如果作为CREATE VIRTUAL TABLE语句的一部分,为FTS表显式地提供了列名,那么可以为每一列选择性地指定一个数据类型名。这是纯粹的语法糖,提供的类型名不会被FTS或SQLite核心用于任何目的。同样的道理也适用于与FTS列名一起指定的任何约束--它们会被解析,但不会被系统以任何方式使用或记录。</target>
        </trans-unit>
        <trans-unit id="4ec154d4b803f19da5aae8c26059349f5ffc0b8b" translate="yes" xml:space="preserve">
          <source>If conflict is with a remote UPDATE and the resolution is OMIT, then the old.* values are rebased using the new.* values in the remote change. Or, if the resolution is REPLACE, then the change is copied into the rebased changeset with updates to columns also updated by the conflicting remote UPDATE removed. If this means no columns would be updated, the change is omitted.</source>
          <target state="translated">如果与远程UPDATE冲突,并且解决方法是OMIT,那么旧的.*值将使用远程变化中的新的.*值进行重基。或者,如果解决方法是REPLACE,那么更改会被复制到重新建立的更改集中,同时删除被冲突的远程UPDATE更新的列的更新。如果这意味着没有列会被更新,那么这个改变就被省略了。</target>
        </trans-unit>
        <trans-unit id="eacad9fb0a3ce1ea1edfa735ab3f942dbf9e8cd8" translate="yes" xml:space="preserve">
          <source>If cursor P1 is an index, then the content is the key of the row. If cursor P2 is a table, then the content extracted is the data.</source>
          <target state="translated">如果光标P1是一个索引,那么内容就是该行的键。如果光标P2是表,那么提取的内容就是数据。</target>
        </trans-unit>
        <trans-unit id="ecd4bc0795e5315c7b840830ae1ae10db7944fd7" translate="yes" xml:space="preserve">
          <source>If cursor P1 is not open, jump to instruction P2. Otherwise, fall through.</source>
          <target state="translated">如果光标P1没有打开,则跳转到指令P2。否则,落空。</target>
        </trans-unit>
        <trans-unit id="b0e0c624719d0c72631b398ea85cd293212feef6" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as a key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">如果游标P1指向一个SQL表(使用整数键的B-Tree),那么使用寄存器P3中的值作为键。如果游标P1指向一个SQL索引,那么P3是P4寄存器数组中的第一个,作为未打包的索引键使用。</target>
        </trans-unit>
        <trans-unit id="eed3ade81291c8b1e43812aa13b2f866776f9f36" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as the key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">如果游标P1指向一个SQL表(使用整数键的B-Tree),那么使用寄存器P3中的值作为键。如果游标P1指向一个SQL索引,那么P3是P4寄存器数组中的第一个,作为未打包的索引键使用。</target>
        </trans-unit>
        <trans-unit id="bde1d5766ee802e72c51189e7fb68596781976ad" translate="yes" xml:space="preserve">
          <source>If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</source>
          <target state="translated">如果光标P1先前已通过&lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;进行了移动，请立即完成该搜索操作，而不会造成进一步延迟。如果光标搜索已经发生，则该指令为无操作。</target>
        </trans-unit>
        <trans-unit id="b9a382b280888652763d650554446d773be05c07" translate="yes" xml:space="preserve">
          <source>If data is of type &lt;b&gt;text&lt;/b&gt; then the comparison is determined by the standard C data comparison functions &lt;b&gt;memcmp()&lt;/b&gt; or &lt;b&gt;strcmp()&lt;/b&gt;. The comparison looks at bytes from two inputs one by one and returns the first non-zero difference. Strings are '\000' terminated so shorter strings sort before longer strings, as you would expect.</source>
          <target state="translated">如果数据是&lt;b&gt;文本&lt;/b&gt;类型的，则比较由标准C数据比较函数&lt;b&gt;memcmp（）&lt;/b&gt;或&lt;b&gt;strcmp（）确定&lt;/b&gt;。比较将逐个查看来自两个输入的字节，然后返回第一个非零差异。字符串以'\ 000'结尾，因此，较短的字符串将排在较长的字符串之前，这与您期望的一样。</target>
        </trans-unit>
        <trans-unit id="0120d2592940874456695d5517c48510978290bc" translate="yes" xml:space="preserve">
          <source>If database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.</source>
          <target state="translated">如果数据库zDb是一个非WAL模式的附加数据库的名称,则返回SQLITE_OK,并将*pnLog和*pnCkpt都设置为-1。如果zDb不是NULL(或零长度字符串),也不是任何附加数据库的名称,则返回SQLITE_ERROR给调用者。</target>
        </trans-unit>
        <trans-unit id="ed9f3d01c8cb63f65cf1f8cb1ada863d801c5821" translate="yes" xml:space="preserve">
          <source>If defined, support for sub-selects and the IN() operator are omitted.</source>
          <target state="translated">如果定义了,则省略对子选择和IN()运算符的支持。</target>
        </trans-unit>
        <trans-unit id="5f4710e921e7c9706b1a7d0affff80c102083b4a" translate="yes" xml:space="preserve">
          <source>If desired, you can verify the new database by running this command:</source>
          <target state="translated">如果需要,你可以通过运行这个命令来验证新的数据库。</target>
        </trans-unit>
        <trans-unit id="d0b0b6a44b8709f88072f86b2bad9194c580b896" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is 0 (false) then the result is 0 even if the other input is NULL. A NULL and true or two NULLs give a NULL output.</source>
          <target state="translated">如果P1或P2为0(false),那么即使其他输入为NULL,结果也是0。NULL和true或两个NULL都是NULL输出。</target>
        </trans-unit>
        <trans-unit id="0c5f4e14888f22c44de9608417d3500cbb09c876" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is nonzero (true) then the result is 1 (true) even if the other input is NULL. A NULL and false or two NULLs give a NULL output.</source>
          <target state="translated">如果P1或P2为非零(真),那么即使其他输入为NULL,结果也是1(真)。NULL和false或两个NULL会得到一个NULL输出。</target>
        </trans-unit>
        <trans-unit id="f718f36fc0872a36f2f90015ef098011701953fd" translate="yes" xml:space="preserve">
          <source>If either P3 or the sorter contains a NULL in one of their significant fields (not counting the P4 fields at the end which are ignored) then the comparison is assumed to be equal.</source>
          <target state="translated">如果P3或分拣器的一个重要字段中含有NULL(不包括末尾被忽略的P4字段),则假设比较结果是相等的。</target>
        </trans-unit>
        <trans-unit id="cb70cc2d7081446ae1bd92c809ed77dcb6489c40" translate="yes" xml:space="preserve">
          <source>If either X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; or X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; are non-numeric, then the boundary is the first row for which the expression &quot;X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;&quot; is true.</source>
          <target state="translated">如果X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;或X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;是非数字的，则边界是表达式&amp;ldquo; X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; &amp;rdquo;为真的第一行。</target>
        </trans-unit>
        <trans-unit id="40afda50342c1866ef5c9245fe131f4faa8b196a" translate="yes" xml:space="preserve">
          <source>If either operand has an explicit collating function assignment using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.</source>
          <target state="translated">如果两个操作数都使用后缀&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;进行了显式整理功能分配，则该显式整理功能将用于比较，并优先于左操作数的整理功能。</target>
        </trans-unit>
        <trans-unit id="55672cdef058eed493a94d268600f0dc4cf6e695" translate="yes" xml:space="preserve">
          <source>If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previous sentence, a column name preceded by one or more unary &quot;+&quot; operators and/or CAST operators is still considered a column name.</source>
          <target state="translated">如果操作数中的任何一个是列,那么就使用该列的整理函数,优先于左边的操作数。就上一句话而言,列名前面有一个或多个单数 &quot;+&quot;运算符和/或CAST运算符的,仍然被认为是一个列名。</target>
        </trans-unit>
        <trans-unit id="c6ebcbeab69b86f653a3410afabe08a544dcaea8" translate="yes" xml:space="preserve">
          <source>If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status() are undefined.</source>
          <target state="translated">如果当前值或高水位标志太大,不能用32位整数表示,那么sqlite3_status()返回的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="f734ad1cf91506e2435f2ec6895dbb828ca868ad" translate="yes" xml:space="preserve">
          <source>If everything is OK, the query above should return a single row where the second column is 1. Any other result indicates either that there is a checksum error, or checksum validation is disabled.</source>
          <target state="translated">如果一切正常,上面的查询应该返回一条单行,其中第二列是1,任何其他结果都表明有一个校验错误,或者校验验证被禁用。</target>
        </trans-unit>
        <trans-unit id="10b7374ac7ffa60e3b709049b312d9aea49ec9de" translate="yes" xml:space="preserve">
          <source>If file-locking is enabled (it is enabled by default), then connections from multiple processes may also read and write the database file. However concurrency is reduced as follows:</source>
          <target state="translated">如果启用了文件锁定(默认情况下是启用的),那么来自多个进程的连接也可以读写数据库文件。但是并发性会降低,具体如下。</target>
        </trans-unit>
        <trans-unit id="d3ef8fd536a105baf87d357ae62955ed380fa9cf" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled when it is prepared, the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; to remove all rows from the table before dropping it. The implicit DELETE does not cause any SQL triggers to fire, but may invoke foreign key actions or constraint violations. If an immediate foreign key constraint is violated, the DROP TABLE statement fails and the table is not dropped. If a deferred foreign key constraint is violated, then an error is reported when the user attempts to commit the transaction if the foreign key constraint violations still exist at that point. Any &quot;foreign key mismatch&quot; errors encountered as part of an implicit DELETE are ignored.</source>
          <target state="translated">如果在准备&lt;a href=&quot;lang_droptable&quot;&gt;表&lt;/a&gt;时启用了外键约束，则DROP TABLE命令将执行隐式&lt;a href=&quot;lang_delete&quot;&gt;DELETE，&lt;/a&gt;以在删除表之前从表中删除所有行。隐式DELETE不会引发任何SQL触发器，但可能会调用外键操作或违反约束的行为。如果违反了立即外键约束，则DROP TABLE语句将失败，并且不会删除该表。如果违反了延迟的外键约束，则如果此时仍存在外键约束冲突，则用户尝试提交事务时将报告错误。作为隐式DELETE的一部分遇到的任何&amp;ldquo;外键不匹配&amp;rdquo;错误都将被忽略。</target>
        </trans-unit>
        <trans-unit id="4f44f3a8f93f85a791245b413bb9ad1095b808f6" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled, disable them using &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;.</source>
          <target state="translated">如果启用了外键约束，请使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF&lt;/a&gt;禁用它们。</target>
        </trans-unit>
        <trans-unit id="6a1eb421ae6f8eb8b7414f3ba7bf623bab8ed0c1" translate="yes" xml:space="preserve">
          <source>If foreign key constraints were originally enabled then run &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; to verify that the schema change did not break any foreign key constraints.</source>
          <target state="translated">如果最初启用了外键约束，则运行&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;来验证架构更改没有破坏任何外键约束。</target>
        </trans-unit>
        <trans-unit id="c13741cd4626e3d89fe66c4aae10d469f36c6a45" translate="yes" xml:space="preserve">
          <source>If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with CHANGESET_FOREIGN_KEY as the second argument exactly once before the changeset is committed. If the conflict handler returns CHANGESET_OMIT, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns CHANGESET_ABORT, the changeset is rolled back.</source>
          <target state="translated">如果启用了外键处理,并且应用一个变化集使数据库处于包含外键违反的状态,那么冲突处理程序将在变化集提交之前以CHANGESET_FOREIGN_KEY作为第二个参数被调用一次。如果冲突处理程序返回CHANGESET_OMIT,那么包括引起外键约束违反的变化在内的变化将被提交。或者,如果它返回CHANGESET_ABORT,则改变集被回滚。</target>
        </trans-unit>
        <trans-unit id="664ed429f3e8a71469131f1cf927d67cea7224ef" translate="yes" xml:space="preserve">
          <source>If foreign keys constraints were originally enabled, reenable them now.</source>
          <target state="translated">如果原来启用了外键约束,现在重新启用。</target>
        </trans-unit>
        <trans-unit id="ae0d6d454ce848e119fe19c9d3921a6301be3ccd" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">如果尚未将其附加到作为第一个参数传递的会话对象，则此函数以与&lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;函数相同的方式附加表zTbl 。如果zTbl不存在或没有主键，则此功能为无操作（但不会返回错误）。</target>
        </trans-unit>
        <trans-unit id="b18e9847f65d260e65a6581d1c54f05d17b07506" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">如果尚未将其附加到作为第一个参数传递的会话对象，则此函数以与&lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;函数相同的方式附加表zTbl 。如果zTbl不存在或没有主键，则此功能为无操作（但不会返回错误）。</target>
        </trans-unit>
        <trans-unit id="a8c1f9f82d9d1138df42ada4c0e8d4ac1b13017c" translate="yes" xml:space="preserve">
          <source>If many threads and/or processes need to write the database at the same instant (and they cannot queue up and take turns) then it is best to select a database engine that supports that capability, which always means a client/server database engine.</source>
          <target state="translated">如果很多线程和/或进程需要在同一时刻写入数据库(它们不能排队轮流写),那么最好选择支持这种能力的数据库引擎,这总是意味着客户/服务器数据库引擎。</target>
        </trans-unit>
        <trans-unit id="277d800367bb442a2e4d79fba0d9ab386719bb03" translate="yes" xml:space="preserve">
          <source>If mmap_size is set to N then all current implementations map the first N bytes of the database file and use legacy xRead() calls for any content beyond N bytes. If the database file is smaller than N bytes, then the entire file is mapped. In the future, new OS interfaces could, in theory, map regions of the file other than the first N bytes, but no such implementation currently exists.</source>
          <target state="translated">如果mmap_size被设置为N,那么当前所有的实现都会映射数据库文件的前N个字节,并对超过N个字节的内容使用传统的xRead()调用。如果数据库文件小于N个字节,那么整个文件都会被映射。未来,新的操作系统接口理论上可以映射除前N个字节以外的文件区域,但目前还没有这样的实现。</target>
        </trans-unit>
        <trans-unit id="44cd764c270354ba3be43d380aabce5d77a1bc54" translate="yes" xml:space="preserve">
          <source>If more than one such fragment can be found, then fragments that contain a larger number of &quot;extra&quot; phrase matches are favored. The start of the selected text fragment may be moved a few tokens forward or backward to attempt to concentrate the phrase matches toward the center of the fragment.</source>
          <target state="translated">如果可以找到多个这样的片段,那么包含大量 &quot;额外的 &quot;短语匹配的片段将受到青睐。所选文本片段的开始可以向前或向后移动几个标记,以尝试将短语匹配集中到片段的中心。</target>
        </trans-unit>
        <trans-unit id="26cb5f0f4343465953038f56daf635f7d45d2d33" translate="yes" xml:space="preserve">
          <source>If multi-threaded processing is enabled via the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; setting, then sort operations will attempt to start helper threads when the amount of content to be sorted exceeds the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; and PMA Size determined by the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. This compile-time option sets the default value for the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. The default value is 250.</source>
          <target state="translated">如果通过&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA线程&lt;/a&gt;设置启用了多线程处理，则当要排序的内容量超过&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt;启动时间选项确定的&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;和PMA Size 的最小值时，排序操作将尝试启动帮助程序线程。此编译时选项设置&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt;启动时选项的默认值。默认值为250。</target>
        </trans-unit>
        <trans-unit id="aefd863d94581cbe189ba146626a8379609c65b7" translate="yes" xml:space="preserve">
          <source>If multiple calls to sqlite3_create_function() specify the same function name, and the same number of arguments, and the same preferred text encoding, then the callbacks and other parameters of the second call overwrite the first, and the destructor callback from the first call (if it exists) is invoked.</source>
          <target state="translated">如果多次调用sqlite3_create_function()指定了相同的函数名,和相同的参数数,以及相同的首选文本编码,那么第二次调用的回调和其他参数就会覆盖第一次调用,并调用第一次调用的析构器回调(如果存在的话)。</target>
        </trans-unit>
        <trans-unit id="180acf91f65a788cf692bf4d0ecd25eb3f41224e" translate="yes" xml:space="preserve">
          <source>If multiple commands are being executed against the same SQLite database connection at the same time, the autocommit is deferred until the very last command completes. For example, if a SELECT statement is being executed, the execution of the command will pause as each row of the result is returned. During this pause other INSERT, UPDATE, or DELETE commands can be executed against other tables in the database. But none of these changes will commit until the original SELECT statement finishes.</source>
          <target state="translated">如果同时针对同一个SQLite数据库连接执行多条命令,则自动提交会推迟到最后一条命令完成。例如,如果正在执行一条SELECT语句,当返回结果的每一条记录时,命令的执行将暂停。在这个暂停期间,可以针对数据库中的其他表执行其他INSERT、UPDATE或DELETE命令。但是在原始的SELECT语句完成之前,这些更改都不会提交。</target>
        </trans-unit>
        <trans-unit id="02760b51331cbab337a4b4abdc9926115fb4b89f" translate="yes" xml:space="preserve">
          <source>If neither of these two query strategies can be used, all queries on FTS tables are implemented using a linear scan of the entire table. If the table contains large amounts of data, this may be an impractical approach (the first example on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds using a modern PC).</source>
          <target state="translated">如果这两种查询策略都不能使用,那么对FTS表的所有查询都会使用整个表的线性扫描来实现。如果表包含大量数据,这可能是一种不切实际的方法(本页的第一个例子显示,使用现代PC对1.5 GB的数据进行线性扫描需要大约30秒)。</target>
        </trans-unit>
        <trans-unit id="46d15914a8966b2144fb307d96a3896b83eea8f4" translate="yes" xml:space="preserve">
          <source>If no</source>
          <target state="translated">如果没有</target>
        </trans-unit>
        <trans-unit id="d80775017369d9f582b22c2b8463af70c053cb1a" translate="yes" xml:space="preserve">
          <source>If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert. If the table is initially empty, then a ROWID of 1 is used. If the largest ROWID is equal to the largest possible integer (9223372036854775807) then the database engine starts picking positive candidate ROWIDs at random until it finds one that is not previously used. If no unused ROWID can be found after a reasonable number of attempts, the insert operation fails with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. If no negative ROWID values are inserted explicitly, then automatically generated ROWID values will always be greater than zero.</source>
          <target state="translated">如果在插入上未指定ROWID，或者指定的ROWID的值为NULL，则将自动创建适当的ROWID。通常的算法是为新创建的行赋予ROWID，该ROWID比插入之前表中的最大ROWID大一。如果表最初为空，则使用ROWID为1。如果最大ROWID等于可能的最大整数（9223372036854775807），则数据库引擎开始随机选择正候选ROWID，直到找到以前未使用过的ROWID。如果经过合理的尝试次数后未找到未使用的ROWID，则插入操作将失败，并显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误。如果没有明确插入负的ROWID值，则自动生成的ROWID值将始终大于零。</target>
        </trans-unit>
        <trans-unit id="e2deadd7a9c793e3167a0e629e8b9b96ff70f176" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned.</source>
          <target state="translated">如果没有发生错误,则返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="8e5398b47308ea9ae66110e9bb05403692680696" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned. If an error does occur, an SQLite error code is returned. The values of the output variables may not be trusted in this case.</source>
          <target state="translated">如果没有发生错误,则返回SQLITE_OK。如果确实发生了错误,则返回SQLite错误代码。在这种情况下,输出变量的值可能不被信任。</target>
        </trans-unit>
        <trans-unit id="b8dd386d2569bc5457aac9dba2010126d7a04d7d" translate="yes" xml:space="preserve">
          <source>If no master journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a master journal is named in the file journal, then the file journal is hot if its master journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">如果不涉及主日志,那么如果日志存在,且日志头不为零,且其对应的数据库文件没有 RESERVED 锁,则该日志为热日志。如果在文件日志中命名了主日志,那么如果主日志存在,并且对应的数据库文件没有 RESERVED 锁,那么文件日志就是热日志。了解什么时候是热日志是很重要的,所以前面的规则将用圆点重复。</target>
        </trans-unit>
        <trans-unit id="e9ec2ab3e066aabbb424ce10a035adf5f5270552" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">如果在数据库中找不到与主键值匹配的行，则使用第二个参数传递的&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt;调用冲突处理程序函数。</target>
        </trans-unit>
        <trans-unit id="532395f09f545a6e9963ddaa843af136eeb8913b" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">如果在数据库中找不到与主键值匹配的行，则使用第二个参数传递的&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt;调用冲突处理程序函数。</target>
        </trans-unit>
        <trans-unit id="96d3acb3ee8eb3ea8e9644e28f8d2dc56f1b840a" translate="yes" xml:space="preserve">
          <source>If no super-journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a super-journal is named in the file journal, then the file journal is hot if its super-journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">如果不涉及超级期刊,那么如果期刊存在,且刊头不为零,且其对应的数据库文件没有 RESERVED 锁,则该期刊为热期刊。如果在文件日志中命名了超级日志,那么如果它的超级日志存在,并且对应的数据库文件没有 RESERVED 锁,那么文件日志就是热日志。了解一个日志什么时候是热日志是很重要的,所以前面的规则将用子弹重复。</target>
        </trans-unit>
        <trans-unit id="5795a39454965fb21426bc7bb9e2147672f5e177" translate="yes" xml:space="preserve">
          <source>If none of the strings above occur anywhere in the type declaration, then the datatype is numeric. Note in particular that the datatype for columns with an empty type declaration is numeric.</source>
          <target state="translated">如果类型声明中没有任何地方出现上述字符串,那么数据类型就是数值型。特别注意,类型声明为空的列的数据类型是数字。</target>
        </trans-unit>
        <trans-unit id="5b0f610d4827d05770d8c3809730eca324b8d352" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">如果偏移量iOffset从BLOB的末尾开始小于N个字节，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;读取任何数据。如果N或iOffset小于零，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;读取任何数据。可以使用&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定Blob的大小（以及N + iOffset的最大值）。</target>
        </trans-unit>
        <trans-unit id="bcc2dad992498753f10de4ee979d37a3e30daa67" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">如果偏移量iOffset从BLOB的末尾开始小于N个字节，则返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;读取任何数据。如果N或iOffset小于零，则返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;读取任何数据。可以使用&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定Blob的大小（以及N + iOffset的最大值）。</target>
        </trans-unit>
        <trans-unit id="2e41507fc7f4f5f8ed7f1f9f86f50446d711b557" translate="yes" xml:space="preserve">
          <source>If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.</source>
          <target state="translated">如果一个操作数具有INTEGER、REAL或NUMERIC亲和力,而另一个操作数具有TEXT或BLOB或无亲和力,那么NUMERIC亲和力将应用于另一个操作数。</target>
        </trans-unit>
        <trans-unit id="316990fa091894331a5bfab80d20b7d7b8a1b17a" translate="yes" xml:space="preserve">
          <source>If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.</source>
          <target state="translated">如果一个操作数有TEXT亲和力,而另一个操作数没有亲和力,那么TEXT亲和力被应用到另一个操作数上。</target>
        </trans-unit>
        <trans-unit id="4a746052c71f7cca567e925f8568ed0089126b0e" translate="yes" xml:space="preserve">
          <source>If one or more of the column values in the row inserted by the new change differ from those in the row deleted by the existing change, the existing DELETE is replaced by an UPDATE within the changegroup. Otherwise, if the inserted row is exactly the same as the deleted row, the existing DELETE is simply discarded.</source>
          <target state="translated">如果被新的更改插入的行中的一列或多列的值与被现有更改删除的行中的值不同,那么现有的DELETE将被更改组中的UPDATE代替。否则,如果插入的行与删除的行完全相同,那么现有的DELETE就会被丢弃。</target>
        </trans-unit>
        <trans-unit id="bbb903a0b2fa794db9f8ce5d76be92c6e8ad13da" translate="yes" xml:space="preserve">
          <source>If ownership of the pointer is passed into SQLite by providing a non-NULL D parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; then the ownership remains with SQLite until the object is destroyed. There is no way to transfer ownership out of SQLite and back into the application again.</source>
          <target state="translated">如果通过向&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;或&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;提供非NULL D参数将指针的所有权传递到SQLite，则所有权将保留在SQLite中，直到对象被销毁为止。无法将所有权从SQLite移出并再次移回应用程序。</target>
        </trans-unit>
        <trans-unit id="8503abe821374258f98c6ba5585311ca76bf6ece" translate="yes" xml:space="preserve">
          <source>If page 1 data is read as required by H35230, then the value of the</source>
          <target state="translated">如果按照H35230的要求读取第1页的数据,那么第1页中的</target>
        </trans-unit>
        <trans-unit id="017b230392006407b67880da521173469a1b31d0" translate="yes" xml:space="preserve">
          <source>If parameter iCol is greater than or equal to the number of columns in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO error), an appropriate SQLite error code is returned.</source>
          <target state="translated">如果参数iCol大于或等于表中的列数,则返回SQLITE_RANGE。或者,如果发生错误(如OOM条件或IO错误),则返回一个适当的SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="c373aca4c319795b45d2c1f0dc2245e638666f60" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the FTS5 table. Or, if iCol is non-negative but less than the number of columns in the table, return the total number of tokens in column iCol, considering all rows in the FTS5 table.</source>
          <target state="translated">如果参数iCol小于0,则将输出变量*pnToken设置为FTS5表中的令牌总数。或者,如果iCol是非负数,但小于表中的列数,则考虑到FTS5表中的所有行,返回iCol列中的令牌总数。</target>
        </trans-unit>
        <trans-unit id="686ce79e8e629eea956f529880e81a4b9a406c30" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the current row. Or, if iCol is non-negative but less than the number of columns in the table, set *pnToken to the number of tokens in column iCol of the current row.</source>
          <target state="translated">如果参数iCol小于0,则将输出变量*pnToken设置为当前行的tokens总数。或者,如果iCol是非负数,但小于表中的列数,则设置*pnToken为当前行iCol列中的tokens数量。</target>
        </trans-unit>
        <trans-unit id="88577f66da407130b6c2fbcee7dc6e283e2a74d7" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">如果参数zDb为NULL或指向长度为零的字符串，则将对&lt;a href=&quot;../lang_attach&quot;&gt;连接&lt;/a&gt;到&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; db的所有WAL数据库尝试指定的操作。在这种情况下，写入输出参数* pnLog和* pnCkpt的值是不确定的。如果在处理一个或多个附加的WAL数据库时遇到SQLITE_BUSY错误，仍将在所有剩余的附加数据库上尝试该操作，并在最后返回SQLITE_BUSY。如果在处理附加数据库时发生任何其他错误，则将放弃处理并将错误代码立即返回给调用方。如果在处理附加数据库时未遇到错误（SQLITE_BUSY或其他），则返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="83e25a419f885754ebe2acacb05d4faa8a67cc7b" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">如果参数zDb为NULL或指向长度为零的字符串，则将对&lt;a href=&quot;lang_attach&quot;&gt;连接&lt;/a&gt;到&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; db的所有WAL数据库尝试指定的操作。在这种情况下，写入输出参数* pnLog和* pnCkpt的值是不确定的。如果在处理一个或多个附加的WAL数据库时遇到SQLITE_BUSY错误，仍将在所有剩余的附加数据库上尝试该操作，并在最后返回SQLITE_BUSY。如果在处理附加数据库时发生任何其他错误，则将放弃处理并将错误代码立即返回给调用方。如果在处理附加数据库时未遇到错误（SQLITE_BUSY或其他），则返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="d5e79777c8fc72c43d9863555c6ca53f645883e2" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">如果pnLog不为NULL，则* pnLog设置为日志文件中的总帧数；如果由于错误或数据库未处于&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;而无法运行检查点，则将* pnLog设置为-1 。如果pnCkpt不为NULL，则将* pnCkpt设置为日志文件中检查点帧的总数（包括调用该函数之前已被检查点的帧），如果检查点由于错误或错误而无法运行，则将其设置为-1。因为数据库不在WAL模式下。请注意，成功完成SQLITE_CHECKPOINT_TRUNCATE后，日志文件将被截断为零字节，因此* pnLog和* pnCkpt都将设置为零。</target>
        </trans-unit>
        <trans-unit id="d64232e8314def054a53cca48179ce0748631809" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">如果pnLog不为NULL，则* pnLog设置为日志文件中的总帧数；如果由于错误或数据库未处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;而无法运行检查点，则将* pnLog设置为-1 。如果pnCkpt不为NULL，则将* pnCkpt设置为日志文件中检查点帧的总数（包括调用该函数之前已被检查点的帧），如果检查点由于错误或错误而无法运行，则将其设置为-1。因为数据库不在WAL模式下。请注意，成功完成SQLITE_CHECKPOINT_TRUNCATE后，日志文件将被截断为零字节，因此* pnLog和* pnCkpt都将设置为零。</target>
        </trans-unit>
        <trans-unit id="41dd1bdb1c62f1c1fa9eb1f2a9f608c75f290fb8" translate="yes" xml:space="preserve">
          <source>If present, output a more verbose report for each query analyzed.</source>
          <target state="translated">如果存在,则为每个分析的查询输出一个更详细的报告。</target>
        </trans-unit>
        <trans-unit id="dfd446567083de1e9ebdea0d18573182ac68033b" translate="yes" xml:space="preserve">
          <source>If pzTail is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in zSql. These routines only compile the first statement in zSql, so *pzTail is left pointing to what remains uncompiled.</source>
          <target state="translated">如果pzTail不是NULL,那么*pzTail将指向zSql中第一条SQL语句结束后的第一个字节。这些例程只编译zSql中的第一条语句,所以*pzTail被留在指向未编译的地方。</target>
        </trans-unit>
        <trans-unit id="daeeadf12f9cfe6f720cf3d4bdd4fb456397cc60" translate="yes" xml:space="preserve">
          <source>If r[P3] is zero or negative, that means there is no OFFSET and r[P2] is set to be the value of the LIMIT, r[P1].</source>
          <target state="translated">如果r[P3]为零或负值,表示没有OFFSET,r[P2]设置为LIMIT的值,r[P1]。</target>
        </trans-unit>
        <trans-unit id="6c50ebdc1c9d5314285662a0bf55da3e625fe7b5" translate="yes" xml:space="preserve">
          <source>If register P1 holds an integer convert it to a real value.</source>
          <target state="translated">如果寄存器P1持有一个整数,则将其转换为实值。</target>
        </trans-unit>
        <trans-unit id="24add31372893a82dd86705b4a5c1cbba71ea8ec" translate="yes" xml:space="preserve">
          <source>If required to truncate a database page from the end of the database file, the associated</source>
          <target state="translated">如果需要从数据库文件的末尾截断数据库页面,相关的</target>
        </trans-unit>
        <trans-unit id="986e38dddb8763966fae3720cfb00c3ae4f64940" translate="yes" xml:space="preserve">
          <source>If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands as the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; would have been NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="translated">如果对与先前&lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt;或&lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt;相同的两个操作数进行&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;比较的结果为NULL或false（0），则跳至P2。如果对前两个操作数进行&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;比较的结果为true（1），则失败。</target>
        </trans-unit>
        <trans-unit id="3939be1758da993faac1647e5a0238d1c34fd401" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">如果以&lt;a href=&quot;../sharedcache&quot;&gt;共享缓存模式运行&lt;/a&gt;，则应用程序必须保证在备份运行时不访问目标数据库使用的共享缓存。在实践中，这意味着应用程序必须保证正在备份的磁盘文件不会被进程内的任何连接访问，而不仅仅是传递给sqlite3_backup_init（）的特定连接。</target>
        </trans-unit>
        <trans-unit id="91671997be6a1d6d67488b4259ddff989b286fc6" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">如果以&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式运行&lt;/a&gt;，则应用程序必须保证在备份运行时不访问目标数据库使用的共享缓存。在实践中，这意味着应用程序必须保证正在备份的磁盘文件不会被进程内的任何连接访问，而不仅仅是传递给sqlite3_backup_init（）的特定连接。</target>
        </trans-unit>
        <trans-unit id="813ffbbe7a10f587c30164e3c760a93f923869e0" translate="yes" xml:space="preserve">
          <source>If set to 1, then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE. If omitted or set to 0 then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is NORMAL.</source>
          <target state="translated">如果设置为1，则默认的&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt;设置为EXCLUSIVE。如果省略或设置为0，则默认的&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt;为NORMAL。</target>
        </trans-unit>
        <trans-unit id="8dd726c58400329230cb7ffbb590015b7fc272ad" translate="yes" xml:space="preserve">
          <source>If single-thread mode has not been selected at compile-time or start-time, then individual database connections can be created as either multi-thread or serialized. It is not possible to downgrade an individual database connection to single-thread mode. Nor is it possible to escalate an individual database connection if the compile-time or start-time mode is single-thread.</source>
          <target state="translated">如果在编译时或启动时没有选择单线程模式,那么可以将单个数据库连接创建为多线程或序列化。不可能将单个数据库连接降级为单线程模式,如果编译时或启动时没有选择单线程模式,也不可能将单个数据库连接升级为多线程或序列化模式。如果编译时或启动时模式为单线程,也不可能升级单个数据库连接。</target>
        </trans-unit>
        <trans-unit id="297fbafe0f12618a3892916307ed5e193747b9f8" translate="yes" xml:space="preserve">
          <source>If single-thread mode is selected at compile-time, then critical mutexing logic is omitted from the build and it is impossible to enable either multi-thread or serialized modes at start-time or run-time.</source>
          <target state="translated">如果在编译时选择了单线程模式,那么在构建中就会省略关键的互斥逻辑,并且在启动时或运行时无法启用多线程或序列化模式。</target>
        </trans-unit>
        <trans-unit id="bc15b1addaaecdb30cb643e4374238a5f983835b" translate="yes" xml:space="preserve">
          <source>If some future version of SQLite adds new ALTER TABLE capabilities, those capabilities will very likely use one of the two procedures outlined above.</source>
          <target state="translated">如果未来SQLite的某个版本增加了新的ALTER TABLE功能,那么这些功能很可能会使用上述两个过程中的一个。</target>
        </trans-unit>
        <trans-unit id="a247ea4cd25be5ebc1e3446b36da4e3d6e48aaf1" translate="yes" xml:space="preserve">
          <source>If some other error occurs (e.g. an OOM condition), an SQLite error code is returned and *ppValue is set to NULL.</source>
          <target state="translated">如果发生其他错误(如OOM条件),将返回一个SQLite错误代码,并将*ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="e277177a9a5ad8b0a8ae8ddf4692ab5b1cd48938" translate="yes" xml:space="preserve">
          <source>If specified, interpret all relative paths as relative to DIR, instead of the current working directory.</source>
          <target state="translated">如果指定,将所有相对路径解释为相对于DIR,而不是当前工作目录。</target>
        </trans-unit>
        <trans-unit id="c10bbb5923a9a453a504ada2ef95db3b448455c2" translate="yes" xml:space="preserve">
          <source>If specified, use file FILE as the archive. Otherwise, assume that the current &quot;main&quot; database is the archive to be operated on.</source>
          <target state="translated">如果指定,使用文件FILE作为存档。否则,假设当前的 &quot;主 &quot;数据库是要操作的存档。</target>
        </trans-unit>
        <trans-unit id="781f0c1e44a6d5e4cbc382e01b2a73157527db47" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">如果sqlite3_backup_step（）无法获得所需的文件系统锁，则将调用&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler函数&lt;/a&gt;（如果已指定）。如果忙处理程序在锁可用之前返回非零值，则&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给调用方。在这种情况下，可以稍后重试对sqlite3_backup_step（）的调用。如果在调用sqlite3_backup_step（）时使用了源&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;来写入源数据库，则立即返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;。同样，在这种情况下，稍后可以重试对sqlite3_backup_step（）的调用。如果是&lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;返回，则没有必要重试对sqlite3_backup_step（）的调用。这些错误被认为是致命的。应用程序必须接受备份操作失败，并将备份操作句柄传递给sqlite3_backup_finish（）才能释放关联的资源。</target>
        </trans-unit>
        <trans-unit id="97664464d7946d7d0d5f82dbee0724dc2319f847" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">如果sqlite3_backup_step（）无法获得所需的文件系统锁，则将调用&lt;a href=&quot;busy_handler&quot;&gt;busy-handler函数&lt;/a&gt;（如果已指定）。如果忙处理程序在锁可用之前返回非零值，则&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给调用方。在这种情况下，可以稍后重试对sqlite3_backup_step（）的调用。如果在调用sqlite3_backup_step（）时使用了源&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;来写入源数据库，则立即返回&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;。同样，在这种情况下，稍后可以重试对sqlite3_backup_step（）的调用。如果是&lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;，&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;或&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;返回，则没有必要重试对sqlite3_backup_step（）的调用。这些错误被认为是致命的。应用程序必须接受备份操作失败，并将备份操作句柄传递给sqlite3_backup_finish（）才能释放关联的资源。</target>
        </trans-unit>
        <trans-unit id="416d4d371ff0cd3598d43dc30a0639c13aed646a" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">如果sqlite3_deserialize（D，S，P，N，M，F）由于任何原因而失败，并且如果参数F中的SQLITE_DESERIALIZE_FREEONCLOSE位置1，则在返回之前在参数P上调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cec31d664476098d45397cb4e64acc667d8c0501" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">如果sqlite3_deserialize（D，S，P，N，M，F）由于任何原因而失败，并且如果参数F中的SQLITE_DESERIALIZE_FREEONCLOSE位置1，则在返回之前在参数P上调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aeea9650fe067179f154dc4c0a23753bc2cbcaea" translate="yes" xml:space="preserve">
          <source>If sqlite3_malloc() fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer is returned.</source>
          <target state="translated">如果sqlite3_malloc()在处理这两个例程的过程中失败了(例如在UTF-8到UTF-16的转换过程中),那么将返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="cac2f36b365eeaba945df88aa0f1da7631750708" translate="yes" xml:space="preserve">
          <source>If sqlite3_unlock_notify() is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify() is invoked. If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify().</source>
          <target state="translated">如果在多线程应用程序中调用sqlite3_unlock_notify(),那么在调用sqlite3_unlock_notify()的时候,阻塞连接有可能已经结束了它的事务。如果发生这种情况,那么指定的回调会在调用sqlite3_unlock_notify()时立即被调用。</target>
        </trans-unit>
        <trans-unit id="d3dbf8613ad9cf5c029072fff340e1a64123138d" translate="yes" xml:space="preserve">
          <source>If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is automatically created and populated with the single table used to store the state of an RBU vacuum - &quot;rbu_state&quot;. If an ongoing RBU vacuum is suspended, this table is populated with state data. The next time sqlite3rbu_vacuum() is called with the same S parameter, it detects this data and attempts to resume the suspended vacuum operation. When an RBU vacuum operation is completed or encounters an error, RBU automatically deletes the contents of the rbu_state table. In this case, the next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from scratch.</source>
          <target state="translated">如果在调用sqlite3rbu_vacuum()时,状态数据库S不存在,那么它将被自动创建,并被用于存储RBU真空状态的单表--&quot;rbu_state &quot;所填充。如果一个正在进行的RBU真空被暂停,这个表就会被状态数据填充。下一次用相同的S参数调用sqlite3rbu_vacuum()时,它会检测到这些数据,并尝试恢复暂停的真空操作。当一个RBU真空操作完成或遇到错误时,RBU会自动删除rbu_state表的内容。在这种情况下,下一次调用sqlite3rbu_vacuum()会从头开始一个全新的真空操作。</target>
        </trans-unit>
        <trans-unit id="9b583cb7d9f730fb38a0d4c0658d985458639786" translate="yes" xml:space="preserve">
          <source>If step 1 was successful, an attempt is made to read the</source>
          <target state="translated">如果步骤1成功,则尝试读取</target>
        </trans-unit>
        <trans-unit id="95b4922965cf280511e54a7e6a975a3cf943cead" translate="yes" xml:space="preserve">
          <source>If successful, a pointer to a buffer containing the inverted changeset is stored in *ppOut, the size of the same buffer is stored in *pnOut, and SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are zeroed and an SQLite error code returned.</source>
          <target state="translated">如果成功,则在*ppOut中存储一个指向包含反转变化集的缓冲区的指针,在*pnOut中存储相同缓冲区的大小,并返回SQLITE_OK。如果发生错误,*pnOut和*ppOut都被清零,并返回SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="2d2a26797b61cd3892af9cbfe95715fb203e64ff" translate="yes" xml:space="preserve">
          <source>If successful, this function returns SQLITE_OK and populates (*pp) with a pointer to a new sqlite3_changegroup object before returning. The caller should eventually free the returned object using a call to sqlite3changegroup_delete(). If an error occurs, an SQLite error code (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.</source>
          <target state="translated">如果成功,这个函数返回SQLITE_OK,并在返回之前用指向一个新的sqlite3_changegroup对象的指针填充(*pp)。调用者最终应该使用调用 sqlite3changegroup_delete()来释放返回的对象。如果发生错误,则返回一个SQLite错误代码(即SQLITE_NOMEM),并将*pp设置为NULL。</target>
        </trans-unit>
        <trans-unit id="25d0330551ddd2fa16bdd016ab08a130f3f7634f" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the &quot;conflicting row&quot; associated with the current conflict-handler callback and returns SQLITE_OK.</source>
          <target state="translated">如果成功,这个函数将*ppValue设置为指向一个受保护的sqlite3_value对象,该对象包含与当前冲突处理回调相关联的 &quot;冲突行 &quot;的iVal'th值,并返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="fa261183bb429d753dbe1a765227df127f987423" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of new row values stored as part of the UPDATE or INSERT change and returns SQLITE_OK. If the change is an UPDATE and does not include a new value for the requested column, *ppValue is set to NULL and SQLITE_OK returned. The name of the function comes from the fact that this is similar to the &quot;new.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">如果成功,这个函数将*ppValue设置为指向一个受保护的sqlite3_value对象,这个对象包含了作为UPDATE或INSERT更改的一部分而存储的新行值向量中的iVal'th值,并返回SQLITE_OK。如果更改是UPDATE,并且不包含请求列的新值,那么*ppValue被设置为NULL,并返回SQLITE_OK。该函数的名称来自于这与更新或删除触发器可用的 &quot;new.*&quot;列类似。</target>
        </trans-unit>
        <trans-unit id="8a04e15ae358710d2ad80e6a9a9c13bb73faba6b" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of original row values stored as part of the UPDATE or DELETE change and returns SQLITE_OK. The name of the function comes from the fact that this is similar to the &quot;old.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">如果成功,这个函数将*ppValue设置为指向一个受保护的sqlite3_value对象,该对象包含作为UPDATE或DELETE更改的一部分而存储的原始行值向量中的iVal'th值,并返回SQLITE_OK。该函数的名称来自于这与更新或删除触发器可用的 &quot;old.*&quot;列类似。</target>
        </trans-unit>
        <trans-unit id="5f323dfa9043b9e0668bb0be64be173c0214f5b4" translate="yes" xml:space="preserve">
          <source>If successful, xCreateFunction() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">如果成功，则xCreateFunction（）返回SQLITE_OK。否则，它将返回一个SQLite错误代码。在这种情况下，&lt;b&gt;不会&lt;/b&gt;调用xDestroy函数。</target>
        </trans-unit>
        <trans-unit id="0c5491699943eedd46aaea7dc769af1705417f26" translate="yes" xml:space="preserve">
          <source>If successful, xCreateTokenizer() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">如果成功，则xCreateTokenizer（）返回SQLITE_OK。否则，它将返回一个SQLite错误代码。在这种情况下，&lt;b&gt;不会&lt;/b&gt;调用xDestroy函数。</target>
        </trans-unit>
        <trans-unit id="128b9faf8d31130c2470e9c58674eddd1a9c50a3" translate="yes" xml:space="preserve">
          <source>If such a text fragment can be found, it is returned with the following modifications:</source>
          <target state="translated">如果能找到这样的文本片段,则以下列修改后返回。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="2b388f659392c2a3dcc9c7c0db559bd88cf8ff51" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have a &quot;-x&quot; argument, that causes them to accumulate output as Comma-Separated-Values (CSV) in a temporary file, then invoke the default system utility for viewing CSV files (usually a spreadsheet program) on the result. This is a quick way of sending the result of a query to a spreadsheet for easy viewing:</source>
          <target state="translated">如果&quot;.output &quot;或&quot;.once &quot;命令的参数为&quot;-x&quot;,则会导致它们将输出结果以逗号分隔值(CSV)的形式累积到一个临时文件中,然后调用系统默认的实用程序来查看结果上的CSV文件(通常是电子表格程序)。这是一种快速将查询结果发送到电子表格的方法,方便查看。</target>
        </trans-unit>
        <trans-unit id="b4746f29b85def95350d80c6bb29ef47dac1ca98" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have an argument of &quot;-e&quot; then output is collected into a temporary file and the system text editor is invoked on that text file. Thus, the command &quot;.once -e&quot; achieves the same result as &quot;.once '|open -f'&quot; but with the benefit of being portable across all systems.</source>
          <target state="translated">如果&quot;.output &quot;或&quot;.once &quot;命令的参数为&quot;-e&quot;,那么输出将被收集到一个临时文件中,并在该文本文件上调用系统文本编辑器。因此,&quot;.once -e &quot;命令与&quot;.once '|open -f'&quot;的结果是一样的,但其优点是可以在所有系统中移植。</target>
        </trans-unit>
        <trans-unit id="3daa35758772f94d91f7bd83ab5f9ceb0840b773" translate="yes" xml:space="preserve">
          <source>If the &quot;.recover&quot; command recovers one or more rows that it cannot attribute to any database table, the output script creates a &quot;lost_and_found&quot; table to store the orphaned rows. The schema of the lost_and_found table is as follows:</source>
          <target state="translated">如果&quot;.recover &quot;命令恢复了一条或多条不能归属于任何数据库表的记录,输出脚本会创建一个 &quot;lost_and_found &quot;表来存储被遗弃的记录。lost_and_found表的模式如下。</target>
        </trans-unit>
        <trans-unit id="1ddf7f749d8128e48a3bd895bfea3bcecad29d40" translate="yes" xml:space="preserve">
          <source>If the &quot;CREATE VIRTUAL TABLE&quot; statement specifies module FTS4 (not FTS3), then special directives - FTS4 options - similar to the &quot;tokenize=*&quot; option may also appear in place of column names. An FTS4 option consists of the option name, followed by an &quot;=&quot; character, followed by the option value. The option value may optionally be enclosed in single or double quotes, with embedded quote characters escaped in the same way as for SQL literals. There may not be whitespace on either side of the &quot;=&quot; character. For example, to create an FTS4 table with the value of option &quot;matchinfo&quot; set to &quot;fts3&quot;:</source>
          <target state="translated">如果 &quot;CREATE VIRTUAL TABLE &quot;语句指定的是模块FTS4(而不是FTS3),那么类似于 &quot;tokenize=*&quot;选项的特殊指令--FTS4选项也可以出现在列名的位置。一个FTS4选项由选项名组成,后面是一个&quot;=&quot;字符,然后是选项值。选项值可以选择用单引号或双引号括起来,嵌入式引号字符的转义方式与SQL字元的转义方式相同。在&quot;=&quot;字符的两边不能有空格。例如,创建一个FTS4表,选项 &quot;matchinfo &quot;的值设置为 &quot;fts3&quot;。</target>
        </trans-unit>
        <trans-unit id="77546b3dd108217dd30ccb1edbd6835383de8523" translate="yes" xml:space="preserve">
          <source>If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs in between &quot;CREATE&quot; and &quot;VIEW&quot; then the view that is created is only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that created it and is automatically deleted when the database connection is closed.</source>
          <target state="translated">如果&amp;ldquo; TEMP&amp;rdquo;或&amp;ldquo; TEMPORARY&amp;rdquo;关键字出现在&amp;ldquo; CREATE&amp;rdquo;和&amp;ldquo; VIEW&amp;rdquo;之间，则创建的视图仅对创建它的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;可见，并在关闭数据库连接时自动删除。</target>
        </trans-unit>
        <trans-unit id="e15eb31b4ca840d3439ac476fb29777eeeba453d" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the number of rows of the FTS table that contain at least one instance of the term (in any column). If col contains an integer value, then this column contains the number of rows of the FTS table that contain at least one instance of the term in the column identified by the col value. As usual, the columns of the FTS table are numbered from left to right, starting with zero.</source>
          <target state="translated">如果 &quot;col &quot;列包含值'*',那么这一列包含FTS表中至少包含一个术语实例的行数(在任何列中)。如果 &quot;col &quot;列包含一个整数值,那么这一列包含FTS表中至少包含一个术语实例的行数,该术语实例在col值所标识的列中。像往常一样,FTS表的列从左到右编号,从0开始。</target>
        </trans-unit>
        <trans-unit id="be0668162f080a59b68a89416d5dac39edc657f3" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the total number of instances of the term in all rows of the FTS table (in any column). Otherwise, if col contains an integer value, then this column contains the total number of instances of the term that appear in the FTS table column identified by the col value.</source>
          <target state="translated">如果 &quot;col &quot;列包含值'*',那么这一列包含FTS表中所有行(任何一列)中该术语的实例总数。否则,如果col包含一个整数值,那么这一列包含由col值确定的FTS表列中出现的术语实例总数。</target>
        </trans-unit>
        <trans-unit id="f99db6ea5060e99b5afec54227ba46139ccc5e7b" translate="yes" xml:space="preserve">
          <source>If the &quot;schema&quot; is omitted, it defaults to the primary database (usually called 'main', unless renamed using &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;). Hence, the following two queries are normally equivalent:</source>
          <target state="translated">如果省略&amp;ldquo; schema&amp;rdquo;，则默认为主数据库（通常称为&amp;ldquo; main&amp;rdquo;，除非使用&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;重命名）。因此，以下两个查询通常是等效的：</target>
        </trans-unit>
        <trans-unit id="9f6d4e5f223a311e53834767137885dbc0d539c8" translate="yes" xml:space="preserve">
          <source>If the &quot;unordered&quot; argument is present, then the query planner assumes that the index is unordered and will not use the index for a range query or for sorting.</source>
          <target state="translated">如果存在 &quot;unordered &quot;参数,那么查询规划器会假设索引是无序的,并且不会将索引用于范围查询或排序。</target>
        </trans-unit>
        <trans-unit id="8751a71ff20c3c0ca54298560e238a1beb92d451" translate="yes" xml:space="preserve">
          <source>If the $bigstring variable has both a string and a &quot;bytearray&quot; representation, then TCL inserts the value as a string. If it has only a &quot;bytearray&quot; representation, then the value is inserted as a BLOB. To force a value to be inserted as a BLOB even if it also has a text representation, use a &quot;@&quot; character to in place of the &quot;$&quot;. Like this:</source>
          <target state="translated">如果$bigstring变量有字符串和 &quot;字节数组 &quot;两种表示方式,那么TCL就会把值作为字符串插入。如果它只有一个 &quot;字节数组 &quot;表示法,那么这个值将作为一个BLOB插入。要强制将一个值作为BLOB插入,即使它也有文本表示,使用&quot;@&quot;字符来代替&quot;$&quot;。就像这样。</target>
        </trans-unit>
        <trans-unit id="0c3adca9fee497a14e9991dafc4be56e1a6347bb" translate="yes" xml:space="preserve">
          <source>If the %Q formatting option is used instead of %q, like this:</source>
          <target state="translated">如果用%Q格式化选项代替%q,像这样。</target>
        </trans-unit>
        <trans-unit id="0d1bfccef6e7ea95fdaf4eab71d72c15d5446d0c" translate="yes" xml:space="preserve">
          <source>If the --vtab option is passed to sqldiff.exe, then it ignores all underlying shadow tables belonging to an FTS3, FTS5 or rtree virtual table and instead includes the virtual table differences directly.</source>
          <target state="translated">如果将--vtab选项传递给sqldiff.exe,那么它就会忽略所有属于FTS3、FTS5或rtree虚拟表的底层影子表,而直接包含虚拟表的差异。</target>
        </trans-unit>
        <trans-unit id="07a5d9f4ebefe616bbce2e1699c303419392f340" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter actually contains two or more statements of SQL, only the first statement is compiled. (This is different from the behavior of &lt;b&gt;sqlite_exec&lt;/b&gt; which executes all SQL statements in its input string.) The 3rd parameter to &lt;b&gt;sqlite_compile&lt;/b&gt; is made to point to the first character beyond the end of the first statement of SQL in the input. If the 2nd parameter contains only a single SQL statement, then the 3rd parameter will be made to point to the '\000' terminator at the end of the 2nd parameter.</source>
          <target state="translated">如果第二个参数实际上包含两个或多个SQL语句，则仅编译第一个语句。（这与在输入字符串中执行所有SQL语句的&lt;b&gt;sqlite_exec&lt;/b&gt;行为不同。）使&lt;b&gt;sqlite_compile&lt;/b&gt;的第三个参数指向输入中SQL的第一条语句末尾以外的第一个字符。如果第二个参数仅包含一个SQL语句，则将使第三个参数指向第二个参数末尾的'\ 000'终止符。</target>
        </trans-unit>
        <trans-unit id="ace6723edaabac46df7516bfbb37cb232ed631b4" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.</source>
          <target state="translated">如果sqlite3_exec()的第2个参数是一个NULL指针,一个指向空字符串的指针,或者一个只包含whitespace和/或SQL注释的指针,那么就不会评估SQL语句,也不会改变数据库。</target>
        </trans-unit>
        <trans-unit id="c83d25737a958db458bb466d715ef1df1385742b" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">如果sqlite3_open_v2（）的第3个参数不是上面显示的组合之一，可以选择与其他&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_ *位&lt;/a&gt;组合，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="a1fab614cdb3090bc486b1f93bb2bcc48a6de130" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">如果sqlite3_open_v2（）的第3个参数不是上面显示的组合之一，可以选择与其他&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_ *位&lt;/a&gt;组合，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="fab55d69b6d16a6b2315e4a3b04227ca982143b2" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">如果sqlite3_open_v2（）的第三个参数不是上面显示的必需组合之一，可以选择与其他&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_ *位&lt;/a&gt;组合，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="eafad762f6d4301ebb9f9fbfe8b641eb52751808" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">如果sqlite3_open_v2（）的第三个参数不是上面显示的必需组合之一，可以选择与其他&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_ *位&lt;/a&gt;组合，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="34c05ef78416159159b83c40de507c749c65acd9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">如果设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;标志，则只要在编译时或启动时未设置单线程模式，数据库连接就会以多线程&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;打开。如果设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;标志，则除非在编译时或启动时预先选择了单线程，否则数据库连接将以序列化&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;打开。所述&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;标志导致数据库连接到有资格使用&lt;a href=&quot;sharedcache&quot;&gt;共享高速缓存模式&lt;/a&gt;，而不管是否共享高速缓存的使用使能&lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（） &lt;/a&gt;。该&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;标志使数据库连接即使启用也不会参与&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f124aef410c3a3a5452b1a6fa293c0baf98a2590" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">如果未打开作为第一个参数传递的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;以进行写入（&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;的flags参数为零），则此函数返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b097a680522bfef6d5db94910e22cbe0a87ca6c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法将sqlite3_file.pMethods元素设置为非NULL指针，则即使&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;报告失败，也可以调用sqlite3_io_methods.xClose方法。防止在失败的&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;之后调用xClose的唯一方法是将&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;设置为将sqlite3_file.pMethods元素设置为NULL。</target>
        </trans-unit>
        <trans-unit id="c4075392a6aa7bc2b0c022c207b5beef854359fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;操作码返回SQLITE_OK，则文件描述符将置于&amp;ldquo;批量写入模式&amp;rdquo;，这意味着所有后续写入操作都将在下一个&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE上&lt;/a&gt;进行自动推迟。不支持批量原子写入的系统将返回SQLITE_NOTFOUND。成功执行SQLITE_FCNTL_BEGIN_ATOMIC_WRITE之后，并在关闭&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;或&lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE之前&lt;/a&gt;，SQLite将不在同一&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;文件描述符上进行VFS接口调用，除了使用SQLITE_FHITE_XHINT_ZEH的方法使用&lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FHITE_ZE_SIZE&lt;/a&gt;进行调用外。</target>
        </trans-unit>
        <trans-unit id="eadccb78851e96452064935ca6338980e2d4c8f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">如果&lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法调用sqlite3_vtab_nochange（）并发现UPDATE语句未更改该列，则xColumn方法可以选择返回而不设置结果，而无需调用任何&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx（）接口&lt;/a&gt;。在这种情况下，对于&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法中的同一列，&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;将返回true 。</target>
        </trans-unit>
        <trans-unit id="a8a1933767ab95a99c4ac8ef45461802121a0a08" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">如果未打开作为第一个参数传递的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;以进行写入（&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;的flags参数为零），则此函数返回&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b723e9fc3d49332b65d60edda223c8ec9ca4d696" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface is used to override the glob(X,Y) function with an alternative implementation then the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator will invoke the alternative implementation.</source>
          <target state="translated">如果使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;接口通过替代实现覆盖glob（X，Y）函数，则&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符将调用替代实现。</target>
        </trans-unit>
        <trans-unit id="3092cc5ebddb90376d018bb6c31fa51fc5b9d178" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;操作码返回SQLITE_OK，则文件描述符将置于&amp;ldquo;批量写入模式&amp;rdquo;，这意味着所有后续写入操作都将在下一个&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE上&lt;/a&gt;进行自动推迟。不支持批量原子写入的系统将返回SQLITE_NOTFOUND。成功执行SQLITE_FCNTL_BEGIN_ATOMIC_WRITE之后，并在关闭&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;或&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE之前&lt;/a&gt;，SQLite将不在同一&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;文件描述符上进行VFS接口调用，除了使用SQLITE_FHITE_XHINT_ZEH的方法使用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FHITE_ZE_SIZE&lt;/a&gt;进行调用外。</target>
        </trans-unit>
        <trans-unit id="26aea5eaba4882a7f57e469fe581e38b779b7c63" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">如果设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;标志，则只要在编译时或启动时未设置单线程模式，数据库连接就会以多线程&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;打开。如果设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;标志，则除非在编译时或启动时预先选择了单线程，否则数据库连接将以序列化&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;打开。所述&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;标志导致数据库连接到有资格使用&lt;a href=&quot;../sharedcache&quot;&gt;共享高速缓存模式&lt;/a&gt;，而不管是否共享高速缓存的使用使能&lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（） &lt;/a&gt;。该&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;标志使数据库连接即使启用也不会参与&lt;a href=&quot;../sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d6b9e280cf3c9ed4800b321c18f34c5a4956d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; option is used, then SQLite is capable of using 8+3 filenames but that capabilities is disabled and must be enabled separately for each database connection by using using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; when &lt;a href=&quot;c3ref/open&quot;&gt;opening&lt;/a&gt; or &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ing&lt;/a&gt; the database files and include the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter in the URI. If SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt; then 8+3 filenames are enabled by default and this step can be skipped.</source>
          <target state="translated">如果使用了&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt;选项，则SQLite能够使用8 + 3文件名，但是该功能已禁用，必须在&lt;a href=&quot;c3ref/open&quot;&gt;打开&lt;/a&gt;或&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;数据库文件时使用&lt;a href=&quot;uri&quot;&gt;URI文件&lt;/a&gt;名为每个数据库连接分别启用该功能，并包括URI中的&amp;ldquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &amp;rdquo;查询参数。如果使用&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt;编译SQLite，则默认启用8 + 3个文件名，并且可以跳过此步骤。</target>
        </trans-unit>
        <trans-unit id="f14f4e625a540ecf3e1de270c88730b0b55cfa0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies disk storage for temporary files, then override that decision and use memory storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">如果&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数为临时文件指定了磁盘存储，则覆盖该决定并改用内存存储。否则，请遵循&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数的建议。</target>
        </trans-unit>
        <trans-unit id="cc4e5ad04a8f404976f4ea549e621889ed4a2406" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies memory storage for temporary files, then override that decision and use disk storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">如果&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数为临时文件指定了内存存储，则覆盖该决定并改用磁盘存储。否则，请遵循&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数的建议。</target>
        </trans-unit>
        <trans-unit id="c75f136169c511a3f8a8fd887440953a9ba6fdef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of a column is REAL and that column contains a value that can be converted to an integer without loss of information (if the value contains no fractional part and is not too large to be represented as an integer) then the column may be stored in the record as an integer. SQLite will convert the value back to floating point when extracting it from the record.</source>
          <target state="translated">如果列的&lt;a href=&quot;datatype3#affinity&quot;&gt;亲和力&lt;/a&gt;为REAL，并且该列包含可以转换为整数而不会丢失信息的值（如果该值不包含小数部分，并且也不能太大以表示为整数），则该列可能是以整数形式存储在记录中。从记录中提取值时，SQLite会将值转换回浮点。</target>
        </trans-unit>
        <trans-unit id="6bdd9340a9dcd6ebb4b2136a687baf206a35c611" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not aliased by &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then it is not persistent and might change. In particular the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will change rowids for tables that do not declare an INTEGER PRIMARY KEY. Therefore, applications should not normally access the rowid directly, but instead use an INTEGER PRIMARY KEY.</source>
          <target state="translated">如果&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;不是由&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;别名的，则它不是永久的，并且可能会更改。特别是，&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令将更改未声明INTEGER PRIMARY KEY的表的行ID。因此，应用程序通常不应直接访问rowid，而应使用INTEGER PRIMARY KEY。</target>
        </trans-unit>
        <trans-unit id="534413628d6b934f8819dac36d834908d33b9044" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.P1 cursor is not currently pointing to a valid row, then this opcode is a no-op and control passes through into the &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE .P1&lt;/a&gt;光标当前未指向有效行，则此操作码为无操作，并且控制权传递到&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2855fd74b06888f79f65a4994feb49e64faf791" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.P1 cursor is pointing to a valid row, then that row might be the target row, or it might be near and slightly before the target row. This opcode attempts to position the cursor on the target row by, perhaps by invoking sqlite3BtreeStep() on the cursor between 0 and This.P1 times.</source>
          <target state="translated">如果&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE .P1&lt;/a&gt;游标指向有效行，则该行可能是目标行，或者可能在目标行附近并且稍早于目标行。此操作码可能尝试通过在0到This.P1之间调用光标上的sqlite3BtreeStep（）来将光标定位在目标行上。</target>
        </trans-unit>
        <trans-unit id="96317212b202d64aa994eed839385d463798a08e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; opcode is being used to fetch the value of an unchanging column during an UPDATE operation, then the P5 value is OPFLAG_NOCHNG. This will cause the sqlite3_vtab_nochange() function to return true inside the xColumn method of the virtual table implementation. The P5 column might also contain other bits (OPFLAG_LENGTHARG or OPFLAG_TYPEOFARG) but those bits are unused by &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;.</source>
          <target state="translated">如果在UPDATE操作期间使用&lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;操作码来获取不变列的值，则P5值为OPFLAG_NOCHNG。这将导致sqlite3_vtab_nochange（）函数在虚拟表实现的xColumn方法内部返回true。P5列可能还包含其他位（OPFLAG_LENGTHARG或OPFLAG_TYPEOFARG），但&lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;未使用这些位。</target>
        </trans-unit>
        <trans-unit id="2b4eaedd5855ff13b903e656d850adc325c12c79" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is used on a subquery in the FROM clause of a SELECT statement, that effectively merges the subquery into the outer query. The output of EXPLAIN QUERY PLAN reflects this, as in the following example:</source>
          <target state="translated">如果在SELECT语句的FROM子句中的子查询上使用了展&lt;a href=&quot;optoverview#flattening&quot;&gt;平优化&lt;/a&gt;，则可以有效地将子查询合并到外部查询中。EXPLAIN QUERY PLAN的输出反映了这一点，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="6110f6d9f2445ffa2d331ca1dfcaf53aa3a365b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS&lt;/a&gt; pragma is set to ON and the result of a query is an empty set, then the callback is invoked once with the third parameter (argv) set to 0. In other words</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;EMPTY_RESULT_CALLBACKS&lt;/a&gt;编译指示设置为ON，并且查询结果为空集，则在第三个参数（argv）设置为0的情况下调用一次回调。</target>
        </trans-unit>
        <trans-unit id="b1c24c8f45d6339d5389a76337c9e88f41b5e36a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; flag is set, then the F_FULLFSYNC syncing method is used for all sync operations and the checkpoint_fullfsync setting is irrelevant.</source>
          <target state="translated">如果设置了&lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt;标志，则将F_FULLFSYNC同步方法用于所有同步操作，并且checkpoint_fullfsync设置无关紧要。</target>
        </trans-unit>
        <trans-unit id="a73873febe6d7de1338d537c333841d126c81b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; pragma is ON, then the name of the result is the name of the source table column without the source table name prefix: COLUMN.</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;编译指示为ON，则结果的名称为没有源表名称前缀COLUMN的源表列的名称。</target>
        </trans-unit>
        <trans-unit id="1069754e926abbbcc7551f7b3c103d01ced65dbe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">如果&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法将sqlite3_file.pMethods元素设置为非NULL指针，则即使&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;报告失败，也可以调用sqlite3_io_methods.xClose方法。防止在失败的&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;之后调用xClose的唯一方法是将&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;设置为将sqlite3_file.pMethods元素设置为NULL。</target>
        </trans-unit>
        <trans-unit id="e03a0f37d058bb5a34bec7fac575235294acd0da" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">如果&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法调用sqlite3_vtab_nochange（）并发现UPDATE语句未更改该列，则xColumn方法可以选择返回而不设置结果，而无需调用任何&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx（）接口&lt;/a&gt;。在这种情况下，对于&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法中的同一列，&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;将返回true 。</target>
        </trans-unit>
        <trans-unit id="6aba978070ccc979bd49ef28d0ef204e751d91d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method in a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation returns an error message using &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error()&lt;/a&gt; then give that error message preference over internally-generated messages.</source>
          <target state="translated">如果&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现中的&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法使用&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error（）&lt;/a&gt;返回一条错误消息，则该错误消息优先于内部生成的消息。</target>
        </trans-unit>
        <trans-unit id="a18d90fb5154dfedaa1471558060511dc56cfb54" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL, then &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statements are prohibited for that virtual table, and the virtual table is an &quot;eponymous-only virtual table&quot;. Eponymous-only virtual tables are useful as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法为NULL，则该虚拟表禁止使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句，并且该虚拟表是&amp;ldquo;仅具有名称的虚拟表&amp;rdquo;。仅具有名称的虚拟表可用作&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e36f28038a4ddd30d8f77a7f397ce33837d3478d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; method for the virtual table is defined, and if xFindFunction() sometimes returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, then the constraints might also be of the form:</source>
          <target state="translated">如果为虚拟表定义了&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction（）&lt;/a&gt;方法，并且如果xFindFunction（）有时返回&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;或更大，则约束也可能采用以下形式：</target>
        </trans-unit>
        <trans-unit id="89b6cc463721d8831624d29f70a88929969774cd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;), this pragma causes a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation to run on database</source>
          <target state="translated">如果启用了&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;（通过&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;），则该杂注将导致在数据库上运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作</target>
        </trans-unit>
        <trans-unit id="fa30bb229e0ba6c16b036d0680166f4c0e969175" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;header&lt;/b&gt; argument is true then the first row of the CSV file to be treated as a header rather than as data. The second line of the CSV file becomes the first row of content. If the &lt;b&gt;schema=&lt;/b&gt; options is omitted, then the first line of the CSV file determines the names of the columns.</source>
          <target state="translated">如果&lt;b&gt;header&lt;/b&gt;参数为true，则CSV文件的第一行将被视为标题而不是数据。CSV文件的第二行成为内容的第一行。如果省略&lt;b&gt;schema =&lt;/b&gt;选项，则CSV文件的第一行将确定列的名称。</target>
        </trans-unit>
        <trans-unit id="c1cfb6451556f25af13b7b368489aadb6eb20ce2" translate="yes" xml:space="preserve">
          <source>If the AUTOINCREMENT keyword appears after INTEGER PRIMARY KEY, that changes the automatic ROWID assignment algorithm to prevent the reuse of ROWIDs over the lifetime of the database. In other words, the purpose of AUTOINCREMENT is to prevent the reuse of ROWIDs from previously deleted rows.</source>
          <target state="translated">如果AUTOINCREMENT关键字出现在INTEGER PRIMARY KEY之后,那就改变了自动分配ROWID的算法,以防止在数据库的生命周期内重复使用ROWID。换句话说,AUTOINCREMENT的目的是防止以前删除的行的ROWID被重复使用。</target>
        </trans-unit>
        <trans-unit id="e7ae8b25bf55713a14aa930c0d079c55585a0c82" translate="yes" xml:space="preserve">
          <source>If the C version of the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU library&lt;/a&gt; is available, then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined. Compiling with this macro enables an FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; that uses the ICU library to split a document into terms (words) using the conventions for a specified language and locale.</source>
          <target state="translated">如果&lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU库&lt;/a&gt;的C版本可用，则还可以使用已定义的SQLITE_ENABLE_ICU预处理程序宏来编译FTS。使用此宏进行编译，可使FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;令牌生成器&lt;/a&gt;使用ICU库，使用指定语言和语言环境的约定将文档拆分为术语（单词）。</target>
        </trans-unit>
        <trans-unit id="aade338ead72cd83806851289f36afe9ffee6390" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果尝试执行DELETE操作，但是SQLite返回SQLITE_CONSTRAINT（只有在违反外键约束的情况下才会发生），将使用作为第二个参数传递的&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;调用冲突处理函数。这包括尝试执行DELETE操作的情况，因为对冲突处理程序函数的较早调用返回了&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4726b3dbe2c58403328aff3054192714f5fc075" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果尝试执行DELETE操作，但是SQLite返回SQLITE_CONSTRAINT（只有在违反外键约束的情况下才会发生），将使用作为第二个参数传递的&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;调用冲突处理函数。这包括尝试执行DELETE操作的情况，因为对冲突处理程序函数的较早调用返回了&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a02c654b3d70302948f2081631be3edc27671a93" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has an ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are sorted according to the ORDER BY. The first</source>
          <target state="translated">如果DELETE语句有ORDER BY子句,那么在没有LIMIT子句的情况下,所有要删除的记录都会按照ORDER BY进行排序。第一条</target>
        </trans-unit>
        <trans-unit id="63547bac31e35c719e75fc46ff0cebecf92fd269" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has no ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine the subset that are actually deleted.</source>
          <target state="translated">如果DELETE语句没有ORDER BY子句,那么在应用LIMIT和OFFSET子句确定实际被删除的子集之前,所有在没有LIMIT子句的情况下会被删除的行都会以任意的顺序组合。</target>
        </trans-unit>
        <trans-unit id="20e8eb12f584aa2a2c71da9ffe10b6bc6f97692b" translate="yes" xml:space="preserve">
          <source>If the ESCAPE option is used, the ESCAPE character must be ASCII, or a single-byte character in UTF-8.</source>
          <target state="translated">如果使用ESCAPE选项,ESCAPE字符必须是ASCII码,或UTF-8中的单字节字符。</target>
        </trans-unit>
        <trans-unit id="d5df7edc7165f75cb1f0d5e995a539c8d7c8967f" translate="yes" xml:space="preserve">
          <source>If the F parameter is not one of the above, then the behavior is undefined and probably undesirable. Older versions of SQLite were more tolerant of invalid F parameters than newer versions.</source>
          <target state="translated">如果F参数不是上述之一,那么该行为是未定义的,可能是不可取的。旧版本的SQLite对无效F参数的容忍度比新版本更高。</target>
        </trans-unit>
        <trans-unit id="7f76a2496ff32a61cee2f76ed3e0830800bfd787" translate="yes" xml:space="preserve">
          <source>If the FROM clause is omitted from a simple SELECT statement, then the input data is implicitly a single row zero columns wide (i.e.</source>
          <target state="translated">如果在一个简单的SELECT语句中省略了FROM子句,那么输入的数据就隐含在零列宽的单行中(也就是</target>
        </trans-unit>
        <trans-unit id="408ec930c8db59ef8bcaccad18026b5e15f9eaec" translate="yes" xml:space="preserve">
          <source>If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed with a &quot;^&quot; character. In this case, in order to match the token must appear as the very first token in any column of the matching row. Examples:</source>
          <target state="translated">如果FTS表是FTS4表(而不是FTS3表),标记也可以用&quot;^&quot;字符作为前缀。在这种情况下,为了匹配,标记必须作为匹配行中任何列的第一个标记出现。例子。</target>
        </trans-unit>
        <trans-unit id="93fd7e443f86d05e9fc567cfba4cc2ea3b224813" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the 'detail' option set to 'col', then the</source>
          <target state="translated">如果在创建FTS5表时,将 &quot;详细 &quot;选项设置为 &quot;列&quot;,则</target>
        </trans-unit>
        <trans-unit id="328eea17bcdc9be6b714e803c02a72c349cdef14" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the detail=none or detail=column option specified, full-text queries may not contain any tokens longer than 3 unicode characters. LIKE and GLOB pattern matching may be slightly slower, but still works. If the index is to be used only for LIKE and/or GLOB pattern matching, these options are worth experimenting with to reduce the index size.</source>
          <target state="translated">如果在创建FTS5表时指定了detail=none或detail=column选项,则全文查询可能不包含任何超过3个unicode字符的标记。LIKE和GLOB模式匹配可能会稍微慢一些,但仍然可以使用。如果索引只用于LIKE和/或GLOB模式匹配,这些选项值得尝试,以减少索引大小。</target>
        </trans-unit>
        <trans-unit id="99ee296e09aab46dd06e0a5f1c140a90b72606e3" translate="yes" xml:space="preserve">
          <source>If the HAVE_FDATASYNC compile-time option is true, then the default &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for unix systems will attempt to use fdatasync() instead of fsync() where appropriate. If this flag is missing or false, then fsync() is always used.</source>
          <target state="translated">如果HAVE_FDATASYNC编译时选项为true，则Unix系统的默认&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;将在适当的情况下尝试使用fdatasync（）代替fsync（）。如果此标志丢失或为false，则始终使用fsync（）。</target>
        </trans-unit>
        <trans-unit id="8e31d6de70624cd3258a7c666db7d8624e2234e9" translate="yes" xml:space="preserve">
          <source>If the HAVE_GMTIME_R option is true and if &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is true, then the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords will use the threadsafe &quot;gmtime_r()&quot; interface rather than &quot;gmtime()&quot;. In the usual case where &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is not defined or is false, then the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; are used to implement the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords and neither gmtime_r() nor gmtime() is ever called.</source>
          <target state="translated">如果HAVE_GMTIME_R选项为true，并且&lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt;为true，则CURRENT_TIME，CURRENT_DATE和CURRENT_TIMESTAMP关键字将使用线程安全的&amp;ldquo; gmtime_r（）&amp;rdquo;接口而不是&amp;ldquo; gmtime（）&amp;rdquo;。在&lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;未定义SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt;或为false 的通常情况下，内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;用于实现CURRENT_TIME，CURRENT_DATE和CURRENT_TIMESTAMP关键字，并且从未调用过gmtime_r（）和gmtime（）。</target>
        </trans-unit>
        <trans-unit id="40cdcf3ade2687218b791686ca4436d6b3c5cfba" translate="yes" xml:space="preserve">
          <source>If the HAVE_ISNAN option is true, then SQLite invokes the system library isnan() function to determine if a double-precision floating point value is a NaN. If HAVE_ISNAN is undefined or false, then SQLite substitutes its own home-grown implementation of isnan().</source>
          <target state="translated">如果HAVE_ISNAN选项为true,那么SQLite就会调用系统库中的isnan()函数来确定一个双精度浮点值是否为NaN。如果HAVE_ISNAN选项未定义或为false,那么SQLite就会用它自己的自家开发的annan()实现来代替。</target>
        </trans-unit>
        <trans-unit id="153cb2536cd91084b29b41e9d14f8a7ef310cc61" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_R option is true, then SQLite uses the threadsafe localtime_r() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">如果HAVE_LOCALTIME_R选项为true，则SQLite使用线程安全的localtime_r（）库例程而不是localtime（）来帮助实现内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;的&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修饰符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c4b14956847344de7b5a6ccb25e5f358e368735" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_S option is true, then SQLite uses the threadsafe localtime_s() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">如果HAVE_LOCALTIME_S选项为true，则SQLite使用线程安全的localtime_s（）库例程而不是localtime（）来帮助实现内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;的&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修饰符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="997bea68ec053527286253926a4446e11225f13c" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is omitted or is false, then SQLite uses a wrapper around system malloc() and realloc() that enlarges each allocation by 8 bytes and writes the size of the allocation in the initial 8 bytes, and then SQLite also implements its own home-grown version of malloc_usable_size() that consults that 8-byte prefix to find the allocation size. This approach works but it is suboptimal. Applications are encouraged to use HAVE_MALLOC_USABLE_SIZE whenever possible.</source>
          <target state="translated">如果HAVE_MALLOC_USABLE_SIZE选项被省略或为false,那么SQLite就会使用一个围绕系统malloc()和realloc()的封装器,将每个分配额扩大8个字节,并将分配额的大小写在初始的8个字节中,然后SQLite也会实现自己自家开发的malloc_usable_size()版本,参考这个8个字节的前缀来查找分配额的大小。这种方法是可行的,但它是次优的。我们鼓励应用程序尽可能地使用HAVE_MALLOC_USABLE_SIZE。</target>
        </trans-unit>
        <trans-unit id="55308f0ca78c87c49d7100dbf1e1e1adc1d30409" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is true, then SQLite tries uses the malloc_usable_size() interface to find the size of a memory allocation obtained from the standard-library malloc() or realloc() routines. This option is only applicable if the standard-library malloc() is used. On Apple systems, &quot;zone malloc&quot; is used instead, and so this option is not applicable. And, of course, if the application supplies its own malloc implementation using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; then this option has no effect.</source>
          <target state="translated">如果HAVE_MALLOC_USABLE_SIZE选项为true，则SQLite会尝试使用malloc_usable_size（）接口来查找从标准库malloc（）或realloc（）例程获得的内存分配的大小。仅当使用标准库malloc（）时，此选项才适用。在Apple系统上，使用&amp;ldquo;区域malloc&amp;rdquo;代替，因此该选项不适用。而且，当然，如果应用程序使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;提供了自己的malloc实现，则此选项无效。</target>
        </trans-unit>
        <trans-unit id="3344d140659472562fd4dea21990938229ddf3ec" translate="yes" xml:space="preserve">
          <source>If the HAVE_STRCHRNUL option is true, then SQLite uses the strchrnul() library function. If this option is missing or false, then SQLite substitutes its own home-grown implementation of strchrnul().</source>
          <target state="translated">如果HAVE_STRCHRNUL选项为true,那么SQLite就会使用strchrnul()库函数。如果这个选项缺失或为false,那么SQLite就会用它自己的国产strchrnul()实现来代替。</target>
        </trans-unit>
        <trans-unit id="08d8894136dfc0e284f285c182990a928235abdc" translate="yes" xml:space="preserve">
          <source>If the HAVE_USLEEP option is true, then the default unix VFS uses the usleep() system call to implement the xSleep method. If this option is undefined or false, then xSleep on unix is implemented using sleep() which means that &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; will have a minimum wait interval of 1000 milliseconds regardless of its argument.</source>
          <target state="translated">如果HAVE_USLEEP选项为true，则默认的unix VFS使用usleep（）系统调用来实现xSleep方法。如果此选项未定义或为false，则使用sleep（）实现unix上的xSleep，这意味着&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;的最小等待间隔为1000毫秒，无论其参数如何。</target>
        </trans-unit>
        <trans-unit id="538ccd48ed8bd61407504bbf28bbe6d0ffe8bf96" translate="yes" xml:space="preserve">
          <source>If the HAVE_UTIME option is true, then the built-in but non-standard &quot;unix-dotfile&quot; VFS will use the utime() system call, instead of utimes(), to set the last access time on the lock file.</source>
          <target state="translated">如果HAVE_UTIME选项为真,那么内置但非标准的 &quot;unix-dotfile &quot;VFS将使用utime()系统调用,而不是utimes()来设置锁文件的最后访问时间。</target>
        </trans-unit>
        <trans-unit id="7cab5093752cc9a8b0a63442b0923931057ad2d6" translate="yes" xml:space="preserve">
          <source>If the INTO clause is included, then the original database file is unchanged and a new database is created in the filename given by the argument to the INTO clause. The new database will contain the same logical content as the original database, fully vacuumed.</source>
          <target state="translated">如果包含INTO子句,那么原数据库文件不变,在INTO子句参数给出的文件名中创建一个新的数据库。新数据库将包含与原数据库相同的逻辑内容,完全真空化。</target>
        </trans-unit>
        <trans-unit id="b0e0bffd82940bcd9134c72373f0af179d9c5474" translate="yes" xml:space="preserve">
          <source>If the LIMIT expression evaluates to non-negative value</source>
          <target state="translated">如果LIMIT表达式评估为非负值</target>
        </trans-unit>
        <trans-unit id="f61e07bad4e222ccefd74ac63dc52c1ed3c63a8f" translate="yes" xml:space="preserve">
          <source>If the NATURAL keyword is in the join-operator then an implicit USING clause is added to the join-constraints. The implicit USING clause contains each of the column names that appear in both the left and right-hand input datasets. If the left and right-hand input datasets feature no common column names, then the NATURAL keyword has no effect on the results of the join. A USING or ON clause may not be added to a join that specifies the NATURAL keyword.</source>
          <target state="translated">如果在join-operator中使用了NATURAL关键字,那么就会在join-constraints中添加一个隐式的USING子句。隐式USING子句包含左手和右手输入数据集中出现的每个列名。如果左边和右边的输入数据集没有共同的列名,那么NATURAL关键字对连接的结果没有影响。在指定NATURAL关键字的连接中,不能添加USING或ON子句。</target>
        </trans-unit>
        <trans-unit id="a2b9577c2b86e52c07b264eb7017d085b143b677" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routine might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">如果语句返回的第N列是表达式或子查询,而不是列值,那么这些函数都返回NULL。如果发生内存分配错误,这些例程也可能返回NULL。否则,它们会返回查询结果列所提取的附加数据库、表或列的名称。</target>
        </trans-unit>
        <trans-unit id="7286275584ec903ae36c4fc51d813a102d9d7ca1" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routines might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">如果语句返回的第N列是一个表达式或子查询,而不是一个列值,那么所有这些函数都返回NULL。如果发生内存分配错误,这些例程也可能返回NULL。否则,它们会返回所附数据库、表或查询结果列的名称。</target>
        </trans-unit>
        <trans-unit id="f987b1e749686c5439c4369e9509e69172835e8f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this delete one of several associated with deleting a table row and all its associated index entries. Exactly one of those deletes is the &quot;primary&quot; delete. The others are all on OPFLAG_FORDELETE cursors or else are marked with the AUXDELETE flag.</source>
          <target state="translated">如果在P5上设置了OPFLAG_AUXDELETE位,则表明这次删除是与删除表行及其所有相关索引项相关联的几次删除之一。恰恰其中的一个删除是 &quot;主 &quot;删除。其他的都是在OPFLAG_FORDELETE游标上,否则就用AUXDELETE标志。</target>
        </trans-unit>
        <trans-unit id="2e0584b25ae53697595c710240b674cfcd931b66" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set in P2, then P3 contains the address of the memory cell that contains the value that the rowid of the row will be set to by the update.</source>
          <target state="translated">如果在P2中设置了OPFLAG_ISUPDATE标志,那么P3就包含了包含该行的rowid将被更新设置为的值的内存单元的地址。</target>
        </trans-unit>
        <trans-unit id="85453347b772792d0ef83ca6247504c978601416" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an UPDATE operation. Otherwise (if the flag is clear) then this opcode is part of an INSERT operation. The difference is only important to the update hook.</source>
          <target state="translated">如果OPFLAG_ISUPDATE标志被设置,那么这个操作码是UPDATE操作的一部分。否则(如果标志是清除的),那么这个操作码是INSERT操作的一部分。这两者的区别只对更新钩子很重要。</target>
        </trans-unit>
        <trans-unit id="358930ea0c0cb3bf8ddbac06391138cf9e1e9b1f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then the result is guaranteed to only be used as the argument of a length() or typeof() function, respectively. The loading of large blobs can be skipped for length() and all content loading can be skipped for typeof().</source>
          <target state="translated">如果在P5上设置了OPFLAG_LENGTHARG和OPFLAG_TYPEOFARG位,那么保证结果只能分别作为length()或typeof()函数的参数。对于length()来说,可以跳过大的blob的加载,对于typeof()来说,可以跳过所有的内容加载。</target>
        </trans-unit>
        <trans-unit id="b673a87eca1e30fb0e05ce7b3a0e2e621baf2f1c" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row change count is incremented (otherwise not).</source>
          <target state="translated">如果设置了P2的OPFLAG_NCHANGE标志(NB:P2不是P5),则行变化计数递增(否则不递增)。</target>
        </trans-unit>
        <trans-unit id="8006bf0580f0ceee7abfbb502ff0bc2738a32586" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is incremented (otherwise not). If the OPFLAG_LASTROWID flag of P5 is set, then rowid is stored for subsequent return by the sqlite3_last_insert_rowid() function (otherwise it is unmodified).</source>
          <target state="translated">如果P5的OPFLAG_NCHANGE标志被设置,那么行变化计数会被递增(否则不递增)。如果设置了P5的OPFLAG_LASTROWID标志,那么 rowid将被存储起来,以便后续由sqlite3_last_insert_rowid()函数返回(否则不修改)。</target>
        </trans-unit>
        <trans-unit id="0464f564c819708fc95ba0ca873e884f00c0c5ec" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then the cursor will be left pointing at either the next or the previous record in the table. If it is left pointing at the next record, then the next &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will be a no-op. As a result, in this case it is ok to delete a record from within a &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; loop. If OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be left in an undefined state.</source>
          <target state="translated">如果将P5参数的OPFLAG_SAVEPOSITION位置1，则光标将指向表中的下一个或上一个记录。如果它指向下一条记录，则下一条&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;指令将为空操作。结果，在这种情况下，可以从&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;循环中删除记录。如果P5的OPFLAG_SAVEPOSITION位清零，则光标将处于未定义状态。</target>
        </trans-unit>
        <trans-unit id="b8443bd622375a798ed2a10b2bb936621afb5e73" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equal to P3.</source>
          <target state="translated">如果设置了P5的OPFLAG_USESEEKRESULT标志,那么通过避免在游标P1上进行不必要的查找,实现的运行速度会更快。但是,OPFLAG_USESEEKRESULT标志只有在之前没有在游标上进行搜索,或者最近一次搜索使用的键等于P3的情况下才能被设置。</target>
        </trans-unit>
        <trans-unit id="24d1994d6156f999d1ee517ed391edb59d48c618" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equivalent to P2.</source>
          <target state="translated">如果设置了P5的OPFLAG_USESEEKRESULT标志,那么通过避免在游标P1上进行不必要的查找,实现的运行速度会更快。但是,OPFLAG_USESEEKRESULT标志只有在之前没有在游标上进行过搜索,或者最近一次搜索使用了与P2等价的键的情况下才能被设置。</target>
        </trans-unit>
        <trans-unit id="1f2be7bea7738f3621eca4267ce81f09d41a2e23" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is a constant integer K then the expression is considered an alias for the K-th column of the result set (columns are numbered from left to right starting with 1).</source>
          <target state="translated">如果ORDER BY表达式是一个常数整数K,那么该表达式被认为是结果集第K-th列的别名(列从1开始从左到右编号)。</target>
        </trans-unit>
        <trans-unit id="54b7818868eb0e39bd8ddbed56195f5499a4600b" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is an identifier that corresponds to the alias of one of the output columns, then the expression is considered an alias for that column.</source>
          <target state="translated">如果ORDER BY表达式是一个与某一输出列的别名相对应的标识符,那么该表达式被认为是该列的别名。</target>
        </trans-unit>
        <trans-unit id="00fdbe0ee21cda19b4a8ae7897474539b1f0a75c" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the specified collation sequence is used.</source>
          <target state="translated">如果使用后缀&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;为ORDER BY表达式分配了排序规则序列，则使用指定的排序规则序列。</target>
        </trans-unit>
        <trans-unit id="d77a3e5eca6240aa4cf73a2d563a4460d778268d" translate="yes" xml:space="preserve">
          <source>If the P1 cursor must be pointing to a valid row (not a NULL row) of a real table, not a pseudo-table.</source>
          <target state="translated">如果P1游标必须指向真实表的有效行(不是NULL行),而不是伪表。</target>
        </trans-unit>
        <trans-unit id="1f5366d1e68bed932cc9eadcf38bc5c4aed05e24" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">如果P1索引条目大于或等于键值,则跳转到P2。否则跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="eb12e9cd16de01f1875169ba7dbce89a734843ad" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">如果P1索引条目大于键值,则跳转到P2。否则跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="dbe830f25814f54ccec56a9eb14db5b310130922" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">如果P1索引条目小于或等于键值,则跳转到P2。否则跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="a25915e27b156d98cb891f738fe575b0c439ae6a" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">如果P1索引条目小于键值,则跳转到P2。否则跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="64d6010c68c3d803b2d20f7d66e38f73be2fb061" translate="yes" xml:space="preserve">
          <source>If the P1 value is non-zero, then also set the MEM_Cleared flag so that NULL values will not compare equal even if SQLITE_NULLEQ is set on &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; or &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;.</source>
          <target state="translated">如果P1的值不为零，则还要设置MEM_Cleared标志，以使即使在&lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt;或&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;上设置了SQLITE_NULLEQ，NULL值也不会相等。</target>
        </trans-unit>
        <trans-unit id="f14a9a47b078e93cd304b6691cdab49407396c8d" translate="yes" xml:space="preserve">
          <source>If the P3 value is non-zero, then the table referred to must be an intkey table (an SQL table, not an index). In this case the row change count is incremented by the number of rows in the table being cleared. If P3 is greater than zero, then the value stored in register P3 is also incremented by the number of rows in the table being cleared.</source>
          <target state="translated">如果P3值为非零,那么所指的表必须是一个intkey表(一个SQL表,不是索引)。在这种情况下,行变化计数按被清除表中的行数递增。如果P3大于零,那么存储在寄存器P3中的值也会按被清零表中的行数递增。</target>
        </trans-unit>
        <trans-unit id="5877a66b1cea7b0ea64daa7c24ed48ab6bbcee07" translate="yes" xml:space="preserve">
          <source>If the PRIMARY KEY of a WITHOUT ROWID tables uses the same columns with the same collating sequence more than once, then the second and subsequent occurrences of that column in the PRIMARY KEY definition are ignored. For example, the following CREATE TABLE statements all specify the same table, which will have the exact same representation on disk:</source>
          <target state="translated">如果一个WITHOUT ROWID表的PRIMARY KEY不止一次地使用具有相同整理序列的相同列,那么PRIMARY KEY定义中该列的第二次及以后的出现将被忽略。例如,下面的CREATE TABLE语句都指定了同一个表,该表在磁盘上的表示方式将完全相同。</target>
        </trans-unit>
        <trans-unit id="d8742c4d987b7b8bb8b01f7cdaee658b0bce0f67" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is followed by a collation-sequence name, then all indices in all attached databases that use the named collation sequences are recreated.</source>
          <target state="translated">如果REINDEX关键字后面跟着一个整理序列名称,那么所有使用命名的整理序列的附加数据库中的所有索引都会被重新创建。</target>
        </trans-unit>
        <trans-unit id="89611a3566f7e2d206b997930c668d8b59f61d02" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is not followed by a collation-sequence or database object identifier, then all indices in all attached databases are rebuilt.</source>
          <target state="translated">如果REINDEX关键字后面没有整理序列或数据库对象标识符,那么所有附加数据库中的所有索引都会被重建。</target>
        </trans-unit>
        <trans-unit id="9ec1988ffd8f39b68011de5a95c4dd634ef25613" translate="yes" xml:space="preserve">
          <source>If the S argument to sqlite3_txn_state(D,S) is not the name of a valid schema, then -1 is returned.</source>
          <target state="translated">如果sqlite3_txn_state(D,S)的S参数不是一个有效模式的名称,那么返回-1。</target>
        </trans-unit>
        <trans-unit id="95360c5e4a315542249137c79e8a2d6b511f7fdc" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;a non-aggregate query&lt;/b&gt;, then each expression in the result expression list is evaluated for each row in the dataset filtered by the WHERE clause.</source>
          <target state="translated">如果SELECT语句&lt;b&gt;是非聚合查询&lt;/b&gt;，则将针对WHERE子句过滤的数据集中的每一行对结果表达式列表中的每个表达式进行求值。</target>
        </trans-unit>
        <trans-unit id="869026a04188f9191fbf03ed77ea46ac1ecc8cb4" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query with a GROUP BY&lt;/b&gt; clause, then each of the expressions specified as part of the GROUP BY clause is evaluated for each row of the dataset. Each row is then assigned to a &quot;group&quot; based on the results; rows for which the results of evaluating the GROUP BY expressions are the same get assigned to the same group. For the purposes of grouping rows, NULL values are considered equal. The usual rules for &lt;a href=&quot;datatype3#collation&quot;&gt;selecting a collation sequence&lt;/a&gt; with which to compare text values apply when evaluating expressions in a GROUP BY clause. The expressions in the GROUP BY clause do &lt;em&gt;not&lt;/em&gt; have to be expressions that appear in the result. The expressions in a GROUP BY clause may not be aggregate expressions.</source>
          <target state="translated">如果SELECT语句是&lt;b&gt;带有GROUP BY&lt;/b&gt;子句&lt;b&gt;的聚合查询&lt;/b&gt;，则将对数据集的每一行评估作为GROUP BY子句的一部分指定的每个表达式。然后根据结果将每一行分配给一个&amp;ldquo;组&amp;rdquo;。将对GROUP BY表达式求值的结果相同的行分配给同一组。为了对行进行分组，将NULL值视为相等。在GROUP BY子句中评估表达式时，将应用&lt;a href=&quot;datatype3#collation&quot;&gt;选择与排序&lt;/a&gt;规则序列进行比较的常规规则。在GROUP BY子句中的这个表达式&lt;em&gt;并非&lt;/em&gt;必须出现在结果表达式。 GROUP BY子句中的表达式不能为聚合表达式。</target>
        </trans-unit>
        <trans-unit id="5f32b910ff370c514af729f0255dcd885c666376" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query without a GROUP BY&lt;/b&gt; clause, then each aggregate expression in the result-set is evaluated once across the entire dataset. Each non-aggregate expression in the result-set is evaluated once for an arbitrarily selected row of the dataset. The same arbitrarily selected row is used for each non-aggregate expression. Or, if the dataset contains zero rows, then each non-aggregate expression is evaluated against a row consisting entirely of NULL values.</source>
          <target state="translated">如果SELECT语句是&lt;b&gt;不带GROUP BY&lt;/b&gt;子句&lt;b&gt;的聚合查询&lt;/b&gt;，则结果集中的每个聚合表达式将在整个数据集中进行一次评估。对于数据集的任意选择的行，结果集中的每个非聚合表达式都会被评估一次。相同的任意选择的行用于每个非聚合表达式。或者，如果数据集包含零行，则将针对完全由NULL值组成的行评估每个非聚合表达式。</target>
        </trans-unit>
        <trans-unit id="14209330d1f571e7543dcd8d5633bd2d841dd6e1" translate="yes" xml:space="preserve">
          <source>If the SELECT statement specified as part of the CREATE VIRTUAL TABLE command returns five columns, then the final column is used for application context only. Swarmvtab does not use this value at all, except that it is passed after &amp;lt;database-name&amp;gt; to both the openclose and missing functions, if specified. In other words, instead of invoking the functions as described above, if the &quot;context&quot; column is present swarmvtab instead invokes:</source>
          <target state="translated">如果作为CREATE VIRTUAL TABLE命令的一部分指定的SELECT语句返回五列，则最后一列仅用于应用程序上下文。Swarmvtab根本不使用该值，只是将它在&amp;lt;database-name&amp;gt;之后传递给openclose和缺少的函数（如果已指定）。换句话说，如果没有出现&amp;ldquo; context&amp;rdquo;列，则swarmvtab代替调用上述函数，而是调用：</target>
        </trans-unit>
        <trans-unit id="40411dedc1ef7864197c263597ddfac1b246cd97" translate="yes" xml:space="preserve">
          <source>If the SQL COMMIT command turns autocommit on and the autocommit logic then tries to commit change but fails because some other process is holding a SHARED lock, then autocommit is turned back off automatically. This allows the user to retry the COMMIT at a later time after the SHARED lock has had an opportunity to clear.</source>
          <target state="translated">如果SQL COMMIT命令开启了自动提交,然后自动提交逻辑试图提交更改,但由于其他进程持有SHARED锁而失败,那么自动提交会自动关闭。这样,用户就可以在SHARED锁有机会清除后,在以后的时间重新尝试COMMIT。</target>
        </trans-unit>
        <trans-unit id="507b41df5b9644d0a599bc2c2ba64c3ea6d21fd9" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">如果正在执行的SQL语句返回任何数据，则每次准备好调用者处理新的数据行时，都将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;。可以使用&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;列访问功能&lt;/a&gt;访问这些值。再次调用sqlite3_step（）以检索下一行数据。</target>
        </trans-unit>
        <trans-unit id="ae2787ab5fa2a6425b73b07a4b0ad6b9f341262a" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">如果正在执行的SQL语句返回任何数据，则每次准备好调用者处理新的数据行时，都将返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。可以使用&lt;a href=&quot;column_blob&quot;&gt;列访问功能&lt;/a&gt;访问这些值。再次调用sqlite3_step（）以检索下一行数据。</target>
        </trans-unit>
        <trans-unit id="95d391fa1b14c12c13b7ff2232dd79f1ad704028" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">如果SQL语句当前未指向有效行，或者列索引​​超出范围，则结果不确定。仅当最近对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）的&lt;/a&gt;调用已返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;并且随后未调用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;时，才可以调用这些例程。如果在&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;之后或&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;以外的值之后调用了这些例程中的任何一个，则结果是不确定的。如果是&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;当这些例程中的任何一个都处于挂起状态时，从另一个线程调用它们，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="34c305f0b8de32e5d504a58326a82216502c31ad" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">如果SQL语句当前未指向有效行，或者列索引​​超出范围，则结果不确定。仅当最近对&lt;a href=&quot;step&quot;&gt;sqlite3_step（）的&lt;/a&gt;调用已返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;并且随后未调用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;和&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;时，才可以调用这些例程。如果在&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;之后或&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;以外的值之后调用了这些例程中的任何一个，则结果是不确定的。如果是&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;当这些例程中的任何一个都处于挂起状态时，从另一个线程调用它们，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="975432fbe3b7571414ef3444c9bae0dbbb675815" translate="yes" xml:space="preserve">
          <source>If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will invoke sqlite3_free() on the serialization buffer when the database connection closes. If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64() if writes on the database cause it to grow larger than M bytes.</source>
          <target state="translated">如果在F中设置了SQLITE_DESERIALIZE_FREEONCLOSE位,那么当数据库连接关闭时,SQLite将在序列化缓冲区上调用sqlite3_free()。如果设置了SQLITE_DESERIALIZE_RESIZEABLE位,那么如果对数据库的写入导致缓冲区增长超过M个字节,SQLite将尝试使用sqlite3_realloc64()增加缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="ea23bbe6e0f5cd400c470a465a873018f1aa3b8b" translate="yes" xml:space="preserve">
          <source>If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or reg(P3) is NULL then the take the jump. If the SQLITE_JUMPIFNULL bit is clear then fall through if either operand is NULL.</source>
          <target state="translated">如果P5的SQLITE_JUMPIFNULL位被设置,且reg(P1)或reg(P3)为NULL,则采取跳转。如果SQLITE_JUMPIFNULL位为清,那么如果任何一个操作数为NULL,则落空。</target>
        </trans-unit>
        <trans-unit id="d13a5c515dea25bad07a7535880df286b04090a5" translate="yes" xml:space="preserve">
          <source>If the SQLite library is compiled without the NDEBUG preprocessor macro, then the PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace &lt;/a&gt; causes the VDBE to trace the execution of programs. Though this feature was originally intended for testing and debugging, it can also be useful in learning about how the VDBE operates. Use &quot;&lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt;&quot; to turn tracing on and &quot;&lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt;&quot; to turn tracing back off. Like this:</source>
          <target state="translated">如果在没有NDEBUG预处理程序宏的情况下编译SQLite库，则PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt;会使VDBE跟踪程序的执行。尽管此功能最初是用于测试和调试的，但它对于了解VDBE的运行方式也很有用。使用&amp;ldquo; &lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt; &amp;rdquo;打开跟踪，使用&amp;ldquo; &lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt; &amp;rdquo;关闭跟踪。像这样：</target>
        </trans-unit>
        <trans-unit id="4b9cda344fb3698660c6374cdcb25b1c3d461a5e" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error.</source>
          <target state="translated">如果在CREATE和INDEX之间出现UNIQUE关键字,那么就不允许插入重复的索引条目。任何插入重复条目的尝试都会导致错误。</target>
        </trans-unit>
        <trans-unit id="2b55abf3573b260c179e3130856801dc205be5f3" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error. For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous) and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard.</source>
          <target state="translated">如果在CREATE和INDEX之间出现UNIQUE关键字,那么就不允许插入重复的索引条目。任何插入重复条目的尝试都会导致错误。对于唯一索引的目的,所有的NULL值都被认为与所有其他的NULL值不同,因此是唯一的。这是SQL-92标准的两种可能的解释之一(标准中的语言含糊不清),是PostgreSQL、MySQL、Firebird和Oracle遵循的解释。Informix和Microsoft SQL Server遵循标准的另一种解释。</target>
        </trans-unit>
        <trans-unit id="302753955d8021d9d751890a4a62678a7bd1dc4c" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果尝试执行UPDATE操作，但SQLite返回SQLITE_CONSTRAINT，则将冲突处理程序函数与作为第二个参数传递的&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT一起&lt;/a&gt;调用。这包括在较早调用冲突处理程序函数返回&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;之后尝试执行UPDATE操作的情况。</target>
        </trans-unit>
        <trans-unit id="40c8985574cc4136a7a40f15001ace597cd448e0" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果尝试执行UPDATE操作，但SQLite返回SQLITE_CONSTRAINT，则将冲突处理程序函数与作为第二个参数传递的&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT一起&lt;/a&gt;调用。这包括在较早调用冲突处理程序函数返回&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;之后尝试执行UPDATE操作的情况。</target>
        </trans-unit>
        <trans-unit id="751229ce68d5f9fb206ae67bb99718de4be423dd" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement does not have a WHERE clause, all rows in the table are modified by the UPDATE. Otherwise, the UPDATE affects only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression is true&lt;/a&gt;. It is not an error if the WHERE clause does not evaluate to true for any row in the table - this just means that the UPDATE statement affects zero rows.</source>
          <target state="translated">如果UPDATE语句没有WHERE子句，则UPDATE修改表中的所有行。否则，UPDATE仅影响那些WHERE子句&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式为true的行&lt;/a&gt;。如果表中的任何行的WHERE子句都不为true，这不是错误-这仅意味着UPDATE语句影响零行。</target>
        </trans-unit>
        <trans-unit id="074562fe8dfabc7ba122942fddf559f05fa48e31" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement has no ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine which are actually updated.</source>
          <target state="translated">如果UPDATE语句没有ORDER BY子句,那么在没有LIMIT子句的情况下,所有会被更新的行都会以任意的顺序组合在一起,然后再应用LIMIT和OFFSET子句来确定哪些行被实际更新。</target>
        </trans-unit>
        <trans-unit id="0ee1b94b95429e744f462704efa364a50f2413f6" translate="yes" xml:space="preserve">
          <source>If the WAL-index is implemented as a memory-mapped file and that file is read-only to the first thread to connect, then that thread creates an private heap-memory ersazt WAL-index and runs the recovery routine to populate that private WAL-index. The same data results, but it is held privately rather that being written into the public shared memory area.</source>
          <target state="translated">如果WAL-index是以内存映射文件的形式实现的,并且该文件对第一个连接的线程来说是只读的,那么该线程就会创建一个私有的堆内存ersazt WAL-index,并运行恢复例程来填充该私有的WAL-index。结果是相同的数据,但它是被私人持有的,而不是被写入公共共享内存区域。</target>
        </trans-unit>
        <trans-unit id="7648c2d70dafce18f6cb4ef634247a503d61eeca" translate="yes" xml:space="preserve">
          <source>If the WHERE clause evaluates to FALSE, then skip the steps that follow and continue to the next record.</source>
          <target state="translated">如果WHERE子句的值为FALSE,则跳过下面的步骤,继续下一条记录。</target>
        </trans-unit>
        <trans-unit id="37f61285fabc2a1caf8acf5c9c00c9ccc80b5f28" translate="yes" xml:space="preserve">
          <source>If the WHERE clause is not present, all records in the table are deleted. If a WHERE clause is supplied, then only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt; is true are deleted. Rows for which the expression is false or NULL are retained.</source>
          <target state="translated">如果WHERE子句不存在，则删除表中的所有记录。如果提供了WHERE子句，则仅删除WHERE子句&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式&lt;/a&gt;为true的那些行。保留表达式为false或NULL的行。</target>
        </trans-unit>
        <trans-unit id="7ecdfb78c909bf7386760f4b8a9af44a0acb2a2c" translate="yes" xml:space="preserve">
          <source>If the WHERE clause of a query contains an OR expression, then SQLite might use the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; strategy (also known as the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;). In this case there will be single top-level record for the search, with two sub-records, one for each index:</source>
          <target state="translated">如果查询的WHERE子句包含OR表达式，则SQLite可能会使用&lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&amp;ldquo;按联合进行OR&amp;rdquo;&lt;/a&gt;策略（也称为&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化&lt;/a&gt;）。在这种情况下，将有一个用于搜索的顶级记录，其中有两个子记录，每个索引一个：</target>
        </trans-unit>
        <trans-unit id="66d534e3ba541f4a816044bc7bb6de32d19f621c" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="translated">如果sqlite3_free_filename（Y）的Y参数不是NULL指针或以前从sqlite3_create_filename（）获取的指针，则可能发生堆损坏或段错误之类的不良情况。在调用sqlite3_free_filename（Y）之后，应再次使用值Y。这意味着，如果已使用Y调用了VFS的&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen（）&lt;/a&gt;方法，则在调用sqlite3_free_filename（Y）之前也应调用相应的[sqlite3_module.xClose（）方法。</target>
        </trans-unit>
        <trans-unit id="47f803875c1a08bebb885c914c92a3d72ff50a92" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="translated">如果sqlite3_free_filename（Y）的Y参数不是NULL指针或以前从sqlite3_create_filename（）获取的指针，则可能发生堆损坏或段错误之类的不良情况。在调用sqlite3_free_filename（Y）之后，应再次使用值Y。这意味着，如果已使用Y调用了VFS的&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen（）&lt;/a&gt;方法，则在调用sqlite3_free_filename（Y）之前也应调用相应的[sqlite3_module.xClose（）方法。</target>
        </trans-unit>
        <trans-unit id="e0ffc6e6c2f8710bdccd517328f86881951d2cb6" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should not be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="translated">如果sqlite3_free_filename（Y）的Y参数不是NULL指针或以前从sqlite3_create_filename（）获取的指针，则可能发生堆损坏或段错误之类的不良情况。在调用sqlite3_free_filename（Y）之后，不应再次使用值Y。这意味着，如果已使用Y调用了VFS的&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen（）&lt;/a&gt;方法，则在调用sqlite3_free_filename（Y）之前也应调用相应的[sqlite3_module.xClose（）方法。</target>
        </trans-unit>
        <trans-unit id="15d00867bdc20268b3f199466aa210a4d8a43f54" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should not be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="translated">如果sqlite3_free_filename（Y）的Y参数不是NULL指针或以前从sqlite3_create_filename（）获取的指针，则可能发生堆损坏或段错误之类的不良情况。在调用sqlite3_free_filename（Y）之后，不应再次使用值Y。这意味着，如果已使用Y调用了VFS的&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen（）&lt;/a&gt;方法，则在调用sqlite3_free_filename（Y）之前也应调用相应的[sqlite3_module.xClose（）方法。</target>
        </trans-unit>
        <trans-unit id="74877c4dea96c98f4b3c0b669711d0dd7770d2b9" translate="yes" xml:space="preserve">
          <source>If the _HAVE_SQLITE_CONFIG_H macro is defined then the SQLite source code will attempt to #include a file named &quot;config.h&quot;. The &quot;config.h&quot; file usually contains other configuration options, especially &quot;HAVE_</source>
          <target state="translated">如果定义了_HAVE_SQLITE_CONFIG_H宏,那么SQLite源代码将尝试#包含一个名为 &quot;config.h &quot;的文件。config.h &quot;文件通常包含其他配置选项,特别是 &quot;HAVE_SQLITE_CONFIG_H&quot;。</target>
        </trans-unit>
        <trans-unit id="558abcd908b311140ea78da82869118d13cb3c75" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">如果操作代码为&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt;，并且回调&lt;a href=&quot;#SQLITE_DENY&quot;&gt;函数&lt;/a&gt;返回SQLITE_IGNORE，则将&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt;语句构造为替换NULL值，以代替如果已返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;将被读取的表列。所述&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;返回可用于拒绝一个表中的各个列不可信的用户访问。当&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;引用一个表但没有从该表中提取任何列值时（例如，在诸如&amp;ldquo; SELECT count（*）FROM tab&amp;rdquo;之类的查询中），则对该表调用一次&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; Authorizer回调，其列名为是一个空字符串。如果操作代码为&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;并且回调&lt;a href=&quot;#SQLITE_DENY&quot;&gt;函数&lt;/a&gt;返回SQLITE_IGNORE，然后继续执行&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作，但&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;被禁用，并且所有行均被单独删除。</target>
        </trans-unit>
        <trans-unit id="551e501bb088fee5fee1641a8f77e7fc3633f5dd" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">如果操作代码为&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;，并且回调&lt;a href=&quot;c_deny&quot;&gt;函数&lt;/a&gt;返回SQLITE_IGNORE，则将&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt;语句构造为替换NULL值，以代替如果已返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;将被读取的表列。所述&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;返回可用于拒绝一个表中的各个列不可信的用户访问。当&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;引用一个表但没有从该表中提取任何列值时（例如，在诸如&amp;ldquo; SELECT count（*）FROM tab&amp;rdquo;之类的查询中），则对该表调用一次&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; Authorizer回调，其列名为是一个空字符串。如果操作代码为&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;并且回调&lt;a href=&quot;c_deny&quot;&gt;函数&lt;/a&gt;返回SQLITE_IGNORE，然后继续执行&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;操作，但&lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;被禁用，并且所有行均被单独删除。</target>
        </trans-unit>
        <trans-unit id="bd1e313db1648e3d841b56f1eba1325f9492fb26" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, consider disabling the unused capabilities with:</source>
          <target state="translated">如果应用程序不使用触发器或视图,请考虑用以下方法禁用未使用的功能。</target>
        </trans-unit>
        <trans-unit id="e48946c22fc154fe87cb537c121e425dbb9574d0" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, then disable the unused capabilities using:</source>
          <target state="translated">如果应用程序不使用触发器或视图,则使用以下方法禁用未使用的功能。</target>
        </trans-unit>
        <trans-unit id="f5d26d8716b0cdd9f988973fac2e73b815006603" translate="yes" xml:space="preserve">
          <source>If the application does use triggers or views, then use queries to scan the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table to verify that the triggers and views found there are expected, that there are no surplus triggers or views, existing triggers and views have not been tampered with, and that no existing ordinary tables have been replaced by malicious views.</source>
          <target state="translated">如果应用程序确实使用了触发器或视图，则使用查询来扫描&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;表，以验证找到的触发器和视图是预期的，没有多余的触发器或视图，现有的触发器和视图未被篡改以及没有现有的普通表已被恶意视图取代。</target>
        </trans-unit>
        <trans-unit id="0aef3c759a1be5c730a8586e6ee0c4911bb88637" translate="yes" xml:space="preserve">
          <source>If the application includes any &lt;a href=&quot;appfunc&quot;&gt;custom SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab#customvtab&quot;&gt;custom virtual tables&lt;/a&gt; that have side effects or that might leak privileged information, then the application should use one or more of the techniques below to prevent a maliciously crafted database schema from surreptitiously running those SQL functions and/or virtual tables for nefarious purposes:</source>
          <target state="translated">如果应用程序包含任何具有副作用或可能泄露特权信息的&lt;a href=&quot;appfunc&quot;&gt;自定义SQL函数&lt;/a&gt;或&lt;a href=&quot;vtab#customvtab&quot;&gt;自定义虚拟表&lt;/a&gt;，则该应用程序应使用以下一种或多种技术来防止恶意制作的数据库架构秘密运行这些SQL函数和/或出于邪恶目的的虚拟表：</target>
        </trans-unit>
        <trans-unit id="2469e0f7ca599347e4594642b1d8b0b3f0287081" translate="yes" xml:space="preserve">
          <source>If the application invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) on the database connection prior to closing, then the final checkpoint is still run but the WAL and WAL-index files are not deleted as they normally would be. This leaves the database in a state that allows other processes without write permission on the database, WAL, or WAL-index files to open the database read-only. If the WAL and WAL-index files are missing, then a process that lacks permission to create and initialize those files will not be able to open the database, unless the database is designated as immutable using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">如果应用程序在关闭之前在数据库连接上调用&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;），则最终检查点仍将运行，但不会像通常那样删除WAL和WAL-index文件。这使数据库处于一种状态，该状态允许其他对数据库，WAL或WAL-index文件没有写许可权的进程以只读方式打开数据库。如果缺少WAL和WAL-index文件，则除非创建了&lt;a href=&quot;uri#uriimmutable&quot;&gt;不可变查询参数&lt;/a&gt;将该数据库指定为不可变的，否则缺少创建和初始化那些文件的权限的进程将无法打开数据库。</target>
        </trans-unit>
        <trans-unit id="0623d9575995bdb9d6c267b0da83f975d16d83ea" translate="yes" xml:space="preserve">
          <source>If the application is designed to manage data in small pieces, then the database should never contain any large strings or BLOBs and hence element 1 above should not be a factor. If the database does contain large strings or BLOBs, they should be read using &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; and rows that contain the large strings or BLOBs should never be update by any means other than &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt;. Otherwise, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; routine will need to read the entire row into contiguous memory at some point, and that will involve at least one large memory allocation.</source>
          <target state="translated">如果应用程序旨在管理小块数据，则数据库不应包含任何大字符串或BLOB，因此，上面的元素1不应成为因素。如果数据库确实包含大字符串或BLOB，则应使用&lt;a href=&quot;c3ref/blob&quot;&gt;增量BLOB I / O&lt;/a&gt;读取它们，并且包含大字符串或BLOB的行不应通过&lt;a href=&quot;c3ref/blob&quot;&gt;增量BLOB I / O&lt;/a&gt;以外的任何其他方式进行更新。否则，&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;例程将需要在某一时刻将整行读取到连续内存中，这将涉及至少一个大内存分配。</target>
        </trans-unit>
        <trans-unit id="d0ebb1eaae39f6046644fb7a5c8e50db080966a3" translate="yes" xml:space="preserve">
          <source>If the application or host computer crashes before the transaction completes, then the rollback journal or write-ahead log contains information needed to restore the main database file to a consistent state. When a rollback journal or write-ahead log contains information necessary for recovering the state of the database, they are called a &quot;hot journal&quot; or &quot;hot WAL file&quot;. Hot journals and WAL files are only a factor during error recovery scenarios and so are uncommon, but they are part of the state of an SQLite database and so cannot be ignored. This document defines the format of a rollback journal and the write-ahead log file, but the focus is on the main database file.</source>
          <target state="translated">如果应用程序或主机在事务完成之前崩溃,那么回滚日志或写头日志包含了将主数据库文件恢复到一致状态所需的信息。当回滚日志或写前日志包含恢复数据库状态所需的信息时,它们被称为 &quot;热日志 &quot;或 &quot;热WAL文件&quot;。热日志和WAL文件只是在错误恢复场景中的一个因素,所以并不常见,但它们是SQLite数据库状态的一部分,所以不能忽视。本文档定义了回滚日志和写前日志文件的格式,但重点是主数据库文件。</target>
        </trans-unit>
        <trans-unit id="2a5d41f54973dce5874420b1200abe91d1314dc8" translate="yes" xml:space="preserve">
          <source>If the application uses &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side effects, then it is recommended to set the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on those SQL functions to prevent them from being used inside triggers and views. To illustrate the importance of this flag, consider an application that implements an SQL function &quot;send_money(...)&quot;. Without the SQLITE_DIRECTONLY flag, an attacker might be able to add a trigger or view that uses that custom function, then trick a high-privilege application to run an otherwise harmless query that invokes that malicious trigger or view. The SQLITE_DIRECTONLY flag prevents the attack by requiring the &quot;send_money()&quot; function to be invoked directly by the application, rather than indirectly through a trigger or view.</source>
          <target state="translated">如果应用程序使用具有副作用的应用&lt;a href=&quot;c3ref/create_function&quot;&gt;程序定义的SQL函数&lt;/a&gt;，则建议在这些SQL函数上设置&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志，以防止在触发器和视图中使用它们。为了说明此标志的重要性，请考虑实现SQL函数&amp;ldquo; send_money（...）&amp;rdquo;的应用程序。没有SQLITE_DIRECTONLY标志，攻击者可能能够添加使用该自定义功能的触发器或视图，然后诱使高特权应用程序运行调用该恶意触发器或视图的否则无害的查询。 SQLITE_DIRECTONLY标志通过要求应用程序直接调用&amp;ldquo; send_money（）&amp;rdquo;函数而不是通过触发器或视图间接调用来防止攻击。</target>
        </trans-unit>
        <trans-unit id="d6f9cd1b9ea5044b899607d0f8509b7399b72066" translate="yes" xml:space="preserve">
          <source>If the application wanted to keep all content in memory, it could continue reading and parsing the other pages using a background thread after drawing the first page. Or, since reading from SQLite is so efficient, the application might instead choose to reduce its memory footprint and only keep a single slide in memory at a time. Or maybe it keeps the current slide and the next slide in memory, to facility rapid transitions to the next slide.</source>
          <target state="translated">如果应用程序想将所有内容保留在内存中,它可以在绘制第一页后,使用后台线程继续读取和解析其他页面。或者,由于从SQLite中读取的效率很高,应用程序可能会选择减少其内存占用,一次只在内存中保留一张幻灯片。或者,它可能在内存中保留当前幻灯片和下一张幻灯片,以便快速过渡到下一张幻灯片。</target>
        </trans-unit>
        <trans-unit id="9908f3b7f0fcd38e518a64cda27a8bcf7af02eae" translate="yes" xml:space="preserve">
          <source>If the argument</source>
          <target state="translated">如果争论</target>
        </trans-unit>
        <trans-unit id="8569a113bc3212a8fdd578bf6c990f890a161761" translate="yes" xml:space="preserve">
          <source>If the argument N is positive then the suggested cache size is set to N. If the argument N is negative, then the number of cache pages is adjusted to be a number of pages that would use approximately abs(N*1024) bytes of memory based on the current page size. SQLite remembers the number of pages in the page cache, not the amount of memory used. So if you set the cache size using a negative number and subsequently change the page size (using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command) then the maximum amount of cache memory will go up or down in proportion to the change in page size.</source>
          <target state="translated">如果参数N为正，则建议的缓存大小设置为N。如果参数N为负，则将缓存页数调整为将使用大约abs（N * 1024）字节内存的页数。根据当前页面大小。SQLite会记住页面缓存中的页面数，而不是所使用的内存量。因此，如果您使用负数设置高速缓存大小，然后更改页面大小（使用&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt;命令），则最大高速缓存内存将与页面大小的变化成比例地增加或减少。</target>
        </trans-unit>
        <trans-unit id="333007bde9d13022c1e70f3f252829b77ea3504a" translate="yes" xml:space="preserve">
          <source>If the argument N is zero then the soft heap limit is disabled.</source>
          <target state="translated">如果参数N为0,那么软堆限制将被禁用。</target>
        </trans-unit>
        <trans-unit id="0910062f14fed63da9341471516f0b8c2feb398e" translate="yes" xml:space="preserve">
          <source>If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates.</source>
          <target state="translated">如果json(X)的参数X包含有重复标签的JSON对象,那么是否保留重复的标签是没有定义的。当前的实现保留了重复的内容。然而,未来对该例程的增强可能会选择默默地删除重复的对象。</target>
        </trans-unit>
        <trans-unit id="6f833aefc23dc66bc8a11fd873780dad93c32799" translate="yes" xml:space="preserve">
          <source>If the argument is an empty string then the authorizer is disabled. If the argument is omitted, then the current authorizer is returned.</source>
          <target state="translated">如果参数是空字符串,那么授权器将被禁用,如果参数被省略,则返回当前授权器。如果参数被省略,则返回当前的授权者。</target>
        </trans-unit>
        <trans-unit id="aac72e2d439c55d86892749d71b2d6fa2195d5f5" translate="yes" xml:space="preserve">
          <source>If the argument to &quot;.read&quot; begins with the &quot;|&quot; character, then instead of opening the argument as a file, it runs the argument (without the leading &quot;|&quot;) as a command, then uses the output of that command as its input. Thus, if you have a script that generates SQL, you can execute that SQL directly using a command similar to the following:</source>
          <target state="translated">如果&quot;.read &quot;的参数以&quot;|&quot;字符开头,那么它就不会将参数作为文件打开,而是将参数(没有前导的&quot;|&quot;)作为命令运行,然后将该命令的输出作为输入。因此,如果你有一个生成SQL的脚本,你可以使用类似下面的命令直接执行该SQL。</target>
        </trans-unit>
        <trans-unit id="db2e11d8e987617a2ede3ca5cb77cc0207ab30da" translate="yes" xml:space="preserve">
          <source>If the argument to %Q is a null pointer then the output is an unquoted &quot;NULL&quot;. In other words, a null pointer generates an SQL NULL, and a non-null pointer generates a valid SQL string literal. If the argument to %q is a null pointer then no output is generated. Thus a null-pointer to %q is the same as an empty string.</source>
          <target state="translated">如果%Q的参数是一个空指针,那么输出的是一个未引用的 &quot;NULL&quot;。换句话说,null指针会生成一个SQL NULL,而非null指针会生成一个有效的SQL字符串文字。如果%q的参数是一个空指针,那么就不会产生输出。因此,指向%q的空指针和空字符串是一样的。</target>
        </trans-unit>
        <trans-unit id="34bfefe0d198d1d0315cf64a45912620ff3af0d6" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; is negative N, that means to use approximately -1024*N bytes of memory for the page cache regardless of the page size.</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt;的参数为负N，则意味着无论页面大小如何，都将大约-1024 * N字节的内存用于页面缓存。</target>
        </trans-unit>
        <trans-unit id="ad1260c6e1a01baa74d5f905fe5850603affd484" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or sqlite3_mutex_leave() is a NULL pointer, then all three routines behave as no-ops.</source>
          <target state="translated">如果sqlite3_mutex_enter()、sqlite3_mutex_try()或sqlite3_mutex_leave()的参数是一个NULL指针,那么这三个例程的行为都是no-ops。</target>
        </trans-unit>
        <trans-unit id="0142caf16fb3155af68268c72b44fbf8e770bbff" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_held() is a NULL pointer then the routine should return 1. This seems counter-intuitive since clearly the mutex cannot be held if it does not exist. But the reason the mutex does not exist is because the build is not using mutexes. And we do not want the assert() containing the call to sqlite3_mutex_held() to fail, so a non-zero return is the appropriate thing to do. The sqlite3_mutex_notheld() interface should also return 1 when given a NULL pointer.</source>
          <target state="translated">如果sqlite3_mutex_held()的参数是一个NULL指针,那么这个例程应该返回1。这似乎有悖于直觉,因为很明显,如果mutex不存在,它就不能被持有。但是,mutex不存在的原因是因为构建过程中没有使用mutexes。而且我们不希望包含调用sqlite3_mutex_held()的assert()失败,所以非零返回是合适的做法。sqlite3_mutex_notheld()接口在给定一个NULL指针时也应该返回1。</target>
        </trans-unit>
        <trans-unit id="a14ce7fd473c10953375f9ccbf76e06b28005ef4" translate="yes" xml:space="preserve">
          <source>If the array variable name is omitted or is the empty string, then the value of each column is stored in a variable with the same name as the column itself. For example:</source>
          <target state="translated">如果数组变量名被省略或者是空字符串,那么每一列的值就会被存储在一个与该列本身同名的变量中。例如</target>
        </trans-unit>
        <trans-unit id="ac696fda1c1264eced84b7c7d2919bb500892965" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果由于某些其他违反约束（例如NOT NOT NULL或UNIQUE）的原因而导致插入行的尝试失败，则将第二个参数设置为&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;来调用冲突处理程序函数。这包括由于先前对冲突处理程序函数的调用返回&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;而重新尝试INSERT操作的情况。</target>
        </trans-unit>
        <trans-unit id="00b4296a5ab760c82790fc716c15427ea1f6520d" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果由于某些其他违反约束（例如NOT NOT NULL或UNIQUE）的原因而导致插入行的尝试失败，则将第二个参数设置为&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;来调用冲突处理程序函数。这包括由于先前对冲突处理程序函数的调用返回&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;而重新尝试INSERT操作的情况。</target>
        </trans-unit>
        <trans-unit id="1a0b7bf9240c877d42c55de96b224187eca54a50" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">如果由于数据库已经包含具有相同主键值的行而导致插入行的尝试失败，则将第二个参数设置为&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;来调用冲突处理程序函数。</target>
        </trans-unit>
        <trans-unit id="86e563d45d385632baebf3e72388be8c4af6aec3" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">如果由于数据库已经包含具有相同主键值的行而导致插入行的尝试失败，则将第二个参数设置为&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;来调用冲突处理程序函数。</target>
        </trans-unit>
        <trans-unit id="3629ea18c991de1dc5f5b9e0680718c68964bd44" translate="yes" xml:space="preserve">
          <source>If the bClear argument is non-zero, then the auxiliary data is cleared (set to NULL) before this function returns. In this case the xDelete, if any, is not invoked.</source>
          <target state="translated">如果bClear参数是非零,那么在该函数返回之前,辅助数据被清除(设置为NULL)。在这种情况下,如果有xDelete,则不会被调用。</target>
        </trans-unit>
        <trans-unit id="85be6aa821286c3a809817d29ac82866a6650696" translate="yes" xml:space="preserve">
          <source>If the backup process is restarted frequently enough it may never run to completion and the backupDb() function may never return.</source>
          <target state="translated">如果备份进程频繁重启,可能永远不会运行完成,backupDb()函数可能永远不会返回。</target>
        </trans-unit>
        <trans-unit id="ed3ecd64439c51685da70c45077d54474b903f89" translate="yes" xml:space="preserve">
          <source>If the base expression is NULL then the result of the CASE is always the result of evaluating the ELSE expression if it exists, or NULL if it does not.</source>
          <target state="translated">如果基础表达式为NULL,那么CASE的结果总是在ELSE表达式存在的情况下评估ELSE表达式的结果,如果不存在,则为NULL。</target>
        </trans-unit>
        <trans-unit id="8a427aa0dc34d2b046c1ad51ad7573c594257eb3" translate="yes" xml:space="preserve">
          <source>If the base window has an ORDER BY clause, it is copied into the new window. In this case the new window must not specify an ORDER BY clause. If the base window has no ORDER BY clause, one may be specified as part of the new window definition.</source>
          <target state="translated">如果基本窗口有一个ORDER BY子句,它将被复制到新窗口中。在这种情况下,新窗口必须不指定 ORDER BY 子句。如果基本窗口没有 ORDER BY 子句,则可以指定一个子句作为新窗口定义的一部分。</target>
        </trans-unit>
        <trans-unit id="119dee4cbf58f5993be5ffddf2563e1e23c3d8e2" translate="yes" xml:space="preserve">
          <source>If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed. If an error occurs while committing the transaction, an error code is returned and the transaction rolled back.</source>
          <target state="translated">如果被关闭的blob句柄被打开用于读写访问,并且如果数据库处于自动提交模式,并且没有其他打开的读写blob句柄或活动的写语句,则当前事务被提交。如果提交事务时发生错误,则返回错误代码,事务回滚。</target>
        </trans-unit>
        <trans-unit id="a888511d0d42c7a009b52c11f52254e39a8e8777" translate="yes" xml:space="preserve">
          <source>If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.</source>
          <target state="translated">如果被阻塞的连接试图在共享缓存表上获得写锁,而当前有多个其他连接在同一张表上持有读锁,那么SQLite会任意选择其他连接中的一个作为阻塞连接。</target>
        </trans-unit>
        <trans-unit id="b15e015a6e8222ac8277a814fcfbbc84b5b7b2fa" translate="yes" xml:space="preserve">
          <source>If the branch instruction that implements the &quot;c!=0&quot; test on line 58 is changed into a no-op, then the while-loop will loop forever and the test suite will fail with a time-out. But if that branch is changed into an unconditional jump, then the hash function will always return 0. The problem is that 0 is a valid hash. A hash function that always returns 0 still works in the sense that SQLite still always gets the correct answer. The table-name hash table degenerates into a linked-list and so the table-name lookups that occur while parsing SQL statements might be a little slower, but the end result will be the same.</source>
          <target state="translated">如果将第58行实现 &quot;c!=0 &quot;测试的分支指令改为无条件跳转,那么while-loop将永远循环,测试套件将超时失败。但如果将该分支改为无条件跳转,那么哈希函数将永远返回0。问题是,0是一个有效的哈希值。一个总是返回0的哈希函数仍然有效,在这个意义上,SQLite仍然总是得到正确的答案。表名哈希表会退化成一个链接列表,因此在解析SQL语句时发生的表名查找可能会慢一点,但最终结果是一样的。</target>
        </trans-unit>
        <trans-unit id="d10a175cfd1fe16985e295daacc2dcfb3f2982ad" translate="yes" xml:space="preserve">
          <source>If the buffer contains a patchset, then all prior calls to this function on the same changegroup object must also have specified patchsets. Or, if the buffer contains a changeset, so must have the earlier calls to this function. Otherwise, SQLITE_ERROR is returned and no changes are added to the changegroup.</source>
          <target state="translated">如果缓冲区包含一个补丁集,那么之前对同一changegroup对象的所有函数调用也必须有指定的补丁集。或者,如果缓冲区包含一个变化集,那么必须有之前对这个函数的调用。否则,将返回SQLITE_ERROR,并且没有任何变化被添加到changegroup中。</target>
        </trans-unit>
        <trans-unit id="5cba5e39badf94f78fab97af6a07c73e6243cd28" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">如果忙回调为NULL，则在遇到锁定时立即返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果忙回调不为NULL，则可以使用两个参数来调用该回调。</target>
        </trans-unit>
        <trans-unit id="5b0bd17ec528127c481fd60daa34e2af13ea7150" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">如果忙回调为NULL，则在遇到锁定时立即返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果忙回调不为NULL，则可以使用两个参数来调用该回调。</target>
        </trans-unit>
        <trans-unit id="afcbf1f3e790adb1bb6040c89a071eb5f4f5a2b5" translate="yes" xml:space="preserve">
          <source>If the busy method is invoked without an argument, the name of the callback procedure last set by the busy method is returned. If no callback procedure has been set, an empty string is returned.</source>
          <target state="translated">如果在没有参数的情况下调用了busy方法,则返回busy方法最后设置的回调过程的名称,如果没有设置回调过程,则返回一个空字符串。如果没有设置回调过程,则返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="85f5b0357119cb8e1c6a774de7f6ae30085546fa" translate="yes" xml:space="preserve">
          <source>If the cache validate procedure prescribed by H35040 is required and does not prove that the</source>
          <target state="translated">如果需要H35040规定的缓存验证程序,并且不能证明</target>
        </trans-unit>
        <trans-unit id="854ac2efa118a1d9433a97bc97dd8176f442561c" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35140 fails (due to an IO error or similar), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35140所要求的对xAccess()的调用失败(由于IO错误或类似的原因),那么SQLite应放弃打开的尝试。</target>
        </trans-unit>
        <trans-unit id="1c9becc9db0bbc14b6323875b3f39aa5c2a244e7" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35490所要求的对xAccess()的调用失败(由于IO或其他内部VFS错误),那么SQLite应放弃打开某个</target>
        </trans-unit>
        <trans-unit id="7bd0a091025aae3680b1db643d16d28c98cc6e9b" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 reveals that the journal file is no longer present in the file system, then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果对H35490要求的xAccess()的调用显示文件系统中已经不存在日志文件,那么SQLite应放弃打开一个</target>
        </trans-unit>
        <trans-unit id="3c3c8cf623e8c157f82c9c8bd8de3ce49f6292d0" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35160所要求的对xCheckReservedLock()的调用失败(由于IO或其他内部VFS错误),那么SQLite应放弃尝试打开一个</target>
        </trans-unit>
        <trans-unit id="527cca95e4fd8fdc84a2ca6b5f00a7e854482d28" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 indicates that some other</source>
          <target state="translated">如果H35160所要求的对xCheckReservedLock()的调用表明,其他一些</target>
        </trans-unit>
        <trans-unit id="b6b7e886a7c9cbfdadb1dc23e73d315693f496ee" translate="yes" xml:space="preserve">
          <source>If the call to xDelete() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35450所要求的对xDelete()的调用失败(由于IO或其他内部VFS错误),那么SQLite应放弃尝试打开一个</target>
        </trans-unit>
        <trans-unit id="5af5d373c56bb9dcd62ea184e1e76437bf4a9601" translate="yes" xml:space="preserve">
          <source>If the call to xFileSize() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35450要求的对xFileSize()的调用失败(由于IO或其他内部VFS错误),那么SQLite将放弃打开一个</target>
        </trans-unit>
        <trans-unit id="2a548d9a4e673897d73f6b03d7eb848a11645c48" translate="yes" xml:space="preserve">
          <source>If the call to xOpen() required by H35440 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35440所要求的对xOpen()的调用失败(由于IO或其他内部VFS错误),那么SQLite应放弃打开某个</target>
        </trans-unit>
        <trans-unit id="d1ec650a833c11cb6d8b04d5f0bcc10f45ba6aa9" translate="yes" xml:space="preserve">
          <source>If the callback function returns any value other than SQLITE_OK, the query is abandoned and the xQueryPhrase function returns immediately. If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK. Otherwise, the error code is propagated upwards.</source>
          <target state="translated">如果回调函数返回SQLITE_OK以外的任何值,则放弃查询,xQueryPhrase函数立即返回。如果返回的值是SQLITE_DONE,xQueryPhrase返回SQLITE_OK。否则,错误代码会向上传播。</target>
        </trans-unit>
        <trans-unit id="e7031b92fb19c04c6b57152812c2809849a4f000" translate="yes" xml:space="preserve">
          <source>If the callback function to &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.</source>
          <target state="translated">如果&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的回调函数返回非零值，则sqlite3_exec（）将返回SQLITE_ABORT。</target>
        </trans-unit>
        <trans-unit id="4e73b6d395789a1b49c6f60fbafb266cb7180446" translate="yes" xml:space="preserve">
          <source>If the case_sensitive_like pragma is enabled as follows:</source>
          <target state="translated">如果启用case_sensitive_like pragma,如下所示。</target>
        </trans-unit>
        <trans-unit id="a386306ee9feeed2835e0b935d9f3858fdfe7719" translate="yes" xml:space="preserve">
          <source>If the change to table X also affects other tables or indexes or triggers are views within schema, then run &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements to modify those other tables indexes and views too. For example, if the name of a column changes, all FOREIGN KEY constraints, triggers, indexes, and views that refer to that column must be modified.</source>
          <target state="translated">如果对表X的更改也影响其他表或索引，或者触发器是架构内的视图，则运行&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句也可以修改其他表的索引和视图。例如，如果列名更改，则必须修改所有引用该列的FOREIGN KEY约束，触发器，索引和视图。</target>
        </trans-unit>
        <trans-unit id="4f32e1ca273326c7edb692e7f8fb897873c86b6d" translate="yes" xml:space="preserve">
          <source>If the columns of your result set are named by AS clauses, then SQLite is guaranteed to use the identifier to the right of the AS keyword as the column name. If the result set does not use an AS clause, then SQLite is free to name the column anything it wants. See the &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; documentation for further information.</source>
          <target state="translated">如果结果集的列由AS子句命名，则SQLite保证使用AS关键字右侧的标识符作为列名。如果结果集不使用AS子句，则SQLite可以随意为其命名该列。有关更多信息，请参见&lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="2f6ac289e0c179705fc9860a15b31aba8aa6dfe9" translate="yes" xml:space="preserve">
          <source>If the compression method for the record is either 0 or 8 (see below), then the uncompressed data associated with the zip file entry. Or, if the compression method is not 0 or 8, this column contains a NULL value.</source>
          <target state="translated">如果记录的压缩方法是0或8(见下文),那么与压缩文件条目相关的未压缩数据。或者,如果压缩方法不是0或8,这一列包含一个NULL值。</target>
        </trans-unit>
        <trans-unit id="6d7fff8b9b0e80fbe64f6ffbfb79c99106754efa" translate="yes" xml:space="preserve">
          <source>If the content is compressed, then such an &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; database is &lt;a href=&quot;affcase1#smaller&quot;&gt;the same size&lt;/a&gt; (&amp;plusmn;1%) as an equivalent ZIP archive, and it has the advantage of being able to update individual &quot;files&quot; without rewriting the entire document.</source>
          <target state="translated">如果内容是压缩的，则此类&lt;a href=&quot;sqlar&quot;&gt;SQLite存档&lt;/a&gt;数据库&lt;a href=&quot;affcase1#smaller&quot;&gt;的大小&lt;/a&gt;与等效的ZIP存档大小相同（&amp;plusmn;1％），并且具有无需更新整个文档即可更新单个&amp;ldquo;文件&amp;rdquo;的优点。</target>
        </trans-unit>
        <trans-unit id="07d4949504c6ebefef1a44e834288b1c17ef2c29" translate="yes" xml:space="preserve">
          <source>If the content of a subquery might need to be visited more than once, then the use of a co-routine is undesirable, as the co-routine would then have to compute the data more than once. And if the subquery cannot be flattened, that means the subquery must be manifested into a transient table.</source>
          <target state="translated">如果一个子查询的内容可能需要访问不止一次,那么使用协程是不可取的,因为协程就必须不止一次地计算数据。而如果子查询不能被扁平化,那就意味着子查询必须表现为一个瞬时表。</target>
        </trans-unit>
        <trans-unit id="c4de8e7a63ccfd940999297f77703800e91edb69" translate="yes" xml:space="preserve">
          <source>If the content option is used along with the languageid option, then the named languageid column must exist in the content= table (subject to the usual rules - if a query never needs to read the content table then this restriction does not apply).</source>
          <target state="translated">如果content选项和languageid选项一起使用,那么命名的languageid列必须存在于content=表中(受制于通常的规则--如果一个查询从来不需要读取content表,那么这个限制就不适用)。</target>
        </trans-unit>
        <trans-unit id="69c4116a662051610d482a3763e629de02d91b0e" translate="yes" xml:space="preserve">
          <source>If the coroutine that is launched by this instruction ends with &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; or &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; then continue to the next instruction. But if the coroutine launched by this instruction ends with &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;, then jump to P2 rather than continuing with the next instruction.</source>
          <target state="translated">如果此指令启动的协程以&lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;或&lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt;结尾，则继续执行下一条指令。但是，如果此指令启动的协程以&lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine结尾&lt;/a&gt;，则跳至P2而不是继续执行下一条指令。</target>
        </trans-unit>
        <trans-unit id="d90236a26f30bb94fe93491f2ee7d8229a45dcb7" translate="yes" xml:space="preserve">
          <source>If the covering index is used for the scan, the &quot;fruit&quot; column will appear naturally in the correct order, but when there are two or more rows with the same fruit, the price might be out of order. When this occurs, SQLite does many small sorts, one sort for each distinct value of fruit, rather than one large sort. Figure 22 below illustrates the concept.</source>
          <target state="translated">如果使用覆盖索引进行扫描,&quot;水果 &quot;列自然会以正确的顺序出现,但当有两行或多行有相同的水果时,价格可能会失序。当出现这种情况时,SQLite会做很多小的排序,对每一个不同的水果值做一个排序,而不是做一个大的排序。下图22说明了这个概念。</target>
        </trans-unit>
        <trans-unit id="9c6f80849dfd69b57ae6014cb409620e08c9388e" translate="yes" xml:space="preserve">
          <source>If the current statement is not inside an explicit transaction (a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; block), then an implicit transaction is committed as soon as the statement has finished executing. In this case deferred constraints behave the same as immediate constraints.</source>
          <target state="translated">如果当前语句不在显式事务（&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;块）内，则在语句执行完成后立即提交隐式事务。在这种情况下，延迟约束的行为与立即约束相同。</target>
        </trans-unit>
        <trans-unit id="392488489ea8e86894e96e98c9d528e435e44b99" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.8.2 or greater, the estimatedRows field may be set to an estimate of the number of rows returned by the proposed query plan. If this value is not explicitly set, the default estimate of 25 rows is used.</source>
          <target state="translated">如果SQLite的当前版本是3.8.2或更高版本,可以将估计行数字段设置为建议的查询计划返回的行数。如果没有明确设置这个值,则使用默认的25行估计值。</target>
        </trans-unit>
        <trans-unit id="d14a622439a8b842f388bc686b9c68da678476ab" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.9.0 or greater, the idxFlags field may be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return only zero or one rows given the input constraints. Additional bits of the idxFlags field might be understood in later versions of SQLite.</source>
          <target state="translated">如果当前版本的SQLite是3.9.0或更高版本,idxFlags字段可以设置为SQLITE_INDEX_SCAN_UNIQUE,以表示给定的输入约束条件下,虚拟表将只返回0或1条记录。idxFlags字段的其他位可能在SQLite的以后版本中被理解。</target>
        </trans-unit>
        <trans-unit id="7ead26894e06c87e567f28556505a47feb41761a" translate="yes" xml:space="preserve">
          <source>If the cursor P1 is already opened on an ephemeral table, the table is cleared (all content is erased).</source>
          <target state="translated">如果光标P1已经在一个历时表上打开,那么该表将被清除(所有内容被清除)。</target>
        </trans-unit>
        <trans-unit id="4895543ee94b53e62d72914bc8c347747fb66179" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">如果使用OPFLAG_SEEKEQ标志打开了光标P1，则此操作码将始终停留在等于键的记录上，否则立即跳转到P2。当游标为OPFLAG_SEEKEQ时，此操作码后必须跟具有相同参数的&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;操作码。该&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;如果这个操作码成功操作码会被跳过，但&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;操作码将在后续的循环迭代中使用。</target>
        </trans-unit>
        <trans-unit id="77bb6e8019c4e57a173df053565a659dee60ffeb" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">如果使用OPFLAG_SEEKEQ标志打开了光标P1，则此操作码将始终停留在等于键的记录上，否则立即跳转到P2。当游标为OPFLAG_SEEKEQ时，此操作码后必须是具有相同参数的&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;操作码。该&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;如果这个操作码成功操作码会被跳过，但&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;操作码将在后续的循环迭代中使用。</target>
        </trans-unit>
        <trans-unit id="6654fbd1f580e1606c2cb7ef134e0a96bcfe4a7c" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="translated">如果使用OPFLAG_SEEKEQ标志打开了光标P1，则此操作码将落在与键完全匹配的记录上，否则将导致跳转到P2。当游标为OPFLAG_SEEKEQ时，此操作码后必须跟具有相同参数的&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;操作码。该&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;如果这个操作码成功操作码会被跳过，但&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;操作码将在后续的循环迭代中使用。 OPFLAG_SEEKEQ标志是对btree层的提示，表明这是一个相等搜索。</target>
        </trans-unit>
        <trans-unit id="a5226a8f5df78028a70c1168477ceda8c9db8705" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="translated">如果使用OPFLAG_SEEKEQ标志打开了光标P1，则此操作码将落在与键完全匹配的记录上，否则将导致跳转到P2。当游标为OPFLAG_SEEKEQ时，此操作码后必须跟具有相同参数的&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;操作码。该&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;如果这个操作码成功操作码会被跳过，但&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;操作码将在后续的循环迭代中使用。OPFLAG_SEEKEQ标志是对btree层的提示，表明这是一个相等搜索。</target>
        </trans-unit>
        <trans-unit id="dd3c36932aae97dabbc79dda8de195dddbecf67b" translate="yes" xml:space="preserve">
          <source>If the cursor ends up past the target row (indicating the the target row does not exist in the btree) then jump to SeekOP.P2.</source>
          <target state="translated">如果光标经过目标行(表明目标行在btree中不存在),则跳转到SeekOP.P2。</target>
        </trans-unit>
        <trans-unit id="ab4bfe1f95f30885f0c414ba75caba527ba256bd" translate="yes" xml:space="preserve">
          <source>If the cursor is successfully moved to the target row by 0 or more sqlite3BtreeNext() calls, then jump to This.P2, which will land just past the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode that follows the &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.</source>
          <target state="translated">如果通过0次或多次sqlite3BtreeNext（）调用成功将光标移动到目标行，则跳至This.P2，它将登陆到SeekGE之后的&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;操作码&lt;a href=&quot;opcode#SeekGE&quot;&gt;之后&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c34174e24836739ad2de38f328a95e6bd8361fd" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">如果数据库连接与未完成的准备语句或未完成的sqlite3_backup对象相关联，则sqlite3_close（）将使数据库连接保持打开状态并返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果使用未完成的准备语句和/或未完成的sqlite3_backups调用sqlite3_close_v2（），则数据库连接将变为无法使用的&amp;ldquo;僵尸&amp;rdquo;，当最后一个准备好的语句完成或最后一个sqlite3_backup完成时，数据库连接将被自动释放。 sqlite3_close_v2（）接口旨在用于垃圾收集的宿主语言，并且调用析构函数的顺序是任意的。</target>
        </trans-unit>
        <trans-unit id="6a86fbb2e17cc862733085ba2da83a55d59e3eb0" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">如果数据库连接与未完成的准备语句或未完成的sqlite3_backup对象相关联，则sqlite3_close（）将使数据库连接保持打开状态并返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果使用未完成的准备语句和/或未完成的sqlite3_backups调用sqlite3_close_v2（），则数据库连接将变为无法使用的&amp;ldquo;僵尸&amp;rdquo;，当最后一个准备好的语句完成或最后一个sqlite3_backup完成时，数据库连接将被自动释放。 sqlite3_close_v2（）接口旨在用于垃圾收集的宿主语言，并且调用析构函数的顺序是任意的。</target>
        </trans-unit>
        <trans-unit id="fb1362fb98673ef522db1a6a32001f7f2b59540f" translate="yes" xml:space="preserve">
          <source>If the database connection is newly opened, make sure it has read the database schema by preparing then discarding some query against the database, or calling sqlite3_table_column_metadata(), ignoring any errors. This step is only necessary if the application desires to keep the database in WAL mode after the reset if it was in WAL mode before the reset.</source>
          <target state="translated">如果数据库连接是新打开的,通过准备然后丢弃一些针对数据库的查询,或者调用sqlite3_table_column_metadata(),确保它已经读取了数据库模式,忽略任何错误。只有当应用程序希望在重置后将数据库保持在WAL模式时,如果数据库在重置前处于WAL模式,才需要这一步。</target>
        </trans-unit>
        <trans-unit id="1e3e236bab50bdd2cf247016c21c0818a0ad15df" translate="yes" xml:space="preserve">
          <source>If the database file has aliases (hard or soft links) and the file is opened by a different alias than the one used to create the journal, then the journal will not be found. To avoid this problem, you should not create links to SQLite database files.</source>
          <target state="translated">如果数据库文件有别名(硬链接或软链接),而打开该文件的别名与创建日记的别名不同,那么将找不到日记。为了避免这个问题,你不应该创建SQLite数据库文件的链接。</target>
        </trans-unit>
        <trans-unit id="b5462897225632e86adf2dda0274ca8b010e12de" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">如果数据库模式发生更改，则&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;会自动重新编译SQL语句并尝试再次运行，而不是像通常那样返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;。在sqlite3_step（）放弃并返回错误之前，将进行多达&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY次&lt;/a&gt;重试。</target>
        </trans-unit>
        <trans-unit id="589bc4cd8d0a621a42dc8c997193ae6380bd4790" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">如果数据库模式发生更改，则&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;会自动重新编译SQL语句并尝试再次运行，而不是像通常那样返回&lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;。在sqlite3_step（）放弃并返回错误之前，将进行多达&lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY次&lt;/a&gt;重试。</target>
        </trans-unit>
        <trans-unit id="66c44f3be0c0d8ad85eed52612c2f2c579f73474" translate="yes" xml:space="preserve">
          <source>If the database schema contains foreign key errors that require looking at more than one table definition to identify, then those errors are not detected when the tables are created. Instead, such errors prevent the application from preparing SQL statements that modify the content of the child or parent tables in ways that use the foreign keys. Errors reported when content is changed are &quot;DML errors&quot; and errors reported when the schema is changed are &quot;DDL errors&quot;. So, in other words, misconfigured foreign key constraints that require looking at both the child and parent are DML errors. The English language error message for foreign key DML errors is usually &quot;foreign key mismatch&quot; but can also be &quot;no such table&quot; if the parent table does not exist. Foreign key DML errors are reported if:</source>
          <target state="translated">如果数据库模式包含需要查看多个表定义才能识别的外键错误,那么在创建表时不会检测到这些错误。相反,这类错误会阻止应用程序准备以使用外键的方式修改子表或父表内容的SQL语句。当内容被更改时报告的错误是 &quot;DML错误&quot;,而当模式被更改时报告的错误是 &quot;DDL错误&quot;。所以,换句话说,配置错误的外键约束需要同时查看子表和父表,是DML错误。外键DML错误的英文错误信息通常是 &quot;foreign key mismatch&quot;,但如果父表不存在,也可以是 &quot;no such table&quot;。如果出现以下情况,则会报告外键DML错误。</target>
        </trans-unit>
        <trans-unit id="8302ec0e25c3b92c0aa14eef9d1503f836a94585" translate="yes" xml:space="preserve">
          <source>If the declared type contains the string &quot;INT&quot; then it is assigned INTEGER affinity.</source>
          <target state="translated">如果声明的类型包含字符串 &quot;INT&quot;,那么它被分配给INTEGER亲和力。</target>
        </trans-unit>
        <trans-unit id="9bb6b49e698e48cc0bb2b3442b91fd7f7d66dd5e" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains any of the strings &quot;REAL&quot;, &quot;FLOA&quot;, or &quot;DOUB&quot; then the column has REAL affinity.</source>
          <target state="translated">如果一个列的声明类型包含 &quot;REAL&quot;、&quot;FLOA &quot;或 &quot;DOUB &quot;中的任何一个字符串,那么这个列就具有REAL亲和力。</target>
        </trans-unit>
        <trans-unit id="f28b903cf6eed2606240e84c579a7053774d3dee" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains the string &quot;BLOB&quot; or if no type is specified then the column has affinity BLOB.</source>
          <target state="translated">如果一个列的声明类型包含字符串 &quot;BLOB&quot;,或者如果没有指定类型,那么该列具有亲和力BLOB。</target>
        </trans-unit>
        <trans-unit id="ee88c791daf6e99faa6560e540692aa5bc2c800f" translate="yes" xml:space="preserve">
          <source>If the declared type of the column contains any of the strings &quot;CHAR&quot;, &quot;CLOB&quot;, or &quot;TEXT&quot; then that column has TEXT affinity. Notice that the type VARCHAR contains the string &quot;CHAR&quot; and is thus assigned TEXT affinity.</source>
          <target state="translated">如果列的声明类型包含 &quot;CHAR&quot;、&quot;CLOB &quot;或 &quot;TEXT &quot;中的任何一个字符串,那么该列就具有TEXT亲缘性。请注意,类型VARCHAR包含字符串 &quot;CHAR&quot;,因此被赋予TEXT亲和性。</target>
        </trans-unit>
        <trans-unit id="de0d2c280ce73b7cd6a79e09cb8d9ab5ce1c8380" translate="yes" xml:space="preserve">
          <source>If the default entry point &quot;sqlite3_extension_init&quot; is not present in the loadable extension, also try an entry point &quot;sqlite3_X_init&quot; where &quot;X&quot; is based on the shared library filename. This allows every extension to have a different entry point, which allows them to be statically linked with no code changes.</source>
          <target state="translated">如果在可加载的扩展中没有默认的切入点 &quot;sqlite3_extension_init&quot;,也可以尝试一个切入点 &quot;sqlite3_X_init&quot;,其中 &quot;X &quot;是基于共享库文件名的。这使得每个扩展都有不同的切入点,这使得它们可以在不改变代码的情况下进行静态链接。</target>
        </trans-unit>
        <trans-unit id="2f1570bf7cd89b0efb998b886e0a28b989f79bba" translate="yes" xml:space="preserve">
          <source>If the default value of a column is CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP, then the value used in the new row is a text representation of the current UTC date and/or time. For CURRENT_TIME, the format of the value is &quot;HH:MM:SS&quot;. For CURRENT_DATE, &quot;YYYY-MM-DD&quot;. The format for CURRENT_TIMESTAMP is &quot;YYYY-MM-DD HH:MM:SS&quot;.</source>
          <target state="translated">如果列的默认值是CURRENT_TIME、CURRENT_DATE或CURRENT_TIMESTAMP,那么在新行中使用的值是当前UTC日期和/或时间的文本表示。对于 CURRENT_TIME,值的格式是 &quot;HH:MM:SS&quot;。对于CURRENT_DATE,值的格式是 &quot;YYYY-MM-DD&quot;。CURRENT_TIMESTAMP 的格式是 &quot;YYYY-MM-DD HH:MM:SS&quot;。</target>
        </trans-unit>
        <trans-unit id="763669d7f38746d95d771edeb8a196a32d9d9e41" translate="yes" xml:space="preserve">
          <source>If the default value of a column is an expression in parentheses, then the expression is evaluated once for each row inserted and the results used in the new row.</source>
          <target state="translated">如果列的默认值是括号中的表达式,那么每插入一行,表达式就会被评估一次,并在新行中使用结果。</target>
        </trans-unit>
        <trans-unit id="f9fe1ed106b11da1d5f4cf451a970a2b10eba0b4" translate="yes" xml:space="preserve">
          <source>If the default value of the column is a constant NULL, text, blob or signed-number value, then that value is used directly in the new row.</source>
          <target state="translated">如果列的默认值是一个常量的NULL、文本、blob或有符号的数字值,那么在新行中直接使用该值。</target>
        </trans-unit>
        <trans-unit id="6072ed5efdb78dd0e13242a8b605916b880d7376" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;column&lt;/b&gt;, then for each term the FTS index records the rowid and column number only, omitting the term offset information. This results in the following restrictions:</source>
          <target state="translated">如果detail选项设置为&lt;b&gt;column&lt;/b&gt;，则对于每个术语，FTS索引仅记录rowid和列号，而忽略术语偏移量信息。这导致以下限制：</target>
        </trans-unit>
        <trans-unit id="e6f14be9765a087a59fad069383360a3c524d64a" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;none&lt;/b&gt;, then for each term the FTS index records just the rowid is stored. Both column and offset information are omitted. As well as the restrictions itemized above for detail=column mode, this imposes the following extra limitations:</source>
          <target state="translated">如果detail选项设置为&lt;b&gt;none&lt;/b&gt;，那么对于每个术语，FTS索引仅记录rowid。列和偏移量信息均被省略。除了上面对detail = column模式列出的限制之外，这还施加了以下额外限制：</target>
        </trans-unit>
        <trans-unit id="c0b004cd1f197d0bb3d8b70f7d3071c3e7d65b08" translate="yes" xml:space="preserve">
          <source>If the file-size is not zero bytes and the page cache does not contain valid data for the first page of the database, then the data for the first page must be read from the database.</source>
          <target state="translated">如果文件大小不是零字节,且页面缓存中不包含数据库第一页的有效数据,则必须从数据库中读取第一页的数据。</target>
        </trans-unit>
        <trans-unit id="7d40fd66a8466c922e947b1b7af920a75a0b5408" translate="yes" xml:space="preserve">
          <source>If the filename argument to the shell is a ZIP archive rather than an SQLite database, then the shell automatically opens that ZIP archive using the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">如果外壳程序的filename参数是ZIP存档而不是SQLite数据库，则外壳程序会使用&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表&lt;/a&gt;自动打开该ZIP存档。</target>
        </trans-unit>
        <trans-unit id="ae3dbad88e43cb04cd5afd00c461d318a7360e00" translate="yes" xml:space="preserve">
          <source>If the filename is &quot;:memory:&quot;, then a private, temporary in-memory database is created for the connection. This in-memory database will vanish when the database connection is closed. Future versions of SQLite might make use of additional special filenames that begin with the &quot;:&quot; character. It is recommended that when a database filename actually does begin with a &quot;:&quot; character you should prefix the filename with a pathname such as &quot;./&quot; to avoid ambiguity.</source>
          <target state="translated">如果文件名是&quot;:memory:&quot;,那么就会为该连接创建一个私有的、临时的内存数据库。当数据库连接关闭时,这个内存中的数据库将消失。未来版本的SQLite可能会使用更多以&quot;:&quot;字符开头的特殊文件名。建议当数据库文件名确实以&quot;:&quot;字符开头时,应该在文件名前加上一个路径名,如&quot;./&quot;,以避免歧义。</target>
        </trans-unit>
        <trans-unit id="62f7e60cb107b276af1d9e468c997800e50e0c47" translate="yes" xml:space="preserve">
          <source>If the filename is an empty string, then a private, temporary on-disk database will be created. This private database will be automatically deleted as soon as the database connection is closed.</source>
          <target state="translated">如果文件名是一个空字符串,那么将创建一个私人的临时磁盘数据库。一旦数据库连接关闭,这个私人数据库将被自动删除。</target>
        </trans-unit>
        <trans-unit id="e090a4024fb7e0384c6590b18fdaa1dae521998f" translate="yes" xml:space="preserve">
          <source>If the filename pointer returned by this routine is not NULL, then it can be used as the filename input parameter to these routines:</source>
          <target state="translated">如果这个例程返回的文件名指针不是NULL,那么它可以作为这些例程的文件名输入参数。</target>
        </trans-unit>
        <trans-unit id="32dd493cb01796f1b19bb91ce938cad16395b6df" translate="yes" xml:space="preserve">
          <source>If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</source>
          <target state="translated">如果sqlite3_create_function_v2()或sqlite3_create_window_function()的最终参数不是NULL,那么它就是应用程序数据指针的destructor。当函数被删除时,无论是被重载还是数据库连接关闭时,都会调用destructor。如果调用sqlite3_create_function_v2()失败,destructor也会被调用。当desttructor回调被调用时,它将被传递一个参数,这个参数是应用程序数据指针的副本,这个指针是sqlite3_create_function_v2()的第五个参数。</target>
        </trans-unit>
        <trans-unit id="a0307f53fcf484b466b65b063fa221cd6f594f91" translate="yes" xml:space="preserve">
          <source>If the first character of the &quot;.output&quot; or &quot;.once&quot; filename is a pipe symbol (&quot;|&quot;) then the remaining characters are treated as a command and the output is sent to that command. This makes it easy to pipe the results of a query into some other process. For example, the &quot;open -f&quot; command on a Mac opens a text editor to display the content that it reads from standard input. So to see the results of a query in a text editor, one could type:</source>
          <target state="translated">如果&quot;.output &quot;或&quot;.once &quot;文件名的第一个字符是一个管道符号(&quot;|&quot;),那么剩下的字符将被视为一个命令,输出将被发送到该命令。这样就可以很容易地将查询结果用管道传送到其他进程中。例如,Mac上的 &quot;open -f &quot;命令可以打开一个文本编辑器,显示它从标准输入中读取的内容。因此,要在文本编辑器中查看查询结果,可以键入。</target>
        </trans-unit>
        <trans-unit id="f6248b44ea5d1fc55c81c80463d285a1931abd4d" translate="yes" xml:space="preserve">
          <source>If the flags parameter is non-zero, then the BLOB is opened for read and write access. If the flags parameter is zero, the BLOB is opened for read-only access.</source>
          <target state="translated">如果flags参数为非零,则打开BLOB进行读写访问。如果flags参数为零,则打开BLOB进行只读访问。</target>
        </trans-unit>
        <trans-unit id="42e53a5898ca221d8e5453208404df16340c520e" translate="yes" xml:space="preserve">
          <source>If the frame type is RANGE or GROUPS, then rows with the same values for all ORDER BY expressions are considered &quot;peers&quot;. Or, if there are no ORDER BY terms, all rows are peers. Peers are always within the same frame.</source>
          <target state="translated">如果框架类型是range或groups,那么对于所有ORDER BY表达式具有相同值的行被认为是 &quot;对等体&quot;。或者,如果没有ORDER BY项,则所有行都是对等体。对等体总是在同一个框架内。</target>
        </trans-unit>
        <trans-unit id="4aa0a21905f32bbcafa3289b7a629a809ef523ab" translate="yes" xml:space="preserve">
          <source>If the full-text index is consistent with the contents of the table, the INSERT used to invoke the integrity-check command succeeds. Or, if any discrepancy is found, it fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="translated">如果全文索引与表的内容一致，则用于调用完整性检查命令的INSERT成功。或者，如果发现任何差异，它将失败并显示&lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="f22af0b11cea33d685991d206d7069a56eda1b2e" translate="yes" xml:space="preserve">
          <source>If the function is registered using the sqlite3_collation_needed() API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8. If sqlite3_collation_needed16() is used, the names are passed as UTF-16 in machine native byte order. A call to either function replaces the existing collation-needed callback.</source>
          <target state="translated">如果该函数是使用sqlite3_collation_needed()API注册的,那么它将把未定义的整理序列的名称作为UTF-8编码的字符串传递。如果使用sqlite3_collation_needed16(),则以UTF-16的机器本地字节顺序传递名称。对这两个函数的调用都会替换现有的 collation-needed 回调。</target>
        </trans-unit>
        <trans-unit id="6a62bcf0e73dbd9b64d823a84e324e7b03ef33b0" translate="yes" xml:space="preserve">
          <source>If the hard upper bound on mmap_size is non-zero at compilation time, it may still be reduced or zeroed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,X,Y) interface. The X and Y parameters must both be 64-bit signed integers. The X parameter is the default mmap_size of the process and the Y is the new hard upper bound. The hard upper bound cannot be increased above its compile-time setting using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; but it can be reduced or zeroed.</source>
          <target state="translated">如果mmap_size的硬上限在编译时不为零，则仍可以使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;，X，Y）接口在开始时将其降低或归零。X和Y参数都必须是64位有符号整数。X参数是进程的默认mmap_size，Y参数是新的硬上限。使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;不能将硬上限提高到其编译时设置之上，但可以将其降低或清零。</target>
        </trans-unit>
        <trans-unit id="7e3c788b80a3fc760cf36b37df86e977c5bf4e82" translate="yes" xml:space="preserve">
          <source>If the initial value of register P1 is less than 1, then the value is unchanged and control passes through to the next instruction.</source>
          <target state="translated">如果寄存器P1的初始值小于1,则该值不变,控制权传递到下一条指令。</target>
        </trans-unit>
        <trans-unit id="c6c2836bf573a577c3b9e85be740fd6180f2bc75" translate="yes" xml:space="preserve">
          <source>If the insert operation would cause the uniqueness constraint identified by the conflict-target clause to fail, then the insert is omitted and either the DO NOTHING or DO UPDATE operation is performed instead. In the case of a multi-row insert, this decision is made separately for each row of the insert.</source>
          <target state="translated">如果插入操作会导致冲突目标子句所确定的唯一性约束失败,那么就省略插入操作,而执行DO NOTHING或DO UPDATE操作。在多行插入的情况下,这个决定是针对插入的每一行单独做出的。</target>
        </trans-unit>
        <trans-unit id="94f24cffd74c8aa91288ff50b98f2890c0c1dd37" translate="yes" xml:space="preserve">
          <source>If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="translated">如果 integrity_check pragma 发现了问题,就会返回描述问题的字符串(以每行单列的多行形式)。参数integrity_check最多只能返回</target>
        </trans-unit>
        <trans-unit id="5cd79e7c31e9806cd77deff0cb0e96d9ab910562" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid DELETE or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old()&lt;/a&gt; API may be used to obtain the old.* values within the change payload.</source>
          <target state="translated">如果迭代器指向有效的DELETE或UPDATE条目，则可以使用&lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old（）&lt;/a&gt; API获取更改有效载荷内的old。*值。</target>
        </trans-unit>
        <trans-unit id="b3c7141c41f848703cade5e408485ed848edf925" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid INSERT or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt; API may be used to obtain the new.* values within the change payload.</source>
          <target state="translated">如果迭代器指向有效的INSERT或UPDATE条目，则可以使用&lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new（）&lt;/a&gt; API获取更改有效载荷内的new。*值。</target>
        </trans-unit>
        <trans-unit id="27b2873f49d5b86c6645b602757d6284a617e429" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid entry, the &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op()&lt;/a&gt; API may be used to determine the type of change (INSERT, UPDATE or DELETE) that the iterator points to. Additionally, the same API can be used to obtain the name of the table the change applies to and its expected number of columns and primary key columns.</source>
          <target state="translated">如果迭代器指向有效条目，则可以使用&lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op（）&lt;/a&gt; API确定迭代器指向的更改类型（INSERT，UPDATE或DELETE）。此外，可以使用相同的API获取更改所适用的表的名称及其预期的列数和主键列。</target>
        </trans-unit>
        <trans-unit id="b7875cd04c26b022cfa813504a6e1447dc659fda" translate="yes" xml:space="preserve">
          <source>If the join between the target table and the FROM clause results in multiple output rows for the same target table row, then only one of those output rows is used for updating the target table. The output row selected is arbitrary and might change from one release of SQLite to the next, or from one run to the next.</source>
          <target state="translated">如果目标表和FROM子句之间的连接导致同一目标表行有多条输出行,那么这些输出行中只有一条用于更新目标表。所选择的输出行是任意的,可能在SQLite的一个版本到下一个版本,或者在一次运行到下一次运行时发生变化。</target>
        </trans-unit>
        <trans-unit id="5e43f90e3097e7ba0e1ecf1e86b3e41e586eb695" translate="yes" xml:space="preserve">
          <source>If the join-operator is &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot; or a comma (&quot;,&quot;) and there is no ON or USING clause, then the result of the join is simply the cartesian product of the left and right-hand datasets. If join-operator does have ON or USING clauses, those are handled according to the following bullet points:</source>
          <target state="translated">如果join-operator是 &quot;CROSS JOIN&quot;、&quot;INNER JOIN&quot;、&quot;JOIN &quot;或逗号(&quot;,&quot;),并且没有ON或USING子句,那么join的结果只是左手和右手数据集的卡方乘积。如果join-operator确实有ON或USING子句,则按照以下要点处理。</target>
        </trans-unit>
        <trans-unit id="e1fb18a5273cd27a264734974f9f02d1710aa767" translate="yes" xml:space="preserve">
          <source>If the join-operator is a &quot;LEFT JOIN&quot; or &quot;LEFT OUTER JOIN&quot;, then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original left-hand input dataset that corresponds to no rows at all in the composite dataset (if any). The added rows contain NULL values in the columns that would normally contain values copied from the right-hand input dataset.</source>
          <target state="translated">如果join-operator是 &quot;LEFT JOIN &quot;或 &quot;LEFT OUTER JOIN&quot;,那么在应用了ON或USING过滤子句之后,对于原始左侧输入数据集中的每一条记录,都会在输出中增加一条额外的记录,而这条记录对应的是复合数据集中的任何记录(如果有的话)。增加的行在通常会包含从右侧输入数据集复制的值的列中包含NULL值。</target>
        </trans-unit>
        <trans-unit id="76658faf4e1e99248322d20ab1af06451a7269ae" translate="yes" xml:space="preserve">
          <source>If the json_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed.</source>
          <target state="translated">如果调用json_remove(X)函数时没有路径参数,那么它将返回重新格式化的输入X,并删除多余的空白。</target>
        </trans-unit>
        <trans-unit id="b094bdd6dfc46d4028fcd23aee2c781ab15d0c15" translate="yes" xml:space="preserve">
          <source>If the last client using the database shuts down cleanly by calling &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;, then a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run automatically in order to transfer all information from the wal file over into the main database, and both the shm file and the wal file are unlinked. Thus, when the database is not in use by any client, it is usually the case that only the main database file exists on disk. However, if the last client did not call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; before it shut down, or if the last client to disconnect was a read-only client, then the final cleanup operation does not occur and the shm and wal files may still exist on disk even when the database is not in use.</source>
          <target state="translated">如果最后一个使用数据库的客户端通过调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;完全关闭，则将自动运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;，以便将所有信息从wal文件传输到主数据库中，并且shm文件和wal文件均未链接。因此，当没有任何客户端使用数据库时，通常情况是磁盘上仅存在主数据库文件。但是，如果最后一个客户端在关闭前未调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;，或者如果最后一个断开连接的客户端是只读客户端，则不会进行最终的清理操作，并且磁盘上可能仍然存在shm和wal文件即使不使用数据库也是如此。</target>
        </trans-unit>
        <trans-unit id="4f7a9d6c2807cb225b7b7ab46b05552f481cc42e" translate="yes" xml:space="preserve">
          <source>If the last connection to a database crashed, then the first new connection to open the database will start a recovery process. An exclusive lock is held during recovery. So if a third database connection tries to jump in and query while the second connection is running recovery, the third connection will get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">如果与数据库的最后一个连接崩溃，则第一个打开数据库的新连接将启动恢复过程。恢复期间将保留排他锁。因此，如果在第二个连接正在运行恢复的同时第三个数据库连接尝试跳入并查询，则第三个连接将收到&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="37b7298e57bd67e9cd0305c3baee9cc81b8dbc9d" translate="yes" xml:space="preserve">
          <source>If the lastname and firstname on the bottom row of the previous screen are bound to ?1 and ?2, then the query above computes the next 7 rows. And, assuming there is an appropriate index, it does so very efficiently &amp;mdash; much more efficiently than OFFSET.</source>
          <target state="translated">如果前一个屏幕的下一行的姓和名绑定到？1和？2，则上面的查询将计算接下来的7行。而且，假设有一个合适的索引，它会非常高效-比OFFSET效率更高。</target>
        </trans-unit>
        <trans-unit id="4e01c1ab95f2a00094ec0341f6411fa5bdba3e3d" translate="yes" xml:space="preserve">
          <source>If the library is not configured for UTF-8 and the Tcl library is one of the newer ones that uses UTF-8 internally, then a conversion from UTF-8 to iso8859 and back again is done inside the TCL interface.</source>
          <target state="translated">如果库没有配置UTF-8,而Tcl库又是内部使用UTF-8的新库,那么在TCL接口内就会完成从UTF-8到iso8859的转换。</target>
        </trans-unit>
        <trans-unit id="e9f32c50cc50b5c20674f65e05651f4083f0b21f" translate="yes" xml:space="preserve">
          <source>If the locking mode is EXCLUSIVE when first entering &lt;a href=&quot;wal&quot;&gt;WAL journal mode&lt;/a&gt;, then the locking mode cannot be changed to NORMAL until after exiting WAL journal mode. If the locking mode is NORMAL when first entering WAL journal mode, then the locking mode can be changed between NORMAL and EXCLUSIVE and back again at any time and without needing to exit WAL journal mode.</source>
          <target state="translated">如果在首次进入&lt;a href=&quot;wal&quot;&gt;WAL日志模式&lt;/a&gt;时锁定模式为EXCLUSIVE ，则只有在退出WAL日志模式后才能将锁定模式更改为NORMAL。如果在首次进入WAL日志模式时锁定模式为NORMAL，则可以在NORMAL和EXCLUSIVE之间更改锁定模式，然后随时退出，而无需退出WAL日志模式。</target>
        </trans-unit>
        <trans-unit id="4d5f5f76a7fce4a19ed7250628145b10beef7a78" translate="yes" xml:space="preserve">
          <source>If the matchable phrase in the FTS query is restricted to matching data in a specified FTS table column, then only phrase matches that occur within that column are considered.</source>
          <target state="translated">如果FTS查询中的可匹配短语被限制为匹配指定FTS表列中的数据,那么只考虑该列中出现的短语匹配。</target>
        </trans-unit>
        <trans-unit id="e74ad1dee292520ae801328610398f65c1bd2944" translate="yes" xml:space="preserve">
          <source>If the memory allocation subsystems within SQLite are configured for breakdown-free operation but the actual memory usage exceeds design limits set by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;, SQLite will usually continue to operate normally. The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; automatically failover to the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; general-purpose memory allocator. And it is usually the case that the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator will continue to function without fragmentation even if &lt;b&gt;M&lt;/b&gt; and/or &lt;b&gt;n&lt;/b&gt; exceeds the limits imposed by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;. The &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; shows that it is possible for a memory allocation to break down and fail in this circumstance, but such a failure requires an especially despicable sequence of allocations and deallocations - a sequence that SQLite has never been observed to follow. So in practice it is usually the case that the limits imposed by Robson can be exceeded by a considerable margin with no ill effect.</source>
          <target state="translated">如果将SQLite中的内存分配子系统配置为无故障运行，但实际内存使用量超出了&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson证明所&lt;/a&gt;设置的设计限制，则SQLite通常将继续正常运行。页面&lt;a href=&quot;malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;和&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器会&lt;/a&gt;自动故障转移到&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;通用内存分配器。通常情况下，即使&lt;b&gt;M&lt;/b&gt;和/或&lt;b&gt;n&lt;/b&gt;超过了&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson证明&lt;/a&gt;施加的限制，&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;内存分配器也将继续运行而不会产生碎片。在&lt;a href=&quot;malloc#nofrag&quot;&gt;罗布森证明&lt;/a&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;显示了在这种情况下内存分配有可能崩溃并失败，但是这种失败需要特别卑鄙的分配和取消分配序列-从未观察到遵循SQLite的序列。因此，在实践中，通常情况下，可以大幅度超出Robson施加的限制而不会产生不良影响。</target>
        </trans-unit>
        <trans-unit id="ccc13fed0f9a7a53b6beaefda251b5fe55a5b377" translate="yes" xml:space="preserve">
          <source>If the missing function returns an error, then the database is not opened and the error returned to the user. If an openclose function is configured, then a &quot;close&quot; invocation is issued at this point to match the earlier &quot;open&quot;. The following pseudo-code illustrates the procedure used by a swarmvtab instance with both missing and openclose functions configured when a component database is opened.</source>
          <target state="translated">如果缺失的函数返回错误,那么数据库就不会被打开,并将错误返回给用户。如果配置了openclose函数,那么此时会发出一个 &quot;close &quot;调用,以配合之前的 &quot;open&quot;。下面的伪代码说明了一个同时配置了缺失函数和openclose函数的swarmvtab实例在打开组件数据库时使用的过程。</target>
        </trans-unit>
        <trans-unit id="da30913cd33d5b91e0a650b018579fde9dd09c23" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果以最近呼叫&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;为&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的声明&lt;/a&gt; S表示错误，那么&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;返回相应的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40013c6ef594b13a3f8340842450df9d33bd6702" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">如果最近调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;为&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的声明&lt;/a&gt;小号返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，或者如果&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;以前从未呼吁S，然后&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cc58a427f7c8746f7e6e3f5425c1b7c73b16876" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果以最近呼叫&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;为&lt;a href=&quot;stmt&quot;&gt;准备好的声明&lt;/a&gt; S表示错误，那么&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;返回相应的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36afaf441091086a1762a1226de0f8218bd283bf" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">如果最近调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;为&lt;a href=&quot;stmt&quot;&gt;准备好的声明&lt;/a&gt;小号返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;或&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，或者如果&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;以前从未呼吁S，然后&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd08063b2d67d7c5aa3fda6b30f29f4f613d2690" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">如果与&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 关联的最新sqlite3_ * API调用失败，则sqlite3_errcode（D）接口返回该API调用的数字&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。 sqlite3_extended_errcode（）接口是相同的，只是即使禁用&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;，它也始终返回扩展结果代码。</target>
        </trans-unit>
        <trans-unit id="02b382e95c5f6b3f587125cf8455da646274a1ae" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">如果与&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 关联的最新sqlite3_ * API调用失败，则sqlite3_errcode（D）接口返回该API调用的数字&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。sqlite3_extended_errcode（）接口是相同的，只是即使禁用&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;，它也始终返回扩展结果代码。</target>
        </trans-unit>
        <trans-unit id="5550b629f440ed23b3241e812f943180a93fdc19" translate="yes" xml:space="preserve">
          <source>If the nByte argument is negative, then zSql is read up to the first zero terminator. If nByte is positive, then it is the number of bytes read from zSql. If nByte is zero, then no prepared statement is generated. If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an nByte parameter that is the number of bytes in the input string</source>
          <target state="translated">如果nByte参数为负值,那么zSql将被读到第一个零结束符。如果nByte为正值,那么它就是从zSql中读取的字节数。如果nByte为零,那么就不会生成准备好的语句。如果调用者知道所提供的字符串是nul-terminator的,那么传递一个nByte参数是输入字符串中的字节数,在性能上有一个小小的优势</target>
        </trans-unit>
        <trans-unit id="e34afe39a4a88dd3fd33f4104d3959b3a21962af" translate="yes" xml:space="preserve">
          <source>If the name of the database is an empty string, open a new database in a temporary file that is automatically deleted when the database is closed.</source>
          <target state="translated">如果数据库名称为空字符串,则在临时文件中打开一个新的数据库,当数据库关闭时自动删除。</target>
        </trans-unit>
        <trans-unit id="4c3da3e28f6b46a881fb905c79f9b554244037e3" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the final contents of the changegroup is undefined.</source>
          <target state="translated">如果新的变更集包含对已经存在于变更组中的表的变更,那么表的列数和主键列的位置必须一致。如果不是这样,这个函数就会以SQLITE_SCHEMA失败。如果输入的变更组出现损坏,并且检测到损坏,则返回SQLITE_CORRUPT。或者,如果在处理过程中出现内存不足的情况,这个函数返回SQLITE_NOMEM。在所有情况下,如果发生错误,changegroup的最终内容是未定义的。</target>
        </trans-unit>
        <trans-unit id="96ca16b2fc66ae0f3d6b77a841fb9c9703e99865" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the state of the final contents of the changegroup is undefined.</source>
          <target state="translated">如果新的变更集包含对已经存在于变更组中的表的变更,那么表的列数和主键列的位置必须一致。如果不是这样,这个函数就会以SQLITE_SCHEMA失败。如果输入的变更组出现损坏,并且检测到损坏,则返回SQLITE_CORRUPT。或者,如果在处理过程中出现内存不足的情况,这个函数返回SQLITE_NOMEM。在所有情况下,如果发生错误,changegroup的最终内容的状态是未定义的。</target>
        </trans-unit>
        <trans-unit id="27ef56041d2d705e25a721ff1b854e81e350859e" translate="yes" xml:space="preserve">
          <source>If the new limit is a negative number, the limit is unchanged. For each limit category SQLITE_LIMIT_</source>
          <target state="translated">如果新的限制是负数,则限制不变。对于每一个限制类别,SQLITE_LIMIT_</target>
        </trans-unit>
        <trans-unit id="dbc989a098eb2be336e5500ea022b41d17fc93aa" translate="yes" xml:space="preserve">
          <source>If the number of output rows is K, then the time needed to sort is proportional to KlogK. If K is small, the sorting time is usually not a factor, but in a query such as the above where K==N, the time needed to sort can be much greater than the time needed to do a full table scan. Furthermore, the entire output is accumulated in temporary storage (which might be either in main memory or on disk, depending on various compile-time and run-time settings) which can mean that a lot of temporary storage is required to complete the query.</source>
          <target state="translated">如果输出行数为K,那么排序所需的时间与KlogK成正比。如果K很小,排序时间通常不是一个因素,但在像上面这样K==N的查询中,排序所需的时间可能远远大于做一次全表扫描所需的时间。此外,整个输出结果会积累在临时存储中(可能在主内存中,也可能在磁盘上,这取决于各种编译时和运行时的设置),这可能意味着需要大量的临时存储来完成查询。</target>
        </trans-unit>
        <trans-unit id="c9314fcd77821589cea840c1fc80043331e7d710" translate="yes" xml:space="preserve">
          <source>If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second. The number of milliseconds of sleep actually requested from the operating system is returned.</source>
          <target state="translated">如果操作系统不支持毫秒时间分辨率的睡眠请求,那么时间将被四舍五入到最接近的秒。返回实际向操作系统请求的睡眠时间的毫秒数。</target>
        </trans-unit>
        <trans-unit id="13ac5ae90471727393e9b13c70a7b1b4bc52ca60" translate="yes" xml:space="preserve">
          <source>If the operating system returns an I/O error while attempting to obtain a certain lock on shared memory in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; then SQLite might fail to reset its cache, which could lead to database corruption if subsequent writes are attempted.</source>
          <target state="translated">如果操作系统在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;尝试获取共享内存上的某个锁定时返回I / O错误，则SQLite可能无法重置其缓存，如果尝试后续写入，则可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="cdf4bb4c410d8ce86d8512a4260a05ff5271bb95" translate="yes" xml:space="preserve">
          <source>If the operation is successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">如果操作成功,则返回SQLITE_OK。否则,返回SQLite错误代码。在这种情况下,如果参数pzErrMsg不是NULL,*pzErrMsg可以被设置为指向一个包含英文错误信息的缓冲区。调用者有责任使用 sqlite3_free()释放这个缓冲区。</target>
        </trans-unit>
        <trans-unit id="387f85a0f9d5d2d59fdee2093a34c406de18ba33" translate="yes" xml:space="preserve">
          <source>If the operation successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">如果操作成功,则返回SQLITE_OK。否则,返回SQLite错误代码。在这种情况下,如果参数pzErrMsg不是NULL,*pzErrMsg可以被设置为指向一个包含英文错误信息的缓冲区。调用者有责任使用 sqlite3_free()释放这个缓冲区。</target>
        </trans-unit>
        <trans-unit id="64ab9d2da26c1826cadd00ea1395a9af67e21893" translate="yes" xml:space="preserve">
          <source>If the optional ESCAPE clause is present, then the expression following the ESCAPE keyword must evaluate to a string consisting of a single character. This character may be used in the LIKE pattern to include literal percent or underscore characters. The escape character followed by a percent symbol (%), underscore (_), or a second instance of the escape character itself matches a literal percent symbol, underscore, or a single escape character, respectively.</source>
          <target state="translated">如果存在可选的ESCAPE子句,那么ESCAPE关键字后的表达式必须评估为一个由单个字符组成的字符串。这个字符可以在LIKE模式中使用,以包含字面的百分号或下划线字符。转义字符后面的百分号(%)、下划线(_)或转义字符本身的第二个实例分别与字面百分号、下划线或单个转义字符相匹配。</target>
        </trans-unit>
        <trans-unit id="3874cddaea0653331a0794c8eb1dd76401bd55b2" translate="yes" xml:space="preserve">
          <source>If the optional IF NOT EXISTS clause is present and another index with the same name already exists, then this command becomes a no-op.</source>
          <target state="translated">如果存在可选的IF NOT EXISTS子句,并且已经存在另一个同名索引,那么这条命令就会变成无操作。</target>
        </trans-unit>
        <trans-unit id="65cace3a0d2d4d6370079a8ce7f587fee8e20bbc" translate="yes" xml:space="preserve">
          <source>If the outer query is an aggregate, then the subquery may not contain ORDER BY.</source>
          <target state="translated">如果外部查询是一个集合,那么子查询可能不包含ORDER BY。</target>
        </trans-unit>
        <trans-unit id="0b950d8e0107ea7fe292918a7624ecc4c5105550" translate="yes" xml:space="preserve">
          <source>If the outer query is part of a compound select, then the subquery may not have a LIMIT clause.</source>
          <target state="translated">如果外查询是复合选择的一部分,那么子查询可能没有LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="9ec4e583fb2aac08c6ef7929f12a08ccd0d23acd" translate="yes" xml:space="preserve">
          <source>If the output parameters (ppRebase) and (pnRebase) are non-NULL and the input is a changeset (not a patchset), then sqlite3changeset_apply_v2() may set (*ppRebase) to point to a &quot;rebase&quot; that may be used with the sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase) is set to the size of the buffer in bytes. It is the responsibility of the caller to eventually free any such buffer using sqlite3_free(). The buffer is only allocated and populated if one or more conflicts were encountered while applying the patchset. See comments surrounding the sqlite3_rebaser APIs for further details.</source>
          <target state="translated">如果输出参数(ppRebase)和(pnRebase)是非NULL,并且输入是一个变化集(而不是补丁集),那么sqlite3changeset_apply_v2()可以设置(*ppRebase)指向一个 &quot;rebase&quot;,这个 &quot;rebase &quot;可以在返回之前使用sqlite3_rebaser APIs缓冲区。在这种情况下,(*pnRebase)被设置为缓冲区的大小,单位是字节。调用者有责任使用sqlite3_free()最终释放任何这样的缓冲区。只有在应用补丁集时遇到一个或多个冲突时,缓冲区才会被分配和填充。更多细节请参见围绕 sqlite3_rebaser APIs 的注释。</target>
        </trans-unit>
        <trans-unit id="e9ff399a5e615a33dc8fa9681024351734065387" translate="yes" xml:space="preserve">
          <source>If the parameter is a positive value, B-tree structures are only eligible for merging if one of the following is true:</source>
          <target state="translated">如果该参数为正值,则只有当以下情况之一为真时,B树结构才有资格进行合并。</target>
        </trans-unit>
        <trans-unit id="60b6cd8e8d3dd19980d55457d739967fca11e05a" translate="yes" xml:space="preserve">
          <source>If the parameter is named, then its name appears in P4. The P4 value is used by sqlite3_bind_parameter_name().</source>
          <target state="translated">如果参数是命名的,那么它的名字就会出现在P4中,P4的值由sqlite3_bind_parameter_name()使用。P4的值被sqlite3_bind_parameter_name()使用。</target>
        </trans-unit>
        <trans-unit id="b51f3bd8d197cc75de48b64a5587d9918566615a" translate="yes" xml:space="preserve">
          <source>If the parameter is negative, and there are B-tree structures on more than one level within the FTS index, all B-tree structures are assigned to the same level before the merge operation is commenced. Additionally, if the parameter is negative, the value of the usermerge configuration option is not respected - as few as two b-trees from the same level may be merged together.</source>
          <target state="translated">如果参数为负值,并且在FTS索引的多个级别上有B树结构,那么在合并操作开始之前,所有的B树结构都会被分配到同一级别。</target>
        </trans-unit>
        <trans-unit id="ff1e8b8711836cc88e8f7bc11a03808c27d6ff91" translate="yes" xml:space="preserve">
          <source>If the paths are sorted using the BINARY collation sequence, then the overflow pages associated with a cell will appear earlier in the sort-order than its child page:</source>
          <target state="translated">如果使用BINARY整理序列对路径进行排序,那么在排序顺序中,与单元格相关联的溢出页将比其子页更早出现。</target>
        </trans-unit>
        <trans-unit id="e58cd97227118f50b919227b576a1a6d96943367" translate="yes" xml:space="preserve">
          <source>If the process that wants to write is unable to obtain a RESERVED lock, it must mean that another process already has a RESERVED lock. In that case, the write attempt fails and returns SQLITE_BUSY.</source>
          <target state="translated">如果要写的进程无法获得一个RESERVED锁,那一定意味着另一个进程已经有了一个RESERVED锁。在这种情况下,写的尝试会失败,并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="406129ab5d2092b3ea22acba195d09ec62e01cc6" translate="yes" xml:space="preserve">
          <source>If the progress callback returns non-zero, the operation is interrupted. This feature can be used to implement a &quot;Cancel&quot; button on a GUI progress dialog box.</source>
          <target state="translated">如果进度回调返回非零,则中断操作。此功能可用于在GUI进度对话框上实现 &quot;取消 &quot;按钮。</target>
        </trans-unit>
        <trans-unit id="ab297d564d935b4268428b382c93fe0d78c1a7ca" translate="yes" xml:space="preserve">
          <source>If the query contains an ORDER BY clause or a GROUP BY clause or if the query uses the DISTINCT keyword then it is advantageous to select a path through the graph that causes rows to naturally appear in sorted order, so that no separate sorting step is required. Automatic elimination of ORDER BY clauses can make a large performance difference, so this is another factor that needs to be considered in a complete implementation.</source>
          <target state="translated">如果查询中包含ORDER BY子句或GROUP BY子句,或者查询中使用了DISTINCT关键字,那么选择一条通过图的路径是有利的,它可以使行自然地按排序顺序出现,这样就不需要单独的排序步骤。自动消除ORDER BY子句会带来很大的性能差异,所以这也是完整实现中需要考虑的另一个因素。</target>
        </trans-unit>
        <trans-unit id="4359b51a903396b955ce1a84240a1385d5c4cd97" translate="yes" xml:space="preserve">
          <source>If the query runs to completion without incident, SQLITE_OK is returned. Or, if some error occurs before the query completes or is aborted by the callback, an SQLite error code is returned.</source>
          <target state="translated">如果查询顺利完成,则返回SQLITE_OK。或者,如果在查询完成之前发生错误或者被回调中止,则返回SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="78d49d24ce74dae451d0ef728d6bf465dbd467e9" translate="yes" xml:space="preserve">
          <source>If the reason for writing to the database file is because the memory cache was full, then the writer will not commit right away. Instead, the writer might continue to make changes to other pages. Before subsequent changes are written to the database file, the rollback journal must be flushed to disk again. Note also that the EXCLUSIVE lock that the writer obtained in order to write to the database initially must be held until all changes are committed. That means that no other processes are able to access the database from the time the memory cache first spills to disk until the transaction commits.</source>
          <target state="translated">如果向数据库文件写入的原因是因为内存缓存已满,那么写入者不会马上提交。相反,写入者可能会继续对其他页面进行修改。在后续的修改写入数据库文件之前,必须再次将回滚日志刷新到磁盘。还需要注意的是,写入者最初为了写入数据库而获得的EXCLUSIVE锁必须保持到所有更改提交为止。也就是说,从内存缓存第一次溢出磁盘到事务提交之前,其他进程都无法访问数据库。</target>
        </trans-unit>
        <trans-unit id="f4de1a28535def0f53f335b0aa1ec084bfb958b6" translate="yes" xml:space="preserve">
          <source>If the record contains fewer than P2 fields, then extract a NULL. Or, if the P4 argument is a P4_MEM use the value of the P4 argument as the result.</source>
          <target state="translated">如果记录包含的字段少于P2,则提取一个NULL。或者,如果P4参数是P4_MEM,则使用P4参数的值作为结果。</target>
        </trans-unit>
        <trans-unit id="a233c4347f5d21c12355351382fcf901413d7e49" translate="yes" xml:space="preserve">
          <source>If the recovered database schema already contains a table named &quot;lost_and_found&quot;, the &quot;.recover&quot; command uses the name &quot;lost_and_found0&quot;. If the name &quot;lost_and_found0&quot; is also already taken, &quot;lost_and_found1&quot;, and so on. The default name &quot;lost_and_found&quot; may be overridden by invoking &quot;.recover&quot; with the --lost-and-found switch. For example, to have the output script call the table &quot;orphaned_rows&quot;:</source>
          <target state="translated">如果恢复的数据库模式已经包含一个名为 &quot;lost_and_found &quot;的表,则&quot;.recover &quot;命令使用 &quot;lost_and_found0 &quot;这个名称。如果 &quot;lost_and_found0 &quot;这个名字也已经被采用,则采用 &quot;lost_and_found1&quot;,以此类推。默认的名称 &quot;lost_and_found &quot;可以通过调用&quot;.recover &quot;和--lost-and-found开关来覆盖。例如,让输出脚本调用表 &quot;orphaned_rows&quot;。</target>
        </trans-unit>
        <trans-unit id="872cffdf6d4bf05d01de18a6904e492aef161446" translate="yes" xml:space="preserve">
          <source>If the requested page is already in the page cache, then the page cache implementation must return a pointer to the page buffer with its content intact. If the requested page is not already in the cache, then the cache implementation should use the value of the createFlag parameter to help it determined what action to take:</source>
          <target state="translated">如果请求的页面已经在页面缓存中,那么页面缓存实现必须返回一个指向页面缓冲区的指针,并保持其内容完整。如果请求的页面还没有在缓存中,那么缓存实现应该使用createFlag参数的值来帮助它决定采取什么行动。</target>
        </trans-unit>
        <trans-unit id="db0bc69173aefab4964d855c64d49581690da543" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">如果结果是BLOB或UTF-16字符串，则sqlite3_column_bytes16（）例程返回该BLOB或字符串中的字节数。如果结果是UTF-8字符串，则sqlite3_column_bytes16（）将字符串转换为UTF-16，然后返回字节数。如果结果是数字值，则sqlite3_column_bytes16（）使用&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;将该值转换为UTF-16字符串，并返回该字符串中的字节数。如果结果为NULL，则sqlite3_column_bytes16（）返回零。</target>
        </trans-unit>
        <trans-unit id="3b44d7bd1746ffad7cf756ce26aeea67c4d49e66" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">如果结果是BLOB或UTF-16字符串，则sqlite3_column_bytes16（）例程返回该BLOB或字符串中的字节数。如果结果是UTF-8字符串，则sqlite3_column_bytes16（）将字符串转换为UTF-16，然后返回字节数。如果结果是数字值，则sqlite3_column_bytes16（）使用&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;将该值转换为UTF-16字符串，并返回该字符串中的字节数。如果结果为NULL，则sqlite3_column_bytes16（）返回零。</target>
        </trans-unit>
        <trans-unit id="5a04fb4ab27b4007fb1a3789b739c65a862ccba9" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">如果结果是BLOB或UTF-8字符串，则sqlite3_column_bytes（）例程返回该BLOB或字符串中的字节数。如果结果是UTF-16字符串，则sqlite3_column_bytes（）将字符串转换为UTF-8，然后返回字节数。如果结果是数字值，则sqlite3_column_bytes（）使用&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;将该值转换为UTF-8字符串，并返回该字符串中的字节数。如果结果为NULL，则sqlite3_column_bytes（）返回零。</target>
        </trans-unit>
        <trans-unit id="97aa0401915ee07da3fcfb4b2dd9b95ffff68377" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">如果结果是BLOB或UTF-8字符串，则sqlite3_column_bytes（）例程返回该BLOB或字符串中的字节数。如果结果是UTF-16字符串，则sqlite3_column_bytes（）将字符串转换为UTF-8，然后返回字节数。如果结果是数字值，则sqlite3_column_bytes（）使用&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;将该值转换为UTF-8字符串，并返回该字符串中的字节数。如果结果为NULL，则sqlite3_column_bytes（）返回零。</target>
        </trans-unit>
        <trans-unit id="cce95bf5c0bc98e89e8fc40f80872857badf8433" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes() or sqlite3_column_bytes16() interfaces can be used to determine the size of that BLOB or string.</source>
          <target state="translated">如果结果是一个BLOB或TEXT字符串,那么可以使用sqlite3_column_bytes()或sqlite3_column_bytes16()接口来确定该BLOB或字符串的大小。</target>
        </trans-unit>
        <trans-unit id="fd9c1a162239f42f97865bf762c6375eed8fe6fe" translate="yes" xml:space="preserve">
          <source>If the result is a general expression, not a just the name of a source table column, then the name of the result is a copy of the expression text.</source>
          <target state="translated">如果结果是一个通用的表达式,而不仅仅是一个源表列的名称,那么结果的名称就是表达式文本的复制。</target>
        </trans-unit>
        <trans-unit id="57f0dbb6f6834911f1360c14b63d681228556516" translate="yes" xml:space="preserve">
          <source>If the result set of a query is empty, then by default &lt;b&gt;sqlite_get_table&lt;/b&gt; will set nrow to 0 and leave its result parameter is set to NULL. But if the EMPTY_RESULT_CALLBACKS pragma is ON then the result parameter is initialized to the names of the columns only. For example, consider this query which has an empty result set:</source>
          <target state="translated">如果查询的结果集为空，则默认情况下&lt;b&gt;sqlite_get_table&lt;/b&gt;会将nrow设置为0，并将其result参数设置为NULL。但是，如果EMPTY_RESULT_CALLBACKS编译指示为ON，则将结果参数初始化为仅列名。例如，考虑此查询的结果集为空：</target>
        </trans-unit>
        <trans-unit id="d816ce55af3aa1bc324149c293eb2742dfc0c53d" translate="yes" xml:space="preserve">
          <source>If the right-hand side of an IN operator can be list of values as in the following:</source>
          <target state="translated">如果一个IN运算符的右侧可以列出如下所示的数值。</target>
        </trans-unit>
        <trans-unit id="b287ebc787ae1fe1352a6696e98abccff05e37e6" translate="yes" xml:space="preserve">
          <source>If the row comes from a WITHOUT ROWID table, this column contains NULL. Otherwise, it contains the 64-bit integer rowid value for the row.</source>
          <target state="translated">如果行来自一个WITHOUT ROWID表,这一列包含NULL。否则,它包含该行的64位整数rowid值。</target>
        </trans-unit>
        <trans-unit id="489be44720b2f1c706095444d825988cba31b9db" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">如果BLOB句柄指向的行被&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;或&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;副作用修改，则BLOB句柄将标记为&amp;ldquo;已过期&amp;rdquo;。如果更改了该行的任何列，甚至是BLOB句柄所在的列以外的其他列，也是如此。为到期的BLOB句柄调用&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;和&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;失败，返回码为&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;。 BLOB到期之前不会回滚在BLOB到期之前写入BLOB的更改。如果交易继续完成，则此类更改最终将提交。</target>
        </trans-unit>
        <trans-unit id="855918a93d6aa4472f75825b61dee9d03ea7eab1" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">如果BLOB句柄指向的行被&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;或&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;副作用修改，则BLOB句柄将标记为&amp;ldquo;已过期&amp;rdquo;。如果更改了该行的任何列，甚至是BLOB句柄所在的列以外的其他列，也是如此。为到期的BLOB句柄调用&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;失败，返回码为&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;。 BLOB到期之前不会回滚在BLOB到期之前写入BLOB的更改。如果交易继续完成，则此类更改最终将提交。</target>
        </trans-unit>
        <trans-unit id="5ad667b790a078db1e6c6968fc928120e549e94b" translate="yes" xml:space="preserve">
          <source>If the same database is being read and written using two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; (two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; objects returned by separate calls to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;) and the two database connections do not have a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, then the reader is only able to see complete committed transactions from the writer. Partial changes by the writer that have not been committed are invisible to the reader. This is true regardless of whether the two database connections are in the same thread, in different threads of the same process, or in different processes. This is the usual and expected behavior for SQL database systems.</source>
          <target state="translated">如果使用两个不同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;（通过分别调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;返回的两个不同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象）读取和写入同一数据库，并且两个数据库连接没有&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;，则读取器只能看到完整的提交来自作者的交易。作者尚未完成的部分更改对于读者是看不见的。无论两个数据库连接是在同一线程中，在同一进程的不同线程中还是在不同的进程中，都是如此。这是SQL数据库系统的通常和预期的行为。</target>
        </trans-unit>
        <trans-unit id="2e0132de71fd47828befdd8cddea786393211a76" translate="yes" xml:space="preserve">
          <source>If the savepoint-name in a RELEASE command does not match any savepoint currently in the transaction stack, then no savepoints are released, the database is unchanged, and the RELEASE command returns an error.</source>
          <target state="translated">如果RELEASE命令中的savepoint-name与当前事务堆栈中的任何savepoint不匹配,那么就不会释放任何savepoints,数据库不变,RELEASE命令返回一个错误。</target>
        </trans-unit>
        <trans-unit id="0e8e411b07fe2c001323f612676b1abf9cd50210" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">如果第二个参数（zDbName）与任何打开的数据库文件的名称都不匹配，则返回SQLITE_ERROR。此错误代码不会被记住，&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;不会将其重新调用。基础xFileControl方法也可能返回SQLITE_ERROR。无法区分不正确的zDbName和来自基础xFileControl方法的SQLITE_ERROR返回。</target>
        </trans-unit>
        <trans-unit id="0a6c4ada949c40cb1aa6d07b25694fd6c11c1796" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">如果第二个参数（zDbName）与任何打开的数据库文件的名称都不匹配，则返回SQLITE_ERROR。此错误代码不会被记住，&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;不会将其重新调用。基础xFileControl方法也可能返回SQLITE_ERROR。无法区分不正确的zDbName和来自基础xFileControl方法的SQLITE_ERROR返回。</target>
        </trans-unit>
        <trans-unit id="b78c0101bf92e2df502819dbd3877a0d27dbb142" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be greater than zero bytes by a query required by H35450, then SQLite shall attempt to upgrade the</source>
          <target state="translated">如果通过H35450要求的查询发现一个潜在的热日志文件的大小大于零字节,那么SQLite应尝试升级到</target>
        </trans-unit>
        <trans-unit id="84a94aa97953d8f31911d07edfb705a8ac22630d" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be zero bytes by a query required by H35450, then SQLite shall close the file handle opened on the journal file and delete the journal file using a call to the VFS xDelete() method. In this case SQLite shall conclude that there is no</source>
          <target state="translated">如果通过H35450要求的查询发现一个潜在的热日志文件的大小为零字节,那么SQLite应关闭在该日志文件上打开的文件句柄,并使用调用VFS xDelete()方法删除该日志文件。在这种情况下,SQLite应断定不存在</target>
        </trans-unit>
        <trans-unit id="8775f72effd63665f56849704eebc4e3eb03a777" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">如果WHERE子句中绑定到&lt;a href=&quot;../lang_expr#varparam&quot;&gt;主机参数&lt;/a&gt;的特定值可能会影响语句查询计划的选择，则该语句将在任何更改后的第一个&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中自动重新编译，就像发生了模式更改一样。在&lt;a href=&quot;bind_blob&quot;&gt;绑定&lt;/a&gt;该的&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。如果参数位于&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的左侧，或者将参数与索引列进行比较并且启用了&lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，则WHERE子句&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的特定值可能会影响查询计划的选择。</target>
        </trans-unit>
        <trans-unit id="44b5aede3751869315efb1ad0c6228b799d6377d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">如果WHERE子句中绑定到&lt;a href=&quot;lang_expr#varparam&quot;&gt;主机参数&lt;/a&gt;的特定值可能会影响语句查询计划的选择，则该语句将在任何更改后的第一个&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中自动重新编译，就像发生了模式更改一样。在&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;绑定&lt;/a&gt;该的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。如果参数位于&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的左侧，或者将参数与索引列进行比较并且启用了&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，则WHERE子句&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的特定值可能会影响查询计划的选择。</target>
        </trans-unit>
        <trans-unit id="a67ab94a492111af2ad307d63a14eece5d2506a2" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">如果WHERE子句中绑定到&lt;a href=&quot;../lang_expr#varparam&quot;&gt;主机参数&lt;/a&gt;的特定值可能会影响语句查询计划的选择，则该语句将在任何后续操作后的第一个&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中自动重新编译，就像发生了架构更改一样。更改为该&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的&lt;a href=&quot;bind_blob&quot;&gt;绑定&lt;/a&gt;。如果参数是&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的左侧，或者将参数与索引列进行比较并且启用了&lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，则WHERE子句&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的特定值可能会影响查询计划的选择。。</target>
        </trans-unit>
        <trans-unit id="1532d90d6e0b3047b8c2ebb4f13faa142948903d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">如果WHERE子句中绑定到&lt;a href=&quot;lang_expr#varparam&quot;&gt;主机参数&lt;/a&gt;的特定值可能会影响语句查询计划的选择，则该语句将在任何后续操作后的第一个&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中自动重新编译，就像发生了架构更改一样。更改为该&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;绑定&lt;/a&gt;。如果参数是&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的左侧，或者将参数与索引列进行比较并且启用了&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，则WHERE子句&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的特定值可能会影响查询计划的选择。。</target>
        </trans-unit>
        <trans-unit id="9e1ce97d9fc0705c3229e21c8809d3855d59efd3" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">如果指定的列是&amp;ldquo; rowid&amp;rdquo;，&amp;ldquo; oid&amp;rdquo;或&amp;ldquo; _rowid_&amp;rdquo;，并且该表不是&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，并且已显式声明了&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，则将为显式声明的列设置输出参数。如果没有&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，那么将&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;的输出设置如下：</target>
        </trans-unit>
        <trans-unit id="8f350a11b8322175a383ceadb167cdbb00955970" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">如果指定的列是&amp;ldquo; rowid&amp;rdquo;，&amp;ldquo; oid&amp;rdquo;或&amp;ldquo; _rowid_&amp;rdquo;，并且该表不是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，并且已显式声明了&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，则将为显式声明的列设置输出参数。如果没有&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，那么将&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;的输出设置如下：</target>
        </trans-unit>
        <trans-unit id="f3164e0e380d4749ee94c4239d71835f6ebe7294" translate="yes" xml:space="preserve">
          <source>If the specified compress or uncompress functions do not exist, the table may still be created. An error is not returned until the FTS4 table is read (if the uncompress function does not exist) or written (if it is the compress function that does not exist).</source>
          <target state="translated">如果指定的压缩或解压函数不存在,仍可创建表格。在读取FTS4表(如果解压函数不存在)或写入FTS4表(如果是压缩函数不存在)之前,不会返回错误。</target>
        </trans-unit>
        <trans-unit id="63eb5c5c72bb1ff543038003d7ef2fd45c2837fe" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">如果指定的表实际上是视图，则返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce9d8284bfd79645e82900ecac60c2249827b2a4" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">如果指定的表实际上是视图，则返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fece2731796046aa37a6f47896457da35d0048d" translate="yes" xml:space="preserve">
          <source>If the specified value is an integer (or text that looks like an integer), it is inserted verbatim. If the value is not a valid UNIX mode, some programs may behave unexpectedly when extracting files from the archive.</source>
          <target state="translated">如果指定的值是一个整数(或看起来像一个整数的文本),它将被逐字插入。如果该值不是有效的UNIX模式,一些程序在从存档中提取文件时可能会出现意外情况。</target>
        </trans-unit>
        <trans-unit id="e4f3a6c8e56d6f7f8102c0223dc18717b78218c4" translate="yes" xml:space="preserve">
          <source>If the specified view cannot be found and the IF EXISTS clause is not present, it is an error. If the specified view cannot be found and an IF EXISTS clause is present in the DROP VIEW statement, then the statement is a no-op.</source>
          <target state="translated">如果找不到指定的视图,且IF EXISTS子句不存在,则为错误。如果找不到指定的视图,而DROP VIEW语句中又有IF EXISTS子句,则该语句为无操作。</target>
        </trans-unit>
        <trans-unit id="969d1886dea91ce69d33e9942c74c8365291e28d" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it might return true if the column is being fetched as part of an UPDATE operation during which the column value will not change. The virtual table implementation can use this hint as permission to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">如果在&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法中调用了sqlite3_vtab_nochange（X）例程，则如果作为UPDATE操作的一部分来获取该列，则在列值不变的情况下，它可能返回true。虚拟表实现可以使用此提示作为许可来替换返回值，该返回值的计算成本较低，并且相应的&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法将其理解为&amp;ldquo;不变&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="90a8c9a64f685446aa6aabbcaddc7d44c89fc5a1" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">如果在&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法中调用了sqlite3_vtab_nochange（X）例程，则当且仅当作为UPDATE操作的一部分来提取列时，该列返回true，在此过程中列值将保持不变。应用程序可能会使用它来代替返回值，该返回值的计算成本较低，并且相应的&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法将其理解为&amp;ldquo;不变&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="d0558f9621b3961678e1c8ba8bcf516d2187f206" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it might return true if the column is being fetched as part of an UPDATE operation during which the column value will not change. The virtual table implementation can use this hint as permission to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">如果在&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法中调用了sqlite3_vtab_nochange（X）例程，则如果作为UPDATE操作的一部分来获取该列，则在列值不变的情况下，它可能返回true。虚拟表实现可以使用此提示作为许可来替换返回值，该返回值的计算成本较低，并且相应的&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法将其理解为&amp;ldquo;不变&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="589f84e6663e321a54522d9b6141cb9b22a8427e" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">如果在&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法中调用了sqlite3_vtab_nochange（X）例程，则当且仅当作为UPDATE操作的一部分来提取列时，该列返回true，在此过程中列值将保持不变。应用程序可能会使用它来代替返回值，该返回值的计算成本较低，并且相应的&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法将其理解为&amp;ldquo;不变&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="aeaddc8619c2a7f7c9c53fa9fbcf5b7907cc4bc7" translate="yes" xml:space="preserve">
          <source>If the sqlite_stat1.idx column is NULL, then the sqlite_stat1.stat column contains a single integer which is the approximate number of rows in the table identified by sqlite_stat1.tbl. If the sqlite_stat1.idx column is the same as the sqlite_stat1.tbl column, then the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and the sqlite_stat1.stat field contains information about the index btree that implements the WITHOUT ROWID table.</source>
          <target state="translated">如果sqlite_stat1.idx列为NULL，则sqlite_stat1.stat列包含单个整数，该整数是由sqlite_stat1.tbl标识的表中的大约行数。如果sqlite_stat1.idx列与sqlite_stat1.tbl列相同，则该表是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，而sqlite_stat1.stat字段包含有关实现WITHOUT ROWID表的索引btree的信息。</target>
        </trans-unit>
        <trans-unit id="7ef8812fff06e258ef45bbe3080d7b83145fdfcb" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound SELECT, then</source>
          <target state="translated">如果子查询是一个复合SELECT,那么就是</target>
        </trans-unit>
        <trans-unit id="95d8d057928b20b8273091a81f8f75e5dc26f5b2" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then all terms of the ORDER by clause of the parent must be simple references to columns of the sub-query.</source>
          <target state="translated">如果子查询是一个复合选择,那么父查询的ORDER by子句的所有条款必须是对子查询列的简单引用。</target>
        </trans-unit>
        <trans-unit id="cfa26eb2d70555062705f5059521f66db3517508" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then it must not use an ORDER BY clause.</source>
          <target state="translated">如果子查询是一个复合选择,那么它必须不使用ORDER BY子句。</target>
        </trans-unit>
        <trans-unit id="a41d547f4cfa21fa6c9e383332bb2ccbe73488d1" translate="yes" xml:space="preserve">
          <source>If the subquery is the right operand of a LEFT JOIN then</source>
          <target state="translated">如果子查询是一个LEFT JOIN的右边操作数,那么就是</target>
        </trans-unit>
        <trans-unit id="9251592b196cd1f8e1c4b9db367256eca51eaf76" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT then the outer query may not have a WHERE clause.</source>
          <target state="translated">如果子查询使用LIMIT,那么外层查询可能没有WHERE子句。</target>
        </trans-unit>
        <trans-unit id="3915c5066778c0e52bdae49ad9f9428a2640f7be" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT, then the outer query may not be DISTINCT.</source>
          <target state="translated">如果子查询使用LIMIT,那么外层查询可能不是DISTINCT。</target>
        </trans-unit>
        <trans-unit id="3ca99915e9f2329a546bdb9b1fd10bf3cea382c2" translate="yes" xml:space="preserve">
          <source>If the table has 32 or fewer columns, a single unsigned integer is output for each phrase in the query. The least significant bit of the integer is set if the phrase appears at least once in column 0. The second least significant bit is set if the phrase appears once or more in column 1. And so on.</source>
          <target state="translated">如果表的列数为32列或更少,则为查询中的每个短语输出一个无符号整数。如果该短语在第0列中至少出现一次,那么整数的最小有效位就会被设置。如果该短语在第1列中出现一次或更多,则设置第二个最小有效位。以此类推。</target>
        </trans-unit>
        <trans-unit id="721c91e5cd9182aa981b27d672f91c90481093e6" translate="yes" xml:space="preserve">
          <source>If the table has more than 32 columns, an extra integer is added to the output of each phrase for each extra 32 columns or part thereof. Integers corresponding to the same phrase are clumped together. For example, if a table with 45 columns is queried for two phrases, 4 integers are output. The first corresponds to phrase 0 and columns 0-31 of the table. The second integer contains data for phrase 0 and columns 32-44, and so on.</source>
          <target state="translated">如果表的列数超过32列,则每多出32列或其中一部分,就在每个短语的输出中增加一个额外的整数。对应于同一短语的整数会聚集在一起。例如,如果一个有45列的表被查询到两个短语,则输出4个整数。第一个整数对应于短语0和表的0-31列。第二个整数包含短语0和第32-44列的数据,以此类推。</target>
        </trans-unit>
        <trans-unit id="dd1a6a322a6da8501607606cd285b56e7643fea3" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xInstCount, xInst, xPhraseFirst and xPhraseNext APIs behave as if the current row contains no phrase matches at all (i.e. xInstCount() returns 0).</source>
          <target state="translated">如果表也是一个无内容表,那么xInstCount、xInst、xPhraseFirst和xPhraseNext API就会表现为当前行根本不包含短语匹配(即xInstCount()返回0)。</target>
        </trans-unit>
        <trans-unit id="6fe44f3588c5a2857dcbb9370708a1c62e0664e1" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xPhraseFirstColumn and xPhraseNextColumn APIs behave as if the current row contains no phrase matches at all (i.e. xPhraseFirstColumn() sets the iterator to EOF).</source>
          <target state="translated">如果表也是一个无内容表,xPhraseFirstColumn和xPhraseNextColumn API的行为就像当前行根本不包含短语匹配一样(即xPhraseFirstColumn()将迭代器设置为EOF)。</target>
        </trans-unit>
        <trans-unit id="8fa583fa8336ae813a54303aa49ca52aa9df3514" translate="yes" xml:space="preserve">
          <source>If the tables are not compatible, SQLITE_SCHEMA is returned. If the tables are compatible but do not have any PRIMARY KEY columns, it is not an error but no changes are added to the session object. As with other session APIs, tables without PRIMARY KEYs are simply ignored.</source>
          <target state="translated">如果表不兼容,则返回SQLITE_SCHEMA。如果表是兼容的,但没有任何PRIMARY KEY列,这不是一个错误,但不会向会话对象添加任何更改。与其他会话API一样,没有PRIMARY KEY的表会被直接忽略。</target>
        </trans-unit>
        <trans-unit id="39d5998574043194036193b1ccfe1d960d708066" translate="yes" xml:space="preserve">
          <source>If the target database table has an INTEGER PRIMARY KEY, it is not possible to insert a NULL value into the IPK column. Attempting to do so results in an SQLITE_MISMATCH error.</source>
          <target state="translated">如果目标数据库表有一个INTEGER PRIMARY KEY,就不能在IPK列中插入一个NULL值。试图这样做会导致一个SQLITE_MISMATCH错误。</target>
        </trans-unit>
        <trans-unit id="9c95a9c982f66790e65014b945cf26e39c71b898" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table that has no PRIMARY KEY declaration, the data_% table must also contain a column named &quot;rbu_rowid&quot;. The rbu_rowid column is mapped to the tables &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. For example, if the target database contains either of the following:</source>
          <target state="translated">如果目标数据库表是虚拟表或没有PRIMARY KEY声明的表，则data_％表还必须包含一个名为&amp;ldquo; rbu_rowid&amp;rdquo;的列。rbu_rowid列映射到表&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;。例如，如果目标数据库包含以下任一：</target>
        </trans-unit>
        <trans-unit id="fbd25358ffefdc6dc4f80487cafab05d3b5b26ee" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table with no PRIMARY KEY, the rbu_control value should not include a character corresponding to the rbu_rowid value. For example, this:</source>
          <target state="translated">如果目标数据库表是一个虚拟表或者是一个没有PRIMARY KEY的表,那么rbu_control值中不应该包含一个与rbu_rowid值相对应的字符。例如,这。</target>
        </trans-unit>
        <trans-unit id="01af3a5676cb2f1557deacfea75c22d3ec69c112" translate="yes" xml:space="preserve">
          <source>If the text fragment does not begin at the start of a column value, the &quot;ellipses&quot; text is prepended to it.</source>
          <target state="translated">如果文本片段不是从列值的开头开始,则在其前面加上 &quot;省略号 &quot;文本。</target>
        </trans-unit>
        <trans-unit id="c5699be55281fc6c124864de2ed79fa2e78862fa" translate="yes" xml:space="preserve">
          <source>If the text fragment does not finish at the end of a column value, the &quot;ellipses&quot; text is appended to it.</source>
          <target state="translated">如果文本片段没有在列值的结尾处结束,则在其上附加 &quot;省略号 &quot;文本。</target>
        </trans-unit>
        <trans-unit id="9b02a2cc603460380751e873e7881c3872500434" translate="yes" xml:space="preserve">
          <source>If the third parameter (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped.</source>
          <target state="translated">如果第三个参数(指向sqlite3_module对象的指针)为NULL,那么就不会创建新的模块,任何现有的同名模块都会被删除。</target>
        </trans-unit>
        <trans-unit id="1fb42f686bdf0ae2d9460cba55a33f179256de59" translate="yes" xml:space="preserve">
          <source>If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.</source>
          <target state="translated">如果两个快照句柄不与同一个数据库文件相关联,那么比较的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="e40d631505df75eada1d7356f623733efe0e7e84" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">如果值N超出范围或第N个参数为无名，则返回NULL。即使最初在&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;中将命名参数指定为UTF-16，返回的字符串始终采用UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="345b60970d744b5b63e874a6cd2300d092b35eca" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">如果值N超出范围或第N个参数为无名，则返回NULL。即使最初在&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;中将命名参数指定为UTF-16，返回的字符串始终采用UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="d68928282b4992ea60ac59e231acaeb89700dde0" translate="yes" xml:space="preserve">
          <source>If the value being substituted is larger than the width, then full value is added to the output. In other words, the width is the minimum width of the value as it is rendered in the output.</source>
          <target state="translated">如果被替换的值大于宽度,那么全值将被添加到输出中。换句话说,宽度是数值在输出中呈现的最小宽度。</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="6f9d3eb4af97233320c8cb8d005d76e733f1eb82" translate="yes" xml:space="preserve">
          <source>If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json1 function (such as &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; or &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; or &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt;) then it is interpreted as JSON and is inserted as JSON retaining all of its substructure.</source>
          <target state="translated">如果路径/值对的值是SQLite TEXT值，则通常将其作为带引号的JSON字符串插入，即使该字符串看起来像有效的JSON。但是，如果该值是另一个json1函数（例如&lt;a href=&quot;json1#jmini&quot;&gt;json（）&lt;/a&gt;或&lt;a href=&quot;json1#jarray&quot;&gt;json_array（）&lt;/a&gt;或&lt;a href=&quot;json1#jobj&quot;&gt;json_object（）&lt;/a&gt;）的结果，则将其解释为JSON并插入为JSON，以保留其所有子结构。</target>
        </trans-unit>
        <trans-unit id="b32ac49b143ce73b794453377ce559efe5961df7" translate="yes" xml:space="preserve">
          <source>If the value of the zString variable is NULL, the generated SQL will look like the following:</source>
          <target state="translated">如果zString变量的值是NULL,那么生成的SQL就会像下面这样。</target>
        </trans-unit>
        <trans-unit id="8161ccbb4f6a18f526e60b92f180512b88485f22" translate="yes" xml:space="preserve">
          <source>If the values &quot;inserted&quot; into the text columns as part of a 'delete' command are not the same as those currently stored within the table, the results may be unpredictable.</source>
          <target state="translated">如果作为 &quot;删除 &quot;命令的一部分,&quot;插入 &quot;到文本列中的值与当前存储在表中的值不一样,那么结果可能是不可预测的。</target>
        </trans-unit>
        <trans-unit id="59bbe3f4e62b07925a07b5a183754aca1009b0a0" translate="yes" xml:space="preserve">
          <source>If the variable does not have a bytearray representation, then &quot;@&quot; works just like &quot;$&quot;. Note that &quot;:&quot; works like &quot;$&quot; in all cases so the following is another way to express the same statement:</source>
          <target state="translated">如果变量没有用字节数组表示,那么&quot;@&quot;就像&quot;$&quot;一样。请注意,&quot;:&quot;在所有情况下都和&quot;$&quot;一样,所以下面是表达相同语句的另一种方式。</target>
        </trans-unit>
        <trans-unit id="967912701ccde0cf6890cfdea463d69721e44f33" translate="yes" xml:space="preserve">
          <source>If the virtual machine is unable to open the database file because it is locked by another thread or process, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_BUSY. The calling function should do some other activity, or sleep, for a short amount of time to give the lock a chance to clear, then invoke &lt;b&gt;sqlite_step&lt;/b&gt; again. This can be repeated as many times as desired.</source>
          <target state="translated">如果虚拟机由于被另一个线程或进程锁定而无法打开数据库文件，则&lt;b&gt;sqlite_step&lt;/b&gt;将返回SQLITE_BUSY。调用函数应该在短时间内进行一些其他活动或睡眠，以使锁有机会被清除，然后再次调用&lt;b&gt;sqlite_step&lt;/b&gt;。可以根据需要将其重复多次。</target>
        </trans-unit>
        <trans-unit id="d0cab5be9268823b532780f4620139e0b2493eda" translate="yes" xml:space="preserve">
          <source>If the virtual table contains one or more rows that match the search criteria, then the cursor must be left point at the first row. Subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero). If there are no rows match, then the cursor must be left in a state that will cause the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; to return true (non-zero). The SQLite engine will use the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods to access that row content. The &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; method will be used to advance to the next row.</source>
          <target state="translated">如果虚拟表包含一个或多个符合搜索条件的行，则光标必须位于第一行的左侧。对&lt;a href=&quot;vtab#xeof&quot;&gt;xEof的&lt;/a&gt;后续调用必须返回false（零）。如果没有匹配的行，则游标必须处于会导致&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;返回true（非零）的状态。 SQLite引擎将使用&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;和&lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt;方法访问该行内容。该&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;方法将被用于推进到下一行。</target>
        </trans-unit>
        <trans-unit id="ad0d9be234c914ee5ff307719c3b70dd43c84d33" translate="yes" xml:space="preserve">
          <source>If the virtual table will output rows in the order specified by the ORDER BY clause, then the orderByConsumed flag may be set to true. If the output is not automatically in the correct order then orderByConsumed must be left in its default false setting. This will indicate to the SQLite core that it will need to do a separate sorting pass over the data after it comes out of the virtual table.</source>
          <target state="translated">如果虚拟表将按照ORDER BY子句指定的顺序输出行,那么orderByConsumed标志可以设置为true。如果输出的顺序不是自动正确的,那么orderByConsumed必须保留其默认的false设置。这将向SQLite核心表明,在数据从虚拟表出来后,它需要对数据进行单独的排序传递。</target>
        </trans-unit>
        <trans-unit id="40852f77f22b22d25b15aa100b0b83a4fb17d34c" translate="yes" xml:space="preserve">
          <source>If the width is a single &quot;*&quot; character instead of a number, then the actual width value is read as an integer from the argument list. If the value read is negative, then the absolute value is used for the width and the value is left-justified as if the &quot;-&quot; flag were present.</source>
          <target state="translated">如果宽度是一个单一的 &quot;*&quot;字符而不是数字,那么实际的宽度值就会从参数列表中读出一个整数。如果读出的值是负数,那么宽度的绝对值就会被使用,并且该值会像&quot;-&quot;标志一样被左对齐。</target>
        </trans-unit>
        <trans-unit id="5f665397e9a7b0fe05142c4eb0f952c2d738840c" translate="yes" xml:space="preserve">
          <source>If the xAccess() query required by H35490 reveals that the journal file is still present in the file system, then SQLite shall conclude that the journal file is a</source>
          <target state="translated">如果H35490所要求的xAccess()查询发现该日志文件仍然存在于文件系统中,那么SQLite应断定该日志文件是一个</target>
        </trans-unit>
        <trans-unit id="2ece4dc60c85bd0f6370651e04aa59f231e6a232" translate="yes" xml:space="preserve">
          <source>If the xColumn method implementation calls none of the functions above, then the value of the column defaults to an SQL NULL.</source>
          <target state="translated">如果xColumn方法的实现没有调用上述任何一个函数,那么该列的值默认为SQL NULL。</target>
        </trans-unit>
        <trans-unit id="df9512eb02b352fc76419bfac69b024afe92a594" translate="yes" xml:space="preserve">
          <source>If the xCreate method is omitted (left as a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;. New instances of the virtual table cannot be created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; and the virtual table can only be used via its module name. Note that SQLite versions prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and will segfault if an attempt is made to &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; on an eponymous-only virtual table because the xCreate method was not checked for null.</source>
          <target state="translated">如果省略xCreate方法（保留为NULL指针），则虚拟表是&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;仅&lt;/a&gt;具有别名的虚拟表。无法使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;创建虚拟表的新实例，并且只能通过其模块名称使用虚拟表。请注意，3.9.0（2015-10-14）之前的SQLite版本无法理解仅具有名称的虚拟表，并且由于未检查xCreate方法而试图在仅具有名称的&lt;a href=&quot;lang_createvtab&quot;&gt;虚拟表&lt;/a&gt;上创建CREATE VIRTUAL TABLE时将出现段错误为空。</target>
        </trans-unit>
        <trans-unit id="2621a8e3fdadffc723f38e49d09955e1039ab97f" translate="yes" xml:space="preserve">
          <source>If the xCreate method is the exact same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, that indicates that the virtual table does not need to initialize backing store. Such a virtual table can be used as an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; or as a named virtual table using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; or both.</source>
          <target state="translated">如果xCreate方法是完全相同的指针作为&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法，指示该虚拟表不需要初始化后备存储器。这样的虚拟表可以用作&lt;a href=&quot;vtab#epovtab&quot;&gt;同义虚拟表&lt;/a&gt;或使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;或同时用作命名虚拟表。</target>
        </trans-unit>
        <trans-unit id="1ea6013e86112c06dab3e4770a560b43808bcc0c" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">如果xEntryPoint例程遇到错误，则应使* pzErrMsg指向适当的错误消息（从&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;获得），并返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。在调用xEntryPoint（）之前，SQLite确保* pzErrMsg为NULL。xEntryPoint（）返回后，SQLite将在* pzErrMsg上调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;。如果任何xEntryPoint（）返回错误，则引发xEntryPoint（）的&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;调用将失败。</target>
        </trans-unit>
        <trans-unit id="f84dff46c33beaf54e0ca4079880cc37a3fce130" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">如果xEntryPoint例程遇到错误，则应使* pzErrMsg指向适当的错误消息（从&lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;获得），并返回适当的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。在调用xEntryPoint（）之前，SQLite确保* pzErrMsg为NULL。xEntryPoint（）返回后，SQLite将在* pzErrMsg上调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;。如果任何xEntryPoint（）返回错误，则引发xEntryPoint（）的&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;调用将失败。</target>
        </trans-unit>
        <trans-unit id="74fa84b64e4977d1c29908e0f6708d6d082c0af7" translate="yes" xml:space="preserve">
          <source>If the xUpdate method is performing an UPDATE, then &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; can be used to discover which columns of the virtual table were actually modified by the UPDATE statement. The &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; interface returns true for columns that do not change. On every UPDATE, SQLite will first invoke &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; separately for each unchanging column in the table to obtain the value for that column. The &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method can check to see if the column is unchanged at the SQL level by invoking &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt;. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; sees that the column is not being modified, it should return without setting a result using one of the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces. Only in that case &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; will be true within the xUpdate method. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; does invoke one or more &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces, then SQLite understands that as a change in the value of the column and the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; call for that column within xUpdate will return false.</source>
          <target state="translated">如果xUpdate方法正在执行UPDATE，则可以使用&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;来发现UPDATE语句实际修改了虚拟表的哪些列。该&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;接口返回true为不更改列。在每个UPDATE上，SQLite将首先为表中的每个不变列分别调用&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;以获得该列的值。该&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法可以检查，看看是否列不变在SQL级别通过调用&lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange（）。&lt;/a&gt;如果&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;看到未修改该列，则应使用&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx（）&lt;/a&gt;之一返回而不设置结果接口。只有在这种情况下，在xUpdate方法中&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（）才&lt;/a&gt;为true。如果&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;确实调用了一个或多个&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx（）&lt;/a&gt;接口，则SQLite会理解，作为列值的更改，xUpdate 中对该列的&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（）&lt;/a&gt;调用将返回false。</target>
        </trans-unit>
        <trans-unit id="7b85064db380f0c3b1175d1e7fe24a5bdf881bd8" translate="yes" xml:space="preserve">
          <source>If the xUpdate method violates some constraint of the virtual table (including, but not limited to, attempting to store a value of the wrong datatype, attempting to store a value that is too large or too small, or attempting to change a read-only value) then the xUpdate must fail with an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果xUpdate方法违反了虚拟表的某些约束（包括但不限于尝试存储错误数据类型的值，尝试存储太大或太小的值或尝试更改只读值值），则xUpdate必须失败，并带有相应的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a7985513fccd145b507f142e6f37dfce68e7177" translate="yes" xml:space="preserve">
          <source>If the zString variable holds text like &quot;Hello&quot;, then this statement will work just fine. But suppose the user enters a string like &quot;Hi y'all!&quot;. The SQL statement generated reads as follows:</source>
          <target state="translated">如果zString变量中存放的是 &quot;你好 &quot;这样的文本,那么这条语句就能正常工作。但假设用户输入的是 &quot;你们好!&quot;这样的字符串。生成的SQL语句如下。</target>
        </trans-unit>
        <trans-unit id="38c9c0042a5b1d208534216bf07dfb6099f9ebb4" translate="yes" xml:space="preserve">
          <source>If there are many client programs sending SQL to the same database over a network, then use a client/server database engine instead of SQLite. SQLite will work over a network filesystem, but because of the latency associated with most network filesystems, performance will not be great. Also, file locking logic is buggy in many network filesystem implementations (on both Unix and Windows). If file locking does not work correctly, two or more clients might try to modify the same part of the same database at the same time, resulting in corruption. Because this problem results from bugs in the underlying filesystem implementation, there is nothing SQLite can do to prevent it.</source>
          <target state="translated">如果有很多客户端程序通过网络向同一个数据库发送SQL,那么就用客户端/服务器数据库引擎代替SQLite。SQLite可以在网络文件系统上工作,但由于大多数网络文件系统的延迟,性能不会很好。此外,在许多网络文件系统实现中,文件锁定逻辑是错误的(在Unix和Windows上)。如果文件锁定不能正常工作,两个或更多的客户端可能会试图同时修改同一数据库的同一部分,从而导致损坏。因为这个问题是由底层文件系统实现中的错误导致的,所以SQLite无法阻止这个问题的发生。</target>
        </trans-unit>
        <trans-unit id="36f4c3a2fda5cf31617c5fabae95e90bafd39057" translate="yes" xml:space="preserve">
          <source>If there are multiple (hard or symbolic) links to a database file, the journal will be created using the name of the link through which the file was opened. If a crash occurs and the database is opened again using a different link, the hot journal will not be located and no rollback will occur.</source>
          <target state="translated">如果一个数据库文件有多个(硬链接或符号)链接,将使用打开文件的链接名称创建日志。如果发生崩溃,使用不同的链接再次打开数据库,热日志将无法找到,也不会发生回滚。</target>
        </trans-unit>
        <trans-unit id="11044e3b942016886a776e1bab1892306cb966d9" translate="yes" xml:space="preserve">
          <source>If there are still more pages to copy from database pDb, then the function sleeps for 250 milliseconds (using the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; utility) and then returns to step 2.</source>
          <target state="translated">如果还有更多页面要从数据库pDb复制，则该函数休眠250毫秒（使用&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;实用程序），然后返回到步骤2。</target>
        </trans-unit>
        <trans-unit id="afce5a653d0b42c7793177067bc50ad86675aae0" translate="yes" xml:space="preserve">
          <source>If there exists an index that maps the &quot;two&quot; column of the &quot;examp&quot; table into integers, then SQLite will use that index to find the integer keys of all rows in examp that have a value of 50 for column two, or all rows that are less than 50, etc. But the following queries cannot use the index:</source>
          <target state="translated">如果存在一个索引,将 &quot;examp &quot;表的 &quot;二 &quot;列映射成整数,那么SQLite就会使用这个索引来查找examp中所有二列值为50的行的整数键,或者所有小于50的行等。但是下面的查询不能使用该索引。</target>
        </trans-unit>
        <trans-unit id="856948c8edddeced0c9cafe3bd0f42f4ee0fc501" translate="yes" xml:space="preserve">
          <source>If there has been one or more REPLACE resolutions on a key, it is rebased according to a REPLACE.</source>
          <target state="translated">如果一个键上已经有一个或多个REPLACE决议,则根据REPLACE进行重新计算。</target>
        </trans-unit>
        <trans-unit id="4dc77fa5e92703a982360848038ee795cce33659" translate="yes" xml:space="preserve">
          <source>If there have been no REPLACE resolutions on a key, then the local changeset is rebased according to the most recent of the OMIT resolutions.</source>
          <target state="translated">如果在一个键上没有REPLACE的决议,那么本地的变化集将根据最近的OMIT决议来重新计算。</target>
        </trans-unit>
        <trans-unit id="b7ee1d4caced0cc280acbdfbbd3da7974e0aedc7" translate="yes" xml:space="preserve">
          <source>If there is a USING clause then each of the column names specified must exist in the datasets to both the left and right of the join-operator. For each pair of named columns, the expression &quot;lhs.X = rhs.X&quot; is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which all such expressions evaluates to true are included from the result set. When comparing values as a result of a USING clause, the normal rules for handling affinities, collation sequences and NULL values in comparisons apply. The column from the dataset on the left-hand side of the join-operator is considered to be on the left-hand side of the comparison operator (=) for the purposes of collation sequence and affinity precedence.</source>
          <target state="translated">如果有USING子句，则指定的每个列名都必须存在于join-operator左侧和右侧的数据集中。对于每对命名列，对于笛卡尔乘积的每一行，将表达式&amp;ldquo; lhs.X = rhs.X&amp;rdquo;作为&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式&lt;/a&gt;进行求值。结果集中仅包含所有此类表达式求值为true的行。当比较作为USING子句的结果的值时，适用处理比较中的亲和力，排序规则序列和NULL值的常规规则。出于排序顺序和相似性优先顺序的考虑，联接运算符左侧的数据集中的列被视为位于比较运算符（=）的左侧。</target>
        </trans-unit>
        <trans-unit id="d234388212b95e999640f17f4b156605cf6f600f" translate="yes" xml:space="preserve">
          <source>If there is already a read transaction open when this function is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR, SQLITE_BUSY or SQLITE_ERROR_SNAPSHOT is returned. If another error code - for example SQLITE_PROTOCOL or an SQLITE_IOERR error code - is returned, then the final state of the read transaction is undefined. If SQLITE_OK is returned, then the read transaction is now open on database snapshot P.</source>
          <target state="translated">如果在调用这个函数时已经有一个读事务被打开,那么如果返回SQLITE_ERROR、SQLITE_BUSY或SQLITE_ERROR_SNAPSHOT,那么同一个读事务仍然被打开(在同一个数据库快照上)。如果返回了另一个错误代码--例如SQLITE_PROTOCOL或SQLITE_IOERR错误代码,那么读事务的最终状态是未定义的。如果返回SQLITE_OK,那么读事务现在已经在数据库快照P上打开。</target>
        </trans-unit>
        <trans-unit id="b3ba606d14be7904e644a6f345ba54604a8e5ba7" translate="yes" xml:space="preserve">
          <source>If there is already an auxiliary data pointer when this function is invoked, then it is replaced by the new pointer. If an xDelete callback was specified along with the original pointer, it is invoked at this point.</source>
          <target state="translated">如果在调用这个函数时,已经有一个辅助数据指针,那么它将被新的指针替换。如果xDelete回调与原始指针一起被指定,那么它将在此时被调用。</target>
        </trans-unit>
        <trans-unit id="7d3f7f6da384d18458af17b6bbb473e63bd6c0a4" translate="yes" xml:space="preserve">
          <source>If there is an AS clause on the result, then the name of the column is the right-hand side of the AS clause.</source>
          <target state="translated">如果结果上有一个AS子句,那么列的名称就是AS子句的右侧。</target>
        </trans-unit>
        <trans-unit id="ea4985ea47701fb618426a82280d62d99731524f" translate="yes" xml:space="preserve">
          <source>If there is an ON clause then the ON expression is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the expression evaluates to true are included from the dataset.</source>
          <target state="translated">如果存在ON子句，则将笛卡尔乘积的每一行作为&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式&lt;/a&gt;评估ON 表达式。数据集中仅包含表达式评估为true的行。</target>
        </trans-unit>
        <trans-unit id="2e70dfed6b6c48ce8dce24e64f939fa0229381a9" translate="yes" xml:space="preserve">
          <source>If there is no compatible table, it is not an error, but none of the changes associated with the table are applied. A warning message is issued via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At most one such warning is issued for each table in the changeset.</source>
          <target state="translated">如果没有兼容的表,这不是一个错误,但与表相关的变化都不会被应用。通过sqlite3_log()机制发出一条警告信息,错误代码为SQLITE_SCHEMA。对于变化集中的每个表,最多发出一个这样的警告。</target>
        </trans-unit>
        <trans-unit id="8b1f218c8fcc4cd8280015ffb23038ba539a45b9" translate="yes" xml:space="preserve">
          <source>If there is no index named</source>
          <target state="translated">如果没有名为</target>
        </trans-unit>
        <trans-unit id="5f851a7381e365ca34ec1852c08b2f940f8860fc" translate="yes" xml:space="preserve">
          <source>If there is no selftest table, the &quot;.selftest&quot; command runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;.</source>
          <target state="translated">如果没有自检表，则&amp;ldquo; .selftest&amp;rdquo;命令运行&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c042772d4bc73bd02a9ce067deaf034251147e0f" translate="yes" xml:space="preserve">
          <source>If there is only a single table or subquery in the FROM clause, then the input data used by the SELECT statement is the contents of the named table. If there is more than one table or subquery in FROM clause then the contents of all tables and/or subqueries are joined into a single dataset for the simple SELECT statement to operate on. Exactly how the data is combined depends on the specific &lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator&lt;/a&gt; and &lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint&lt;/a&gt; used to connect the tables or subqueries together.</source>
          <target state="translated">如果FROM子句中只有一个表或子查询，则SELECT语句使用的输入数据就是命名表的内容。如果FROM子句中有多个表或子查询，则所有表和/或子查询的内容都将合并到一个数据集中，以使简单的SELECT语句可以操作。数据的确切组合方式取决于用于将表或子查询连接在一起的特定联接&lt;a href=&quot;syntax/join-operator&quot;&gt;运算符&lt;/a&gt;和联接&lt;a href=&quot;syntax/join-constraint&quot;&gt;约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c64aa9b4e57f38edc6d2ba80d1689a5d372c4ee" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">如果这些例程是在不同于包含接收&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt;指针的应用程序定义函数的线程中调用的，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="cd8848554ca2d7f3d01b722c239f1dc6287ba93f" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">如果这些例程是在不同于包含接收&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt;指针的应用程序定义函数的线程中调用的，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="915164f8017ef4e64adbf0d45fa62da4e11e9b32" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro disables the &quot;deferred token&quot; optimization in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;. The &quot;deferred token&quot; optimization avoids loading massive posting lists for terms that are in most documents of the collection and instead simply scans for those tokens in the document source. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; should get exactly the same answer both with and without this optimization.</source>
          <target state="translated">如果此C预处理器宏禁用&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4中&lt;/a&gt;的&amp;ldquo;延迟令牌&amp;rdquo;优化。 &amp;ldquo;递延令牌&amp;rdquo;优化避免了为集合的大多数文档中的术语加载大量的过帐列表，而只是在文档源中扫描这些令牌。无论是否进行此优化，&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;都应获得完全相同的答案。</target>
        </trans-unit>
        <trans-unit id="ae29c8f0136956324cb9875e314002993d7a9c98" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined and if the xDeviceCharacteristics method of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object for a database file reports (via one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits) that the filesystem supports atomic writes and if a transaction involves a change to only a single page of the database file, then the transaction commits with just a single write request of a single page of the database and no rollback journal is created or written. On filesystems that support atomic writes, this optimization can result in significant speed improvements for small updates. However, few filesystems support this capability and the code paths that check for this capability slow down write performance on systems that lack atomic write capability, so this feature is disabled by default.</source>
          <target state="translated">如果定义了此C预处理器宏，并且数据库文件的&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xDeviceCharacteristics方法报告（通过&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt;位之一）报告该文件系统支持原子写入，并且如果事务仅涉及更改数据库的单个页面，文件，则仅提交数据库单页的单个写入请求，就不会提交或写入回滚日志，而提交事务。在支持原子写入的文件系统上，此优化可以显着提高小型更新的速度。但是，很少有文件系统支持此功能，并且检查此功能的代码路径会降低缺少原子写功能的系统上的写性能，因此默认情况下禁用此功能。</target>
        </trans-unit>
        <trans-unit id="f74239b5b9713fd263bba27dcb07765bb74b0239" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, directory syncs are disabled. SQLite typically attempts to sync the parent directory when a file is deleted to ensure the directory entries are updated immediately on disk.</source>
          <target state="translated">如果定义了这个C-preprocessor宏,则禁用目录同步。SQLite通常会在文件被删除时尝试同步父目录,以确保目录项在磁盘上立即更新。</target>
        </trans-unit>
        <trans-unit id="5737b83035ce500dcfa496d2b2b66e0845cad862" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, large file support is disabled.</source>
          <target state="translated">如果定义了这个C-preprocessor宏,则禁用大文件支持。</target>
        </trans-unit>
        <trans-unit id="262e2217c94b5b2f3ea64e55aebf18183a8f388a" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; is omitted from the build and is unavailable to applications.</source>
          <target state="translated">如果定义了此C预处理程序宏，则&lt;a href=&quot;fts3&quot;&gt;FTS3中&lt;/a&gt;的&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt;标记化器将从构建中省略，并且对应用程序不可用。</target>
        </trans-unit>
        <trans-unit id="39617688d9840b06235bc5d306b07bb0ba889ba9" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, then extra code is included that allows SQLite to function on a filesystem that only support 8+3 filenames. If the value of this macro is 1, then the default behavior is to continue to use long filenames and to only use 8+3 filenames if the database connection is opened using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; with the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter. If the value of this macro is 2, then the use of 8+3 filenames becomes the default but may be disabled on using the &lt;code&gt;8_3_names=0&lt;/code&gt; query parameter.</source>
          <target state="translated">如果定义了此C预处理器宏，则将包含额外的代码，这些代码使SQLite可以在仅支持8 + 3文件名的文件系统上运行。如果此宏的值为1，则默认行为是继续使用长文件名，并且如果使用带有&amp;ldquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &amp;rdquo;查询参数的&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;打开数据库连接，则默认行为是仅使用8 + 3文件名。如果此宏的值为2，则默认使用8 + 3文件名，但在使用 &lt;code&gt;8_3_names=0&lt;/code&gt; 查询参数时可能会被禁用。</target>
        </trans-unit>
        <trans-unit id="ad3d89f2752a79cf47c58e04a726219583d11898" translate="yes" xml:space="preserve">
          <source>If this SELECT returns any rows at all, then SQLite concludes that deleting the row from the parent table would violate the foreign key constraint and returns an error. Similar queries may be run if the content of the parent key is modified or a new row is inserted into the parent table. If these queries cannot use an index, they are forced to do a linear scan of the entire child table. In a non-trivial database, this may be prohibitively expensive.</source>
          <target state="translated">如果这个SELECT根本没有返回任何行,那么SQLite就会得出结论,从父表中删除该行会违反外键约束,并返回一个错误。如果修改了父键的内容,或者在父表中插入了新的记录,则可能会运行类似的查询。如果这些查询不能使用索引,就会被迫对整个子表进行线性扫描。在一个非平凡的数据库中,这可能是非常昂贵的。</target>
        </trans-unit>
        <trans-unit id="1a76560d5f1317c75f52d66cf33f56778e31d3b4" translate="yes" xml:space="preserve">
          <source>If this expression returns a non-zero value N, then there exists an embedded NUL at the N-th character position. Thus to count the number fo rows that contain embedded NUL characters:</source>
          <target state="translated">如果这个表达式返回一个非零值N,那么在第N个字符的位置上存在一个嵌入的NUL。因此要计算包含内嵌NUL字符的行数fo。</target>
        </trans-unit>
        <trans-unit id="5f0db89932b716eb4d510a7bedc168db8c08402a" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with -DSQLITE_CKSUMVFS_STATIC and statically linked against the application, initialize it using a single API call as follows:</source>
          <target state="translated">如果该扩展使用-DSQLITE_CKSUMVFS_STATIC编译,并对应用程序进行静态链接,则使用一个API调用对其进行初始化,如下所示。</target>
        </trans-unit>
        <trans-unit id="d8ee4bc759bb4de0d55341a4133e995c0e985e4b" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol defined, then there exists a built-in tokenizer named &quot;icu&quot; implemented using the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h) of this tokenizer may be an ICU locale identifier. For example &quot;tr_TR&quot; for Turkish as used in Turkey, or &quot;en_AU&quot; for English as used in Australia. For example:</source>
          <target state="translated">如果这个扩展在编译时定义了SQLITE_ENABLE_ICU预处理器符号,那么就存在一个名为 &quot;icu &quot;的内置tokenizer,它是使用ICU库实现的。传递给 xCreate()方法 (参见 fts3_tokenizer.h)的第一个参数可以是一个 ICU 本地化标识符。例如,&quot;tr_TR &quot;代表土耳其语,在土耳其使用;&quot;en_AU &quot;代表英语,在澳大利亚使用。举例来说。</target>
        </trans-unit>
        <trans-unit id="d023458a29576f7575443a7b9afec6275af3fcf1" translate="yes" xml:space="preserve">
          <source>If this function is called when the iterator does not point to a valid entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise, SQLITE_OK is returned and the output variables populated as described above.</source>
          <target state="translated">如果这个函数在迭代器没有指向一个有效的条目时被调用,则返回SQLITE_MISUSE,并将输出变量清零。否则,将返回SQLITE_OK,并如上所述填充输出变量。</target>
        </trans-unit>
        <trans-unit id="575c4fba56a8b3b5c139b07c2f0bb05a15bdbd1b" translate="yes" xml:space="preserve">
          <source>If this function needs to obtain extra database locks before dirty pages can be flushed to disk, it does so. If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner. If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database. If any databases are skipped because locks cannot be obtained, but no other error occurs, this function returns SQLITE_BUSY.</source>
          <target state="translated">如果这个函数需要在脏页被刷新到磁盘之前获得额外的数据库锁,它就会这样做。如果不能立即获得这些锁,并且配置了一个忙处理回调,则以通常的方式调用该函数。如果仍然无法获得所需的锁,则跳过数据库,并尝试将属于下一个(如果有的话)数据库的任何脏页刷新。如果因为无法获得锁而跳过任何数据库,但没有发生其他错误,则该函数返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="4a59fbb2ab0548034e0f0c93999e3d83e86e0a83" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">如果使此全局变量指向一个字符串，该字符串是文件夹（即目录）的名称，则将假定所有使用相对路径名指定并由SQLite使用内置Windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt;创建或访问的数据库文件都可以相对于该目录。如果此变量是NULL指针，则SQLite假定使用相对路径名指定的所有数据库文件都相对于该进程的当前目录。仅Windows VFS使用此全局变量。 Unix VFS会忽略它。</target>
        </trans-unit>
        <trans-unit id="84ebd8e9c186529f8ee21c34bc9c7d688ed08739" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">如果使此全局变量指向一个字符串，该字符串是文件夹（即目录）的名称，则将假定所有使用相对路径名指定并由SQLite使用内置Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;创建或访问的数据库文件都可以相对于该目录。如果此变量是NULL指针，则SQLite假定使用相对路径名指定的所有数据库文件都相对于该进程的当前目录。仅Windows VFS使用此全局变量。 Unix VFS会忽略它。</target>
        </trans-unit>
        <trans-unit id="ae61adf99b3e9cfc86e28932de2b54c5d4c9e28e" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">如果使此全局变量指向一个字符串，该字符串是文件夹（也称为目录）的名称，则SQLite在使用内置&lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt;时创建的所有临时文件都将放置在该目录中。如果此变量是NULL指针，则SQLite将搜索适当的临时文件目录。</target>
        </trans-unit>
        <trans-unit id="2fef70c16016d67dc3025afd347c1e52be3b317a" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">如果使此全局变量指向一个字符串，该字符串是文件夹（也称为目录）的名称，则SQLite在使用内置&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;时创建的所有临时文件都将放置在该目录中。如果此变量是NULL指针，则SQLite将搜索适当的临时文件目录。</target>
        </trans-unit>
        <trans-unit id="377f589c93b8d1620f4832f74e589324c623fda3" translate="yes" xml:space="preserve">
          <source>If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.</source>
          <target state="translated">如果在xConnect或xCreate虚拟表方法的上下文之外调用该接口,那么行为将未定义。</target>
        </trans-unit>
        <trans-unit id="16ae3ddca07ff1751105a0aea6145c79101d244a" translate="yes" xml:space="preserve">
          <source>If this macro is defined to a positive integer</source>
          <target state="translated">如果这个宏定义为正整数,那么就会出现这样的情况</target>
        </trans-unit>
        <trans-unit id="5cc647c8428edf625b094fb0de5d9a7c439f06d1" translate="yes" xml:space="preserve">
          <source>If this macro is defined, then the special &quot;$</source>
          <target state="translated">如果定义了这个宏,那么特殊的&quot;$?</target>
        </trans-unit>
        <trans-unit id="53c0130971cedde038e298ffc488f5a86580ab11" translate="yes" xml:space="preserve">
          <source>If this option is defined, SQLite's built-in date and time manipulation functions are omitted. Specifically, the SQL functions julianday(), date(), time(), datetime() and strftime() are not available. The default column values CURRENT_TIME, CURRENT_DATE and CURRENT_TIMESTAMP are still available.</source>
          <target state="translated">如果定义了这个选项,SQLite的内置日期和时间操作函数就会被省略。具体来说,SQL函数julianday()、date()、time()、datetime()和strftime()不可用。默认的列值CURRENT_TIME、CURRENT_DATE和CURRENT_TIMESTAMP仍然可用。</target>
        </trans-unit>
        <trans-unit id="3a2de06267117d8a8013c26631a2b4a79f2165b1" translate="yes" xml:space="preserve">
          <source>If this option is defined, the library cannot create or write to databases that support &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;. Executing a &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; statement is not an error (since unknown PRAGMAs are silently ignored), but does not return a value or modify the auto-vacuum flag in the database file. If a database that supports auto-vacuum is opened by a library compiled with this option, it is automatically opened in read-only mode.</source>
          <target state="translated">如果定义了此选项，则库无法创建或写入支持&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum的&lt;/a&gt;数据库。执行&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt;语句不是错误（因为未知PRAGMA会被静默忽略），但是不会返回值或修改数据库文件中的auto-vacuum标志。如果使用此选项编译的库打开了支持自动真空的数据库，则它将以只读模式自动打开。</target>
        </trans-unit>
        <trans-unit id="0d1cff91ceb786cc24acfd1c107d786b9aaa0367" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">如果定义了此选项，则无法识别&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;语法。</target>
        </trans-unit>
        <trans-unit id="6e68b63912f5ef9b57357a53a1d6030e0a438ede" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">如果定义了此选项，则无法识别&lt;a href=&quot;gencol&quot;&gt;生成的列&lt;/a&gt;语法。</target>
        </trans-unit>
        <trans-unit id="de1fe97e82a4364864c18ee6d16ca1ab17fe291c" translate="yes" xml:space="preserve">
          <source>If this option is defined, then it must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate a parse.c file. Because of this, this option may only be used when the library is built from source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the collection of pre-packaged C files provided for non-Unix like platforms on the website.</source>
          <target state="translated">如果定义了此选项，则在使用&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器&lt;/a&gt;工具生成parse.c文件时，也必须定义它。因此，仅当从源而不是通过&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;或从网站上为非Unix平台提供的预打包C文件集合构建库时，才可以使用此选项。</target>
        </trans-unit>
        <trans-unit id="391001eddc6a6f9380d8efca6c5990bffd30c02d" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only only works, of course, on systems that support alloca().</source>
          <target state="translated">如果启用了这个选项,那么将在少数合适的情况下使用 alloca()内存分配器。这样一来,二进制文件就会稍微小一些,速度也快一些。当然,SQLITE_USE_ALLOCA编译时只在支持alloca()的系统上有效。</target>
        </trans-unit>
        <trans-unit id="0a7cb0c994326370629ee23298fc6078fa599fa4" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only works, of course, on systems that support alloca().</source>
          <target state="translated">如果启用了这个选项,那么将在少数合适的情况下使用 alloca()内存分配器。这样一来,二进制文件就会稍微小一些,速度也快一些。当然,SQLITE_USE_ALLOCA编译时只在支持 alloca()的系统上工作。</target>
        </trans-unit>
        <trans-unit id="e396be7869391838487d1744007a3e656f8af09d" translate="yes" xml:space="preserve">
          <source>If this option is passed a non-zero argument, the &quot;.expert&quot; command generates similar data distribution statistics for all indexes considered based on PERCENT percent of the rows currently stored in each database table. For databases with unusual data distributions, this may lead to better index recommendations, particularly if the application intends to run ANALYZE.</source>
          <target state="translated">如果这个选项被传递一个非零的参数,&quot;.expert &quot;命令就会根据每个数据库表中当前存储的行数的percent百分比为所有被考虑的索引生成类似的数据分布统计。对于具有不寻常数据分布的数据库,这可能会带来更好的索引推荐,特别是当应用程序打算运行ANALYZE时。</target>
        </trans-unit>
        <trans-unit id="84432c7bc70fca55a254f66874dd4bc62fe9abea" translate="yes" xml:space="preserve">
          <source>If this option is present, then SQLite will use the isnan() function from the system math library. This is an alias for the &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; configuration option.</source>
          <target state="translated">如果存在此选项，则SQLite将使用系统数学库中的isnan（）函数。这是&lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt;配置选项的别名。</target>
        </trans-unit>
        <trans-unit id="8be490fe1c118ec4e22a3ceeab9a17451a39a86c" translate="yes" xml:space="preserve">
          <source>If this option is present, then the built-in &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator will be case sensitive. This same effect can be achieved at run-time using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">如果存在此选项，则内置的&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符将区分大小写。使用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;可以在运行时实现相同的效果。</target>
        </trans-unit>
        <trans-unit id="ada121bcb0877b4a8c48986ff56dc5ba81d63e98" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">如果先前未调用此例程，或者如果先前的调用的N小于1或P的NULL指针，则使用从默认&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xRandomness方法获得的随机性来种子PRNG 。如果对该程序的上一次调用的N为1或更大，并且P为非NULL，则在内部生成伪随机性，而无需使用&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness方法。</target>
        </trans-unit>
        <trans-unit id="37bc48a662f5023c1e8434007284ca1643b9979a" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">如果先前未调用此例程，或者如果先前的调用的N小于1或P的NULL指针，则使用从默认&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xRandomness方法获得的随机性来种子PRNG 。如果对该程序的上一次调用的N为1或更大，并且P为非NULL，则在内部生成伪随机性，而无需使用&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness方法。</target>
        </trans-unit>
        <trans-unit id="7e75d3fd5002bfcaea7e83bd9fd2a7a917209184" translate="yes" xml:space="preserve">
          <source>If this value is returned, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_ABORT.</source>
          <target state="translated">如果返回这个值,那么到目前为止应用的任何更改都会被回滚,并且调用 sqlite3changeset_apply()返回 SQLITE_ABORT。</target>
        </trans-unit>
        <trans-unit id="aefcb4f212e79bade6ab9e99069db614c4e4b2ca" translate="yes" xml:space="preserve">
          <source>If tracing is enabled (by the sqlite3_trace()) interface, then the UTF-8 string contained in P4 is emitted on the trace callback. Or if P4 is blank, use the string returned by sqlite3_sql().</source>
          <target state="translated">如果跟踪是启用的(由sqlite3_trace())接口,那么P4中包含的UTF-8字符串会在跟踪回调时发出。如果P4为空,则使用sqlite3_sql()返回的字符串。</target>
        </trans-unit>
        <trans-unit id="3f4fc8020e070710f30d36574cc04f57550a8abc" translate="yes" xml:space="preserve">
          <source>If two database connections shared the same cache and the reader has enabled the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt;, then the reader will be able to see changes made by the writer before the writer transaction commits. The combined use of &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is the only way that one database connection can see uncommitted changes on a different database connection. In all other circumstances, separate database connections are completely isolated from one another.</source>
          <target state="translated">如果两个数据库连接共享相同的缓存，并且读取器启用了&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;，那么读取器将能够在写入器事务提交之前看到写入器所做的更改。&lt;a href=&quot;sharedcache&quot;&gt;共享高速缓存模式&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;的组合使用是一个数据库连接可以看到不同数据库连接上未提交的更改的唯一方法。在所有其他情况下，单独的数据库连接彼此完全隔离。</target>
        </trans-unit>
        <trans-unit id="b41151cd8ed57f8a05f71e68d3e6f727b509adc0" translate="yes" xml:space="preserve">
          <source>If two or more distinct but shareable in-memory databases are needed in a single process, then the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter can be used with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; to create a named in-memory database:</source>
          <target state="translated">如果在单个过程中需要两个或多个不同但可共享的内存数据库，则可以将&lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt;查询参数与&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;一起使用，以创建一个命名的内存数据库：</target>
        </trans-unit>
        <trans-unit id="7c051c04a74b426b583f6b46003048b9ec27b20e" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">如果两个或多个线程同时为相同的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;预处理语句&lt;/a&gt;和结果列调用一个或多个&lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;列元数据接口&lt;/a&gt;，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="3f3b1a7191faa957bd4b9a2df637334c8be60539" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">如果两个或多个线程同时为相同的&lt;a href=&quot;stmt&quot;&gt;预处理语句&lt;/a&gt;和结果列调用一个或多个&lt;a href=&quot;column_database_name&quot;&gt;列元数据接口&lt;/a&gt;，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="f59e0a816231da9addc2b58ecf1aebf4318f03f1" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined.</source>
          <target state="translated">如果两个或多个线程同时针对同一个准备好的语句和列调用其中的一个或多个例程,那么结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="47c7553b72e9db086338dfa731f7055b973ce5ac" translate="yes" xml:space="preserve">
          <source>If two processes have open connections to the same database file and one process closes its connection, unlinks the file, then creates a new database file in its place with the same name and reopens the new file, then the two processes will be talking to different database files with the same name. (Note that this is only possible on Posix and Posix-like systems that permit a file to be unlinked while it is still open for reading and writing. Windows does not allow this to occur.) Since rollback journals and WAL files are based on the name of the database file, the two different database files will share the same rollback journal or WAL file. A rollback or recovery for one of the databases might use content from the other database, resulting in corruption. A similar problem occurs if a database file is renamed while it is opened and a new file is created with the old name.</source>
          <target state="translated">如果两个进程对同一个数据库文件有开放的连接,而其中一个进程关闭了它的连接,解除了文件的链接,然后在它的位置上创建了一个新的同名数据库文件,并重新打开了新的文件,那么这两个进程将与不同的同名数据库文件对话。(请注意,只有在Posix和类似Posix的系统上才可能发生这种情况,因为这些系统允许在文件仍处于打开读写状态时解除链接。Windows不允许这样做)。)由于回滚日志和WAL文件是基于数据库文件的名称,两个不同的数据库文件将共享同一个回滚日志或WAL文件。其中一个数据库的回滚或恢复可能会使用另一个数据库的内容,从而导致损坏。如果数据库文件在打开时被重新命名,并以旧名创建新文件,也会出现类似问题。</target>
        </trans-unit>
        <trans-unit id="0f73506a4d083541e30151f33df9ff76bf05c8d1" translate="yes" xml:space="preserve">
          <source>If using the MATCH or = operators, the expression to the left of the MATCH operator is usually the name of the FTS5 table (the exception is when &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;specifying a column-filter&lt;/a&gt;). The expression on the right must be a text value specifying the term to search for. For the table-valued function syntax, the term to search for is specified as the first table argument. For example:</source>
          <target state="translated">如果使用MATCH或=运算符，则MATCH运算符左侧的表达式通常是FTS5表的名称（&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;指定column-filter&lt;/a&gt;时例外）。右边的表达式必须是一个文本值，指定要搜索的术语。对于表值函数语法，将要搜索的术语指定为第一个表参数。例如：</target>
        </trans-unit>
        <trans-unit id="10c759f053d61c7e03ff959d29d1e1974783d209" translate="yes" xml:space="preserve">
          <source>If using the MinGW compiler, the command-line is this:</source>
          <target state="translated">如果使用MinGW编译器,命令行是这样的。</target>
        </trans-unit>
        <trans-unit id="06877745f4f906674e7afae07a31cb3adf870f29" translate="yes" xml:space="preserve">
          <source>If using the amalgamation autoconf based build system, setting the CPPFLAGS environment variable while running the 'configure' script is an easy way to set these macros. For example, the following command:</source>
          <target state="translated">如果使用基于amalgamation autoconf的构建系统,在运行 &quot;configure &quot;脚本时设置CPPFLAGS环境变量是设置这些宏的简单方法。例如,下面的命令。</target>
        </trans-unit>
        <trans-unit id="c06d03a70a5b876ea7069032c87d9367a09e46c5" translate="yes" xml:space="preserve">
          <source>If when you try to load your library you get back an error message that says &quot;mach-o, but wrong architecture&quot; then you might need to add command-line options &quot;-arch i386&quot; or &quot;arch x86_64&quot; to gcc, depending on how your application is built.</source>
          <target state="translated">如果当你试图加载你的库时,你得到的错误信息是 &quot;mach-o,但架构错误&quot;,那么你可能需要在gcc中添加命令行选项&quot;-arch i386 &quot;或 &quot;arch x86_64&quot;,这取决于你的应用程序是如何构建的。</target>
        </trans-unit>
        <trans-unit id="7cf9b897ab48ed18b82e59ac2a561abc36b27d81" translate="yes" xml:space="preserve">
          <source>If while attempting to detect a</source>
          <target state="translated">如果在试图检测一个</target>
        </trans-unit>
        <trans-unit id="56ea56ee57997f44a3b4181f1b3a8efe3168e325" translate="yes" xml:space="preserve">
          <source>If xBestIndex returns &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, that does not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular combination of input parameters specified should not be used in the query plan. The SQLITE_CONSTRAINT return is useful for &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that have required parameters. If the aConstraint[].usable field is false for one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.</source>
          <target state="translated">如果xBestIndex返回&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，则不表示错误。而是，SQLITE_CONSTRAINT指示在查询计划中不应使用指定的输入参数的特定组合。 SQLITE_CONSTRAINT返回对于具有必需参数的&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;很有用。如果aConstraint []。usable字段的必需参数之一为false，则xBestIndex方法应返回SQLITE_CONSTRAINT。</target>
        </trans-unit>
        <trans-unit id="f2ddd15ff69a5ac03ff2cdad02ade0037f75db16" translate="yes" xml:space="preserve">
          <source>If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.</source>
          <target state="translated">如果xRead()返回SQLITE_IOERR_SHORT_READ,它还必须用零填充缓冲区的未读部分。一个未能将短读填充为零的VFS看起来似乎是可行的,但如果未能将短读填充为零,最终会导致SQLITE_IOERR_SHORT_READ的未读部分。然而,未能零填充短读将最终导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="406e06acbef99d386159c93608eee295bbb8911c" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; a string into a BLOB, then the entire length of the string is shown. For example:</source>
          <target state="translated">如果将字符串&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST投射&lt;/a&gt;到BLOB中，则会显示字符串的整个长度。例如：</target>
        </trans-unit>
        <trans-unit id="4c77d01ec7cf778a68ddf7a39c6762175e2b9a47" translate="yes" xml:space="preserve">
          <source>If you abuse the library by trying to call &lt;b&gt;sqlite_step&lt;/b&gt; inappropriately it will attempt return SQLITE_MISUSE. This can happen if you call sqlite_step() on the same virtual machine at the same time from two or more threads or if you call sqlite_step() again after it returned SQLITE_DONE or SQLITE_ERROR or if you pass in an invalid virtual machine pointer to sqlite_step(). You should not depend on the SQLITE_MISUSE return code to indicate an error. It is possible that a misuse of the interface will go undetected and result in a program crash. The SQLITE_MISUSE is intended as a debugging aid only - to help you detect incorrect usage prior to a mishap. The misuse detection logic is not guaranteed to work in every case.</source>
          <target state="translated">如果您试图通过不适当地调用&lt;b&gt;sqlite_step&lt;/b&gt;来滥用该库，它将尝试返回SQLITE_MISUSE。如果您同时从两个或多个线程在同一虚拟机上调用sqlite_step（），或者在返回SQLITE_DONE或SQLITE_ERROR后再次调用sqlite_step（），或者将无效的虚拟机指针传递给sqlite_step（），则会发生这种情况。 ）。您不应该依赖SQLITE_MISUSE返回代码来指示错误。接口的滥用可能会被发现并导致程序崩溃。 SQLITE_MISUSE仅用作调试帮助-帮助您在发生意外之前检测到不正确的用法。不能保证滥用检测逻辑在每种情况下都能正常工作。</target>
        </trans-unit>
        <trans-unit id="873a7faf9a3abe0d1c1b374fb25f49d1d975c393" translate="yes" xml:space="preserve">
          <source>If you append the character '*' to the end of the pattern, then a prefix search is performed. For example:</source>
          <target state="translated">如果你在模式的末尾添加字符'*',那么就会执行前缀搜索。例如:</target>
        </trans-unit>
        <trans-unit id="feb267998fb090ad7c9de72555f7d36aa562a1a7" translate="yes" xml:space="preserve">
          <source>If you are a &quot;rustacean&quot; and feel that Rust already meets the preconditions listed above, and that SQLite should be recoded in Rust, then you are welcomed and encouraged to contact the SQLite developers privately and argue your case.</source>
          <target state="translated">如果你是一个 &quot;rustacean&quot;,觉得Rust已经满足了上述前提条件,而SQLite应该用Rust重新编码,那么欢迎并鼓励你私下联系SQLite开发者,论证你的理由。</target>
        </trans-unit>
        <trans-unit id="abe76df81a0ba114f6ec2f514aa5a8bd31614980" translate="yes" xml:space="preserve">
          <source>If you are a devoted Git user, you can still easily access SQLite. This section gives some hints on how to do so.</source>
          <target state="translated">如果你是一个忠实的 Git 用户,你仍然可以轻松地访问 SQLite。本节将给出一些关于如何访问的提示。</target>
        </trans-unit>
        <trans-unit id="b343ba4a7d7f527696dab2d0f4840db430c944d2" translate="yes" xml:space="preserve">
          <source>If you are an SQLite user whose has stumbled over some quirk of SQLite that is not mentioned here, please send us an email so that we can document the problem.</source>
          <target state="translated">如果你是一个SQLite用户,在这里没有提到SQLite的一些怪癖,请给我们发邮件,以便我们记录问题。</target>
        </trans-unit>
        <trans-unit id="5de71147613f21cf2bdcb3bcc197abf7747cdeb4" translate="yes" xml:space="preserve">
          <source>If you are using separate source files, name all of the source files instead of just the two amalgamation source files. Once this is done, commit your changes as follows:</source>
          <target state="translated">如果你使用的是单独的源文件,请命名所有的源文件,而不是只命名两个合并源文件。完成后,提交你的修改如下。</target>
        </trans-unit>
        <trans-unit id="4850a90372994c2a6bc8e2907d79c1145e74bbe1" translate="yes" xml:space="preserve">
          <source>If you delete a lot of data and want to shrink the database file, run the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. VACUUM will reconstruct the database from scratch. This will leave the database with an empty free-list and a file that is minimal in size. Note, however, that the VACUUM can take some time to run and it can use up to twice as much temporary disk space as the original file while it is running.</source>
          <target state="translated">如果删除大量数据并希望收缩数据库文件，请运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令。 VACUUM将从头开始重建数据库。这将使数据库具有一个空的空闲列表和一个最小的文件。但是请注意，VACUUM可能需要花费一些时间才能运行，并且其临时磁盘空间最多可以运行时为原始文件的两倍。</target>
        </trans-unit>
        <trans-unit id="5f248ef1c5726530e6b14bd3353f02b25fd1dbc4" translate="yes" xml:space="preserve">
          <source>If you delete the</source>
          <target state="translated">如果您删除了</target>
        </trans-unit>
        <trans-unit id="45dba72fc49e11d88cfbda6839af5580be8953a7" translate="yes" xml:space="preserve">
          <source>If you do not have a backup, recovery is very difficult. You might be able to find partial string data in a binary dump of the raw database file. Recovering numeric data might also be possible given special tools, though to our knowledge no such tools exist. SQLite is sometimes compiled with the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; option which overwrites all deleted content with zeros. If that is the case then recovery is clearly impossible. Recovery is also impossible if you have run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has not been run, then some of the deleted content might still be in the database file, in areas marked for reuse. But, again, there exist no procedures or tools that we know of to help you recover that data.</source>
          <target state="translated">如果没有备份，恢复将非常困难。您可能能够在原始数据库文件的二进制转储中找到部分字符串数据。使用特殊工具也可以恢复数字数据，尽管据我们所知，尚无此类工具。有时使用&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt;选项编译SQLite，该选项将用零覆盖所有已删除的内容。如果真是这样，那么恢复显然是不可能的。如果由于删除了数据而运行了&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM，&lt;/a&gt;则恢复也是不可能的。如果未使用SQLITE_SECURE_DELETE并且尚未运行VACUUM，则某些已删除的内容可能仍在数据库文件的标记为可重复使用的区域中。但是，同样，我们不知道可以帮助您恢复数据的过程或工具。</target>
        </trans-unit>
        <trans-unit id="6123d0cbcd49adc87278ebf33c0308d19e13c18e" translate="yes" xml:space="preserve">
          <source>If you do not want to use your web browser to view the new check-in, you can get some information from the command-line using commands like these:</source>
          <target state="translated">如果你不想使用网页浏览器查看新的签到,你可以使用这些命令从命令行获得一些信息。</target>
        </trans-unit>
        <trans-unit id="165e1548a7d4a581b8c9984a9f7ab5cdc62be5bb" translate="yes" xml:space="preserve">
          <source>If you do this immediately after creating a new database file, before anything else has been written into the file, then that might be all that you need to do. Otherwise, the API call above should be followed by:</source>
          <target state="translated">如果你在创建一个新的数据库文件后,在其他任何东西被写入文件之前,立即这样做,那么这可能是你需要做的所有事情。否则,上面的API调用后面应该跟上。</target>
        </trans-unit>
        <trans-unit id="c8e5a488a0f9459d060660cf0d22bea3c48ed8ca" translate="yes" xml:space="preserve">
          <source>If you feel that you need dynamic pointer type strings in your application, that is a strong indicator that you are misusing the pointer-passing interface. Your intended use may be unsafe. Please rethink your design. Determine if you really need to be passing pointers through SQL in the first place. Or perhaps find a different mechanism other than the pointer-passing interfaces described by this article.</source>
          <target state="translated">如果你觉得在你的应用程序中需要动态指针类型的字符串,那就说明你误用了指针传递接口。你的预期使用可能是不安全的。请重新考虑你的设计。首先确定你是否真的需要通过SQL传递指针。或者,除了本文描述的指针传递接口之外,也许还可以找到一种不同的机制。</target>
        </trans-unit>
        <trans-unit id="88a9f11dc162c0fbb6ecd06e339a9fb7195e5fab" translate="yes" xml:space="preserve">
          <source>If you find errors in either the documentation or the code, feel free to fix them and/or contact the author at &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;. Your bug fixes or suggestions are always welcomed.</source>
          <target state="translated">如果您在文档或代码中发现错误，请随时进行修复和/或通过&lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;与作者联系。我们始终欢迎您修复错误或提出建议。</target>
        </trans-unit>
        <trans-unit id="888116b604c695e34258cc3ceb95b003a7ab4815" translate="yes" xml:space="preserve">
          <source>If you have a backup copy of your database file, recover the information from your backup.</source>
          <target state="translated">如果您有数据库文件的备份副本,请从备份中恢复信息。</target>
        </trans-unit>
        <trans-unit id="882c38087164067f62c9c7b1c8a9cb99d1dcf2ef" translate="yes" xml:space="preserve">
          <source>If you have a database of large BLOBs, do you get better read performance when you store the complete BLOB content directly in the database or is it faster to store each BLOB in a separate file and store just the corresponding filename in the database?</source>
          <target state="translated">如果你有一个大型BLOB的数据库,如果直接将完整的BLOB内容存储在数据库中,是否能获得更好的读取性能,还是将每个BLOB存储在一个单独的文件中,只将相应的文件名存储在数据库中更快?</target>
        </trans-unit>
        <trans-unit id="763f3c8f82a8dbfe2292008ca244c1681fbd52b1" translate="yes" xml:space="preserve">
          <source>If you have a script and you want to start debugging at some point half-way through that script, simply set a breakpoint in gdb (or whatever debugger you are using) on the test_breakpoint() function, and add a &quot;.breakpoint&quot; command where you want to stop. When you reach that first breakpoint, set whatever additional breakpoints are variable traces you need.</source>
          <target state="translated">如果你有一个脚本,并且你想在该脚本中途的某个点开始调试,只需在gdb(或任何你正在使用的调试器)中对test_breakpoint()函数设置一个断点,并在你想停止的地方添加一个&quot;.breakpoint &quot;命令。当你到达第一个断点时,设置任何额外的断点都是你需要的变量痕迹。</target>
        </trans-unit>
        <trans-unit id="a1693c0c5d23752d02c6e3b93f043c8eb31a26df" translate="yes" xml:space="preserve">
          <source>If you have done any assembly language programming or have worked with any kind of abstract machine before, all of these details should be familiar to you. So let's jump right in and start looking as some code.</source>
          <target state="translated">如果你做过任何汇编语言编程,或者以前用过任何一种抽象机,这些细节你应该都很熟悉。所以让我们直接跳进去,开始看作为一些代码。</target>
        </trans-unit>
        <trans-unit id="ec726a0b109ca2b2f984dbfe63a95238609005d5" translate="yes" xml:space="preserve">
          <source>If you intend to use this virtual table in cooperation with an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table (for spelling correction of search terms) then you might extract the vocabulary using an &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table:</source>
          <target state="translated">如果您打算将此虚拟表与&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;表配合使用（用于对搜索词进行拼写更正），则可以使用&lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt;表提取词汇表：</target>
        </trans-unit>
        <trans-unit id="20f09458f074cbdfa69a4cd879b9a24a9c5ffaed" translate="yes" xml:space="preserve">
          <source>If you made NL to CR-NL line ending changes or space to tab indentation changes in the original baseline, make the same changes to the new source file.</source>
          <target state="translated">如果您在原始基线中进行了 NL 到 CR-NL 行结束的更改或空格到制表符缩进的更改,请对新的源文件进行同样的更改。</target>
        </trans-unit>
        <trans-unit id="6938d0165858c470278846efb2784fece3e6d115" translate="yes" xml:space="preserve">
          <source>If you need an exact answer, you should not use binary64 floating-point values, in SQLite or in any other product. This is not an SQLite limitation. It is a mathematical limitation inherent in the design of floating-point numbers.</source>
          <target state="translated">如果你需要一个准确的答案,你不应该在SQLite或任何其他产品中使用二进制64浮点值。这不是SQLite的限制,而是浮点数设计中固有的数学限制。这是浮点数字设计中固有的数学限制。</target>
        </trans-unit>
        <trans-unit id="5e4831ba155a21bf312a9328909ee6b27a5a08fb" translate="yes" xml:space="preserve">
          <source>If you need to verify that the SQLite source code that you have is authentic and has not been modified in any way (perhaps by an adversary) that can be done using a few simple command-line tools. At the root of the SQLite source tree is a file named &quot;manifest&quot;. The manifest file contains the name of every other file in the source tree together with either a SHA1 or SHA3-256 hash for that file. (SHA1 is used for older files and SHA3-256 for newer files.) You can write a script to extract these hashes and verify them against the source code files. The hash name for the check-in is just the SHA3-256 hash of the &quot;manifest&quot; file itself.</source>
          <target state="translated">如果你需要验证你所拥有的SQLite源代码是真实的,并且没有被以任何方式修改过(也许是被对手修改过),可以使用一些简单的命令行工具来完成。在SQLite源码树的根部有一个名为 &quot;manifest &quot;的文件。manifest文件包含了源树中每一个其他文件的名称,以及该文件的SHA1或SHA3-256哈希值。(SHA1用于旧文件,SHA3-256用于新文件。)你可以写一个脚本来提取这些哈希值,并对照源代码文件进行验证。签入的哈希名只是 &quot;manifest &quot;文件本身的SHA3-256哈希。</target>
        </trans-unit>
        <trans-unit id="a95dfc6dc355d4bcfc654c806aedf507385d37e3" translate="yes" xml:space="preserve">
          <source>If you notice new CVEs associated with SQLite that are not in the table below, please bring them to the attention of the developers on the &lt;a href=&quot;https://sqlite.org/forum/about&quot;&gt;SQLite Forum&lt;/a&gt; so they can be added.</source>
          <target state="translated">如果您发现下表中没有列出与SQLite相关的新CVE，请在&lt;a href=&quot;https://sqlite.org/forum/about&quot;&gt;SQLite论坛&lt;/a&gt;上引起开发人员的注意，以便可以添加它们。</target>
        </trans-unit>
        <trans-unit id="397118cfe02899896d93de7bdac7c4252da15fbe" translate="yes" xml:space="preserve">
          <source>If you really need to update an R-Tree based on complex queries against the same R-Tree, it is best to run the complex queries first and store the results in a temporary table, then update the R-Tree based on the values stored in the temporary table.</source>
          <target state="translated">如果真的需要根据对同一R树的复杂查询来更新R树,最好先运行复杂查询,并将结果存储在临时表中,然后根据临时表中存储的值来更新R树。</target>
        </trans-unit>
        <trans-unit id="5df7ef5af012df18a05531f4528bcf648f59acb3" translate="yes" xml:space="preserve">
          <source>If you remember nothing else about floating-point values, please don't forget this one key idea.</source>
          <target state="translated">如果你对浮点值没有其他印象,请不要忘记这个关键的概念。</target>
        </trans-unit>
        <trans-unit id="13da8fa523e1031c91ec41d25db356602a2c65ba" translate="yes" xml:space="preserve">
          <source>If you specify a column a width of 0, then the column width is automatically adjusted to be the maximum of three numbers: 10, the width of the header, and the width of the first row of data. This makes the column width self-adjusting. The default width setting for every column is this auto-adjusting 0 value.</source>
          <target state="translated">如果你指定一个列的宽度为0,那么列的宽度会自动调整为三个数字的最大值。10,页眉的宽度,和第一行数据的宽度.这使得列的宽度可以自我调整。每一列的默认宽度设置就是这个自动调整的0值。</target>
        </trans-unit>
        <trans-unit id="473942d6eb4b318988fc65567c504fbaea4558ae" translate="yes" xml:space="preserve">
          <source>If you use version 2.6.0 or later of the library to open a database file that was originally created by version 2.5.6 or earlier, an attempt to rebuild the database into the new format will occur automatically. This can take some time for a large database. (Allow 1 or 2 seconds per megabyte of database under Unix - longer under Windows.) This format conversion is irreversible. It is &lt;strong&gt;strongly&lt;/strong&gt; suggested that you make a backup copy of older database files prior to opening them with version 2.6.0 or later of the library, in case there are errors in the format conversion logic.</source>
          <target state="translated">如果您使用库的2.6.0或更高版本来打开最初由2.5.6或更早版本创建的数据库文件，则将自动尝试将数据库重建为新格式。对于大型数据库，这可能需要一些时间。 （在Unix下，每兆字节数据库允许1或2秒-在Windows下，更长的时间。）这种格式转换是不可逆的。这是&lt;strong&gt;强烈&lt;/strong&gt;建议您使用2.6.0或更高版本的库打开它们使旧的数据库文件备份副本之前，万一有格式转换的逻辑错误。</target>
        </trans-unit>
        <trans-unit id="57f756e359121a9c945b91158a295a20dd82b0db" translate="yes" xml:space="preserve">
          <source>If you want to configure the new project, type:</source>
          <target state="translated">如果你想配置新的项目,请键入。</target>
        </trans-unit>
        <trans-unit id="bda3419a07a7eb3933cb5a599b2b66398d9d3b26" translate="yes" xml:space="preserve">
          <source>If you want to know how the SQLite library works internally, you need to begin with a solid understanding of the Virtual Database Engine or VDBE. The VDBE occurs right in the middle of the processing stream (see the &lt;a href=&quot;arch&quot;&gt;architecture diagram&lt;/a&gt;) and so it seems to touch most parts of the library. Even parts of the code that do not directly interact with the VDBE are usually in a supporting role. The VDBE really is the heart of SQLite.</source>
          <target state="translated">如果您想了解SQLite库在内部的工作方式，则需要对虚拟数据库引擎或VDBE有深入的了解。 VDBE恰好出现在处理流的中间（请参阅&lt;a href=&quot;arch&quot;&gt;体系结构图&lt;/a&gt;），因此它似乎触及了库的大部分。甚至不直接与VDBE交互的部分代码也通常起辅助作用。 VDBE确实是SQLite的心脏。</target>
        </trans-unit>
        <trans-unit id="45ef57f77f1b898b089bfb8776638647a0457adc" translate="yes" xml:space="preserve">
          <source>If you want to use a keyword as a name, you need to quote it. There are four ways of quoting keywords in SQLite:</source>
          <target state="translated">如果你想使用关键字作为名称,你需要引用它。在SQLite中,有四种引用关键字的方式。</target>
        </trans-unit>
        <trans-unit id="33c132e45cdeb83d38d9892ca9d1c9494534573d" translate="yes" xml:space="preserve">
          <source>If you will be opening multiple database connections in your application, rather than invoking the extension entry points for each database connection separately, you might want to consider using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions and to cause them to be automatically started as each database connection is opened. You only have to register each extension once, and you can do so near the beginning of your main() routine. Using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions makes your extensions work as if they were built into the core SQLite - they automatically exist whenever you open a new database connection without needing to be initialized. Just be sure to complete any configuration you need to accomplish using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; before registering your extensions, since the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface implicitly calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">如果要在应用程序中打开多个数据库连接，而不是分别为每个数据库连接调用扩展入口点，则可能要考虑使用&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;接口注册扩展，并使每个扩展自动启动。数据库连接已打开。您只需注册每个扩展名一次，并且可以在main（）例程的开头附近进行注册。使用&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;接口注册您的扩展名可使您的扩展名像内置在核心SQLite中一样工作-每当您打开新的数据库连接而无需初始化时，它们便自动存在。只要确保完成您需要使用完成的任何配置&lt;a href=&quot;c3ref/config&quot;&gt;&lt;/a&gt;在注册扩展之前，请先使用sqlite3_config（），因为&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;接口隐式调用了&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2a19b719f76f7faa9b10e93907a0fe776f85db7" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 140 terabytes in size, assuming you can find a disk drive and filesystem that will support 140-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">如果你的数据会增长到你不习惯或无法装入一个磁盘文件的大小,那么你应该选择SQLite以外的解决方案。SQLite支持大小高达140TB的数据库,假设你能找到一个能支持140TB文件的磁盘驱动器和文件系统。即便如此,当内容的大小看起来可能会爬到TB范围内时,最好考虑集中式客户/服务器数据库。</target>
        </trans-unit>
        <trans-unit id="22b27cadfcf6135e72ec61c4781266a907795c13" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 281 terabytes in size, assuming you can find a disk drive and filesystem that will support 281-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">如果你的数据会增长到你不习惯或无法装入一个磁盘文件的大小,那么你应该选择SQLite以外的解决方案。SQLite支持大小达281TB的数据库,假设你能找到一个能支持281TB文件的磁盘驱动器和文件系统。即便如此,当内容的大小看起来可能会爬到太字节的范围时,最好考虑集中式的客户/服务器数据库。</target>
        </trans-unit>
        <trans-unit id="b8bce6edf7a889c813c03d5b445472e1ddc49ad2" translate="yes" xml:space="preserve">
          <source>If your system defines a custom OS interface for SQLite or if you were using the undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface, then you will need to make modifications in order to upgrade to SQLite version 3.5.0. This may seem painful at first glance. But as you look more closely, you will probably discover that your changes are made smaller and easier to understand and manage by the new SQLite interface. It is likely that your changes will now also work seamlessly with the SQLite amalgamation. You will no longer need to make any changes to the code SQLite source code. All of your changes can be effected by application code and you can link against a standard, unmodified version of the SQLite amalgamation. Furthermore, the OS interface layer, which was formerly undocumented, is now an officially support interface for SQLite. So you have some assurance that this will be a one-time change and that your new backend will continue to work in future versions of SQLite.</source>
          <target state="translated">如果您的系统为SQLite定义了自定义OS接口，或者您使用的是未&lt;b&gt;公开的sqlite3_os_switch（）&lt;/b&gt;界面，则需要进行修改才能升级到SQLite 3.5.0版。乍看起来，这似乎很痛苦。但是当您仔细观察时，您可能会发现新的SQLite界面使更改变得更小，更易于理解和管理。您的更改现在很可能也可以与SQLite合并无缝地协同工作。您将不再需要对代码SQLite源代码进行任何更改。您的所有更改都可以由应用程序代码来实现，并且可以链接到标准的，未修改的SQLite合并版本。此外，以前未记录的OS接口层现在已成为SQLite的官方支持接口。因此，您可以确保这将是一次更改，并且您的新后端将继续在将来的SQLite版本中使用。</target>
        </trans-unit>
        <trans-unit id="4d01491e7aaf0e3b7eeb3d6755bf0ba092a441ec" translate="yes" xml:space="preserve">
          <source>If zipfile() is invoked with 2 arguments, then the entry added to the archive is equivalent to that added by inserting the same two values into the &quot;name&quot; and &quot;data&quot; columns of a zipfile virtual table, with all other values set to NULL. If invoked with 4 arguments, it is equivalent to inserting the 4 values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot; and &quot;data&quot; columns. In other words, the following pairs of queries are equivalent:</source>
          <target state="translated">如果调用zipfile()时有2个参数,那么添加到档案中的条目就相当于在zipfile虚拟表中的 &quot;name &quot;和 &quot;data &quot;列中插入相同的两个值,其他值都设置为NULL。如果调用4个参数,相当于在 &quot;name&quot;、&quot;mode&quot;、&quot;mtime &quot;和 &quot;data &quot;列中插入4个值。换句话说,下面的一对查询是等价的。</target>
        </trans-unit>
        <trans-unit id="d49c9a42ebbe9cba3927bb51a35d92fe353713e9" translate="yes" xml:space="preserve">
          <source>If, as part of the</source>
          <target state="translated">如果,作为</target>
        </trans-unit>
        <trans-unit id="1b931ae5cbce5d6c96daf33260c2b72ee5539dbd" translate="yes" xml:space="preserve">
          <source>If, while opening a</source>
          <target state="translated">如果在打开一个</target>
        </trans-unit>
        <trans-unit id="f48c9c6740ea7cbd9ee32d778ecff2f9da591ab1" translate="yes" xml:space="preserve">
          <source>IfNoHope</source>
          <target state="translated">IfNoHope</target>
        </trans-unit>
        <trans-unit id="0d430ae72e07c71cbfc6aac6b856ba69c4a14902" translate="yes" xml:space="preserve">
          <source>IfNot</source>
          <target state="translated">IfNot</target>
        </trans-unit>
        <trans-unit id="f975ef3b4d80471cd49ea9ce8bd7a669078224d8" translate="yes" xml:space="preserve">
          <source>IfNotOpen</source>
          <target state="translated">IfNotOpen</target>
        </trans-unit>
        <trans-unit id="d2a091305f84e463b224fd2549c504926b658103" translate="yes" xml:space="preserve">
          <source>IfNotZero</source>
          <target state="translated">IfNotZero</target>
        </trans-unit>
        <trans-unit id="8ea5813d833284a6b426730c347d4a031b76be44" translate="yes" xml:space="preserve">
          <source>IfNullRow</source>
          <target state="translated">IfNullRow</target>
        </trans-unit>
        <trans-unit id="7661d111573d853c18bf38582f4762e932f703e7" translate="yes" xml:space="preserve">
          <source>IfPos</source>
          <target state="translated">IfPos</target>
        </trans-unit>
        <trans-unit id="a6bb95ea00b2b20f56a2debeb7afeb897471ef50" translate="yes" xml:space="preserve">
          <source>IfSmaller</source>
          <target state="translated">IfSmaller</target>
        </trans-unit>
        <trans-unit id="91d8cebb7b70f29e3262ce44bfc944c449089a8d" translate="yes" xml:space="preserve">
          <source>Ignore extra whitespace at the end of of &quot;.&quot; commands in the shell.</source>
          <target state="translated">忽略shell中&quot;.&quot;命令末尾的多余空格。</target>
        </trans-unit>
        <trans-unit id="d609bda3312485a36bcab24d9a33ae880a4d9c03" translate="yes" xml:space="preserve">
          <source>Immediately after an iterator is created by sqlite3changeset_start(), it does not point to any change in the changeset. Assuming the changeset is not empty, the first call to this function advances the iterator to point to the first change in the changeset. Each subsequent call advances the iterator to point to the next change in the changeset (if any). If no error occurs and the iterator points to a valid change after a call to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. Otherwise, if all changes in the changeset have already been visited, SQLITE_DONE is returned.</source>
          <target state="translated">当一个迭代器被sqlite3changeset_start()创建后,它不会立即指向变化集中的任何变化。假设变化集不是空的,对这个函数的第一次调用将迭代器推进到指向变化集的第一个变化。随后的每一次调用都将迭代器推进到变化集中的下一个变化(如果有的话)。如果没有发生错误,并且在调用 sqlite3changeset_next()后迭代器指向一个有效的变化,则返回 SQLITE_ROW。否则,如果变化集中的所有变化都已经被访问,则返回SQLITE_DONE。</target>
        </trans-unit>
        <trans-unit id="49deaa07b4de652a28623d07d5618cb8f1e55666" translate="yes" xml:space="preserve">
          <source>Immediately following the wal-header are zero or more frames. Each frame consists of a 24-byte frame-header followed by a</source>
          <target state="translated">紧接在 wal-header 之后的是零个或多个帧。每个帧由一个24字节的帧头组成,后面是一个</target>
        </trans-unit>
        <trans-unit id="efc77ef3528cb380e78002c642146ddfcb72a6c8" translate="yes" xml:space="preserve">
          <source>Implement a procedure that calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and passes it a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure from the previous step. This procedure is probably the only exported symbol in the source file that implements your VFS.</source>
          <target state="translated">实现一个过程，该过程调用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;并将其指针传递给上一步中的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;结构。此过程可能是实现VFS的源文件中唯一导出的符号。</target>
        </trans-unit>
        <trans-unit id="5f991f27713d088110dc4560a5b48613a2e55fa7" translate="yes" xml:space="preserve">
          <source>Implement the &quot;LIMIT ... OFFSET ...&quot; clause on SELECT statements.</source>
          <target state="translated">在SELECT语句上实现 &quot;LIMIT ...OFFSET ...&quot;子句。</target>
        </trans-unit>
        <trans-unit id="cb1780300fa34dfe12b3de8afb5a8d426d248748" translate="yes" xml:space="preserve">
          <source>Implement the methods required by the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">实现&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象所需的方法。</target>
        </trans-unit>
        <trans-unit id="edbf1d07115719c5c7e93d86f1046b341948dbde" translate="yes" xml:space="preserve">
          <source>Implement the other methods required by &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;所需的其他方法。</target>
        </trans-unit>
        <trans-unit id="a8b02a72a8b5be24e42656704837d215920a00aa" translate="yes" xml:space="preserve">
          <source>Implement the xOpen method that opens a file and populates an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object, including setting pMethods to point to the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object from the previous step.</source>
          <target state="translated">实现xOpen方法，该方法打开文件并填充&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象，包括将pMethods设置为指向上一步中的&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="87cdff8728ab99514f76ab384b99b3f529310cf0" translate="yes" xml:space="preserve">
          <source>Implementation Limits For SQLite</source>
          <target state="translated">SQLite的实现限制</target>
        </trans-unit>
        <trans-unit id="32808d9f543dc0758af6de0786717c61ede1f9c3" translate="yes" xml:space="preserve">
          <source>Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.</source>
          <target state="translated">聚合SQL函数的实现使用这个例程来分配内存来存储它们的状态。</target>
        </trans-unit>
        <trans-unit id="7165ad4b3d6ce30cae4f1408c3a0f8924f93a699" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;appfunc&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">实现自定义辅助功能类似于实现&lt;a href=&quot;appfunc&quot;&gt;标量SQL函数&lt;/a&gt;。该实现应为fts5_extension_function类型的C函数，定义如下：</target>
        </trans-unit>
        <trans-unit id="4018bcd662e8105cb957cfc5a507fd128f58cc71" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;c3ref/create_function&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">实现自定义辅助功能类似于实现&lt;a href=&quot;c3ref/create_function&quot;&gt;标量SQL函数&lt;/a&gt;。实现应为fts5_extension_function类型的C函数，定义如下：</target>
        </trans-unit>
        <trans-unit id="cf816f713b7837e18241382d77dfd40a1b6bacf3" translate="yes" xml:space="preserve">
          <source>Implicit versus explicit transactions</source>
          <target state="translated">隐性交易与显性交易</target>
        </trans-unit>
        <trans-unit id="2f1059e48758f0fdc4ddd1f86b6fae46066d008b" translate="yes" xml:space="preserve">
          <source>Important bug fix: the IN operator was not working if either the left-hand or right-hand side was derived from an INTEGER PRIMARY KEY.</source>
          <target state="translated">重要的bug修复:如果左手或右手是由INTEGER PRIMARY KEY派生出来的,IN操作符就无法使用。</target>
        </trans-unit>
        <trans-unit id="a0fe78ecda103e8930771647f6dec46b0b349000" translate="yes" xml:space="preserve">
          <source>Impose A Limit On Heap Size</source>
          <target state="translated">限制堆的大小</target>
        </trans-unit>
        <trans-unit id="ed65a595437d44d40ac23326bd1b47c2bed21cbd" translate="yes" xml:space="preserve">
          <source>Imposter Tables</source>
          <target state="translated">冒名顶替表</target>
        </trans-unit>
        <trans-unit id="8bd676db829fa1254e9904aed550e4eaa10267fe" translate="yes" xml:space="preserve">
          <source>Imposter tables are intended for analysis and debugging only. This is not a feature that most application developers should understand or even know about. Imposter tables are for experts only.</source>
          <target state="translated">冒牌表仅用于分析和调试。这不是大多数应用程序开发人员应该理解或甚至知道的功能。冒牌表只适合专家使用。</target>
        </trans-unit>
        <trans-unit id="310974bd6288a19d56c62511f50674a5f6b79b46" translate="yes" xml:space="preserve">
          <source>Improper use of imposter tables can cause index corruption, though any corruption created this way can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">不正确使用冒名顶替表可能会导致索引损坏，尽管可以通过运行&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;来解决以这种方式创建的任何损坏。</target>
        </trans-unit>
        <trans-unit id="7cc4395a9bbe14f613da8e2834455cc8120ab269" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;omit-left-join optimization&lt;/a&gt; so that it works in cases where the right-hand table is UNIQUE but not necessarily NOT NULL.</source>
          <target state="translated">改进&lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;省略左连接优化&lt;/a&gt;，以使其在右侧表为UNIQUE但不一定为NOT NULL的情况下起作用。</target>
        </trans-unit>
        <trans-unit id="15dafad2713cbb23a2ff9f35c0397160bab08c72" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#pushdown&quot;&gt;push-down optimization&lt;/a&gt; so that it works for many LEFT JOINs.</source>
          <target state="translated">改进&lt;a href=&quot;optoverview#pushdown&quot;&gt;下推优化&lt;/a&gt;，使其适用于许多LEFT JOIN。</target>
        </trans-unit>
        <trans-unit id="115d57ca1c0c67b9c62b8627805bc54cd437ed61" translate="yes" xml:space="preserve">
          <source>Improve the format of the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; raw output, so that it gives better information about the query plan and about the relationships between the various components of the plan.</source>
          <target state="translated">改进&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;原始输出的格式，以便它提供有关查询计划以及计划中各个组件之间的关系的更好信息。</target>
        </trans-unit>
        <trans-unit id="14bd38dceda1ed2c01f162d1f3444a0f4f8b3ecd" translate="yes" xml:space="preserve">
          <source>Improve the performance of fts3/4 queries that use the OR operator and at least one auxiliary fts function.</source>
          <target state="translated">提高使用OR运算符和至少一个辅助fts函数的fts3/4查询的性能。</target>
        </trans-unit>
        <trans-unit id="b9c8f318457693f2fa88c903d8d43102377e8c69" translate="yes" xml:space="preserve">
          <source>Improve the performance of the &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace() SQL function&lt;/a&gt; for cases where there are many substitutions on megabyte-sized strings, in an attempt to avoid OSSFuzz timeouts during testing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</source>
          <target state="translated">在兆字节大小的字符串上存在许多替换的情况下，请提高&lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace（）SQL函数&lt;/a&gt;的性能，以免在测试期间出现OSSFuzz超时。登机&lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ed5007819cc6bdecc581d33162266f7dd3fe7" translate="yes" xml:space="preserve">
          <source>Improved Concurrency</source>
          <target state="translated">改进的并发性</target>
        </trans-unit>
        <trans-unit id="072e9878a7002455b6aee44f48f435995e934eb5" translate="yes" xml:space="preserve">
          <source>Improved Concurrency.</source>
          <target state="translated">改善并发症。</target>
        </trans-unit>
        <trans-unit id="fd596055fe2374f07cb22e2ed1eddaf72d523d42" translate="yes" xml:space="preserve">
          <source>Improved accuracy of floating-point conversions using &quot;long double&quot;.</source>
          <target state="translated">使用 &quot;长双 &quot;提高浮点转换的准确性。</target>
        </trans-unit>
        <trans-unit id="93fc56155be2598f9cbcf49e841b4a0140cf2c72" translate="yes" xml:space="preserve">
          <source>Improved algorithm for running queries with both an ORDER BY and a LIMIT where only the inner-most loop naturally generates rows in the correct order.</source>
          <target state="translated">改进了运行ORDER BY和LIMIT查询的算法,其中只有最里面的循环自然而然地以正确的顺序生成行。</target>
        </trans-unit>
        <trans-unit id="b070ecb9dcd3bd88a65a96d0f66e5d97c46345dc" translate="yes" xml:space="preserve">
          <source>Improved concurrency.</source>
          <target state="translated">改善并发症。</target>
        </trans-unit>
        <trans-unit id="9f23829b58c284f668ccf3661f99fc3dbbec1e58" translate="yes" xml:space="preserve">
          <source>Improved crash-robustness: write the database page size into the rollback journal header.</source>
          <target state="translated">改进的崩溃性:将数据库页面大小写入回滚日志头。</target>
        </trans-unit>
        <trans-unit id="7321289816f2bf6478248e1de203f755159291e2" translate="yes" xml:space="preserve">
          <source>Improved de-quoting of column names for &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; statements with an aggregate query on the right-hand side.</source>
          <target state="translated">改进了&lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt;语句的列名的去引用，并在右侧具有聚合查询。</target>
        </trans-unit>
        <trans-unit id="bf0fc640800a9514f6d8718203e257a7690d605b" translate="yes" xml:space="preserve">
          <source>Improved error detection of misused aggregate functions.</source>
          <target state="translated">改进对误用集合函数的错误检测。</target>
        </trans-unit>
        <trans-unit id="10bc21bc5dd5e57a67add58ea3202819c9a3c931" translate="yes" xml:space="preserve">
          <source>Improved error messages for &quot;foreign key mismatch&quot; showing the names of the two tables involved.</source>
          <target state="translated">改进了 &quot;外键不匹配 &quot;的错误信息,显示了相关两个表的名称。</target>
        </trans-unit>
        <trans-unit id="90dbb37d863c75537960cc5646693be15d517e85" translate="yes" xml:space="preserve">
          <source>Improved error messages for invalid boolean arguments to dot-commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">改进了针对&lt;a href=&quot;cli&quot;&gt;命令行shell&lt;/a&gt;中点命令的布尔值无效布尔参数的错误消息。</target>
        </trans-unit>
        <trans-unit id="b0dec14662a3a9f70430b0cb1619e2a60b783318" translate="yes" xml:space="preserve">
          <source>Improved error messages in the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension.</source>
          <target state="translated">改进了&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;扩展中的错误消息。</target>
        </trans-unit>
        <trans-unit id="e2c14cbb8bf1ab0754b223743a066a939afc76bf" translate="yes" xml:space="preserve">
          <source>Improved error messages on &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; failures.</source>
          <target state="translated">改进了有关&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="94cd821953431d9f45b2ba280ac0721b09c232ad" translate="yes" xml:space="preserve">
          <source>Improved estimates for the cost of running a DISTINCT operator.</source>
          <target state="translated">改进了对DISTINCT运营商运营成本的估算。</target>
        </trans-unit>
        <trans-unit id="2c62ff1f4b8293cf16ee945ea648937c03b9bc58" translate="yes" xml:space="preserve">
          <source>Improved fuzz-testing of database files, with fixes for problems found.</source>
          <target state="translated">改进了数据库文件的模糊测试,并对发现的问题进行了修复。</target>
        </trans-unit>
        <trans-unit id="26cc1d230c175a8810d6dd909c46be8d110c203b" translate="yes" xml:space="preserve">
          <source>Improved name resolution for deeply nested queries.</source>
          <target state="translated">改进了深度嵌套查询的名称解析。</target>
        </trans-unit>
        <trans-unit id="d3565d7b7ed6ef82845a8772788a705a908dc7c3" translate="yes" xml:space="preserve">
          <source>Improved optimization of &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; operators.</source>
          <target state="translated">改进了&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt;运算符的优化。</target>
        </trans-unit>
        <trans-unit id="a23eee66d3ed2b6341f9511337eea95095e21556" translate="yes" xml:space="preserve">
          <source>Improved optimization of AND and OR operators when one or the other operand is a constant.</source>
          <target state="translated">当一个或另一个操作数为常数时,改进了AND和OR操作数的优化。</target>
        </trans-unit>
        <trans-unit id="524c0e2c2353a4bf3f7178e269f56a6cac4ecf9b" translate="yes" xml:space="preserve">
          <source>Improved optimization of ORDER BY clauses on compound queries.</source>
          <target state="translated">改进对复合查询的ORDER BY子句的优化。</target>
        </trans-unit>
        <trans-unit id="af8c59932cd987b7607835b656e726f3dcea902b" translate="yes" xml:space="preserve">
          <source>Improved optimization of aggregate subqueries contained within an aggregate query.</source>
          <target state="translated">改进了对集合查询中包含的集合子查询的优化。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
