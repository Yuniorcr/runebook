<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="55672cdef058eed493a94d268600f0dc4cf6e695" translate="yes" xml:space="preserve">
          <source>If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previous sentence, a column name preceded by one or more unary &quot;+&quot; operators and/or CAST operators is still considered a column name.</source>
          <target state="translated">如果操作数中的任何一个是列,那么就使用该列的整理函数,优先于左边的操作数。就上一句话而言,列名前面有一个或多个单数 &quot;+&quot;运算符和/或CAST运算符的,仍然被认为是一个列名。</target>
        </trans-unit>
        <trans-unit id="c6ebcbeab69b86f653a3410afabe08a544dcaea8" translate="yes" xml:space="preserve">
          <source>If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status() are undefined.</source>
          <target state="translated">如果当前值或高水位标志太大,不能用32位整数表示,那么sqlite3_status()返回的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="10b7374ac7ffa60e3b709049b312d9aea49ec9de" translate="yes" xml:space="preserve">
          <source>If file-locking is enabled (it is enabled by default), then connections from multiple processes may also read and write the database file. However concurrency is reduced as follows:</source>
          <target state="translated">如果启用了文件锁定(默认情况下是启用的),那么来自多个进程的连接也可以读写数据库文件。但是并发性会降低,具体如下。</target>
        </trans-unit>
        <trans-unit id="d3ef8fd536a105baf87d357ae62955ed380fa9cf" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled when it is prepared, the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; to remove all rows from the table before dropping it. The implicit DELETE does not cause any SQL triggers to fire, but may invoke foreign key actions or constraint violations. If an immediate foreign key constraint is violated, the DROP TABLE statement fails and the table is not dropped. If a deferred foreign key constraint is violated, then an error is reported when the user attempts to commit the transaction if the foreign key constraint violations still exist at that point. Any &quot;foreign key mismatch&quot; errors encountered as part of an implicit DELETE are ignored.</source>
          <target state="translated">如果在准备&lt;a href=&quot;lang_droptable&quot;&gt;表&lt;/a&gt;时启用了外键约束，则DROP TABLE命令将执行隐式&lt;a href=&quot;lang_delete&quot;&gt;DELETE，&lt;/a&gt;以在删除表之前从表中删除所有行。隐式DELETE不会引发任何SQL触发器，但可能会调用外键操作或违反约束的行为。如果违反了立即外键约束，则DROP TABLE语句将失败，并且不会删除该表。如果违反了延迟的外键约束，则如果此时仍存在外键约束冲突，则用户尝试提交事务时将报告错误。作为隐式DELETE的一部分遇到的任何&amp;ldquo;外键不匹配&amp;rdquo;错误都将被忽略。</target>
        </trans-unit>
        <trans-unit id="4f44f3a8f93f85a791245b413bb9ad1095b808f6" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled, disable them using &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;.</source>
          <target state="translated">如果启用了外键约束，请使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF&lt;/a&gt;禁用它们。</target>
        </trans-unit>
        <trans-unit id="6a1eb421ae6f8eb8b7414f3ba7bf623bab8ed0c1" translate="yes" xml:space="preserve">
          <source>If foreign key constraints were originally enabled then run &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; to verify that the schema change did not break any foreign key constraints.</source>
          <target state="translated">如果最初启用了外键约束，则运行&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;来验证架构更改没有破坏任何外键约束。</target>
        </trans-unit>
        <trans-unit id="c13741cd4626e3d89fe66c4aae10d469f36c6a45" translate="yes" xml:space="preserve">
          <source>If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with CHANGESET_FOREIGN_KEY as the second argument exactly once before the changeset is committed. If the conflict handler returns CHANGESET_OMIT, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns CHANGESET_ABORT, the changeset is rolled back.</source>
          <target state="translated">如果启用了外键处理,并且应用一个变化集使数据库处于包含外键违反的状态,那么冲突处理程序将在变化集提交之前以CHANGESET_FOREIGN_KEY作为第二个参数被调用一次。如果冲突处理程序返回CHANGESET_OMIT,那么包括引起外键约束违反的变化在内的变化将被提交。或者,如果它返回CHANGESET_ABORT,则改变集被回滚。</target>
        </trans-unit>
        <trans-unit id="664ed429f3e8a71469131f1cf927d67cea7224ef" translate="yes" xml:space="preserve">
          <source>If foreign keys constraints were originally enabled, reenable them now.</source>
          <target state="translated">如果原来启用了外键约束,现在重新启用。</target>
        </trans-unit>
        <trans-unit id="ae0d6d454ce848e119fe19c9d3921a6301be3ccd" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">如果尚未将其附加到作为第一个参数传递的会话对象，则此函数以与&lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;函数相同的方式附加表zTbl 。如果zTbl不存在或没有主键，则此功能为无操作（但不会返回错误）。</target>
        </trans-unit>
        <trans-unit id="b18e9847f65d260e65a6581d1c54f05d17b07506" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">如果尚未将其附加到作为第一个参数传递的会话对象，则此函数以与&lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;函数相同的方式附加表zTbl 。如果zTbl不存在或没有主键，则此功能为无操作（但不会返回错误）。</target>
        </trans-unit>
        <trans-unit id="a8c1f9f82d9d1138df42ada4c0e8d4ac1b13017c" translate="yes" xml:space="preserve">
          <source>If many threads and/or processes need to write the database at the same instant (and they cannot queue up and take turns) then it is best to select a database engine that supports that capability, which always means a client/server database engine.</source>
          <target state="translated">如果很多线程和/或进程需要在同一时刻写入数据库(它们不能排队轮流写),那么最好选择支持这种能力的数据库引擎,这总是意味着客户/服务器数据库引擎。</target>
        </trans-unit>
        <trans-unit id="277d800367bb442a2e4d79fba0d9ab386719bb03" translate="yes" xml:space="preserve">
          <source>If mmap_size is set to N then all current implementations map the first N bytes of the database file and use legacy xRead() calls for any content beyond N bytes. If the database file is smaller than N bytes, then the entire file is mapped. In the future, new OS interfaces could, in theory, map regions of the file other than the first N bytes, but no such implementation currently exists.</source>
          <target state="translated">如果mmap_size被设置为N,那么当前所有的实现都会映射数据库文件的前N个字节,并对超过N个字节的内容使用传统的xRead()调用。如果数据库文件小于N个字节,那么整个文件都会被映射。未来,新的操作系统接口理论上可以映射除前N个字节以外的文件区域,但目前还没有这样的实现。</target>
        </trans-unit>
        <trans-unit id="44cd764c270354ba3be43d380aabce5d77a1bc54" translate="yes" xml:space="preserve">
          <source>If more than one such fragment can be found, then fragments that contain a larger number of &quot;extra&quot; phrase matches are favored. The start of the selected text fragment may be moved a few tokens forward or backward to attempt to concentrate the phrase matches toward the center of the fragment.</source>
          <target state="translated">如果可以找到多个这样的片段,那么包含大量 &quot;额外的 &quot;短语匹配的片段将受到青睐。所选文本片段的开始可以向前或向后移动几个标记,以尝试将短语匹配集中到片段的中心。</target>
        </trans-unit>
        <trans-unit id="26cb5f0f4343465953038f56daf635f7d45d2d33" translate="yes" xml:space="preserve">
          <source>If multi-threaded processing is enabled via the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; setting, then sort operations will attempt to start helper threads when the amount of content to be sorted exceeds the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; and PMA Size determined by the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. This compile-time option sets the default value for the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. The default value is 250.</source>
          <target state="translated">如果通过&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA线程&lt;/a&gt;设置启用了多线程处理，则当要排序的内容量超过&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt;启动时间选项确定的&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;和PMA Size 的最小值时，排序操作将尝试启动帮助程序线程。此编译时选项设置&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt;启动时选项的默认值。默认值为250。</target>
        </trans-unit>
        <trans-unit id="180acf91f65a788cf692bf4d0ecd25eb3f41224e" translate="yes" xml:space="preserve">
          <source>If multiple commands are being executed against the same SQLite database connection at the same time, the autocommit is deferred until the very last command completes. For example, if a SELECT statement is being executed, the execution of the command will pause as each row of the result is returned. During this pause other INSERT, UPDATE, or DELETE commands can be executed against other tables in the database. But none of these changes will commit until the original SELECT statement finishes.</source>
          <target state="translated">如果同时针对同一个SQLite数据库连接执行多条命令,则自动提交会推迟到最后一条命令完成。例如,如果正在执行一条SELECT语句,当返回结果的每一条记录时,命令的执行将暂停。在这个暂停期间,可以针对数据库中的其他表执行其他INSERT、UPDATE或DELETE命令。但是在原始的SELECT语句完成之前,这些更改都不会提交。</target>
        </trans-unit>
        <trans-unit id="02760b51331cbab337a4b4abdc9926115fb4b89f" translate="yes" xml:space="preserve">
          <source>If neither of these two query strategies can be used, all queries on FTS tables are implemented using a linear scan of the entire table. If the table contains large amounts of data, this may be an impractical approach (the first example on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds using a modern PC).</source>
          <target state="translated">如果这两种查询策略都不能使用,那么对FTS表的所有查询都会使用整个表的线性扫描来实现。如果表包含大量数据,这可能是一种不切实际的方法(本页的第一个例子显示,使用现代PC对1.5 GB的数据进行线性扫描需要大约30秒)。</target>
        </trans-unit>
        <trans-unit id="46d15914a8966b2144fb307d96a3896b83eea8f4" translate="yes" xml:space="preserve">
          <source>If no</source>
          <target state="translated">如果没有</target>
        </trans-unit>
        <trans-unit id="d80775017369d9f582b22c2b8463af70c053cb1a" translate="yes" xml:space="preserve">
          <source>If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert. If the table is initially empty, then a ROWID of 1 is used. If the largest ROWID is equal to the largest possible integer (9223372036854775807) then the database engine starts picking positive candidate ROWIDs at random until it finds one that is not previously used. If no unused ROWID can be found after a reasonable number of attempts, the insert operation fails with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. If no negative ROWID values are inserted explicitly, then automatically generated ROWID values will always be greater than zero.</source>
          <target state="translated">如果在插入上未指定ROWID，或者指定的ROWID的值为NULL，则将自动创建适当的ROWID。通常的算法是为新创建的行赋予ROWID，该ROWID比插入之前表中的最大ROWID大一。如果表最初为空，则使用ROWID为1。如果最大ROWID等于可能的最大整数（9223372036854775807），则数据库引擎开始随机选择正候选ROWID，直到找到以前未使用过的ROWID。如果经过合理的尝试次数后未找到未使用的ROWID，则插入操作将失败，并显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误。如果没有明确插入负的ROWID值，则自动生成的ROWID值将始终大于零。</target>
        </trans-unit>
        <trans-unit id="e2deadd7a9c793e3167a0e629e8b9b96ff70f176" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned.</source>
          <target state="translated">如果没有发生错误,则返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="8e5398b47308ea9ae66110e9bb05403692680696" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned. If an error does occur, an SQLite error code is returned. The values of the output variables may not be trusted in this case.</source>
          <target state="translated">如果没有发生错误,则返回SQLITE_OK。如果确实发生了错误,则返回SQLite错误代码。在这种情况下,输出变量的值可能不被信任。</target>
        </trans-unit>
        <trans-unit id="b8dd386d2569bc5457aac9dba2010126d7a04d7d" translate="yes" xml:space="preserve">
          <source>If no master journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a master journal is named in the file journal, then the file journal is hot if its master journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">如果不涉及主日志,那么如果日志存在,且日志头不为零,且其对应的数据库文件没有 RESERVED 锁,则该日志为热日志。如果在文件日志中命名了主日志,那么如果主日志存在,并且对应的数据库文件没有 RESERVED 锁,那么文件日志就是热日志。了解什么时候是热日志是很重要的,所以前面的规则将用圆点重复。</target>
        </trans-unit>
        <trans-unit id="e9ec2ab3e066aabbb424ce10a035adf5f5270552" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">如果在数据库中找不到与主键值匹配的行，则使用第二个参数传递的&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt;调用冲突处理程序函数。</target>
        </trans-unit>
        <trans-unit id="532395f09f545a6e9963ddaa843af136eeb8913b" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">如果在数据库中找不到与主键值匹配的行，则使用第二个参数传递的&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt;调用冲突处理程序函数。</target>
        </trans-unit>
        <trans-unit id="96d3acb3ee8eb3ea8e9644e28f8d2dc56f1b840a" translate="yes" xml:space="preserve">
          <source>If no super-journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a super-journal is named in the file journal, then the file journal is hot if its super-journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5795a39454965fb21426bc7bb9e2147672f5e177" translate="yes" xml:space="preserve">
          <source>If none of the strings above occur anywhere in the type declaration, then the datatype is numeric. Note in particular that the datatype for columns with an empty type declaration is numeric.</source>
          <target state="translated">如果类型声明中没有任何地方出现上述字符串,那么数据类型就是数值型。特别注意,类型声明为空的列的数据类型是数字。</target>
        </trans-unit>
        <trans-unit id="5b0f610d4827d05770d8c3809730eca324b8d352" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">如果偏移量iOffset从BLOB的末尾开始小于N个字节，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;读取任何数据。如果N或iOffset小于零，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;读取任何数据。可以使用&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定Blob的大小（以及N + iOffset的最大值）。</target>
        </trans-unit>
        <trans-unit id="bcc2dad992498753f10de4ee979d37a3e30daa67" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">如果偏移量iOffset从BLOB的末尾开始小于N个字节，则返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;读取任何数据。如果N或iOffset小于零，则返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;读取任何数据。可以使用&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定Blob的大小（以及N + iOffset的最大值）。</target>
        </trans-unit>
        <trans-unit id="2e41507fc7f4f5f8ed7f1f9f86f50446d711b557" translate="yes" xml:space="preserve">
          <source>If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.</source>
          <target state="translated">如果一个操作数具有INTEGER、REAL或NUMERIC亲和力,而另一个操作数具有TEXT或BLOB或无亲和力,那么NUMERIC亲和力将应用于另一个操作数。</target>
        </trans-unit>
        <trans-unit id="316990fa091894331a5bfab80d20b7d7b8a1b17a" translate="yes" xml:space="preserve">
          <source>If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.</source>
          <target state="translated">如果一个操作数有TEXT亲和力,而另一个操作数没有亲和力,那么TEXT亲和力被应用到另一个操作数上。</target>
        </trans-unit>
        <trans-unit id="4a746052c71f7cca567e925f8568ed0089126b0e" translate="yes" xml:space="preserve">
          <source>If one or more of the column values in the row inserted by the new change differ from those in the row deleted by the existing change, the existing DELETE is replaced by an UPDATE within the changegroup. Otherwise, if the inserted row is exactly the same as the deleted row, the existing DELETE is simply discarded.</source>
          <target state="translated">如果被新的更改插入的行中的一列或多列的值与被现有更改删除的行中的值不同,那么现有的DELETE将被更改组中的UPDATE代替。否则,如果插入的行与删除的行完全相同,那么现有的DELETE就会被丢弃。</target>
        </trans-unit>
        <trans-unit id="bbb903a0b2fa794db9f8ce5d76be92c6e8ad13da" translate="yes" xml:space="preserve">
          <source>If ownership of the pointer is passed into SQLite by providing a non-NULL D parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; then the ownership remains with SQLite until the object is destroyed. There is no way to transfer ownership out of SQLite and back into the application again.</source>
          <target state="translated">如果通过向&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;或&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;提供非NULL D参数将指针的所有权传递到SQLite，则所有权将保留在SQLite中，直到对象被销毁为止。无法将所有权从SQLite移出并再次移回应用程序。</target>
        </trans-unit>
        <trans-unit id="8503abe821374258f98c6ba5585311ca76bf6ece" translate="yes" xml:space="preserve">
          <source>If page 1 data is read as required by H35230, then the value of the</source>
          <target state="translated">如果按照H35230的要求读取第1页的数据,那么第1页中的</target>
        </trans-unit>
        <trans-unit id="017b230392006407b67880da521173469a1b31d0" translate="yes" xml:space="preserve">
          <source>If parameter iCol is greater than or equal to the number of columns in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO error), an appropriate SQLite error code is returned.</source>
          <target state="translated">如果参数iCol大于或等于表中的列数,则返回SQLITE_RANGE。或者,如果发生错误(如OOM条件或IO错误),则返回一个适当的SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="c373aca4c319795b45d2c1f0dc2245e638666f60" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the FTS5 table. Or, if iCol is non-negative but less than the number of columns in the table, return the total number of tokens in column iCol, considering all rows in the FTS5 table.</source>
          <target state="translated">如果参数iCol小于0,则将输出变量*pnToken设置为FTS5表中的令牌总数。或者,如果iCol是非负数,但小于表中的列数,则考虑到FTS5表中的所有行,返回iCol列中的令牌总数。</target>
        </trans-unit>
        <trans-unit id="686ce79e8e629eea956f529880e81a4b9a406c30" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the current row. Or, if iCol is non-negative but less than the number of columns in the table, set *pnToken to the number of tokens in column iCol of the current row.</source>
          <target state="translated">如果参数iCol小于0,则将输出变量*pnToken设置为当前行的tokens总数。或者,如果iCol是非负数,但小于表中的列数,则设置*pnToken为当前行iCol列中的tokens数量。</target>
        </trans-unit>
        <trans-unit id="88577f66da407130b6c2fbcee7dc6e283e2a74d7" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">如果参数zDb为NULL或指向长度为零的字符串，则将对&lt;a href=&quot;../lang_attach&quot;&gt;连接&lt;/a&gt;到&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; db的所有WAL数据库尝试指定的操作。在这种情况下，写入输出参数* pnLog和* pnCkpt的值是不确定的。如果在处理一个或多个附加的WAL数据库时遇到SQLITE_BUSY错误，仍将在所有剩余的附加数据库上尝试该操作，并在最后返回SQLITE_BUSY。如果在处理附加数据库时发生任何其他错误，则将放弃处理并将错误代码立即返回给调用方。如果在处理附加数据库时未遇到错误（SQLITE_BUSY或其他），则返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="83e25a419f885754ebe2acacb05d4faa8a67cc7b" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">如果参数zDb为NULL或指向长度为零的字符串，则将对&lt;a href=&quot;lang_attach&quot;&gt;连接&lt;/a&gt;到&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; db的所有WAL数据库尝试指定的操作。在这种情况下，写入输出参数* pnLog和* pnCkpt的值是不确定的。如果在处理一个或多个附加的WAL数据库时遇到SQLITE_BUSY错误，仍将在所有剩余的附加数据库上尝试该操作，并在最后返回SQLITE_BUSY。如果在处理附加数据库时发生任何其他错误，则将放弃处理并将错误代码立即返回给调用方。如果在处理附加数据库时未遇到错误（SQLITE_BUSY或其他），则返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="d5e79777c8fc72c43d9863555c6ca53f645883e2" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">如果pnLog不为NULL，则* pnLog设置为日志文件中的总帧数；如果由于错误或数据库未处于&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;而无法运行检查点，则将* pnLog设置为-1 。如果pnCkpt不为NULL，则将* pnCkpt设置为日志文件中检查点帧的总数（包括调用该函数之前已被检查点的帧），如果检查点由于错误或错误而无法运行，则将其设置为-1。因为数据库不在WAL模式下。请注意，成功完成SQLITE_CHECKPOINT_TRUNCATE后，日志文件将被截断为零字节，因此* pnLog和* pnCkpt都将设置为零。</target>
        </trans-unit>
        <trans-unit id="d64232e8314def054a53cca48179ce0748631809" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">如果pnLog不为NULL，则* pnLog设置为日志文件中的总帧数；如果由于错误或数据库未处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;而无法运行检查点，则将* pnLog设置为-1 。如果pnCkpt不为NULL，则将* pnCkpt设置为日志文件中检查点帧的总数（包括调用该函数之前已被检查点的帧），如果检查点由于错误或错误而无法运行，则将其设置为-1。因为数据库不在WAL模式下。请注意，成功完成SQLITE_CHECKPOINT_TRUNCATE后，日志文件将被截断为零字节，因此* pnLog和* pnCkpt都将设置为零。</target>
        </trans-unit>
        <trans-unit id="41dd1bdb1c62f1c1fa9eb1f2a9f608c75f290fb8" translate="yes" xml:space="preserve">
          <source>If present, output a more verbose report for each query analyzed.</source>
          <target state="translated">如果存在,则为每个分析的查询输出一个更详细的报告。</target>
        </trans-unit>
        <trans-unit id="dfd446567083de1e9ebdea0d18573182ac68033b" translate="yes" xml:space="preserve">
          <source>If pzTail is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in zSql. These routines only compile the first statement in zSql, so *pzTail is left pointing to what remains uncompiled.</source>
          <target state="translated">如果pzTail不是NULL,那么*pzTail将指向zSql中第一条SQL语句结束后的第一个字节。这些例程只编译zSql中的第一条语句,所以*pzTail被留在指向未编译的地方。</target>
        </trans-unit>
        <trans-unit id="daeeadf12f9cfe6f720cf3d4bdd4fb456397cc60" translate="yes" xml:space="preserve">
          <source>If r[P3] is zero or negative, that means there is no OFFSET and r[P2] is set to be the value of the LIMIT, r[P1].</source>
          <target state="translated">如果r[P3]为零或负值,表示没有OFFSET,r[P2]设置为LIMIT的值,r[P1]。</target>
        </trans-unit>
        <trans-unit id="6c50ebdc1c9d5314285662a0bf55da3e625fe7b5" translate="yes" xml:space="preserve">
          <source>If register P1 holds an integer convert it to a real value.</source>
          <target state="translated">如果寄存器P1持有一个整数,则将其转换为实值。</target>
        </trans-unit>
        <trans-unit id="24add31372893a82dd86705b4a5c1cbba71ea8ec" translate="yes" xml:space="preserve">
          <source>If required to truncate a database page from the end of the database file, the associated</source>
          <target state="translated">如果需要从数据库文件的末尾截断数据库页面,相关的</target>
        </trans-unit>
        <trans-unit id="986e38dddb8763966fae3720cfb00c3ae4f64940" translate="yes" xml:space="preserve">
          <source>If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands as the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; would have been NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3939be1758da993faac1647e5a0238d1c34fd401" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">如果以&lt;a href=&quot;../sharedcache&quot;&gt;共享缓存模式运行&lt;/a&gt;，则应用程序必须保证在备份运行时不访问目标数据库使用的共享缓存。在实践中，这意味着应用程序必须保证正在备份的磁盘文件不会被进程内的任何连接访问，而不仅仅是传递给sqlite3_backup_init（）的特定连接。</target>
        </trans-unit>
        <trans-unit id="91671997be6a1d6d67488b4259ddff989b286fc6" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">如果以&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式运行&lt;/a&gt;，则应用程序必须保证在备份运行时不访问目标数据库使用的共享缓存。在实践中，这意味着应用程序必须保证正在备份的磁盘文件不会被进程内的任何连接访问，而不仅仅是传递给sqlite3_backup_init（）的特定连接。</target>
        </trans-unit>
        <trans-unit id="813ffbbe7a10f587c30164e3c760a93f923869e0" translate="yes" xml:space="preserve">
          <source>If set to 1, then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE. If omitted or set to 0 then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is NORMAL.</source>
          <target state="translated">如果设置为1，则默认的&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt;设置为EXCLUSIVE。如果省略或设置为0，则默认的&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt;为NORMAL。</target>
        </trans-unit>
        <trans-unit id="8dd726c58400329230cb7ffbb590015b7fc272ad" translate="yes" xml:space="preserve">
          <source>If single-thread mode has not been selected at compile-time or start-time, then individual database connections can be created as either multi-thread or serialized. It is not possible to downgrade an individual database connection to single-thread mode. Nor is it possible to escalate an individual database connection if the compile-time or start-time mode is single-thread.</source>
          <target state="translated">如果在编译时或启动时没有选择单线程模式,那么可以将单个数据库连接创建为多线程或序列化。不可能将单个数据库连接降级为单线程模式,如果编译时或启动时没有选择单线程模式,也不可能将单个数据库连接升级为多线程或序列化模式。如果编译时或启动时模式为单线程,也不可能升级单个数据库连接。</target>
        </trans-unit>
        <trans-unit id="297fbafe0f12618a3892916307ed5e193747b9f8" translate="yes" xml:space="preserve">
          <source>If single-thread mode is selected at compile-time, then critical mutexing logic is omitted from the build and it is impossible to enable either multi-thread or serialized modes at start-time or run-time.</source>
          <target state="translated">如果在编译时选择了单线程模式,那么在构建中就会省略关键的互斥逻辑,并且在启动时或运行时无法启用多线程或序列化模式。</target>
        </trans-unit>
        <trans-unit id="bc15b1addaaecdb30cb643e4374238a5f983835b" translate="yes" xml:space="preserve">
          <source>If some future version of SQLite adds new ALTER TABLE capabilities, those capabilities will very likely use one of the two procedures outlined above.</source>
          <target state="translated">如果未来SQLite的某个版本增加了新的ALTER TABLE功能,那么这些功能很可能会使用上述两个过程中的一个。</target>
        </trans-unit>
        <trans-unit id="a247ea4cd25be5ebc1e3446b36da4e3d6e48aaf1" translate="yes" xml:space="preserve">
          <source>If some other error occurs (e.g. an OOM condition), an SQLite error code is returned and *ppValue is set to NULL.</source>
          <target state="translated">如果发生其他错误(如OOM条件),将返回一个SQLite错误代码,并将*ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="e277177a9a5ad8b0a8ae8ddf4692ab5b1cd48938" translate="yes" xml:space="preserve">
          <source>If specified, interpret all relative paths as relative to DIR, instead of the current working directory.</source>
          <target state="translated">如果指定,将所有相对路径解释为相对于DIR,而不是当前工作目录。</target>
        </trans-unit>
        <trans-unit id="c10bbb5923a9a453a504ada2ef95db3b448455c2" translate="yes" xml:space="preserve">
          <source>If specified, use file FILE as the archive. Otherwise, assume that the current &quot;main&quot; database is the archive to be operated on.</source>
          <target state="translated">如果指定,使用文件FILE作为存档。否则,假设当前的 &quot;主 &quot;数据库是要操作的存档。</target>
        </trans-unit>
        <trans-unit id="781f0c1e44a6d5e4cbc382e01b2a73157527db47" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">如果sqlite3_backup_step（）无法获得所需的文件系统锁，则将调用&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler函数&lt;/a&gt;（如果已指定）。如果忙处理程序在锁可用之前返回非零值，则&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给调用方。在这种情况下，可以稍后重试对sqlite3_backup_step（）的调用。如果在调用sqlite3_backup_step（）时使用了源&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;来写入源数据库，则立即返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;。同样，在这种情况下，稍后可以重试对sqlite3_backup_step（）的调用。如果是&lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;返回，则没有必要重试对sqlite3_backup_step（）的调用。这些错误被认为是致命的。应用程序必须接受备份操作失败，并将备份操作句柄传递给sqlite3_backup_finish（）才能释放关联的资源。</target>
        </trans-unit>
        <trans-unit id="97664464d7946d7d0d5f82dbee0724dc2319f847" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">如果sqlite3_backup_step（）无法获得所需的文件系统锁，则将调用&lt;a href=&quot;busy_handler&quot;&gt;busy-handler函数&lt;/a&gt;（如果已指定）。如果忙处理程序在锁可用之前返回非零值，则&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给调用方。在这种情况下，可以稍后重试对sqlite3_backup_step（）的调用。如果在调用sqlite3_backup_step（）时使用了源&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;来写入源数据库，则立即返回&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;。同样，在这种情况下，稍后可以重试对sqlite3_backup_step（）的调用。如果是&lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;，&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;或&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;返回，则没有必要重试对sqlite3_backup_step（）的调用。这些错误被认为是致命的。应用程序必须接受备份操作失败，并将备份操作句柄传递给sqlite3_backup_finish（）才能释放关联的资源。</target>
        </trans-unit>
        <trans-unit id="416d4d371ff0cd3598d43dc30a0639c13aed646a" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">如果sqlite3_deserialize（D，S，P，N，M，F）由于任何原因而失败，并且如果参数F中的SQLITE_DESERIALIZE_FREEONCLOSE位置1，则在返回之前在参数P上调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cec31d664476098d45397cb4e64acc667d8c0501" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">如果sqlite3_deserialize（D，S，P，N，M，F）由于任何原因而失败，并且如果参数F中的SQLITE_DESERIALIZE_FREEONCLOSE位置1，则在返回之前在参数P上调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aeea9650fe067179f154dc4c0a23753bc2cbcaea" translate="yes" xml:space="preserve">
          <source>If sqlite3_malloc() fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer is returned.</source>
          <target state="translated">如果sqlite3_malloc()在处理这两个例程的过程中失败了(例如在UTF-8到UTF-16的转换过程中),那么将返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="cac2f36b365eeaba945df88aa0f1da7631750708" translate="yes" xml:space="preserve">
          <source>If sqlite3_unlock_notify() is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify() is invoked. If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify().</source>
          <target state="translated">如果在多线程应用程序中调用sqlite3_unlock_notify(),那么在调用sqlite3_unlock_notify()的时候,阻塞连接有可能已经结束了它的事务。如果发生这种情况,那么指定的回调会在调用sqlite3_unlock_notify()时立即被调用。</target>
        </trans-unit>
        <trans-unit id="d3dbf8613ad9cf5c029072fff340e1a64123138d" translate="yes" xml:space="preserve">
          <source>If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is automatically created and populated with the single table used to store the state of an RBU vacuum - &quot;rbu_state&quot;. If an ongoing RBU vacuum is suspended, this table is populated with state data. The next time sqlite3rbu_vacuum() is called with the same S parameter, it detects this data and attempts to resume the suspended vacuum operation. When an RBU vacuum operation is completed or encounters an error, RBU automatically deletes the contents of the rbu_state table. In this case, the next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from scratch.</source>
          <target state="translated">如果在调用sqlite3rbu_vacuum()时,状态数据库S不存在,那么它将被自动创建,并被用于存储RBU真空状态的单表--&quot;rbu_state &quot;所填充。如果一个正在进行的RBU真空被暂停,这个表就会被状态数据填充。下一次用相同的S参数调用sqlite3rbu_vacuum()时,它会检测到这些数据,并尝试恢复暂停的真空操作。当一个RBU真空操作完成或遇到错误时,RBU会自动删除rbu_state表的内容。在这种情况下,下一次调用sqlite3rbu_vacuum()会从头开始一个全新的真空操作。</target>
        </trans-unit>
        <trans-unit id="9b583cb7d9f730fb38a0d4c0658d985458639786" translate="yes" xml:space="preserve">
          <source>If step 1 was successful, an attempt is made to read the</source>
          <target state="translated">如果步骤1成功,则尝试读取</target>
        </trans-unit>
        <trans-unit id="95b4922965cf280511e54a7e6a975a3cf943cead" translate="yes" xml:space="preserve">
          <source>If successful, a pointer to a buffer containing the inverted changeset is stored in *ppOut, the size of the same buffer is stored in *pnOut, and SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are zeroed and an SQLite error code returned.</source>
          <target state="translated">如果成功,则在*ppOut中存储一个指向包含反转变化集的缓冲区的指针,在*pnOut中存储相同缓冲区的大小,并返回SQLITE_OK。如果发生错误,*pnOut和*ppOut都被清零,并返回SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="2d2a26797b61cd3892af9cbfe95715fb203e64ff" translate="yes" xml:space="preserve">
          <source>If successful, this function returns SQLITE_OK and populates (*pp) with a pointer to a new sqlite3_changegroup object before returning. The caller should eventually free the returned object using a call to sqlite3changegroup_delete(). If an error occurs, an SQLite error code (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.</source>
          <target state="translated">如果成功,这个函数返回SQLITE_OK,并在返回之前用指向一个新的sqlite3_changegroup对象的指针填充(*pp)。调用者最终应该使用调用 sqlite3changegroup_delete()来释放返回的对象。如果发生错误,则返回一个SQLite错误代码(即SQLITE_NOMEM),并将*pp设置为NULL。</target>
        </trans-unit>
        <trans-unit id="25d0330551ddd2fa16bdd016ab08a130f3f7634f" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the &quot;conflicting row&quot; associated with the current conflict-handler callback and returns SQLITE_OK.</source>
          <target state="translated">如果成功,这个函数将*ppValue设置为指向一个受保护的sqlite3_value对象,该对象包含与当前冲突处理回调相关联的 &quot;冲突行 &quot;的iVal'th值,并返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="fa261183bb429d753dbe1a765227df127f987423" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of new row values stored as part of the UPDATE or INSERT change and returns SQLITE_OK. If the change is an UPDATE and does not include a new value for the requested column, *ppValue is set to NULL and SQLITE_OK returned. The name of the function comes from the fact that this is similar to the &quot;new.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">如果成功,这个函数将*ppValue设置为指向一个受保护的sqlite3_value对象,这个对象包含了作为UPDATE或INSERT更改的一部分而存储的新行值向量中的iVal'th值,并返回SQLITE_OK。如果更改是UPDATE,并且不包含请求列的新值,那么*ppValue被设置为NULL,并返回SQLITE_OK。该函数的名称来自于这与更新或删除触发器可用的 &quot;new.*&quot;列类似。</target>
        </trans-unit>
        <trans-unit id="8a04e15ae358710d2ad80e6a9a9c13bb73faba6b" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of original row values stored as part of the UPDATE or DELETE change and returns SQLITE_OK. The name of the function comes from the fact that this is similar to the &quot;old.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">如果成功,这个函数将*ppValue设置为指向一个受保护的sqlite3_value对象,该对象包含作为UPDATE或DELETE更改的一部分而存储的原始行值向量中的iVal'th值,并返回SQLITE_OK。该函数的名称来自于这与更新或删除触发器可用的 &quot;old.*&quot;列类似。</target>
        </trans-unit>
        <trans-unit id="5f323dfa9043b9e0668bb0be64be173c0214f5b4" translate="yes" xml:space="preserve">
          <source>If successful, xCreateFunction() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">如果成功，则xCreateFunction（）返回SQLITE_OK。否则，它将返回一个SQLite错误代码。在这种情况下，&lt;b&gt;不会&lt;/b&gt;调用xDestroy函数。</target>
        </trans-unit>
        <trans-unit id="0c5491699943eedd46aaea7dc769af1705417f26" translate="yes" xml:space="preserve">
          <source>If successful, xCreateTokenizer() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">如果成功，则xCreateTokenizer（）返回SQLITE_OK。否则，它将返回一个SQLite错误代码。在这种情况下，&lt;b&gt;不会&lt;/b&gt;调用xDestroy函数。</target>
        </trans-unit>
        <trans-unit id="128b9faf8d31130c2470e9c58674eddd1a9c50a3" translate="yes" xml:space="preserve">
          <source>If such a text fragment can be found, it is returned with the following modifications:</source>
          <target state="translated">如果能找到这样的文本片段,则以下列修改后返回。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="2b388f659392c2a3dcc9c7c0db559bd88cf8ff51" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have a &quot;-x&quot; argument, that causes them to accumulate output as Comma-Separated-Values (CSV) in a temporary file, then invoke the default system utility for viewing CSV files (usually a spreadsheet program) on the result. This is a quick way of sending the result of a query to a spreadsheet for easy viewing:</source>
          <target state="translated">如果&quot;.output &quot;或&quot;.once &quot;命令的参数为&quot;-x&quot;,则会导致它们将输出结果以逗号分隔值(CSV)的形式累积到一个临时文件中,然后调用系统默认的实用程序来查看结果上的CSV文件(通常是电子表格程序)。这是一种快速将查询结果发送到电子表格的方法,方便查看。</target>
        </trans-unit>
        <trans-unit id="b4746f29b85def95350d80c6bb29ef47dac1ca98" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have an argument of &quot;-e&quot; then output is collected into a temporary file and the system text editor is invoked on that text file. Thus, the command &quot;.once -e&quot; achieves the same result as &quot;.once '|open -f'&quot; but with the benefit of being portable across all systems.</source>
          <target state="translated">如果&quot;.output &quot;或&quot;.once &quot;命令的参数为&quot;-e&quot;,那么输出将被收集到一个临时文件中,并在该文本文件上调用系统文本编辑器。因此,&quot;.once -e &quot;命令与&quot;.once '|open -f'&quot;的结果是一样的,但其优点是可以在所有系统中移植。</target>
        </trans-unit>
        <trans-unit id="3daa35758772f94d91f7bd83ab5f9ceb0840b773" translate="yes" xml:space="preserve">
          <source>If the &quot;.recover&quot; command recovers one or more rows that it cannot attribute to any database table, the output script creates a &quot;lost_and_found&quot; table to store the orphaned rows. The schema of the lost_and_found table is as follows:</source>
          <target state="translated">如果&quot;.recover &quot;命令恢复了一条或多条不能归属于任何数据库表的记录,输出脚本会创建一个 &quot;lost_and_found &quot;表来存储被遗弃的记录。lost_and_found表的模式如下。</target>
        </trans-unit>
        <trans-unit id="1ddf7f749d8128e48a3bd895bfea3bcecad29d40" translate="yes" xml:space="preserve">
          <source>If the &quot;CREATE VIRTUAL TABLE&quot; statement specifies module FTS4 (not FTS3), then special directives - FTS4 options - similar to the &quot;tokenize=*&quot; option may also appear in place of column names. An FTS4 option consists of the option name, followed by an &quot;=&quot; character, followed by the option value. The option value may optionally be enclosed in single or double quotes, with embedded quote characters escaped in the same way as for SQL literals. There may not be whitespace on either side of the &quot;=&quot; character. For example, to create an FTS4 table with the value of option &quot;matchinfo&quot; set to &quot;fts3&quot;:</source>
          <target state="translated">如果 &quot;CREATE VIRTUAL TABLE &quot;语句指定的是模块FTS4(而不是FTS3),那么类似于 &quot;tokenize=*&quot;选项的特殊指令--FTS4选项也可以出现在列名的位置。一个FTS4选项由选项名组成,后面是一个&quot;=&quot;字符,然后是选项值。选项值可以选择用单引号或双引号括起来,嵌入式引号字符的转义方式与SQL字元的转义方式相同。在&quot;=&quot;字符的两边不能有空格。例如,创建一个FTS4表,选项 &quot;matchinfo &quot;的值设置为 &quot;fts3&quot;。</target>
        </trans-unit>
        <trans-unit id="77546b3dd108217dd30ccb1edbd6835383de8523" translate="yes" xml:space="preserve">
          <source>If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs in between &quot;CREATE&quot; and &quot;VIEW&quot; then the view that is created is only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that created it and is automatically deleted when the database connection is closed.</source>
          <target state="translated">如果&amp;ldquo; TEMP&amp;rdquo;或&amp;ldquo; TEMPORARY&amp;rdquo;关键字出现在&amp;ldquo; CREATE&amp;rdquo;和&amp;ldquo; VIEW&amp;rdquo;之间，则创建的视图仅对创建它的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;可见，并在关闭数据库连接时自动删除。</target>
        </trans-unit>
        <trans-unit id="e15eb31b4ca840d3439ac476fb29777eeeba453d" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the number of rows of the FTS table that contain at least one instance of the term (in any column). If col contains an integer value, then this column contains the number of rows of the FTS table that contain at least one instance of the term in the column identified by the col value. As usual, the columns of the FTS table are numbered from left to right, starting with zero.</source>
          <target state="translated">如果 &quot;col &quot;列包含值'*',那么这一列包含FTS表中至少包含一个术语实例的行数(在任何列中)。如果 &quot;col &quot;列包含一个整数值,那么这一列包含FTS表中至少包含一个术语实例的行数,该术语实例在col值所标识的列中。像往常一样,FTS表的列从左到右编号,从0开始。</target>
        </trans-unit>
        <trans-unit id="be0668162f080a59b68a89416d5dac39edc657f3" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the total number of instances of the term in all rows of the FTS table (in any column). Otherwise, if col contains an integer value, then this column contains the total number of instances of the term that appear in the FTS table column identified by the col value.</source>
          <target state="translated">如果 &quot;col &quot;列包含值'*',那么这一列包含FTS表中所有行(任何一列)中该术语的实例总数。否则,如果col包含一个整数值,那么这一列包含由col值确定的FTS表列中出现的术语实例总数。</target>
        </trans-unit>
        <trans-unit id="f99db6ea5060e99b5afec54227ba46139ccc5e7b" translate="yes" xml:space="preserve">
          <source>If the &quot;schema&quot; is omitted, it defaults to the primary database (usually called 'main', unless renamed using &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;). Hence, the following two queries are normally equivalent:</source>
          <target state="translated">如果省略&amp;ldquo; schema&amp;rdquo;，则默认为主数据库（通常称为&amp;ldquo; main&amp;rdquo;，除非使用&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;重命名）。因此，以下两个查询通常是等效的：</target>
        </trans-unit>
        <trans-unit id="9f6d4e5f223a311e53834767137885dbc0d539c8" translate="yes" xml:space="preserve">
          <source>If the &quot;unordered&quot; argument is present, then the query planner assumes that the index is unordered and will not use the index for a range query or for sorting.</source>
          <target state="translated">如果存在 &quot;unordered &quot;参数,那么查询规划器会假设索引是无序的,并且不会将索引用于范围查询或排序。</target>
        </trans-unit>
        <trans-unit id="8751a71ff20c3c0ca54298560e238a1beb92d451" translate="yes" xml:space="preserve">
          <source>If the $bigstring variable has both a string and a &quot;bytearray&quot; representation, then TCL inserts the value as a string. If it has only a &quot;bytearray&quot; representation, then the value is inserted as a BLOB. To force a value to be inserted as a BLOB even if it also has a text representation, use a &quot;@&quot; character to in place of the &quot;$&quot;. Like this:</source>
          <target state="translated">如果$bigstring变量有字符串和 &quot;字节数组 &quot;两种表示方式,那么TCL就会把值作为字符串插入。如果它只有一个 &quot;字节数组 &quot;表示法,那么这个值将作为一个BLOB插入。要强制将一个值作为BLOB插入,即使它也有文本表示,使用&quot;@&quot;字符来代替&quot;$&quot;。就像这样。</target>
        </trans-unit>
        <trans-unit id="0c3adca9fee497a14e9991dafc4be56e1a6347bb" translate="yes" xml:space="preserve">
          <source>If the %Q formatting option is used instead of %q, like this:</source>
          <target state="translated">如果用%Q格式化选项代替%q,像这样。</target>
        </trans-unit>
        <trans-unit id="0d1bfccef6e7ea95fdaf4eab71d72c15d5446d0c" translate="yes" xml:space="preserve">
          <source>If the --vtab option is passed to sqldiff.exe, then it ignores all underlying shadow tables belonging to an FTS3, FTS5 or rtree virtual table and instead includes the virtual table differences directly.</source>
          <target state="translated">如果将--vtab选项传递给sqldiff.exe,那么它就会忽略所有属于FTS3、FTS5或rtree虚拟表的底层影子表,而直接包含虚拟表的差异。</target>
        </trans-unit>
        <trans-unit id="07a5d9f4ebefe616bbce2e1699c303419392f340" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter actually contains two or more statements of SQL, only the first statement is compiled. (This is different from the behavior of &lt;b&gt;sqlite_exec&lt;/b&gt; which executes all SQL statements in its input string.) The 3rd parameter to &lt;b&gt;sqlite_compile&lt;/b&gt; is made to point to the first character beyond the end of the first statement of SQL in the input. If the 2nd parameter contains only a single SQL statement, then the 3rd parameter will be made to point to the '\000' terminator at the end of the 2nd parameter.</source>
          <target state="translated">如果第二个参数实际上包含两个或多个SQL语句，则仅编译第一个语句。（这与在输入字符串中执行所有SQL语句的&lt;b&gt;sqlite_exec&lt;/b&gt;行为不同。）使&lt;b&gt;sqlite_compile&lt;/b&gt;的第三个参数指向输入中SQL的第一条语句末尾以外的第一个字符。如果第二个参数仅包含一个SQL语句，则将使第三个参数指向第二个参数末尾的'\ 000'终止符。</target>
        </trans-unit>
        <trans-unit id="ace6723edaabac46df7516bfbb37cb232ed631b4" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.</source>
          <target state="translated">如果sqlite3_exec()的第2个参数是一个NULL指针,一个指向空字符串的指针,或者一个只包含whitespace和/或SQL注释的指针,那么就不会评估SQL语句,也不会改变数据库。</target>
        </trans-unit>
        <trans-unit id="c83d25737a958db458bb466d715ef1df1385742b" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">如果sqlite3_open_v2（）的第3个参数不是上面显示的组合之一，可以选择与其他&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_ *位&lt;/a&gt;组合，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="a1fab614cdb3090bc486b1f93bb2bcc48a6de130" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">如果sqlite3_open_v2（）的第3个参数不是上面显示的组合之一，可以选择与其他&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_ *位&lt;/a&gt;组合，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="fab55d69b6d16a6b2315e4a3b04227ca982143b2" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafad762f6d4301ebb9f9fbfe8b641eb52751808" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c05ef78416159159b83c40de507c749c65acd9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">如果设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;标志，则只要在编译时或启动时未设置单线程模式，数据库连接就会以多线程&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;打开。如果设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;标志，则除非在编译时或启动时预先选择了单线程，否则数据库连接将以序列化&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;打开。所述&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;标志导致数据库连接到有资格使用&lt;a href=&quot;sharedcache&quot;&gt;共享高速缓存模式&lt;/a&gt;，而不管是否共享高速缓存的使用使能&lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（） &lt;/a&gt;。该&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;标志使数据库连接即使启用也不会参与&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f124aef410c3a3a5452b1a6fa293c0baf98a2590" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">如果未打开作为第一个参数传递的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;以进行写入（&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;的flags参数为零），则此函数返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b097a680522bfef6d5db94910e22cbe0a87ca6c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法将sqlite3_file.pMethods元素设置为非NULL指针，则即使&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;报告失败，也可以调用sqlite3_io_methods.xClose方法。防止在失败的&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;之后调用xClose的唯一方法是将&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;设置为将sqlite3_file.pMethods元素设置为NULL。</target>
        </trans-unit>
        <trans-unit id="c4075392a6aa7bc2b0c022c207b5beef854359fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;操作码返回SQLITE_OK，则文件描述符将置于&amp;ldquo;批量写入模式&amp;rdquo;，这意味着所有后续写入操作都将在下一个&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE上&lt;/a&gt;进行自动推迟。不支持批量原子写入的系统将返回SQLITE_NOTFOUND。成功执行SQLITE_FCNTL_BEGIN_ATOMIC_WRITE之后，并在关闭&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;或&lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE之前&lt;/a&gt;，SQLite将不在同一&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;文件描述符上进行VFS接口调用，除了使用SQLITE_FHITE_XHINT_ZEH的方法使用&lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FHITE_ZE_SIZE&lt;/a&gt;进行调用外。</target>
        </trans-unit>
        <trans-unit id="eadccb78851e96452064935ca6338980e2d4c8f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">如果&lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法调用sqlite3_vtab_nochange（）并发现UPDATE语句未更改该列，则xColumn方法可以选择返回而不设置结果，而无需调用任何&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx（）接口&lt;/a&gt;。在这种情况下，对于&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法中的同一列，&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;将返回true 。</target>
        </trans-unit>
        <trans-unit id="a8a1933767ab95a99c4ac8ef45461802121a0a08" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">如果未打开作为第一个参数传递的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;以进行写入（&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;的flags参数为零），则此函数返回&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b723e9fc3d49332b65d60edda223c8ec9ca4d696" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface is used to override the glob(X,Y) function with an alternative implementation then the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator will invoke the alternative implementation.</source>
          <target state="translated">如果使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;接口通过替代实现覆盖glob（X，Y）函数，则&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符将调用替代实现。</target>
        </trans-unit>
        <trans-unit id="3092cc5ebddb90376d018bb6c31fa51fc5b9d178" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;操作码返回SQLITE_OK，则文件描述符将置于&amp;ldquo;批量写入模式&amp;rdquo;，这意味着所有后续写入操作都将在下一个&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE上&lt;/a&gt;进行自动推迟。不支持批量原子写入的系统将返回SQLITE_NOTFOUND。成功执行SQLITE_FCNTL_BEGIN_ATOMIC_WRITE之后，并在关闭&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;或&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE之前&lt;/a&gt;，SQLite将不在同一&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;文件描述符上进行VFS接口调用，除了使用SQLITE_FHITE_XHINT_ZEH的方法使用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FHITE_ZE_SIZE&lt;/a&gt;进行调用外。</target>
        </trans-unit>
        <trans-unit id="26aea5eaba4882a7f57e469fe581e38b779b7c63" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">如果设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;标志，则只要在编译时或启动时未设置单线程模式，数据库连接就会以多线程&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;打开。如果设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;标志，则除非在编译时或启动时预先选择了单线程，否则数据库连接将以序列化&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;打开。所述&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;标志导致数据库连接到有资格使用&lt;a href=&quot;../sharedcache&quot;&gt;共享高速缓存模式&lt;/a&gt;，而不管是否共享高速缓存的使用使能&lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（） &lt;/a&gt;。该&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;标志使数据库连接即使启用也不会参与&lt;a href=&quot;../sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d6b9e280cf3c9ed4800b321c18f34c5a4956d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; option is used, then SQLite is capable of using 8+3 filenames but that capabilities is disabled and must be enabled separately for each database connection by using using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; when &lt;a href=&quot;c3ref/open&quot;&gt;opening&lt;/a&gt; or &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ing&lt;/a&gt; the database files and include the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter in the URI. If SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt; then 8+3 filenames are enabled by default and this step can be skipped.</source>
          <target state="translated">如果使用了&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt;选项，则SQLite能够使用8 + 3文件名，但是该功能已禁用，必须在&lt;a href=&quot;c3ref/open&quot;&gt;打开&lt;/a&gt;或&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;数据库文件时使用&lt;a href=&quot;uri&quot;&gt;URI文件&lt;/a&gt;名为每个数据库连接分别启用该功能，并包括URI中的&amp;ldquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &amp;rdquo;查询参数。如果使用&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt;编译SQLite，则默认启用8 + 3个文件名，并且可以跳过此步骤。</target>
        </trans-unit>
        <trans-unit id="f14f4e625a540ecf3e1de270c88730b0b55cfa0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies disk storage for temporary files, then override that decision and use memory storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">如果&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数为临时文件指定了磁盘存储，则覆盖该决定并改用内存存储。否则，请遵循&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数的建议。</target>
        </trans-unit>
        <trans-unit id="cc4e5ad04a8f404976f4ea549e621889ed4a2406" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies memory storage for temporary files, then override that decision and use disk storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">如果&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数为临时文件指定了内存存储，则覆盖该决定并改用磁盘存储。否则，请遵循&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数的建议。</target>
        </trans-unit>
        <trans-unit id="c75f136169c511a3f8a8fd887440953a9ba6fdef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of a column is REAL and that column contains a value that can be converted to an integer without loss of information (if the value contains no fractional part and is not too large to be represented as an integer) then the column may be stored in the record as an integer. SQLite will convert the value back to floating point when extracting it from the record.</source>
          <target state="translated">如果列的&lt;a href=&quot;datatype3#affinity&quot;&gt;亲和力&lt;/a&gt;为REAL，并且该列包含可以转换为整数而不会丢失信息的值（如果该值不包含小数部分，并且也不能太大以表示为整数），则该列可能是以整数形式存储在记录中。从记录中提取值时，SQLite会将值转换回浮点。</target>
        </trans-unit>
        <trans-unit id="6bdd9340a9dcd6ebb4b2136a687baf206a35c611" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not aliased by &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then it is not persistent and might change. In particular the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will change rowids for tables that do not declare an INTEGER PRIMARY KEY. Therefore, applications should not normally access the rowid directly, but instead use an INTEGER PRIMARY KEY.</source>
          <target state="translated">如果&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;不是由&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;别名的，则它不是永久的，并且可能会更改。特别是，&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令将更改未声明INTEGER PRIMARY KEY的表的行ID。因此，应用程序通常不应直接访问rowid，而应使用INTEGER PRIMARY KEY。</target>
        </trans-unit>
        <trans-unit id="96317212b202d64aa994eed839385d463798a08e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; opcode is being used to fetch the value of an unchanging column during an UPDATE operation, then the P5 value is OPFLAG_NOCHNG. This will cause the sqlite3_vtab_nochange() function to return true inside the xColumn method of the virtual table implementation. The P5 column might also contain other bits (OPFLAG_LENGTHARG or OPFLAG_TYPEOFARG) but those bits are unused by &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;.</source>
          <target state="translated">如果在UPDATE操作期间使用&lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;操作码来获取不变列的值，则P5值为OPFLAG_NOCHNG。这将导致sqlite3_vtab_nochange（）函数在虚拟表实现的xColumn方法内部返回true。P5列可能还包含其他位（OPFLAG_LENGTHARG或OPFLAG_TYPEOFARG），但&lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;未使用这些位。</target>
        </trans-unit>
        <trans-unit id="2b4eaedd5855ff13b903e656d850adc325c12c79" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is used on a subquery in the FROM clause of a SELECT statement, that effectively merges the subquery into the outer query. The output of EXPLAIN QUERY PLAN reflects this, as in the following example:</source>
          <target state="translated">如果在SELECT语句的FROM子句中的子查询上使用了展&lt;a href=&quot;optoverview#flattening&quot;&gt;平优化&lt;/a&gt;，则可以有效地将子查询合并到外部查询中。EXPLAIN QUERY PLAN的输出反映了这一点，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="6110f6d9f2445ffa2d331ca1dfcaf53aa3a365b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS&lt;/a&gt; pragma is set to ON and the result of a query is an empty set, then the callback is invoked once with the third parameter (argv) set to 0. In other words</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;EMPTY_RESULT_CALLBACKS&lt;/a&gt;编译指示设置为ON，并且查询结果为空集，则在第三个参数（argv）设置为0的情况下调用一次回调。</target>
        </trans-unit>
        <trans-unit id="b1c24c8f45d6339d5389a76337c9e88f41b5e36a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; flag is set, then the F_FULLFSYNC syncing method is used for all sync operations and the checkpoint_fullfsync setting is irrelevant.</source>
          <target state="translated">如果设置了&lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt;标志，则将F_FULLFSYNC同步方法用于所有同步操作，并且checkpoint_fullfsync设置无关紧要。</target>
        </trans-unit>
        <trans-unit id="a73873febe6d7de1338d537c333841d126c81b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; pragma is ON, then the name of the result is the name of the source table column without the source table name prefix: COLUMN.</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;编译指示为ON，则结果的名称为没有源表名称前缀COLUMN的源表列的名称。</target>
        </trans-unit>
        <trans-unit id="1069754e926abbbcc7551f7b3c103d01ced65dbe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">如果&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法将sqlite3_file.pMethods元素设置为非NULL指针，则即使&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;报告失败，也可以调用sqlite3_io_methods.xClose方法。防止在失败的&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;之后调用xClose的唯一方法是将&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;设置为将sqlite3_file.pMethods元素设置为NULL。</target>
        </trans-unit>
        <trans-unit id="e03a0f37d058bb5a34bec7fac575235294acd0da" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">如果&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法调用sqlite3_vtab_nochange（）并发现UPDATE语句未更改该列，则xColumn方法可以选择返回而不设置结果，而无需调用任何&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx（）接口&lt;/a&gt;。在这种情况下，对于&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法中的同一列，&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;将返回true 。</target>
        </trans-unit>
        <trans-unit id="6aba978070ccc979bd49ef28d0ef204e751d91d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method in a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation returns an error message using &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error()&lt;/a&gt; then give that error message preference over internally-generated messages.</source>
          <target state="translated">如果&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现中的&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法使用&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error（）&lt;/a&gt;返回一条错误消息，则该错误消息优先于内部生成的消息。</target>
        </trans-unit>
        <trans-unit id="a18d90fb5154dfedaa1471558060511dc56cfb54" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL, then &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statements are prohibited for that virtual table, and the virtual table is an &quot;eponymous-only virtual table&quot;. Eponymous-only virtual tables are useful as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法为NULL，则该虚拟表禁止使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句，并且该虚拟表是&amp;ldquo;仅具有名称的虚拟表&amp;rdquo;。仅具有名称的虚拟表可用作&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e36f28038a4ddd30d8f77a7f397ce33837d3478d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; method for the virtual table is defined, and if xFindFunction() sometimes returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, then the constraints might also be of the form:</source>
          <target state="translated">如果为虚拟表定义了&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction（）&lt;/a&gt;方法，并且如果xFindFunction（）有时返回&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;或更大，则约束也可能采用以下形式：</target>
        </trans-unit>
        <trans-unit id="89b6cc463721d8831624d29f70a88929969774cd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;), this pragma causes a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation to run on database</source>
          <target state="translated">如果启用了&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;（通过&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;），则该杂注将导致在数据库上运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作</target>
        </trans-unit>
        <trans-unit id="fa30bb229e0ba6c16b036d0680166f4c0e969175" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;header&lt;/b&gt; argument is true then the first row of the CSV file to be treated as a header rather than as data. The second line of the CSV file becomes the first row of content. If the &lt;b&gt;schema=&lt;/b&gt; options is omitted, then the first line of the CSV file determines the names of the columns.</source>
          <target state="translated">如果&lt;b&gt;header&lt;/b&gt;参数为true，则CSV文件的第一行将被视为标题而不是数据。CSV文件的第二行成为内容的第一行。如果省略&lt;b&gt;schema =&lt;/b&gt;选项，则CSV文件的第一行将确定列的名称。</target>
        </trans-unit>
        <trans-unit id="c1cfb6451556f25af13b7b368489aadb6eb20ce2" translate="yes" xml:space="preserve">
          <source>If the AUTOINCREMENT keyword appears after INTEGER PRIMARY KEY, that changes the automatic ROWID assignment algorithm to prevent the reuse of ROWIDs over the lifetime of the database. In other words, the purpose of AUTOINCREMENT is to prevent the reuse of ROWIDs from previously deleted rows.</source>
          <target state="translated">如果AUTOINCREMENT关键字出现在INTEGER PRIMARY KEY之后,那就改变了自动分配ROWID的算法,以防止在数据库的生命周期内重复使用ROWID。换句话说,AUTOINCREMENT的目的是防止以前删除的行的ROWID被重复使用。</target>
        </trans-unit>
        <trans-unit id="e7ae8b25bf55713a14aa930c0d079c55585a0c82" translate="yes" xml:space="preserve">
          <source>If the C version of the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU library&lt;/a&gt; is available, then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined. Compiling with this macro enables an FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; that uses the ICU library to split a document into terms (words) using the conventions for a specified language and locale.</source>
          <target state="translated">如果&lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU库&lt;/a&gt;的C版本可用，则还可以使用已定义的SQLITE_ENABLE_ICU预处理程序宏来编译FTS。使用此宏进行编译，可使FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;令牌生成器&lt;/a&gt;使用ICU库，使用指定语言和语言环境的约定将文档拆分为术语（单词）。</target>
        </trans-unit>
        <trans-unit id="aade338ead72cd83806851289f36afe9ffee6390" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果尝试执行DELETE操作，但是SQLite返回SQLITE_CONSTRAINT（只有在违反外键约束的情况下才会发生），将使用作为第二个参数传递的&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;调用冲突处理函数。这包括尝试执行DELETE操作的情况，因为对冲突处理程序函数的较早调用返回了&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4726b3dbe2c58403328aff3054192714f5fc075" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果尝试执行DELETE操作，但是SQLite返回SQLITE_CONSTRAINT（只有在违反外键约束的情况下才会发生），将使用作为第二个参数传递的&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;调用冲突处理函数。这包括尝试执行DELETE操作的情况，因为对冲突处理程序函数的较早调用返回了&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a02c654b3d70302948f2081631be3edc27671a93" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has an ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are sorted according to the ORDER BY. The first</source>
          <target state="translated">如果DELETE语句有ORDER BY子句,那么在没有LIMIT子句的情况下,所有要删除的记录都会按照ORDER BY进行排序。第一条</target>
        </trans-unit>
        <trans-unit id="63547bac31e35c719e75fc46ff0cebecf92fd269" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has no ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine the subset that are actually deleted.</source>
          <target state="translated">如果DELETE语句没有ORDER BY子句,那么在应用LIMIT和OFFSET子句确定实际被删除的子集之前,所有在没有LIMIT子句的情况下会被删除的行都会以任意的顺序组合。</target>
        </trans-unit>
        <trans-unit id="20e8eb12f584aa2a2c71da9ffe10b6bc6f97692b" translate="yes" xml:space="preserve">
          <source>If the ESCAPE option is used, the ESCAPE character must be ASCII, or a single-byte character in UTF-8.</source>
          <target state="translated">如果使用ESCAPE选项,ESCAPE字符必须是ASCII码,或UTF-8中的单字节字符。</target>
        </trans-unit>
        <trans-unit id="d5df7edc7165f75cb1f0d5e995a539c8d7c8967f" translate="yes" xml:space="preserve">
          <source>If the F parameter is not one of the above, then the behavior is undefined and probably undesirable. Older versions of SQLite were more tolerant of invalid F parameters than newer versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f76a2496ff32a61cee2f76ed3e0830800bfd787" translate="yes" xml:space="preserve">
          <source>If the FROM clause is omitted from a simple SELECT statement, then the input data is implicitly a single row zero columns wide (i.e.</source>
          <target state="translated">如果在一个简单的SELECT语句中省略了FROM子句,那么输入的数据就隐含在零列宽的单行中(也就是</target>
        </trans-unit>
        <trans-unit id="408ec930c8db59ef8bcaccad18026b5e15f9eaec" translate="yes" xml:space="preserve">
          <source>If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed with a &quot;^&quot; character. In this case, in order to match the token must appear as the very first token in any column of the matching row. Examples:</source>
          <target state="translated">如果FTS表是FTS4表(而不是FTS3表),标记也可以用&quot;^&quot;字符作为前缀。在这种情况下,为了匹配,标记必须作为匹配行中任何列的第一个标记出现。例子。</target>
        </trans-unit>
        <trans-unit id="93fd7e443f86d05e9fc567cfba4cc2ea3b224813" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the 'detail' option set to 'col', then the</source>
          <target state="translated">如果在创建FTS5表时,将 &quot;详细 &quot;选项设置为 &quot;列&quot;,则</target>
        </trans-unit>
        <trans-unit id="99ee296e09aab46dd06e0a5f1c140a90b72606e3" translate="yes" xml:space="preserve">
          <source>If the HAVE_FDATASYNC compile-time option is true, then the default &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for unix systems will attempt to use fdatasync() instead of fsync() where appropriate. If this flag is missing or false, then fsync() is always used.</source>
          <target state="translated">如果HAVE_FDATASYNC编译时选项为true，则Unix系统的默认&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;将在适当的情况下尝试使用fdatasync（）代替fsync（）。如果此标志丢失或为false，则始终使用fsync（）。</target>
        </trans-unit>
        <trans-unit id="8e31d6de70624cd3258a7c666db7d8624e2234e9" translate="yes" xml:space="preserve">
          <source>If the HAVE_GMTIME_R option is true and if &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is true, then the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords will use the threadsafe &quot;gmtime_r()&quot; interface rather than &quot;gmtime()&quot;. In the usual case where &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is not defined or is false, then the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; are used to implement the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords and neither gmtime_r() nor gmtime() is ever called.</source>
          <target state="translated">如果HAVE_GMTIME_R选项为true，并且&lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt;为true，则CURRENT_TIME，CURRENT_DATE和CURRENT_TIMESTAMP关键字将使用线程安全的&amp;ldquo; gmtime_r（）&amp;rdquo;接口而不是&amp;ldquo; gmtime（）&amp;rdquo;。在&lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;未定义SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt;或为false 的通常情况下，内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;用于实现CURRENT_TIME，CURRENT_DATE和CURRENT_TIMESTAMP关键字，并且从未调用过gmtime_r（）和gmtime（）。</target>
        </trans-unit>
        <trans-unit id="40cdcf3ade2687218b791686ca4436d6b3c5cfba" translate="yes" xml:space="preserve">
          <source>If the HAVE_ISNAN option is true, then SQLite invokes the system library isnan() function to determine if a double-precision floating point value is a NaN. If HAVE_ISNAN is undefined or false, then SQLite substitutes its own home-grown implementation of isnan().</source>
          <target state="translated">如果HAVE_ISNAN选项为true,那么SQLite就会调用系统库中的isnan()函数来确定一个双精度浮点值是否为NaN。如果HAVE_ISNAN选项未定义或为false,那么SQLite就会用它自己的自家开发的annan()实现来代替。</target>
        </trans-unit>
        <trans-unit id="153cb2536cd91084b29b41e9d14f8a7ef310cc61" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_R option is true, then SQLite uses the threadsafe localtime_r() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">如果HAVE_LOCALTIME_R选项为true，则SQLite使用线程安全的localtime_r（）库例程而不是localtime（）来帮助实现内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;的&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修饰符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c4b14956847344de7b5a6ccb25e5f358e368735" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_S option is true, then SQLite uses the threadsafe localtime_s() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">如果HAVE_LOCALTIME_S选项为true，则SQLite使用线程安全的localtime_s（）库例程而不是localtime（）来帮助实现内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;的&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修饰符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="997bea68ec053527286253926a4446e11225f13c" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is omitted or is false, then SQLite uses a wrapper around system malloc() and realloc() that enlarges each allocation by 8 bytes and writes the size of the allocation in the initial 8 bytes, and then SQLite also implements its own home-grown version of malloc_usable_size() that consults that 8-byte prefix to find the allocation size. This approach works but it is suboptimal. Applications are encouraged to use HAVE_MALLOC_USABLE_SIZE whenever possible.</source>
          <target state="translated">如果HAVE_MALLOC_USABLE_SIZE选项被省略或为false,那么SQLite就会使用一个围绕系统malloc()和realloc()的封装器,将每个分配额扩大8个字节,并将分配额的大小写在初始的8个字节中,然后SQLite也会实现自己自家开发的malloc_usable_size()版本,参考这个8个字节的前缀来查找分配额的大小。这种方法是可行的,但它是次优的。我们鼓励应用程序尽可能地使用HAVE_MALLOC_USABLE_SIZE。</target>
        </trans-unit>
        <trans-unit id="55308f0ca78c87c49d7100dbf1e1e1adc1d30409" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is true, then SQLite tries uses the malloc_usable_size() interface to find the size of a memory allocation obtained from the standard-library malloc() or realloc() routines. This option is only applicable if the standard-library malloc() is used. On Apple systems, &quot;zone malloc&quot; is used instead, and so this option is not applicable. And, of course, if the application supplies its own malloc implementation using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; then this option has no effect.</source>
          <target state="translated">如果HAVE_MALLOC_USABLE_SIZE选项为true，则SQLite会尝试使用malloc_usable_size（）接口来查找从标准库malloc（）或realloc（）例程获得的内存分配的大小。仅当使用标准库malloc（）时，此选项才适用。在Apple系统上，使用&amp;ldquo;区域malloc&amp;rdquo;代替，因此该选项不适用。而且，当然，如果应用程序使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;提供了自己的malloc实现，则此选项无效。</target>
        </trans-unit>
        <trans-unit id="3344d140659472562fd4dea21990938229ddf3ec" translate="yes" xml:space="preserve">
          <source>If the HAVE_STRCHRNUL option is true, then SQLite uses the strchrnul() library function. If this option is missing or false, then SQLite substitutes its own home-grown implementation of strchrnul().</source>
          <target state="translated">如果HAVE_STRCHRNUL选项为true,那么SQLite就会使用strchrnul()库函数。如果这个选项缺失或为false,那么SQLite就会用它自己的国产strchrnul()实现来代替。</target>
        </trans-unit>
        <trans-unit id="08d8894136dfc0e284f285c182990a928235abdc" translate="yes" xml:space="preserve">
          <source>If the HAVE_USLEEP option is true, then the default unix VFS uses the usleep() system call to implement the xSleep method. If this option is undefined or false, then xSleep on unix is implemented using sleep() which means that &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; will have a minimum wait interval of 1000 milliseconds regardless of its argument.</source>
          <target state="translated">如果HAVE_USLEEP选项为true，则默认的unix VFS使用usleep（）系统调用来实现xSleep方法。如果此选项未定义或为false，则使用sleep（）实现unix上的xSleep，这意味着&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;的最小等待间隔为1000毫秒，无论其参数如何。</target>
        </trans-unit>
        <trans-unit id="538ccd48ed8bd61407504bbf28bbe6d0ffe8bf96" translate="yes" xml:space="preserve">
          <source>If the HAVE_UTIME option is true, then the built-in but non-standard &quot;unix-dotfile&quot; VFS will use the utime() system call, instead of utimes(), to set the last access time on the lock file.</source>
          <target state="translated">如果HAVE_UTIME选项为真,那么内置但非标准的 &quot;unix-dotfile &quot;VFS将使用utime()系统调用,而不是utimes()来设置锁文件的最后访问时间。</target>
        </trans-unit>
        <trans-unit id="7cab5093752cc9a8b0a63442b0923931057ad2d6" translate="yes" xml:space="preserve">
          <source>If the INTO clause is included, then the original database file is unchanged and a new database is created in the filename given by the argument to the INTO clause. The new database will contain the same logical content as the original database, fully vacuumed.</source>
          <target state="translated">如果包含INTO子句,那么原数据库文件不变,在INTO子句参数给出的文件名中创建一个新的数据库。新数据库将包含与原数据库相同的逻辑内容,完全真空化。</target>
        </trans-unit>
        <trans-unit id="b0e0bffd82940bcd9134c72373f0af179d9c5474" translate="yes" xml:space="preserve">
          <source>If the LIMIT expression evaluates to non-negative value</source>
          <target state="translated">如果LIMIT表达式评估为非负值</target>
        </trans-unit>
        <trans-unit id="f61e07bad4e222ccefd74ac63dc52c1ed3c63a8f" translate="yes" xml:space="preserve">
          <source>If the NATURAL keyword is in the join-operator then an implicit USING clause is added to the join-constraints. The implicit USING clause contains each of the column names that appear in both the left and right-hand input datasets. If the left and right-hand input datasets feature no common column names, then the NATURAL keyword has no effect on the results of the join. A USING or ON clause may not be added to a join that specifies the NATURAL keyword.</source>
          <target state="translated">如果在join-operator中使用了NATURAL关键字,那么就会在join-constraints中添加一个隐式的USING子句。隐式USING子句包含左手和右手输入数据集中出现的每个列名。如果左边和右边的输入数据集没有共同的列名,那么NATURAL关键字对连接的结果没有影响。在指定NATURAL关键字的连接中,不能添加USING或ON子句。</target>
        </trans-unit>
        <trans-unit id="a2b9577c2b86e52c07b264eb7017d085b143b677" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routine might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">如果语句返回的第N列是表达式或子查询,而不是列值,那么这些函数都返回NULL。如果发生内存分配错误,这些例程也可能返回NULL。否则,它们会返回查询结果列所提取的附加数据库、表或列的名称。</target>
        </trans-unit>
        <trans-unit id="7286275584ec903ae36c4fc51d813a102d9d7ca1" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routines might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f987b1e749686c5439c4369e9509e69172835e8f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this delete one of several associated with deleting a table row and all its associated index entries. Exactly one of those deletes is the &quot;primary&quot; delete. The others are all on OPFLAG_FORDELETE cursors or else are marked with the AUXDELETE flag.</source>
          <target state="translated">如果在P5上设置了OPFLAG_AUXDELETE位,则表明这次删除是与删除表行及其所有相关索引项相关联的几次删除之一。恰恰其中的一个删除是 &quot;主 &quot;删除。其他的都是在OPFLAG_FORDELETE游标上,否则就用AUXDELETE标志。</target>
        </trans-unit>
        <trans-unit id="2e0584b25ae53697595c710240b674cfcd931b66" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set in P2, then P3 contains the address of the memory cell that contains the value that the rowid of the row will be set to by the update.</source>
          <target state="translated">如果在P2中设置了OPFLAG_ISUPDATE标志,那么P3就包含了包含该行的rowid将被更新设置为的值的内存单元的地址。</target>
        </trans-unit>
        <trans-unit id="85453347b772792d0ef83ca6247504c978601416" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an UPDATE operation. Otherwise (if the flag is clear) then this opcode is part of an INSERT operation. The difference is only important to the update hook.</source>
          <target state="translated">如果OPFLAG_ISUPDATE标志被设置,那么这个操作码是UPDATE操作的一部分。否则(如果标志是清除的),那么这个操作码是INSERT操作的一部分。这两者的区别只对更新钩子很重要。</target>
        </trans-unit>
        <trans-unit id="358930ea0c0cb3bf8ddbac06391138cf9e1e9b1f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then the result is guaranteed to only be used as the argument of a length() or typeof() function, respectively. The loading of large blobs can be skipped for length() and all content loading can be skipped for typeof().</source>
          <target state="translated">如果在P5上设置了OPFLAG_LENGTHARG和OPFLAG_TYPEOFARG位,那么保证结果只能分别作为length()或typeof()函数的参数。对于length()来说,可以跳过大的blob的加载,对于typeof()来说,可以跳过所有的内容加载。</target>
        </trans-unit>
        <trans-unit id="b673a87eca1e30fb0e05ce7b3a0e2e621baf2f1c" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row change count is incremented (otherwise not).</source>
          <target state="translated">如果设置了P2的OPFLAG_NCHANGE标志(NB:P2不是P5),则行变化计数递增(否则不递增)。</target>
        </trans-unit>
        <trans-unit id="8006bf0580f0ceee7abfbb502ff0bc2738a32586" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is incremented (otherwise not). If the OPFLAG_LASTROWID flag of P5 is set, then rowid is stored for subsequent return by the sqlite3_last_insert_rowid() function (otherwise it is unmodified).</source>
          <target state="translated">如果P5的OPFLAG_NCHANGE标志被设置,那么行变化计数会被递增(否则不递增)。如果设置了P5的OPFLAG_LASTROWID标志,那么 rowid将被存储起来,以便后续由sqlite3_last_insert_rowid()函数返回(否则不修改)。</target>
        </trans-unit>
        <trans-unit id="0464f564c819708fc95ba0ca873e884f00c0c5ec" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then the cursor will be left pointing at either the next or the previous record in the table. If it is left pointing at the next record, then the next &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will be a no-op. As a result, in this case it is ok to delete a record from within a &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; loop. If OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be left in an undefined state.</source>
          <target state="translated">如果将P5参数的OPFLAG_SAVEPOSITION位置1，则光标将指向表中的下一个或上一个记录。如果它指向下一条记录，则下一条&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;指令将为空操作。结果，在这种情况下，可以从&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;循环中删除记录。如果P5的OPFLAG_SAVEPOSITION位清零，则光标将处于未定义状态。</target>
        </trans-unit>
        <trans-unit id="b8443bd622375a798ed2a10b2bb936621afb5e73" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equal to P3.</source>
          <target state="translated">如果设置了P5的OPFLAG_USESEEKRESULT标志,那么通过避免在游标P1上进行不必要的查找,实现的运行速度会更快。但是,OPFLAG_USESEEKRESULT标志只有在之前没有在游标上进行搜索,或者最近一次搜索使用的键等于P3的情况下才能被设置。</target>
        </trans-unit>
        <trans-unit id="24d1994d6156f999d1ee517ed391edb59d48c618" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equivalent to P2.</source>
          <target state="translated">如果设置了P5的OPFLAG_USESEEKRESULT标志,那么通过避免在游标P1上进行不必要的查找,实现的运行速度会更快。但是,OPFLAG_USESEEKRESULT标志只有在之前没有在游标上进行过搜索,或者最近一次搜索使用了与P2等价的键的情况下才能被设置。</target>
        </trans-unit>
        <trans-unit id="1f2be7bea7738f3621eca4267ce81f09d41a2e23" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is a constant integer K then the expression is considered an alias for the K-th column of the result set (columns are numbered from left to right starting with 1).</source>
          <target state="translated">如果ORDER BY表达式是一个常数整数K,那么该表达式被认为是结果集第K-th列的别名(列从1开始从左到右编号)。</target>
        </trans-unit>
        <trans-unit id="54b7818868eb0e39bd8ddbed56195f5499a4600b" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is an identifier that corresponds to the alias of one of the output columns, then the expression is considered an alias for that column.</source>
          <target state="translated">如果ORDER BY表达式是一个与某一输出列的别名相对应的标识符,那么该表达式被认为是该列的别名。</target>
        </trans-unit>
        <trans-unit id="00fdbe0ee21cda19b4a8ae7897474539b1f0a75c" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the specified collation sequence is used.</source>
          <target state="translated">如果使用后缀&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;为ORDER BY表达式分配了排序规则序列，则使用指定的排序规则序列。</target>
        </trans-unit>
        <trans-unit id="d77a3e5eca6240aa4cf73a2d563a4460d778268d" translate="yes" xml:space="preserve">
          <source>If the P1 cursor must be pointing to a valid row (not a NULL row) of a real table, not a pseudo-table.</source>
          <target state="translated">如果P1游标必须指向真实表的有效行(不是NULL行),而不是伪表。</target>
        </trans-unit>
        <trans-unit id="1f5366d1e68bed932cc9eadcf38bc5c4aed05e24" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">如果P1索引条目大于或等于键值,则跳转到P2。否则跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="eb12e9cd16de01f1875169ba7dbce89a734843ad" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">如果P1索引条目大于键值,则跳转到P2。否则跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="dbe830f25814f54ccec56a9eb14db5b310130922" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">如果P1索引条目小于或等于键值,则跳转到P2。否则跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="a25915e27b156d98cb891f738fe575b0c439ae6a" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">如果P1索引条目小于键值,则跳转到P2。否则跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="64d6010c68c3d803b2d20f7d66e38f73be2fb061" translate="yes" xml:space="preserve">
          <source>If the P1 value is non-zero, then also set the MEM_Cleared flag so that NULL values will not compare equal even if SQLITE_NULLEQ is set on &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; or &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;.</source>
          <target state="translated">如果P1的值不为零，则还要设置MEM_Cleared标志，以使即使在&lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt;或&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;上设置了SQLITE_NULLEQ，NULL值也不会相等。</target>
        </trans-unit>
        <trans-unit id="f14a9a47b078e93cd304b6691cdab49407396c8d" translate="yes" xml:space="preserve">
          <source>If the P3 value is non-zero, then the table referred to must be an intkey table (an SQL table, not an index). In this case the row change count is incremented by the number of rows in the table being cleared. If P3 is greater than zero, then the value stored in register P3 is also incremented by the number of rows in the table being cleared.</source>
          <target state="translated">如果P3值为非零,那么所指的表必须是一个intkey表(一个SQL表,不是索引)。在这种情况下,行变化计数按被清除表中的行数递增。如果P3大于零,那么存储在寄存器P3中的值也会按被清零表中的行数递增。</target>
        </trans-unit>
        <trans-unit id="5877a66b1cea7b0ea64daa7c24ed48ab6bbcee07" translate="yes" xml:space="preserve">
          <source>If the PRIMARY KEY of a WITHOUT ROWID tables uses the same columns with the same collating sequence more than once, then the second and subsequent occurrences of that column in the PRIMARY KEY definition are ignored. For example, the following CREATE TABLE statements all specify the same table, which will have the exact same representation on disk:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8742c4d987b7b8bb8b01f7cdaee658b0bce0f67" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is followed by a collation-sequence name, then all indices in all attached databases that use the named collation sequences are recreated.</source>
          <target state="translated">如果REINDEX关键字后面跟着一个整理序列名称,那么所有使用命名的整理序列的附加数据库中的所有索引都会被重新创建。</target>
        </trans-unit>
        <trans-unit id="89611a3566f7e2d206b997930c668d8b59f61d02" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is not followed by a collation-sequence or database object identifier, then all indices in all attached databases are rebuilt.</source>
          <target state="translated">如果REINDEX关键字后面没有整理序列或数据库对象标识符,那么所有附加数据库中的所有索引都会被重建。</target>
        </trans-unit>
        <trans-unit id="95360c5e4a315542249137c79e8a2d6b511f7fdc" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;a non-aggregate query&lt;/b&gt;, then each expression in the result expression list is evaluated for each row in the dataset filtered by the WHERE clause.</source>
          <target state="translated">如果SELECT语句&lt;b&gt;是非聚合查询&lt;/b&gt;，则将针对WHERE子句过滤的数据集中的每一行对结果表达式列表中的每个表达式进行求值。</target>
        </trans-unit>
        <trans-unit id="869026a04188f9191fbf03ed77ea46ac1ecc8cb4" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query with a GROUP BY&lt;/b&gt; clause, then each of the expressions specified as part of the GROUP BY clause is evaluated for each row of the dataset. Each row is then assigned to a &quot;group&quot; based on the results; rows for which the results of evaluating the GROUP BY expressions are the same get assigned to the same group. For the purposes of grouping rows, NULL values are considered equal. The usual rules for &lt;a href=&quot;datatype3#collation&quot;&gt;selecting a collation sequence&lt;/a&gt; with which to compare text values apply when evaluating expressions in a GROUP BY clause. The expressions in the GROUP BY clause do &lt;em&gt;not&lt;/em&gt; have to be expressions that appear in the result. The expressions in a GROUP BY clause may not be aggregate expressions.</source>
          <target state="translated">如果SELECT语句是&lt;b&gt;带有GROUP BY&lt;/b&gt;子句&lt;b&gt;的聚合查询&lt;/b&gt;，则将对数据集的每一行评估作为GROUP BY子句的一部分指定的每个表达式。然后根据结果将每一行分配给一个&amp;ldquo;组&amp;rdquo;。将对GROUP BY表达式求值的结果相同的行分配给同一组。为了对行进行分组，将NULL值视为相等。在GROUP BY子句中评估表达式时，将应用&lt;a href=&quot;datatype3#collation&quot;&gt;选择与排序&lt;/a&gt;规则序列进行比较的常规规则。在GROUP BY子句中的这个表达式&lt;em&gt;并非&lt;/em&gt;必须出现在结果表达式。 GROUP BY子句中的表达式不能为聚合表达式。</target>
        </trans-unit>
        <trans-unit id="5f32b910ff370c514af729f0255dcd885c666376" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query without a GROUP BY&lt;/b&gt; clause, then each aggregate expression in the result-set is evaluated once across the entire dataset. Each non-aggregate expression in the result-set is evaluated once for an arbitrarily selected row of the dataset. The same arbitrarily selected row is used for each non-aggregate expression. Or, if the dataset contains zero rows, then each non-aggregate expression is evaluated against a row consisting entirely of NULL values.</source>
          <target state="translated">如果SELECT语句是&lt;b&gt;不带GROUP BY&lt;/b&gt;子句&lt;b&gt;的聚合查询&lt;/b&gt;，则结果集中的每个聚合表达式将在整个数据集中进行一次评估。对于数据集的任意选择的行，结果集中的每个非聚合表达式都会被评估一次。相同的任意选择的行用于每个非聚合表达式。或者，如果数据集包含零行，则将针对完全由NULL值组成的行评估每个非聚合表达式。</target>
        </trans-unit>
        <trans-unit id="14209330d1f571e7543dcd8d5633bd2d841dd6e1" translate="yes" xml:space="preserve">
          <source>If the SELECT statement specified as part of the CREATE VIRTUAL TABLE command returns five columns, then the final column is used for application context only. Swarmvtab does not use this value at all, except that it is passed after &amp;lt;database-name&amp;gt; to both the openclose and missing functions, if specified. In other words, instead of invoking the functions as described above, if the &quot;context&quot; column is present swarmvtab instead invokes:</source>
          <target state="translated">如果作为CREATE VIRTUAL TABLE命令的一部分指定的SELECT语句返回五列，则最后一列仅用于应用程序上下文。Swarmvtab根本不使用该值，只是将它在&amp;lt;database-name&amp;gt;之后传递给openclose和缺少的函数（如果已指定）。换句话说，如果没有出现&amp;ldquo; context&amp;rdquo;列，则swarmvtab代替调用上述函数，而是调用：</target>
        </trans-unit>
        <trans-unit id="40411dedc1ef7864197c263597ddfac1b246cd97" translate="yes" xml:space="preserve">
          <source>If the SQL COMMIT command turns autocommit on and the autocommit logic then tries to commit change but fails because some other process is holding a SHARED lock, then autocommit is turned back off automatically. This allows the user to retry the COMMIT at a later time after the SHARED lock has had an opportunity to clear.</source>
          <target state="translated">如果SQL COMMIT命令开启了自动提交,然后自动提交逻辑试图提交更改,但由于其他进程持有SHARED锁而失败,那么自动提交会自动关闭。这样,用户就可以在SHARED锁有机会清除后,在以后的时间重新尝试COMMIT。</target>
        </trans-unit>
        <trans-unit id="507b41df5b9644d0a599bc2c2ba64c3ea6d21fd9" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">如果正在执行的SQL语句返回任何数据，则每次准备好调用者处理新的数据行时，都将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;。可以使用&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;列访问功能&lt;/a&gt;访问这些值。再次调用sqlite3_step（）以检索下一行数据。</target>
        </trans-unit>
        <trans-unit id="ae2787ab5fa2a6425b73b07a4b0ad6b9f341262a" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">如果正在执行的SQL语句返回任何数据，则每次准备好调用者处理新的数据行时，都将返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。可以使用&lt;a href=&quot;column_blob&quot;&gt;列访问功能&lt;/a&gt;访问这些值。再次调用sqlite3_step（）以检索下一行数据。</target>
        </trans-unit>
        <trans-unit id="95d391fa1b14c12c13b7ff2232dd79f1ad704028" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">如果SQL语句当前未指向有效行，或者列索引​​超出范围，则结果不确定。仅当最近对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）的&lt;/a&gt;调用已返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;并且随后未调用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;时，才可以调用这些例程。如果在&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;之后或&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;以外的值之后调用了这些例程中的任何一个，则结果是不确定的。如果是&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;当这些例程中的任何一个都处于挂起状态时，从另一个线程调用它们，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="34c305f0b8de32e5d504a58326a82216502c31ad" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">如果SQL语句当前未指向有效行，或者列索引​​超出范围，则结果不确定。仅当最近对&lt;a href=&quot;step&quot;&gt;sqlite3_step（）的&lt;/a&gt;调用已返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;并且随后未调用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;和&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;时，才可以调用这些例程。如果在&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;之后或&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;以外的值之后调用了这些例程中的任何一个，则结果是不确定的。如果是&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;当这些例程中的任何一个都处于挂起状态时，从另一个线程调用它们，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="975432fbe3b7571414ef3444c9bae0dbbb675815" translate="yes" xml:space="preserve">
          <source>If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will invoke sqlite3_free() on the serialization buffer when the database connection closes. If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64() if writes on the database cause it to grow larger than M bytes.</source>
          <target state="translated">如果在F中设置了SQLITE_DESERIALIZE_FREEONCLOSE位,那么当数据库连接关闭时,SQLite将在序列化缓冲区上调用sqlite3_free()。如果设置了SQLITE_DESERIALIZE_RESIZEABLE位,那么如果对数据库的写入导致缓冲区增长超过M个字节,SQLite将尝试使用sqlite3_realloc64()增加缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="ea23bbe6e0f5cd400c470a465a873018f1aa3b8b" translate="yes" xml:space="preserve">
          <source>If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or reg(P3) is NULL then the take the jump. If the SQLITE_JUMPIFNULL bit is clear then fall through if either operand is NULL.</source>
          <target state="translated">如果P5的SQLITE_JUMPIFNULL位被设置,且reg(P1)或reg(P3)为NULL,则采取跳转。如果SQLITE_JUMPIFNULL位为清,那么如果任何一个操作数为NULL,则落空。</target>
        </trans-unit>
        <trans-unit id="d13a5c515dea25bad07a7535880df286b04090a5" translate="yes" xml:space="preserve">
          <source>If the SQLite library is compiled without the NDEBUG preprocessor macro, then the PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace &lt;/a&gt; causes the VDBE to trace the execution of programs. Though this feature was originally intended for testing and debugging, it can also be useful in learning about how the VDBE operates. Use &quot;&lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt;&quot; to turn tracing on and &quot;&lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt;&quot; to turn tracing back off. Like this:</source>
          <target state="translated">如果在没有NDEBUG预处理程序宏的情况下编译SQLite库，则PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt;会使VDBE跟踪程序的执行。尽管此功能最初是用于测试和调试的，但它对于了解VDBE的运行方式也很有用。使用&amp;ldquo; &lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt; &amp;rdquo;打开跟踪，使用&amp;ldquo; &lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt; &amp;rdquo;关闭跟踪。像这样：</target>
        </trans-unit>
        <trans-unit id="4b9cda344fb3698660c6374cdcb25b1c3d461a5e" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b55abf3573b260c179e3130856801dc205be5f3" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error. For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous) and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard.</source>
          <target state="translated">如果在CREATE和INDEX之间出现UNIQUE关键字,那么就不允许插入重复的索引条目。任何插入重复条目的尝试都会导致错误。对于唯一索引的目的,所有的NULL值都被认为与所有其他的NULL值不同,因此是唯一的。这是SQL-92标准的两种可能的解释之一(标准中的语言含糊不清),是PostgreSQL、MySQL、Firebird和Oracle遵循的解释。Informix和Microsoft SQL Server遵循标准的另一种解释。</target>
        </trans-unit>
        <trans-unit id="302753955d8021d9d751890a4a62678a7bd1dc4c" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果尝试执行UPDATE操作，但SQLite返回SQLITE_CONSTRAINT，则将冲突处理程序函数与作为第二个参数传递的&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT一起&lt;/a&gt;调用。这包括在较早调用冲突处理程序函数返回&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;之后尝试执行UPDATE操作的情况。</target>
        </trans-unit>
        <trans-unit id="40c8985574cc4136a7a40f15001ace597cd448e0" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果尝试执行UPDATE操作，但SQLite返回SQLITE_CONSTRAINT，则将冲突处理程序函数与作为第二个参数传递的&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT一起&lt;/a&gt;调用。这包括在较早调用冲突处理程序函数返回&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;之后尝试执行UPDATE操作的情况。</target>
        </trans-unit>
        <trans-unit id="751229ce68d5f9fb206ae67bb99718de4be423dd" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement does not have a WHERE clause, all rows in the table are modified by the UPDATE. Otherwise, the UPDATE affects only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression is true&lt;/a&gt;. It is not an error if the WHERE clause does not evaluate to true for any row in the table - this just means that the UPDATE statement affects zero rows.</source>
          <target state="translated">如果UPDATE语句没有WHERE子句，则UPDATE修改表中的所有行。否则，UPDATE仅影响那些WHERE子句&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式为true的行&lt;/a&gt;。如果表中的任何行的WHERE子句都不为true，这不是错误-这仅意味着UPDATE语句影响零行。</target>
        </trans-unit>
        <trans-unit id="074562fe8dfabc7ba122942fddf559f05fa48e31" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement has no ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine which are actually updated.</source>
          <target state="translated">如果UPDATE语句没有ORDER BY子句,那么在没有LIMIT子句的情况下,所有会被更新的行都会以任意的顺序组合在一起,然后再应用LIMIT和OFFSET子句来确定哪些行被实际更新。</target>
        </trans-unit>
        <trans-unit id="0ee1b94b95429e744f462704efa364a50f2413f6" translate="yes" xml:space="preserve">
          <source>If the WAL-index is implemented as a memory-mapped file and that file is read-only to the first thread to connect, then that thread creates an private heap-memory ersazt WAL-index and runs the recovery routine to populate that private WAL-index. The same data results, but it is held privately rather that being written into the public shared memory area.</source>
          <target state="translated">如果WAL-index是以内存映射文件的形式实现的,并且该文件对第一个连接的线程来说是只读的,那么该线程就会创建一个私有的堆内存ersazt WAL-index,并运行恢复例程来填充该私有的WAL-index。结果是相同的数据,但它是被私人持有的,而不是被写入公共共享内存区域。</target>
        </trans-unit>
        <trans-unit id="7648c2d70dafce18f6cb4ef634247a503d61eeca" translate="yes" xml:space="preserve">
          <source>If the WHERE clause evaluates to FALSE, then skip the steps that follow and continue to the next record.</source>
          <target state="translated">如果WHERE子句的值为FALSE,则跳过下面的步骤,继续下一条记录。</target>
        </trans-unit>
        <trans-unit id="37f61285fabc2a1caf8acf5c9c00c9ccc80b5f28" translate="yes" xml:space="preserve">
          <source>If the WHERE clause is not present, all records in the table are deleted. If a WHERE clause is supplied, then only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt; is true are deleted. Rows for which the expression is false or NULL are retained.</source>
          <target state="translated">如果WHERE子句不存在，则删除表中的所有记录。如果提供了WHERE子句，则仅删除WHERE子句&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式&lt;/a&gt;为true的那些行。保留表达式为false或NULL的行。</target>
        </trans-unit>
        <trans-unit id="7ecdfb78c909bf7386760f4b8a9af44a0acb2a2c" translate="yes" xml:space="preserve">
          <source>If the WHERE clause of a query contains an OR expression, then SQLite might use the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; strategy (also known as the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;). In this case there will be single top-level record for the search, with two sub-records, one for each index:</source>
          <target state="translated">如果查询的WHERE子句包含OR表达式，则SQLite可能会使用&lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&amp;ldquo;按联合进行OR&amp;rdquo;&lt;/a&gt;策略（也称为&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化&lt;/a&gt;）。在这种情况下，将有一个用于搜索的顶级记录，其中有两个子记录，每个索引一个：</target>
        </trans-unit>
        <trans-unit id="66d534e3ba541f4a816044bc7bb6de32d19f621c" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74877c4dea96c98f4b3c0b669711d0dd7770d2b9" translate="yes" xml:space="preserve">
          <source>If the _HAVE_SQLITE_CONFIG_H macro is defined then the SQLite source code will attempt to #include a file named &quot;config.h&quot;. The &quot;config.h&quot; file usually contains other configuration options, especially &quot;HAVE_</source>
          <target state="translated">如果定义了_HAVE_SQLITE_CONFIG_H宏,那么SQLite源代码将尝试#包含一个名为 &quot;config.h &quot;的文件。config.h &quot;文件通常包含其他配置选项,特别是 &quot;HAVE_SQLITE_CONFIG_H&quot;。</target>
        </trans-unit>
        <trans-unit id="558abcd908b311140ea78da82869118d13cb3c75" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">如果操作代码为&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt;，并且回调&lt;a href=&quot;#SQLITE_DENY&quot;&gt;函数&lt;/a&gt;返回SQLITE_IGNORE，则将&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt;语句构造为替换NULL值，以代替如果已返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;将被读取的表列。所述&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;返回可用于拒绝一个表中的各个列不可信的用户访问。当&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;引用一个表但没有从该表中提取任何列值时（例如，在诸如&amp;ldquo; SELECT count（*）FROM tab&amp;rdquo;之类的查询中），则对该表调用一次&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; Authorizer回调，其列名为是一个空字符串。如果操作代码为&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;并且回调&lt;a href=&quot;#SQLITE_DENY&quot;&gt;函数&lt;/a&gt;返回SQLITE_IGNORE，然后继续执行&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作，但&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;被禁用，并且所有行均被单独删除。</target>
        </trans-unit>
        <trans-unit id="551e501bb088fee5fee1641a8f77e7fc3633f5dd" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">如果操作代码为&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;，并且回调&lt;a href=&quot;c_deny&quot;&gt;函数&lt;/a&gt;返回SQLITE_IGNORE，则将&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt;语句构造为替换NULL值，以代替如果已返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;将被读取的表列。所述&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;返回可用于拒绝一个表中的各个列不可信的用户访问。当&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;引用一个表但没有从该表中提取任何列值时（例如，在诸如&amp;ldquo; SELECT count（*）FROM tab&amp;rdquo;之类的查询中），则对该表调用一次&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; Authorizer回调，其列名为是一个空字符串。如果操作代码为&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;并且回调&lt;a href=&quot;c_deny&quot;&gt;函数&lt;/a&gt;返回SQLITE_IGNORE，然后继续执行&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;操作，但&lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;被禁用，并且所有行均被单独删除。</target>
        </trans-unit>
        <trans-unit id="bd1e313db1648e3d841b56f1eba1325f9492fb26" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, consider disabling the unused capabilities with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48946c22fc154fe87cb537c121e425dbb9574d0" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, then disable the unused capabilities using:</source>
          <target state="translated">如果应用程序不使用触发器或视图,则使用以下方法禁用未使用的功能。</target>
        </trans-unit>
        <trans-unit id="f5d26d8716b0cdd9f988973fac2e73b815006603" translate="yes" xml:space="preserve">
          <source>If the application does use triggers or views, then use queries to scan the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table to verify that the triggers and views found there are expected, that there are no surplus triggers or views, existing triggers and views have not been tampered with, and that no existing ordinary tables have been replaced by malicious views.</source>
          <target state="translated">如果应用程序确实使用了触发器或视图，则使用查询来扫描&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;表，以验证找到的触发器和视图是预期的，没有多余的触发器或视图，现有的触发器和视图未被篡改以及没有现有的普通表已被恶意视图取代。</target>
        </trans-unit>
        <trans-unit id="0aef3c759a1be5c730a8586e6ee0c4911bb88637" translate="yes" xml:space="preserve">
          <source>If the application includes any &lt;a href=&quot;appfunc&quot;&gt;custom SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab#customvtab&quot;&gt;custom virtual tables&lt;/a&gt; that have side effects or that might leak privileged information, then the application should use one or more of the techniques below to prevent a maliciously crafted database schema from surreptitiously running those SQL functions and/or virtual tables for nefarious purposes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2469e0f7ca599347e4594642b1d8b0b3f0287081" translate="yes" xml:space="preserve">
          <source>If the application invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) on the database connection prior to closing, then the final checkpoint is still run but the WAL and WAL-index files are not deleted as they normally would be. This leaves the database in a state that allows other processes without write permission on the database, WAL, or WAL-index files to open the database read-only. If the WAL and WAL-index files are missing, then a process that lacks permission to create and initialize those files will not be able to open the database, unless the database is designated as immutable using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">如果应用程序在关闭之前在数据库连接上调用&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;），则最终检查点仍将运行，但不会像通常那样删除WAL和WAL-index文件。这使数据库处于一种状态，该状态允许其他对数据库，WAL或WAL-index文件没有写许可权的进程以只读方式打开数据库。如果缺少WAL和WAL-index文件，则除非创建了&lt;a href=&quot;uri#uriimmutable&quot;&gt;不可变查询参数&lt;/a&gt;将该数据库指定为不可变的，否则缺少创建和初始化那些文件的权限的进程将无法打开数据库。</target>
        </trans-unit>
        <trans-unit id="0623d9575995bdb9d6c267b0da83f975d16d83ea" translate="yes" xml:space="preserve">
          <source>If the application is designed to manage data in small pieces, then the database should never contain any large strings or BLOBs and hence element 1 above should not be a factor. If the database does contain large strings or BLOBs, they should be read using &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; and rows that contain the large strings or BLOBs should never be update by any means other than &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt;. Otherwise, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; routine will need to read the entire row into contiguous memory at some point, and that will involve at least one large memory allocation.</source>
          <target state="translated">如果应用程序旨在管理小块数据，则数据库不应包含任何大字符串或BLOB，因此，上面的元素1不应成为因素。如果数据库确实包含大字符串或BLOB，则应使用&lt;a href=&quot;c3ref/blob&quot;&gt;增量BLOB I / O&lt;/a&gt;读取它们，并且包含大字符串或BLOB的行不应通过&lt;a href=&quot;c3ref/blob&quot;&gt;增量BLOB I / O&lt;/a&gt;以外的任何其他方式进行更新。否则，&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;例程将需要在某一时刻将整行读取到连续内存中，这将涉及至少一个大内存分配。</target>
        </trans-unit>
        <trans-unit id="d0ebb1eaae39f6046644fb7a5c8e50db080966a3" translate="yes" xml:space="preserve">
          <source>If the application or host computer crashes before the transaction completes, then the rollback journal or write-ahead log contains information needed to restore the main database file to a consistent state. When a rollback journal or write-ahead log contains information necessary for recovering the state of the database, they are called a &quot;hot journal&quot; or &quot;hot WAL file&quot;. Hot journals and WAL files are only a factor during error recovery scenarios and so are uncommon, but they are part of the state of an SQLite database and so cannot be ignored. This document defines the format of a rollback journal and the write-ahead log file, but the focus is on the main database file.</source>
          <target state="translated">如果应用程序或主机在事务完成之前崩溃,那么回滚日志或写头日志包含了将主数据库文件恢复到一致状态所需的信息。当回滚日志或写前日志包含恢复数据库状态所需的信息时,它们被称为 &quot;热日志 &quot;或 &quot;热WAL文件&quot;。热日志和WAL文件只是在错误恢复场景中的一个因素,所以并不常见,但它们是SQLite数据库状态的一部分,所以不能忽视。本文档定义了回滚日志和写前日志文件的格式,但重点是主数据库文件。</target>
        </trans-unit>
        <trans-unit id="2a5d41f54973dce5874420b1200abe91d1314dc8" translate="yes" xml:space="preserve">
          <source>If the application uses &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side effects, then it is recommended to set the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on those SQL functions to prevent them from being used inside triggers and views. To illustrate the importance of this flag, consider an application that implements an SQL function &quot;send_money(...)&quot;. Without the SQLITE_DIRECTONLY flag, an attacker might be able to add a trigger or view that uses that custom function, then trick a high-privilege application to run an otherwise harmless query that invokes that malicious trigger or view. The SQLITE_DIRECTONLY flag prevents the attack by requiring the &quot;send_money()&quot; function to be invoked directly by the application, rather than indirectly through a trigger or view.</source>
          <target state="translated">如果应用程序使用具有副作用的应用&lt;a href=&quot;c3ref/create_function&quot;&gt;程序定义的SQL函数&lt;/a&gt;，则建议在这些SQL函数上设置&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志，以防止在触发器和视图中使用它们。为了说明此标志的重要性，请考虑实现SQL函数&amp;ldquo; send_money（...）&amp;rdquo;的应用程序。没有SQLITE_DIRECTONLY标志，攻击者可能能够添加使用该自定义功能的触发器或视图，然后诱使高特权应用程序运行调用该恶意触发器或视图的否则无害的查询。 SQLITE_DIRECTONLY标志通过要求应用程序直接调用&amp;ldquo; send_money（）&amp;rdquo;函数而不是通过触发器或视图间接调用来防止攻击。</target>
        </trans-unit>
        <trans-unit id="d6f9cd1b9ea5044b899607d0f8509b7399b72066" translate="yes" xml:space="preserve">
          <source>If the application wanted to keep all content in memory, it could continue reading and parsing the other pages using a background thread after drawing the first page. Or, since reading from SQLite is so efficient, the application might instead choose to reduce its memory footprint and only keep a single slide in memory at a time. Or maybe it keeps the current slide and the next slide in memory, to facility rapid transitions to the next slide.</source>
          <target state="translated">如果应用程序想将所有内容保留在内存中,它可以在绘制第一页后,使用后台线程继续读取和解析其他页面。或者,由于从SQLite中读取的效率很高,应用程序可能会选择减少其内存占用,一次只在内存中保留一张幻灯片。或者,它可能在内存中保留当前幻灯片和下一张幻灯片,以便快速过渡到下一张幻灯片。</target>
        </trans-unit>
        <trans-unit id="8569a113bc3212a8fdd578bf6c990f890a161761" translate="yes" xml:space="preserve">
          <source>If the argument N is positive then the suggested cache size is set to N. If the argument N is negative, then the number of cache pages is adjusted to be a number of pages that would use approximately abs(N*1024) bytes of memory based on the current page size. SQLite remembers the number of pages in the page cache, not the amount of memory used. So if you set the cache size using a negative number and subsequently change the page size (using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command) then the maximum amount of cache memory will go up or down in proportion to the change in page size.</source>
          <target state="translated">如果参数N为正，则建议的缓存大小设置为N。如果参数N为负，则将缓存页数调整为将使用大约abs（N * 1024）字节内存的页数。根据当前页面大小。SQLite会记住页面缓存中的页面数，而不是所使用的内存量。因此，如果您使用负数设置高速缓存大小，然后更改页面大小（使用&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt;命令），则最大高速缓存内存将与页面大小的变化成比例地增加或减少。</target>
        </trans-unit>
        <trans-unit id="333007bde9d13022c1e70f3f252829b77ea3504a" translate="yes" xml:space="preserve">
          <source>If the argument N is zero then the soft heap limit is disabled.</source>
          <target state="translated">如果参数N为0,那么软堆限制将被禁用。</target>
        </trans-unit>
        <trans-unit id="0910062f14fed63da9341471516f0b8c2feb398e" translate="yes" xml:space="preserve">
          <source>If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates.</source>
          <target state="translated">如果json(X)的参数X包含有重复标签的JSON对象,那么是否保留重复的标签是没有定义的。当前的实现保留了重复的内容。然而,未来对该例程的增强可能会选择默默地删除重复的对象。</target>
        </trans-unit>
        <trans-unit id="6f833aefc23dc66bc8a11fd873780dad93c32799" translate="yes" xml:space="preserve">
          <source>If the argument is an empty string then the authorizer is disabled. If the argument is omitted, then the current authorizer is returned.</source>
          <target state="translated">如果参数是空字符串,那么授权器将被禁用,如果参数被省略,则返回当前授权器。如果参数被省略,则返回当前的授权者。</target>
        </trans-unit>
        <trans-unit id="db2e11d8e987617a2ede3ca5cb77cc0207ab30da" translate="yes" xml:space="preserve">
          <source>If the argument to %Q is a null pointer then the output is an unquoted &quot;NULL&quot;. In other words, a null pointer generates an SQL NULL, and a non-null pointer generates a valid SQL string literal. If the argument to %q is a null pointer then no output is generated. Thus a null-pointer to %q is the same as an empty string.</source>
          <target state="translated">如果%Q的参数是一个空指针,那么输出的是一个未引用的 &quot;NULL&quot;。换句话说,null指针会生成一个SQL NULL,而非null指针会生成一个有效的SQL字符串文字。如果%q的参数是一个空指针,那么就不会产生输出。因此,指向%q的空指针和空字符串是一样的。</target>
        </trans-unit>
        <trans-unit id="34bfefe0d198d1d0315cf64a45912620ff3af0d6" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; is negative N, that means to use approximately -1024*N bytes of memory for the page cache regardless of the page size.</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt;的参数为负N，则意味着无论页面大小如何，都将大约-1024 * N字节的内存用于页面缓存。</target>
        </trans-unit>
        <trans-unit id="ad1260c6e1a01baa74d5f905fe5850603affd484" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or sqlite3_mutex_leave() is a NULL pointer, then all three routines behave as no-ops.</source>
          <target state="translated">如果sqlite3_mutex_enter()、sqlite3_mutex_try()或sqlite3_mutex_leave()的参数是一个NULL指针,那么这三个例程的行为都是no-ops。</target>
        </trans-unit>
        <trans-unit id="0142caf16fb3155af68268c72b44fbf8e770bbff" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_held() is a NULL pointer then the routine should return 1. This seems counter-intuitive since clearly the mutex cannot be held if it does not exist. But the reason the mutex does not exist is because the build is not using mutexes. And we do not want the assert() containing the call to sqlite3_mutex_held() to fail, so a non-zero return is the appropriate thing to do. The sqlite3_mutex_notheld() interface should also return 1 when given a NULL pointer.</source>
          <target state="translated">如果sqlite3_mutex_held()的参数是一个NULL指针,那么这个例程应该返回1。这似乎有悖于直觉,因为很明显,如果mutex不存在,它就不能被持有。但是,mutex不存在的原因是因为构建过程中没有使用mutexes。而且我们不希望包含调用sqlite3_mutex_held()的assert()失败,所以非零返回是合适的做法。sqlite3_mutex_notheld()接口在给定一个NULL指针时也应该返回1。</target>
        </trans-unit>
        <trans-unit id="a14ce7fd473c10953375f9ccbf76e06b28005ef4" translate="yes" xml:space="preserve">
          <source>If the array variable name is omitted or is the empty string, then the value of each column is stored in a variable with the same name as the column itself. For example:</source>
          <target state="translated">如果数组变量名被省略或者是空字符串,那么每一列的值就会被存储在一个与该列本身同名的变量中。例如</target>
        </trans-unit>
        <trans-unit id="ac696fda1c1264eced84b7c7d2919bb500892965" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果由于某些其他违反约束（例如NOT NOT NULL或UNIQUE）的原因而导致插入行的尝试失败，则将第二个参数设置为&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;来调用冲突处理程序函数。这包括由于先前对冲突处理程序函数的调用返回&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;而重新尝试INSERT操作的情况。</target>
        </trans-unit>
        <trans-unit id="00b4296a5ab760c82790fc716c15427ea1f6520d" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">如果由于某些其他违反约束（例如NOT NOT NULL或UNIQUE）的原因而导致插入行的尝试失败，则将第二个参数设置为&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;来调用冲突处理程序函数。这包括由于先前对冲突处理程序函数的调用返回&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;而重新尝试INSERT操作的情况。</target>
        </trans-unit>
        <trans-unit id="1a0b7bf9240c877d42c55de96b224187eca54a50" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">如果由于数据库已经包含具有相同主键值的行而导致插入行的尝试失败，则将第二个参数设置为&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;来调用冲突处理程序函数。</target>
        </trans-unit>
        <trans-unit id="86e563d45d385632baebf3e72388be8c4af6aec3" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">如果由于数据库已经包含具有相同主键值的行而导致插入行的尝试失败，则将第二个参数设置为&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;来调用冲突处理程序函数。</target>
        </trans-unit>
        <trans-unit id="3629ea18c991de1dc5f5b9e0680718c68964bd44" translate="yes" xml:space="preserve">
          <source>If the bClear argument is non-zero, then the auxiliary data is cleared (set to NULL) before this function returns. In this case the xDelete, if any, is not invoked.</source>
          <target state="translated">如果bClear参数是非零,那么在该函数返回之前,辅助数据被清除(设置为NULL)。在这种情况下,如果有xDelete,则不会被调用。</target>
        </trans-unit>
        <trans-unit id="85be6aa821286c3a809817d29ac82866a6650696" translate="yes" xml:space="preserve">
          <source>If the backup process is restarted frequently enough it may never run to completion and the backupDb() function may never return.</source>
          <target state="translated">如果备份进程频繁重启,可能永远不会运行完成,backupDb()函数可能永远不会返回。</target>
        </trans-unit>
        <trans-unit id="ed3ecd64439c51685da70c45077d54474b903f89" translate="yes" xml:space="preserve">
          <source>If the base expression is NULL then the result of the CASE is always the result of evaluating the ELSE expression if it exists, or NULL if it does not.</source>
          <target state="translated">如果基础表达式为NULL,那么CASE的结果总是在ELSE表达式存在的情况下评估ELSE表达式的结果,如果不存在,则为NULL。</target>
        </trans-unit>
        <trans-unit id="8a427aa0dc34d2b046c1ad51ad7573c594257eb3" translate="yes" xml:space="preserve">
          <source>If the base window has an ORDER BY clause, it is copied into the new window. In this case the new window must not specify an ORDER BY clause. If the base window has no ORDER BY clause, one may be specified as part of the new window definition.</source>
          <target state="translated">如果基本窗口有一个ORDER BY子句,它将被复制到新窗口中。在这种情况下,新窗口必须不指定 ORDER BY 子句。如果基本窗口没有 ORDER BY 子句,则可以指定一个子句作为新窗口定义的一部分。</target>
        </trans-unit>
        <trans-unit id="119dee4cbf58f5993be5ffddf2563e1e23c3d8e2" translate="yes" xml:space="preserve">
          <source>If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed. If an error occurs while committing the transaction, an error code is returned and the transaction rolled back.</source>
          <target state="translated">如果被关闭的blob句柄被打开用于读写访问,并且如果数据库处于自动提交模式,并且没有其他打开的读写blob句柄或活动的写语句,则当前事务被提交。如果提交事务时发生错误,则返回错误代码,事务回滚。</target>
        </trans-unit>
        <trans-unit id="a888511d0d42c7a009b52c11f52254e39a8e8777" translate="yes" xml:space="preserve">
          <source>If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.</source>
          <target state="translated">如果被阻塞的连接试图在共享缓存表上获得写锁,而当前有多个其他连接在同一张表上持有读锁,那么SQLite会任意选择其他连接中的一个作为阻塞连接。</target>
        </trans-unit>
        <trans-unit id="b15e015a6e8222ac8277a814fcfbbc84b5b7b2fa" translate="yes" xml:space="preserve">
          <source>If the branch instruction that implements the &quot;c!=0&quot; test on line 58 is changed into a no-op, then the while-loop will loop forever and the test suite will fail with a time-out. But if that branch is changed into an unconditional jump, then the hash function will always return 0. The problem is that 0 is a valid hash. A hash function that always returns 0 still works in the sense that SQLite still always gets the correct answer. The table-name hash table degenerates into a linked-list and so the table-name lookups that occur while parsing SQL statements might be a little slower, but the end result will be the same.</source>
          <target state="translated">如果将第58行实现 &quot;c!=0 &quot;测试的分支指令改为无条件跳转,那么while-loop将永远循环,测试套件将超时失败。但如果将该分支改为无条件跳转,那么哈希函数将永远返回0。问题是,0是一个有效的哈希值。一个总是返回0的哈希函数仍然有效,在这个意义上,SQLite仍然总是得到正确的答案。表名哈希表会退化成一个链接列表,因此在解析SQL语句时发生的表名查找可能会慢一点,但最终结果是一样的。</target>
        </trans-unit>
        <trans-unit id="d10a175cfd1fe16985e295daacc2dcfb3f2982ad" translate="yes" xml:space="preserve">
          <source>If the buffer contains a patchset, then all prior calls to this function on the same changegroup object must also have specified patchsets. Or, if the buffer contains a changeset, so must have the earlier calls to this function. Otherwise, SQLITE_ERROR is returned and no changes are added to the changegroup.</source>
          <target state="translated">如果缓冲区包含一个补丁集,那么之前对同一changegroup对象的所有函数调用也必须有指定的补丁集。或者,如果缓冲区包含一个变化集,那么必须有之前对这个函数的调用。否则,将返回SQLITE_ERROR,并且没有任何变化被添加到changegroup中。</target>
        </trans-unit>
        <trans-unit id="5cba5e39badf94f78fab97af6a07c73e6243cd28" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">如果忙回调为NULL，则在遇到锁定时立即返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果忙回调不为NULL，则可以使用两个参数来调用该回调。</target>
        </trans-unit>
        <trans-unit id="5b0bd17ec528127c481fd60daa34e2af13ea7150" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">如果忙回调为NULL，则在遇到锁定时立即返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果忙回调不为NULL，则可以使用两个参数来调用该回调。</target>
        </trans-unit>
        <trans-unit id="afcbf1f3e790adb1bb6040c89a071eb5f4f5a2b5" translate="yes" xml:space="preserve">
          <source>If the busy method is invoked without an argument, the name of the callback procedure last set by the busy method is returned. If no callback procedure has been set, an empty string is returned.</source>
          <target state="translated">如果在没有参数的情况下调用了busy方法,则返回busy方法最后设置的回调过程的名称,如果没有设置回调过程,则返回一个空字符串。如果没有设置回调过程,则返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="85f5b0357119cb8e1c6a774de7f6ae30085546fa" translate="yes" xml:space="preserve">
          <source>If the cache validate procedure prescribed by H35040 is required and does not prove that the</source>
          <target state="translated">如果需要H35040规定的缓存验证程序,并且不能证明</target>
        </trans-unit>
        <trans-unit id="854ac2efa118a1d9433a97bc97dd8176f442561c" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35140 fails (due to an IO error or similar), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35140所要求的对xAccess()的调用失败(由于IO错误或类似的原因),那么SQLite应放弃打开的尝试。</target>
        </trans-unit>
        <trans-unit id="1c9becc9db0bbc14b6323875b3f39aa5c2a244e7" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35490所要求的对xAccess()的调用失败(由于IO或其他内部VFS错误),那么SQLite应放弃打开某个</target>
        </trans-unit>
        <trans-unit id="7bd0a091025aae3680b1db643d16d28c98cc6e9b" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 reveals that the journal file is no longer present in the file system, then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果对H35490要求的xAccess()的调用显示文件系统中已经不存在日志文件,那么SQLite应放弃打开一个</target>
        </trans-unit>
        <trans-unit id="3c3c8cf623e8c157f82c9c8bd8de3ce49f6292d0" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35160所要求的对xCheckReservedLock()的调用失败(由于IO或其他内部VFS错误),那么SQLite应放弃尝试打开一个</target>
        </trans-unit>
        <trans-unit id="527cca95e4fd8fdc84a2ca6b5f00a7e854482d28" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 indicates that some other</source>
          <target state="translated">如果H35160所要求的对xCheckReservedLock()的调用表明,其他一些</target>
        </trans-unit>
        <trans-unit id="b6b7e886a7c9cbfdadb1dc23e73d315693f496ee" translate="yes" xml:space="preserve">
          <source>If the call to xDelete() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35450所要求的对xDelete()的调用失败(由于IO或其他内部VFS错误),那么SQLite应放弃尝试打开一个</target>
        </trans-unit>
        <trans-unit id="5af5d373c56bb9dcd62ea184e1e76437bf4a9601" translate="yes" xml:space="preserve">
          <source>If the call to xFileSize() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35450要求的对xFileSize()的调用失败(由于IO或其他内部VFS错误),那么SQLite将放弃打开一个</target>
        </trans-unit>
        <trans-unit id="2a548d9a4e673897d73f6b03d7eb848a11645c48" translate="yes" xml:space="preserve">
          <source>If the call to xOpen() required by H35440 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">如果H35440所要求的对xOpen()的调用失败(由于IO或其他内部VFS错误),那么SQLite应放弃打开某个</target>
        </trans-unit>
        <trans-unit id="d1ec650a833c11cb6d8b04d5f0bcc10f45ba6aa9" translate="yes" xml:space="preserve">
          <source>If the callback function returns any value other than SQLITE_OK, the query is abandoned and the xQueryPhrase function returns immediately. If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK. Otherwise, the error code is propagated upwards.</source>
          <target state="translated">如果回调函数返回SQLITE_OK以外的任何值,则放弃查询,xQueryPhrase函数立即返回。如果返回的值是SQLITE_DONE,xQueryPhrase返回SQLITE_OK。否则,错误代码会向上传播。</target>
        </trans-unit>
        <trans-unit id="e7031b92fb19c04c6b57152812c2809849a4f000" translate="yes" xml:space="preserve">
          <source>If the callback function to &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.</source>
          <target state="translated">如果&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的回调函数返回非零值，则sqlite3_exec（）将返回SQLITE_ABORT。</target>
        </trans-unit>
        <trans-unit id="a386306ee9feeed2835e0b935d9f3858fdfe7719" translate="yes" xml:space="preserve">
          <source>If the change to table X also affects other tables or indexes or triggers are views within schema, then run &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements to modify those other tables indexes and views too. For example, if the name of a column changes, all FOREIGN KEY constraints, triggers, indexes, and views that refer to that column must be modified.</source>
          <target state="translated">如果对表X的更改也影响其他表或索引，或者触发器是架构内的视图，则运行&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句也可以修改其他表的索引和视图。例如，如果列名更改，则必须修改所有引用该列的FOREIGN KEY约束，触发器，索引和视图。</target>
        </trans-unit>
        <trans-unit id="4f32e1ca273326c7edb692e7f8fb897873c86b6d" translate="yes" xml:space="preserve">
          <source>If the columns of your result set are named by AS clauses, then SQLite is guaranteed to use the identifier to the right of the AS keyword as the column name. If the result set does not use an AS clause, then SQLite is free to name the column anything it wants. See the &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; documentation for further information.</source>
          <target state="translated">如果结果集的列由AS子句命名，则SQLite保证使用AS关键字右侧的标识符作为列名。如果结果集不使用AS子句，则SQLite可以随意为其命名该列。有关更多信息，请参见&lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="2f6ac289e0c179705fc9860a15b31aba8aa6dfe9" translate="yes" xml:space="preserve">
          <source>If the compression method for the record is either 0 or 8 (see below), then the uncompressed data associated with the zip file entry. Or, if the compression method is not 0 or 8, this column contains a NULL value.</source>
          <target state="translated">如果记录的压缩方法是0或8(见下文),那么与压缩文件条目相关的未压缩数据。或者,如果压缩方法不是0或8,这一列包含一个NULL值。</target>
        </trans-unit>
        <trans-unit id="6d7fff8b9b0e80fbe64f6ffbfb79c99106754efa" translate="yes" xml:space="preserve">
          <source>If the content is compressed, then such an &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; database is &lt;a href=&quot;affcase1#smaller&quot;&gt;the same size&lt;/a&gt; (&amp;plusmn;1%) as an equivalent ZIP archive, and it has the advantage of being able to update individual &quot;files&quot; without rewriting the entire document.</source>
          <target state="translated">如果内容是压缩的，则此类&lt;a href=&quot;sqlar&quot;&gt;SQLite存档&lt;/a&gt;数据库&lt;a href=&quot;affcase1#smaller&quot;&gt;的大小&lt;/a&gt;与等效的ZIP存档大小相同（&amp;plusmn;1％），并且具有无需更新整个文档即可更新单个&amp;ldquo;文件&amp;rdquo;的优点。</target>
        </trans-unit>
        <trans-unit id="07d4949504c6ebefef1a44e834288b1c17ef2c29" translate="yes" xml:space="preserve">
          <source>If the content of a subquery might need to be visited more than once, then the use of a co-routine is undesirable, as the co-routine would then have to compute the data more than once. And if the subquery cannot be flattened, that means the subquery must be manifested into a transient table.</source>
          <target state="translated">如果一个子查询的内容可能需要访问不止一次,那么使用协程是不可取的,因为协程就必须不止一次地计算数据。而如果子查询不能被扁平化,那就意味着子查询必须表现为一个瞬时表。</target>
        </trans-unit>
        <trans-unit id="c4de8e7a63ccfd940999297f77703800e91edb69" translate="yes" xml:space="preserve">
          <source>If the content option is used along with the languageid option, then the named languageid column must exist in the content= table (subject to the usual rules - if a query never needs to read the content table then this restriction does not apply).</source>
          <target state="translated">如果content选项和languageid选项一起使用,那么命名的languageid列必须存在于content=表中(受制于通常的规则--如果一个查询从来不需要读取content表,那么这个限制就不适用)。</target>
        </trans-unit>
        <trans-unit id="69c4116a662051610d482a3763e629de02d91b0e" translate="yes" xml:space="preserve">
          <source>If the coroutine that is launched by this instruction ends with &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; or &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; then continue to the next instruction. But if the coroutine launched by this instruction ends with &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;, then jump to P2 rather than continuing with the next instruction.</source>
          <target state="translated">如果此指令启动的协程以&lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;或&lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt;结尾，则继续执行下一条指令。但是，如果此指令启动的协程以&lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine结尾&lt;/a&gt;，则跳至P2而不是继续执行下一条指令。</target>
        </trans-unit>
        <trans-unit id="d90236a26f30bb94fe93491f2ee7d8229a45dcb7" translate="yes" xml:space="preserve">
          <source>If the covering index is used for the scan, the &quot;fruit&quot; column will appear naturally in the correct order, but when there are two or more rows with the same fruit, the price might be out of order. When this occurs, SQLite does many small sorts, one sort for each distinct value of fruit, rather than one large sort. Figure 22 below illustrates the concept.</source>
          <target state="translated">如果使用覆盖索引进行扫描,&quot;水果 &quot;列自然会以正确的顺序出现,但当有两行或多行有相同的水果时,价格可能会失序。当出现这种情况时,SQLite会做很多小的排序,对每一个不同的水果值做一个排序,而不是做一个大的排序。下图22说明了这个概念。</target>
        </trans-unit>
        <trans-unit id="9c6f80849dfd69b57ae6014cb409620e08c9388e" translate="yes" xml:space="preserve">
          <source>If the current statement is not inside an explicit transaction (a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; block), then an implicit transaction is committed as soon as the statement has finished executing. In this case deferred constraints behave the same as immediate constraints.</source>
          <target state="translated">如果当前语句不在显式事务（&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;块）内，则在语句执行完成后立即提交隐式事务。在这种情况下，延迟约束的行为与立即约束相同。</target>
        </trans-unit>
        <trans-unit id="392488489ea8e86894e96e98c9d528e435e44b99" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.8.2 or greater, the estimatedRows field may be set to an estimate of the number of rows returned by the proposed query plan. If this value is not explicitly set, the default estimate of 25 rows is used.</source>
          <target state="translated">如果SQLite的当前版本是3.8.2或更高版本,可以将估计行数字段设置为建议的查询计划返回的行数。如果没有明确设置这个值,则使用默认的25行估计值。</target>
        </trans-unit>
        <trans-unit id="d14a622439a8b842f388bc686b9c68da678476ab" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.9.0 or greater, the idxFlags field may be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return only zero or one rows given the input constraints. Additional bits of the idxFlags field might be understood in later versions of SQLite.</source>
          <target state="translated">如果当前版本的SQLite是3.9.0或更高版本,idxFlags字段可以设置为SQLITE_INDEX_SCAN_UNIQUE,以表示给定的输入约束条件下,虚拟表将只返回0或1条记录。idxFlags字段的其他位可能在SQLite的以后版本中被理解。</target>
        </trans-unit>
        <trans-unit id="7ead26894e06c87e567f28556505a47feb41761a" translate="yes" xml:space="preserve">
          <source>If the cursor P1 is already opened on an ephemeral table, the table is cleared (all content is erased).</source>
          <target state="translated">如果光标P1已经在一个历时表上打开,那么该表将被清除(所有内容被清除)。</target>
        </trans-unit>
        <trans-unit id="4895543ee94b53e62d72914bc8c347747fb66179" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">如果使用OPFLAG_SEEKEQ标志打开了光标P1，则此操作码将始终停留在等于键的记录上，否则立即跳转到P2。当游标为OPFLAG_SEEKEQ时，此操作码后必须跟具有相同参数的&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;操作码。该&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;如果这个操作码成功操作码会被跳过，但&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;操作码将在后续的循环迭代中使用。</target>
        </trans-unit>
        <trans-unit id="77bb6e8019c4e57a173df053565a659dee60ffeb" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">如果使用OPFLAG_SEEKEQ标志打开了光标P1，则此操作码将始终停留在等于键的记录上，否则立即跳转到P2。当游标为OPFLAG_SEEKEQ时，此操作码后必须是具有相同参数的&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;操作码。该&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;如果这个操作码成功操作码会被跳过，但&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;操作码将在后续的循环迭代中使用。</target>
        </trans-unit>
        <trans-unit id="6654fbd1f580e1606c2cb7ef134e0a96bcfe4a7c" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5226a8f5df78028a70c1168477ceda8c9db8705" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c34174e24836739ad2de38f328a95e6bd8361fd" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">如果数据库连接与未完成的准备语句或未完成的sqlite3_backup对象相关联，则sqlite3_close（）将使数据库连接保持打开状态并返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果使用未完成的准备语句和/或未完成的sqlite3_backups调用sqlite3_close_v2（），则数据库连接将变为无法使用的&amp;ldquo;僵尸&amp;rdquo;，当最后一个准备好的语句完成或最后一个sqlite3_backup完成时，数据库连接将被自动释放。 sqlite3_close_v2（）接口旨在用于垃圾收集的宿主语言，并且调用析构函数的顺序是任意的。</target>
        </trans-unit>
        <trans-unit id="6a86fbb2e17cc862733085ba2da83a55d59e3eb0" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">如果数据库连接与未完成的准备语句或未完成的sqlite3_backup对象相关联，则sqlite3_close（）将使数据库连接保持打开状态并返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。如果使用未完成的准备语句和/或未完成的sqlite3_backups调用sqlite3_close_v2（），则数据库连接将变为无法使用的&amp;ldquo;僵尸&amp;rdquo;，当最后一个准备好的语句完成或最后一个sqlite3_backup完成时，数据库连接将被自动释放。 sqlite3_close_v2（）接口旨在用于垃圾收集的宿主语言，并且调用析构函数的顺序是任意的。</target>
        </trans-unit>
        <trans-unit id="fb1362fb98673ef522db1a6a32001f7f2b59540f" translate="yes" xml:space="preserve">
          <source>If the database connection is newly opened, make sure it has read the database schema by preparing then discarding some query against the database, or calling sqlite3_table_column_metadata(), ignoring any errors. This step is only necessary if the application desires to keep the database in WAL mode after the reset if it was in WAL mode before the reset.</source>
          <target state="translated">如果数据库连接是新打开的,通过准备然后丢弃一些针对数据库的查询,或者调用sqlite3_table_column_metadata(),确保它已经读取了数据库模式,忽略任何错误。只有当应用程序希望在重置后将数据库保持在WAL模式时,如果数据库在重置前处于WAL模式,才需要这一步。</target>
        </trans-unit>
        <trans-unit id="1e3e236bab50bdd2cf247016c21c0818a0ad15df" translate="yes" xml:space="preserve">
          <source>If the database file has aliases (hard or soft links) and the file is opened by a different alias than the one used to create the journal, then the journal will not be found. To avoid this problem, you should not create links to SQLite database files.</source>
          <target state="translated">如果数据库文件有别名(硬链接或软链接),而打开该文件的别名与创建日记的别名不同,那么将找不到日记。为了避免这个问题,你不应该创建SQLite数据库文件的链接。</target>
        </trans-unit>
        <trans-unit id="b5462897225632e86adf2dda0274ca8b010e12de" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">如果数据库模式发生更改，则&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;会自动重新编译SQL语句并尝试再次运行，而不是像通常那样返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;。在sqlite3_step（）放弃并返回错误之前，将进行多达&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY次&lt;/a&gt;重试。</target>
        </trans-unit>
        <trans-unit id="589bc4cd8d0a621a42dc8c997193ae6380bd4790" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">如果数据库模式发生更改，则&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;会自动重新编译SQL语句并尝试再次运行，而不是像通常那样返回&lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;。在sqlite3_step（）放弃并返回错误之前，将进行多达&lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY次&lt;/a&gt;重试。</target>
        </trans-unit>
        <trans-unit id="66c44f3be0c0d8ad85eed52612c2f2c579f73474" translate="yes" xml:space="preserve">
          <source>If the database schema contains foreign key errors that require looking at more than one table definition to identify, then those errors are not detected when the tables are created. Instead, such errors prevent the application from preparing SQL statements that modify the content of the child or parent tables in ways that use the foreign keys. Errors reported when content is changed are &quot;DML errors&quot; and errors reported when the schema is changed are &quot;DDL errors&quot;. So, in other words, misconfigured foreign key constraints that require looking at both the child and parent are DML errors. The English language error message for foreign key DML errors is usually &quot;foreign key mismatch&quot; but can also be &quot;no such table&quot; if the parent table does not exist. Foreign key DML errors are reported if:</source>
          <target state="translated">如果数据库模式包含需要查看多个表定义才能识别的外键错误,那么在创建表时不会检测到这些错误。相反,这类错误会阻止应用程序准备以使用外键的方式修改子表或父表内容的SQL语句。当内容被更改时报告的错误是 &quot;DML错误&quot;,而当模式被更改时报告的错误是 &quot;DDL错误&quot;。所以,换句话说,配置错误的外键约束需要同时查看子表和父表,是DML错误。外键DML错误的英文错误信息通常是 &quot;foreign key mismatch&quot;,但如果父表不存在,也可以是 &quot;no such table&quot;。如果出现以下情况,则会报告外键DML错误。</target>
        </trans-unit>
        <trans-unit id="8302ec0e25c3b92c0aa14eef9d1503f836a94585" translate="yes" xml:space="preserve">
          <source>If the declared type contains the string &quot;INT&quot; then it is assigned INTEGER affinity.</source>
          <target state="translated">如果声明的类型包含字符串 &quot;INT&quot;,那么它被分配给INTEGER亲和力。</target>
        </trans-unit>
        <trans-unit id="9bb6b49e698e48cc0bb2b3442b91fd7f7d66dd5e" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains any of the strings &quot;REAL&quot;, &quot;FLOA&quot;, or &quot;DOUB&quot; then the column has REAL affinity.</source>
          <target state="translated">如果一个列的声明类型包含 &quot;REAL&quot;、&quot;FLOA &quot;或 &quot;DOUB &quot;中的任何一个字符串,那么这个列就具有REAL亲和力。</target>
        </trans-unit>
        <trans-unit id="f28b903cf6eed2606240e84c579a7053774d3dee" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains the string &quot;BLOB&quot; or if no type is specified then the column has affinity BLOB.</source>
          <target state="translated">如果一个列的声明类型包含字符串 &quot;BLOB&quot;,或者如果没有指定类型,那么该列具有亲和力BLOB。</target>
        </trans-unit>
        <trans-unit id="ee88c791daf6e99faa6560e540692aa5bc2c800f" translate="yes" xml:space="preserve">
          <source>If the declared type of the column contains any of the strings &quot;CHAR&quot;, &quot;CLOB&quot;, or &quot;TEXT&quot; then that column has TEXT affinity. Notice that the type VARCHAR contains the string &quot;CHAR&quot; and is thus assigned TEXT affinity.</source>
          <target state="translated">如果列的声明类型包含 &quot;CHAR&quot;、&quot;CLOB &quot;或 &quot;TEXT &quot;中的任何一个字符串,那么该列就具有TEXT亲缘性。请注意,类型VARCHAR包含字符串 &quot;CHAR&quot;,因此被赋予TEXT亲和性。</target>
        </trans-unit>
        <trans-unit id="de0d2c280ce73b7cd6a79e09cb8d9ab5ce1c8380" translate="yes" xml:space="preserve">
          <source>If the default entry point &quot;sqlite3_extension_init&quot; is not present in the loadable extension, also try an entry point &quot;sqlite3_X_init&quot; where &quot;X&quot; is based on the shared library filename. This allows every extension to have a different entry point, which allows them to be statically linked with no code changes.</source>
          <target state="translated">如果在可加载的扩展中没有默认的切入点 &quot;sqlite3_extension_init&quot;,也可以尝试一个切入点 &quot;sqlite3_X_init&quot;,其中 &quot;X &quot;是基于共享库文件名的。这使得每个扩展都有不同的切入点,这使得它们可以在不改变代码的情况下进行静态链接。</target>
        </trans-unit>
        <trans-unit id="2f1570bf7cd89b0efb998b886e0a28b989f79bba" translate="yes" xml:space="preserve">
          <source>If the default value of a column is CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP, then the value used in the new row is a text representation of the current UTC date and/or time. For CURRENT_TIME, the format of the value is &quot;HH:MM:SS&quot;. For CURRENT_DATE, &quot;YYYY-MM-DD&quot;. The format for CURRENT_TIMESTAMP is &quot;YYYY-MM-DD HH:MM:SS&quot;.</source>
          <target state="translated">如果列的默认值是CURRENT_TIME、CURRENT_DATE或CURRENT_TIMESTAMP,那么在新行中使用的值是当前UTC日期和/或时间的文本表示。对于 CURRENT_TIME,值的格式是 &quot;HH:MM:SS&quot;。对于CURRENT_DATE,值的格式是 &quot;YYYY-MM-DD&quot;。CURRENT_TIMESTAMP 的格式是 &quot;YYYY-MM-DD HH:MM:SS&quot;。</target>
        </trans-unit>
        <trans-unit id="763669d7f38746d95d771edeb8a196a32d9d9e41" translate="yes" xml:space="preserve">
          <source>If the default value of a column is an expression in parentheses, then the expression is evaluated once for each row inserted and the results used in the new row.</source>
          <target state="translated">如果列的默认值是括号中的表达式,那么每插入一行,表达式就会被评估一次,并在新行中使用结果。</target>
        </trans-unit>
        <trans-unit id="f9fe1ed106b11da1d5f4cf451a970a2b10eba0b4" translate="yes" xml:space="preserve">
          <source>If the default value of the column is a constant NULL, text, blob or signed-number value, then that value is used directly in the new row.</source>
          <target state="translated">如果列的默认值是一个常量的NULL、文本、blob或有符号的数字值,那么在新行中直接使用该值。</target>
        </trans-unit>
        <trans-unit id="6072ed5efdb78dd0e13242a8b605916b880d7376" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;column&lt;/b&gt;, then for each term the FTS index records the rowid and column number only, omitting the term offset information. This results in the following restrictions:</source>
          <target state="translated">如果detail选项设置为&lt;b&gt;column&lt;/b&gt;，则对于每个术语，FTS索引仅记录rowid和列号，而忽略术语偏移量信息。这导致以下限制：</target>
        </trans-unit>
        <trans-unit id="e6f14be9765a087a59fad069383360a3c524d64a" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;none&lt;/b&gt;, then for each term the FTS index records just the rowid is stored. Both column and offset information are omitted. As well as the restrictions itemized above for detail=column mode, this imposes the following extra limitations:</source>
          <target state="translated">如果detail选项设置为&lt;b&gt;none&lt;/b&gt;，那么对于每个术语，FTS索引仅记录rowid。列和偏移量信息均被省略。除了上面对detail = column模式列出的限制之外，这还施加了以下额外限制：</target>
        </trans-unit>
        <trans-unit id="c0b004cd1f197d0bb3d8b70f7d3071c3e7d65b08" translate="yes" xml:space="preserve">
          <source>If the file-size is not zero bytes and the page cache does not contain valid data for the first page of the database, then the data for the first page must be read from the database.</source>
          <target state="translated">如果文件大小不是零字节,且页面缓存中不包含数据库第一页的有效数据,则必须从数据库中读取第一页的数据。</target>
        </trans-unit>
        <trans-unit id="7d40fd66a8466c922e947b1b7af920a75a0b5408" translate="yes" xml:space="preserve">
          <source>If the filename argument to the shell is a ZIP archive rather than an SQLite database, then the shell automatically opens that ZIP archive using the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">如果外壳程序的filename参数是ZIP存档而不是SQLite数据库，则外壳程序会使用&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表&lt;/a&gt;自动打开该ZIP存档。</target>
        </trans-unit>
        <trans-unit id="ae3dbad88e43cb04cd5afd00c461d318a7360e00" translate="yes" xml:space="preserve">
          <source>If the filename is &quot;:memory:&quot;, then a private, temporary in-memory database is created for the connection. This in-memory database will vanish when the database connection is closed. Future versions of SQLite might make use of additional special filenames that begin with the &quot;:&quot; character. It is recommended that when a database filename actually does begin with a &quot;:&quot; character you should prefix the filename with a pathname such as &quot;./&quot; to avoid ambiguity.</source>
          <target state="translated">如果文件名是&quot;:memory:&quot;,那么就会为该连接创建一个私有的、临时的内存数据库。当数据库连接关闭时,这个内存中的数据库将消失。未来版本的SQLite可能会使用更多以&quot;:&quot;字符开头的特殊文件名。建议当数据库文件名确实以&quot;:&quot;字符开头时,应该在文件名前加上一个路径名,如&quot;./&quot;,以避免歧义。</target>
        </trans-unit>
        <trans-unit id="62f7e60cb107b276af1d9e468c997800e50e0c47" translate="yes" xml:space="preserve">
          <source>If the filename is an empty string, then a private, temporary on-disk database will be created. This private database will be automatically deleted as soon as the database connection is closed.</source>
          <target state="translated">如果文件名是一个空字符串,那么将创建一个私人的临时磁盘数据库。一旦数据库连接关闭,这个私人数据库将被自动删除。</target>
        </trans-unit>
        <trans-unit id="e090a4024fb7e0384c6590b18fdaa1dae521998f" translate="yes" xml:space="preserve">
          <source>If the filename pointer returned by this routine is not NULL, then it can be used as the filename input parameter to these routines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dd493cb01796f1b19bb91ce938cad16395b6df" translate="yes" xml:space="preserve">
          <source>If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</source>
          <target state="translated">如果sqlite3_create_function_v2()或sqlite3_create_window_function()的最终参数不是NULL,那么它就是应用程序数据指针的destructor。当函数被删除时,无论是被重载还是数据库连接关闭时,都会调用destructor。如果调用sqlite3_create_function_v2()失败,destructor也会被调用。当desttructor回调被调用时,它将被传递一个参数,这个参数是应用程序数据指针的副本,这个指针是sqlite3_create_function_v2()的第五个参数。</target>
        </trans-unit>
        <trans-unit id="a0307f53fcf484b466b65b063fa221cd6f594f91" translate="yes" xml:space="preserve">
          <source>If the first character of the &quot;.output&quot; or &quot;.once&quot; filename is a pipe symbol (&quot;|&quot;) then the remaining characters are treated as a command and the output is sent to that command. This makes it easy to pipe the results of a query into some other process. For example, the &quot;open -f&quot; command on a Mac opens a text editor to display the content that it reads from standard input. So to see the results of a query in a text editor, one could type:</source>
          <target state="translated">如果&quot;.output &quot;或&quot;.once &quot;文件名的第一个字符是一个管道符号(&quot;|&quot;),那么剩下的字符将被视为一个命令,输出将被发送到该命令。这样就可以很容易地将查询结果用管道传送到其他进程中。例如,Mac上的 &quot;open -f &quot;命令可以打开一个文本编辑器,显示它从标准输入中读取的内容。因此,要在文本编辑器中查看查询结果,可以键入。</target>
        </trans-unit>
        <trans-unit id="f6248b44ea5d1fc55c81c80463d285a1931abd4d" translate="yes" xml:space="preserve">
          <source>If the flags parameter is non-zero, then the BLOB is opened for read and write access. If the flags parameter is zero, the BLOB is opened for read-only access.</source>
          <target state="translated">如果flags参数为非零,则打开BLOB进行读写访问。如果flags参数为零,则打开BLOB进行只读访问。</target>
        </trans-unit>
        <trans-unit id="42e53a5898ca221d8e5453208404df16340c520e" translate="yes" xml:space="preserve">
          <source>If the frame type is RANGE or GROUPS, then rows with the same values for all ORDER BY expressions are considered &quot;peers&quot;. Or, if there are no ORDER BY terms, all rows are peers. Peers are always within the same frame.</source>
          <target state="translated">如果框架类型是range或groups,那么对于所有ORDER BY表达式具有相同值的行被认为是 &quot;对等体&quot;。或者,如果没有ORDER BY项,则所有行都是对等体。对等体总是在同一个框架内。</target>
        </trans-unit>
        <trans-unit id="4aa0a21905f32bbcafa3289b7a629a809ef523ab" translate="yes" xml:space="preserve">
          <source>If the full-text index is consistent with the contents of the table, the INSERT used to invoke the integrity-check command succeeds. Or, if any discrepancy is found, it fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="translated">如果全文索引与表的内容一致，则用于调用完整性检查命令的INSERT成功。或者，如果发现任何差异，它将失败并显示&lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="f22af0b11cea33d685991d206d7069a56eda1b2e" translate="yes" xml:space="preserve">
          <source>If the function is registered using the sqlite3_collation_needed() API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8. If sqlite3_collation_needed16() is used, the names are passed as UTF-16 in machine native byte order. A call to either function replaces the existing collation-needed callback.</source>
          <target state="translated">如果该函数是使用sqlite3_collation_needed()API注册的,那么它将把未定义的整理序列的名称作为UTF-8编码的字符串传递。如果使用sqlite3_collation_needed16(),则以UTF-16的机器本地字节顺序传递名称。对这两个函数的调用都会替换现有的 collation-needed 回调。</target>
        </trans-unit>
        <trans-unit id="6a62bcf0e73dbd9b64d823a84e324e7b03ef33b0" translate="yes" xml:space="preserve">
          <source>If the hard upper bound on mmap_size is non-zero at compilation time, it may still be reduced or zeroed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,X,Y) interface. The X and Y parameters must both be 64-bit signed integers. The X parameter is the default mmap_size of the process and the Y is the new hard upper bound. The hard upper bound cannot be increased above its compile-time setting using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; but it can be reduced or zeroed.</source>
          <target state="translated">如果mmap_size的硬上限在编译时不为零，则仍可以使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;，X，Y）接口在开始时将其降低或归零。X和Y参数都必须是64位有符号整数。X参数是进程的默认mmap_size，Y参数是新的硬上限。使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;不能将硬上限提高到其编译时设置之上，但可以将其降低或清零。</target>
        </trans-unit>
        <trans-unit id="7e3c788b80a3fc760cf36b37df86e977c5bf4e82" translate="yes" xml:space="preserve">
          <source>If the initial value of register P1 is less than 1, then the value is unchanged and control passes through to the next instruction.</source>
          <target state="translated">如果寄存器P1的初始值小于1,则该值不变,控制权传递到下一条指令。</target>
        </trans-unit>
        <trans-unit id="c6c2836bf573a577c3b9e85be740fd6180f2bc75" translate="yes" xml:space="preserve">
          <source>If the insert operation would cause the uniqueness constraint identified by the conflict-target clause to fail, then the insert is omitted and either the DO NOTHING or DO UPDATE operation is performed instead. In the case of a multi-row insert, this decision is made separately for each row of the insert.</source>
          <target state="translated">如果插入操作会导致冲突目标子句所确定的唯一性约束失败,那么就省略插入操作,而执行DO NOTHING或DO UPDATE操作。在多行插入的情况下,这个决定是针对插入的每一行单独做出的。</target>
        </trans-unit>
        <trans-unit id="94f24cffd74c8aa91288ff50b98f2890c0c1dd37" translate="yes" xml:space="preserve">
          <source>If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd79e7c31e9806cd77deff0cb0e96d9ab910562" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid DELETE or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old()&lt;/a&gt; API may be used to obtain the old.* values within the change payload.</source>
          <target state="translated">如果迭代器指向有效的DELETE或UPDATE条目，则可以使用&lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old（）&lt;/a&gt; API获取更改有效载荷内的old。*值。</target>
        </trans-unit>
        <trans-unit id="b3c7141c41f848703cade5e408485ed848edf925" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid INSERT or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt; API may be used to obtain the new.* values within the change payload.</source>
          <target state="translated">如果迭代器指向有效的INSERT或UPDATE条目，则可以使用&lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new（）&lt;/a&gt; API获取更改有效载荷内的new。*值。</target>
        </trans-unit>
        <trans-unit id="27b2873f49d5b86c6645b602757d6284a617e429" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid entry, the &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op()&lt;/a&gt; API may be used to determine the type of change (INSERT, UPDATE or DELETE) that the iterator points to. Additionally, the same API can be used to obtain the name of the table the change applies to and its expected number of columns and primary key columns.</source>
          <target state="translated">如果迭代器指向有效条目，则可以使用&lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op（）&lt;/a&gt; API确定迭代器指向的更改类型（INSERT，UPDATE或DELETE）。此外，可以使用相同的API获取更改所适用的表的名称及其预期的列数和主键列。</target>
        </trans-unit>
        <trans-unit id="b7875cd04c26b022cfa813504a6e1447dc659fda" translate="yes" xml:space="preserve">
          <source>If the join between the target table and the FROM clause results in multiple output rows for the same target table row, then only one of those output rows is used for updating the target table. The output row selected is arbitrary and might change from one release of SQLite to the next, or from one run to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e43f90e3097e7ba0e1ecf1e86b3e41e586eb695" translate="yes" xml:space="preserve">
          <source>If the join-operator is &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot; or a comma (&quot;,&quot;) and there is no ON or USING clause, then the result of the join is simply the cartesian product of the left and right-hand datasets. If join-operator does have ON or USING clauses, those are handled according to the following bullet points:</source>
          <target state="translated">如果join-operator是 &quot;CROSS JOIN&quot;、&quot;INNER JOIN&quot;、&quot;JOIN &quot;或逗号(&quot;,&quot;),并且没有ON或USING子句,那么join的结果只是左手和右手数据集的卡方乘积。如果join-operator确实有ON或USING子句,则按照以下要点处理。</target>
        </trans-unit>
        <trans-unit id="e1fb18a5273cd27a264734974f9f02d1710aa767" translate="yes" xml:space="preserve">
          <source>If the join-operator is a &quot;LEFT JOIN&quot; or &quot;LEFT OUTER JOIN&quot;, then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original left-hand input dataset that corresponds to no rows at all in the composite dataset (if any). The added rows contain NULL values in the columns that would normally contain values copied from the right-hand input dataset.</source>
          <target state="translated">如果join-operator是 &quot;LEFT JOIN &quot;或 &quot;LEFT OUTER JOIN&quot;,那么在应用了ON或USING过滤子句之后,对于原始左侧输入数据集中的每一条记录,都会在输出中增加一条额外的记录,而这条记录对应的是复合数据集中的任何记录(如果有的话)。增加的行在通常会包含从右侧输入数据集复制的值的列中包含NULL值。</target>
        </trans-unit>
        <trans-unit id="76658faf4e1e99248322d20ab1af06451a7269ae" translate="yes" xml:space="preserve">
          <source>If the json_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed.</source>
          <target state="translated">如果调用json_remove(X)函数时没有路径参数,那么它将返回重新格式化的输入X,并删除多余的空白。</target>
        </trans-unit>
        <trans-unit id="b094bdd6dfc46d4028fcd23aee2c781ab15d0c15" translate="yes" xml:space="preserve">
          <source>If the last client using the database shuts down cleanly by calling &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;, then a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run automatically in order to transfer all information from the wal file over into the main database, and both the shm file and the wal file are unlinked. Thus, when the database is not in use by any client, it is usually the case that only the main database file exists on disk. However, if the last client did not call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; before it shut down, or if the last client to disconnect was a read-only client, then the final cleanup operation does not occur and the shm and wal files may still exist on disk even when the database is not in use.</source>
          <target state="translated">如果最后一个使用数据库的客户端通过调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;完全关闭，则将自动运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;，以便将所有信息从wal文件传输到主数据库中，并且shm文件和wal文件均未链接。因此，当没有任何客户端使用数据库时，通常情况是磁盘上仅存在主数据库文件。但是，如果最后一个客户端在关闭前未调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;，或者如果最后一个断开连接的客户端是只读客户端，则不会进行最终的清理操作，并且磁盘上可能仍然存在shm和wal文件即使不使用数据库也是如此。</target>
        </trans-unit>
        <trans-unit id="4f7a9d6c2807cb225b7b7ab46b05552f481cc42e" translate="yes" xml:space="preserve">
          <source>If the last connection to a database crashed, then the first new connection to open the database will start a recovery process. An exclusive lock is held during recovery. So if a third database connection tries to jump in and query while the second connection is running recovery, the third connection will get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">如果与数据库的最后一个连接崩溃，则第一个打开数据库的新连接将启动恢复过程。恢复期间将保留排他锁。因此，如果在第二个连接正在运行恢复的同时第三个数据库连接尝试跳入并查询，则第三个连接将收到&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="37b7298e57bd67e9cd0305c3baee9cc81b8dbc9d" translate="yes" xml:space="preserve">
          <source>If the lastname and firstname on the bottom row of the previous screen are bound to ?1 and ?2, then the query above computes the next 7 rows. And, assuming there is an appropriate index, it does so very efficiently &amp;mdash; much more efficiently than OFFSET.</source>
          <target state="translated">如果前一个屏幕的下一行的姓和名绑定到？1和？2，则上面的查询将计算接下来的7行。而且，假设有一个合适的索引，它会非常高效-比OFFSET效率更高。</target>
        </trans-unit>
        <trans-unit id="4e01c1ab95f2a00094ec0341f6411fa5bdba3e3d" translate="yes" xml:space="preserve">
          <source>If the library is not configured for UTF-8 and the Tcl library is one of the newer ones that uses UTF-8 internally, then a conversion from UTF-8 to iso8859 and back again is done inside the TCL interface.</source>
          <target state="translated">如果库没有配置UTF-8,而Tcl库又是内部使用UTF-8的新库,那么在TCL接口内就会完成从UTF-8到iso8859的转换。</target>
        </trans-unit>
        <trans-unit id="e9f32c50cc50b5c20674f65e05651f4083f0b21f" translate="yes" xml:space="preserve">
          <source>If the locking mode is EXCLUSIVE when first entering &lt;a href=&quot;wal&quot;&gt;WAL journal mode&lt;/a&gt;, then the locking mode cannot be changed to NORMAL until after exiting WAL journal mode. If the locking mode is NORMAL when first entering WAL journal mode, then the locking mode can be changed between NORMAL and EXCLUSIVE and back again at any time and without needing to exit WAL journal mode.</source>
          <target state="translated">如果在首次进入&lt;a href=&quot;wal&quot;&gt;WAL日志模式&lt;/a&gt;时锁定模式为EXCLUSIVE ，则只有在退出WAL日志模式后才能将锁定模式更改为NORMAL。如果在首次进入WAL日志模式时锁定模式为NORMAL，则可以在NORMAL和EXCLUSIVE之间更改锁定模式，然后随时退出，而无需退出WAL日志模式。</target>
        </trans-unit>
        <trans-unit id="4d5f5f76a7fce4a19ed7250628145b10beef7a78" translate="yes" xml:space="preserve">
          <source>If the matchable phrase in the FTS query is restricted to matching data in a specified FTS table column, then only phrase matches that occur within that column are considered.</source>
          <target state="translated">如果FTS查询中的可匹配短语被限制为匹配指定FTS表列中的数据,那么只考虑该列中出现的短语匹配。</target>
        </trans-unit>
        <trans-unit id="e74ad1dee292520ae801328610398f65c1bd2944" translate="yes" xml:space="preserve">
          <source>If the memory allocation subsystems within SQLite are configured for breakdown-free operation but the actual memory usage exceeds design limits set by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;, SQLite will usually continue to operate normally. The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; automatically failover to the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; general-purpose memory allocator. And it is usually the case that the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator will continue to function without fragmentation even if &lt;b&gt;M&lt;/b&gt; and/or &lt;b&gt;n&lt;/b&gt; exceeds the limits imposed by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;. The &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; shows that it is possible for a memory allocation to break down and fail in this circumstance, but such a failure requires an especially despicable sequence of allocations and deallocations - a sequence that SQLite has never been observed to follow. So in practice it is usually the case that the limits imposed by Robson can be exceeded by a considerable margin with no ill effect.</source>
          <target state="translated">如果将SQLite中的内存分配子系统配置为无故障运行，但实际内存使用量超出了&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson证明所&lt;/a&gt;设置的设计限制，则SQLite通常将继续正常运行。页面&lt;a href=&quot;malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;和&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器会&lt;/a&gt;自动故障转移到&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;通用内存分配器。通常情况下，即使&lt;b&gt;M&lt;/b&gt;和/或&lt;b&gt;n&lt;/b&gt;超过了&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson证明&lt;/a&gt;施加的限制，&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;内存分配器也将继续运行而不会产生碎片。在&lt;a href=&quot;malloc#nofrag&quot;&gt;罗布森证明&lt;/a&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;显示了在这种情况下内存分配有可能崩溃并失败，但是这种失败需要特别卑鄙的分配和取消分配序列-从未观察到遵循SQLite的序列。因此，在实践中，通常情况下，可以大幅度超出Robson施加的限制而不会产生不良影响。</target>
        </trans-unit>
        <trans-unit id="ccc13fed0f9a7a53b6beaefda251b5fe55a5b377" translate="yes" xml:space="preserve">
          <source>If the missing function returns an error, then the database is not opened and the error returned to the user. If an openclose function is configured, then a &quot;close&quot; invocation is issued at this point to match the earlier &quot;open&quot;. The following pseudo-code illustrates the procedure used by a swarmvtab instance with both missing and openclose functions configured when a component database is opened.</source>
          <target state="translated">如果缺失的函数返回错误,那么数据库就不会被打开,并将错误返回给用户。如果配置了openclose函数,那么此时会发出一个 &quot;close &quot;调用,以配合之前的 &quot;open&quot;。下面的伪代码说明了一个同时配置了缺失函数和openclose函数的swarmvtab实例在打开组件数据库时使用的过程。</target>
        </trans-unit>
        <trans-unit id="da30913cd33d5b91e0a650b018579fde9dd09c23" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果以最近呼叫&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;为&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的声明&lt;/a&gt; S表示错误，那么&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;返回相应的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40013c6ef594b13a3f8340842450df9d33bd6702" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">如果最近调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;为&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的声明&lt;/a&gt;小号返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，或者如果&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;以前从未呼吁S，然后&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cc58a427f7c8746f7e6e3f5425c1b7c73b16876" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果以最近呼叫&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;为&lt;a href=&quot;stmt&quot;&gt;准备好的声明&lt;/a&gt; S表示错误，那么&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;返回相应的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36afaf441091086a1762a1226de0f8218bd283bf" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">如果最近调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;为&lt;a href=&quot;stmt&quot;&gt;准备好的声明&lt;/a&gt;小号返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;或&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，或者如果&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;以前从未呼吁S，然后&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd08063b2d67d7c5aa3fda6b30f29f4f613d2690" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">如果与&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 关联的最新sqlite3_ * API调用失败，则sqlite3_errcode（D）接口返回该API调用的数字&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。 sqlite3_extended_errcode（）接口是相同的，只是即使禁用&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;，它也始终返回扩展结果代码。</target>
        </trans-unit>
        <trans-unit id="02b382e95c5f6b3f587125cf8455da646274a1ae" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">如果与&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 关联的最新sqlite3_ * API调用失败，则sqlite3_errcode（D）接口返回该API调用的数字&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。sqlite3_extended_errcode（）接口是相同的，只是即使禁用&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;，它也始终返回扩展结果代码。</target>
        </trans-unit>
        <trans-unit id="5550b629f440ed23b3241e812f943180a93fdc19" translate="yes" xml:space="preserve">
          <source>If the nByte argument is negative, then zSql is read up to the first zero terminator. If nByte is positive, then it is the number of bytes read from zSql. If nByte is zero, then no prepared statement is generated. If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an nByte parameter that is the number of bytes in the input string</source>
          <target state="translated">如果nByte参数为负值,那么zSql将被读到第一个零结束符。如果nByte为正值,那么它就是从zSql中读取的字节数。如果nByte为零,那么就不会生成准备好的语句。如果调用者知道所提供的字符串是nul-terminator的,那么传递一个nByte参数是输入字符串中的字节数,在性能上有一个小小的优势</target>
        </trans-unit>
        <trans-unit id="e34afe39a4a88dd3fd33f4104d3959b3a21962af" translate="yes" xml:space="preserve">
          <source>If the name of the database is an empty string, open a new database in a temporary file that is automatically deleted when the database is closed.</source>
          <target state="translated">如果数据库名称为空字符串,则在临时文件中打开一个新的数据库,当数据库关闭时自动删除。</target>
        </trans-unit>
        <trans-unit id="4c3da3e28f6b46a881fb905c79f9b554244037e3" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the final contents of the changegroup is undefined.</source>
          <target state="translated">如果新的变更集包含对已经存在于变更组中的表的变更,那么表的列数和主键列的位置必须一致。如果不是这样,这个函数就会以SQLITE_SCHEMA失败。如果输入的变更组出现损坏,并且检测到损坏,则返回SQLITE_CORRUPT。或者,如果在处理过程中出现内存不足的情况,这个函数返回SQLITE_NOMEM。在所有情况下,如果发生错误,changegroup的最终内容是未定义的。</target>
        </trans-unit>
        <trans-unit id="96ca16b2fc66ae0f3d6b77a841fb9c9703e99865" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the state of the final contents of the changegroup is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ef56041d2d705e25a721ff1b854e81e350859e" translate="yes" xml:space="preserve">
          <source>If the new limit is a negative number, the limit is unchanged. For each limit category SQLITE_LIMIT_</source>
          <target state="translated">如果新的限制是负数,则限制不变。对于每一个限制类别,SQLITE_LIMIT_</target>
        </trans-unit>
        <trans-unit id="dbc989a098eb2be336e5500ea022b41d17fc93aa" translate="yes" xml:space="preserve">
          <source>If the number of output rows is K, then the time needed to sort is proportional to KlogK. If K is small, the sorting time is usually not a factor, but in a query such as the above where K==N, the time needed to sort can be much greater than the time needed to do a full table scan. Furthermore, the entire output is accumulated in temporary storage (which might be either in main memory or on disk, depending on various compile-time and run-time settings) which can mean that a lot of temporary storage is required to complete the query.</source>
          <target state="translated">如果输出行数为K,那么排序所需的时间与KlogK成正比。如果K很小,排序时间通常不是一个因素,但在像上面这样K==N的查询中,排序所需的时间可能远远大于做一次全表扫描所需的时间。此外,整个输出结果会积累在临时存储中(可能在主内存中,也可能在磁盘上,这取决于各种编译时和运行时的设置),这可能意味着需要大量的临时存储来完成查询。</target>
        </trans-unit>
        <trans-unit id="c9314fcd77821589cea840c1fc80043331e7d710" translate="yes" xml:space="preserve">
          <source>If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second. The number of milliseconds of sleep actually requested from the operating system is returned.</source>
          <target state="translated">如果操作系统不支持毫秒时间分辨率的睡眠请求,那么时间将被四舍五入到最接近的秒。返回实际向操作系统请求的睡眠时间的毫秒数。</target>
        </trans-unit>
        <trans-unit id="13ac5ae90471727393e9b13c70a7b1b4bc52ca60" translate="yes" xml:space="preserve">
          <source>If the operating system returns an I/O error while attempting to obtain a certain lock on shared memory in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; then SQLite might fail to reset its cache, which could lead to database corruption if subsequent writes are attempted.</source>
          <target state="translated">如果操作系统在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;尝试获取共享内存上的某个锁定时返回I / O错误，则SQLite可能无法重置其缓存，如果尝试后续写入，则可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="cdf4bb4c410d8ce86d8512a4260a05ff5271bb95" translate="yes" xml:space="preserve">
          <source>If the operation is successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387f85a0f9d5d2d59fdee2093a34c406de18ba33" translate="yes" xml:space="preserve">
          <source>If the operation successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">如果操作成功,则返回SQLITE_OK。否则,返回SQLite错误代码。在这种情况下,如果参数pzErrMsg不是NULL,*pzErrMsg可以被设置为指向一个包含英文错误信息的缓冲区。调用者有责任使用 sqlite3_free()释放这个缓冲区。</target>
        </trans-unit>
        <trans-unit id="64ab9d2da26c1826cadd00ea1395a9af67e21893" translate="yes" xml:space="preserve">
          <source>If the optional ESCAPE clause is present, then the expression following the ESCAPE keyword must evaluate to a string consisting of a single character. This character may be used in the LIKE pattern to include literal percent or underscore characters. The escape character followed by a percent symbol (%), underscore (_), or a second instance of the escape character itself matches a literal percent symbol, underscore, or a single escape character, respectively.</source>
          <target state="translated">如果存在可选的ESCAPE子句,那么ESCAPE关键字后的表达式必须评估为一个由单个字符组成的字符串。这个字符可以在LIKE模式中使用,以包含字面的百分号或下划线字符。转义字符后面的百分号(%)、下划线(_)或转义字符本身的第二个实例分别与字面百分号、下划线或单个转义字符相匹配。</target>
        </trans-unit>
        <trans-unit id="3874cddaea0653331a0794c8eb1dd76401bd55b2" translate="yes" xml:space="preserve">
          <source>If the optional IF NOT EXISTS clause is present and another index with the same name already exists, then this command becomes a no-op.</source>
          <target state="translated">如果存在可选的IF NOT EXISTS子句,并且已经存在另一个同名索引,那么这条命令就会变成无操作。</target>
        </trans-unit>
        <trans-unit id="65cace3a0d2d4d6370079a8ce7f587fee8e20bbc" translate="yes" xml:space="preserve">
          <source>If the outer query is an aggregate, then the subquery may not contain ORDER BY.</source>
          <target state="translated">如果外部查询是一个集合,那么子查询可能不包含ORDER BY。</target>
        </trans-unit>
        <trans-unit id="0b950d8e0107ea7fe292918a7624ecc4c5105550" translate="yes" xml:space="preserve">
          <source>If the outer query is part of a compound select, then the subquery may not have a LIMIT clause.</source>
          <target state="translated">如果外查询是复合选择的一部分,那么子查询可能没有LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="9ec4e583fb2aac08c6ef7929f12a08ccd0d23acd" translate="yes" xml:space="preserve">
          <source>If the output parameters (ppRebase) and (pnRebase) are non-NULL and the input is a changeset (not a patchset), then sqlite3changeset_apply_v2() may set (*ppRebase) to point to a &quot;rebase&quot; that may be used with the sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase) is set to the size of the buffer in bytes. It is the responsibility of the caller to eventually free any such buffer using sqlite3_free(). The buffer is only allocated and populated if one or more conflicts were encountered while applying the patchset. See comments surrounding the sqlite3_rebaser APIs for further details.</source>
          <target state="translated">如果输出参数(ppRebase)和(pnRebase)是非NULL,并且输入是一个变化集(而不是补丁集),那么sqlite3changeset_apply_v2()可以设置(*ppRebase)指向一个 &quot;rebase&quot;,这个 &quot;rebase &quot;可以在返回之前使用sqlite3_rebaser APIs缓冲区。在这种情况下,(*pnRebase)被设置为缓冲区的大小,单位是字节。调用者有责任使用sqlite3_free()最终释放任何这样的缓冲区。只有在应用补丁集时遇到一个或多个冲突时,缓冲区才会被分配和填充。更多细节请参见围绕 sqlite3_rebaser APIs 的注释。</target>
        </trans-unit>
        <trans-unit id="e9ff399a5e615a33dc8fa9681024351734065387" translate="yes" xml:space="preserve">
          <source>If the parameter is a positive value, B-tree structures are only eligible for merging if one of the following is true:</source>
          <target state="translated">如果该参数为正值,则只有当以下情况之一为真时,B树结构才有资格进行合并。</target>
        </trans-unit>
        <trans-unit id="60b6cd8e8d3dd19980d55457d739967fca11e05a" translate="yes" xml:space="preserve">
          <source>If the parameter is named, then its name appears in P4. The P4 value is used by sqlite3_bind_parameter_name().</source>
          <target state="translated">如果参数是命名的,那么它的名字就会出现在P4中,P4的值由sqlite3_bind_parameter_name()使用。P4的值被sqlite3_bind_parameter_name()使用。</target>
        </trans-unit>
        <trans-unit id="b51f3bd8d197cc75de48b64a5587d9918566615a" translate="yes" xml:space="preserve">
          <source>If the parameter is negative, and there are B-tree structures on more than one level within the FTS index, all B-tree structures are assigned to the same level before the merge operation is commenced. Additionally, if the parameter is negative, the value of the usermerge configuration option is not respected - as few as two b-trees from the same level may be merged together.</source>
          <target state="translated">如果参数为负值,并且在FTS索引的多个级别上有B树结构,那么在合并操作开始之前,所有的B树结构都会被分配到同一级别。</target>
        </trans-unit>
        <trans-unit id="ff1e8b8711836cc88e8f7bc11a03808c27d6ff91" translate="yes" xml:space="preserve">
          <source>If the paths are sorted using the BINARY collation sequence, then the overflow pages associated with a cell will appear earlier in the sort-order than its child page:</source>
          <target state="translated">如果使用BINARY整理序列对路径进行排序,那么在排序顺序中,与单元格相关联的溢出页将比其子页更早出现。</target>
        </trans-unit>
        <trans-unit id="e58cd97227118f50b919227b576a1a6d96943367" translate="yes" xml:space="preserve">
          <source>If the process that wants to write is unable to obtain a RESERVED lock, it must mean that another process already has a RESERVED lock. In that case, the write attempt fails and returns SQLITE_BUSY.</source>
          <target state="translated">如果要写的进程无法获得一个RESERVED锁,那一定意味着另一个进程已经有了一个RESERVED锁。在这种情况下,写的尝试会失败,并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="406129ab5d2092b3ea22acba195d09ec62e01cc6" translate="yes" xml:space="preserve">
          <source>If the progress callback returns non-zero, the operation is interrupted. This feature can be used to implement a &quot;Cancel&quot; button on a GUI progress dialog box.</source>
          <target state="translated">如果进度回调返回非零,则中断操作。此功能可用于在GUI进度对话框上实现 &quot;取消 &quot;按钮。</target>
        </trans-unit>
        <trans-unit id="ab297d564d935b4268428b382c93fe0d78c1a7ca" translate="yes" xml:space="preserve">
          <source>If the query contains an ORDER BY clause or a GROUP BY clause or if the query uses the DISTINCT keyword then it is advantageous to select a path through the graph that causes rows to naturally appear in sorted order, so that no separate sorting step is required. Automatic elimination of ORDER BY clauses can make a large performance difference, so this is another factor that needs to be considered in a complete implementation.</source>
          <target state="translated">如果查询中包含ORDER BY子句或GROUP BY子句,或者查询中使用了DISTINCT关键字,那么选择一条通过图的路径是有利的,它可以使行自然地按排序顺序出现,这样就不需要单独的排序步骤。自动消除ORDER BY子句会带来很大的性能差异,所以这也是完整实现中需要考虑的另一个因素。</target>
        </trans-unit>
        <trans-unit id="4359b51a903396b955ce1a84240a1385d5c4cd97" translate="yes" xml:space="preserve">
          <source>If the query runs to completion without incident, SQLITE_OK is returned. Or, if some error occurs before the query completes or is aborted by the callback, an SQLite error code is returned.</source>
          <target state="translated">如果查询顺利完成,则返回SQLITE_OK。或者,如果在查询完成之前发生错误或者被回调中止,则返回SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="78d49d24ce74dae451d0ef728d6bf465dbd467e9" translate="yes" xml:space="preserve">
          <source>If the reason for writing to the database file is because the memory cache was full, then the writer will not commit right away. Instead, the writer might continue to make changes to other pages. Before subsequent changes are written to the database file, the rollback journal must be flushed to disk again. Note also that the EXCLUSIVE lock that the writer obtained in order to write to the database initially must be held until all changes are committed. That means that no other processes are able to access the database from the time the memory cache first spills to disk until the transaction commits.</source>
          <target state="translated">如果向数据库文件写入的原因是因为内存缓存已满,那么写入者不会马上提交。相反,写入者可能会继续对其他页面进行修改。在后续的修改写入数据库文件之前,必须再次将回滚日志刷新到磁盘。还需要注意的是,写入者最初为了写入数据库而获得的EXCLUSIVE锁必须保持到所有更改提交为止。也就是说,从内存缓存第一次溢出磁盘到事务提交之前,其他进程都无法访问数据库。</target>
        </trans-unit>
        <trans-unit id="f4de1a28535def0f53f335b0aa1ec084bfb958b6" translate="yes" xml:space="preserve">
          <source>If the record contains fewer than P2 fields, then extract a NULL. Or, if the P4 argument is a P4_MEM use the value of the P4 argument as the result.</source>
          <target state="translated">如果记录包含的字段少于P2,则提取一个NULL。或者,如果P4参数是P4_MEM,则使用P4参数的值作为结果。</target>
        </trans-unit>
        <trans-unit id="a233c4347f5d21c12355351382fcf901413d7e49" translate="yes" xml:space="preserve">
          <source>If the recovered database schema already contains a table named &quot;lost_and_found&quot;, the &quot;.recover&quot; command uses the name &quot;lost_and_found0&quot;. If the name &quot;lost_and_found0&quot; is also already taken, &quot;lost_and_found1&quot;, and so on. The default name &quot;lost_and_found&quot; may be overridden by invoking &quot;.recover&quot; with the --lost-and-found switch. For example, to have the output script call the table &quot;orphaned_rows&quot;:</source>
          <target state="translated">如果恢复的数据库模式已经包含一个名为 &quot;lost_and_found &quot;的表,则&quot;.recover &quot;命令使用 &quot;lost_and_found0 &quot;这个名称。如果 &quot;lost_and_found0 &quot;这个名字也已经被采用,则采用 &quot;lost_and_found1&quot;,以此类推。默认的名称 &quot;lost_and_found &quot;可以通过调用&quot;.recover &quot;和--lost-and-found开关来覆盖。例如,让输出脚本调用表 &quot;orphaned_rows&quot;。</target>
        </trans-unit>
        <trans-unit id="872cffdf6d4bf05d01de18a6904e492aef161446" translate="yes" xml:space="preserve">
          <source>If the requested page is already in the page cache, then the page cache implementation must return a pointer to the page buffer with its content intact. If the requested page is not already in the cache, then the cache implementation should use the value of the createFlag parameter to help it determined what action to take:</source>
          <target state="translated">如果请求的页面已经在页面缓存中,那么页面缓存实现必须返回一个指向页面缓冲区的指针,并保持其内容完整。如果请求的页面还没有在缓存中,那么缓存实现应该使用createFlag参数的值来帮助它决定采取什么行动。</target>
        </trans-unit>
        <trans-unit id="db0bc69173aefab4964d855c64d49581690da543" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">如果结果是BLOB或UTF-16字符串，则sqlite3_column_bytes16（）例程返回该BLOB或字符串中的字节数。如果结果是UTF-8字符串，则sqlite3_column_bytes16（）将字符串转换为UTF-16，然后返回字节数。如果结果是数字值，则sqlite3_column_bytes16（）使用&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;将该值转换为UTF-16字符串，并返回该字符串中的字节数。如果结果为NULL，则sqlite3_column_bytes16（）返回零。</target>
        </trans-unit>
        <trans-unit id="3b44d7bd1746ffad7cf756ce26aeea67c4d49e66" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">如果结果是BLOB或UTF-16字符串，则sqlite3_column_bytes16（）例程返回该BLOB或字符串中的字节数。如果结果是UTF-8字符串，则sqlite3_column_bytes16（）将字符串转换为UTF-16，然后返回字节数。如果结果是数字值，则sqlite3_column_bytes16（）使用&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;将该值转换为UTF-16字符串，并返回该字符串中的字节数。如果结果为NULL，则sqlite3_column_bytes16（）返回零。</target>
        </trans-unit>
        <trans-unit id="5a04fb4ab27b4007fb1a3789b739c65a862ccba9" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">如果结果是BLOB或UTF-8字符串，则sqlite3_column_bytes（）例程返回该BLOB或字符串中的字节数。如果结果是UTF-16字符串，则sqlite3_column_bytes（）将字符串转换为UTF-8，然后返回字节数。如果结果是数字值，则sqlite3_column_bytes（）使用&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;将该值转换为UTF-8字符串，并返回该字符串中的字节数。如果结果为NULL，则sqlite3_column_bytes（）返回零。</target>
        </trans-unit>
        <trans-unit id="97aa0401915ee07da3fcfb4b2dd9b95ffff68377" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">如果结果是BLOB或UTF-8字符串，则sqlite3_column_bytes（）例程返回该BLOB或字符串中的字节数。如果结果是UTF-16字符串，则sqlite3_column_bytes（）将字符串转换为UTF-8，然后返回字节数。如果结果是数字值，则sqlite3_column_bytes（）使用&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;将该值转换为UTF-8字符串，并返回该字符串中的字节数。如果结果为NULL，则sqlite3_column_bytes（）返回零。</target>
        </trans-unit>
        <trans-unit id="cce95bf5c0bc98e89e8fc40f80872857badf8433" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes() or sqlite3_column_bytes16() interfaces can be used to determine the size of that BLOB or string.</source>
          <target state="translated">如果结果是一个BLOB或TEXT字符串,那么可以使用sqlite3_column_bytes()或sqlite3_column_bytes16()接口来确定该BLOB或字符串的大小。</target>
        </trans-unit>
        <trans-unit id="fd9c1a162239f42f97865bf762c6375eed8fe6fe" translate="yes" xml:space="preserve">
          <source>If the result is a general expression, not a just the name of a source table column, then the name of the result is a copy of the expression text.</source>
          <target state="translated">如果结果是一个通用的表达式,而不仅仅是一个源表列的名称,那么结果的名称就是表达式文本的复制。</target>
        </trans-unit>
        <trans-unit id="57f0dbb6f6834911f1360c14b63d681228556516" translate="yes" xml:space="preserve">
          <source>If the result set of a query is empty, then by default &lt;b&gt;sqlite_get_table&lt;/b&gt; will set nrow to 0 and leave its result parameter is set to NULL. But if the EMPTY_RESULT_CALLBACKS pragma is ON then the result parameter is initialized to the names of the columns only. For example, consider this query which has an empty result set:</source>
          <target state="translated">如果查询的结果集为空，则默认情况下&lt;b&gt;sqlite_get_table&lt;/b&gt;会将nrow设置为0，并将其result参数设置为NULL。但是，如果EMPTY_RESULT_CALLBACKS编译指示为ON，则将结果参数初始化为仅列名。例如，考虑此查询的结果集为空：</target>
        </trans-unit>
        <trans-unit id="d816ce55af3aa1bc324149c293eb2742dfc0c53d" translate="yes" xml:space="preserve">
          <source>If the right-hand side of an IN operator can be list of values as in the following:</source>
          <target state="translated">如果一个IN运算符的右侧可以列出如下所示的数值。</target>
        </trans-unit>
        <trans-unit id="b287ebc787ae1fe1352a6696e98abccff05e37e6" translate="yes" xml:space="preserve">
          <source>If the row comes from a WITHOUT ROWID table, this column contains NULL. Otherwise, it contains the 64-bit integer rowid value for the row.</source>
          <target state="translated">如果行来自一个WITHOUT ROWID表,这一列包含NULL。否则,它包含该行的64位整数rowid值。</target>
        </trans-unit>
        <trans-unit id="489be44720b2f1c706095444d825988cba31b9db" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">如果BLOB句柄指向的行被&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;或&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;副作用修改，则BLOB句柄将标记为&amp;ldquo;已过期&amp;rdquo;。如果更改了该行的任何列，甚至是BLOB句柄所在的列以外的其他列，也是如此。为到期的BLOB句柄调用&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;和&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;失败，返回码为&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;。 BLOB到期之前不会回滚在BLOB到期之前写入BLOB的更改。如果交易继续完成，则此类更改最终将提交。</target>
        </trans-unit>
        <trans-unit id="855918a93d6aa4472f75825b61dee9d03ea7eab1" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">如果BLOB句柄指向的行被&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;或&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;副作用修改，则BLOB句柄将标记为&amp;ldquo;已过期&amp;rdquo;。如果更改了该行的任何列，甚至是BLOB句柄所在的列以外的其他列，也是如此。为到期的BLOB句柄调用&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;失败，返回码为&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;。 BLOB到期之前不会回滚在BLOB到期之前写入BLOB的更改。如果交易继续完成，则此类更改最终将提交。</target>
        </trans-unit>
        <trans-unit id="5ad667b790a078db1e6c6968fc928120e549e94b" translate="yes" xml:space="preserve">
          <source>If the same database is being read and written using two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; (two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; objects returned by separate calls to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;) and the two database connections do not have a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, then the reader is only able to see complete committed transactions from the writer. Partial changes by the writer that have not been committed are invisible to the reader. This is true regardless of whether the two database connections are in the same thread, in different threads of the same process, or in different processes. This is the usual and expected behavior for SQL database systems.</source>
          <target state="translated">如果使用两个不同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;（通过分别调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;返回的两个不同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象）读取和写入同一数据库，并且两个数据库连接没有&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;，则读取器只能看到完整的提交来自作者的交易。作者尚未完成的部分更改对于读者是看不见的。无论两个数据库连接是在同一线程中，在同一进程的不同线程中还是在不同的进程中，都是如此。这是SQL数据库系统的通常和预期的行为。</target>
        </trans-unit>
        <trans-unit id="2e0132de71fd47828befdd8cddea786393211a76" translate="yes" xml:space="preserve">
          <source>If the savepoint-name in a RELEASE command does not match any savepoint currently in the transaction stack, then no savepoints are released, the database is unchanged, and the RELEASE command returns an error.</source>
          <target state="translated">如果RELEASE命令中的savepoint-name与当前事务堆栈中的任何savepoint不匹配,那么就不会释放任何savepoints,数据库不变,RELEASE命令返回一个错误。</target>
        </trans-unit>
        <trans-unit id="0e8e411b07fe2c001323f612676b1abf9cd50210" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">如果第二个参数（zDbName）与任何打开的数据库文件的名称都不匹配，则返回SQLITE_ERROR。此错误代码不会被记住，&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;不会将其重新调用。基础xFileControl方法也可能返回SQLITE_ERROR。无法区分不正确的zDbName和来自基础xFileControl方法的SQLITE_ERROR返回。</target>
        </trans-unit>
        <trans-unit id="0a6c4ada949c40cb1aa6d07b25694fd6c11c1796" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">如果第二个参数（zDbName）与任何打开的数据库文件的名称都不匹配，则返回SQLITE_ERROR。此错误代码不会被记住，&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;不会将其重新调用。基础xFileControl方法也可能返回SQLITE_ERROR。无法区分不正确的zDbName和来自基础xFileControl方法的SQLITE_ERROR返回。</target>
        </trans-unit>
        <trans-unit id="b78c0101bf92e2df502819dbd3877a0d27dbb142" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be greater than zero bytes by a query required by H35450, then SQLite shall attempt to upgrade the</source>
          <target state="translated">如果通过H35450要求的查询发现一个潜在的热日志文件的大小大于零字节,那么SQLite应尝试升级到</target>
        </trans-unit>
        <trans-unit id="84a94aa97953d8f31911d07edfb705a8ac22630d" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be zero bytes by a query required by H35450, then SQLite shall close the file handle opened on the journal file and delete the journal file using a call to the VFS xDelete() method. In this case SQLite shall conclude that there is no</source>
          <target state="translated">如果通过H35450要求的查询发现一个潜在的热日志文件的大小为零字节,那么SQLite应关闭在该日志文件上打开的文件句柄,并使用调用VFS xDelete()方法删除该日志文件。在这种情况下,SQLite应断定不存在</target>
        </trans-unit>
        <trans-unit id="8775f72effd63665f56849704eebc4e3eb03a777" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">如果WHERE子句中绑定到&lt;a href=&quot;../lang_expr#varparam&quot;&gt;主机参数&lt;/a&gt;的特定值可能会影响语句查询计划的选择，则该语句将在任何更改后的第一个&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中自动重新编译，就像发生了模式更改一样。在&lt;a href=&quot;bind_blob&quot;&gt;绑定&lt;/a&gt;该的&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。如果参数位于&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的左侧，或者将参数与索引列进行比较并且启用了&lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，则WHERE子句&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的特定值可能会影响查询计划的选择。</target>
        </trans-unit>
        <trans-unit id="44b5aede3751869315efb1ad0c6228b799d6377d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">如果WHERE子句中绑定到&lt;a href=&quot;lang_expr#varparam&quot;&gt;主机参数&lt;/a&gt;的特定值可能会影响语句查询计划的选择，则该语句将在任何更改后的第一个&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中自动重新编译，就像发生了模式更改一样。在&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;绑定&lt;/a&gt;该的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。如果参数位于&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的左侧，或者将参数与索引列进行比较并且启用了&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，则WHERE子句&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的特定值可能会影响查询计划的选择。</target>
        </trans-unit>
        <trans-unit id="a67ab94a492111af2ad307d63a14eece5d2506a2" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1532d90d6e0b3047b8c2ebb4f13faa142948903d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1ce97d9fc0705c3229e21c8809d3855d59efd3" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">如果指定的列是&amp;ldquo; rowid&amp;rdquo;，&amp;ldquo; oid&amp;rdquo;或&amp;ldquo; _rowid_&amp;rdquo;，并且该表不是&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，并且已显式声明了&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，则将为显式声明的列设置输出参数。如果没有&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，那么将&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;的输出设置如下：</target>
        </trans-unit>
        <trans-unit id="8f350a11b8322175a383ceadb167cdbb00955970" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">如果指定的列是&amp;ldquo; rowid&amp;rdquo;，&amp;ldquo; oid&amp;rdquo;或&amp;ldquo; _rowid_&amp;rdquo;，并且该表不是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，并且已显式声明了&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，则将为显式声明的列设置输出参数。如果没有&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，那么将&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;的输出设置如下：</target>
        </trans-unit>
        <trans-unit id="f3164e0e380d4749ee94c4239d71835f6ebe7294" translate="yes" xml:space="preserve">
          <source>If the specified compress or uncompress functions do not exist, the table may still be created. An error is not returned until the FTS4 table is read (if the uncompress function does not exist) or written (if it is the compress function that does not exist).</source>
          <target state="translated">如果指定的压缩或解压函数不存在,仍可创建表格。在读取FTS4表(如果解压函数不存在)或写入FTS4表(如果是压缩函数不存在)之前,不会返回错误。</target>
        </trans-unit>
        <trans-unit id="63eb5c5c72bb1ff543038003d7ef2fd45c2837fe" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">如果指定的表实际上是视图，则返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce9d8284bfd79645e82900ecac60c2249827b2a4" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">如果指定的表实际上是视图，则返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fece2731796046aa37a6f47896457da35d0048d" translate="yes" xml:space="preserve">
          <source>If the specified value is an integer (or text that looks like an integer), it is inserted verbatim. If the value is not a valid UNIX mode, some programs may behave unexpectedly when extracting files from the archive.</source>
          <target state="translated">如果指定的值是一个整数(或看起来像一个整数的文本),它将被逐字插入。如果该值不是有效的UNIX模式,一些程序在从存档中提取文件时可能会出现意外情况。</target>
        </trans-unit>
        <trans-unit id="e4f3a6c8e56d6f7f8102c0223dc18717b78218c4" translate="yes" xml:space="preserve">
          <source>If the specified view cannot be found and the IF EXISTS clause is not present, it is an error. If the specified view cannot be found and an IF EXISTS clause is present in the DROP VIEW statement, then the statement is a no-op.</source>
          <target state="translated">如果找不到指定的视图,且IF EXISTS子句不存在,则为错误。如果找不到指定的视图,而DROP VIEW语句中又有IF EXISTS子句,则该语句为无操作。</target>
        </trans-unit>
        <trans-unit id="90a8c9a64f685446aa6aabbcaddc7d44c89fc5a1" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">如果在&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法中调用了sqlite3_vtab_nochange（X）例程，则当且仅当作为UPDATE操作的一部分来提取列时，该列返回true，在此过程中列值将保持不变。应用程序可能会使用它来代替返回值，该返回值的计算成本较低，并且相应的&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法将其理解为&amp;ldquo;不变&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="589f84e6663e321a54522d9b6141cb9b22a8427e" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">如果在&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法中调用了sqlite3_vtab_nochange（X）例程，则当且仅当作为UPDATE操作的一部分来提取列时，该列返回true，在此过程中列值将保持不变。应用程序可能会使用它来代替返回值，该返回值的计算成本较低，并且相应的&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法将其理解为&amp;ldquo;不变&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="aeaddc8619c2a7f7c9c53fa9fbcf5b7907cc4bc7" translate="yes" xml:space="preserve">
          <source>If the sqlite_stat1.idx column is NULL, then the sqlite_stat1.stat column contains a single integer which is the approximate number of rows in the table identified by sqlite_stat1.tbl. If the sqlite_stat1.idx column is the same as the sqlite_stat1.tbl column, then the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and the sqlite_stat1.stat field contains information about the index btree that implements the WITHOUT ROWID table.</source>
          <target state="translated">如果sqlite_stat1.idx列为NULL，则sqlite_stat1.stat列包含单个整数，该整数是由sqlite_stat1.tbl标识的表中的大约行数。如果sqlite_stat1.idx列与sqlite_stat1.tbl列相同，则该表是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，而sqlite_stat1.stat字段包含有关实现WITHOUT ROWID表的索引btree的信息。</target>
        </trans-unit>
        <trans-unit id="7ef8812fff06e258ef45bbe3080d7b83145fdfcb" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound SELECT, then</source>
          <target state="translated">如果子查询是一个复合SELECT,那么就是</target>
        </trans-unit>
        <trans-unit id="95d8d057928b20b8273091a81f8f75e5dc26f5b2" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then all terms of the ORDER by clause of the parent must be simple references to columns of the sub-query.</source>
          <target state="translated">如果子查询是一个复合选择,那么父查询的ORDER by子句的所有条款必须是对子查询列的简单引用。</target>
        </trans-unit>
        <trans-unit id="cfa26eb2d70555062705f5059521f66db3517508" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then it must not use an ORDER BY clause.</source>
          <target state="translated">如果子查询是一个复合选择,那么它必须不使用ORDER BY子句。</target>
        </trans-unit>
        <trans-unit id="a41d547f4cfa21fa6c9e383332bb2ccbe73488d1" translate="yes" xml:space="preserve">
          <source>If the subquery is the right operand of a LEFT JOIN then</source>
          <target state="translated">如果子查询是一个LEFT JOIN的右边操作数,那么就是</target>
        </trans-unit>
        <trans-unit id="9251592b196cd1f8e1c4b9db367256eca51eaf76" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT then the outer query may not have a WHERE clause.</source>
          <target state="translated">如果子查询使用LIMIT,那么外层查询可能没有WHERE子句。</target>
        </trans-unit>
        <trans-unit id="3915c5066778c0e52bdae49ad9f9428a2640f7be" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT, then the outer query may not be DISTINCT.</source>
          <target state="translated">如果子查询使用LIMIT,那么外层查询可能不是DISTINCT。</target>
        </trans-unit>
        <trans-unit id="3ca99915e9f2329a546bdb9b1fd10bf3cea382c2" translate="yes" xml:space="preserve">
          <source>If the table has 32 or fewer columns, a single unsigned integer is output for each phrase in the query. The least significant bit of the integer is set if the phrase appears at least once in column 0. The second least significant bit is set if the phrase appears once or more in column 1. And so on.</source>
          <target state="translated">如果表的列数为32列或更少,则为查询中的每个短语输出一个无符号整数。如果该短语在第0列中至少出现一次,那么整数的最小有效位就会被设置。如果该短语在第1列中出现一次或更多,则设置第二个最小有效位。以此类推。</target>
        </trans-unit>
        <trans-unit id="721c91e5cd9182aa981b27d672f91c90481093e6" translate="yes" xml:space="preserve">
          <source>If the table has more than 32 columns, an extra integer is added to the output of each phrase for each extra 32 columns or part thereof. Integers corresponding to the same phrase are clumped together. For example, if a table with 45 columns is queried for two phrases, 4 integers are output. The first corresponds to phrase 0 and columns 0-31 of the table. The second integer contains data for phrase 0 and columns 32-44, and so on.</source>
          <target state="translated">如果表的列数超过32列,则每多出32列或其中一部分,就在每个短语的输出中增加一个额外的整数。对应于同一短语的整数会聚集在一起。例如,如果一个有45列的表被查询到两个短语,则输出4个整数。第一个整数对应于短语0和表的0-31列。第二个整数包含短语0和第32-44列的数据,以此类推。</target>
        </trans-unit>
        <trans-unit id="dd1a6a322a6da8501607606cd285b56e7643fea3" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xInstCount, xInst, xPhraseFirst and xPhraseNext APIs behave as if the current row contains no phrase matches at all (i.e. xInstCount() returns 0).</source>
          <target state="translated">如果表也是一个无内容表,那么xInstCount、xInst、xPhraseFirst和xPhraseNext API就会表现为当前行根本不包含短语匹配(即xInstCount()返回0)。</target>
        </trans-unit>
        <trans-unit id="6fe44f3588c5a2857dcbb9370708a1c62e0664e1" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xPhraseFirstColumn and xPhraseNextColumn APIs behave as if the current row contains no phrase matches at all (i.e. xPhraseFirstColumn() sets the iterator to EOF).</source>
          <target state="translated">如果表也是一个无内容表,xPhraseFirstColumn和xPhraseNextColumn API的行为就像当前行根本不包含短语匹配一样(即xPhraseFirstColumn()将迭代器设置为EOF)。</target>
        </trans-unit>
        <trans-unit id="8fa583fa8336ae813a54303aa49ca52aa9df3514" translate="yes" xml:space="preserve">
          <source>If the tables are not compatible, SQLITE_SCHEMA is returned. If the tables are compatible but do not have any PRIMARY KEY columns, it is not an error but no changes are added to the session object. As with other session APIs, tables without PRIMARY KEYs are simply ignored.</source>
          <target state="translated">如果表不兼容,则返回SQLITE_SCHEMA。如果表是兼容的,但没有任何PRIMARY KEY列,这不是一个错误,但不会向会话对象添加任何更改。与其他会话API一样,没有PRIMARY KEY的表会被直接忽略。</target>
        </trans-unit>
        <trans-unit id="39d5998574043194036193b1ccfe1d960d708066" translate="yes" xml:space="preserve">
          <source>If the target database table has an INTEGER PRIMARY KEY, it is not possible to insert a NULL value into the IPK column. Attempting to do so results in an SQLITE_MISMATCH error.</source>
          <target state="translated">如果目标数据库表有一个INTEGER PRIMARY KEY,就不能在IPK列中插入一个NULL值。试图这样做会导致一个SQLITE_MISMATCH错误。</target>
        </trans-unit>
        <trans-unit id="9c95a9c982f66790e65014b945cf26e39c71b898" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table that has no PRIMARY KEY declaration, the data_% table must also contain a column named &quot;rbu_rowid&quot;. The rbu_rowid column is mapped to the tables &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. For example, if the target database contains either of the following:</source>
          <target state="translated">如果目标数据库表是虚拟表或没有PRIMARY KEY声明的表，则data_％表还必须包含一个名为&amp;ldquo; rbu_rowid&amp;rdquo;的列。rbu_rowid列映射到表&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;。例如，如果目标数据库包含以下任一：</target>
        </trans-unit>
        <trans-unit id="fbd25358ffefdc6dc4f80487cafab05d3b5b26ee" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table with no PRIMARY KEY, the rbu_control value should not include a character corresponding to the rbu_rowid value. For example, this:</source>
          <target state="translated">如果目标数据库表是一个虚拟表或者是一个没有PRIMARY KEY的表,那么rbu_control值中不应该包含一个与rbu_rowid值相对应的字符。例如,这。</target>
        </trans-unit>
        <trans-unit id="01af3a5676cb2f1557deacfea75c22d3ec69c112" translate="yes" xml:space="preserve">
          <source>If the text fragment does not begin at the start of a column value, the &quot;ellipses&quot; text is prepended to it.</source>
          <target state="translated">如果文本片段不是从列值的开头开始,则在其前面加上 &quot;省略号 &quot;文本。</target>
        </trans-unit>
        <trans-unit id="c5699be55281fc6c124864de2ed79fa2e78862fa" translate="yes" xml:space="preserve">
          <source>If the text fragment does not finish at the end of a column value, the &quot;ellipses&quot; text is appended to it.</source>
          <target state="translated">如果文本片段没有在列值的结尾处结束,则在其上附加 &quot;省略号 &quot;文本。</target>
        </trans-unit>
        <trans-unit id="9b02a2cc603460380751e873e7881c3872500434" translate="yes" xml:space="preserve">
          <source>If the third parameter (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped.</source>
          <target state="translated">如果第三个参数(指向sqlite3_module对象的指针)为NULL,那么就不会创建新的模块,任何现有的同名模块都会被删除。</target>
        </trans-unit>
        <trans-unit id="1fb42f686bdf0ae2d9460cba55a33f179256de59" translate="yes" xml:space="preserve">
          <source>If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.</source>
          <target state="translated">如果两个快照句柄不与同一个数据库文件相关联,那么比较的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="e40d631505df75eada1d7356f623733efe0e7e84" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">如果值N超出范围或第N个参数为无名，则返回NULL。即使最初在&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;中将命名参数指定为UTF-16，返回的字符串始终采用UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="345b60970d744b5b63e874a6cd2300d092b35eca" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">如果值N超出范围或第N个参数为无名，则返回NULL。即使最初在&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;中将命名参数指定为UTF-16，返回的字符串始终采用UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="d68928282b4992ea60ac59e231acaeb89700dde0" translate="yes" xml:space="preserve">
          <source>If the value being substituted is larger than the width, then full value is added to the output. In other words, the width is the minimum width of the value as it is rendered in the output.</source>
          <target state="translated">如果被替换的值大于宽度,那么全值将被添加到输出中。换句话说,宽度是数值在输出中呈现的最小宽度。</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="6f9d3eb4af97233320c8cb8d005d76e733f1eb82" translate="yes" xml:space="preserve">
          <source>If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json1 function (such as &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; or &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; or &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt;) then it is interpreted as JSON and is inserted as JSON retaining all of its substructure.</source>
          <target state="translated">如果路径/值对的值是SQLite TEXT值，则通常将其作为带引号的JSON字符串插入，即使该字符串看起来像有效的JSON。但是，如果该值是另一个json1函数（例如&lt;a href=&quot;json1#jmini&quot;&gt;json（）&lt;/a&gt;或&lt;a href=&quot;json1#jarray&quot;&gt;json_array（）&lt;/a&gt;或&lt;a href=&quot;json1#jobj&quot;&gt;json_object（）&lt;/a&gt;）的结果，则将其解释为JSON并插入为JSON，以保留其所有子结构。</target>
        </trans-unit>
        <trans-unit id="b32ac49b143ce73b794453377ce559efe5961df7" translate="yes" xml:space="preserve">
          <source>If the value of the zString variable is NULL, the generated SQL will look like the following:</source>
          <target state="translated">如果zString变量的值是NULL,那么生成的SQL就会像下面这样。</target>
        </trans-unit>
        <trans-unit id="8161ccbb4f6a18f526e60b92f180512b88485f22" translate="yes" xml:space="preserve">
          <source>If the values &quot;inserted&quot; into the text columns as part of a 'delete' command are not the same as those currently stored within the table, the results may be unpredictable.</source>
          <target state="translated">如果作为 &quot;删除 &quot;命令的一部分,&quot;插入 &quot;到文本列中的值与当前存储在表中的值不一样,那么结果可能是不可预测的。</target>
        </trans-unit>
        <trans-unit id="59bbe3f4e62b07925a07b5a183754aca1009b0a0" translate="yes" xml:space="preserve">
          <source>If the variable does not have a bytearray representation, then &quot;@&quot; works just like &quot;$&quot;. Note that &quot;:&quot; works like &quot;$&quot; in all cases so the following is another way to express the same statement:</source>
          <target state="translated">如果变量没有用字节数组表示,那么&quot;@&quot;就像&quot;$&quot;一样。请注意,&quot;:&quot;在所有情况下都和&quot;$&quot;一样,所以下面是表达相同语句的另一种方式。</target>
        </trans-unit>
        <trans-unit id="967912701ccde0cf6890cfdea463d69721e44f33" translate="yes" xml:space="preserve">
          <source>If the virtual machine is unable to open the database file because it is locked by another thread or process, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_BUSY. The calling function should do some other activity, or sleep, for a short amount of time to give the lock a chance to clear, then invoke &lt;b&gt;sqlite_step&lt;/b&gt; again. This can be repeated as many times as desired.</source>
          <target state="translated">如果虚拟机由于被另一个线程或进程锁定而无法打开数据库文件，则&lt;b&gt;sqlite_step&lt;/b&gt;将返回SQLITE_BUSY。调用函数应该在短时间内进行一些其他活动或睡眠，以使锁有机会被清除，然后再次调用&lt;b&gt;sqlite_step&lt;/b&gt;。可以根据需要将其重复多次。</target>
        </trans-unit>
        <trans-unit id="d0cab5be9268823b532780f4620139e0b2493eda" translate="yes" xml:space="preserve">
          <source>If the virtual table contains one or more rows that match the search criteria, then the cursor must be left point at the first row. Subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero). If there are no rows match, then the cursor must be left in a state that will cause the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; to return true (non-zero). The SQLite engine will use the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods to access that row content. The &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; method will be used to advance to the next row.</source>
          <target state="translated">如果虚拟表包含一个或多个符合搜索条件的行，则光标必须位于第一行的左侧。对&lt;a href=&quot;vtab#xeof&quot;&gt;xEof的&lt;/a&gt;后续调用必须返回false（零）。如果没有匹配的行，则游标必须处于会导致&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;返回true（非零）的状态。 SQLite引擎将使用&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;和&lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt;方法访问该行内容。该&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;方法将被用于推进到下一行。</target>
        </trans-unit>
        <trans-unit id="ad0d9be234c914ee5ff307719c3b70dd43c84d33" translate="yes" xml:space="preserve">
          <source>If the virtual table will output rows in the order specified by the ORDER BY clause, then the orderByConsumed flag may be set to true. If the output is not automatically in the correct order then orderByConsumed must be left in its default false setting. This will indicate to the SQLite core that it will need to do a separate sorting pass over the data after it comes out of the virtual table.</source>
          <target state="translated">如果虚拟表将按照ORDER BY子句指定的顺序输出行,那么orderByConsumed标志可以设置为true。如果输出的顺序不是自动正确的,那么orderByConsumed必须保留其默认的false设置。这将向SQLite核心表明,在数据从虚拟表出来后,它需要对数据进行单独的排序传递。</target>
        </trans-unit>
        <trans-unit id="40852f77f22b22d25b15aa100b0b83a4fb17d34c" translate="yes" xml:space="preserve">
          <source>If the width is a single &quot;*&quot; character instead of a number, then the actual width value is read as an integer from the argument list. If the value read is negative, then the absolute value is used for the width and the value is left-justified as if the &quot;-&quot; flag were present.</source>
          <target state="translated">如果宽度是一个单一的 &quot;*&quot;字符而不是数字,那么实际的宽度值就会从参数列表中读出一个整数。如果读出的值是负数,那么宽度的绝对值就会被使用,并且该值会像&quot;-&quot;标志一样被左对齐。</target>
        </trans-unit>
        <trans-unit id="5f665397e9a7b0fe05142c4eb0f952c2d738840c" translate="yes" xml:space="preserve">
          <source>If the xAccess() query required by H35490 reveals that the journal file is still present in the file system, then SQLite shall conclude that the journal file is a</source>
          <target state="translated">如果H35490所要求的xAccess()查询发现该日志文件仍然存在于文件系统中,那么SQLite应断定该日志文件是一个</target>
        </trans-unit>
        <trans-unit id="2ece4dc60c85bd0f6370651e04aa59f231e6a232" translate="yes" xml:space="preserve">
          <source>If the xColumn method implementation calls none of the functions above, then the value of the column defaults to an SQL NULL.</source>
          <target state="translated">如果xColumn方法的实现没有调用上述任何一个函数,那么该列的值默认为SQL NULL。</target>
        </trans-unit>
        <trans-unit id="df9512eb02b352fc76419bfac69b024afe92a594" translate="yes" xml:space="preserve">
          <source>If the xCreate method is omitted (left as a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;. New instances of the virtual table cannot be created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; and the virtual table can only be used via its module name. Note that SQLite versions prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and will segfault if an attempt is made to &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; on an eponymous-only virtual table because the xCreate method was not checked for null.</source>
          <target state="translated">如果省略xCreate方法（保留为NULL指针），则虚拟表是&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;仅&lt;/a&gt;具有别名的虚拟表。无法使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;创建虚拟表的新实例，并且只能通过其模块名称使用虚拟表。请注意，3.9.0（2015-10-14）之前的SQLite版本无法理解仅具有名称的虚拟表，并且由于未检查xCreate方法而试图在仅具有名称的&lt;a href=&quot;lang_createvtab&quot;&gt;虚拟表&lt;/a&gt;上创建CREATE VIRTUAL TABLE时将出现段错误为空。</target>
        </trans-unit>
        <trans-unit id="2621a8e3fdadffc723f38e49d09955e1039ab97f" translate="yes" xml:space="preserve">
          <source>If the xCreate method is the exact same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, that indicates that the virtual table does not need to initialize backing store. Such a virtual table can be used as an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; or as a named virtual table using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; or both.</source>
          <target state="translated">如果xCreate方法是完全相同的指针作为&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法，指示该虚拟表不需要初始化后备存储器。这样的虚拟表可以用作&lt;a href=&quot;vtab#epovtab&quot;&gt;同义虚拟表&lt;/a&gt;或使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;或同时用作命名虚拟表。</target>
        </trans-unit>
        <trans-unit id="1ea6013e86112c06dab3e4770a560b43808bcc0c" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">如果xEntryPoint例程遇到错误，则应使* pzErrMsg指向适当的错误消息（从&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;获得），并返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。在调用xEntryPoint（）之前，SQLite确保* pzErrMsg为NULL。xEntryPoint（）返回后，SQLite将在* pzErrMsg上调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;。如果任何xEntryPoint（）返回错误，则引发xEntryPoint（）的&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;调用将失败。</target>
        </trans-unit>
        <trans-unit id="f84dff46c33beaf54e0ca4079880cc37a3fce130" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">如果xEntryPoint例程遇到错误，则应使* pzErrMsg指向适当的错误消息（从&lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;获得），并返回适当的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。在调用xEntryPoint（）之前，SQLite确保* pzErrMsg为NULL。xEntryPoint（）返回后，SQLite将在* pzErrMsg上调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;。如果任何xEntryPoint（）返回错误，则引发xEntryPoint（）的&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;调用将失败。</target>
        </trans-unit>
        <trans-unit id="74fa84b64e4977d1c29908e0f6708d6d082c0af7" translate="yes" xml:space="preserve">
          <source>If the xUpdate method is performing an UPDATE, then &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; can be used to discover which columns of the virtual table were actually modified by the UPDATE statement. The &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; interface returns true for columns that do not change. On every UPDATE, SQLite will first invoke &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; separately for each unchanging column in the table to obtain the value for that column. The &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method can check to see if the column is unchanged at the SQL level by invoking &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt;. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; sees that the column is not being modified, it should return without setting a result using one of the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces. Only in that case &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; will be true within the xUpdate method. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; does invoke one or more &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces, then SQLite understands that as a change in the value of the column and the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; call for that column within xUpdate will return false.</source>
          <target state="translated">如果xUpdate方法正在执行UPDATE，则可以使用&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;来发现UPDATE语句实际修改了虚拟表的哪些列。该&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;接口返回true为不更改列。在每个UPDATE上，SQLite将首先为表中的每个不变列分别调用&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;以获得该列的值。该&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法可以检查，看看是否列不变在SQL级别通过调用&lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange（）。&lt;/a&gt;如果&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;看到未修改该列，则应使用&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx（）&lt;/a&gt;之一返回而不设置结果接口。只有在这种情况下，在xUpdate方法中&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（）才&lt;/a&gt;为true。如果&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;确实调用了一个或多个&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx（）&lt;/a&gt;接口，则SQLite会理解，作为列值的更改，xUpdate 中对该列的&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（）&lt;/a&gt;调用将返回false。</target>
        </trans-unit>
        <trans-unit id="7b85064db380f0c3b1175d1e7fe24a5bdf881bd8" translate="yes" xml:space="preserve">
          <source>If the xUpdate method violates some constraint of the virtual table (including, but not limited to, attempting to store a value of the wrong datatype, attempting to store a value that is too large or too small, or attempting to change a read-only value) then the xUpdate must fail with an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果xUpdate方法违反了虚拟表的某些约束（包括但不限于尝试存储错误数据类型的值，尝试存储太大或太小的值或尝试更改只读值值），则xUpdate必须失败，并带有相应的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a7985513fccd145b507f142e6f37dfce68e7177" translate="yes" xml:space="preserve">
          <source>If the zString variable holds text like &quot;Hello&quot;, then this statement will work just fine. But suppose the user enters a string like &quot;Hi y'all!&quot;. The SQL statement generated reads as follows:</source>
          <target state="translated">如果zString变量中存放的是 &quot;你好 &quot;这样的文本,那么这条语句就能正常工作。但假设用户输入的是 &quot;你们好!&quot;这样的字符串。生成的SQL语句如下。</target>
        </trans-unit>
        <trans-unit id="38c9c0042a5b1d208534216bf07dfb6099f9ebb4" translate="yes" xml:space="preserve">
          <source>If there are many client programs sending SQL to the same database over a network, then use a client/server database engine instead of SQLite. SQLite will work over a network filesystem, but because of the latency associated with most network filesystems, performance will not be great. Also, file locking logic is buggy in many network filesystem implementations (on both Unix and Windows). If file locking does not work correctly, two or more clients might try to modify the same part of the same database at the same time, resulting in corruption. Because this problem results from bugs in the underlying filesystem implementation, there is nothing SQLite can do to prevent it.</source>
          <target state="translated">如果有很多客户端程序通过网络向同一个数据库发送SQL,那么就用客户端/服务器数据库引擎代替SQLite。SQLite可以在网络文件系统上工作,但由于大多数网络文件系统的延迟,性能不会很好。此外,在许多网络文件系统实现中,文件锁定逻辑是错误的(在Unix和Windows上)。如果文件锁定不能正常工作,两个或更多的客户端可能会试图同时修改同一数据库的同一部分,从而导致损坏。因为这个问题是由底层文件系统实现中的错误导致的,所以SQLite无法阻止这个问题的发生。</target>
        </trans-unit>
        <trans-unit id="36f4c3a2fda5cf31617c5fabae95e90bafd39057" translate="yes" xml:space="preserve">
          <source>If there are multiple (hard or symbolic) links to a database file, the journal will be created using the name of the link through which the file was opened. If a crash occurs and the database is opened again using a different link, the hot journal will not be located and no rollback will occur.</source>
          <target state="translated">如果一个数据库文件有多个(硬链接或符号)链接,将使用打开文件的链接名称创建日志。如果发生崩溃,使用不同的链接再次打开数据库,热日志将无法找到,也不会发生回滚。</target>
        </trans-unit>
        <trans-unit id="11044e3b942016886a776e1bab1892306cb966d9" translate="yes" xml:space="preserve">
          <source>If there are still more pages to copy from database pDb, then the function sleeps for 250 milliseconds (using the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; utility) and then returns to step 2.</source>
          <target state="translated">如果还有更多页面要从数据库pDb复制，则该函数休眠250毫秒（使用&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;实用程序），然后返回到步骤2。</target>
        </trans-unit>
        <trans-unit id="afce5a653d0b42c7793177067bc50ad86675aae0" translate="yes" xml:space="preserve">
          <source>If there exists an index that maps the &quot;two&quot; column of the &quot;examp&quot; table into integers, then SQLite will use that index to find the integer keys of all rows in examp that have a value of 50 for column two, or all rows that are less than 50, etc. But the following queries cannot use the index:</source>
          <target state="translated">如果存在一个索引,将 &quot;examp &quot;表的 &quot;二 &quot;列映射成整数,那么SQLite就会使用这个索引来查找examp中所有二列值为50的行的整数键,或者所有小于50的行等。但是下面的查询不能使用该索引。</target>
        </trans-unit>
        <trans-unit id="856948c8edddeced0c9cafe3bd0f42f4ee0fc501" translate="yes" xml:space="preserve">
          <source>If there has been one or more REPLACE resolutions on a key, it is rebased according to a REPLACE.</source>
          <target state="translated">如果一个键上已经有一个或多个REPLACE决议,则根据REPLACE进行重新计算。</target>
        </trans-unit>
        <trans-unit id="4dc77fa5e92703a982360848038ee795cce33659" translate="yes" xml:space="preserve">
          <source>If there have been no REPLACE resolutions on a key, then the local changeset is rebased according to the most recent of the OMIT resolutions.</source>
          <target state="translated">如果在一个键上没有REPLACE的决议,那么本地的变化集将根据最近的OMIT决议来重新计算。</target>
        </trans-unit>
        <trans-unit id="b7ee1d4caced0cc280acbdfbbd3da7974e0aedc7" translate="yes" xml:space="preserve">
          <source>If there is a USING clause then each of the column names specified must exist in the datasets to both the left and right of the join-operator. For each pair of named columns, the expression &quot;lhs.X = rhs.X&quot; is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which all such expressions evaluates to true are included from the result set. When comparing values as a result of a USING clause, the normal rules for handling affinities, collation sequences and NULL values in comparisons apply. The column from the dataset on the left-hand side of the join-operator is considered to be on the left-hand side of the comparison operator (=) for the purposes of collation sequence and affinity precedence.</source>
          <target state="translated">如果有USING子句，则指定的每个列名都必须存在于join-operator左侧和右侧的数据集中。对于每对命名列，对于笛卡尔乘积的每一行，将表达式&amp;ldquo; lhs.X = rhs.X&amp;rdquo;作为&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式&lt;/a&gt;进行求值。结果集中仅包含所有此类表达式求值为true的行。当比较作为USING子句的结果的值时，适用处理比较中的亲和力，排序规则序列和NULL值的常规规则。出于排序顺序和相似性优先顺序的考虑，联接运算符左侧的数据集中的列被视为位于比较运算符（=）的左侧。</target>
        </trans-unit>
        <trans-unit id="d234388212b95e999640f17f4b156605cf6f600f" translate="yes" xml:space="preserve">
          <source>If there is already a read transaction open when this function is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR, SQLITE_BUSY or SQLITE_ERROR_SNAPSHOT is returned. If another error code - for example SQLITE_PROTOCOL or an SQLITE_IOERR error code - is returned, then the final state of the read transaction is undefined. If SQLITE_OK is returned, then the read transaction is now open on database snapshot P.</source>
          <target state="translated">如果在调用这个函数时已经有一个读事务被打开,那么如果返回SQLITE_ERROR、SQLITE_BUSY或SQLITE_ERROR_SNAPSHOT,那么同一个读事务仍然被打开(在同一个数据库快照上)。如果返回了另一个错误代码--例如SQLITE_PROTOCOL或SQLITE_IOERR错误代码,那么读事务的最终状态是未定义的。如果返回SQLITE_OK,那么读事务现在已经在数据库快照P上打开。</target>
        </trans-unit>
        <trans-unit id="b3ba606d14be7904e644a6f345ba54604a8e5ba7" translate="yes" xml:space="preserve">
          <source>If there is already an auxiliary data pointer when this function is invoked, then it is replaced by the new pointer. If an xDelete callback was specified along with the original pointer, it is invoked at this point.</source>
          <target state="translated">如果在调用这个函数时,已经有一个辅助数据指针,那么它将被新的指针替换。如果xDelete回调与原始指针一起被指定,那么它将在此时被调用。</target>
        </trans-unit>
        <trans-unit id="7d3f7f6da384d18458af17b6bbb473e63bd6c0a4" translate="yes" xml:space="preserve">
          <source>If there is an AS clause on the result, then the name of the column is the right-hand side of the AS clause.</source>
          <target state="translated">如果结果上有一个AS子句,那么列的名称就是AS子句的右侧。</target>
        </trans-unit>
        <trans-unit id="ea4985ea47701fb618426a82280d62d99731524f" translate="yes" xml:space="preserve">
          <source>If there is an ON clause then the ON expression is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the expression evaluates to true are included from the dataset.</source>
          <target state="translated">如果存在ON子句，则将笛卡尔乘积的每一行作为&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式&lt;/a&gt;评估ON 表达式。数据集中仅包含表达式评估为true的行。</target>
        </trans-unit>
        <trans-unit id="2e70dfed6b6c48ce8dce24e64f939fa0229381a9" translate="yes" xml:space="preserve">
          <source>If there is no compatible table, it is not an error, but none of the changes associated with the table are applied. A warning message is issued via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At most one such warning is issued for each table in the changeset.</source>
          <target state="translated">如果没有兼容的表,这不是一个错误,但与表相关的变化都不会被应用。通过sqlite3_log()机制发出一条警告信息,错误代码为SQLITE_SCHEMA。对于变化集中的每个表,最多发出一个这样的警告。</target>
        </trans-unit>
        <trans-unit id="8b1f218c8fcc4cd8280015ffb23038ba539a45b9" translate="yes" xml:space="preserve">
          <source>If there is no index named</source>
          <target state="translated">如果没有名为</target>
        </trans-unit>
        <trans-unit id="5f851a7381e365ca34ec1852c08b2f940f8860fc" translate="yes" xml:space="preserve">
          <source>If there is no selftest table, the &quot;.selftest&quot; command runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;.</source>
          <target state="translated">如果没有自检表，则&amp;ldquo; .selftest&amp;rdquo;命令运行&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c042772d4bc73bd02a9ce067deaf034251147e0f" translate="yes" xml:space="preserve">
          <source>If there is only a single table or subquery in the FROM clause, then the input data used by the SELECT statement is the contents of the named table. If there is more than one table or subquery in FROM clause then the contents of all tables and/or subqueries are joined into a single dataset for the simple SELECT statement to operate on. Exactly how the data is combined depends on the specific &lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator&lt;/a&gt; and &lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint&lt;/a&gt; used to connect the tables or subqueries together.</source>
          <target state="translated">如果FROM子句中只有一个表或子查询，则SELECT语句使用的输入数据就是命名表的内容。如果FROM子句中有多个表或子查询，则所有表和/或子查询的内容都将合并到一个数据集中，以使简单的SELECT语句可以操作。数据的确切组合方式取决于用于将表或子查询连接在一起的特定联接&lt;a href=&quot;syntax/join-operator&quot;&gt;运算符&lt;/a&gt;和联接&lt;a href=&quot;syntax/join-constraint&quot;&gt;约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c64aa9b4e57f38edc6d2ba80d1689a5d372c4ee" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">如果这些例程是在不同于包含接收&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt;指针的应用程序定义函数的线程中调用的，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="cd8848554ca2d7f3d01b722c239f1dc6287ba93f" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">如果这些例程是在不同于包含接收&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt;指针的应用程序定义函数的线程中调用的，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="915164f8017ef4e64adbf0d45fa62da4e11e9b32" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro disables the &quot;deferred token&quot; optimization in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;. The &quot;deferred token&quot; optimization avoids loading massive posting lists for terms that are in most documents of the collection and instead simply scans for those tokens in the document source. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; should get exactly the same answer both with and without this optimization.</source>
          <target state="translated">如果此C预处理器宏禁用&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4中&lt;/a&gt;的&amp;ldquo;延迟令牌&amp;rdquo;优化。 &amp;ldquo;递延令牌&amp;rdquo;优化避免了为集合的大多数文档中的术语加载大量的过帐列表，而只是在文档源中扫描这些令牌。无论是否进行此优化，&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;都应获得完全相同的答案。</target>
        </trans-unit>
        <trans-unit id="ae29c8f0136956324cb9875e314002993d7a9c98" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined and if the xDeviceCharacteristics method of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object for a database file reports (via one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits) that the filesystem supports atomic writes and if a transaction involves a change to only a single page of the database file, then the transaction commits with just a single write request of a single page of the database and no rollback journal is created or written. On filesystems that support atomic writes, this optimization can result in significant speed improvements for small updates. However, few filesystems support this capability and the code paths that check for this capability slow down write performance on systems that lack atomic write capability, so this feature is disabled by default.</source>
          <target state="translated">如果定义了此C预处理器宏，并且数据库文件的&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xDeviceCharacteristics方法报告（通过&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt;位之一）报告该文件系统支持原子写入，并且如果事务仅涉及更改数据库的单个页面，文件，则仅提交数据库单页的单个写入请求，就不会提交或写入回滚日志，而提交事务。在支持原子写入的文件系统上，此优化可以显着提高小型更新的速度。但是，很少有文件系统支持此功能，并且检查此功能的代码路径会降低缺少原子写功能的系统上的写性能，因此默认情况下禁用此功能。</target>
        </trans-unit>
        <trans-unit id="f74239b5b9713fd263bba27dcb07765bb74b0239" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, directory syncs are disabled. SQLite typically attempts to sync the parent directory when a file is deleted to ensure the directory entries are updated immediately on disk.</source>
          <target state="translated">如果定义了这个C-preprocessor宏,则禁用目录同步。SQLite通常会在文件被删除时尝试同步父目录,以确保目录项在磁盘上立即更新。</target>
        </trans-unit>
        <trans-unit id="5737b83035ce500dcfa496d2b2b66e0845cad862" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, large file support is disabled.</source>
          <target state="translated">如果定义了这个C-preprocessor宏,则禁用大文件支持。</target>
        </trans-unit>
        <trans-unit id="262e2217c94b5b2f3ea64e55aebf18183a8f388a" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; is omitted from the build and is unavailable to applications.</source>
          <target state="translated">如果定义了此C预处理程序宏，则&lt;a href=&quot;fts3&quot;&gt;FTS3中&lt;/a&gt;的&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt;标记化器将从构建中省略，并且对应用程序不可用。</target>
        </trans-unit>
        <trans-unit id="39617688d9840b06235bc5d306b07bb0ba889ba9" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, then extra code is included that allows SQLite to function on a filesystem that only support 8+3 filenames. If the value of this macro is 1, then the default behavior is to continue to use long filenames and to only use 8+3 filenames if the database connection is opened using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; with the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter. If the value of this macro is 2, then the use of 8+3 filenames becomes the default but may be disabled on using the &lt;code&gt;8_3_names=0&lt;/code&gt; query parameter.</source>
          <target state="translated">如果定义了此C预处理器宏，则将包含额外的代码，这些代码使SQLite可以在仅支持8 + 3文件名的文件系统上运行。如果此宏的值为1，则默认行为是继续使用长文件名，并且如果使用带有&amp;ldquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &amp;rdquo;查询参数的&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;打开数据库连接，则默认行为是仅使用8 + 3文件名。如果此宏的值为2，则默认使用8 + 3文件名，但在使用 &lt;code&gt;8_3_names=0&lt;/code&gt; 查询参数时可能会被禁用。</target>
        </trans-unit>
        <trans-unit id="ad3d89f2752a79cf47c58e04a726219583d11898" translate="yes" xml:space="preserve">
          <source>If this SELECT returns any rows at all, then SQLite concludes that deleting the row from the parent table would violate the foreign key constraint and returns an error. Similar queries may be run if the content of the parent key is modified or a new row is inserted into the parent table. If these queries cannot use an index, they are forced to do a linear scan of the entire child table. In a non-trivial database, this may be prohibitively expensive.</source>
          <target state="translated">如果这个SELECT根本没有返回任何行,那么SQLite就会得出结论,从父表中删除该行会违反外键约束,并返回一个错误。如果修改了父键的内容,或者在父表中插入了新的记录,则可能会运行类似的查询。如果这些查询不能使用索引,就会被迫对整个子表进行线性扫描。在一个非平凡的数据库中,这可能是非常昂贵的。</target>
        </trans-unit>
        <trans-unit id="d8ee4bc759bb4de0d55341a4133e995c0e985e4b" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol defined, then there exists a built-in tokenizer named &quot;icu&quot; implemented using the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h) of this tokenizer may be an ICU locale identifier. For example &quot;tr_TR&quot; for Turkish as used in Turkey, or &quot;en_AU&quot; for English as used in Australia. For example:</source>
          <target state="translated">如果这个扩展在编译时定义了SQLITE_ENABLE_ICU预处理器符号,那么就存在一个名为 &quot;icu &quot;的内置tokenizer,它是使用ICU库实现的。传递给 xCreate()方法 (参见 fts3_tokenizer.h)的第一个参数可以是一个 ICU 本地化标识符。例如,&quot;tr_TR &quot;代表土耳其语,在土耳其使用;&quot;en_AU &quot;代表英语,在澳大利亚使用。举例来说。</target>
        </trans-unit>
        <trans-unit id="d023458a29576f7575443a7b9afec6275af3fcf1" translate="yes" xml:space="preserve">
          <source>If this function is called when the iterator does not point to a valid entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise, SQLITE_OK is returned and the output variables populated as described above.</source>
          <target state="translated">如果这个函数在迭代器没有指向一个有效的条目时被调用,则返回SQLITE_MISUSE,并将输出变量清零。否则,将返回SQLITE_OK,并如上所述填充输出变量。</target>
        </trans-unit>
        <trans-unit id="575c4fba56a8b3b5c139b07c2f0bb05a15bdbd1b" translate="yes" xml:space="preserve">
          <source>If this function needs to obtain extra database locks before dirty pages can be flushed to disk, it does so. If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner. If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database. If any databases are skipped because locks cannot be obtained, but no other error occurs, this function returns SQLITE_BUSY.</source>
          <target state="translated">如果这个函数需要在脏页被刷新到磁盘之前获得额外的数据库锁,它就会这样做。如果不能立即获得这些锁,并且配置了一个忙处理回调,则以通常的方式调用该函数。如果仍然无法获得所需的锁,则跳过数据库,并尝试将属于下一个(如果有的话)数据库的任何脏页刷新。如果因为无法获得锁而跳过任何数据库,但没有发生其他错误,则该函数返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="4a59fbb2ab0548034e0f0c93999e3d83e86e0a83" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">如果使此全局变量指向一个字符串，该字符串是文件夹（即目录）的名称，则将假定所有使用相对路径名指定并由SQLite使用内置Windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt;创建或访问的数据库文件都可以相对于该目录。如果此变量是NULL指针，则SQLite假定使用相对路径名指定的所有数据库文件都相对于该进程的当前目录。仅Windows VFS使用此全局变量。 Unix VFS会忽略它。</target>
        </trans-unit>
        <trans-unit id="84ebd8e9c186529f8ee21c34bc9c7d688ed08739" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">如果使此全局变量指向一个字符串，该字符串是文件夹（即目录）的名称，则将假定所有使用相对路径名指定并由SQLite使用内置Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;创建或访问的数据库文件都可以相对于该目录。如果此变量是NULL指针，则SQLite假定使用相对路径名指定的所有数据库文件都相对于该进程的当前目录。仅Windows VFS使用此全局变量。 Unix VFS会忽略它。</target>
        </trans-unit>
        <trans-unit id="ae61adf99b3e9cfc86e28932de2b54c5d4c9e28e" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">如果使此全局变量指向一个字符串，该字符串是文件夹（也称为目录）的名称，则SQLite在使用内置&lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt;时创建的所有临时文件都将放置在该目录中。如果此变量是NULL指针，则SQLite将搜索适当的临时文件目录。</target>
        </trans-unit>
        <trans-unit id="2fef70c16016d67dc3025afd347c1e52be3b317a" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">如果使此全局变量指向一个字符串，该字符串是文件夹（也称为目录）的名称，则SQLite在使用内置&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;时创建的所有临时文件都将放置在该目录中。如果此变量是NULL指针，则SQLite将搜索适当的临时文件目录。</target>
        </trans-unit>
        <trans-unit id="377f589c93b8d1620f4832f74e589324c623fda3" translate="yes" xml:space="preserve">
          <source>If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.</source>
          <target state="translated">如果在xConnect或xCreate虚拟表方法的上下文之外调用该接口,那么行为将未定义。</target>
        </trans-unit>
        <trans-unit id="16ae3ddca07ff1751105a0aea6145c79101d244a" translate="yes" xml:space="preserve">
          <source>If this macro is defined to a positive integer</source>
          <target state="translated">如果这个宏定义为正整数,那么就会出现这样的情况</target>
        </trans-unit>
        <trans-unit id="5cc647c8428edf625b094fb0de5d9a7c439f06d1" translate="yes" xml:space="preserve">
          <source>If this macro is defined, then the special &quot;$</source>
          <target state="translated">如果定义了这个宏,那么特殊的&quot;$?</target>
        </trans-unit>
        <trans-unit id="53c0130971cedde038e298ffc488f5a86580ab11" translate="yes" xml:space="preserve">
          <source>If this option is defined, SQLite's built-in date and time manipulation functions are omitted. Specifically, the SQL functions julianday(), date(), time(), datetime() and strftime() are not available. The default column values CURRENT_TIME, CURRENT_DATE and CURRENT_TIMESTAMP are still available.</source>
          <target state="translated">如果定义了这个选项,SQLite的内置日期和时间操作函数就会被省略。具体来说,SQL函数julianday()、date()、time()、datetime()和strftime()不可用。默认的列值CURRENT_TIME、CURRENT_DATE和CURRENT_TIMESTAMP仍然可用。</target>
        </trans-unit>
        <trans-unit id="3a2de06267117d8a8013c26631a2b4a79f2165b1" translate="yes" xml:space="preserve">
          <source>If this option is defined, the library cannot create or write to databases that support &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;. Executing a &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; statement is not an error (since unknown PRAGMAs are silently ignored), but does not return a value or modify the auto-vacuum flag in the database file. If a database that supports auto-vacuum is opened by a library compiled with this option, it is automatically opened in read-only mode.</source>
          <target state="translated">如果定义了此选项，则库无法创建或写入支持&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum的&lt;/a&gt;数据库。执行&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt;语句不是错误（因为未知PRAGMA会被静默忽略），但是不会返回值或修改数据库文件中的auto-vacuum标志。如果使用此选项编译的库打开了支持自动真空的数据库，则它将以只读模式自动打开。</target>
        </trans-unit>
        <trans-unit id="0d1cff91ceb786cc24acfd1c107d786b9aaa0367" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">如果定义了此选项，则无法识别&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;语法。</target>
        </trans-unit>
        <trans-unit id="6e68b63912f5ef9b57357a53a1d6030e0a438ede" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; syntax is not recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1fe97e82a4364864c18ee6d16ca1ab17fe291c" translate="yes" xml:space="preserve">
          <source>If this option is defined, then it must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate a parse.c file. Because of this, this option may only be used when the library is built from source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the collection of pre-packaged C files provided for non-Unix like platforms on the website.</source>
          <target state="translated">如果定义了此选项，则在使用&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器&lt;/a&gt;工具生成parse.c文件时，也必须定义它。因此，仅当从源而不是通过&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;或从网站上为非Unix平台提供的预打包C文件集合构建库时，才可以使用此选项。</target>
        </trans-unit>
        <trans-unit id="391001eddc6a6f9380d8efca6c5990bffd30c02d" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only only works, of course, on systems that support alloca().</source>
          <target state="translated">如果启用了这个选项,那么将在少数合适的情况下使用 alloca()内存分配器。这样一来,二进制文件就会稍微小一些,速度也快一些。当然,SQLITE_USE_ALLOCA编译时只在支持alloca()的系统上有效。</target>
        </trans-unit>
        <trans-unit id="0a7cb0c994326370629ee23298fc6078fa599fa4" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only works, of course, on systems that support alloca().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e396be7869391838487d1744007a3e656f8af09d" translate="yes" xml:space="preserve">
          <source>If this option is passed a non-zero argument, the &quot;.expert&quot; command generates similar data distribution statistics for all indexes considered based on PERCENT percent of the rows currently stored in each database table. For databases with unusual data distributions, this may lead to better index recommendations, particularly if the application intends to run ANALYZE.</source>
          <target state="translated">如果这个选项被传递一个非零的参数,&quot;.expert &quot;命令就会根据每个数据库表中当前存储的行数的percent百分比为所有被考虑的索引生成类似的数据分布统计。对于具有不寻常数据分布的数据库,这可能会带来更好的索引推荐,特别是当应用程序打算运行ANALYZE时。</target>
        </trans-unit>
        <trans-unit id="84432c7bc70fca55a254f66874dd4bc62fe9abea" translate="yes" xml:space="preserve">
          <source>If this option is present, then SQLite will use the isnan() function from the system math library. This is an alias for the &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; configuration option.</source>
          <target state="translated">如果存在此选项，则SQLite将使用系统数学库中的isnan（）函数。这是&lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt;配置选项的别名。</target>
        </trans-unit>
        <trans-unit id="8be490fe1c118ec4e22a3ceeab9a17451a39a86c" translate="yes" xml:space="preserve">
          <source>If this option is present, then the built-in &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator will be case sensitive. This same effect can be achieved at run-time using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">如果存在此选项，则内置的&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符将区分大小写。使用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;可以在运行时实现相同的效果。</target>
        </trans-unit>
        <trans-unit id="ada121bcb0877b4a8c48986ff56dc5ba81d63e98" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">如果先前未调用此例程，或者如果先前的调用的N小于1或P的NULL指针，则使用从默认&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xRandomness方法获得的随机性来种子PRNG 。如果对该程序的上一次调用的N为1或更大，并且P为非NULL，则在内部生成伪随机性，而无需使用&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness方法。</target>
        </trans-unit>
        <trans-unit id="37bc48a662f5023c1e8434007284ca1643b9979a" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">如果先前未调用此例程，或者如果先前的调用的N小于1或P的NULL指针，则使用从默认&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xRandomness方法获得的随机性来种子PRNG 。如果对该程序的上一次调用的N为1或更大，并且P为非NULL，则在内部生成伪随机性，而无需使用&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness方法。</target>
        </trans-unit>
        <trans-unit id="7e75d3fd5002bfcaea7e83bd9fd2a7a917209184" translate="yes" xml:space="preserve">
          <source>If this value is returned, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_ABORT.</source>
          <target state="translated">如果返回这个值,那么到目前为止应用的任何更改都会被回滚,并且调用 sqlite3changeset_apply()返回 SQLITE_ABORT。</target>
        </trans-unit>
        <trans-unit id="aefcb4f212e79bade6ab9e99069db614c4e4b2ca" translate="yes" xml:space="preserve">
          <source>If tracing is enabled (by the sqlite3_trace()) interface, then the UTF-8 string contained in P4 is emitted on the trace callback. Or if P4 is blank, use the string returned by sqlite3_sql().</source>
          <target state="translated">如果跟踪是启用的(由sqlite3_trace())接口,那么P4中包含的UTF-8字符串会在跟踪回调时发出。如果P4为空,则使用sqlite3_sql()返回的字符串。</target>
        </trans-unit>
        <trans-unit id="3f4fc8020e070710f30d36574cc04f57550a8abc" translate="yes" xml:space="preserve">
          <source>If two database connections shared the same cache and the reader has enabled the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt;, then the reader will be able to see changes made by the writer before the writer transaction commits. The combined use of &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is the only way that one database connection can see uncommitted changes on a different database connection. In all other circumstances, separate database connections are completely isolated from one another.</source>
          <target state="translated">如果两个数据库连接共享相同的缓存，并且读取器启用了&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;，那么读取器将能够在写入器事务提交之前看到写入器所做的更改。&lt;a href=&quot;sharedcache&quot;&gt;共享高速缓存模式&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;的组合使用是一个数据库连接可以看到不同数据库连接上未提交的更改的唯一方法。在所有其他情况下，单独的数据库连接彼此完全隔离。</target>
        </trans-unit>
        <trans-unit id="b41151cd8ed57f8a05f71e68d3e6f727b509adc0" translate="yes" xml:space="preserve">
          <source>If two or more distinct but shareable in-memory databases are needed in a single process, then the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter can be used with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; to create a named in-memory database:</source>
          <target state="translated">如果在单个过程中需要两个或多个不同但可共享的内存数据库，则可以将&lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt;查询参数与&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;一起使用，以创建一个命名的内存数据库：</target>
        </trans-unit>
        <trans-unit id="7c051c04a74b426b583f6b46003048b9ec27b20e" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">如果两个或多个线程同时为相同的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;预处理语句&lt;/a&gt;和结果列调用一个或多个&lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;列元数据接口&lt;/a&gt;，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="3f3b1a7191faa957bd4b9a2df637334c8be60539" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">如果两个或多个线程同时为相同的&lt;a href=&quot;stmt&quot;&gt;预处理语句&lt;/a&gt;和结果列调用一个或多个&lt;a href=&quot;column_database_name&quot;&gt;列元数据接口&lt;/a&gt;，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="f59e0a816231da9addc2b58ecf1aebf4318f03f1" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined.</source>
          <target state="translated">如果两个或多个线程同时针对同一个准备好的语句和列调用其中的一个或多个例程,那么结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="47c7553b72e9db086338dfa731f7055b973ce5ac" translate="yes" xml:space="preserve">
          <source>If two processes have open connections to the same database file and one process closes its connection, unlinks the file, then creates a new database file in its place with the same name and reopens the new file, then the two processes will be talking to different database files with the same name. (Note that this is only possible on Posix and Posix-like systems that permit a file to be unlinked while it is still open for reading and writing. Windows does not allow this to occur.) Since rollback journals and WAL files are based on the name of the database file, the two different database files will share the same rollback journal or WAL file. A rollback or recovery for one of the databases might use content from the other database, resulting in corruption. A similar problem occurs if a database file is renamed while it is opened and a new file is created with the old name.</source>
          <target state="translated">如果两个进程对同一个数据库文件有开放的连接,而其中一个进程关闭了它的连接,解除了文件的链接,然后在它的位置上创建了一个新的同名数据库文件,并重新打开了新的文件,那么这两个进程将与不同的同名数据库文件对话。(请注意,只有在Posix和类似Posix的系统上才可能发生这种情况,因为这些系统允许在文件仍处于打开读写状态时解除链接。Windows不允许这样做)。)由于回滚日志和WAL文件是基于数据库文件的名称,两个不同的数据库文件将共享同一个回滚日志或WAL文件。其中一个数据库的回滚或恢复可能会使用另一个数据库的内容,从而导致损坏。如果数据库文件在打开时被重新命名,并以旧名创建新文件,也会出现类似问题。</target>
        </trans-unit>
        <trans-unit id="0f73506a4d083541e30151f33df9ff76bf05c8d1" translate="yes" xml:space="preserve">
          <source>If using the MATCH or = operators, the expression to the left of the MATCH operator is usually the name of the FTS5 table (the exception is when &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;specifying a column-filter&lt;/a&gt;). The expression on the right must be a text value specifying the term to search for. For the table-valued function syntax, the term to search for is specified as the first table argument. For example:</source>
          <target state="translated">如果使用MATCH或=运算符，则MATCH运算符左侧的表达式通常是FTS5表的名称（&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;指定column-filter&lt;/a&gt;时例外）。右边的表达式必须是一个文本值，指定要搜索的术语。对于表值函数语法，将要搜索的术语指定为第一个表参数。例如：</target>
        </trans-unit>
        <trans-unit id="10c759f053d61c7e03ff959d29d1e1974783d209" translate="yes" xml:space="preserve">
          <source>If using the MinGW compiler, the command-line is this:</source>
          <target state="translated">如果使用MinGW编译器,命令行是这样的。</target>
        </trans-unit>
        <trans-unit id="06877745f4f906674e7afae07a31cb3adf870f29" translate="yes" xml:space="preserve">
          <source>If using the amalgamation autoconf based build system, setting the CPPFLAGS environment variable while running the 'configure' script is an easy way to set these macros. For example, the following command:</source>
          <target state="translated">如果使用基于amalgamation autoconf的构建系统,在运行 &quot;configure &quot;脚本时设置CPPFLAGS环境变量是设置这些宏的简单方法。例如,下面的命令。</target>
        </trans-unit>
        <trans-unit id="c06d03a70a5b876ea7069032c87d9367a09e46c5" translate="yes" xml:space="preserve">
          <source>If when you try to load your library you get back an error message that says &quot;mach-o, but wrong architecture&quot; then you might need to add command-line options &quot;-arch i386&quot; or &quot;arch x86_64&quot; to gcc, depending on how your application is built.</source>
          <target state="translated">如果当你试图加载你的库时,你得到的错误信息是 &quot;mach-o,但架构错误&quot;,那么你可能需要在gcc中添加命令行选项&quot;-arch i386 &quot;或 &quot;arch x86_64&quot;,这取决于你的应用程序是如何构建的。</target>
        </trans-unit>
        <trans-unit id="7cf9b897ab48ed18b82e59ac2a561abc36b27d81" translate="yes" xml:space="preserve">
          <source>If while attempting to detect a</source>
          <target state="translated">如果在试图检测一个</target>
        </trans-unit>
        <trans-unit id="56ea56ee57997f44a3b4181f1b3a8efe3168e325" translate="yes" xml:space="preserve">
          <source>If xBestIndex returns &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, that does not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular combination of input parameters specified should not be used in the query plan. The SQLITE_CONSTRAINT return is useful for &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that have required parameters. If the aConstraint[].usable field is false for one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.</source>
          <target state="translated">如果xBestIndex返回&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，则不表示错误。而是，SQLITE_CONSTRAINT指示在查询计划中不应使用指定的输入参数的特定组合。 SQLITE_CONSTRAINT返回对于具有必需参数的&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;很有用。如果aConstraint []。usable字段的必需参数之一为false，则xBestIndex方法应返回SQLITE_CONSTRAINT。</target>
        </trans-unit>
        <trans-unit id="f2ddd15ff69a5ac03ff2cdad02ade0037f75db16" translate="yes" xml:space="preserve">
          <source>If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.</source>
          <target state="translated">如果xRead()返回SQLITE_IOERR_SHORT_READ,它还必须用零填充缓冲区的未读部分。一个未能将短读填充为零的VFS看起来似乎是可行的,但如果未能将短读填充为零,最终会导致SQLITE_IOERR_SHORT_READ的未读部分。然而,未能零填充短读将最终导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="4c77d01ec7cf778a68ddf7a39c6762175e2b9a47" translate="yes" xml:space="preserve">
          <source>If you abuse the library by trying to call &lt;b&gt;sqlite_step&lt;/b&gt; inappropriately it will attempt return SQLITE_MISUSE. This can happen if you call sqlite_step() on the same virtual machine at the same time from two or more threads or if you call sqlite_step() again after it returned SQLITE_DONE or SQLITE_ERROR or if you pass in an invalid virtual machine pointer to sqlite_step(). You should not depend on the SQLITE_MISUSE return code to indicate an error. It is possible that a misuse of the interface will go undetected and result in a program crash. The SQLITE_MISUSE is intended as a debugging aid only - to help you detect incorrect usage prior to a mishap. The misuse detection logic is not guaranteed to work in every case.</source>
          <target state="translated">如果您试图通过不适当地调用&lt;b&gt;sqlite_step&lt;/b&gt;来滥用该库，它将尝试返回SQLITE_MISUSE。如果您同时从两个或多个线程在同一虚拟机上调用sqlite_step（），或者在返回SQLITE_DONE或SQLITE_ERROR后再次调用sqlite_step（），或者将无效的虚拟机指针传递给sqlite_step（），则会发生这种情况。 ）。您不应该依赖SQLITE_MISUSE返回代码来指示错误。接口的滥用可能会被发现并导致程序崩溃。 SQLITE_MISUSE仅用作调试帮助-帮助您在发生意外之前检测到不正确的用法。不能保证滥用检测逻辑在每种情况下都能正常工作。</target>
        </trans-unit>
        <trans-unit id="873a7faf9a3abe0d1c1b374fb25f49d1d975c393" translate="yes" xml:space="preserve">
          <source>If you append the character '*' to the end of the pattern, then a prefix search is performed. For example:</source>
          <target state="translated">如果你在模式的末尾添加字符'*',那么就会执行前缀搜索。例如:</target>
        </trans-unit>
        <trans-unit id="feb267998fb090ad7c9de72555f7d36aa562a1a7" translate="yes" xml:space="preserve">
          <source>If you are a &quot;rustacean&quot; and feel that Rust already meets the preconditions listed above, and that SQLite should be recoded in Rust, then you are welcomed and encouraged to contact the SQLite developers privately and argue your case.</source>
          <target state="translated">如果你是一个 &quot;rustacean&quot;,觉得Rust已经满足了上述前提条件,而SQLite应该用Rust重新编码,那么欢迎并鼓励你私下联系SQLite开发者,论证你的理由。</target>
        </trans-unit>
        <trans-unit id="abe76df81a0ba114f6ec2f514aa5a8bd31614980" translate="yes" xml:space="preserve">
          <source>If you are a devoted Git user, you can still easily access SQLite. This section gives some hints on how to do so.</source>
          <target state="translated">如果你是一个忠实的 Git 用户,你仍然可以轻松地访问 SQLite。本节将给出一些关于如何访问的提示。</target>
        </trans-unit>
        <trans-unit id="b343ba4a7d7f527696dab2d0f4840db430c944d2" translate="yes" xml:space="preserve">
          <source>If you are an SQLite user whose has stumbled over some quirk of SQLite that is not mentioned here, please send us an email so that we can document the problem.</source>
          <target state="translated">如果你是一个SQLite用户,在这里没有提到SQLite的一些怪癖,请给我们发邮件,以便我们记录问题。</target>
        </trans-unit>
        <trans-unit id="5de71147613f21cf2bdcb3bcc197abf7747cdeb4" translate="yes" xml:space="preserve">
          <source>If you are using separate source files, name all of the source files instead of just the two amalgamation source files. Once this is done, commit your changes as follows:</source>
          <target state="translated">如果你使用的是单独的源文件,请命名所有的源文件,而不是只命名两个合并源文件。完成后,提交你的修改如下。</target>
        </trans-unit>
        <trans-unit id="4850a90372994c2a6bc8e2907d79c1145e74bbe1" translate="yes" xml:space="preserve">
          <source>If you delete a lot of data and want to shrink the database file, run the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. VACUUM will reconstruct the database from scratch. This will leave the database with an empty free-list and a file that is minimal in size. Note, however, that the VACUUM can take some time to run and it can use up to twice as much temporary disk space as the original file while it is running.</source>
          <target state="translated">如果删除大量数据并希望收缩数据库文件，请运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令。 VACUUM将从头开始重建数据库。这将使数据库具有一个空的空闲列表和一个最小的文件。但是请注意，VACUUM可能需要花费一些时间才能运行，并且其临时磁盘空间最多可以运行时为原始文件的两倍。</target>
        </trans-unit>
        <trans-unit id="5f248ef1c5726530e6b14bd3353f02b25fd1dbc4" translate="yes" xml:space="preserve">
          <source>If you delete the</source>
          <target state="translated">如果您删除了</target>
        </trans-unit>
        <trans-unit id="45dba72fc49e11d88cfbda6839af5580be8953a7" translate="yes" xml:space="preserve">
          <source>If you do not have a backup, recovery is very difficult. You might be able to find partial string data in a binary dump of the raw database file. Recovering numeric data might also be possible given special tools, though to our knowledge no such tools exist. SQLite is sometimes compiled with the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; option which overwrites all deleted content with zeros. If that is the case then recovery is clearly impossible. Recovery is also impossible if you have run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has not been run, then some of the deleted content might still be in the database file, in areas marked for reuse. But, again, there exist no procedures or tools that we know of to help you recover that data.</source>
          <target state="translated">如果没有备份，恢复将非常困难。您可能能够在原始数据库文件的二进制转储中找到部分字符串数据。使用特殊工具也可以恢复数字数据，尽管据我们所知，尚无此类工具。有时使用&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt;选项编译SQLite，该选项将用零覆盖所有已删除的内容。如果真是这样，那么恢复显然是不可能的。如果由于删除了数据而运行了&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM，&lt;/a&gt;则恢复也是不可能的。如果未使用SQLITE_SECURE_DELETE并且尚未运行VACUUM，则某些已删除的内容可能仍在数据库文件的标记为可重复使用的区域中。但是，同样，我们不知道可以帮助您恢复数据的过程或工具。</target>
        </trans-unit>
        <trans-unit id="6123d0cbcd49adc87278ebf33c0308d19e13c18e" translate="yes" xml:space="preserve">
          <source>If you do not want to use your web browser to view the new check-in, you can get some information from the command-line using commands like these:</source>
          <target state="translated">如果你不想使用网页浏览器查看新的签到,你可以使用这些命令从命令行获得一些信息。</target>
        </trans-unit>
        <trans-unit id="c8e5a488a0f9459d060660cf0d22bea3c48ed8ca" translate="yes" xml:space="preserve">
          <source>If you feel that you need dynamic pointer type strings in your application, that is a strong indicator that you are misusing the pointer-passing interface. Your intended use may be unsafe. Please rethink your design. Determine if you really need to be passing pointers through SQL in the first place. Or perhaps find a different mechanism other than the pointer-passing interfaces described by this article.</source>
          <target state="translated">如果你觉得在你的应用程序中需要动态指针类型的字符串,那就说明你误用了指针传递接口。你的预期使用可能是不安全的。请重新考虑你的设计。首先确定你是否真的需要通过SQL传递指针。或者,除了本文描述的指针传递接口之外,也许还可以找到一种不同的机制。</target>
        </trans-unit>
        <trans-unit id="88a9f11dc162c0fbb6ecd06e339a9fb7195e5fab" translate="yes" xml:space="preserve">
          <source>If you find errors in either the documentation or the code, feel free to fix them and/or contact the author at &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;. Your bug fixes or suggestions are always welcomed.</source>
          <target state="translated">如果您在文档或代码中发现错误，请随时进行修复和/或通过&lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;与作者联系。我们始终欢迎您修复错误或提出建议。</target>
        </trans-unit>
        <trans-unit id="888116b604c695e34258cc3ceb95b003a7ab4815" translate="yes" xml:space="preserve">
          <source>If you have a backup copy of your database file, recover the information from your backup.</source>
          <target state="translated">如果您有数据库文件的备份副本,请从备份中恢复信息。</target>
        </trans-unit>
        <trans-unit id="882c38087164067f62c9c7b1c8a9cb99d1dcf2ef" translate="yes" xml:space="preserve">
          <source>If you have a database of large BLOBs, do you get better read performance when you store the complete BLOB content directly in the database or is it faster to store each BLOB in a separate file and store just the corresponding filename in the database?</source>
          <target state="translated">如果你有一个大型BLOB的数据库,如果直接将完整的BLOB内容存储在数据库中,是否能获得更好的读取性能,还是将每个BLOB存储在一个单独的文件中,只将相应的文件名存储在数据库中更快?</target>
        </trans-unit>
        <trans-unit id="763f3c8f82a8dbfe2292008ca244c1681fbd52b1" translate="yes" xml:space="preserve">
          <source>If you have a script and you want to start debugging at some point half-way through that script, simply set a breakpoint in gdb (or whatever debugger you are using) on the test_breakpoint() function, and add a &quot;.breakpoint&quot; command where you want to stop. When you reach that first breakpoint, set whatever additional breakpoints are variable traces you need.</source>
          <target state="translated">如果你有一个脚本,并且你想在该脚本中途的某个点开始调试,只需在gdb(或任何你正在使用的调试器)中对test_breakpoint()函数设置一个断点,并在你想停止的地方添加一个&quot;.breakpoint &quot;命令。当你到达第一个断点时,设置任何额外的断点都是你需要的变量痕迹。</target>
        </trans-unit>
        <trans-unit id="a1693c0c5d23752d02c6e3b93f043c8eb31a26df" translate="yes" xml:space="preserve">
          <source>If you have done any assembly language programming or have worked with any kind of abstract machine before, all of these details should be familiar to you. So let's jump right in and start looking as some code.</source>
          <target state="translated">如果你做过任何汇编语言编程,或者以前用过任何一种抽象机,这些细节你应该都很熟悉。所以让我们直接跳进去,开始看作为一些代码。</target>
        </trans-unit>
        <trans-unit id="ec726a0b109ca2b2f984dbfe63a95238609005d5" translate="yes" xml:space="preserve">
          <source>If you intend to use this virtual table in cooperation with an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table (for spelling correction of search terms) then you might extract the vocabulary using an &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table:</source>
          <target state="translated">如果您打算将此虚拟表与&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;表配合使用（用于对搜索词进行拼写更正），则可以使用&lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt;表提取词汇表：</target>
        </trans-unit>
        <trans-unit id="20f09458f074cbdfa69a4cd879b9a24a9c5ffaed" translate="yes" xml:space="preserve">
          <source>If you made NL to CR-NL line ending changes or space to tab indentation changes in the original baseline, make the same changes to the new source file.</source>
          <target state="translated">如果您在原始基线中进行了 NL 到 CR-NL 行结束的更改或空格到制表符缩进的更改,请对新的源文件进行同样的更改。</target>
        </trans-unit>
        <trans-unit id="5e4831ba155a21bf312a9328909ee6b27a5a08fb" translate="yes" xml:space="preserve">
          <source>If you need to verify that the SQLite source code that you have is authentic and has not been modified in any way (perhaps by an adversary) that can be done using a few simple command-line tools. At the root of the SQLite source tree is a file named &quot;manifest&quot;. The manifest file contains the name of every other file in the source tree together with either a SHA1 or SHA3-256 hash for that file. (SHA1 is used for older files and SHA3-256 for newer files.) You can write a script to extract these hashes and verify them against the source code files. The hash name for the check-in is just the SHA3-256 hash of the &quot;manifest&quot; file itself.</source>
          <target state="translated">如果你需要验证你所拥有的SQLite源代码是真实的,并且没有被以任何方式修改过(也许是被对手修改过),可以使用一些简单的命令行工具来完成。在SQLite源码树的根部有一个名为 &quot;manifest &quot;的文件。manifest文件包含了源树中每一个其他文件的名称,以及该文件的SHA1或SHA3-256哈希值。(SHA1用于旧文件,SHA3-256用于新文件。)你可以写一个脚本来提取这些哈希值,并对照源代码文件进行验证。签入的哈希名只是 &quot;manifest &quot;文件本身的SHA3-256哈希。</target>
        </trans-unit>
        <trans-unit id="397118cfe02899896d93de7bdac7c4252da15fbe" translate="yes" xml:space="preserve">
          <source>If you really need to update an R-Tree based on complex queries against the same R-Tree, it is best to run the complex queries first and store the results in a temporary table, then update the R-Tree based on the values stored in the temporary table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13da8fa523e1031c91ec41d25db356602a2c65ba" translate="yes" xml:space="preserve">
          <source>If you specify a column a width of 0, then the column width is automatically adjusted to be the maximum of three numbers: 10, the width of the header, and the width of the first row of data. This makes the column width self-adjusting. The default width setting for every column is this auto-adjusting 0 value.</source>
          <target state="translated">如果你指定一个列的宽度为0,那么列的宽度会自动调整为三个数字的最大值。10,页眉的宽度,和第一行数据的宽度.这使得列的宽度可以自我调整。每一列的默认宽度设置就是这个自动调整的0值。</target>
        </trans-unit>
        <trans-unit id="473942d6eb4b318988fc65567c504fbaea4558ae" translate="yes" xml:space="preserve">
          <source>If you use version 2.6.0 or later of the library to open a database file that was originally created by version 2.5.6 or earlier, an attempt to rebuild the database into the new format will occur automatically. This can take some time for a large database. (Allow 1 or 2 seconds per megabyte of database under Unix - longer under Windows.) This format conversion is irreversible. It is &lt;strong&gt;strongly&lt;/strong&gt; suggested that you make a backup copy of older database files prior to opening them with version 2.6.0 or later of the library, in case there are errors in the format conversion logic.</source>
          <target state="translated">如果您使用库的2.6.0或更高版本来打开最初由2.5.6或更早版本创建的数据库文件，则将自动尝试将数据库重建为新格式。对于大型数据库，这可能需要一些时间。 （在Unix下，每兆字节数据库允许1或2秒-在Windows下，更长的时间。）这种格式转换是不可逆的。这是&lt;strong&gt;强烈&lt;/strong&gt;建议您使用2.6.0或更高版本的库打开它们使旧的数据库文件备份副本之前，万一有格式转换的逻辑错误。</target>
        </trans-unit>
        <trans-unit id="57f756e359121a9c945b91158a295a20dd82b0db" translate="yes" xml:space="preserve">
          <source>If you want to configure the new project, type:</source>
          <target state="translated">如果你想配置新的项目,请键入。</target>
        </trans-unit>
        <trans-unit id="bda3419a07a7eb3933cb5a599b2b66398d9d3b26" translate="yes" xml:space="preserve">
          <source>If you want to know how the SQLite library works internally, you need to begin with a solid understanding of the Virtual Database Engine or VDBE. The VDBE occurs right in the middle of the processing stream (see the &lt;a href=&quot;arch&quot;&gt;architecture diagram&lt;/a&gt;) and so it seems to touch most parts of the library. Even parts of the code that do not directly interact with the VDBE are usually in a supporting role. The VDBE really is the heart of SQLite.</source>
          <target state="translated">如果您想了解SQLite库在内部的工作方式，则需要对虚拟数据库引擎或VDBE有深入的了解。 VDBE恰好出现在处理流的中间（请参阅&lt;a href=&quot;arch&quot;&gt;体系结构图&lt;/a&gt;），因此它似乎触及了库的大部分。甚至不直接与VDBE交互的部分代码也通常起辅助作用。 VDBE确实是SQLite的心脏。</target>
        </trans-unit>
        <trans-unit id="45ef57f77f1b898b089bfb8776638647a0457adc" translate="yes" xml:space="preserve">
          <source>If you want to use a keyword as a name, you need to quote it. There are four ways of quoting keywords in SQLite:</source>
          <target state="translated">如果你想使用关键字作为名称,你需要引用它。在SQLite中,有四种引用关键字的方式。</target>
        </trans-unit>
        <trans-unit id="33c132e45cdeb83d38d9892ca9d1c9494534573d" translate="yes" xml:space="preserve">
          <source>If you will be opening multiple database connections in your application, rather than invoking the extension entry points for each database connection separately, you might want to consider using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions and to cause them to be automatically started as each database connection is opened. You only have to register each extension once, and you can do so near the beginning of your main() routine. Using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions makes your extensions work as if they were built into the core SQLite - they automatically exist whenever you open a new database connection without needing to be initialized. Just be sure to complete any configuration you need to accomplish using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; before registering your extensions, since the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface implicitly calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">如果要在应用程序中打开多个数据库连接，而不是分别为每个数据库连接调用扩展入口点，则可能要考虑使用&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;接口注册扩展，并使每个扩展自动启动。数据库连接已打开。您只需注册每个扩展名一次，并且可以在main（）例程的开头附近进行注册。使用&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;接口注册您的扩展名可使您的扩展名像内置在核心SQLite中一样工作-每当您打开新的数据库连接而无需初始化时，它们便自动存在。只要确保完成您需要使用完成的任何配置&lt;a href=&quot;c3ref/config&quot;&gt;&lt;/a&gt;在注册扩展之前，请先使用sqlite3_config（），因为&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;接口隐式调用了&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2a19b719f76f7faa9b10e93907a0fe776f85db7" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 140 terabytes in size, assuming you can find a disk drive and filesystem that will support 140-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">如果你的数据会增长到你不习惯或无法装入一个磁盘文件的大小,那么你应该选择SQLite以外的解决方案。SQLite支持大小高达140TB的数据库,假设你能找到一个能支持140TB文件的磁盘驱动器和文件系统。即便如此,当内容的大小看起来可能会爬到TB范围内时,最好考虑集中式客户/服务器数据库。</target>
        </trans-unit>
        <trans-unit id="22b27cadfcf6135e72ec61c4781266a907795c13" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 281 terabytes in size, assuming you can find a disk drive and filesystem that will support 281-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bce6edf7a889c813c03d5b445472e1ddc49ad2" translate="yes" xml:space="preserve">
          <source>If your system defines a custom OS interface for SQLite or if you were using the undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface, then you will need to make modifications in order to upgrade to SQLite version 3.5.0. This may seem painful at first glance. But as you look more closely, you will probably discover that your changes are made smaller and easier to understand and manage by the new SQLite interface. It is likely that your changes will now also work seamlessly with the SQLite amalgamation. You will no longer need to make any changes to the code SQLite source code. All of your changes can be effected by application code and you can link against a standard, unmodified version of the SQLite amalgamation. Furthermore, the OS interface layer, which was formerly undocumented, is now an officially support interface for SQLite. So you have some assurance that this will be a one-time change and that your new backend will continue to work in future versions of SQLite.</source>
          <target state="translated">如果您的系统为SQLite定义了自定义OS接口，或者您使用的是未&lt;b&gt;公开的sqlite3_os_switch（）&lt;/b&gt;界面，则需要进行修改才能升级到SQLite 3.5.0版。乍看起来，这似乎很痛苦。但是当您仔细观察时，您可能会发现新的SQLite界面使更改变得更小，更易于理解和管理。您的更改现在很可能也可以与SQLite合并无缝地协同工作。您将不再需要对代码SQLite源代码进行任何更改。您的所有更改都可以由应用程序代码来实现，并且可以链接到标准的，未修改的SQLite合并版本。此外，以前未记录的OS接口层现在已成为SQLite的官方支持接口。因此，您可以确保这将是一次更改，并且您的新后端将继续在将来的SQLite版本中使用。</target>
        </trans-unit>
        <trans-unit id="4d01491e7aaf0e3b7eeb3d6755bf0ba092a441ec" translate="yes" xml:space="preserve">
          <source>If zipfile() is invoked with 2 arguments, then the entry added to the archive is equivalent to that added by inserting the same two values into the &quot;name&quot; and &quot;data&quot; columns of a zipfile virtual table, with all other values set to NULL. If invoked with 4 arguments, it is equivalent to inserting the 4 values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot; and &quot;data&quot; columns. In other words, the following pairs of queries are equivalent:</source>
          <target state="translated">如果调用zipfile()时有2个参数,那么添加到档案中的条目就相当于在zipfile虚拟表中的 &quot;name &quot;和 &quot;data &quot;列中插入相同的两个值,其他值都设置为NULL。如果调用4个参数,相当于在 &quot;name&quot;、&quot;mode&quot;、&quot;mtime &quot;和 &quot;data &quot;列中插入4个值。换句话说,下面的一对查询是等价的。</target>
        </trans-unit>
        <trans-unit id="d49c9a42ebbe9cba3927bb51a35d92fe353713e9" translate="yes" xml:space="preserve">
          <source>If, as part of the</source>
          <target state="translated">如果,作为</target>
        </trans-unit>
        <trans-unit id="1b931ae5cbce5d6c96daf33260c2b72ee5539dbd" translate="yes" xml:space="preserve">
          <source>If, while opening a</source>
          <target state="translated">如果在打开一个</target>
        </trans-unit>
        <trans-unit id="f48c9c6740ea7cbd9ee32d778ecff2f9da591ab1" translate="yes" xml:space="preserve">
          <source>IfNoHope</source>
          <target state="translated">IfNoHope</target>
        </trans-unit>
        <trans-unit id="0d430ae72e07c71cbfc6aac6b856ba69c4a14902" translate="yes" xml:space="preserve">
          <source>IfNot</source>
          <target state="translated">IfNot</target>
        </trans-unit>
        <trans-unit id="f975ef3b4d80471cd49ea9ce8bd7a669078224d8" translate="yes" xml:space="preserve">
          <source>IfNotOpen</source>
          <target state="translated">IfNotOpen</target>
        </trans-unit>
        <trans-unit id="d2a091305f84e463b224fd2549c504926b658103" translate="yes" xml:space="preserve">
          <source>IfNotZero</source>
          <target state="translated">IfNotZero</target>
        </trans-unit>
        <trans-unit id="8ea5813d833284a6b426730c347d4a031b76be44" translate="yes" xml:space="preserve">
          <source>IfNullRow</source>
          <target state="translated">IfNullRow</target>
        </trans-unit>
        <trans-unit id="7661d111573d853c18bf38582f4762e932f703e7" translate="yes" xml:space="preserve">
          <source>IfPos</source>
          <target state="translated">IfPos</target>
        </trans-unit>
        <trans-unit id="a6bb95ea00b2b20f56a2debeb7afeb897471ef50" translate="yes" xml:space="preserve">
          <source>IfSmaller</source>
          <target state="translated">IfSmaller</target>
        </trans-unit>
        <trans-unit id="91d8cebb7b70f29e3262ce44bfc944c449089a8d" translate="yes" xml:space="preserve">
          <source>Ignore extra whitespace at the end of of &quot;.&quot; commands in the shell.</source>
          <target state="translated">忽略shell中&quot;.&quot;命令末尾的多余空格。</target>
        </trans-unit>
        <trans-unit id="d609bda3312485a36bcab24d9a33ae880a4d9c03" translate="yes" xml:space="preserve">
          <source>Immediately after an iterator is created by sqlite3changeset_start(), it does not point to any change in the changeset. Assuming the changeset is not empty, the first call to this function advances the iterator to point to the first change in the changeset. Each subsequent call advances the iterator to point to the next change in the changeset (if any). If no error occurs and the iterator points to a valid change after a call to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. Otherwise, if all changes in the changeset have already been visited, SQLITE_DONE is returned.</source>
          <target state="translated">当一个迭代器被sqlite3changeset_start()创建后,它不会立即指向变化集中的任何变化。假设变化集不是空的,对这个函数的第一次调用将迭代器推进到指向变化集的第一个变化。随后的每一次调用都将迭代器推进到变化集中的下一个变化(如果有的话)。如果没有发生错误,并且在调用 sqlite3changeset_next()后迭代器指向一个有效的变化,则返回 SQLITE_ROW。否则,如果变化集中的所有变化都已经被访问,则返回SQLITE_DONE。</target>
        </trans-unit>
        <trans-unit id="49deaa07b4de652a28623d07d5618cb8f1e55666" translate="yes" xml:space="preserve">
          <source>Immediately following the wal-header are zero or more frames. Each frame consists of a 24-byte frame-header followed by a</source>
          <target state="translated">紧接在 wal-header 之后的是零个或多个帧。每个帧由一个24字节的帧头组成,后面是一个</target>
        </trans-unit>
        <trans-unit id="efc77ef3528cb380e78002c642146ddfcb72a6c8" translate="yes" xml:space="preserve">
          <source>Implement a procedure that calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and passes it a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure from the previous step. This procedure is probably the only exported symbol in the source file that implements your VFS.</source>
          <target state="translated">实现一个过程，该过程调用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;并将其指针传递给上一步中的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;结构。此过程可能是实现VFS的源文件中唯一导出的符号。</target>
        </trans-unit>
        <trans-unit id="5f991f27713d088110dc4560a5b48613a2e55fa7" translate="yes" xml:space="preserve">
          <source>Implement the &quot;LIMIT ... OFFSET ...&quot; clause on SELECT statements.</source>
          <target state="translated">在SELECT语句上实现 &quot;LIMIT ...OFFSET ...&quot;子句。</target>
        </trans-unit>
        <trans-unit id="cb1780300fa34dfe12b3de8afb5a8d426d248748" translate="yes" xml:space="preserve">
          <source>Implement the methods required by the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">实现&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象所需的方法。</target>
        </trans-unit>
        <trans-unit id="edbf1d07115719c5c7e93d86f1046b341948dbde" translate="yes" xml:space="preserve">
          <source>Implement the other methods required by &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;所需的其他方法。</target>
        </trans-unit>
        <trans-unit id="a8b02a72a8b5be24e42656704837d215920a00aa" translate="yes" xml:space="preserve">
          <source>Implement the xOpen method that opens a file and populates an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object, including setting pMethods to point to the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object from the previous step.</source>
          <target state="translated">实现xOpen方法，该方法打开文件并填充&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象，包括将pMethods设置为指向上一步中的&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="87cdff8728ab99514f76ab384b99b3f529310cf0" translate="yes" xml:space="preserve">
          <source>Implementation Limits For SQLite</source>
          <target state="translated">SQLite的实现限制</target>
        </trans-unit>
        <trans-unit id="32808d9f543dc0758af6de0786717c61ede1f9c3" translate="yes" xml:space="preserve">
          <source>Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.</source>
          <target state="translated">聚合SQL函数的实现使用这个例程来分配内存来存储它们的状态。</target>
        </trans-unit>
        <trans-unit id="7165ad4b3d6ce30cae4f1408c3a0f8924f93a699" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;appfunc&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4018bcd662e8105cb957cfc5a507fd128f58cc71" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;c3ref/create_function&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">实现自定义辅助功能类似于实现&lt;a href=&quot;c3ref/create_function&quot;&gt;标量SQL函数&lt;/a&gt;。实现应为fts5_extension_function类型的C函数，定义如下：</target>
        </trans-unit>
        <trans-unit id="cf816f713b7837e18241382d77dfd40a1b6bacf3" translate="yes" xml:space="preserve">
          <source>Implicit versus explicit transactions</source>
          <target state="translated">隐性交易与显性交易</target>
        </trans-unit>
        <trans-unit id="2f1059e48758f0fdc4ddd1f86b6fae46066d008b" translate="yes" xml:space="preserve">
          <source>Important bug fix: the IN operator was not working if either the left-hand or right-hand side was derived from an INTEGER PRIMARY KEY.</source>
          <target state="translated">重要的bug修复:如果左手或右手是由INTEGER PRIMARY KEY派生出来的,IN操作符就无法使用。</target>
        </trans-unit>
        <trans-unit id="a0fe78ecda103e8930771647f6dec46b0b349000" translate="yes" xml:space="preserve">
          <source>Impose A Limit On Heap Size</source>
          <target state="translated">限制堆的大小</target>
        </trans-unit>
        <trans-unit id="ed65a595437d44d40ac23326bd1b47c2bed21cbd" translate="yes" xml:space="preserve">
          <source>Imposter Tables</source>
          <target state="translated">冒名顶替表</target>
        </trans-unit>
        <trans-unit id="8bd676db829fa1254e9904aed550e4eaa10267fe" translate="yes" xml:space="preserve">
          <source>Imposter tables are intended for analysis and debugging only. This is not a feature that most application developers should understand or even know about. Imposter tables are for experts only.</source>
          <target state="translated">冒牌表仅用于分析和调试。这不是大多数应用程序开发人员应该理解或甚至知道的功能。冒牌表只适合专家使用。</target>
        </trans-unit>
        <trans-unit id="310974bd6288a19d56c62511f50674a5f6b79b46" translate="yes" xml:space="preserve">
          <source>Improper use of imposter tables can cause index corruption, though any corruption created this way can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">不正确使用冒名顶替表可能会导致索引损坏，尽管可以通过运行&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;来解决以这种方式创建的任何损坏。</target>
        </trans-unit>
        <trans-unit id="7cc4395a9bbe14f613da8e2834455cc8120ab269" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;omit-left-join optimization&lt;/a&gt; so that it works in cases where the right-hand table is UNIQUE but not necessarily NOT NULL.</source>
          <target state="translated">改进&lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;省略左连接优化&lt;/a&gt;，以使其在右侧表为UNIQUE但不一定为NOT NULL的情况下起作用。</target>
        </trans-unit>
        <trans-unit id="15dafad2713cbb23a2ff9f35c0397160bab08c72" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#pushdown&quot;&gt;push-down optimization&lt;/a&gt; so that it works for many LEFT JOINs.</source>
          <target state="translated">改进&lt;a href=&quot;optoverview#pushdown&quot;&gt;下推优化&lt;/a&gt;，使其适用于许多LEFT JOIN。</target>
        </trans-unit>
        <trans-unit id="115d57ca1c0c67b9c62b8627805bc54cd437ed61" translate="yes" xml:space="preserve">
          <source>Improve the format of the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; raw output, so that it gives better information about the query plan and about the relationships between the various components of the plan.</source>
          <target state="translated">改进&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;原始输出的格式，以便它提供有关查询计划以及计划中各个组件之间的关系的更好信息。</target>
        </trans-unit>
        <trans-unit id="14bd38dceda1ed2c01f162d1f3444a0f4f8b3ecd" translate="yes" xml:space="preserve">
          <source>Improve the performance of fts3/4 queries that use the OR operator and at least one auxiliary fts function.</source>
          <target state="translated">提高使用OR运算符和至少一个辅助fts函数的fts3/4查询的性能。</target>
        </trans-unit>
        <trans-unit id="b9c8f318457693f2fa88c903d8d43102377e8c69" translate="yes" xml:space="preserve">
          <source>Improve the performance of the &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace() SQL function&lt;/a&gt; for cases where there are many substitutions on megabyte-sized strings, in an attempt to avoid OSSFuzz timeouts during testing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</source>
          <target state="translated">在兆字节大小的字符串上存在许多替换的情况下，请提高&lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace（）SQL函数&lt;/a&gt;的性能，以免在测试期间出现OSSFuzz超时。登机&lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ed5007819cc6bdecc581d33162266f7dd3fe7" translate="yes" xml:space="preserve">
          <source>Improved Concurrency</source>
          <target state="translated">改进的并发性</target>
        </trans-unit>
        <trans-unit id="072e9878a7002455b6aee44f48f435995e934eb5" translate="yes" xml:space="preserve">
          <source>Improved Concurrency.</source>
          <target state="translated">改善并发症。</target>
        </trans-unit>
        <trans-unit id="fd596055fe2374f07cb22e2ed1eddaf72d523d42" translate="yes" xml:space="preserve">
          <source>Improved accuracy of floating-point conversions using &quot;long double&quot;.</source>
          <target state="translated">使用 &quot;长双 &quot;提高浮点转换的准确性。</target>
        </trans-unit>
        <trans-unit id="93fc56155be2598f9cbcf49e841b4a0140cf2c72" translate="yes" xml:space="preserve">
          <source>Improved algorithm for running queries with both an ORDER BY and a LIMIT where only the inner-most loop naturally generates rows in the correct order.</source>
          <target state="translated">改进了运行ORDER BY和LIMIT查询的算法,其中只有最里面的循环自然而然地以正确的顺序生成行。</target>
        </trans-unit>
        <trans-unit id="b070ecb9dcd3bd88a65a96d0f66e5d97c46345dc" translate="yes" xml:space="preserve">
          <source>Improved concurrency.</source>
          <target state="translated">改善并发症。</target>
        </trans-unit>
        <trans-unit id="9f23829b58c284f668ccf3661f99fc3dbbec1e58" translate="yes" xml:space="preserve">
          <source>Improved crash-robustness: write the database page size into the rollback journal header.</source>
          <target state="translated">改进的崩溃性:将数据库页面大小写入回滚日志头。</target>
        </trans-unit>
        <trans-unit id="7321289816f2bf6478248e1de203f755159291e2" translate="yes" xml:space="preserve">
          <source>Improved de-quoting of column names for &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; statements with an aggregate query on the right-hand side.</source>
          <target state="translated">改进了&lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt;语句的列名的去引用，并在右侧具有聚合查询。</target>
        </trans-unit>
        <trans-unit id="bf0fc640800a9514f6d8718203e257a7690d605b" translate="yes" xml:space="preserve">
          <source>Improved error detection of misused aggregate functions.</source>
          <target state="translated">改进对误用集合函数的错误检测。</target>
        </trans-unit>
        <trans-unit id="10bc21bc5dd5e57a67add58ea3202819c9a3c931" translate="yes" xml:space="preserve">
          <source>Improved error messages for &quot;foreign key mismatch&quot; showing the names of the two tables involved.</source>
          <target state="translated">改进了 &quot;外键不匹配 &quot;的错误信息,显示了相关两个表的名称。</target>
        </trans-unit>
        <trans-unit id="90dbb37d863c75537960cc5646693be15d517e85" translate="yes" xml:space="preserve">
          <source>Improved error messages for invalid boolean arguments to dot-commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">改进了针对&lt;a href=&quot;cli&quot;&gt;命令行shell&lt;/a&gt;中点命令的布尔值无效布尔参数的错误消息。</target>
        </trans-unit>
        <trans-unit id="b0dec14662a3a9f70430b0cb1619e2a60b783318" translate="yes" xml:space="preserve">
          <source>Improved error messages in the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension.</source>
          <target state="translated">改进了&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;扩展中的错误消息。</target>
        </trans-unit>
        <trans-unit id="2c62ff1f4b8293cf16ee945ea648937c03b9bc58" translate="yes" xml:space="preserve">
          <source>Improved fuzz-testing of database files, with fixes for problems found.</source>
          <target state="translated">改进了数据库文件的模糊测试,并对发现的问题进行了修复。</target>
        </trans-unit>
        <trans-unit id="26cc1d230c175a8810d6dd909c46be8d110c203b" translate="yes" xml:space="preserve">
          <source>Improved name resolution for deeply nested queries.</source>
          <target state="translated">改进了深度嵌套查询的名称解析。</target>
        </trans-unit>
        <trans-unit id="d3565d7b7ed6ef82845a8772788a705a908dc7c3" translate="yes" xml:space="preserve">
          <source>Improved optimization of &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; operators.</source>
          <target state="translated">改进了&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt;运算符的优化。</target>
        </trans-unit>
        <trans-unit id="a23eee66d3ed2b6341f9511337eea95095e21556" translate="yes" xml:space="preserve">
          <source>Improved optimization of AND and OR operators when one or the other operand is a constant.</source>
          <target state="translated">当一个或另一个操作数为常数时,改进了AND和OR操作数的优化。</target>
        </trans-unit>
        <trans-unit id="524c0e2c2353a4bf3f7178e269f56a6cac4ecf9b" translate="yes" xml:space="preserve">
          <source>Improved optimization of ORDER BY clauses on compound queries.</source>
          <target state="translated">改进对复合查询的ORDER BY子句的优化。</target>
        </trans-unit>
        <trans-unit id="af8c59932cd987b7607835b656e726f3dcea902b" translate="yes" xml:space="preserve">
          <source>Improved optimization of aggregate subqueries contained within an aggregate query.</source>
          <target state="translated">改进了对集合查询中包含的集合子查询的优化。</target>
        </trans-unit>
        <trans-unit id="d664cf7cb7a8aa891620cace778bbb7e18301125" translate="yes" xml:space="preserve">
          <source>Improved optimization of queries containing aggregate min() or max().</source>
          <target state="translated">改进了对包含集合min()或max()的查询的优化。</target>
        </trans-unit>
        <trans-unit id="aa1222b8dcd6d3acb1bb29b90eb9192b7d6106ad" translate="yes" xml:space="preserve">
          <source>Improved performance of queries like &quot;SELECT min(x) FROM t WHERE y IN (?,?,?)&quot; assuming an index on t(x,y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a557fad116fe49221d1a9424a92f1e575e49e1" translate="yes" xml:space="preserve">
          <source>Improved performance of queries with many OR-connected terms in the WHERE clause that can all be indexed.</source>
          <target state="translated">提高了在WHERE子句中有许多OR连接词的查询性能,这些词都可以被索引。</target>
        </trans-unit>
        <trans-unit id="fc268c97ccbef9521d6905694e7c21645578065f" translate="yes" xml:space="preserve">
          <source>Improved pthreads detection in configure scripts.</source>
          <target state="translated">改进了配置脚本中的pthreads检测。</target>
        </trans-unit>
        <trans-unit id="17ac50232b81e80729264e903268e1bebc9e53d7" translate="yes" xml:space="preserve">
          <source>Improved query plan optimization when the DISTINCT keyword is present.</source>
          <target state="translated">当存在DISTINCT关键字时,改进了查询计划优化。</target>
        </trans-unit>
        <trans-unit id="59b96d30821cc9cbdef8a394c82f7fd97d223fd7" translate="yes" xml:space="preserve">
          <source>Improved resistance against goofy query planner decisions caused by incomplete or incorrect modifications to the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; table by the application.</source>
          <target state="translated">改进了对应用程序对&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;表的不完整或不正确修改导致的愚蠢查询计划者决策的抵抗力。</target>
        </trans-unit>
        <trans-unit id="6b8ef39e97edafb5ec621a586930697f00cfaa0e" translate="yes" xml:space="preserve">
          <source>Improved response to out-of-memory errors</source>
          <target state="translated">改善对内存外错误的反应</target>
        </trans-unit>
        <trans-unit id="5ae15f37694ee149c6eea70b18fae46fd07528e4" translate="yes" xml:space="preserve">
          <source>Improved robustness against corrupt database files.</source>
          <target state="translated">提高了对数据库文件损坏的鲁棒性。</target>
        </trans-unit>
        <trans-unit id="166028811fd163330b2455278e9c44de42779fbe" translate="yes" xml:space="preserve">
          <source>Improved support for Cygwin.</source>
          <target state="translated">改进对Cygwin的支持。</target>
        </trans-unit>
        <trans-unit id="4c53e2cba5a1410927dfe514c0901b0fd71f140c" translate="yes" xml:space="preserve">
          <source>Improved support for using the STDCALL calling convention in winsqlite3.dll.</source>
          <target state="translated">改进了对winsqlite3.dll中STDCALL调用约定的支持。</target>
        </trans-unit>
        <trans-unit id="92763dc3583bdd282b9026c7f80e9e51775413fc" translate="yes" xml:space="preserve">
          <source>Improved syntax error messages in the parser</source>
          <target state="translated">改进了解析器中的语法错误信息。</target>
        </trans-unit>
        <trans-unit id="35f950df2561f1db8f684a7b33f41fde15c8c04c" translate="yes" xml:space="preserve">
          <source>Improved test coverage</source>
          <target state="translated">提高测试覆盖率</target>
        </trans-unit>
        <trans-unit id="6fb91ee1a232fc876617f991f25282c326c1cf11" translate="yes" xml:space="preserve">
          <source>Improved test coverage. Fixed a few obscure bugs found by the improved tests.</source>
          <target state="translated">提高了测试覆盖率。修正了改进后的测试所发现的一些不明显的错误。</target>
        </trans-unit>
        <trans-unit id="5177fb86b97cfe6466bc589640835c3dab84ade3" translate="yes" xml:space="preserve">
          <source>Improved the cost estimation for an index scan which includes a WHERE clause that can be partially or fully evaluated using columns in the index and without having to do a table lookup. This fixes a performance regression that occurred for some obscure queries following the ORDER BY LIMIT optimization introduced in &lt;a href=&quot;#version_3_12_0&quot;&gt;version 3.12.0&lt;/a&gt;.</source>
          <target state="translated">改进了包含WHERE子句的索引扫描的成本估算，该索引可以使用索引中的列进行部分或完全评估，而无需执行表查找。这修复了在&lt;a href=&quot;#version_3_12_0&quot;&gt;3.12.0版中&lt;/a&gt;引入的ORDER BY LIMIT优化之后某些晦涩的查询所发生的性能下降。</target>
        </trans-unit>
        <trans-unit id="9737446abc238ba64625d047b10e2ea194379924" translate="yes" xml:space="preserve">
          <source>Improved the query planner so that the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; can be used on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if one or more of the disjuncts use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operators.</source>
          <target state="translated">改进了查询计划程序，以便即使一个或多个析取项使用&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;，&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;，&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;，&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;运算符，也可以在&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;上使用&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c7991b90a25fa494ea7173ba16f41d0e843c78b" translate="yes" xml:space="preserve">
          <source>Improved the windows VFS to better defend against interference from anti-virus software.</source>
          <target state="translated">改进了windows VFS,更好地抵御反病毒软件的干扰。</target>
        </trans-unit>
        <trans-unit id="6c9542942225b685370a9ff791f1911ab55a40d4" translate="yes" xml:space="preserve">
          <source>Improved tracing and debugging facilities in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Windows &lt;a href=&quot;vfs&quot;&gt;VFS中&lt;/a&gt;改进的跟踪和调试功能。</target>
        </trans-unit>
        <trans-unit id="c1ee9a0442382c4cebcfe1b576c0d1fff396e4cb" translate="yes" xml:space="preserve">
          <source>Improved unicode filename handling in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on Windows.</source>
          <target state="translated">Windows &lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;改进的unicode文件名处理。</target>
        </trans-unit>
        <trans-unit id="09e6f225ca0ca885645a927e0763b14b484dc7f0" translate="yes" xml:space="preserve">
          <source>Improvements and bug-fixes in support for &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;.</source>
          <target state="translated">支持&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT的&lt;/a&gt;改进和错误修复。</target>
        </trans-unit>
        <trans-unit id="c4b534f7c6c26f504f16d9c38af50fef3ae45002" translate="yes" xml:space="preserve">
          <source>Improvements to &quot;dot-command&quot; handling in the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">改进了&lt;a href=&quot;cli&quot;&gt;命令行界面中&lt;/a&gt; &amp;ldquo;点命令&amp;rdquo;的处理。</target>
        </trans-unit>
        <trans-unit id="47099268e1cc1a7d37272d0a960d324c9d2e5b20" translate="yes" xml:space="preserve">
          <source>Improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">对&lt;a href=&quot;fts3&quot;&gt;FTS3的&lt;/a&gt;改进。</target>
        </trans-unit>
        <trans-unit id="18fe2fab208a9bdfd95bd5b0724b7f338ba76be8" translate="yes" xml:space="preserve">
          <source>Improvements to cost estimates for the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化的&lt;/a&gt;成本估算的改进。</target>
        </trans-unit>
        <trans-unit id="f56d95c4feb425fac688efbe211f20dca39f2585" translate="yes" xml:space="preserve">
          <source>Improvements to rounding behavior, so that the results of rounding binary numbers using the &lt;a href=&quot;lang_corefunc#round&quot;&gt;round()&lt;/a&gt; function are closer to what people who are used to thinking in decimal actually expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5353c2af79675cc29c5733088967c970c2cbd2d3" translate="yes" xml:space="preserve">
          <source>Improvements to test coverage, other minor bugs fixed, memory leaks plugged, code refactored and/or recommended in places for easier reading.</source>
          <target state="translated">改进了测试覆盖率,修复了其他小bug,堵住了内存泄漏,重构了代码和/或推荐的地方,方便阅读。</target>
        </trans-unit>
        <trans-unit id="1672d028ed8042c2cdc755bd4feb4bfb1a305542" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;.help&quot; command.</source>
          <target state="translated">改进&quot;.help &quot;命令。</target>
        </trans-unit>
        <trans-unit id="9829e00db8ef5babdf62ad53520c9aed14ba5d0e" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;PRAGMA integrity_check&quot; command</source>
          <target state="translated">改进 &quot;PRAGMA integrity_check &quot;命令。</target>
        </trans-unit>
        <trans-unit id="e5c25ee1584b55a6798dccb371f9de65d6e26320" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;命令行外壳的&lt;/a&gt;改进：</target>
        </trans-unit>
        <trans-unit id="7bd7a08c86f6e2927260bf75b7f206267bdb5a66" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt; in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it recovers more content from corrupt database files.</source>
          <target state="translated">改进了&lt;a href=&quot;cli&quot;&gt;CLI中&lt;/a&gt;的&lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt;，以便从损坏的数据库文件中恢复更多内容。</target>
        </trans-unit>
        <trans-unit id="56bedeb29e748e173925f592478fb7224bd2a9a7" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge command&lt;/a&gt; of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to better control the index size for a full-text index that is subject to a large number of updates.</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;的&lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge命令&lt;/a&gt;的改进，可以更好地控制全文索引的索引大小，该全文索引需要进行大量更新。</target>
        </trans-unit>
        <trans-unit id="4f8a0d7434e9fa0e3d93bd594ec2f731beeeee4c" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;:</source>
          <target state="translated">对&lt;a href=&quot;optoverview&quot;&gt;查询计划程序的&lt;/a&gt;改进：</target>
        </trans-unit>
        <trans-unit id="64a384308e143ce85fad7f48be7bf89bd88826a0" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax bubble diagrams&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;syntaxdiagrams&quot;&gt;语法气泡图的&lt;/a&gt;改进</target>
        </trans-unit>
        <trans-unit id="444f392b3ac06b6a270033461a34681437b33fc9" translate="yes" xml:space="preserve">
          <source>Improvements to the Makefiles and build scripts used by VisualStudio.</source>
          <target state="translated">改进VisualStudio使用的Makefile和构建脚本。</target>
        </trans-unit>
        <trans-unit id="187c307e740f14eb7715914261b63385a7891140" translate="yes" xml:space="preserve">
          <source>Improvements to the amalgamation generator script so that all symbols are prefixed with either SQLITE_PRIVATE or SQLITE_API.</source>
          <target state="translated">对合并生成器脚本进行了改进,使所有符号都以 SQLITE_PRIVATE 或 SQLITE_API 为前缀。</target>
        </trans-unit>
        <trans-unit id="8487f548381bd47de49bbe554c9e3c26fcef5a1f" translate="yes" xml:space="preserve">
          <source>Improvements to the comments in the VDBE byte-code display when running &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">运行&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;时，改进了VDBE字节码显示中的注释。</target>
        </trans-unit>
        <trans-unit id="e6a8494de38f18f2b5e148ff117a682e5366a648" translate="yes" xml:space="preserve">
          <source>Improvements to the effectiveness and accuracy of the &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; SQL hint functions.</source>
          <target state="translated">改进了SQL提示函数&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;似然（）&lt;/a&gt;，&lt;a href=&quot;lang_corefunc#likely&quot;&gt;可能性（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不太&lt;/a&gt;可能（）的有效性和准确性。</target>
        </trans-unit>
        <trans-unit id="fb078db70835b73a43d340944c34ddf931e04436" translate="yes" xml:space="preserve">
          <source>Improvements to the handling of CSV inputs in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">改进了&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;中CSV输入的处理</target>
        </trans-unit>
        <trans-unit id="35621122cb25f12ea29297b200f9cd7f54653df0" translate="yes" xml:space="preserve">
          <source>Improvements to the query planner so that it makes better estimates of plan costs and hence does a better job of choosing the right plan, especially when &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; is used.</source>
          <target state="translated">对查询计划程序的改进，使其可以更好地估算计划成本，从而更好地选择正确的计划，尤其是在使用&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;时。</target>
        </trans-unit>
        <trans-unit id="b56408ef9cd6514cec8e529db1c7c154a8214dac" translate="yes" xml:space="preserve">
          <source>Improvements to the windows makefiles and build processes.</source>
          <target state="translated">改进windows的makefiles和构建过程。</target>
        </trans-unit>
        <trans-unit id="01c7395c54005792d7fd39d556adb0b44131f473" translate="yes" xml:space="preserve">
          <source>In &quot;column&quot; mode (and also in &quot;box&quot;, &quot;table&quot;, and &quot;markdown&quot; modes) the width of columns adjusts automatically. But you can override this, providing a minimum width for each column using the &quot;.width&quot; command. The arguments to &quot;.width&quot; are integers which are the minimum number of spaces to devote to each column. Negative numbers mean right-justify. Thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24a3b4f842f4beb9d0cf338bd2105050638be32" translate="yes" xml:space="preserve">
          <source>In &quot;line&quot; mode, each column in a row of the database is shown on a line by itself. Each line consists of the column name, an equal sign and the column data. Successive records are separated by a blank line. Here is an example of line mode output:</source>
          <target state="translated">在 &quot;行 &quot;模式下,数据库一行中的每一列都单独显示在一行上。每一行由列名、等号和列数据组成。连续的记录之间用空行隔开。下面是一个行模式输出的例子。</target>
        </trans-unit>
        <trans-unit id="ba464cb54f172ce24a6d088a3cb06af2c611f784" translate="yes" xml:space="preserve">
          <source>In &quot;quote&quot; mode, the output is formatted as SQL literals. Strings are enclosed in single-quotes and internal single-quotes are escaped by doubling. Blobs are displayed in hexadecimal blob literal notation (Ex: x'abcd'). Numbers are displayed as ASCII text and NULL values are shown as &quot;NULL&quot;. All columns are separated from each other by a comma (or whatever alternative character is selected using &quot;.separator&quot;).</source>
          <target state="translated">在 &quot;引号 &quot;模式下,输出的格式为SQL字元。字符串用单引号括起来,内部单引号用双引号转义。块以十六进制的块文字符号显示(例如:x'abcd')。数字显示为ASCII文本,NULL值显示为 &quot;NULL&quot;。所有列之间用逗号(或用&quot;.分隔符 &quot;选择的任何替代字符)分隔。</target>
        </trans-unit>
        <trans-unit id="e70135d1b4c87e02724b6a6725f67c0cdcedb6a8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">在&lt;a href=&quot;../wal&quot;&gt;WAL模式下&lt;/a&gt;，在同一个数据库文件上打开的多个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;可以各自读取数据库文件的不同历史版本。当&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;开始读取事务时，该连接将看到数据库的不变副本，因为该副本在事务首次启动时存在。在启动新的读取事务之前，读取器将看不到其他连接对数据库的后续更改。</target>
        </trans-unit>
        <trans-unit id="545faac3a749c9fbe686ac2c42b0a8ce0746bb4b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), shared-cache mode was modified so that the same cache can be shared across an entire process rather than just within a single thread. Prior to this change, there were restrictions on passing database connections between threads. Those restrictions were dropped in 3.5.0 update. This document describes shared-cache mode as of version 3.5.0.</source>
          <target state="translated">在&lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;3.5.0版&lt;/a&gt;（2007-09-04）中，修改了共享缓存模式，以便可以在整个进程中共享同一缓存，而不仅仅是在单个线程中共享。在进行此更改之前，在线程之间传递数据库连接受到限制。这些限制在3.5.0更新中被删除。本文档介绍了自3.5.0版开始的共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="8b22aada76f514795f041039b72ce60807690314" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; mode, call fsync() immediately after truncating the journal file to ensure that the transaction is durable across a power loss.</source>
          <target state="translated">在&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = TRUNCATE&lt;/a&gt;模式下，在截断日志文件后立即调用fsync（），以确保事务在断电后仍可持久。</target>
        </trans-unit>
        <trans-unit id="b06cad3e4dffb16827f43add94eb56f4465695b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, attempting to attach the same database file more than once results in an error.</source>
          <target state="translated">在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;，尝试多次附加同一数据库文件会导致错误。</target>
        </trans-unit>
        <trans-unit id="9f41922c2aa21a0c294b4cbf9d4bf48e3b8e9e1c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, if a writer crashes and leaves the &lt;a href=&quot;walformat#shm&quot;&gt;shm file&lt;/a&gt; in an inconsistent state, subsequent transactions are now able to recover the shm file even if there are active read transactions. Before this enhancement, shm file recovery that scenario would result in an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d45c296410a6677088e7e7ac84b1e93a1f22edc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;，在同一个数据库文件上打开的多个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;可以各自读取数据库文件的不同历史版本。当&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;开始读取事务时，该连接将看到数据库的不变副本，因为该副本在事务首次启动时存在。在启动新的读取事务之前，读取器将看不到其他连接对数据库的后续更改。</target>
        </trans-unit>
        <trans-unit id="ddd420dd1a1ef7aee27736d7c043708aacde1ceb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode when synchronous is NORMAL (1), the WAL file is synchronized before each &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the database file is synchronized after each completed &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the WAL file header is synchronized when a WAL file begins to be reused after a checkpoint, but no sync operations occur during most transactions. With synchronous=FULL in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction help ensure that transactions are durable across a power loss. Transactions are consistent with or without the extra syncs provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL is normally all one needs in WAL mode.</source>
          <target state="translated">在&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;模式下，当sync为NORMAL（1）时，将在每个&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;之前对WAL文件进行同步，而在每个完成的&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;之后对数据库文件进行同步，并且在检查点之后开始重新使用WAL文件时，将对WAL文件头进行同步。同步操作发生在大多数事务中。在WAL模式下，当sync = FULL时，在每次事务提交之后，都会对WAL文件进行额外的同步操作。每笔交易之后的额外WAL同步有助于确保交易在断电后具有持久性。事务是否与sync = FULL提供的额外同步一致，也可以不同步。如果不考虑耐久性，那么在WAL模式下通常只需要sync = NORMAL。</target>
        </trans-unit>
        <trans-unit id="1207ec4eb27468881c3e5a75c509547ec16346af" translate="yes" xml:space="preserve">
          <source>In DDL</source>
          <target state="translated">在DDL中</target>
        </trans-unit>
        <trans-unit id="0fc22d3edb7a25933470b0fc98cd018feb112e2e" translate="yes" xml:space="preserve">
          <source>In DML</source>
          <target state="translated">在DML</target>
        </trans-unit>
        <trans-unit id="805c25b267572c14bae2116b6611f039f1f80c5c" translate="yes" xml:space="preserve">
          <source>In I/O error tests, after the I/O error simulation failure mechanism is disabled, the database is examined using &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to make sure that the I/O error has not introduced database corruption.</source>
          <target state="translated">在I / O错误测试中，禁用I / O错误模拟失败机制后，将使用&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;检查数据库，以确保I / O错误未引起数据库损坏。</target>
        </trans-unit>
        <trans-unit id="0f2cfcdcfc92b4b01bee8dec645ecb5ceaaa8098" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table.</source>
          <target state="translated">在Lemon中，分词器调用解析器。Yacc以相反的方式操作，解析器调用标记器。Lemon方法是可重入且线程安全的，而Yacc使用全局变量，因此两者都不是。对于SQLite，重入性尤其重要，因为某些SQL语句对解析器进行递归调用。例如，当解析CREATE TABLE语句时，SQLite递归调用解析器以生成INSERT语句，以在&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;表中添加新条目。</target>
        </trans-unit>
        <trans-unit id="d3369588aeb6a765cf20a5709a06e66a042c401f" translate="yes" xml:space="preserve">
          <source>In NORMAL locking-mode (the default unless overridden at compile-time using &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;), a database connection unlocks the database file at the conclusion of each read or write transaction. When the locking-mode is set to EXCLUSIVE, the database connection never releases file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock is obtained and held. The first time the database is written, an exclusive lock is obtained and held.</source>
          <target state="translated">在NORMAL锁定模式下（除非使用&lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;在编译时进行覆盖，否则默认为默认模式），数据库连接将在每次​​读取或写入事务结束时解锁数据库文件。当锁定模式设置为EXCLUSIVE时，数据库连接永远不会释放文件锁。第一次以EXCLUSIVE模式读取数据库时，将获取并保留一个共享锁。第一次写入数据库时​​，将获得并保留排他锁。</target>
        </trans-unit>
        <trans-unit id="f8c693ba3fad2e1d7df97dd42327c19b66a284bb" translate="yes" xml:space="preserve">
          <source>In SQLite</source>
          <target state="translated">在SQLite中</target>
        </trans-unit>
        <trans-unit id="e298a84cbd8720f440fc21a95dd67ebcefa40857" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06) and later, the colUsed field is available to indicate which fields of the virtual table are actually used by the statement being prepared. If the lowest bit of colUsed is set, that means that the first column is used. The second lowest bit corresponds to the second column. And so forth. If the most significant bit of colUsed is set, that means that one or more columns other than the first 63 columns are used. If column usage information is needed by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method, then the required bits must be encoded into either the idxNum or idxStr output fields.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;版本3.10.0&lt;/a&gt;（2016-01-06）和更高版本中，colUsed字段可用于指示所准备的语句实际使用虚拟表的哪些字段。如果设置了colUsed的最低位，则表示使用了第一列。第二最低位对应于第二列。依此类推。如果设置了colUsed的最高有效位，则表示使用了前63列以外的一个或多个列。如果&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法需要列使用情况信息，则必须将所需的位编码为idxNum或idxStr输出字段。</target>
        </trans-unit>
        <trans-unit id="828bdde156beec9d0455bf5a047ac9dedf77b343" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;version 3.28.0&lt;/a&gt; (2019-04-16), windows function support was extended to include the EXCLUDE clause, GROUPS frame types, window chaining, and support for &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; and &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot; boundaries in RANGE frames.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;版本3.28.0&lt;/a&gt;（2019-04-16）中，对Windows函数的支持进行了扩展，以包括EXCLUDE子句，GROUPS框架类型，窗口链接以及对Windows中的&amp;ldquo; &amp;lt;expr&amp;gt; PRECEDING&amp;rdquo;和&amp;ldquo; &amp;lt;expr&amp;gt; FOLLOWING&amp;rdquo;边界的支持。 RANGE帧。</target>
        </trans-unit>
        <trans-unit id="7a9dbb486e8961eb98612eeeff0292e2cdc9f06c" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26) and earlier, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; used to always return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it was invoked again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; without an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. This caused problems on some poorly written smartphone applications which did not correctly handle the &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; and &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error returns. Rather than fix the many defective smartphone applications, the behavior of SQLite was changed in 3.6.23.2 to automatically reset the prepared statement. But that changed caused issues in other improperly implemented applications that were actually looking for an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return to terminate their query loops. (Anytime an application gets an SQLITE_MISUSE error code from SQLite, that means the application is misusing the SQLite interface and is thus incorrectly implemented.) The SQLITE_OMIT_AUTORESET interface was added to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;version 3.7.5&lt;/a&gt; (2011-02-01) in an effort to get all of the (broken) applications to work again without having to actually fix the applications.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;3.6.23.1&lt;/a&gt;（2010-03-26）及更早版本中，如果在返回&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;以外的任何内容之后再次调用&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;，而没有中间调用&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;，则&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;总是返回SQLITE_MISUSE。这在一些编写不正确的智能手机应用程序上引起了问题，这些应用程序不能正确处理&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;和&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误返回。不是修复许多有缺陷的智能手机应用程序，而是在3.6.23.2中更改了SQLite的行为，以自动重置准备好的语句。但是这种变化导致了其他未正确实施的应用程序中的问题，这些应用程序实际上正在寻找&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;返回以终止其查询循环。（每当应用程序从SQLite获取SQLITE_MISUSE错误代码，这意味着该应用程序滥用SQLite接口，因此实现不正确。）SQLITE_OMIT_AUTORESET接口已添加到SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;版本3.7.5&lt;/a&gt;（2011-02-01）中，以期使所有（损坏的）应用程序再次运行，而无需实际修复应用程序。</target>
        </trans-unit>
        <trans-unit id="ae75dbb8c6b830d21fb52ab24e85cf97f8c0d055" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indices in the schema.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;版本3.8.0&lt;/a&gt;（2013-08-26）及更高版本中，每次准备使用自动索引的语句时，都会向&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;发送一条&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt;消息。应用程序开发人员可以并且应该使用这些警告来确定对架构中新的持久索引的需求。</target>
        </trans-unit>
        <trans-unit id="311b836bebf13bf229bfb5d427d7d61edb397191" translate="yes" xml:space="preserve">
          <source>In SQLite Version 3</source>
          <target state="translated">在SQLite 3版本中</target>
        </trans-unit>
        <trans-unit id="44b0d77bd3716352e42cf5f2569dabd7987b859f" translate="yes" xml:space="preserve">
          <source>In SQLite version 2</source>
          <target state="translated">在SQLite 2版本中</target>
        </trans-unit>
        <trans-unit id="ab1b358df4951321dec42436274a7fc7055620c8" translate="yes" xml:space="preserve">
          <source>In SQLite version 2, if many processes are reading from the database, it might be the case that there is never a time when there are no active readers. And if there is always at least one read lock on the database, no process would ever be able to make changes to the database because it would be impossible to acquire a write lock. This situation is called &lt;em&gt;writer starvation&lt;/em&gt;.</source>
          <target state="translated">在SQLite版本2中，如果有许多进程正在从数据库中读取数据，则可能是从来没有时间没有活动的读取器。而且，如果数据库上始终至少有一个读锁，则任何进程都将无法对数据库进行更改，因为将不可能获得写锁。这种情况称为&lt;em&gt;作家饥饿&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0e7545ebfe6eb34f26f31fe8304f6f550663c8e8" translate="yes" xml:space="preserve">
          <source>In SQLite version 3, the sqlite3_exec routine is just a wrapper around calls to the prepared statement interface.</source>
          <target state="translated">在SQLite第3版中,sqlite3_exec例程只是对准备好的语句接口调用的一个包装器。</target>
        </trans-unit>
        <trans-unit id="e7a56207acc60b29c6f42211f54c5ca8f6e54fa3" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.0, the rowid is a 64-bit signed integer. This is an expansion of SQLite version 2.8 which only permitted rowids of 32-bits.</source>
          <target state="translated">在SQLite 3.0版本中,rowid是一个64位有符号的整数。这是对SQLite 2.8版本的扩展,该版本只允许32位的rowid。</target>
        </trans-unit>
        <trans-unit id="eade6a0b14d85e68f1dde5969cd3e571c5e3e4f6" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted. That capability is no longer provided. Only built-in memory allocators can be used.</source>
          <target state="translated">在SQLite 3.5.0和3.5.1版本中,可以定义SQLITE_OMIT_MEMORY_ALLOCATION,这将导致这些例程的内置实现被省略。现在不再提供这种功能。只能使用内置的内存分配器。</target>
        </trans-unit>
        <trans-unit id="7278a0046b6c686e7491a606645054d45ac6a9da" translate="yes" xml:space="preserve">
          <source>In SQLite versions 3.3.0 through 3.4.2 when shared-cache mode is enabled, a database connection may only be used by the thread that called &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create it. And a connection could only share cache with another connection in the same thread. These restrictions were dropped beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04).</source>
          <target state="translated">在启用共享缓存模式的SQLite 3.3.0至3.4.2版本中，数据库连接只能由调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;的线程创建。一个连接只能与同一线程中的另一个连接共享缓存。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;3.5.0&lt;/a&gt;（2007-09-04）开始删除了这些限制。</target>
        </trans-unit>
        <trans-unit id="4af0e6be92f4dba4280a2c7e3664bbca74929393" translate="yes" xml:space="preserve">
          <source>In SQLite, a column with type INTEGER PRIMARY KEY is an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (except in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) which is always a 64-bit signed integer.</source>
          <target state="translated">在SQLite中，类型为INTEGER PRIMARY KEY的列是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;的别名（在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中除外），该别名始终是64位有符号整数。</target>
        </trans-unit>
        <trans-unit id="d48f1e4d1dbe48d61b2a0bc14d1d629523402032" translate="yes" xml:space="preserve">
          <source>In SQLite, a database object (a table, index, trigger or view) is identified by the name of the object and the name of the database that it resides in. Database objects may reside in the main database, the temp database, or in an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;.</source>
          <target state="translated">在SQLite中，数据库对象（表，索引，触发器或视图）由对象名称和其所在数据库的名称标识。数据库对象可以位于主数据库，临时数据库或一个&lt;a href=&quot;lang_attach&quot;&gt;附加的数据库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d037fc285a8e821543df8fc13d9f7837388fd3a" translate="yes" xml:space="preserve">
          <source>In SQLite, table rows normally have a 64-bit signed integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; which is unique among all rows in the same table. (&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are the exception.)</source>
          <target state="translated">在SQLite中，表行通常具有64位带符号整数&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;，该ID在同一表的所有行中都是唯一的。（&lt;a href=&quot;withoutrowid&quot;&gt;没有ROWID&lt;/a&gt;表是例外。）</target>
        </trans-unit>
        <trans-unit id="fe38d7c32db7d9028a7337d49fe5d30adb864ee5" translate="yes" xml:space="preserve">
          <source>In SQLite, the answer to the previous question is &quot;no&quot;. For testing purposes, the SQLite source code defines macros called ALWAYS() and NEVER(). The ALWAYS() macro surrounds conditions which are expected to always evaluate as true and NEVER() surrounds conditions that are always evaluated to false. These macros serve as comments to indicate that the conditions are defensive code. In release builds, these macros are pass-throughs:</source>
          <target state="translated">在SQLite中,前一个问题的答案是 &quot;没有&quot;。为了测试的目的,SQLite源代码定义了名为ALWAYS()和NEVER()的宏。ALWAYS()宏包围了那些预期总是被评估为真的条件,而NEVER()包围了那些总是被评估为假的条件。这些宏作为注释,表明这些条件是防御性代码。在发行版构建中,这些宏是通证。</target>
        </trans-unit>
        <trans-unit id="f43676df6968c4bb63677e4842db7886283fb3e7" translate="yes" xml:space="preserve">
          <source>In SQLite, the presence of assert(X) means that the developers have a proof that X is always true. Readers can depend upon X being true to help them reason about the code. An assert(X) is a strong statement about the truth of X. There is no doubt.</source>
          <target state="translated">在SQLite中,assert(X)的存在意味着开发者可以证明X总是真。读者可以依靠X为真来帮助他们推理代码。assert(X)是一个关于X的真实性的有力声明,没有任何疑问。</target>
        </trans-unit>
        <trans-unit id="afc867db69a6f0ff03a7d5c74a860a19b5e1f763" translate="yes" xml:space="preserve">
          <source>In WAL mode, changes to the database are detected using the wal-index and so the change counter is not needed. Hence, the change counter might not be incremented on each transaction in WAL mode.</source>
          <target state="translated">在WAL模式下,数据库的变化是通过wal-index来检测的,所以不需要变化计数器。因此,在WAL模式下,变化计数器可能不会在每个事务中递增。</target>
        </trans-unit>
        <trans-unit id="56b4d5a656b5f1cb948b72fc909adc62f6fce99b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, all ORDER BY expressions are handled as aliases for one of the result columns of the compound. If an ORDER BY expression is not an integer alias, then SQLite searches the left-most SELECT in the compound for a result column that matches either the second or third rules above. If a match is found, the search stops and the expression is handled as an alias for the result column that it has been matched against. Otherwise, the next SELECT to the right is tried, and so on. If no matching expression can be found in the result columns of any constituent SELECT, it is an error. Each term of the ORDER BY clause is processed separately and may be matched against result columns from different SELECT statements in the compound.</source>
          <target state="translated">在&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT&lt;/a&gt;语句中，所有ORDER BY表达式均作为复合结果列之一的别名处理。如果ORDER BY表达式不是整数别名，则SQLite会在化合物中最左边的SELECT中搜索与上述第二或第三条规则匹配的结果列。如果找到匹配项，则搜索将停止，并且该表达式将作为已与其匹配的结果列的别名进行处理。否则，将尝试右边的下一个SELECT，依此类推。如果在任何组成的SELECT的结果列中找不到匹配的表达式，则为错误。 ORDER BY子句的每个术语都单独处理，并且可以与复合物中不同SELECT语句的结果列进行匹配。</target>
        </trans-unit>
        <trans-unit id="7e23feed60f0ebed492861c5dd540e487916faa3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may have an ORDER BY clause. That ORDER BY clause will apply across all elements of the compound. If the right-most element of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause, then no ORDER BY clause is allowed on that statement.</source>
          <target state="translated">在&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT&lt;/a&gt;语句中，只有最后一个或最右边的&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单SELECT&lt;/a&gt;可以具有ORDER BY子句。该ORDER BY子句将应用于该化合物的所有元素。如果&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT&lt;/a&gt;的最右边的元素是&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;子句，则该语句上不允许使用ORDER BY子句。</target>
        </trans-unit>
        <trans-unit id="60dd93ddbe8f5275cb023ced823e2e72128039a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may contain a LIMIT clause. In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, the LIMIT clause applies to the entire compound, not just the final SELECT. If the right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; then no LIMIT clause is allowed.</source>
          <target state="translated">在&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT中&lt;/a&gt;，只有最后一个或最右边的&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单SELECT&lt;/a&gt;可以包含LIMIT子句。在&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT中&lt;/a&gt;，LIMIT子句适用于整个复合，而不仅仅是最终的SELECT。如果最右边的&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单SELECT&lt;/a&gt;是&lt;a href=&quot;lang_select#values&quot;&gt;VALUES子句，&lt;/a&gt;则不允许LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="4a8149bd98030a655ea899de201ec17546792e89" translate="yes" xml:space="preserve">
          <source>In a CASE with a base expression, the base expression is evaluated just once and the result is compared against the evaluation of each WHEN expression from left to right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression for which the comparison is true. Or, if none of the WHEN expressions evaluate to a value equal to the base expression, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions produce a result equal to the base expression, the overall result is NULL.</source>
          <target state="translated">在带有基础表达式的CASE中,基础表达式只被评价一次,其结果与从左到右的每个WHEN表达式的评价进行比较。CASE表达式的结果是与比较为真的第一个WHEN表达式对应的THEN表达式的评价。或者,如果没有一个WHEN表达式的值等于基础表达式,则是评价ELSE表达式(如果有)的结果。如果没有ELSE表达式,并且没有一个WHEN表达式产生的结果等于基础表达式,则整体结果为NULL。</target>
        </trans-unit>
        <trans-unit id="9908cac3e7af8453ade042a08abc46157b47dbc8" translate="yes" xml:space="preserve">
          <source>In a CASE without a base expression, each WHEN expression is evaluated and the result treated as a boolean, starting with the leftmost and continuing to the right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression that evaluates to true. Or, if none of the WHEN expressions evaluate to true, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions are true, then the overall result is NULL.</source>
          <target state="translated">在没有基础表达式的CASE中,每个WHEN表达式都会被评估,结果被当作布尔值处理,从最左边开始,一直到右边。CASE表达式的结果是与第一个WHEN表达式对应的THEN表达式的评价,该表达式的评价结果为真。或者,如果没有一个WHEN表达式评价为真,则是评价ELSE表达式(如果有)的结果。如果没有ELSE表达式,而且WHEN表达式都不为真,那么总体结果为NULL。</target>
        </trans-unit>
        <trans-unit id="6181d4389ce1218d0117e383d6876208b5204220" translate="yes" xml:space="preserve">
          <source>In a compound SELECT, all the constituent SELECTs must return the same number of result columns. As the components of a compound SELECT must be simple SELECT statements, they may not contain &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses. &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses may only occur at the end of the entire compound SELECT, and then only if the final element of the compound is not a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause.</source>
          <target state="translated">在复合SELECT中，所有组成的SELECT必须返回相同数量的结果列。由于复合SELECT的组件必须是简单的SELECT语句，因此它们可能不包含&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;或&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;子句。&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;和&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;子句只能在整个复合SELECT的末尾出现，然后仅在该复合词的最后一个元素不是&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;子句时才出现。</target>
        </trans-unit>
        <trans-unit id="78d71ac8fe601725ccb2ce14d7f5ff1b4e551c1c" translate="yes" xml:space="preserve">
          <source>In a custom format defined by the RBU application.</source>
          <target state="translated">以RBU应用程序定义的自定义格式。</target>
        </trans-unit>
        <trans-unit id="c01843d896cd964dc56835ee2c755615d047e3ab" translate="yes" xml:space="preserve">
          <source>In a database that uses ptrmap pages, all pages at locations identified by the computation in the previous paragraph must be ptrmap page and no other page may be a ptrmap page. Except, if the byte-lock page happens to fall on the same page number as a ptrmap page, then the ptrmap is moved to the following page for that one case.</source>
          <target state="translated">在使用ptrmap页的数据库中,上一段计算确定的位置的所有页面必须是ptrmap页,其他页面不得是ptrmap页。只是,如果字节锁页恰好和ptrmap页落在同一个页码上,那么这一个情况下,ptrmap就会被移到下一个页面。</target>
        </trans-unit>
        <trans-unit id="27e8a07a53d50d810a0832f44496263b4918565d" translate="yes" xml:space="preserve">
          <source>In a database with ptrmap pages, the first ptrmap page is page 2. A ptrmap page consists of an array of 5-byte entries. Let J be the number of 5-byte entries that will fit in the usable space of a page. (In other words, J=U/5.) The first ptrmap page will contain back pointer information for pages 3 through J+2, inclusive. The second pointer map page will be on page J+3 and that ptrmap page will provide back pointer information for pages J+4 through 2*J+3 inclusive. And so forth for the entire database file.</source>
          <target state="translated">在一个有ptrmap页的数据库中,第一个ptrmap页是第2页。一个ptrmap页由一个5字节的条目数组组成。让J是一个页的可用空间中可以容纳的5字节条目的数量,(换句话说,J=U/5)。(换句话说,J=U/5。)第一个ptrmap页将包含第3页到J+2页(含)的后指针信息。第二个指针图页将在J+3页上,该ptrmap页将提供J+4到2*J+3(含)页的后指针信息。以此类推整个数据库文件。</target>
        </trans-unit>
        <trans-unit id="413d5f86aecfe4e03a70ec087a2506b07314a985" translate="yes" xml:space="preserve">
          <source>In a general query, dependencies need not be on a single loop, and hence the matrix of dependencies might not be representable as a graph. For example, one of the WHERE clause constraints might be S.a=L.b+P.c, implying that the S loop must be an inner loop of both L and P. Such dependencies cannot be drawn as a graph since there is no way for an arc to originate at two or more nodes at once.</source>
          <target state="translated">在一般的查询中,依赖关系不需要在一个单一的循环上,因此依赖关系的矩阵可能不能用图来表示。例如,其中一个WHERE子句约束条件可能是S.a=L.b+P.c,这意味着S循环必须是L和P的内部循环。这样的依赖关系不能画成图,因为没有办法让一个弧线同时起源于两个或多个节点。</target>
        </trans-unit>
        <trans-unit id="3cba367e5a45e9ef327972801946d29ebc579596" translate="yes" xml:space="preserve">
          <source>In a join, two or more tables are combined to generate a single result. The result table consists of every possible combination of rows from the tables being joined. The easiest and most natural way to implement this is with nested loops.</source>
          <target state="translated">在联接中,两个或多个表被结合起来,生成一个结果。结果表由被连接表的所有可能的行组合组成。最简单、最自然的实现方式是使用嵌套循环。</target>
        </trans-unit>
        <trans-unit id="ea43a43981be0da7d2383a4a8fa8f578ad332998" translate="yes" xml:space="preserve">
          <source>In a more complete build, SQLite also uses library routines like malloc() and free() and operating system interfaces for opening, reading, writing, and closing files. But even then, the number of dependencies is very small. Other &quot;modern&quot; language, in contrast, often require multi-megabyte runtimes loaded with thousands and thousands of interfaces.</source>
          <target state="translated">在更完整的构建中,SQLite还使用了malloc()和free()等库例程,以及打开、读取、写入和关闭文件的操作系统接口。但即便如此,依赖的数量也非常少。相比之下,其他的 &quot;现代 &quot;语言往往需要多兆字节的运行时,加载成千上万的接口。</target>
        </trans-unit>
        <trans-unit id="84d7fa8dbd084f79299c977c5d7f182884242ce4" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, access to the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; is serialized if and only if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is enabled. If &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled then the methods in &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; must take care of their own serialization needs.</source>
          <target state="translated">在多线程应用程序中，只有在启用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS的&lt;/a&gt;情况下，对&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods的&lt;/a&gt;访问才被序列化。如果禁用了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS，&lt;/a&gt;则&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods中&lt;/a&gt;的方法必须照顾自己的序列化需求。</target>
        </trans-unit>
        <trans-unit id="f07ff4f6d979804b51470d547e3016d910de27f0" translate="yes" xml:space="preserve">
          <source>In a multithreaded environment, SQLite uses mutexes to serialize access to shared resources. The mutex subsystem is only required for applications that access SQLite from multiple threads. For single-threaded applications, or applications which only call SQLite from a single thread, the mutex subsystem can be completely disabled by recompiling with the following option:</source>
          <target state="translated">在多线程环境中,SQLite使用mutexes来序列化对共享资源的访问。只有从多个线程访问SQLite的应用程序才需要使用mutex子系统。对于单线程应用程序,或者只从单线程调用SQLite的应用程序,可以通过使用以下选项重新编译来完全禁用mutex子系统。</target>
        </trans-unit>
        <trans-unit id="4d4533ee698cc81c52715976a896f4db12f7a8cf" translate="yes" xml:space="preserve">
          <source>In a normal index, there is a one-to-one mapping between rows in a table and entries in each index associated with that table. However, in a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, the index b-tree only contains entries corresponding to table rows for which the WHERE clause expression on the CREATE INDEX statement is true. Corresponding rows in the index and table b-trees share the same rowid or primary key values and contain the same value for all indexed columns.</source>
          <target state="translated">在普通索引中，表中的行与与该表关联的每个索引中的条目之间存在一对一的映射。但是，在&lt;a href=&quot;partialindex&quot;&gt;部分索引中&lt;/a&gt;，索引b树仅包含与CREATE INDEX语句上的WHERE子句表达式为true的表行相对应的条目。索引树b和表b树中的相应行共享相同的rowid或主键值，并且对于所有索引列都包含相同的值。</target>
        </trans-unit>
        <trans-unit id="ce9e9da4042a8b1a6fff277efdbca241b2bb44b8" translate="yes" xml:space="preserve">
          <source>In a prefix search, the matchlen is the number of characters in the string that match against the prefix. For a non-prefix search, this is the same as length(word).</source>
          <target state="translated">在前缀搜索中,matchlen是字符串中与前缀匹配的字符数。对于非前缀搜索,这与 length(word)相同。</target>
        </trans-unit>
        <trans-unit id="540eb7e11b15dfedf16222538153a627d93ae118" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat3 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if the entry with left-most column S1 is earlier in the index b-tree than the entry with left-most column S2, then in the sqlite_stat3 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">在一个完善的 sqlite_stat3 表中,任何一个索引的样本必须按照它们在索引中出现的顺序出现。换句话说,如果在索引b树中,最左列S1的条目比最左列S2的条目要早,那么在sqlite_stat3表中,样本S1的rowid必须比样本S2小。</target>
        </trans-unit>
        <trans-unit id="471a1674cd89ff60cc26aaa2e09dcb5715c114d4" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat4 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if entry S1 is earlier in the index b-tree than entry S2, then in the sqlite_stat4 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">在一个完善的sqlite_stat4表中,任何一个单一索引的样本必须按照它们在索引中出现的顺序出现。换句话说,如果条目S1在索引b树中比条目S2更早,那么在sqlite_stat4表中,样本S1的rowid必须比样本S2小。</target>
        </trans-unit>
        <trans-unit id="211f3f65b2d350ffdf823361c3c94beeb6b3685e" translate="yes" xml:space="preserve">
          <source>In addition to &quot;supporting&quot; SQLite through the year 2050, the developers also promise to keep the SQLite &lt;a href=&quot;cintro&quot;&gt;C-language API&lt;/a&gt; and &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt; fully backwards compatible. This means that application written to use SQLite today should be able to link against and use future versions of SQLite released decades in the future.</source>
          <target state="translated">除了在2050年之前&amp;ldquo;支持&amp;rdquo; SQLite，开发人员还承诺保持SQLite &lt;a href=&quot;cintro&quot;&gt;C语言API&lt;/a&gt;和&lt;a href=&quot;fileformat2&quot;&gt;磁盘格式&lt;/a&gt;完全向后兼容。这意味着今天编写的使用SQLite的应用程序应该能够链接并使用几十年后发布的SQLite的将来版本。</target>
        </trans-unit>
        <trans-unit id="2d62e10830dbc04e04eb1ce98ea4d36c1849dd6d" translate="yes" xml:space="preserve">
          <source>In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex method about the ORDER BY clause. (In an aggregate query, the SQLite core might put in GROUP BY clause information in place of the ORDER BY clause information, but this fact should not make any difference to the xBestIndex method.) If all terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify the column for each term in the order by clause and whether or not that column is ASC or DESC.</source>
          <target state="translated">除了WHERE子句约束外,SQLite核心还告诉xBestIndex方法有关ORDER BY子句的信息。(在集合查询中,SQLite核心可能会放入GROUP BY子句信息来代替ORDER BY子句信息,但这个事实应该不会对xBestIndex方法产生任何影响)。如果ORDER BY子句的所有条款都是虚拟表中的列,那么nOrderBy将是ORDER BY子句中的条款数,aOrderBy[]数组将标识每个条款在order by子句中的列,以及该列是ASC还是DESC。</target>
        </trans-unit>
        <trans-unit id="ae32760f149e6ccbf9d662c3e5f266d79f8381ea" translate="yes" xml:space="preserve">
          <source>In addition to being a result code, the SQLITE_ABORT value is also used as a &lt;a href=&quot;c3ref/c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">除了作为结果代码之外，SQLITE_ABORT值还用作从&lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;接口返回的&lt;a href=&quot;c3ref/c_fail&quot;&gt;冲突解决模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bf173fd8743d9addd4d23da77cbd1023dcac612" translate="yes" xml:space="preserve">
          <source>In addition to locking this byte, a connection running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; also gets an exclusive lock on all other WAL locks except for WAL_READ_LOCK(0).</source>
          <target state="translated">除了锁定该​​字节外，运行连接&lt;a href=&quot;walformat#recovery&quot;&gt;恢复&lt;/a&gt;的连接还将获得除WAL_READ_LOCK（0）以外的所有其他WAL锁的排他锁。</target>
        </trans-unit>
        <trans-unit id="cb3414acfc85a9001c1b555d3204dd8c38c36eeb" translate="yes" xml:space="preserve">
          <source>In addition to making SQLite easier to incorporate into other projects, the amalgamation also makes it run faster. Many compilers are able to do additional optimizations on code when it is contained with in a single translation unit such as it is in the amalgamation. We have measured performance improvements of between 5 and 10% when we use the amalgamation to compile SQLite rather than individual source files. The downside of this is that the additional optimizations often take the form of function inlining which tends to make the size of the resulting binary image larger.</source>
          <target state="translated">除了让SQLite更容易融入其他项目之外,合并也让它运行得更快。当代码被包含在一个单一的翻译单元中时,许多编译器能够对代码进行额外的优化,例如amalgamation中的代码。我们已经测量到,当我们使用amalgamation编译SQLite而不是单个源文件时,性能提高了5到10%。这样做的缺点是,额外的优化通常采取函数内联的形式,这往往会使生成的二进制图像的大小变大。</target>
        </trans-unit>
        <trans-unit id="dc82fe62c10524b3d4ccdfbeed7cfd03442b0fdf" translate="yes" xml:space="preserve">
          <source>In addition to providing built-in &quot;simple&quot;, &quot;porter&quot; and (possibly) &quot;icu&quot; and &quot;unicode61&quot; tokenizers, FTS provides an interface for applications to implement and register custom tokenizers written in C. The interface used to create a new tokenizer is defined and described in the fts3_tokenizer.h source file.</source>
          <target state="translated">除了提供内置的 &quot;simple&quot;、&quot;porter &quot;和(可能是)&quot;icu &quot;和 &quot;unicode61 &quot;tokenizer之外,FTS还提供了一个接口,供应用程序实现和注册用C语言编写的自定义tokenizer。用于创建新tokenizer的接口在fts3_tokenizer.h源文件中进行了定义和描述。</target>
        </trans-unit>
        <trans-unit id="96c71370cd3f6550d6c5dcd90baa2ddaf820ea27" translate="yes" xml:space="preserve">
          <source>In addition to reading and writing SQLite database files, the &lt;b&gt;sqlite3&lt;/b&gt; program will also read and write ZIP archives. Simply specify a ZIP archive filename in place of an SQLite database filename on the initial command line, or in the &quot;.open&quot; command, and &lt;b&gt;sqlite3&lt;/b&gt; will automatically detect that the file is a ZIP archive instead of an SQLite database and will open it as such. This works regardless of file suffix. So you can open JAR, DOCX, and ODP files and any other file format that is really a ZIP archive and SQLite will read it for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73759a104c50187a5dc43c3f84c36657f75e9027" translate="yes" xml:space="preserve">
          <source>In addition to the four main test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffa68d498101dd69c9fe08bfcd580625d879a08" translate="yes" xml:space="preserve">
          <source>In addition to the incompatible changes listed above, SQLite version 3.6.0 adds the following backwards compatible changes and enhancements:</source>
          <target state="translated">除了上面列出的不兼容变化外,SQLite 3.6.0版本还增加了以下向后兼容的变化和增强功能。</target>
        </trans-unit>
        <trans-unit id="8f29eabb94163c908fdf9ce75645a4e743012d26" translate="yes" xml:space="preserve">
          <source>In addition to the official repositories, the developers typically keep complete clones of all software on their personal machines. And there are uncountable clones scattered about the internet.</source>
          <target state="translated">除了官方的软件库,开发者一般会在个人机器上保存所有软件的完整克隆。而互联网上散落着难以计数的克隆软件。</target>
        </trans-unit>
        <trans-unit id="7d07efab2f131a863a93f94a25375b6ef4bc7a4a" translate="yes" xml:space="preserve">
          <source>In addition to the primary vdbe.c source code file, there are other helper code files in the source tree, all of whose names begin with &quot;vdbe&quot; - short for &quot;Virtual DataBase Engine&quot;.</source>
          <target state="translated">除了主要的vdbe.c源码文件,在源码树中还有其他的帮助代码文件,它们的名字都是以 &quot;vdbe &quot;开头的--&quot;Virtual DataBase Engine &quot;的缩写。</target>
        </trans-unit>
        <trans-unit id="e225e51508417bb108b16321c68b3adb1795c7b9" translate="yes" xml:space="preserve">
          <source>In addition to the required flags, the following optional flags are also supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b9657ef03e307e851c2e7bae3bdd3ad8613131" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_master table may contain zero or more entries for</source>
          <target state="translated">除了应用程序和/或开发人员使用CREATE语句SQL创建的表、索引、视图和触发器之外,sqlite_master表还可能包含零个或多个条目,用于以下情况</target>
        </trans-unit>
        <trans-unit id="52a812fb18ec964152fad4865c6ca9189ffdf18b" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_schema table may contain zero or more entries for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a409c2d7a3384bc3f57eb2c0537e46f7868645bd" translate="yes" xml:space="preserve">
          <source>In addition to the three major test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">除了三大测试线束外,还有其他几个小程序实现专门的测试。</target>
        </trans-unit>
        <trans-unit id="0718e6fdf0cd1e299f6d920f46595f0908dd4b09" translate="yes" xml:space="preserve">
          <source>In addition, there are some defined constants:</source>
          <target state="translated">此外,还有一些确定的常数。</target>
        </trans-unit>
        <trans-unit id="fbb8e299adb3ff32a155642d73390e9d9fa9566c" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650bcf7f3c9667b8bca2e9d81188fd4ca62bdf99" translate="yes" xml:space="preserve">
          <source>In all of the full-text queries above, the right-hand operand of the MATCH operator is a string consisting of a single term. In this case, the MATCH expression evaluates to true for all documents that contain one or more instances of the specified word (&quot;sqlite&quot;, &quot;search&quot; or &quot;database&quot;, depending on which example you look at). Specifying a single term as the right-hand operand of the MATCH operator results in the simplest and most common type of full-text query possible. However more complicated queries are possible, including phrase searches, term-prefix searches and searches for documents containing combinations of terms occurring within a defined proximity of each other. The various ways in which the full-text index may be queried are &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">在上面所有的全文查询中，MATCH运算符的右侧操作数是由单个术语组成的字符串。在这种情况下，对于包含一个或多个指定单词实例（&amp;ldquo; sqlite&amp;rdquo;，&amp;ldquo; search&amp;rdquo;或&amp;ldquo; database&amp;rdquo;，取决于您查看的示例）的所有文档，MATCH表达式的计算结果均为true。指定单个术语作为MATCH运算符的右侧操作数会导致最简单和最常见的全文查询类型。但是，更复杂的查询是可能的，包括短语搜索，术语前缀搜索以及对包含在彼此定义的邻近范围内出现的术语组合的文档的搜索。&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;下面描述&lt;/a&gt;查询全文索引的各种方式。</target>
        </trans-unit>
        <trans-unit id="fec3ea71809f1fd12bdd320ecfb2400479f6f909" translate="yes" xml:space="preserve">
          <source>In all of the write tests, it is important to disable anti-virus software prior to running the direct-to-disk performance tests. We found that anti-virus software slows down direct-to-disk by an order of magnitude whereas it impacts SQLite writes very little. This is probably due to the fact that direct-to-disk changes thousands of separate files which all need to be checked by anti-virus, whereas SQLite writes only changes the single database file.</source>
          <target state="translated">在所有的写入测试中,在运行直接到磁盘的性能测试之前,禁用防病毒软件是很重要的。我们发现,防病毒软件会使直接到磁盘的速度降低一个数量级,而它对SQLite写入的影响却很小。这可能是由于direct-to-disk会改变成千上万个独立的文件,这些文件都需要防病毒软件检查,而SQLite写入只改变单个数据库文件。</target>
        </trans-unit>
        <trans-unit id="19fd1c2e26ad6ba4190cb1ba85655e3d415fb1a9" translate="yes" xml:space="preserve">
          <source>In all other cases this function returns SQLITE_MISUSE.</source>
          <target state="translated">在所有其他情况下,该函数返回SQLITE_MISUSE。</target>
        </trans-unit>
        <trans-unit id="a9b1d686d80c16cbd892850ec817e33e118fdb64" translate="yes" xml:space="preserve">
          <source>In all the examples above, there has only been a single SELECT statement. If a query contains sub-selects, those are shown as being children of the outer SELECT. For example:</source>
          <target state="translated">在上面所有的例子中,只有一条SELECT语句。如果一个查询包含子选择,那么这些子选择就会被显示为外层SELECT的子选择。例如:</target>
        </trans-unit>
        <trans-unit id="c9c18ce865540a24f1f5ee5d4ef74324465c3e44" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement, a list of column names can be set to a row value of the same size.</source>
          <target state="translated">在&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句中，可以将列名列表设置为相同大小的行值。</target>
        </trans-unit>
        <trans-unit id="34ecd17e630ff3ecf740af54bcb0cb9af6e271db" translate="yes" xml:space="preserve">
          <source>In an expression used as part of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;.</source>
          <target state="translated">在用作&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;一部分的表达式中。</target>
        </trans-unit>
        <trans-unit id="68e31982331dd4f44aeeef7efedd25a5db6a0a14" translate="yes" xml:space="preserve">
          <source>In an index on a WITHOUT ROWID table, if a column of the PRIMARY KEY is also a column in the index and has a matching collating sequence, then the indexed column is not repeated in the table-key suffix on the end of the index record. As an example, consider the following SQL:</source>
          <target state="translated">在WITHOUT ROWID表的索引中,如果PRIMARY KEY的某一列也是索引中的一列,并且有匹配的整理序列,那么索引记录末尾的表-键后缀就不会重复。作为一个例子,考虑以下SQL。</target>
        </trans-unit>
        <trans-unit id="b98eca53cbed3b51f01e882fbf03443737203ad3" translate="yes" xml:space="preserve">
          <source>In an interior b-tree page, the pointers and keys logically alternate with a pointer on both ends. (The previous sentence is to be understood conceptually - the actual layout of the keys and pointers within the page is more complicated and will be described in the sequel.) All keys within the same page are unique and are logically organized in ascending order from left to right. (Again, this ordering is logical, not physical. The actual location of keys within the page is arbitrary.) For any key X, pointers to the left of a X refer to b-tree pages on which all keys are less than or equal to X. Pointers to the right of X refer to pages where all keys are greater than X.</source>
          <target state="translated">在一个内部b树页面中,指针和键在逻辑上是交替排列的,两端都有一个指针。前面的句子要从概念上理解--页面内键和指针的实际布局比较复杂,将在后文中描述)。同一页面内的所有键都是唯一的,并且在逻辑上是按照从左到右的升序组织的。(同样,这种排序是逻辑上的,而不是物理上的。键在页面中的实际位置是任意的。)对于任何键X,指向X左边的指针指的是所有键小于或等于X的b树页面,指向X右边的指针指的是所有键大于X的页面。</target>
        </trans-unit>
        <trans-unit id="39488c0191328e370ea86a4f1833476c2e9dc423" translate="yes" xml:space="preserve">
          <source>In an ordinary SQLite table, the PRIMARY KEY is really just a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; index. The key used to look up records on disk is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. The special &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; column type in ordinary SQLite tables causes the column to be an alias for the rowid, and so an INTEGER PRIMARY KEY is a true PRIMARY KEY. But any other kind of PRIMARY KEYs, including &quot;INT PRIMARY KEY&quot; are just unique indexes in an ordinary rowid table.</source>
          <target state="translated">在普通的SQLite表中，PRIMARY KEY实际上只是一个&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;索引。用于查找磁盘上记录的键是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。普通SQLite表中特殊的&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &amp;rdquo;列类型使该列成为rowid的别名，因此INTEGER PRIMARY KEY是真实的PRIMARY KEY。但是任何其他类型的PRIMARY KEY（包括&amp;ldquo; INT PRIMARY KEY&amp;rdquo;）都只是普通rowid表中的唯一索引。</target>
        </trans-unit>
        <trans-unit id="2602231eda03cd82b0bfe3849f20e2339713b36f" translate="yes" xml:space="preserve">
          <source>In any aggregate function that takes a single argument, that argument can be preceded by the keyword DISTINCT. In such cases, duplicate elements are filtered before being passed into the aggregate function. For example, the function &quot;count(distinct X)&quot; will return the number of distinct values of column X instead of the total number of non-null values in column X.</source>
          <target state="translated">在任何接受单一参数的聚合函数中,该参数前面可以加上关键字DISTINCT。在这种情况下,重复的元素在被传递到聚合函数之前会被过滤掉。例如,函数 &quot;count(distinct X)&quot;将返回列X的独特值的数量,而不是列X中非空值的总数。</target>
        </trans-unit>
        <trans-unit id="15eb51d3758bed15da54f5c0830882a735d49cb2" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_master table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_master table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">在任何包含ptrmap页的数据库文件中,所有b树根页必须排在任何非根b树页、单元格有效载荷溢出页或自由列表页之前。这个限制保证了在自动抽真空或增量抽真空的过程中,根页面永远不会被移动。自动清空逻辑不知道如何更新sqlite_master表的root_page字段,因此为了保持sqlite_master表的完整性,必须防止在自动清空期间移动根页面。通过CREATE TABLE、CREATE INDEX、DROP TABLE、DROP INDEX等操作,将根页移动到数据库文件的开头。</target>
        </trans-unit>
        <trans-unit id="d9bc87111dc7feda77c011e8d21c00fc7e80e539" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_schema table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_schema table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016fc239bf2f87e674a823e588afff2d09643b5a" translate="yes" xml:space="preserve">
          <source>In automatic EXPLAIN QUERY PLAN mode, the shell automatically runs a separate EXPLAIN QUERY PLAN query for each statement you enter and displays the result before actually running the query. Use the &quot;.eqp off&quot; command to turn automatic EXPLAIN QUERY PLAN mode back off.</source>
          <target state="translated">在自动 EXPLAIN QUERY PLAN 模式下,shell 会为您输入的每一条语句自动运行一个单独的 EXPLAIN QUERY PLAN 查询,并在实际运行查询之前显示结果。使用&quot;.eqp off &quot;命令来关闭自动EXPLAIN查询计划模式。</target>
        </trans-unit>
        <trans-unit id="a0296b5facf2017142e185ec710adebd650dd374" translate="yes" xml:space="preserve">
          <source>In batch-mode operation, where an FTS table is initially built up using a large number of INSERT operations, then queried repeatedly without further changes, it is often a good idea to run &quot;optimize&quot; after the last INSERT and before the first query.</source>
          <target state="translated">在批处理模式的操作中,一个FTS表最初是通过大量的INSERT操作建立起来的,然后在没有进一步修改的情况下反复查询,在最后一次INSERT之后、第一次查询之前运行 &quot;优化 &quot;通常是一个好主意。</target>
        </trans-unit>
        <trans-unit id="0f704787571a999cc9c3b84bb71144a5bcf64e37" translate="yes" xml:space="preserve">
          <source>In both cases, the split amalgamation can be obtained by substituting &quot;sqlite3-all.c&quot; for &quot;sqlite3.c&quot; as the make target.</source>
          <target state="translated">在这两种情况下,将 &quot;sqlite3-all.c &quot;替换为 &quot;sqlite3.c &quot;作为make目标,就可以得到拆分合并。</target>
        </trans-unit>
        <trans-unit id="fc2950d0c83c287a896b8aadaea3a0c15a77bfa3" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">简而言之，sqlite3_wal_checkpoint（D，X）导致&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的数据库 X的&lt;a href=&quot;../wal&quot;&gt;预写日志中&lt;/a&gt;的内容被传输到数据库文件中，并且预写日志被重置。有关更多信息，请参见&lt;a href=&quot;../wal#ckpt&quot;&gt;检查点&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="05e7a053b7377f3e594b4b5661cacef3a8037473" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">简而言之，sqlite3_wal_checkpoint（D，X）导致&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的数据库 X的&lt;a href=&quot;wal&quot;&gt;预写日志中&lt;/a&gt;的内容被传输到数据库文件中，并且预写日志被重置。有关更多信息，请参见&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="9c00ece9c1ea98470c62a3e9e8dcd9514aa371cf" translate="yes" xml:space="preserve">
          <source>In brief, the CPU performance of SQLite is measured as follows:</source>
          <target state="translated">简单来说,SQLite的CPU性能测评如下。</target>
        </trans-unit>
        <trans-unit id="9e64879e9d401b77adebcff06d6d47d07d757ab4" translate="yes" xml:space="preserve">
          <source>In cases where it is complicated, the complications in applying a changeset lie in conflict resolution. Refer to the API documentation linked above for details.</source>
          <target state="translated">在复杂的情况下,应用变化集的复杂性在于解决冲突。详情请参考上面链接的API文档。</target>
        </trans-unit>
        <trans-unit id="0d808e9f43de5ebbcabce2337be4b9dd05f38065" translate="yes" xml:space="preserve">
          <source>In cases where two or more phrase instances overlap (share one or more tokens in common), a single open and close marker is inserted for each set of overlapping phrases. For example:</source>
          <target state="translated">在两个或多个短语实例重叠的情况下(有一个或多个共同的标记),为每一组重叠的短语插入一个开闭标记。例如:</target>
        </trans-unit>
        <trans-unit id="c541beea5651ea9308221a19ef6bad8134493156" translate="yes" xml:space="preserve">
          <source>In column mode, each record is shown on a separate line with the data aligned in columns. For example:</source>
          <target state="translated">在列模式下,每条记录都显示在单独的一行上,数据按列排列。例如:</target>
        </trans-unit>
        <trans-unit id="27dcedbb38ae9d16b71fde759bf65bb67ce0f587" translate="yes" xml:space="preserve">
          <source>In common use, SQLite databases tend to range in size from a few kilobytes to a few gigabytes, though terabyte-size SQLite databases are known to exist in production.</source>
          <target state="translated">在通常的使用中,SQLite数据库的大小往往从几千字节到几千兆字节不等,尽管已知生产中存在TB大小的SQLite数据库。</target>
        </trans-unit>
        <trans-unit id="15ec9746d32bfb65e8d0e42717374e59fcc87690" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil is a single standalone binary which is installed by putting it on $PATH. That one binary contains all the functionality of core Git and also GitHub and/or GitLab. It manages a community server with wiki, bug tracking, and forums, provides packaged downloads for consumers, login managements, and so forth, with no extra software required.</source>
          <target state="translated">相比之下,Fossil 是一个独立的二进制文件,只要把它放在 $PATH 上就可以安装。这一个二进制文件包含了核心 Git 的所有功能,也包含了 GitHub 和/或 GitLab。它管理着一个包含 wiki、bug 跟踪和论坛的社区服务器,为消费者提供打包下载、登录管理等等,不需要额外的软件。</target>
        </trans-unit>
        <trans-unit id="a51fb2bb312c4e04f9b038dff963c7e47c882987" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil users only need to think about their working directory and the check-in they are working on. That is 60% less distraction. Every developer has a finite number of brain-cycles. Fossil requires fewer brain-cycles to operate, thus freeing up intellectual resources to focus on the software under development.</source>
          <target state="translated">相比之下,Fossil用户只需要考虑自己的工作目录和正在进行的签到。这就减少了60%的分心。每个开发者的脑力循环是有限的。Fossil需要更少的脑循环来操作,从而释放出智力资源,专注于开发中的软件。</target>
        </trans-unit>
        <trans-unit id="0fcdb16d38afda3fa9a7a2e8625220ffc33d6191" translate="yes" xml:space="preserve">
          <source>In either case, if performance problems do arise in an SQLite application those problems can often be resolved by adding one or two &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements to the schema or perhaps running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; one time and without having to touch a single line of application code. But if a performance problem comes up in a custom or pile-of-files format, the fix will often require extensive changes to application code to add and maintain new indices or to extract information using different algorithms.</source>
          <target state="translated">无论哪种情况，如果在SQLite应用程序中确实出现性能问题，通常可以通过向架构中添加一个或两个&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句或运行一次&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;而无需触摸任何一行应用程序代码来解决这些问题。但是，如果以自定义或文件堆格式出现性能问题，则此修复程序通常需要对应用程序代码进行大量更改，以添加和维护新索引或使用不同算法提取信息。</target>
        </trans-unit>
        <trans-unit id="25aa68ecfd2b0c4f0ec2db607f906e4651bce4ef" translate="yes" xml:space="preserve">
          <source>In every case, the pager cache size was adjusted to keep the amount of cache memory at about 2MB. For example, a 2000 page cache was used for 1024 byte pages and a 31 page cache was used for 65536 byte pages. The BLOB values were read in a random order.</source>
          <target state="translated">在每一种情况下,都对寻呼机缓存大小进行了调整,使缓存内存量保持在2MB左右。例如,2000页的缓存用于1024字节的页面,31页的缓存用于65536字节的页面。BLOB值的读取顺序是随机的。</target>
        </trans-unit>
        <trans-unit id="cf40b39d63a8fb0ce771e83c7921ec57173f92f8" translate="yes" xml:space="preserve">
          <source>In extreme cases, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors, rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">在极端情况下，请考虑使用&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;选项编译SQLite，然后通过&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;）接口为SQLite提供固定的内存块以用作其堆。这将防止恶意SQL通过使用过多的内存来执行拒绝服务攻击。如果（例如）提供了5 MB的内存供SQLite使用，那么一旦消耗了这么多内存，SQLite将开始返回SQLITE_NOMEM错误，而不是占用应用程序其他部分所需的内存。这也将SQLite的内存沙箱化，以使应用程序其他部分的写后写错误不会对SQLite造成问题，反之亦然。</target>
        </trans-unit>
        <trans-unit id="b60127a70276716ca6ce96b164af1caff22c34ff" translate="yes" xml:space="preserve">
          <source>In fairness to PostgreSQL, it started thrashing on this test. A knowledgeable administrator might be able to get PostgreSQL to run a lot faster here by tweaking and tuning the server a little.</source>
          <target state="translated">为了公平起见,PostgreSQL在这次测试中开始暴走。一个知识渊博的管理员也许可以通过调整一下服务器,让PostgreSQL运行得更快。</target>
        </trans-unit>
        <trans-unit id="776b2a0854afad2e6c812aae004c09f148d516c9" translate="yes" xml:space="preserve">
          <source>In fairness, having a built-in implementation of printf() also comes with some disadvantages. To wit:</source>
          <target state="translated">平心而论,内置printf()的实现也有一些缺点。大意是:</target>
        </trans-unit>
        <trans-unit id="c2fda1dfe98bf18ac7aa5572676942f62e5e1fe2" translate="yes" xml:space="preserve">
          <source>In first form, if the main database has already been created, then this pragma returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le' (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If the main database has not already been created, then the value returned is the text encoding that will be used to create the main database, if it is created by this session.</source>
          <target state="translated">在第一种形式中,如果主数据库已经创建,那么这个pragma将返回主数据库使用的文本编码,即 &quot;UTF-8&quot;、&quot;UTF-16le&quot;(little-endian UTF-16编码)或 &quot;UTF-16be&quot;(big-endian UTF-16编码)中的一种。如果主数据库还没有被创建,那么返回的值是将用于创建主数据库的文本编码,如果主数据库是由这个会话创建的话。</target>
        </trans-unit>
        <trans-unit id="b4265b09e5ee96a8a7b2a30c889a0bcc8a3fb773" translate="yes" xml:space="preserve">
          <source>In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number.</source>
          <target state="translated">在格式 4、7 和 10 中,小数秒值 SS.SSS 可以在小数点后有一个或多个数字。在例子中显示的是三位数字,因为只有前三位数字对结果很重要,但输入字符串可以有更少或更多的三位数字,日期/时间函数仍将正确运行。同样,格式12显示的是10位有意义的数字,但日期/时间函数将真正接受表示Julian日数所需的任何数字或少数数字。</target>
        </trans-unit>
        <trans-unit id="af29b68f8112f5b3ba3c7546feb616bd5c5cfef7" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as a floating point value.</source>
          <target state="translated">按照&lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601的&lt;/a&gt;要求，在格式5到7中，&amp;ldquo; T&amp;rdquo;是分隔日期和时间的文字字符。仅指定时间的格式8到10假定日期为2000-01-01。格式11（字符串&amp;ldquo; now&amp;rdquo;）将转换为当前日期和时间，该日期和时间是从所使用的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xCurrentTime方法获得的。日期和时间函数的'now'参数对于同一&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中的多次调用始终返回完全相同的值。&lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;使用世界标准时间（UTC）&lt;/a&gt;。格式12是&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;儒略日数字，&lt;/a&gt;表示为浮点值。</target>
        </trans-unit>
        <trans-unit id="f289b58633d51c42244b9615eefef812e48059b3" translate="yes" xml:space="preserve">
          <source>In general, you can do anything with a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that can be done with an ordinary table, except that you cannot create indices or triggers on a virtual table. Some virtual table implementations might impose additional restrictions. For example, many virtual tables are read-only.</source>
          <target state="translated">通常，除了不能在虚拟表上创建索引或触发器之外，您可以使用&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;执行任何操作，而该操作可以使用普通表完成。某些虚拟表实现可能会施加其他限制。例如，许多虚拟表是只读的。</target>
        </trans-unit>
        <trans-unit id="eeca88e5ce04c05464f766d95ff0eeb5cfc7eabb" translate="yes" xml:space="preserve">
          <source>In hindsight, we should not have tried to make SQLite accept MySQL 3.x syntax, and should have never allowed double-quoted string literals. However, there are countless applications that make use of double-quoted string literals and so we continue to support that capability to avoid breaking legacy.</source>
          <target state="translated">事后看来,我们不应该试图让SQLite接受MySQL 3.x语法,也不应该允许双引号字符串字面。然而,有无数的应用程序使用双引号字符串字面,因此我们继续支持这种能力,以避免打破传统。</target>
        </trans-unit>
        <trans-unit id="f3caa4201cfb419be724f72954ef422185458de8" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">在默认配置下，SQLite API例程返回30个整数&lt;a href=&quot;../rescode&quot;&gt;结果代码之一&lt;/a&gt;。但是，经验表明，这些结果代码中的许多结果都过于粗糙。他们没有提供程序员可能想要的那样多的问题信息。为了解决这个问题，较新版本的SQLite（版本3.3.8 2006-10-09和更高版本）包括对其他结果代码的支持，这些结果代码提供有关错误的更详细信息。这些&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;使用&lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt; API 在每个数据库连接的基础上启用或禁用。或者，可以使用&lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;获得最新错误的扩展代码。</target>
        </trans-unit>
        <trans-unit id="3039a66b6632d9561c27b79f80cd7bfba4d1c329" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">在默认配置下，SQLite API例程返回30个整数&lt;a href=&quot;rescode&quot;&gt;结果代码之一&lt;/a&gt;。但是，经验表明，这些结果代码中的许多结果都过于粗糙。他们没有提供程序员可能想要的那样多的问题信息。为了解决这个问题，较新版本的SQLite（版本3.3.8 2006-10-09和更高版本）包括对其他结果代码的支持，这些结果代码提供有关错误的更详细信息。这些&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;使用&lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt; API 在每个数据库连接的基础上启用或禁用。或者，可以使用&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;获得最新错误的扩展代码。</target>
        </trans-unit>
        <trans-unit id="c851426635cb37e8f1ffc6284cb9e22ec511a9f4" translate="yes" xml:space="preserve">
          <source>In keeping with the pile-of-files theme, OpenDocument stores all slide content in a single big XML file named &quot;content.xml&quot;. LibreOffice reads and parses this entire file just to display the first slide. LibreOffice also seems to read all images into memory as well, which makes sense seeing as when the user does &quot;File/Save&quot; it is going to have to write them all back out again, even though none of them changed. The net effect is that start-up is slow. Double-clicking an OpenDocument file brings up a progress bar rather than the first slide. This results in a bad user experience. The situation grows ever more annoying as the document size increases.</source>
          <target state="translated">为了与文件堆主题保持一致,OpenDocument将所有幻灯片内容存储在一个名为 &quot;content.xml &quot;的大XML文件中。LibreOffice读取和解析这整个文件只是为了显示第一张幻灯片。LibreOffice似乎也会把所有的图片读到内存中,这是有道理的,因为当用户进行 &quot;文件/保存 &quot;时,它将不得不再次把它们全部写回来,即使它们都没有改变。最终的效果是启动速度很慢。双击一个OpenDocument文件会弹出一个进度条,而不是第一张幻灯片。这导致了糟糕的用户体验。随着文件大小的增加,这种情况越来越烦人。</target>
        </trans-unit>
        <trans-unit id="c55972e777545acb2431d05db4c4023b23be4d2b" translate="yes" xml:space="preserve">
          <source>In many cases, method (1) above is the best approach. It does not add extra data to the FTS index or require FTS5 to query for multiple terms, so it is efficient in terms of disk space and query speed. However, it does not support prefix queries very well. If, as suggested above, the token &quot;first&quot; is substituted for &quot;1st&quot; by the tokenizer, then the query:</source>
          <target state="translated">在很多情况下,上述方法(1)是最好的方法。它不会给FTS索引增加额外的数据,也不需要FTS5查询多个术语,所以在磁盘空间和查询速度上都很高效。但是,它不能很好地支持前缀查询。如果按照上面的建议,用tokenizer将 &quot;first &quot;替换成 &quot;1st&quot;,那么查询。</target>
        </trans-unit>
        <trans-unit id="5d477280cde1f0cb61a1a86eeb18153043aeb432" translate="yes" xml:space="preserve">
          <source>In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</source>
          <target state="translated">In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</target>
        </trans-unit>
        <trans-unit id="a92a8e52f2222eb943cf97b12f1b58ee960571a6" translate="yes" xml:space="preserve">
          <source>In most SQL implementations, output columns of an aggregate query may only reference aggregate functions or columns named in the GROUP BY clause. It does not make good sense to reference an ordinary column in an aggregate query because each output row might be composed from two or more rows in the input table(s).</source>
          <target state="translated">在大多数SQL实现中,聚合查询的输出列只能引用聚合函数或GROUP BY子句中命名的列。在聚合查询中引用一个普通的列是没有意义的,因为每条输出行可能是由输入表中的两条或多条记录组成的。</target>
        </trans-unit>
        <trans-unit id="ebf21aed9282198e08f544c4b59f1cde35658d89" translate="yes" xml:space="preserve">
          <source>In most applications, the database page cache subsystem within SQLite uses more dynamically allocated memory than all other parts of SQLite combined. It is not unusual to see the database page cache consume over 10 times more memory than the rest of SQLite combined.</source>
          <target state="translated">在大多数应用程序中,SQLite内的数据库页面缓存子系统使用的动态分配内存比SQLite的所有其他部分加起来还要多。数据库页面缓存所消耗的内存是SQLite其他部分加起来的10倍以上,这种情况并不少见。</target>
        </trans-unit>
        <trans-unit id="ea5d93a0bdef6b6a869ec9bc6ec20416d6dd4af5" translate="yes" xml:space="preserve">
          <source>In most applications, the number of columns is small - a few dozen. There are places in the SQLite code generator that use algorithms that are O(N&amp;sup2;) where N is the number of columns. So if you redefine SQLITE_MAX_COLUMN to be a really huge number and you generate SQL that uses a large number of columns, you may find that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; runs slowly.</source>
          <target state="translated">在大多数应用程序中，列数很少-几十列。SQLite代码生成器中的某些地方使用的算法是O（N&amp;sup2;），其中N是列数。因此，如果将SQLITE_MAX_COLUMN重新定义为一个非常大的数字，并且生成使用大量列的SQL，则可能会发现&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;运行缓慢。</target>
        </trans-unit>
        <trans-unit id="5715db4d1b11556e8f8726b68f211a79da84d8fd" translate="yes" xml:space="preserve">
          <source>In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating a unique index in the database. (The exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and PRIMARY KEYs on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) Hence, the following schemas are logically equivalent:</source>
          <target state="translated">在大多数情况下，通过在数据库中创建唯一索引来实现UNIQUE和PRIMARY KEY约束。（例外是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表上的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;和PRIMARY KEY 。）因此，以下模式在逻辑上是等效的：</target>
        </trans-unit>
        <trans-unit id="5a1cd73f371732c3b6f817956ff2682bb7f1000a" translate="yes" xml:space="preserve">
          <source>In most cases, you will want to supplement the basic commands above with &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; appropriate for your application. Commonly used compile-time options include:</source>
          <target state="translated">在大多数情况下，您将需要使用适合您的应用程序的&lt;a href=&quot;compile&quot;&gt;编译时选项&lt;/a&gt;来补充上述基本命令。常用的编译时选项包括：</target>
        </trans-unit>
        <trans-unit id="97ef5a309f4aafbcba4ef803b72a915f31e696d6" translate="yes" xml:space="preserve">
          <source>In most contexts, the special &quot;rowid&quot; column of normal tables can also be called &quot;oid&quot; or &quot;_rowid_&quot;. However, only &quot;rowid&quot; works as the keyword in the CREATE TABLE statement.</source>
          <target state="translated">在大多数情况下,普通表的特殊 &quot;rowid &quot;列也可以称为 &quot;oid &quot;或&quot;_rowid_&quot;。但是,只有 &quot;rowid &quot;可以作为CREATE TABLE语句中的关键字。</target>
        </trans-unit>
        <trans-unit id="08bdbf2096af9fe45fd4ac595bd3e0c7bb6e8da7" translate="yes" xml:space="preserve">
          <source>In most other SQL database engines the datatype is associated with the table column that holds the data - with the data container. In SQLite 3.0, the datatype is associated with the data itself, not with its container. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Paul Graham&lt;/a&gt; in his book</source>
          <target state="translated">在大多数其他SQL数据库引擎中，数据类型与保存数据的表列相关联-与数据容器相关联。在SQLite 3.0中，数据类型与数据本身关联，而不与容器关联。&lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;保罗&amp;middot;格雷厄姆&lt;/a&gt;（Paul Graham）在他的书中</target>
        </trans-unit>
        <trans-unit id="9b4441386a86e2d230e048847afd960634eadb47" translate="yes" xml:space="preserve">
          <source>In normal cases, new content is appended to the WAL file until the WAL file accumulates about 1000 pages (and is thus about 4MB in size) at which point a checkpoint is automatically run and the WAL file is recycled. The checkpoint does not normally truncate the WAL file (unless the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt; is set). Instead, it merely causes SQLite to start overwriting the WAL file from the beginning. This is done because it is normally faster to overwrite an existing file than to append. When the last connection to a database closes, that connection does one last checkpoint and then deletes the WAL and its associated shared-memory file, to clean up the disk.</source>
          <target state="translated">在正常情况下，新内容会附加到WAL文件中，直到WAL文件累积约1000页（因此大小约为4MB），此时自动运行检查点并回收WAL文件。检查点通常不会截断WAL文件（除非设置了&lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit杂注&lt;/a&gt;）。相反，它仅使SQLite从头开始覆盖WAL文件。这样做是因为覆盖现有文件通常比添加文件快。与数据库的最后一个连接关闭时，该连接将执行最后一个检查点，然后删除WAL及其关联的共享内存文件，以清理磁盘。</target>
        </trans-unit>
        <trans-unit id="9b10dbf3c620afa11c457409454feda884f8c775" translate="yes" xml:space="preserve">
          <source>In older versions of SQLite, shared cache mode could not be used together with virtual tables. This restriction was removed in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10).</source>
          <target state="translated">在旧版本的SQLite中，共享缓存模式不能与虚拟表一起使用。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;版本3.6.17&lt;/a&gt;（2009-08-10）中删除了此限制。</target>
        </trans-unit>
        <trans-unit id="c0ec8617fee4e8f946bad89174a49f940e3f428d" translate="yes" xml:space="preserve">
          <source>In one test that indexed a large set of emails (1636 MiB on disk), the FTS index was 743 MiB on disk with detail=full, 340 MiB with detail=column and 134 MiB with detail=none.</source>
          <target state="translated">在一项对一大组邮件进行索引的测试中(磁盘上有1636 MiB),FTS索引在磁盘上有743 MiB,detail=full,340 MiB,detail=column,134 MiB,detail=none。</target>
        </trans-unit>
        <trans-unit id="79708a29f43e4b6af877ac3750b35c58a6cfa4a6" translate="yes" xml:space="preserve">
          <source>In order for an application to &lt;a href=&quot;fts5#extending_fts5&quot;&gt;add new extensions to FTS5&lt;/a&gt;, such as new tokenizers, the application needs a pointer to the &quot;fts5_api&quot; object.</source>
          <target state="translated">为了使应用程序向&lt;a href=&quot;fts5#extending_fts5&quot;&gt;FTS5添加新的扩展名&lt;/a&gt;，例如新的标记器，该应用程序需要一个指向&amp;ldquo; fts5_api&amp;rdquo;对象的指针。</target>
        </trans-unit>
        <trans-unit id="28a836bfad6faf09ee027032e5467aeee1a64f66" translate="yes" xml:space="preserve">
          <source>In order for the OR-by-UNION technique shown above to be useful, there must be an index available that helps resolve every OR-connected term in the WHERE clause. If even a single OR-connected term is not indexed, then a full table scan would have to be done in order to find the rowids generated by the one term, and if SQLite has to do a full table scan, it might as well do it on the original table and get all of the results in a single pass without having to mess with union operations and follow-on binary searches.</source>
          <target state="translated">为了使上面显示的OR-by-UNION技术有用,必须有一个索引可以帮助解析WHERE子句中的每一个OR连接项。如果连一个OR连接项都没有索引,那么就必须进行全表扫描,才能找到这一个项产生的rowids,如果SQLite必须进行全表扫描,还不如在原表上进行扫描,一次就能得到所有的结果,而不用再去搞联合操作和后续的二元搜索。</target>
        </trans-unit>
        <trans-unit id="eb3713c378b1d1ce3d9a0c47d48cd2eaea6cff83" translate="yes" xml:space="preserve">
          <source>In order to allow multiple threads to use the same database connection at the same time, SQLite must make extensive use of mutexes. And for this reason a new mutex subsystem as been added. The mutex subsystem as the following interface:</source>
          <target state="translated">为了允许多个线程同时使用同一个数据库连接,SQLite必须大量使用mutexes。为此,我们添加了一个新的mutex子系统。该mutex子系统为以下接口。</target>
        </trans-unit>
        <trans-unit id="2b5d71d84c9eba5a8b5eeb690db9b2671be986f0" translate="yes" xml:space="preserve">
          <source>In order to avoid this problem, instead of a single large buffer, input is passed to a streaming API functions by way of a callback function that the sessions module invokes to incrementally request input data as it is required. In all cases, a pair of API function parameters such as</source>
          <target state="translated">为了避免这个问题,输入不是单一的大缓冲区,而是通过回调函数的方式传递给流式API函数,会话模块在需要时调用该函数来递增请求输入数据。在所有情况下,一对API函数参数,如</target>
        </trans-unit>
        <trans-unit id="4b125f2963fbbbf781a2aacf5295274d0ac9b884" translate="yes" xml:space="preserve">
          <source>In order to calculate a documents score, the full-text query is separated into its component phrases. The bm25 score for document</source>
          <target state="translated">为了计算文档得分,全文查询被分离成其组成短语。文件的bm25得分</target>
        </trans-unit>
        <trans-unit id="7154e5ea3dd269ef8c7a3c815659cc160be40ee6" translate="yes" xml:space="preserve">
          <source>In order to change the mapping of the rank column for a single query, a term similar to either of the following is added to the WHERE clause of a query:</source>
          <target state="translated">为了改变单个查询的rank列的映射,在查询的WHERE子句中添加一个类似于以下任一术语。</target>
        </trans-unit>
        <trans-unit id="2abb792779e09d00b7b2cceff1ab43c73c0ae359" translate="yes" xml:space="preserve">
          <source>In order to create an FTS4 table that does not store a copy of the indexed documents at all, the content option should be set to an empty string. For example, the following SQL creates such an FTS4 table with three columns - &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;:</source>
          <target state="translated">为了创建一个完全不存储索引文档副本的FTS4表,内容选项应该设置为空字符串。例如,下面的SQL创建了这样一个有三列--&quot;a&quot;、&quot;b &quot;和 &quot;c &quot;的FTS4表。</target>
        </trans-unit>
        <trans-unit id="dfa1c414109c4c2ee027ceb1647c28553c0a4044" translate="yes" xml:space="preserve">
          <source>In order to create or modify an existing zip file, a &quot;zipfile&quot; virtual table must be created in the database schema. The CREATE VIRTUAL TABLE statement expects a path to the zip file as its only argument. For example, to write to zip file &quot;test.zip&quot; in the current directory, a zipfile table may be created using:</source>
          <target state="translated">为了创建或修改一个现有的 zip 文件,必须在数据库模式中创建一个 &quot;zipfile &quot;虚拟表。CREATE VIRTUAL TABLE 语句要求使用 zip 文件的路径作为唯一的参数。例如,要向当前目录下的zip文件 &quot;test.zip &quot;写入数据,可以使用以下语句创建一个zipfile表。</target>
        </trans-unit>
        <trans-unit id="46eb456df96a41735386e11e34c4d6e23c625078" translate="yes" xml:space="preserve">
          <source>In order to determine whether or not the database file has changed, SQLite uses a counter in the database header (in bytes 24 through 27) which is incremented during every change operation. SQLite saves a copy of this counter prior to releasing its database lock. Then after acquiring the next database lock it compares the saved counter value against the current counter value and erases the cache if the values are different, or reuses the cache if they are the same.</source>
          <target state="translated">为了确定数据库文件是否发生了变化,SQLite在数据库头中使用了一个计数器(字节24到27),这个计数器在每次变化操作时都会递增。SQLite在释放数据库锁之前,会保存这个计数器的副本。然后在获取下一个数据库锁后,它将保存的计数器值与当前的计数器值进行比较,如果数值不同,则清除缓存,如果数值相同,则重新使用缓存。</target>
        </trans-unit>
        <trans-unit id="c5338f8b41864bbeb0f4c2c2e58a285f7e7a5717" translate="yes" xml:space="preserve">
          <source>In order to gain experience with the main ideas surrounding asynchronous IO, this implementation is deliberately kept simple. Additional capabilities may be added in the future.</source>
          <target state="translated">为了获得围绕异步IO的主要思想的经验,这个实现刻意保持简单。将来可能会增加额外的功能。</target>
        </trans-unit>
        <trans-unit id="a809ecf69a6ad9ffe3bc78cfb9dbeacb5971a731" translate="yes" xml:space="preserve">
          <source>In order to guarantee that database files are always consistent, SQLite will occasionally ask the operating system to flush all pending writes to persistent storage then wait for that flush to complete. This is accomplished using the &lt;code&gt;fsync()&lt;/code&gt; system call under unix and &lt;code&gt;FlushFileBuffers()&lt;/code&gt; under Windows. We call this flush of pending writes a &quot;sync&quot;.</source>
          <target state="translated">为了确保数据库文件始终保持一致，SQLite有时会要求操作系统将所有未完成的写入刷新到持久性存储，然后等待该刷新完成。这是通过在Windows 下使用unix下的 &lt;code&gt;fsync()&lt;/code&gt; 系统调用和在Windows 下使用 &lt;code&gt;FlushFileBuffers()&lt;/code&gt; 来完成的。我们称此未完成写入为&amp;ldquo;同步&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="78171183b8bae18fcaabb772e335a2f85feaf3a5" translate="yes" xml:space="preserve">
          <source>In order to maintain backwards compatibility, this setting is ON by default. There are advantages to turning it off, and most applications will be unaffected if it is turned off. For that reason, all applications are encouraged to switch this setting off on every database connection as soon as that connection is opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3d52a785446942df482ef9658c77840bb31674" translate="yes" xml:space="preserve">
          <source>In order to maintain full backwards compatibility for legacy applications, the URI filename capability is disabled by default. URI filenames can be enabled or disabled using the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=1&lt;/a&gt; or &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=0&lt;/a&gt; compile-time options. The compile-time setting for URI filenames can be changed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,0) configuration calls. Regardless of the compile-time or start-time settings, URI filenames can be enabled for individual database connections by including the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; bit in the set of bits passed as the F parameter to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2(N,P,F,V)&lt;/a&gt;.</source>
          <target state="translated">为了保持对旧应用程序的完全向后兼容性，默认情况下禁用URI文件名功能。可以使用&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 1&lt;/a&gt;或&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 0&lt;/a&gt;编译时选项来启用或禁用URI文件名。可以在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;，1）或&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;，0）配置调用在开始时更改URI文件名的编译时设置。无论编译时间或启动时间设置如何，都可以通过将&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;位包含在作为F参数传递给&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（N，P，F，V）&lt;/a&gt;的位集中来为单个数据库连接启用URI文件名。。</target>
        </trans-unit>
        <trans-unit id="ee9ce9696c9f5b398459fe9fa5003d871b602ba2" translate="yes" xml:space="preserve">
          <source>In order to maximize compatibility between SQLite and other database engines, and so that the example above will work on SQLite as it does on other SQL database engines, SQLite supports the concept of &quot;type affinity&quot; on columns. The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required. Any column can still store any type of data. It is just that some columns, given the choice, will prefer to use one storage class over another. The preferred storage class for a column is called its &quot;affinity&quot;.</source>
          <target state="translated">为了最大限度地提高SQLite和其他数据库引擎之间的兼容性,使上面的例子在SQLite上能像在其他SQL数据库引擎上一样工作,SQLite在列上支持 &quot;类型亲和性 &quot;的概念。列的类型亲和性是指该列中存储的数据的推荐类型。这里的重要思想是,类型是推荐的,而不是要求的。任何列仍然可以存储任何类型的数据。只是有些列在有选择的情况下,会优先使用一种存储类而不是另一种。一个列的首选存储类被称为它的 &quot;亲和力&quot;。</target>
        </trans-unit>
        <trans-unit id="c4c58e4d4912a4704b0cbb27832e1afdc4578e5c" translate="yes" xml:space="preserve">
          <source>In order to port SQLite to a new operating system - an operating system not supported by default - the application must provide...</source>
          <target state="translated">为了将SQLite移植到新的操作系统--默认情况下不支持的操作系统--应用程序必须提供。</target>
        </trans-unit>
        <trans-unit id="9139039adfb729ff69195002226ce412be58a20b" translate="yes" xml:space="preserve">
          <source>In order to prevent the number of b-trees in the database from becoming too large (slowing down queries), smaller b-trees are periodically merged into single larger b-trees containing the same data. By default, this happens automatically within INSERT, UPDATE or DELETE statements that modify the full-text index. The 'automerge' parameter determines how many smaller b-trees are merged together at a time. Setting it to a small value can speed up queries (as they have to query and merge the results from fewer b-trees), but can also slow down writing to the database (as each INSERT, UPDATE or DELETE statement has to do more work as part of the automatic merging process).</source>
          <target state="translated">为了防止数据库中b树的数量变得过大(减慢查询速度),较小的b树会定期合并成包含相同数据的较大b树。默认情况下,这将在修改全文索引的INSERT、UPDATE或DELETE语句中自动发生。automerge &quot;参数决定了每次合并多少个较小的b树。将它设置为一个小值可以加快查询速度(因为它们必须查询和合并来自较少b-trees的结果),但也会减慢对数据库的写入速度(因为作为自动合并过程的一部分,每个INSERT、UPDATE或DELETE语句必须做更多的工作)。</target>
        </trans-unit>
        <trans-unit id="3d48be902e74206d36d33669d85fb41c800c7878" translate="yes" xml:space="preserve">
          <source>In order to provide portability between across operating systems, SQLite uses abstract object called the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Each VFS provides methods for opening, read, writing, and closing files on disk, and for other OS-specific task such as finding the current time, or obtaining randomness to initialize the built-in pseudo-random number generator. SQLite currently provides VFSes for unix (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; file) and Windows (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; file).</source>
          <target state="translated">为了提供跨操作系统的可移植性，SQLite使用了称为&lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;抽象对象。每个VFS提供用于打开，读取，写入和关闭磁盘上文件的方法，以及用于其他特定于OS的任务的方法，例如查找当前时间或获取随机性以初始化内置的伪随机数生成器。 SQLite当前为UNIX（在&lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;文件中）和Windows（在&lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt;文件中）提供VFS。</target>
        </trans-unit>
        <trans-unit id="31ad990efe0b69348774fca33a1caeca8003e9e6" translate="yes" xml:space="preserve">
          <source>In order to rebase a local changeset, the remote changeset must first be applied to the local database using sqlite3changeset_apply_v2() and the buffer of rebase information captured. Then:</source>
          <target state="translated">为了对本地的变更集进行重基,首先必须使用sqlite3changeset_apply_v2()将远程的变更集应用到本地数据库中,并捕获重基信息的缓冲区。然后。</target>
        </trans-unit>
        <trans-unit id="aa098185ca802c3d4bb821bfd07089d8121f87d8" translate="yes" xml:space="preserve">
          <source>In order to return data from the database to the user, for example as the results of a SELECT query, SQLite must at some point read data from the database file. Usually, data is read from the database file in aligned blocks of</source>
          <target state="translated">为了将数据库中的数据返回给用户,例如作为一个SELECT查询的结果,SQLite必须在某个时刻从数据库文件中读取数据。通常情况下,数据是以对齐的块从数据库文件中读取的。</target>
        </trans-unit>
        <trans-unit id="fbe7b2f0d6747492938cc0cedd14f11e91e462ca" translate="yes" xml:space="preserve">
          <source>In order to save space, this backing table may be omitted by setting the columnsize option to zero. For example:</source>
          <target state="translated">为了节省空间,可以通过将列大小选项设置为零来省略这个支持表。例如:</target>
        </trans-unit>
        <trans-unit id="1dc49d196adf92707040503b638c58b0d1b51283" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">为了成功，调用&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（D，S，P）&lt;/a&gt;时，数据库连接不得处于&lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;自动提交模式&lt;/a&gt;。如果已在模式S上打开读取事务，则数据库句柄必须没有活动语句（已传递给sqlite3_step（）的SELECT语句，但没有传递给sqlite3_reset（）或sqlite3_finalize（）的语句）。如果违反这些条件之一，或者模式S不存在，或者快照对象无效，则返回SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="4bcc91176e8c72eef945e65a5e94e40093e70723" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">为了成功，调用&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（D，S，P）&lt;/a&gt;时，数据库连接不得处于&lt;a href=&quot;get_autocommit&quot;&gt;自动提交模式&lt;/a&gt;。如果已在模式S上打开读取事务，则数据库句柄必须没有活动语句（已传递给sqlite3_step（）的SELECT语句，但没有传递给sqlite3_reset（）或sqlite3_finalize（）的语句）。如果违反这些条件之一，或者模式S不存在，或者快照对象无效，则返回SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="3885c40685a2b0fc9bd29a3371e31ed82a66178a" translate="yes" xml:space="preserve">
          <source>In order to use FTS5 instead of FTS3 or FTS4, applications usually require minimal modifications. Most of these fall into three categories - changes required to the CREATE VIRTUAL TABLE statement used to create the FTS table, changes required to SELECT queries used to execute queries against the table, and changes required to applications that use &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">为了使用FTS5代替FTS3或FTS4，应用程序通常需要进行最少的修改。其中大多数分为三类-用于创建FTS表的CREATE VIRTUAL TABLE语句所需的更改，用于执行对该表的查询的SELECT查询所需的更改以及使用&lt;a href=&quot;fts3#snippet&quot;&gt;FTS辅助功能的&lt;/a&gt;应用程序所需的更改。</target>
        </trans-unit>
        <trans-unit id="362a80a01b0db13fb3dac03d2ae8d3c5e2853e16" translate="yes" xml:space="preserve">
          <source>In order to use foreign key constraints in SQLite, the library must be compiled with neither &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined. If SQLITE_OMIT_TRIGGER is defined but SQLITE_OMIT_FOREIGN_KEY is not, then SQLite behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14) - foreign key definitions are parsed and may be queried using &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;, but foreign key constraints are not enforced. The &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command is a no-op in this configuration. If OMIT_FOREIGN_KEY is defined, then foreign key definitions cannot even be parsed (attempting to specify a foreign key definition is a syntax error).</source>
          <target state="translated">为了在SQLite中使用外键约束，必须在&lt;a href=&quot;compile#omit_foreign_key&quot;&gt;未定义SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt;或&lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER的情况下&lt;/a&gt;编译库。如果定义了SQLITE_OMIT_TRIGGER但未定义SQLITE_OMIT_FOREIGN_KEY，则SQLite的行为与&lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;版本3.6.19&lt;/a&gt;（2009-10-14）之前的行为相同-将解析外键定义，并可以使用&lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;对其进行查询，但不会强制执行外键约束。在此配置中，&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;命令是no-op。如果定义了OMIT_FOREIGN_KEY，则甚至无法解析外键定义（试图指定外键定义是语法错误）。</target>
        </trans-unit>
        <trans-unit id="2a10b918ff09134ab69409cf683db7b4a9557318" translate="yes" xml:space="preserve">
          <source>In order to use this command to delete a row, the text value 'delete' must be inserted into the special column with the same name as the table. The rowid of the row to delete is inserted into the rowid column. The values inserted into the other columns must match the values currently stored in the table. For example:</source>
          <target state="translated">为了使用这条命令删除一条记录,必须在与表同名的特殊列中插入文本值 &quot;delete&quot;。要删除的行的rowid被插入到rowid列中。插入到其他列中的值必须与当前存储在表中的值相匹配。例如:</target>
        </trans-unit>
        <trans-unit id="18acf9de092948631a77a8a7268e93e0863d7575" translate="yes" xml:space="preserve">
          <source>In ordinary indexes, there is exactly one entry in the index for every row in the table. In partial indexes, only some subset of the rows in the table have corresponding index entries. For example, a partial index might omit entries for which the column being indexed is NULL. When used judiciously, partial indexes can result in smaller database files and improvements in both query and write performance.</source>
          <target state="translated">在普通索引中,表中的每一行正好有一个索引条目。在部分索引中,表中只有部分子集的行有相应的索引条目。例如,部分索引可能会省略那些被索引的列是NULL的条目。如果明智地使用,部分索引可以使数据库文件更小,并改善查询和写入性能。</target>
        </trans-unit>
        <trans-unit id="2aff0a10aa915dae8ca55cc20203451ac3b580cc" translate="yes" xml:space="preserve">
          <source>In other words, an SQLite database can do everything that a pile-of-files or wrapped pile-of-files format can do, plus much more, and with greater lucidity. An SQLite database is a more versatile container than key/value filesystem or a ZIP archive. (For a detailed example, see the &lt;a href=&quot;affcase1&quot;&gt;OpenOffice case study&lt;/a&gt; essay.)</source>
          <target state="translated">换句话说，SQLite数据库可以完成文件堆或包装文件堆格式可以做的所有事情，而且功能更多，而且更加清晰。与键/值文件系统或ZIP存档相比，SQLite数据库是一种用途更广泛的容器。 （有关详细示例，请参阅&lt;a href=&quot;affcase1&quot;&gt;OpenOffice案例研究&lt;/a&gt;文章。）</target>
        </trans-unit>
        <trans-unit id="a0407b322bda5c84932b9210d6c9dd55dfaff1cd" translate="yes" xml:space="preserve">
          <source>In other words, if X begins a write transaction using &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; then issues one or more &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and/or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements, then those changes are visible to subsequent &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that are evaluated in database connection X. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements on a different database connection Y will show no changes until the X transaction commits. But &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements in X will show the changes prior to the commit.</source>
          <target state="translated">换句话说，如果X使用开始的写入事务&lt;a href=&quot;lang_transaction#immediate&quot;&gt;立即开始&lt;/a&gt;然后发出一个或多个&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，和/或&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句，那么这些改变都随后可见&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;，在数据库连接X.评价语句&lt;a href=&quot;lang_select&quot;&gt;选择&lt;/a&gt;在不同的发言在X事务提交之前，数据库连接Y不会显示任何更改。但是X中的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句将在提交之前显示更改。</target>
        </trans-unit>
        <trans-unit id="b76e19862dad40faf099a9e663056c35b57f6bbd" translate="yes" xml:space="preserve">
          <source>In other words, make the same sqlite3_test_control() call except change the last two parameters to zero.</source>
          <target state="translated">换句话说,进行同样的sqlite3_test_control()调用,只是将最后两个参数改为0。</target>
        </trans-unit>
        <trans-unit id="a943abceb2efdd003ead8aa4530811df4446fd2f" translate="yes" xml:space="preserve">
          <source>In other words, opening and using a database file that has two or more names results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">换句话说,打开和使用一个有两个或更多名字的数据库文件会导致未定义的行为,而且可能是不可取的。</target>
        </trans-unit>
        <trans-unit id="5f5d40599d0989dfe7615dba1f4690adcb6d4ca6" translate="yes" xml:space="preserve">
          <source>In other words, powersafe overwrite means that there is no &quot;collateral damage&quot; when a power loss occurs while writing. Only those bytes actually being written might be damaged.</source>
          <target state="translated">换句话说,powerafe overwrite意味着在写的过程中发生断电时,没有 &quot;附带损害&quot;。只有那些实际被写入的字节才可能被损坏。</target>
        </trans-unit>
        <trans-unit id="ebd1e3e7febed4c7b9b73c22b3802bc322206c02" translate="yes" xml:space="preserve">
          <source>In other words, since 2004 all SQLite releases have been backwards compatible, though not necessarily forwards compatible.</source>
          <target state="translated">换句话说,从2004年开始,所有的SQLite版本都是向后兼容的,尽管不一定是向前兼容。</target>
        </trans-unit>
        <trans-unit id="1f360548804fb547b2c55aa98cf2f1549c641a34" translate="yes" xml:space="preserve">
          <source>In other words, the session extension provides a facility for SQLite database files that is similar to the unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;patch&lt;/a&gt; utility program, or to the &quot;merge&quot; capabilities of version control systems such as &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;, &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;, or &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;.</source>
          <target state="translated">换句话说，会话扩展为SQLite数据库文件提供了一种工具，该工具与unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;修补&lt;/a&gt;程序实用程序或版本控制系统（如&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;，&lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;或&lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial）&lt;/a&gt;的&amp;ldquo;合并&amp;rdquo;功能类似。</target>
        </trans-unit>
        <trans-unit id="c9d46649fb7fd18d588f4a5f73a3e3c10dcafa53" translate="yes" xml:space="preserve">
          <source>In other words, unlinking or renaming an open database file results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">换句话说,取消链接或重命名一个打开的数据库文件会导致未定义的行为,而且可能是不可取的。</target>
        </trans-unit>
        <trans-unit id="a8fad5ad802fc08a8688a68301e637bb10e07021" translate="yes" xml:space="preserve">
          <source>In other words, you should call sqlite3_column_text(), sqlite3_column_blob(), or sqlite3_column_text16() first to force the result into the desired format, then invoke sqlite3_column_bytes() or sqlite3_column_bytes16() to find the size of the result. Do not mix calls to sqlite3_column_text() or sqlite3_column_blob() with calls to sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16() with calls to sqlite3_column_bytes().</source>
          <target state="translated">换句话说,应该先调用sqlite3_column_text()、sqlite3_column_blob()或sqlite3_column_text16()来强制将结果转换成所需的格式,然后调用sqlite3_column_bytes()或sqlite3_column_bytes16()来查找结果的大小。不要将调用sqlite3_column_text()或sqlite3_column_blob()与调用sqlite3_column_bytes16()混合使用,也不要将调用sqlite3_column_text16()与调用sqlite3_column_bytes()混合使用。</target>
        </trans-unit>
        <trans-unit id="456e92a6a9d74515a6d36409e4455702906122d6" translate="yes" xml:space="preserve">
          <source>In practical terms, what the powersafe write property means is that when the disk controller detects an impending power loss, it finishes writing whatever sector it is working on prior to parking the heads. It means that individual sector writes will complete once started, even if there is a power loss.</source>
          <target state="translated">在实际操作中,powerafe write属性的意思是,当磁盘控制器检测到即将断电时,它将在停放磁头之前完成它正在进行的任何扇区的写入。这意味着单个扇区的写入一旦开始就会完成,即使出现断电。</target>
        </trans-unit>
        <trans-unit id="9fe8084319ab239e87ac8042e3d629376c48f43e" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">实际上，元数据是在函数调用的函数调用之间保留的，这些函数参数是编译时常量，包括文字值和&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;以及由它们组成的表达式。</target>
        </trans-unit>
        <trans-unit id="553ff79ef31136314c6f3a02cf8b8c9de3d93346" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">实际上，元数据是在函数调用的函数调用之间保留的，这些函数参数是编译时常量，包括文字值和&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;以及由它们组成的表达式。</target>
        </trans-unit>
        <trans-unit id="235238a95713f71f096fe2094b1d8d70514424be" translate="yes" xml:space="preserve">
          <source>In precompiled SQLite libraries available on the website, the Unix versions are compiled with THREADSAFE turned off but the Windows versions are compiled with THREADSAFE turned on. If you need something different that this you will have to recompile.</source>
          <target state="translated">在网站上提供的预编译SQLite库中,Unix版本在编译时关闭了THREADSAFE,但Windows版本在编译时打开了THREADSAFE。如果你需要不同的东西,你将不得不重新编译。</target>
        </trans-unit>
        <trans-unit id="49d7b0c7067454bf2994ce5482f78c23710e1d3a" translate="yes" xml:space="preserve">
          <source>In prior discussion, it was assumed that each SQL statement is prepared once, evaluated, then destroyed. However, SQLite allows the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; to be evaluated multiple times. This is accomplished using the following routines:</source>
          <target state="translated">在前面的讨论中，假设每个SQL语句仅准备一次，评估然后销毁。但是，SQLite允许对同一条&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;进行多次评估。使用以下例程可以完成此操作：</target>
        </trans-unit>
        <trans-unit id="86c3b83aa53c8f50b7b8f707247a7f27be6c0dc8" translate="yes" xml:space="preserve">
          <source>In processing the query above, SQLite invokes the sumint callbacks as follows:</source>
          <target state="translated">在处理上述查询时,SQLite调用sumint回调如下。</target>
        </trans-unit>
        <trans-unit id="59cf5532e18c9ee34b181fd5de97a560addf74bf" translate="yes" xml:space="preserve">
          <source>In queries that are driven by a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, avoid unnecessary tests of the constraint named in the WHERE clause of the partial index, since we know that constraint must always be true.</source>
          <target state="translated">在由&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;驱动的查询中，请避免对部分索引的WHERE子句中命名的约束进行不必要的测试，因为我们知道约束必须始终为true。</target>
        </trans-unit>
        <trans-unit id="82246b58b2662ec98735d83b367a59b70f82fb40" translate="yes" xml:space="preserve">
          <source>In rollback mode, SQLite implements isolation by locking the database file and preventing any reads by other database connections while each write transaction is underway. Readers can be be active at the beginning of a write, before any content is flushed to disk and while all changes are still held in the writer's private memory space. But before any changes are made to the database file on disk, all readers must be (temporally) expelled in order to give the writer exclusive access to the database file. Hence, readers are prohibited from seeing incomplete transactions by virtue of being locked out of the database while the transaction is being written to disk. Only after the transaction is completely written and synced to disk and commits are the readers allowed back into the database. Hence readers never get a chance to see partially written changes.</source>
          <target state="translated">在回滚模式下,SQLite通过锁定数据库文件,并在每个写事务进行时防止其他数据库连接的任何读取来实现隔离。读取器可以在写入开始时,在任何内容被刷新到磁盘之前,并且当所有的更改仍然保存在写入器的私有内存空间中时,读取器是活跃的。但是在对磁盘上的数据库文件进行任何修改之前,所有的读取器必须(暂时)被驱逐,以便让写入者独占数据库文件。因此,在事务写入磁盘时,由于被锁定在数据库之外,禁止读者看到不完整的事务。只有在事务完全写入磁盘并同步到磁盘并提交之后,读者才被允许回到数据库中。因此读者永远没有机会看到部分写入的更改。</target>
        </trans-unit>
        <trans-unit id="068d2699f531d0825115d300a0cccce10e48a71e" translate="yes" xml:space="preserve">
          <source>In spite of the disadvantages, the developers believe that having a built-in printf() implementation inside of SQLite is a net positive.</source>
          <target state="translated">尽管存在缺点,但开发者认为在SQLite内部有一个内置的printf()实现是一个积极的因素。</target>
        </trans-unit>
        <trans-unit id="cf039b1afa32ebe62123ae1292d3fdd466d22e3b" translate="yes" xml:space="preserve">
          <source>In step 2 of the procedure above, the database file is not locked before it is read from. This is the only exception to the locking rules described in section</source>
          <target state="translated">在上述过程的第2步中,数据库文件在被读取之前没有被锁定。这是在第2步中描述的锁定规则的唯一例外。</target>
        </trans-unit>
        <trans-unit id="8ea8892717935eea12390eaf98af13ff334785db" translate="yes" xml:space="preserve">
          <source>In summary then, any query with aggregate functions is implemented by two loops. The first loop scans the input table and computes aggregate information into buckets and the second loop scans through all the buckets to compute the final result.</source>
          <target state="translated">那么总的来说,任何带有聚合函数的查询都是由两个循环来实现的。第一个循环扫描输入表,并将聚合信息计算到桶中,第二个循环扫描所有桶,计算最终结果。</target>
        </trans-unit>
        <trans-unit id="2fe8cccc0c3831ee16f379b0a96fc3ebe090262e" translate="yes" xml:space="preserve">
          <source>In summary, the claim of this essay is that using SQLite as a container for an application file format like OpenDocument and storing lots of smaller objects in that container works out much better than using a ZIP archive holding a few larger objects. To wit:</source>
          <target state="translated">总而言之,这篇文章的主张是,使用SQLite作为OpenDocument这样的应用文件格式的容器,并在这个容器中存储大量的小对象,比使用ZIP存档存放一些大对象的效果要好得多。大意是:</target>
        </trans-unit>
        <trans-unit id="14368b74fc6cabbc46f6b11af62f68ec319ac0f1" translate="yes" xml:space="preserve">
          <source>In support of the &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; goal for SQLite, the parser code generated by Lemon has no unreachable branches, and contains extra (compile-time selected) instrumentation useful for measuring test coverage.</source>
          <target state="translated">为了支持SQLite 的&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DC测试&lt;/a&gt;目标，Lemon生成的解析器代码没有不可达的分支，并且包含用于测量测试覆盖率的额外（选择的编译时）工具。</target>
        </trans-unit>
        <trans-unit id="aad3b77ed5e3adba0d4656a1d99071301ddd4bc1" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;http://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="translated">采用&amp;ldquo;化石三角洲&amp;rdquo;格式&lt;a href=&quot;http://fossil-scm.org&quot;&gt;-Fossil源代码管理系统&lt;/a&gt;用于blob三角洲的格式，或者</target>
        </trans-unit>
        <trans-unit id="30519768573ed5dd959ec460751bfce418bf4435" translate="yes" xml:space="preserve">
          <source>In the &quot;without ANALYZE&quot; case on the left, the NN algorithm chooses loop P (PLINK) as the outer loop because 4.9 is less than 5.2, resulting in path P-T which is algorithm-1. NN only looks at the single best choice at each step so it completely misses the fact that 5.2+4.4 makes a slightly cheaper plan than 4.9+4.8. But the N3 algorithm keeps track of the 5 best paths for a 2-way join, so it ends up selecting path T-P because of its slightly lower overall cost. Path T-P is algorithm-2.</source>
          <target state="translated">在左边的 &quot;没有ANALYZE &quot;的情况下,NN算法选择循环P(PLINK)作为外循环,因为4.9小于5.2,结果路径P-T是算法-1。NN只看每一步的单项最佳选择,所以它完全忽略了5.2+4.4比4.9+4.8做出的方案略微便宜。但是N3算法会跟踪2-way join的5条最佳路径,所以它最终选择路径T-P,因为它的总体成本略低。路径T-P是算法-2。</target>
        </trans-unit>
        <trans-unit id="88edd036016e74b41ab30f363489bc8baf2ff243" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt;, the application needs to tell the extension the location of a C-language array that contains the data for the table-valued function that the extension implements.</source>
          <target state="translated">在&lt;a href=&quot;carray&quot;&gt;CARRAY扩展程序中&lt;/a&gt;，应用程序需要告知扩展程序C语言数组的位置，该数组包含扩展程序实现的表值函数的数据。</target>
        </trans-unit>
        <trans-unit id="0673453ee376202611f58f23515a709feb8d4034" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, enhance the &quot;.mode&quot; command so that it restores the default column and row separators for modes &quot;line&quot;, &quot;list&quot;, &quot;column&quot;, and &quot;tcl&quot;.</source>
          <target state="translated">在&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;，增强&amp;ldquo; .mode&amp;rdquo;命令，以便它恢复模式&amp;ldquo; line&amp;rdquo;，&amp;ldquo; list&amp;rdquo;，&amp;ldquo; column&amp;rdquo;和&amp;ldquo; tcl&amp;rdquo;的默认列和行分隔符。</target>
        </trans-unit>
        <trans-unit id="c5b3d2f7e7ec64c2ea66a15e4b9de436ddc07a10" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH operator&lt;/a&gt; (which does the full-text search) needs to communicate details of matching entries to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; functions so that those functions can convert the details of the match into useful output.</source>
          <target state="translated">在&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;扩展中，&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH运算符&lt;/a&gt;（进行全文搜索）需要将匹配条目的详细信息传递给&lt;a href=&quot;fts3#snippet&quot;&gt;snippet（）&lt;/a&gt;，&lt;a href=&quot;fts3#offsets&quot;&gt;offsets（）&lt;/a&gt;和&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;函数，以便这些函数可以转换匹配项的细节。转换成有用的输出。</target>
        </trans-unit>
        <trans-unit id="7f5a2150475db6cefe817c8c9175290580ea2ad7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;json1&quot;&gt;JSON extension&lt;/a&gt;, fix the JSON validator so that it correctly rejects invalid backslash escapes within strings.</source>
          <target state="translated">在&lt;a href=&quot;json1&quot;&gt;JSON扩展名中&lt;/a&gt;，修复JSON验证程序，使其正确拒绝字符串中无效的反斜杠转义符。</target>
        </trans-unit>
        <trans-unit id="29cf2e016ded4e45037d7dd8bd42e21681c156af" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;, add extra sync operations to avoid the possibility of corruption following a power failure.</source>
          <target state="translated">在&lt;a href=&quot;rbu&quot;&gt;RBU扩展中&lt;/a&gt;，添加额外的同步操作以避免电源故障后损坏的可能性。</target>
        </trans-unit>
        <trans-unit id="11f2b4a17490be52b1b76c1ff6aa70a95cb65d46" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension, when rounding 64-bit floating point numbers to 32-bit for storage, always round in a direction that causes the bounding box to get larger.</source>
          <target state="translated">在&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;扩展中，将64位浮点数四舍五入为32位用于存储时，请始终沿导致边界框变大的方向四舍五入。</target>
        </trans-unit>
        <trans-unit id="240fef4158af161eb22e60a820c151dc84eafe1e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;, add the -uri option to the &quot;sqlite3&quot; TCL command used for creating new database connection objects.</source>
          <target state="translated">在&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口中&lt;/a&gt;，将-uri选项添加到用于创建新数据库连接对象的&amp;ldquo; sqlite3&amp;rdquo; TCL命令中。</target>
        </trans-unit>
        <trans-unit id="156e69c7f61ba1dcce1a1142af151766e801c151" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL language interface&lt;/a&gt;, &quot;@variable&quot; instead of &quot;$variable&quot; always binds as a blob.</source>
          <target state="translated">在&lt;a href=&quot;tclsqlite&quot;&gt;TCL语言界面中&lt;/a&gt;，&amp;ldquo; @ variable&amp;rdquo;而不是&amp;ldquo; $ variable&amp;rdquo;始终绑定为斑点。</target>
        </trans-unit>
        <trans-unit id="d3bfa67674bb524ce3387e6563f15051a77fe593" translate="yes" xml:space="preserve">
          <source>In the C programming language where &lt;b&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;||&lt;/code&gt;&lt;/b&gt; are &quot;short-circuit&quot; operators, MC/DC and branch coverage are very nearly the same thing. The primary difference is in boolean vector tests. One can test for any of several bits in bit-vector and still obtain 100% branch test coverage even though the second element of MC/DC - the requirement that each condition in a decision take on every possible outcome - might not be satisfied.</source>
          <target state="translated">在C编程语言中，&lt;b&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/b&gt;和&lt;b&gt; &lt;code&gt;||&lt;/code&gt; &lt;/b&gt;是&amp;ldquo;短路&amp;rdquo;运算符，MC / DC和分支覆盖范围几乎是同一件事。主要区别在于布尔向量测试。即使可能不满足MC / DC的第二个元素（决定中的每个条件都考虑所有可能结果的要求），也可以测试位向量中的任何几位，并且仍然获得100％的分支测试覆盖率。</target>
        </trans-unit>
        <trans-unit id="a49a291dae627f989ba703462ee2c7e1bcc8b060" translate="yes" xml:space="preserve">
          <source>In the C programming language, it is very easy to write code that has &quot;undefined&quot; or &quot;implementation defined&quot; behavior. That means that the code might work during development, but then give a different answer on a different system, or when recompiled using different compiler options. Examples of undefined and implementation-defined behavior in ANSI C include:</source>
          <target state="translated">在C语言编程中,很容易写出具有 &quot;未定义 &quot;或 &quot;实现定义 &quot;行为的代码。这意味着代码在开发过程中可能会工作,但在不同的系统上,或者使用不同的编译器选项重新编译时,会给出不同的答案。在ANSI C中,未定义和实现定义的行为的例子包括。</target>
        </trans-unit>
        <trans-unit id="c817a7331349197e219cdd351370db507b5f89c0" translate="yes" xml:space="preserve">
          <source>In the COPY command, backslash can now be used to escape a newline.</source>
          <target state="translated">在COPY命令中,现在可以使用反斜杠来转义换行。</target>
        </trans-unit>
        <trans-unit id="cb9f3cc234a2699a8be8b939bc81e4cd1e3c8028" translate="yes" xml:space="preserve">
          <source>In the Fossil full-text search system, documents that participate in the full-text search (wiki pages, tickets, check-ins, documentation files, etc) are tracked by a table called &quot;ftsdocs&quot; (&lt;u&gt;f&lt;/u&gt;ull &lt;u&gt;t&lt;/u&gt;ext &lt;u&gt;s&lt;/u&gt;earch &lt;u&gt;doc&lt;/u&gt;ument&lt;u&gt;s&lt;/u&gt;). As new documents are added to the repository, they are not indexed right away. Indexing is deferred until there is a search request. The ftsdocs table contains an &quot;idxed&quot; field which is true if the document has been indexed and false if not.</source>
          <target state="translated">在化石全文检索系统，参与的全文检索的文献（wiki页面，门票，检查插件，文档文件等）是由一个名为&amp;ldquo;ftsdocs&amp;rdquo;（表跟踪&lt;u&gt;˚F&lt;/u&gt; ULL &lt;u&gt;牛逼&lt;/u&gt;分机&lt;u&gt;小号&lt;/u&gt;目录操作搜索&lt;u&gt;文档&lt;/u&gt; ument &lt;u&gt;小号&lt;/u&gt;）。将新文档添加到资源库后，不会立即对其进行索引。索引将推迟到有搜索请求为止。ftsdocs表包含一个&amp;ldquo; idxed&amp;rdquo;字段，如果文档已被索引，则为true，否则为false。</target>
        </trans-unit>
        <trans-unit id="54570b346f4d608f2bbac12e4181cf27370c513d" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">在输入到&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;及其变体的SQL语句文本中，文字可以用与以下模板之一匹配的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;代替：</target>
        </trans-unit>
        <trans-unit id="2d198fd96a87b68a84840a27e15d7192fd58115f" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">在输入到&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;及其变体的SQL语句文本中，文字可以用与以下模板之一匹配的&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;代替：</target>
        </trans-unit>
        <trans-unit id="0bfef1786d8548ec0f82e3f4f67466b9d9c84839" translate="yes" xml:space="preserve">
          <source>In the TCL test harness, the crash simulation is done in a separate process. The main testing process spawns a child process which runs some SQLite operation and randomly crashes somewhere in the middle of a write operation. A special &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; randomly reorders and corrupts the unsynchronized write operations to simulate the effect of buffered filesystems. After the child dies, the original test process opens and reads the test database and verifies that the changes attempted by the child either completed successfully or else were completely rolled back. The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is used to make sure no database corruption occurs.</source>
          <target state="translated">在TCL测试工具中，崩溃模拟是在单独的过程中完成的。主要的测试过程会产生一个子进程，该子进程运行一些SQLite操作，并在写操作的中间随机崩溃。特殊的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;随机重新排序并破坏了不同步的写操作，以模拟缓冲文件系统的效果。子进程死亡后，原始测试过程将打开并读取测试数据库，并验证子进程尝试的更改是否成功完成或已完全回滚。该&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;INTEGRITY_CHECK &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;用来确保没有数据库损坏发生。</target>
        </trans-unit>
        <trans-unit id="2e83d8a255a88980125401cd881c484a48bd6dc6" translate="yes" xml:space="preserve">
          <source>In the TPC-H Q8 query, the setup costs are all negligible, all dependencies are between individual nodes, and there is no ORDER BY, GROUP BY, or DISTINCT clause. So for TPC-H Q8, the graph above is a reasonable representation of what needs to be computed. The general case involves a lot of extra complication, which for clarity is neglected in the remainder of this article.</source>
          <target state="translated">在TPC-H Q8查询中,设置成本都可以忽略不计,所有的依赖关系都在各个节点之间,而且没有ORDER BY、GROUP BY或者DISTINCT子句。所以对于TPC-H Q8来说,上面的图是需要计算的合理表示。一般情况下,涉及到很多额外的复杂情况,为了清楚起见,本文其余部分忽略了这一点。</target>
        </trans-unit>
        <trans-unit id="9f3539e13c22fa6c6ec2b58a1ccd7e90a2d77370" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句中。</target>
        </trans-unit>
        <trans-unit id="b6311a2e6a2d0640df13bf33c58d5ba4044c66ce" translate="yes" xml:space="preserve">
          <source>In the Windows OS driver, reacquire a SHARED lock if an attempt to acquire an EXCLUSIVE lock fails. Ticket #2354</source>
          <target state="translated">在 Windows OS 驱动程序中,如果获取 EXCLUSIVE 锁的尝试失败,则重新获取 SHARED 锁。Ticket #2354</target>
        </trans-unit>
        <trans-unit id="c812acc1f415592dcfc5eeb302d23caa6a39526f" translate="yes" xml:space="preserve">
          <source>In the above paragraph, the term &quot;equal&quot; means equal when values are compared using the rules &lt;a href=&quot;datatype3#comparisons&quot;&gt;specified here&lt;/a&gt;. The following clarifications apply:</source>
          <target state="translated">在上一段中，术语&amp;ldquo;等于&amp;rdquo;表示使用&lt;a href=&quot;datatype3#comparisons&quot;&gt;此处指定&lt;/a&gt;的规则比较值时等于&amp;ldquo;相等&amp;rdquo; 。以下澄清适用：</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">在上述。</target>
        </trans-unit>
        <trans-unit id="441e596237bc1ae031cea29bc5e12b44c88ed81c" translate="yes" xml:space="preserve">
          <source>In the above, &amp;lt;content&amp;gt; is replaced by the name of the content table. By default, &amp;lt;content_rowid&amp;gt; is replaced by the literal text &quot;rowid&quot;. Or, if the &quot;content_rowid&quot; option is set within the CREATE VIRTUAL TABLE statement, by the value of that option. &amp;lt;cols&amp;gt; is replaced by a comma-separated list of the FTS5 table column names. For example:</source>
          <target state="translated">在上面，&amp;lt;content&amp;gt;被内容表的名称替换。默认情况下，&amp;lt;content_rowid&amp;gt;被文字文本&amp;ldquo; rowid&amp;rdquo;替换。或者，如果在CREATE VIRTUAL TABLE语句中设置了&amp;ldquo; content_rowid&amp;rdquo;选项，则通过该选项的值进行设置。&amp;lt;cols&amp;gt;替换为FTS5表列名称的逗号分隔列表。例如：</target>
        </trans-unit>
        <trans-unit id="a2464dd3bf1c506de33685f476dfeec6d3c9f83a" translate="yes" xml:space="preserve">
          <source>In the above, the user creates the database schema (a single table - &quot;x1&quot;), and then uses the &quot;.expert&quot; command to analyze a query, in this case &quot;SELECT * FROM x1 WHERE a=? AND b&amp;gt;?&quot;. The shell tool recommends that the user create a new index (index &quot;x1_idx_000123a7&quot;) and outputs the plan that the query would use in &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; format. The user then creates an index with an equivalent schema and runs the analysis on the same query again. This time the shell tool does not recommend any new indexes, and outputs the plan that SQLite will use for the query given the existing indexes.</source>
          <target state="translated">在上面，用户创建数据库模式（单个表-&amp;ldquo; x1&amp;rdquo;），然后使用&amp;ldquo; .expert&amp;rdquo;命令分析查询，在这种情况下为&amp;ldquo; SELECT * FROM x1 WHERE a =？AND b&amp;gt;？ &amp;rdquo;。 Shell工具建议用户创建一个新索引（索引&amp;ldquo; x1_idx_000123a7&amp;rdquo;）并以&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;格式输出该查询将使用的计划。然后，用户使用等效的架构创建索引，并再次对同一查询运行分析。这次，shell工具不建议任何新索引，并在给定现有索引的情况下输出SQLite将用于查询的计划。</target>
        </trans-unit>
        <trans-unit id="c0edb5d51a3281366e0040cd06804f7b08ee3eaa" translate="yes" xml:space="preserve">
          <source>In the argments to &quot;rtree&quot; in the CREATE VIRTUAL TABLE statement, the names of the columns are taken from the first token of each argument. All subsequent tokens within each argument are silently ignored. This means, for example, that if you try to give a column a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; or add a constraint such as UNIQUE or NOT NULL or DEFAULT to a column, those extra tokens are accepted as valid, but they do not change the behavior of the rtree. In an RTREE virtual table, the first column always has a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of INTEGER and all other data columns have a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of NUMERIC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94df2ec8cdab4e4a1c3463eb8499a5bac9b92ebf" translate="yes" xml:space="preserve">
          <source>In the call above, pBuf is a pointer to a large, contiguous chunk of memory space that SQLite will use to satisfy all of its memory allocation needs. pBuf might point to a static array or it might be memory obtained from some other application-specific mechanism. szBuf is an integer that is the number of bytes of memory space pointed to by pBuf. mnReq is another integer that is the minimum size of an allocation. Any call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc(N)&lt;/a&gt; where N is less than mnReq will be rounded up to mnReq. mnReq must be a power of two. We shall see later that the mnReq parameter is important in reducing the value of &lt;b&gt;n&lt;/b&gt; and hence the minimum memory size requirement in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;.</source>
          <target state="translated">在上面的调用中，pBuf是指向大量连续内存空间的指针，SQLite将使用该内存空间来满足其所有内存分配需求。 pBuf可能指向静态数组，也可能是从其他一些特定于应用程序的机制获得的内存。 szBuf是一个整数，它是pBuf指向的内存空间的字节数。 mnReq是另一个整数，它是分配的最小大小。N小于mnReq的对&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（N）的&lt;/a&gt;任何调用将四舍五入为mnReq。 mnReq必须为2的幂。稍后我们将看到mnReq参数对于减小&lt;b&gt;n&lt;/b&gt;的值非常重要，因此对于&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson证明中&lt;/a&gt;的最小内存大小要求也很重要。</target>
        </trans-unit>
        <trans-unit id="90165ee71034491a4c0d9359bc73082f9488de28" translate="yes" xml:space="preserve">
          <source>In the call above, pMem is a pointer to an &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object that defines the interface to the application-specific memory allocator. The &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object is really just a structure containing pointers to functions to implement the various memory allocation primitives.</source>
          <target state="translated">在上面的调用中，pMem是指向&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;对象的指针，该对象定义了特定于应用程序的内存分配器的接口。所述&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;对象实际上只是含函数指针来实现各种存储器分配的原语的结构。</target>
        </trans-unit>
        <trans-unit id="c159dc37c192a0696adfe0ed4e91dc6c74c10ae1" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10e05d68bb770ad4b44c8424ff81a8fc9e69978" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890332a4e5fd5b1fbcf7ece72dd3f24eeb42de4e" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, whenever the word &quot;column&quot; is used in the foregoing text, one can substitute &quot;indexed expression&quot; (meaning a copy of the expression that appears in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement) and everything will work the same.</source>
          <target state="translated">对于&lt;a href=&quot;expridx&quot;&gt;表达式&lt;/a&gt;的索引，每当在前面的文本中使用单词&amp;ldquo; column&amp;rdquo;时，就可以替换&amp;ldquo; indexed expression&amp;rdquo;（表示出现在&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句中的表达式的副本），并且所有内容将相同。</target>
        </trans-unit>
        <trans-unit id="d6023ff2ef6625bf825c5177040f5f9d0c7e6eaa" translate="yes" xml:space="preserve">
          <source>In the case of sqlite3changeset_start_strm(), the xInput callback may be invoked by the sessions module at any point during the lifetime of the iterator. If such an xInput callback returns an error, the iterator enters an error state, whereby all subsequent calls to iterator functions immediately fail with the same error code as returned by xInput.</source>
          <target state="translated">在sqlite3changeset_start_strm()的情况下,xInput回调可以被session模块在迭代器生命周期内的任何时候调用。如果这样的xInput回调返回错误,迭代器就会进入错误状态,所有后续对迭代器函数的调用都会立即以xInput返回的相同错误代码失败。</target>
        </trans-unit>
        <trans-unit id="2c842ccec3d83bffac0868a71bae98e55882c42d" translate="yes" xml:space="preserve">
          <source>In the cases above, the values returned by the function affects the information stored in the database file. The values of functions in CHECK constraints determines which entries are valid for a table, and functions in the WHERE clause of a partial index or in an index on an expression compute values stored in the index b-tree. If any of these functions later returns a different value, then the database might no longer be well-formed. Hence, to avoid database corruption, only deterministic functions can be used in the contexts above.</source>
          <target state="translated">在上述情况下,函数返回的值会影响数据库文件中存储的信息。CHECK约束中的函数值决定了哪些条目对表是有效的,部分索引的WHERE子句或表达式上的索引中的函数计算存储在索引b树中的值。如果这些函数中的任何一个后来返回了一个不同的值,那么数据库可能不再是良好的形式。因此,为了避免数据库损坏,在上述情况下只能使用确定性函数。</target>
        </trans-unit>
        <trans-unit id="212f1ca207fd318cb7601421ea08bad1d38b37aa" translate="yes" xml:space="preserve">
          <source>In the command-line shell, use popen() instead of fopen() if the first character of the argument to the &quot;.output&quot; command is &quot;|&quot;.</source>
          <target state="translated">在命令行shell中,如果&quot;.output &quot;命令参数的第一个字符是&quot;|&quot;,则使用popen()代替fopen()。</target>
        </trans-unit>
        <trans-unit id="bd2d277ff0771ee506fb5065fe7a06ad8e377ea0" translate="yes" xml:space="preserve">
          <source>In the current implementation of SQLite, the SQL parser only works with UTF-8 text. So if you supply UTF-16 text it will be converted. This is just an implementation issue and there is nothing to prevent future versions of SQLite from parsing UTF-16 encoded SQL natively.</source>
          <target state="translated">在当前SQLite的实现中,SQL解析器只适用于UTF-8文本。因此,如果你提供UTF-16文本,它将被转换。这只是一个实现上的问题,并不能阻止未来版本的SQLite解析UTF-16编码的SQL。</target>
        </trans-unit>
        <trans-unit id="2904f602a19479b220a87ade171425cb57484f61" translate="yes" xml:space="preserve">
          <source>In the current implementation, a table is analyzed if and only if all of the following are true:</source>
          <target state="translated">在目前的实施中,如果且仅当以下所有条件为真时,才会对表进行分析。</target>
        </trans-unit>
        <trans-unit id="f2454c76bf66b1405ea30b83fd1ca60a2a98f0ef" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">在当前实现中，由于&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt;子句而删除冲突的行时，不会调用更新挂钩。使用&lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;删除行时，也不会调用更新挂钩。本段中定义的异常可能会在将来的SQLite版本中更改。</target>
        </trans-unit>
        <trans-unit id="fb481751cd63e35f2d57a7f24a37356fd4bf25b0" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">在当前实现中，由于&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt;子句而删除冲突的行时，不会调用更新挂钩。使用&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;删除行时，也不会调用更新挂钩。本段中定义的异常可能会在将来的SQLite版本中更改。</target>
        </trans-unit>
        <trans-unit id="6c3c5dcd56d182703694f79901fe613441a9864b" translate="yes" xml:space="preserve">
          <source>In the current row, the number of times the phrase appears in the column.</source>
          <target state="translated">在当前行中,该短语在列中出现的次数。</target>
        </trans-unit>
        <trans-unit id="d3116d32ea608324199d5e0469ef8b030b799865" translate="yes" xml:space="preserve">
          <source>In the diagram at the right, we show that the information that was held in user space is cleared when the lock is released. This used to be literally true for older versions of SQLite. But more recent versions of SQLite keep the user space information in memory in case it might be needed again at the start of the next transaction. It is cheaper to reuse information that is already in local memory than to transfer the information back from the operating system disk cache or to read it off of the disk drive again. Prior to reusing the information in user space, we must first reacquire the shared lock and then we have to check to make sure that no other process modified the database file while we were not holding a lock. There is a counter in the first page of the database that is incremented every time the database file is modified. We can find out if another process has modified the database by checking that counter. If the database was modified, then the user space cache must be cleared and reread. But it is commonly the case that no changes have been made and the user space cache can be reused for a significant performance savings.</source>
          <target state="translated">在右图中,我们显示了当锁被释放时,保存在用户空间中的信息会被清除。对于旧版本的SQLite来说,这曾经是字面上的事实。但更多的最新版本的SQLite将用户空间信息保留在内存中,以防在下一个事务开始时可能再次需要它。重用已经在本地内存中的信息比从操作系统磁盘缓存中转回信息或再次从磁盘驱动器中读取信息要便宜。在重用用户空间中的信息之前,我们必须首先重新获取共享锁,然后我们必须检查是否在我们没有持有锁的时候没有其他进程修改数据库文件。在数据库的第一页有一个计数器,每次数据库文件被修改时,这个计数器都会递增。我们可以通过检查该计数器来了解是否有其他进程修改了数据库。如果数据库被修改了,那么必须清除用户空间缓存,重新读取。但通常情况下,没有修改过,用户空间缓存可以重新使用,大大节省了性能。</target>
        </trans-unit>
        <trans-unit id="bc4afe67e993812e607ae27c7ab087c30151c22e" translate="yes" xml:space="preserve">
          <source>In the diagram, each of the 8 tables in the FROM clause of the query is identified by a large circle with the label of the FROM-clause term: N2, S, L, P, O, C, N1 and R. The arcs in the graph represent the estimated cost of computing each term assuming that the origin of the arc is in an outer loop. For example, the cost of running the S loop as an inner loop to L is 2.30 whereas the cost of running the S loop as an outer loop to L is 9.17.</source>
          <target state="translated">在图中,查询的FROM子句中的8张表中的每一张表都用一个大圆圈标识,并标明FROM-clause项的标签。图中的弧线表示假设弧线的原点在一个外循环中,计算每个术语的估计成本。例如,将S循环作为内循环运行到L的成本是2.30,而将S循环作为外循环运行到L的成本是9.17。</target>
        </trans-unit>
        <trans-unit id="395caf8810d6babac050840aec487ecca9bbc4bd" translate="yes" xml:space="preserve">
          <source>In the event of an operating system or power failure, the various combinations of file-system software and storage hardware available provide varying levels of guarantee as to the integrity of the data written to the file system just before or during the failure. The exact combination of IO operations that SQLite is required to perform in order to safely modify a database file depend on the exact characteristics of the target platform.</source>
          <target state="translated">在操作系统或电源故障的情况下,可用的文件系统软件和存储硬件的各种组合对故障前或故障期间写入文件系统的数据的完整性提供了不同程度的保证。为了安全地修改数据库文件,SQLite需要执行的IO操作的确切组合取决于目标平台的确切特性。</target>
        </trans-unit>
        <trans-unit id="fbf76308006177e994e0ad525f9e6c338bce580b" translate="yes" xml:space="preserve">
          <source>In the example above, all the rows for each partition are grouped together in the final output. This is because the PARTITION BY clause is a prefix of the ORDER BY clause on the overall query. But that does not have to be the case. A partition can be composed of rows scattered about haphazardly within the result set. For example:</source>
          <target state="translated">在上面的例子中,每个分区的所有记录都会在最后的输出中被归为一组。这是因为partition by子句是整体查询上的order by子句的前缀。但不一定要这样。分区可以由结果集中随意散落的行组成。比如说</target>
        </trans-unit>
        <trans-unit id="5cf1e8a43e9d63b712df3d7090fc5c9414ccb7c0" translate="yes" xml:space="preserve">
          <source>In the example above, each triple identifies the location of a token instance by rowid, column number (columns are numbered sequentially starting at 0 from left to right) and position within the column value (the first token in a column value is 0, the second is 1, and so on). Using this index, FTS5 is able to provide timely answers to queries such as &quot;the set of all documents that contain the token 'A'&quot;, or &quot;the set of all documents that contain the sequence 'Y Z'&quot;. The list of instances associated with a single token is called an &quot;instance-list&quot;.</source>
          <target state="translated">在上面的例子中,每个三元组通过rowid、列号(列号从左到右依次从0开始)和列值中的位置(列值中的第一个令牌为0,第二个为1,以此类推)来标识令牌实例的位置。利用该索引,FTS5能够及时回答诸如 &quot;包含令牌'A'的所有文档的集合&quot;,或 &quot;包含序列'Y Z'的所有文档的集合 &quot;等查询。与单个标记相关联的实例列表称为 &quot;实例列表&quot;。</target>
        </trans-unit>
        <trans-unit id="6670429b3f62749505c4b98851abdba99076dc7b" translate="yes" xml:space="preserve">
          <source>In the example above, if most purchase orders do not have a &quot;parent&quot; purchase order, then most parent_po values will be NULL. That means only a small subset of the rows in the purchaseorder table will be indexed. Hence the index will take up much less space. And changes to the original purchaseorder table will run faster since the po_parent index only needs to be updated for those exceptional rows where parent_po is not NULL. But the index is still useful for querying. In particular, if one wants to know all &quot;children&quot; of a particular purchase order &quot;?1&quot;, the query would be:</source>
          <target state="translated">在上面的例子中,如果大多数采购订单没有 &quot;父 &quot;采购订单,那么大多数parent_po值将是NULL。这意味着在采购订单表中只有一小部分的行会被索引。因此索引占用的空间将大大减少。而且对原始的purchaseorder表的更改会运行得更快,因为po_parent索引只需要更新那些parent_po不是NULL的特殊行。但是索引对于查询还是很有用的。特别是,如果想知道某个采购订单&quot;?1 &quot;的所有 &quot;子代&quot;,查询的结果是</target>
        </trans-unit>
        <trans-unit id="093d39a0dc19bc985afaed609f6ca65b1771f970" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.header on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.header off&quot; instead. (The &quot;.header off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">在上面的例子中,&quot;.header on &quot;行导致列标签被打印为输出的第一行。这意味着生成的CSV文件的第一行将包含列标签。如果不需要列标签,可以设置&quot;.header off &quot;来代替。(&quot;.header off &quot;的设置是默认的,如果之前没有打开页眉,可以省略。)</target>
        </trans-unit>
        <trans-unit id="19c364b4c4bd5bb78a54b1baeb3476ed5a370176" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.headers on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.headers off&quot; instead. (The &quot;.headers off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cd93c52fe5f9cca786dee67c9404fab91f9de8" translate="yes" xml:space="preserve">
          <source>In the example above, the window frame consists of all rows between the previous row (&quot;1 PRECEDING&quot;) and the following row (&quot;1 FOLLOWING&quot;), inclusive, where rows are sorted according to the ORDER BY clause in the window-defn (in this case &quot;ORDER BY a&quot;). For example, the frame for the row with (a=3) consists of rows (2, 'B', 'two'), (3, 'C', 'three') and (4, 'D', 'one'). The result of group_concat(b, '.') for that row is therefore 'B.C.D'.</source>
          <target state="translated">在上面的例子中,窗口框架由前一行(&quot;1 PRECEDING&quot;)和后一行(&quot;1 FOLLOWING&quot;)之间的所有行组成,包括在内,其中的行根据window-defn中的ORDER BY子句进行排序(本例中为 &quot;ORDER BY a&quot;)。例如,(a=3)行的框架由(2,'B','2'),(3,'C','3')和(4,'D','1')行组成。因此,该行的group_concat(b,'.')的结果是'B.C.D'。</target>
        </trans-unit>
        <trans-unit id="b3d6a23d97e4594c0776e73b100f4f0f95f7c245" translate="yes" xml:space="preserve">
          <source>In the example queries above, every row of the table being queried must be loaded off of the disk and examined, even if only a small percentage of the rows end up in the result. This can take a long time on a big table. To speed things up, SQLite can use an index.</source>
          <target state="translated">在上面的查询示例中,被查询表的每一条记录都必须从磁盘上加载并进行检查,即使只有一小部分记录最终出现在结果中。这在一个大表上可能会花费很长的时间。为了加快速度,SQLite可以使用索引。</target>
        </trans-unit>
        <trans-unit id="097fb65fd13aa3cb8c9440796ac79504d1b2d367" translate="yes" xml:space="preserve">
          <source>In the example, instead of a single sort of 7 elements, there are 5 sorts of one-element each and 1 sort of 2 elements for the case of fruit=='Orange'.</source>
          <target state="translated">在这个例子中,水果=='橙子'的情况下,不是单一的7个元素的排序,而是有5种各为一个元素的排序和1种2个元素的排序。</target>
        </trans-unit>
        <trans-unit id="28b65ff31e772aaf95fd7eecfcefa7c33d5a2c49" translate="yes" xml:space="preserve">
          <source>In the example, the values in the &quot;term&quot; column are all lower case, even though they were inserted into table &quot;ft&quot; in mixed case. This is because an fts4aux table contains the terms as extracted from the document text by the &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. In this case, since table &quot;ft&quot; uses the &lt;a href=&quot;fts3#tokenizer&quot;&gt;simple tokenizer&lt;/a&gt;, this means all terms have been folded to lower case. Also, there is (for example) no row with column &quot;term&quot; set to &quot;apple&quot; and column &quot;col&quot; set to 1. Since there are no instances of the term &quot;apple&quot; in column 1, no row is present in the fts4aux table.</source>
          <target state="translated">在该示例中，&amp;ldquo; term&amp;rdquo;列中的值均为小写字母，即使它们以混合大小写形式插入表&amp;ldquo; ft&amp;rdquo;中也是如此。这是因为fts4aux表包含由分&lt;a href=&quot;fts3#tokenizer&quot;&gt;词器&lt;/a&gt;从文档文本中提取的术语。在这种情况下，由于表&amp;ldquo; ft&amp;rdquo;使用&lt;a href=&quot;fts3#tokenizer&quot;&gt;简单的分词器&lt;/a&gt;，因此这意味着所有术语均已折叠为小写。另外，（例如）不存在将&amp;ldquo; term&amp;rdquo;列设置为&amp;ldquo; apple&amp;rdquo;且将&amp;ldquo; col&amp;rdquo;列设置为1的行。由于在第1列中没有术语&amp;ldquo; apple&amp;rdquo;的实例，因此fts4aux表。</target>
        </trans-unit>
        <trans-unit id="4d08492de7be0204d6bca6b75942d78b6a5e659c" translate="yes" xml:space="preserve">
          <source>In the examples above,</source>
          <target state="translated">在上面的例子中。</target>
        </trans-unit>
        <trans-unit id="de880219c17c8178404452e7a6a65a0e25a5ab03" translate="yes" xml:space="preserve">
          <source>In the examples above, the APPCOST table would be interrogated to find the edit distance coefficients. It is the presence of the &quot;edit_cost_table=&quot; parameter to the spellfix1 module name that causes editdist3() to be used in place of the built-in edit distance function. If APPCOST is an empty string, then the built-in Wagner edit-distance function is used.</source>
          <target state="translated">在上面的例子中,APPCOST表将被查询以找到编辑距离系数。正是由于spellfix1模块名中存在 &quot;edit_cost_table=&quot;参数,才导致editdist3()被用来代替内置的编辑距离函数。如果APPCOST是一个空字符串,那么就会使用内置的瓦格纳编辑距离函数。</target>
        </trans-unit>
        <trans-unit id="2400a1ee49a9dce2718b34cdfc5c379cec93c638" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3adc83f3d79277fad8353d570dcfc825d479731" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;.</source>
          <target state="translated">在表达&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ff8ef765e12ede160f30458a862b4edd37cec09" translate="yes" xml:space="preserve">
          <source>In the extreme case where the columns being indexed cover all columns of the PRIMARY KEY, the index will consist of only the columns being indexed. The ex25acde example above demonstrates this. Each entry in the ex25acde index consists of only the columns a, c, d, and e, in that order.</source>
          <target state="translated">在极端的情况下,如果被索引的列覆盖了PRIMARY KEY的所有列,索引将只由被索引的列组成。上面的ex25acde例子就证明了这一点。ex25acde索引中的每个条目只由a、c、d和e列组成,顺序如下。</target>
        </trans-unit>
        <trans-unit id="f9d2f7bcd7e33c3c61f03684e92a0123ee2c50c1" translate="yes" xml:space="preserve">
          <source>In the first case, when the table does not previously exist, the table is automatically created and the content of the first row of the input CSV file is used to determine the name of all the columns in the table. In other words, if the table does not previously exist, the first row of the CSV file is interpreted to be column names and the actual data starts on the second row of the CSV file.</source>
          <target state="translated">在第一种情况下,当表之前不存在时,表会自动创建,并使用输入的CSV文件第一行的内容来确定表中所有列的名称。换句话说,如果表之前不存在,CSV文件的第一行被解释为列名,实际数据从CSV文件的第二行开始。</target>
        </trans-unit>
        <trans-unit id="8cfb2ab353eeb9931ea61c166eef50db11918f37" translate="yes" xml:space="preserve">
          <source>In the following example, the window frame for each row consists of all rows from the current row to the end of the set, where rows are sorted according to &quot;ORDER BY a&quot;.</source>
          <target state="translated">在下面的例子中,每行的窗口框架由从当前行到集合末尾的所有行组成,其中行按照 &quot;ORDER BY a &quot;进行排序。</target>
        </trans-unit>
        <trans-unit id="ad3b432372161232b364559d85e3c83dbfa80ec8" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause anyway it sees fit:</source>
          <target state="translated">在下面的查询中,优化器可以自由地对FROM子句的表进行任何它认为合适的排序。</target>
        </trans-unit>
        <trans-unit id="213dce290e5c56de530174ae284660516d8c6333" translate="yes" xml:space="preserve">
          <source>In the future, this option may also disable other floating point functionality, for example the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double()&lt;/a&gt; API functions.</source>
          <target state="translated">将来，此选项可能还会禁用其他浮点功能，例如&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double（）&lt;/a&gt;，&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double（）&lt;/a&gt;，&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double（）&lt;/a&gt;和&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double（）&lt;/a&gt; API函数。</target>
        </trans-unit>
        <trans-unit id="dfaedc6be2b7553cc537d3ce90c362a4be2c9a84" translate="yes" xml:space="preserve">
          <source>In the latter query, the query plan must be &lt;a href=&quot;#option2&quot;&gt;option 2&lt;/a&gt;. Note that you must use the keyword &quot;CROSS&quot; in order to disable the table reordering optimization; INNER JOIN, NATURAL JOIN, JOIN, and other similar combinations work just like a comma join in that the optimizer is free to reorder tables as it sees fit. (Table reordering is also disabled on an outer join, but that is because outer joins are not associative or commutative. Reordering tables in OUTER JOIN changes the result.)</source>
          <target state="translated">在后一个查询中，查询计划必须是&lt;a href=&quot;#option2&quot;&gt;选项2&lt;/a&gt;。请注意，必须使用关键字&amp;ldquo; CROSS&amp;rdquo;才能禁用表重新排序优化。INNER JOIN，NATURAL JOIN，JOIN和其他类似的组合就像逗号联接一样工作，因为优化器可以根据需要自由对表进行重新排序。（在外部联接上也禁用表重新排序，但这是因为外部联接不具有关联性或可交换性。在OUTER JOIN中对表进行重新排序会更改结果。）</target>
        </trans-unit>
        <trans-unit id="db1ceb5581cb83e63561f68248a7b5044a5f4d90" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">在旧版界面中，返回值将为&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。使用&amp;ldquo; v2&amp;rdquo;界面，也可能会返回任何其他&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4f1e2e6a1b6e2882af269cc303fc56c8348c472" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">在旧版界面中，返回值将为&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;，&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;，&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;或&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。使用&amp;ldquo; v2&amp;rdquo;界面，也可能会返回任何其他&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e24ef81342a9cacce2edb83f3edc5fc97054dd2" translate="yes" xml:space="preserve">
          <source>In the previous query the fruit='Peach' constraint narrowed the result down to a single row. But the same technique works even if multiple rows are obtained. Suppose we looked up the price of Oranges instead of Peaches:</source>
          <target state="translated">在前面的查询中,fruit='Peach'约束条件将结果缩小到了一条记录。但是,即使获得多条记录,同样的技术也是有效的。假设我们查询的是橙子的价格,而不是桃子。</target>
        </trans-unit>
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">在前面的章节中,我们已经看到了如何从作为ZIP存档实现的键/值存储转移到一个只有三张表的简单SQLite数据库,可以为应用程序文件格式增加重要的功能。我们可以继续用新的表来增强模式,为了性能而添加索引,为了编程方便而添加触发器和视图,即使面对编程错误,也可以用约束来强制执行内容的一致性。进一步的增强想法包括:</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">在前文中,WHERE子句中的 &quot;type NOT IN ('object','array')&quot;项抑制了容器,只允许通过叶元素。这种方式也可以达到同样的效果。</target>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">在上面的查询中，如果t1和t2都大约有N行，则没有任何索引，查询将需要O（N * N）时间。另一方面，在表t2上创建索引需要O（NlogN）时间，然后使用该索引评估查询需要额外的O（NlogN）时间。在没有&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;信息的情况下，SQLite猜测N为一百万，因此它认为构造自动索引将是更便宜的方法。</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">在上面的查询中,我们大概会将第12区的精确边界的二进制BLOB描述绑定到&quot;:边界 &quot;参数上。</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">在上面的查询中,&quot;PARTITION BY c &quot;子句将结果集分成了三个分区。第一个分区有三条c=='1'的记录。第二个分区有两行c=='三',第三个分区有两行c=='二'。</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">在上面的查询中，&amp;ldquo; a&amp;rdquo;列是GROUP BY子句的一部分，因此输出的每一行都包含&amp;ldquo; a&amp;rdquo;的不同值之一。&amp;ldquo; c&amp;rdquo;列包含在&lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum（）&lt;/a&gt;聚合函数中，因此输出列是&amp;ldquo; a&amp;rdquo;具有相同值的行中所有&amp;ldquo; c&amp;rdquo;值的总和。但是，裸列&amp;ldquo; b&amp;rdquo;的结果是什么？答案是，&amp;ldquo; b&amp;rdquo;结果将是构成聚合的输入行之一中&amp;ldquo; b&amp;rdquo;的值。问题是您通常不知道哪个输入行用于计算&amp;ldquo; b&amp;rdquo;，因此在许多情况下，&amp;ldquo; b&amp;rdquo;的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">在上面的查询中,子查询 &quot;SELECT b FROM ex2 &quot;被评估,其结果被存储在一个临时表(实际上是一个临时索引)中,允许人们使用简单的二进制搜索来确定是否存在一个值ex2.b。一旦这个表被构造出来,就会运行外部查询,并对每一条潜在的结果行进行检查,看ex1.a是否包含在临时表中。只有当检查结果为真时,才会输出该行。</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">在上面的查询中,first_name和last_name列的值将对应于满足max(salary)条件的行。</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">在修改后的查询中,由一个联合程序实现的子查询计算 &quot;a &quot;的五个最新值。这五个值从共同程序传递到外部查询中,其中&quot; expensive_function()&quot;只在应用程序关心的特定行上被调用。</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">在第二个例子中,DO UPDATE子句中的表达式是 &quot;excluded.phonenumber &quot;的形式。前缀 &quot;excluded.&quot;导致 &quot;phonenumber &quot;指的是在没有冲突的情况下本应插入的phonenumber的值。因此,upsert的效果是插入一个Alice的phonenumber,如果不存在的话,或者用新的phonenumber覆盖Alice之前的任何phonenumber。</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">在左边的序列中,第二次插入将失败。在这种情况下,字符串'0'和'0.0'被视为数字,因为它们被插入到一个数字列中,但0==0.0违反了唯一性约束。然而,右手序列中的第二个插入是有效的。在这种情况下,常量0和0.0被视为字符串,这意味着它们是不同的。</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">在外壳程序中，当用户按下Control-C时调用&lt;b&gt;sqlite_interrupt（）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">在spellfix1算法中,cFrom是用户输入的文本,cTo是数据库中存在的正确拼写文本。editdist3算法的目标是确定用户输入的文本与字典文本的接近程度。</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">在sqlite shell中,现在打印初始启动时的版本号。</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">在sqlite shell中,将 &quot;Database opened READ ONLY &quot;信息打印到stderr而不是stdout。</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">在上面的语句中,由MATCH操作符生成的FTS3游标指针被送入carray()表值函数中,而不是其预定的接收方snippet()。carray()函数将指针视为指向整数数组的指针,并逐一返回每个整数,从而泄露了FTS3游标对象的内容。由于FTS3游标对象中包含了指向其他对象的指针,所以上面的语句将是一个指针泄漏。</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">在上面的模板中,NNN代表一个整数文字,VVV代表一个字母数字标识符。这些参数的值(也称为 &quot;主机参数名 &quot;或 &quot;SQL参数&quot;)可以使用这里定义的sqlite3_bind_*()例程来设置。</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">在基础&lt;a href=&quot;fileformat2&quot;&gt;文件格式中&lt;/a&gt;，每个rowid存储为一个&lt;a href=&quot;fileformat2#varint&quot;&gt;可变长度的整数&lt;/a&gt;。这意味着小的非负rowid值比大或负rowid值占用更少的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">在这种情况下，aConstraint []。op值与&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction（）&lt;/a&gt;为FUNCTION 返回的值相同。</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">在这种情况下,可以通过在t2(c)上创建一个索引来避免使用临时b树,如下所示。</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">在这种情况下,SQLite仍然会进行一次二进制搜索,找到索引的第一个条目,其中fruit='Orange'。然后它从索引中提取rowid,并使用该rowid通过二进制搜索查找原表条目,输出原表的价格。但是数据库引擎并没有退出,而是前进到索引的下一行,对下一个 fruit='Orange'条目重复这个过程。推进到索引(或表)的下一行比进行二进制搜索的成本要低得多,因为下一行通常与当前行位于同一个数据库页面上。事实上,与二进制搜索相比,前进到下一行的成本非常便宜,所以我们通常会忽略它。所以我们对这个查询的总成本的估计是3次二进制搜索。如果输出的行数为K,表中的行数为N,那么一般情况下,做这个查询的成本与(K+1)*logN成正比。</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">在这张图中,一个SQL语句(&quot;SELECT v FROM kv WHERE k=?1&quot;)被准备了一次。然后对于每个blob,将blob键值绑定到?1参数上,并对语句进行评估,提取blob内容。</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">在这个例子中,docs.name为 &quot;report-15 &quot;的条目的docs.body字段的内容将被发送到编辑器。编辑器返回后,结果将被写回 docs.body 字段。</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">在这个例子中,demo_data.boundary字段是为了持有对象的精确边界的某种二进制表示。R*Tree索引只持有对象的轴对齐的矩形边界。R*Tree边界只是真实对象边界的近似值。所以通常情况下,R*Tree索引被用来将搜索范围缩小到一个候选对象列表,然后对每个候选对象进行更详细和昂贵的计算,以发现候选对象是否真正符合搜索标准。</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">在这个例子中,rowids不是连续的,而是有序的。SQLite通常会创建从1开始的rowids,每增加一条记录就增加一条。但是如果删除了行,序列中就会出现空白。而且如果需要的话,应用程序可以控制分配的rowid,这样就不一定会在底部插入行。但是无论发生什么,rowid总是唯一的,并且严格按照升序排列。</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">在这个例子中,t2表被用于一个子查询,以翻译t1.b列的值。如果每个表都包含N条记录,SQLite预计子查询将运行N次,因此它会认为先在t2上构造一个自动的瞬时索引,然后使用该索引来满足子查询的N个实例,这样会更快。</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">在最后这个例子中,phonebook2条目只有在新插入的值的validDate比表中已有的条目更新时才会更新。如果表已经包含了一个具有相同名称和当前validDate的条目,那么WHERE子句就会导致DO UPDATE成为无操作。</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">在后一个表中,只有一个B-Tree,它使用 &quot;word &quot;列作为键,&quot;cnt &quot;列作为数据。(技术性:低级实现实际上将 &quot;word &quot;和 &quot;cnt &quot;都存储在B-Tree的 &quot;key &quot;区域。但除非你正在看数据库文件的低级字节编码,否则这个事实并不重要)。)因为只有一个B-Tree,&quot;word &quot;列的文本在数据库中只存储一次。此外,查询特定 &quot;单词 &quot;的 &quot;cnt &quot;值只需要对主B树进行一次二进制搜索,因为 &quot;cnt &quot;值可以直接从第一次搜索找到的记录中检索,而不需要对rowid进行第二次二进制搜索。</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">在这个查询中,&quot;x轴 &quot;和 &quot;y轴 &quot;CTE定义了Mandelbrot Set将被近似的点的网格。m(iter,cx,cy,x,y)&quot;CTE中的每一行都意味着在 &quot;iter &quot;迭代之后,从cx,cy开始的Mandelbrot迭代已经到达了x,y点。本例中的迭代次数被限制为28次(这严重限制了计算的分辨率,但对于低分辨率的ASCII艺术输出来说已经足够了)。m2(iter,cx,cy)&quot;CTE保存了从点cx,cy开始时达到的最大迭代次数。最后,&quot;a(t)&quot;CTE中的每一行都保存着一个字符串,这是输出ASCII-art的单行。最后的SELECT语句只是查询 &quot;a &quot;CTE,逐行检索所有的ASCII-art行。</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">在这个模式中,每张幻灯片没有决定其在演示文稿中的顺序的页码,而是有一个唯一的整数标识符,它与幻灯片的顺序出现的位置无关。幻灯片在演示文稿中的顺序由幻灯片标识符(slideIds)列表决定,该列表以文本字符串的形式存储在VERSION表的MANIFEST列中。由于VERSION表中允许有多个条目,这就意味着同一文档中可以存储多个演示文稿。</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">在这个系统中,歌曲表中的每个条目都需要映射到专辑表中的一个条目,艺术家和专辑的组合相同。</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">这样一来,新的指针传递接口似乎解决了SQLite中从一个扩展向另一个扩展传递指针值的所有安全问题。</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">在具有第四个参数的例程中，其值是参数中的字节数。需要明确的是：该值是&lt;u&gt;字节数&lt;/u&gt;在值中，而不是字符数中。如果sqlite3_bind_text（）或sqlite3_bind_text16（）的第四个参数为负，则字符串的长度为直到第一个零终止符的字节数。如果sqlite3_bind_blob（）的第四个参数为负，则行为未定义。如果为sqlite3_bind_text（）或sqlite3_bind_text16（）或sqlite3_bind_text64（）提供了非负第四个参数，则该参数必须是字节偏移量，假定字符串以NUL终止，则NUL终止符将出现在该字节偏移处。如果任何NUL字符出现在字节偏移量小于第四个参数的值的位置，则结果字符串值将包含嵌入的NUL。涉及带有嵌入式NUL的字符串的表达式的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="f5c0b6c1ce652bbe2a9ce301182f0e17dcf5f222" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occurs at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">在truncate journal模式下,事务的提交方式是将日志文件截断为零长度,而不是像DELETE模式那样删除日志文件(DELETE模式)或将头清零(PERSIST模式)。TRUNCATE模式与PERSIST模式有相同的优点,即包含日志文件和数据库的目录不需要更新。因此,截断一个文件通常比删除它更快。TRUNCATE还有一个好处,就是它后面不需要系统调用(如:fsync())来同步更改到磁盘上。如果这样做,可能会更安全。但是在许多现代文件系统中,truncate是一个原子和同步的操作,因此我们认为truncate在面对电源故障时通常是安全的。如果你不确定TRUNCATE是否会在你的文件系统上是同步和原子的,而且你的数据库在截断操作过程中发生断电或操作系统崩溃时,对你很重要,那么你可以考虑使用不同的日记模式。</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">在3.5.9版本中,上面的查询将返回一个名为 &quot;t1.a &quot;的单列。在3.6.0版本中,列名只是 &quot;a&quot;。</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">在非常旧的SQLite版本（版本3.7.11-2012-03-20之前）中，如果有任何待处理的查询，则ROLLBACK将失败，并显示错误代码&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。在较新版本的SQLite中，ROLLBACK将继续执行，并且挂起的语句通常会中止，从而导致它们返回&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;或&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt;错误。在SQLite版本3.8.8（2015-01-16）及更高版本中，只要ROLLBACK不修改数据库架构，待处理的读取将在ROLLBACK之后继续运行。</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">换句话说,我们有一个名为 &quot;examp &quot;的数据库表,表中有两列数据,分别名为 &quot;一 &quot;和 &quot;二&quot;。现在假设我们要在这个表中插入一条记录。像这样。</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">内存数据库</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">内存数据库和共享缓存。</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">如果使用&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;打开内存数据库，则它们可以使用&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;。如果使用未经修饰的&amp;ldquo;：memory：&amp;rdquo;名称指定内存数据库，则该数据库始终具有专用缓存，并且仅对最初打开该数据库的数据库连接可见。但是，可以通过两个或多个数据库连接打开相同的内存数据库，如下所示：</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">在每个标识符名称的某处加入一个数字。</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">在库中包含一个静态字符串,响应RCS &quot;ident &quot;命令,其中包含库的版本号。</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">不兼容的变化首先被覆盖,因为它们对维护者和程序员来说是最重要的。</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">CREATE TABLE AS和简单SELECT之间的结果集列名称不一致。机票&lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">将A.Rottmann的makefile补丁合并到LIBTOOL中。</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">错误的assert（）语句已删除。入住&lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">报告了不正确的列数据类型。门票&lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">与ORDER BY DESC联接的查询结果不正确。票证&lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">使用跳过提前优化时，查询结果不正确。门票&lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">在小于&lt;a href=&quot;rowvalue&quot;&gt;value&lt;/a&gt;的小于值运算符上的结果不正确。门票&lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="bfb28e75251bc4d83a52b5697560b9c1115b80bf" translate="yes" xml:space="preserve">
          <source>Increase the &lt;a href=&quot;limits#max_variable_number&quot;&gt;default upper bound&lt;/a&gt; on the number of &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; from 999 to 32766.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">将默认&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;分配大小从100字节增加到128字节。</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">将默认&lt;a href=&quot;malloc#lookaside&quot;&gt;后备&lt;/a&gt;大小从512,125增加到1200,100，因为这可以提供更好的性能，同时每个连接仅增加56KB的额外内存。内存敏感的应用程序可以在编译时，启动时或运行时恢复旧的默认设置。</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">将看前缓存行的默认大小从100增加到128字节。</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">将&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt;的默认值增加到50，并确保在所有更改架构的地方都可以使用它，以强制执行语句重试。</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">将&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;扩展名的最大&amp;ldquo;范围&amp;rdquo;值从6增加到30。</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">将数据库页面的最大尺寸从32KiB增加到64KiB。</target>
        </trans-unit>
        <trans-unit id="c023946d393ce520944a7e8848356e945bf33b16" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of database files to 281 TB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">将&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;的最大值从30增加到62（尽管默认值保持为10）。</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">将&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;的最大值从62增加到125。</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">在发出&lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt;错误之前，请将&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;的超时从1秒增加到10秒。</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">提高了对恶意破坏数据库运行的恶意SQL的鲁棒性。</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">将&lt;a href=&quot;c3ref/vfs&quot;&gt;VFS对象&lt;/a&gt;的版本号增加到3，并添加了用于进行完全覆盖测试的新方法xSetSysCall，xGetSysCall和xNextSysCall。</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">通过P2递增一个 &quot;约束计数器&quot;(P2可以是负值或正值)。如果P1为非零,则数据库约束计数器递增(延迟外键约束)。否则,如果P1为零,则递增语句计数器(即时外键约束)。</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version = X&lt;/a&gt;递增架构版本号，其中X比上面步骤2中找到的旧架构版本号大1。</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">递增P1的值，以便&lt;a href=&quot;opcode#Once&quot;&gt;一旦&lt;/a&gt;操作码在第一次运行时就跳转。</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">增量和持续更新</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">索引B树内部单元(头0x02)。</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">索引B树叶单元(头0x0a)。</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">索引B-树叶或内部细胞。</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">内部索引 (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">索引叶 (0x0a)</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">一个给定名称的参数的索引</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">表达式上的索引</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">使用&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;命令删除索引。</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">索引可以使用&lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt;和&lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">子键列不需要索引，但是它们几乎总是有益的。返回&lt;a href=&quot;#fk_basics&quot;&gt;第1节中&lt;/a&gt;的示例，每次应用程序从列表中删除一行时，</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">名称形式为&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;的索引用于在普通表上实现&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束。</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">通过使用&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;标志第三个参数，使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;创建的单个数据库连接可以选择参与或不参与共享缓存模式。使用这些标志中的任何一个都将覆盖&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;建立的全局共享缓存模式设置。最多只能使用一个标志。如果在&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的第三个参数中同时使用了SQLITE_OPEN_SHAREDCACHE和SQLITE_OPEN_PRIVATECACHE标志，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">shm头的各个字段,除了从WAL头复制的salt值之外,都是以主机的本机字节顺序的无符号整数。盐值是WAL头的精确拷贝,并以WAL文件使用的任何字节顺序排列。整数的大小可以是8、16、32或64位。下面是shm头的各个字段的详细分解。</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">各个子项可能是单个比较表达式，例如* a = 5 *或* x&amp;gt; y *，或者它们可以是LIKE或BETWEEN表达式，或者子项可以是AND连接子项的括号列表。对每个子项进行分析，就好像它本身就是整个WHERE子句一样，以便查看该子项是否可自行索引。如果OR子句的&lt;u&gt;每个&lt;/u&gt;子项都可以单独索引，则可以对OR子句进行编码，以便使用单独的索引来评估OR子句的每个项。考虑SQLite如何为每个OR子句术语使用单独的索引的一种方法是，假设WHERE子句的重写方式如下：</target>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">单个虚拟表实现可能会施加其他约束。例如，某些虚拟实现可能提供只读表。或者某些虚拟表实现可能允许&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE，&lt;/a&gt;但不允许&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;。或者某些虚拟表实现可能会限制可以进行的UPDATE的种类。</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">在WHERE子句中使用OR运算符的UPDATE上的无限循环。问题在3.17.0中引入，并在大约一年后在邮件列表中报告。机票&lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">ORDER BY子句的信息存储在aOrderBy[]中。aOrderBy的每个术语都记录了ORDER BY子句的一列。</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">首次公开发布Alpha代码</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">最初发布的2.0版本。放弃了将库改名为 &quot;SQLus &quot;的想法,而保留了 &quot;SQLite &quot;的名称,并凸起了主要版本号。</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">数据库的初始大小,以页为单位</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">初始化 SQLite 库</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">初始化索引X为N-200(其中N为数据库页面的大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">初始化回调的&lt;b&gt;azColumnName []&lt;/b&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">将校验和初始化为偏移量为12的日记头中的校验和非ce值。</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">内连接可以自由地重新排序。但是,左外连接既不是换算的,也不是关联的,因此不会被重新排序。如果优化器认为外连接的左边和右边的内连接是有利的,那么可以重新排序,但是外连接总是按照它们出现的顺序进行评估。</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">将这一行插入递归表中。</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">将寄存器P2持有的整数值插入到寄存器P1持有的RowSet对象中。</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">在数据库中插入记录</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">LIMIT子句可以代替单独的OFFSET子句,指定两个用逗号分隔的标量表达式。在这种情况下,第一个表达式被用作OFFSET表达式,第二个表达式被用作LIMIT表达式。这是与直觉相反的,因为当使用OFFSET子句时,两个表达式中的第二个表达式是OFFSET,第一个表达式是LIMIT。这种偏移和限制的颠倒是有意为之的--它最大限度地提高了与其他SQL数据库系统的兼容性。然而,为了避免混淆,强烈建议程序员使用使用 &quot;OFFSET &quot;关键字的LIMIT子句形式,并避免使用带有逗号分隔偏移量的LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">这条语句没有删除 &quot;二 &quot;列小于50的记录,而只是把 &quot;一 &quot;列放在括号里 VDBE实现这条语句的程序如下。</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">默认情况下，SQLite不会提供对Unicode大小写的完全支持，而是提供了链接外部Unicode比较和转换例程的功能。应用程序可以重载内置的&lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt;整理序列（使用&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;）和内置的&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）&lt;/a&gt;，&lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#lower&quot;&gt;Lower（）&lt;/a&gt;函数（使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;）。 SQLite源代码包括执行这些重载的&amp;ldquo; ICU&amp;rdquo;扩展。或者，开发人员可以根据项目中已经包含的自己的Unicode感知比较例程编写自己的重载。</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">FTS5不使用磁盘上的单一数据结构来存储全文索引,而是使用一系列b树。每次提交一个新的事务时,一个包含提交的事务内容的新b树就会被写入数据库文件。当查询全文索引时,必须对每个b树进行单独查询,并将结果合并后再返回给用户。</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">不使用没有尾部参数的bm25(),而是可以根据每个查询配置映射到rank列的特定辅助函数,或者为FTS表设置不同的持久化默认值。</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">有些用户可能希望使用数据库触发器来保持全文索引与存储在内容表中的一组文档的最新状态,而不是分别写入全文索引和内容表。例如,使用前面例子中的表。</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">指令1在本例中尤为重要。通常情况下,Column指令会从SQLite文件条目数据中的大记录中提取列的值。指令1在瞬时表上设置了一个标志,这样Column反而会把SQLite文件条目的键当作数据来处理,从键中提取列信息。</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">指令0到4和INSERT示例一样。它们启动了主数据库和临时数据库的事务,验证了主数据库的数据库模式,并在表 &quot;examp &quot;上打开了一个读游标。注意,打开游标是为了读,而不是写。在程序的这个阶段,我们只是要扫描表,而不是改变表。稍后我们将在指令15中重新打开同一张表进行写入。</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">指令11到18实现了对所有索引记录的循环,其中的键是由指令8获取的。所有带有这个键的索引记录在索引表中都是连续的,所以我们走过它们,从索引中获取相应的表键。然后用这个表键将光标移动到表中的那一行。剩下的循环与非索引SELECT查询的循环相同。</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">指令18至23在要索引的表的每一行上实现循环。对于每个表行，我们首先在指令19中使用Recno提取该行的整数键，然后在指令20中使用Column获取&amp;ldquo; two&amp;rdquo;列的值&lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;。MakeIdxKey&lt;/a&gt;指令在21处将数据转换为&amp;ldquo; two&amp;rdquo;列中的数据（ （位于堆栈顶部）进入有效的索引键。对于单列索引，这基本上是无操作的。但是，如果对MakeIdxKey的P1操作数大于一个，则会从堆栈中弹出多个条目并将其转换为单个索引键。该&lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;实际创建索引条目的是22处的指令。IdxPut从堆栈中弹出两个元素。堆栈的顶部用作从索引表中获取条目的键。然后，将在堆栈上排第二的整数添加到该索引的整数集中，并将新记录写回到数据库文件中。请注意，如果有两个或两个以上表条目的两列具有相同的值，则同一索引条目可以存储多个整数。</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">指令19到25构造了一个新的数据库记录,将用于替换现有记录。这和我们在insert的描述中看到的代码是一样的,不再赘述。指令25执行后,堆栈是这样的。</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">指令2和3在要查询的数据库表上打开一个读游标。这与INSERT示例中的OpenWrite指令的工作原理相同,只是这次打开的游标是读而不是写。指令4和INSERT示例中一样,验证数据库模式。</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Android的编译说明&lt;a href=&quot;#compile-android&quot;&gt;如下所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">原本会导致溢出的整数算术运算,现在改用浮点运算。</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">存储为段b树节点一部分的整数值使用FTS varint格式进行编码。这种编码是类似的，但&lt;b&gt;不完全相同&lt;/b&gt;，于&lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite的varint格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60896296e2cc4f360fd103b1acf3b75080d48243" translate="yes" xml:space="preserve">
          <source>Integrity of the freelist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">该内存插槽的预期用途</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">表b树的内页没有有效载荷,所以永远不会有任何有效载荷溢出。</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">内部与外部BLOBs</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">SQLite中的内部BLOB与外部BLOB的比较</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">SQLite使用的内部模式对象可能包括以下内容。</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">内部表格</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">在内部,Geopoly以二进制格式存储多边形--SQL BLOB。下面给出了二进制格式的细节。所有的 Geopoly 界面都能接受 GeoJSON 格式或二进制格式的多边形。</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">TRIM()函数的国际化。Ticket #2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">将偏移量X的字节解释为8位无符号整数,并将该整数的值加到校验和中。</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">将寄存器P1的内容解释为一个整数。将P1值的一补存入寄存器P2中。如果P1的值是NULL,那么在P2中存储一个NULL。</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">将光标P1指向的数据解释为使用&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;指令构建的结构。（有关数据格式的其他信息，请参见&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;操作码。）从该记录中提取第P2列。如果记录中的值少于（P2 + 1），则提取NULL。</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">将寄存器P1中的值解释为一个布尔值,将该布尔值(0或1)存储在寄存器P2中。将该布尔值(0或1)存储在寄存器P2中。或者如果寄存器P1中的值是NULL,那么P3就存储在寄存器P2中。如果P4为1,则将答案反转。</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">将寄存器P1中的值解释为布尔值。将布尔值的补码存储在寄存器P2中,如果寄存器P1中的值为NULL,则在P2中存储一个NULL。如果寄存器P1中的值是NULL,那么在P2中存储一个NULL。</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">中断一个长期运行的查询</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">引入扩展错误代码,增加各种I/O错误的错误代码。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">内省SQLite数据库文件（&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;）的磁盘内容</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">直觉上,我们人类理解算法-1是最好的。每个签到可能有很少的子代(一个子代是最常见的情况),而且每个子代都可以用对数时间来测试$trunk标签。事实上,算法-1是实践中较快的选择。但是NGQP没有直观的感受。NGQP必须使用硬数学,而算法-2在数学上略胜一筹。这是因为,在没有其他信息的情况下,NGQP必须假设PLINK_I1和TAGXREF_I1这两个索引质量相同,并且具有同等的选择性。算法-2使用了TAGXREF_I1索引的一个字段和PLINK_I1索引的两个字段,而算法-1只使用了每个索引的第一个字段。由于算法-2使用了更多的索引材料,所以NGQP判断它是更好的算法是正确的。分数很接近,算法-2只是勉强领先算法-1。但算法-2在这里确实是正确的选择。</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">颠倒一个变化集</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">在应用变化集之前将其反转。这相当于在应用变化集之前,使用sqlite3changeset_invert()来反转它。在补丁集中指定这个标志是错误的。</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">在迭代变化集的同时,将变化集反转。这相当于在应用变化集之前,使用sqlite3changeset_invert()对它进行反转。在补丁集中指定这个标志是错误的。</target>
        </trans-unit>
        <trans-unit id="7bcd843ccbf3ca2b0a46090c9286f7cf70d294d4" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">在与提供的语句句柄关联的数据库连接句柄上调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;进行注册，以进行解锁通知回调。如果对unlock_notify（）的调用返回SQLITE_LOCKED，则将此值返回给调用方。</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">调用一个用户函数(P4是指向定义函数的FuncDef对象的指针),P5参数取自寄存器P2和后续函数。函数的结果存储在寄存器P3中。寄存器P3不能是函数的输入之一。</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">调用一个用户函数(P4是一个指向sqlite3_context对象的指针,该对象包含一个指向要运行的函数的指针),P5参数取自寄存器P2和继任者。函数的结果存储在寄存器P3中。寄存器P3不能是函数的输入之一。</target>
        </trans-unit>
        <trans-unit id="bf8b8c1d4d822ee5f5035e452152155ef6c1caa7" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">调用'merge'命令一次,参数设置为 -N,然后</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">在参数设置为N的情况下,调用'merge'命令0次或多次。</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">调用当前结果行的回调函数。</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">在 sqlite3rbu 对象指针 X 上调用 sqlite3rbu_step(X)函数一次或多次,每次调用 sqlite3rbu_step()都会执行一次 b-tree 操作,因此可能需要调用数千次才能应用完整的更新。当更新被完全应用时,sqlite3rbu_step()接口将返回SQLITE_DONE。</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">调用xValue()函数并将结果存储在寄存器P3中。</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">在一个NULL指针上调用sqlite3_finalize()是一个无害的no-op。</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">使用参数调用此编译指示等效于使用与&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;参数&lt;/a&gt;对应的第三个参数调用&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt; C接口：</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">不带参数调用此编译指示等效于调用&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; C接口。</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">SQLite的线程安全吗?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">替换为:</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">隔离与并发</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">数据库连接之间的隔离</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">SQLite中的隔离</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">每当查询计划者使用自动索引时，在&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;上发出&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt;警告。</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">如果使用&lt;a href=&quot;quirks#dblquote&quot;&gt;双引号的字符串文字，&lt;/a&gt;则在&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;上发出SQLITE_WARNING消息。</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">当sqlite_master表损坏时，发出错误而不是断言故障或空指针取消引用，以使sqlite_sequence表根页实际上是btree-index页。入住&lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">如果数据库zFrom不存在或不包含所需的兼容表,这是一个错误。</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">它不能用于将数据复制到内存数据库或从内存数据库中复制。</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">它可以处理掉表或索引时可能发生的SQLITE_LOCKED的特殊情况。</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">它可以管理线程优先级。</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">它存在,而且</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">建立用于基于目标数据库名称确定RBU真空状态数据库名称的约定是一个好主意。下面的示例代码使用&amp;ldquo; &amp;lt;target&amp;gt; -vacuum&amp;rdquo;，其中&amp;lt;target&amp;gt;是要清理的数据库的名称。</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">这是可以接受的调用&lt;b&gt;sqlite_finalize&lt;/b&gt;在虚拟机上之前&lt;b&gt;sqlite_step&lt;/b&gt;返回SQLITE_DONE。这样做会中断正在进行的操作。部分完成的变化将被回滚，并且数据库将被恢复到其原始状态（除非替代恢复算法是使用正在执行的SQL的ON CONFLICT子句选择。）的效果是一样的，如果的回调函数&lt;b&gt;sqlite_exec&lt;/b&gt;民政事务返回非零。</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">在从未传递过&lt;b&gt;sqlite_step&lt;/b&gt;的虚拟机上调用&lt;b&gt;一次sqlite_finalize&lt;/b&gt;也是可以接受的。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">也可以为FTS5创建自定义标记器。&lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;此处描述了&lt;/a&gt;用于执行此操作的API 。</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">也可以自定义 unicode61 将其视为分隔符的代码点集。可以使用 &quot;separators=&quot;选项来指定一个或多个额外的字符作为分隔符,而 &quot;tokenchars=&quot;选项可以指定一个或多个额外的字符作为标记的一部分,而不是作为分隔符。例如</target>
        </trans-unit>
        <trans-unit id="c5f2716f625be713954d4be305f323e2da4e7532" translate="yes" xml:space="preserve">
          <source>It is also possible to express this kind of simultaneous read and write on an R-Tree within a single query, for example if an UPDATE statement tries to change the value of one row of the R-Tree based on a complicated query from another row of the same R-Tree, perhaps something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">向用于创建FTS5表的CREATE VIRTUAL TABLE语句添加类型，约束或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;声明是错误的。创建FTS5表后，可以像其他任何表一样使用&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句填充FTS5 表。像其他任何没有PRIMARY KEY声明的表一样，FTS5表具有名为rowid的隐式INTEGER PRIMARY KEY字段。</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">试图将sz或rawdata字段设置为NULL以外的任何值都是错误的。</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">将columnsize选项设置为0或1以外的任何值都是错误的。</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">第一次调用xToken()时,指定FTS5_TOKEN_COLOCATED标志是错误的。连续多次调用xToken(FTS5_TOKEN_COLOCATED),可以为单一标记指定多个同义词。同义词的数量没有限制。</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">假设游标只用于追加,所以如果游标有效,那么游标一定已经指向btree的末端,所以不会对游标进行任何修改。</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">假设按顺序向文件中写入一系列顺序的数据块比按任意顺序写入相同的数据块要快。</target>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">它是通过调用sqlite3changegroup_new()来创建的。</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">更新 ZIP 存档中的单个条目很困难。更新 ZIP 存檔中的個別項目尤其困難,因為如果電腦斷電和/或在更新過程中發生故障,則不會破壞整個文件。要做到这一点并非不可能,但由于难度太大,实际上没有人这样做。相反,每当用户选择 &quot;文件/保存 &quot;时,整个ZIP存档就会被重写。因此,&quot;文件/保存 &quot;需要的时间比它应该的要长,特别是在旧硬件上。较新的机器速度更快,但在50兆字节的文件中改变一个字符会导致人们烧掉SSD上有限的50兆字节的写入寿命,这还是很麻烦的。</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">P1和P3是同一个寄存器是非法的。有时,如果P3与P2是同一个寄存器,那么实现能够避免memcpy()。</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">重要的是,所有对同一数据库文件的连接都使用相同的锁协议。如果一个应用程序使用POSIX咨询锁,而另一个应用程序使用点文件锁,那么这两个应用程序将看不到对方的锁,无法协调数据库访问,可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">需要注意的是,改变SQLite的版本可能会导致查询计划的改变。相同版本的SQLite总是会选择相同的查询计划,但如果你重新链接你的应用程序来使用不同版本的SQLite,那么查询计划可能会改变。在极少数情况下,SQLite版本变化可能会导致性能倒退。这是一个原因,你应该考虑将你的应用程序静态地链接到SQLite,而不是使用全系统的SQLite共享库,因为后者可能会在你不知情或无法控制的情况下发生变化。</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">重要的是要意识到，&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;都不会执行使用核心例程无法完成的任何操作。实际上，这些包装器仅根据核心例程来实现。</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">为了防止在写扇区时断电后数据库损坏,在回滚日志中存储扇区的所有页面是很重要的。假设第1、2、3、4页都存储在扇区1中,第2页被修改。为了将修改内容写入第2页,底层硬件还必须重写第1、3、4页的内容,因为硬件必须写入完整的扇区。如果这个写操作因断电而中断,第1、3或4页中的一个或多个页可能会留下不正确的数据。因此,为了避免数据库的持久损坏,所有这些页面的原始内容必须包含在回滚日志中。</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">理解这两种不同的 &quot;无服务器 &quot;定义很重要。当一个数据库声称自己是 &quot;无服务器 &quot;时,一定要辨别他们的意思是 &quot;经典无服务器 &quot;还是 &quot;新无服务器&quot;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
