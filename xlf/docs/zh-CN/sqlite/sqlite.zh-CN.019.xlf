<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="59ef232ad2a9a13529bf5e89145da92a1a6319d6" translate="yes" xml:space="preserve">
          <source>Type affinity</source>
          <target state="translated">类型亲和力</target>
        </trans-unit>
        <trans-unit id="38895187a3c7e29b6f02e06c184834c7180dd221" translate="yes" xml:space="preserve">
          <source>Typical output from a single TH3 test program run looks like this:</source>
          <target state="translated">一个TH3测试程序运行的典型输出是这样的。</target>
        </trans-unit>
        <trans-unit id="8711d8537a2bf9829ad98f22b75b8b8dc119969c" translate="yes" xml:space="preserve">
          <source>UNBOUNDED</source>
          <target state="translated">UNBOUNDED</target>
        </trans-unit>
        <trans-unit id="363cb5cb9b015bf8fe75ee8f6f3ad675ca5618cc" translate="yes" xml:space="preserve">
          <source>UNION</source>
          <target state="translated">UNION</target>
        </trans-unit>
        <trans-unit id="e0f0a7115a4e0b11973725c719a99090b1a2caa7" translate="yes" xml:space="preserve">
          <source>UNION ALL ... UNION ALL SELECT</source>
          <target state="translated">UNION ALL ...UNION ALL SELECT</target>
        </trans-unit>
        <trans-unit id="2ef896dc8994d71c3776f028df0d2a89b61b4550" translate="yes" xml:space="preserve">
          <source>UNION, UNION ALL, INTERSECT, and EXCEPT</source>
          <target state="translated">UNION、UNION ALL、INTERSECT和EXCEPT。</target>
        </trans-unit>
        <trans-unit id="c9e6a29d14f3f27cd2ee75b65407552ad50a3078" translate="yes" xml:space="preserve">
          <source>UNIQUE</source>
          <target state="translated">UNIQUE</target>
        </trans-unit>
        <trans-unit id="841c884fb288309550412babe47484ff0e3745f9" translate="yes" xml:space="preserve">
          <source>UNIQUE, CHECK, and NOT NULL constraint errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ead37d8578ae9705f3d87c1d034addd810cd1ed" translate="yes" xml:space="preserve">
          <source>UNIX mode, as returned by stat(2) for the zip file record (an integer). This identifies the type of record (file, directory or symbolic link), and the associated user/group/all permissions.</source>
          <target state="translated">UNIX 模式,由 stat(2)返回的 zip 文件记录(一个整数)。它标识了记录的类型(文件、目录或符号链接),以及相关的用户/组/所有权限。</target>
        </trans-unit>
        <trans-unit id="f6fee659655c0db9d5b27d3ee09d34358c974b03" translate="yes" xml:space="preserve">
          <source>UNLOCKED</source>
          <target state="translated">UNLOCKED</target>
        </trans-unit>
        <trans-unit id="d272346adafef58007de20094d2f682eb2fe1bd2" translate="yes" xml:space="preserve">
          <source>UNSIGNED BIG INT</source>
          <target state="translated">未签字的大国际</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="688e558eee1d1bb512a94d0cc620288bf7d472f2" translate="yes" xml:space="preserve">
          <source>UPDATE And DELETE Statements</source>
          <target state="translated">UPDATE 和 DELETE 语句</target>
        </trans-unit>
        <trans-unit id="49a16f1602f22a2ff3d079003de17960196cd62b" translate="yes" xml:space="preserve">
          <source>UPDATE Changes</source>
          <target state="translated">更新变化</target>
        </trans-unit>
        <trans-unit id="bf53a6aae01db9b5dad497a7e025817f66502008" translate="yes" xml:space="preserve">
          <source>UPDATE and DELETE statements work similarly.</source>
          <target state="translated">UPDATE和DELETE语句的工作原理类似。</target>
        </trans-unit>
        <trans-unit id="1c9d5c3eed910621fdbd8231e3b605e82a063d04" translate="yes" xml:space="preserve">
          <source>UPDATE statements work very much like DELETE statements except that instead of deleting the record they replace it with a new one. Consider this example:</source>
          <target state="translated">UPDATE语句的工作原理与DELETE语句非常相似,只是它们不是删除记录,而是用一个新的记录来替换。考虑这个例子。</target>
        </trans-unit>
        <trans-unit id="23f1f94678733621721dfbd9281a151e75fd39b3" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b = 'v2' WHERE a=1;</source>
          <target state="translated">UPDATE t1 SET b='v2' WHERE a=1;</target>
        </trans-unit>
        <trans-unit id="9d1ad45a1d025bcccb63dad4f87235cf205b5b63" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=0 AND a&amp;lt;10;</source>
          <target state="translated">更新t1设置b = b * 2其中a&amp;gt; = 0且a &amp;lt;10;</target>
        </trans-unit>
        <trans-unit id="7bc4a22623437c880e8e4324cc657c00abd18be7" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=10 AND a&amp;lt;20;</source>
          <target state="translated">更新t1设置b = b * 2其中a&amp;gt; = 10并且a &amp;lt;20;</target>
        </trans-unit>
        <trans-unit id="69fa4f2a787b8c6d32fe94ec05425d1fb170202e" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9980 AND a&amp;lt;9990;</source>
          <target state="translated">更新t1设置b = b * 2其中a&amp;gt; = 9980和a &amp;lt;9990;</target>
        </trans-unit>
        <trans-unit id="bd6a359ea6d6ffa5fa77996361d46448cd59ce9f" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9990 AND a&amp;lt;10000;</source>
          <target state="translated">更新t1设置b = b * 2其中a&amp;gt; = 9990并且a &amp;lt;10000;</target>
        </trans-unit>
        <trans-unit id="0afa724368a197872d6c5ffb446fe74a06bc33c2" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=121928 WHERE a=2;</source>
          <target state="translated">UPDATE t2 SET b=121928 WHERE a=2;</target>
        </trans-unit>
        <trans-unit id="3526291b0bb67daddf75ff2b44713d0b345a7083" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=347393 WHERE a=25000;</source>
          <target state="translated">UPDATE t2 SET b=347393 WHERE a=25000;</target>
        </trans-unit>
        <trans-unit id="1e3a05f35bab1c3145c54848bb462d616f180f96" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=35065 WHERE a=24999;</source>
          <target state="translated">UPDATE t2 SET b=35065 WHERE a=24999;</target>
        </trans-unit>
        <trans-unit id="83da842c2149e8d92733fb66a7c52922e2a8bb02" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=468026 WHERE a=1;</source>
          <target state="translated">UPDATE t2 SET b=468026 WHERE a=1。</target>
        </trans-unit>
        <trans-unit id="abe0aeef0bc8c95cf7dba0b992e2c26051c0fbd4" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='one hundred forty eight thousand three hundred eighty two' WHERE a=1;</source>
          <target state="translated">UPDATE t2 SET c='一百四十八万三千八百二' WHERE a=1。</target>
        </trans-unit>
        <trans-unit id="2e646600f6e7b2bb70471ce989105819d65503b9" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred eighty three thousand ninety nine' WHERE a=24999;</source>
          <target state="translated">UPDATE t2 SET c='三十八万三千九百九十九' WHERE a=24999。</target>
        </trans-unit>
        <trans-unit id="24be2b2373e2e643ec5af7225d298b219c086994" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred sixty six thousand five hundred two' WHERE a=2;</source>
          <target state="translated">UPDATE t2 SET c='三十六万五千两' WHERE a=2。</target>
        </trans-unit>
        <trans-unit id="317adbaa4dc2a3c2843d99c6771359a7f0624c58" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='two hundred fifty six thousand eight hundred thirty' WHERE a=25000;</source>
          <target state="translated">UPDATE t2 SET c='二十五万六千八百三十' WHERE a=25000。</target>
        </trans-unit>
        <trans-unit id="c55112b254b71dd5f11927b24c53d183f3ed4118" translate="yes" xml:space="preserve">
          <source>UPSERT</source>
          <target state="translated">UPSERT</target>
        </trans-unit>
        <trans-unit id="6eee69d236c66ab4ffc25696fb830833cbb3fd3c" translate="yes" xml:space="preserve">
          <source>UPSERT does not currently work for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">UPSERT当前不适用于&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c2066bfe0e8babe467800cce0c33996ece301c4" translate="yes" xml:space="preserve">
          <source>UPSERT is a special syntax addition to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that causes the INSERT to behave as an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or a no-op if the INSERT would violate a uniqueness constraint. UPSERT is not standard SQL. UPSERT in SQLite follows the syntax established by PostgreSQL. UPSERT syntax was added to SQLite with version 3.24.0 (2018-06-04).</source>
          <target state="translated">UPSERT是&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;的特殊语法补充，如果INSERT违反唯一性约束，则它会使INSERT表现为&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或no-op。UPSERT不是标准的SQL。SQLite中的UPSERT遵循PostgreSQL建立的语法。UPSERT语法已添加到SQLite版本3.24.0（2018-06-04）中。</target>
        </trans-unit>
        <trans-unit id="095b20b5d88a77f400266be9db4f8fd23dca8121" translate="yes" xml:space="preserve">
          <source>URI Filenames</source>
          <target state="translated">URI文件名</target>
        </trans-unit>
        <trans-unit id="6b3e19882ec7248890e4c5d13ea994d174863955" translate="yes" xml:space="preserve">
          <source>URI filename examples</source>
          <target state="translated">URI文件名示例</target>
        </trans-unit>
        <trans-unit id="5e847e5e42eefec738b40d802039de3c59cd0211" translate="yes" xml:space="preserve">
          <source>URI filenames</source>
          <target state="translated">URI文件名</target>
        </trans-unit>
        <trans-unit id="bcc83fb4f795835fa81fea70c5b7f4ce3da5fb80" translate="yes" xml:space="preserve">
          <source>URI filenames are parsed according to RFC 3986. If the URI contains an authority, then it must be either an empty string or the string &quot;localhost&quot;. If the authority is not an empty string or &quot;localhost&quot;, an error is returned to the caller. The fragment component of a URI, if present, is ignored.</source>
          <target state="translated">URI文件名根据RFC 3986进行解析。如果URI包含一个权威,那么它必须是一个空字符串或 &quot;localhost &quot;字符串。如果授权不是空字符串或 &quot;localhost&quot;,则会向调用者返回一个错误。如果存在URI的片段成分,则会被忽略。</target>
        </trans-unit>
        <trans-unit id="f52fa99533bd53d2651964895f6aead88e88448d" translate="yes" xml:space="preserve">
          <source>URI filenames in sqlite3_open()</source>
          <target state="translated">sqlite3_open()中的URI文件名。</target>
        </trans-unit>
        <trans-unit id="26ed4ff394970482b699209414b942167f2dd638" translate="yes" xml:space="preserve">
          <source>URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI. A hexadecimal escape sequence consists of a percent sign - &quot;%&quot; - followed by exactly two hexadecimal digits specifying an octet value. Before the path or query components of a URI filename are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet. If this process generates an invalid UTF-8 encoding, the results are undefined.</source>
          <target state="translated">在URI的路径和查询组件中支持URI十六进制转义序列(%HH)。一个十六进制转义序列由一个百分号--&quot;%&quot;--和两个十六进制数字组成,指定一个八位数的值。在解释URI文件名的路径或查询组件之前,它们使用UTF-8编码,所有十六进制转义序列被一个包含相应八位数的单字节所取代。如果这个过程产生了无效的UTF-8编码,那么结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="40da99c368fe0d628f9b0dcc937070f1edfd1b1f" translate="yes" xml:space="preserve">
          <source>URIs are processed as UTF8 text. The filename argument sqlite3_open16() is converted from UTF16 native byte order into UTF8 prior to processing.</source>
          <target state="translated">URI被处理为UTF8文本。文件名参数sqlite3_open16()在处理前会从UTF16本机字节顺序转换为UTF8。</target>
        </trans-unit>
        <trans-unit id="41b3da30e1707f2b0bc331e3534b952825349eed" translate="yes" xml:space="preserve">
          <source>USB flash memory sticks seem to be especially pernicious liars regarding sync requests. One can easily see this by committing a large transaction to an SQLite database on a USB memory stick. The COMMIT command will return relatively quickly, indicating that the memory stick has told the operating system and the operating system has told SQLite that all content is safely in persistent storage, and yet the LED on the end of the memory stick will continue flashing for several more seconds. Pulling out the memory stick while the LED is still flashing will frequently result in database corruption.</source>
          <target state="translated">在同步请求方面,USB闪存棒似乎是特别恶毒的骗子。通过向U盘上的SQLite数据库提交一个大型事务,可以很容易地看出这一点。COMMIT命令会比较快地返回,说明记忆棒已经告诉操作系统,操作系统也已经告诉SQLite,所有的内容都安全地在持久化存储中,然而记忆棒末端的LED灯还会继续闪烁几秒钟。在LED灯还在闪烁的时候拔出记忆棒会经常导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="b0138e4f9dc0aacc367a1f86d8e4506b943320e8" translate="yes" xml:space="preserve">
          <source>USING</source>
          <target state="translated">USING</target>
        </trans-unit>
        <trans-unit id="4a2b12a8f9db417e4cc5f36a3e1c2fec1469fe7f" translate="yes" xml:space="preserve">
          <source>UTC timestamp, in seconds since the UNIX epoch (an integer).</source>
          <target state="translated">UTC时间戳,自UNIX纪元以来的秒数(一个整数)。</target>
        </trans-unit>
        <trans-unit id="28ef7752ac0283beed8e66a2b5b204db183549fd" translate="yes" xml:space="preserve">
          <source>Unallocated space</source>
          <target state="translated">未分配的空间</target>
        </trans-unit>
        <trans-unit id="b0b4a5a01660223c1f1c6d19e4a89997fe5e3325" translate="yes" xml:space="preserve">
          <source>Unary &quot;-&quot;</source>
          <target state="translated">单一的&quot;-&quot;</target>
        </trans-unit>
        <trans-unit id="6bfa68ac4d2f61f36caa0def08a4a0095686e16a" translate="yes" xml:space="preserve">
          <source>Undefined BEFORE trigger behavior</source>
          <target state="translated">未定义BEFORE触发行为</target>
        </trans-unit>
        <trans-unit id="9e37e5dd8e036cac3e0f290adf0e16da58e3ffe8" translate="yes" xml:space="preserve">
          <source>Undefined behavior checks</source>
          <target state="translated">未定义行为检查</target>
        </trans-unit>
        <trans-unit id="79dfa4a9456d7e99f2303579887d4ea94c961a44" translate="yes" xml:space="preserve">
          <source>Under Unix, an &lt;b&gt;sqlite*&lt;/b&gt; pointer should not be carried across a &lt;b&gt;fork()&lt;/b&gt; system call into the child process. The child process should open its own copy of the database after the &lt;b&gt;fork()&lt;/b&gt;.</source>
          <target state="translated">在Unix下，&lt;b&gt;sqlite *&lt;/b&gt;指针不应通过&lt;b&gt;fork（）&lt;/b&gt;系统调用携带到子进程中。子进程应在&lt;b&gt;fork（）&lt;/b&gt;之后打开其自己的数据库副本。</target>
        </trans-unit>
        <trans-unit id="7887974e08825eb481696126029ce641dab388bf" translate="yes" xml:space="preserve">
          <source>Under Unix, you should not carry an open SQLite database across a fork() system call into the child process.</source>
          <target state="translated">在Unix下,你不应该将一个开放的SQLite数据库跨越fork()系统调用带到子进程中。</target>
        </trans-unit>
        <trans-unit id="d2245919272810b035145426205e128fae32a19a" translate="yes" xml:space="preserve">
          <source>Under most circumstances, the original LIKE or GLOB operator is still tested against each input row even if the virtual terms are used to constrain an index. This is because we do not know what additional constraints may be imposed by characters to the right of the</source>
          <target state="translated">在大多数情况下,即使虚拟项被用来约束索引,原始的LIKE或GLOB操作符仍然会对每条输入行进行测试。这是因为我们不知道在虚拟项右边的字符可能会施加什么额外的约束。</target>
        </trans-unit>
        <trans-unit id="0aafde4f0303b5c58e56ca1461baa83fd0408041" translate="yes" xml:space="preserve">
          <source>Unfortunately, SQLite contains many branch instructions that help the code run faster without changing the output. Such branches generate false-positives during mutation testing. As an example, consider the following &lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;hash function&lt;/a&gt; used to accelerate table-name lookup:</source>
          <target state="translated">不幸的是，SQLite包含许多分支指令，这些指令可以帮助代码更快地运行而无需更改输出。这样的分支在突变测试过程中会产生假阳性。例如，请考虑以下用于加速表名查找的&lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;哈希函数&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0c6793d3cab2ac8df02302e6322b00044082495f" translate="yes" xml:space="preserve">
          <source>Unfortunately, algorithm-2 is slower than algorithm-1 in this application.</source>
          <target state="translated">不幸的是,在这个应用中,算法-2比算法-1慢。</target>
        </trans-unit>
        <trans-unit id="fcfb2377607479ca817d6a09b03610de66f64da2" translate="yes" xml:space="preserve">
          <source>Unfortunately, even though virtual tables are ignored by default, any &lt;a href=&quot;fts3#*shadowtab&quot;&gt;underlying database tables&lt;/a&gt; that they create in order to store data within the database are not, and &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; will include add these to any RBU database. For this reason, users attempting to use sqldiff to create RBU updates to apply to target databases with one or more virtual tables will likely have to run sqldiff using the --table option separately for each table to update in the target database.</source>
          <target state="translated">不幸的是，即使默认情况下虚拟表被忽略，它们为在数据库中存储数据而创建的任何&lt;a href=&quot;fts3#*shadowtab&quot;&gt;基础数据库表&lt;/a&gt;也不会被&lt;a href=&quot;sqldiff&quot;&gt;删除&lt;/a&gt;，并且sqldiff将包括将这些表添加到任何RBU数据库中。因此，尝试使用sqldiff创建RBU更新以应用于具有一个或多个虚拟表的目标数据库的用户可能必须使用--table选项单独运行sqldiff，以在目标数据库中更新每个表。</target>
        </trans-unit>
        <trans-unit id="c58a4f6c2a537b213079cd1adcaa6b2001643e9a" translate="yes" xml:space="preserve">
          <source>Unfortunately, most consumer-grade mass storage devices lie about syncing. Disk drives will report that content is safely on persistent media as soon as it reaches the track buffer and before actually being written to oxide. This makes the disk drives seem to operate faster (which is vitally important to the manufacturer so that they can show good benchmark numbers in trade magazines). And in fairness, the lie normally causes no harm, as long as there is no power loss or hard reset prior to the track buffer actually being written to oxide. But if a power loss or hard reset does occur, and if that results in content that was written after a sync reaching oxide while content written before the sync is still in a track buffer, then database corruption can occur.</source>
          <target state="translated">不幸的是,大多数消费级大容量存储设备在同步问题上撒谎。磁盘驱动器会报告说,内容一到达轨道缓冲区,在实际写入氧化物之前,就已经安全地在持久性介质上了。这使得磁盘驱动器看起来运行得更快(这对制造商来说至关重要,这样他们就可以在贸易杂志上展示良好的基准数据)。平心而论,只要在轨道缓冲区实际被写入氧化物之前没有断电或硬复位,这个谎言通常不会造成伤害。但是,如果确实发生了断电或硬复位,如果这导致在同步之后写入的内容到达氧化物,而同步之前写入的内容还在轨道缓冲区中,那么就会发生数据库损坏。</target>
        </trans-unit>
        <trans-unit id="af520d1880e5ee3cdc82e50d4d1525585fc7beb9" translate="yes" xml:space="preserve">
          <source>Unfortunately, the NGQP caused a performance regression in Fossil.</source>
          <target state="translated">不幸的是,NGQP造成了Fossil的性能倒退。</target>
        </trans-unit>
        <trans-unit id="7536fed3548161a0855cd29750230303476e4484" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs (including possible security exploits) were often found when pushing SQLite to extremes. For this reason, newer versions of SQLite have well-defined limits and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="translated">不幸的是，无限制政策已经显示出会产生问题。由于上限没有很好地定义，因此未进行测试，并且在将SQLite推向极限时经常发现错误（包括可能的安全漏洞）。因此，较新版本的SQLite具有明确定义的限制，并且这些限制已作为&lt;a href=&quot;testing&quot;&gt;测试套件的&lt;/a&gt;一部分进行了测试。</target>
        </trans-unit>
        <trans-unit id="154cee1be1782349508f9f52cb47759ac0528fca" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs were often found when pushing SQLite to extremes. For this reason, versions of SQLite since about release 3.5.8 (2008-04-16) have well-defined limits, and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9809fad4d13ccafd43c46a06696bc5f74c1752de" translate="yes" xml:space="preserve">
          <source>Unfortunately, the query plan computed by NN for TPC-H Q8 is not optimal. The plan computed using NN is R-N1-N2-S-C-O-L-P with a cost of 36.92. The notation in the previous sentence means that the R table is run in the outer loop, N1 is in the next inner loop, N2 is in the third loop, and so forth down to P which is in the inner-most loop. The shortest path through the graph (as found via exhaustive search) is P-L-O-C-N1-R-S-N2 with a cost of 27.38. The difference might not seem like much, but remember that the costs are logarithmic, so the shortest path is nearly 750 times faster than that path found using the NN heuristic.</source>
          <target state="translated">遗憾的是,用NN计算出的TPC-H Q8的查询计划不是最优的。用NN计算的计划是R-N1-N2-S-C-O-L-P,成本为36.92。前面一句话中的符号是指R表在外循环中运行,N1在下一个内循环中运行,N2在第三个循环中运行,以此类推一直到最内循环中的P。图中最短的路径(通过穷尽搜索发现)是P-L-O-C-N1-R-S-N2,成本为27.38。这两者之间的差别可能看起来并不大,但请记住,成本是对数的,所以最短路径比使用NN启发式找到的路径快了近750倍。</target>
        </trans-unit>
        <trans-unit id="12b20c37115e65b5f7d7e36cc94465f524bad30b" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers</source>
          <target state="translated">统一资源标识符</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="translated">独特的制约因素</target>
        </trans-unit>
        <trans-unit id="aa980d194e964e7fb7f97273f5336434b107da41" translate="yes" xml:space="preserve">
          <source>Unique index</source>
          <target state="translated">单一指数</target>
        </trans-unit>
        <trans-unit id="7157e0defd66f64a5eef1f6b25ed305c7ea76e58" translate="yes" xml:space="preserve">
          <source>Unix builds come with multiple built-in VFSes. The default VFS for unix is called &quot;unix&quot; and is used in most applications. Other VFSes that might be found in unix (depending on compile-time options) include:</source>
          <target state="translated">Unix构建的时候会有多个内置的VFS。unix的默认VFS被称为 &quot;unix&quot;,在大多数应用程序中使用。其他可能在unix中找到的VFSes(取决于编译时的选项)包括:。</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="e08358316619a161ecbcf33073f1d600c7a3d1d8" translate="yes" xml:space="preserve">
          <source>Unless SQLite is running in &quot;auto_vacuum=FULL&quot; mode, when a large amount of data is deleted from the database file it leaves behind empty space, or &quot;free&quot; database pages. This means the database file might be larger than strictly necessary. Running VACUUM to rebuild the database reclaims this space and reduces the size of the database file.</source>
          <target state="translated">除非SQLite运行在 &quot;auto_vacuum=FULL &quot;模式下,否则当大量数据从数据库文件中删除时,会留下空的空间,或 &quot;空闲 &quot;的数据库页面。这意味着数据库文件可能比严格意义上的需要更大。运行VACUUM重建数据库可以回收这些空间,减小数据库文件的大小。</target>
        </trans-unit>
        <trans-unit id="0e73f60b051af43064d6e0d8d691c92bf067b075" translate="yes" xml:space="preserve">
          <source>Unless a specific tokenizer is specified as part of the CREATE VIRTUAL TABLE statement used to create the FTS table, the default tokenizer, &quot;simple&quot;, is used. The simple tokenizer extracts tokens from a document or basic FTS full-text query according to the following rules:</source>
          <target state="translated">除非在创建 FTS 表的 CREATE VIRTUAL TABLE 语句中指定了特定的标记器,否则将使用默认的标记器 &quot;simple&quot;。simple tokenizer 根据以下规则从文档或基本 FTS 全文查询中提取标记。</target>
        </trans-unit>
        <trans-unit id="5fdc85037d052204b60739c85a692574cdca8812" translate="yes" xml:space="preserve">
          <source>Unless deadlock is detected (see below), sqlite3_unlock_notify() always returns SQLITE_OK.</source>
          <target state="translated">除非检测到死锁(见下文),否则sqlite3_unlock_notify()总是返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="7c4feec28833f0a64ab53ef0f49205604d9d8edc" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the table data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318eb4656e47b06b6ea5260cd43d217bcb29a47f" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the tables data, and are are described under &lt;a href=&quot;lang_createtable#constraints&quot;&gt;SQL Data Constraints&lt;/a&gt; below.</source>
          <target state="translated">除非它是CREATE TABLE ... AS SELECT语句，否则CREATE TABLE包含一个或多个&lt;a href=&quot;syntax/column-def&quot;&gt;列定义&lt;/a&gt;，并可选地后面跟&lt;a href=&quot;syntax/table-constraint&quot;&gt;表约束&lt;/a&gt;列表。每个列定义都由列名组成，可选地，其后跟列的声明类型，然后是一个或多个可选&lt;a href=&quot;syntax/column-constraint&quot;&gt;列约束&lt;/a&gt;。就上一条语句而言，&amp;ldquo;列约束&amp;rdquo;的定义中包括COLLATE和DEFAULT子句，即使这些并不是真正的约束，因为它们并不限制表可能包含的数据。其他约束-NOT NULL，CHECK，UNIQUE，PRIMARY KEY和FOREIGN KEY约束-限制表数据，在&lt;a href=&quot;lang_createtable#constraints&quot;&gt;SQL数据约束&lt;/a&gt;下进行介绍 下面。</target>
        </trans-unit>
        <trans-unit id="1c00ba237aa117de710c9323f816c96f6ada7a01" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">除非返回SQLITE_MISUSE，否则sqlite3_wal_checkpoint_v2（）接口将设置由&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;查询的错误信息。</target>
        </trans-unit>
        <trans-unit id="4e06b73ee3affa8214cc1405f997b2bb6e5fc2af" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">除非返回SQLITE_MISUSE，否则sqlite3_wal_checkpoint_v2（）接口将设置由&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;查询的错误信息。</target>
        </trans-unit>
        <trans-unit id="4591266e2017f729f7aff5d0aced794f6644a4c3" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">除非返回SQLITE_MISUSE，否则此函数设置可通过&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;及相关函数访问的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="0e4971f6a57c5c65a9a1ae31e9cf2a3e92d4934e" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">除非返回SQLITE_MISUSE，否则此函数设置可通过&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;及相关函数访问的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="b37e8216d0e44ec2efee716d4c9dd7d3e0183bf7" translate="yes" xml:space="preserve">
          <source>Unless the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is applied, if a subquery appears in the FROM clause of a SELECT statement, SQLite can either run the subquery and stores the results in a temporary table, or it can run the subquery as a co-routine. The following query is an example of the latter. The subquery is run by a co-routine. The outer query blocks whenever it needs another row of input from the subquery. Control switches to the co-routine which produces the desired output row, then control switches back to the main routine which continues processing.</source>
          <target state="translated">除非应用&lt;a href=&quot;optoverview#flattening&quot;&gt;扁平化优化&lt;/a&gt;，否则如果子查询出现在SELECT语句的FROM子句中，则SQLite可以运行子查询并将结果存储在临时表中，也可以将子查询作为协同例程运行。以下查询是后者的示例。子查询由协同例程运行。每当外部查询需要子查询的另一行输入时，外部查询就会阻塞。控制权切换到产生所需输出行的协同程序，然后控制权切换回到继续处理的主程序。</target>
        </trans-unit>
        <trans-unit id="6debb16b797e55251f765dccb022c7b2f7c44222" translate="yes" xml:space="preserve">
          <source>Unlike most SQL databases, SQLite does not restrict the type of data that may be inserted into a column based on the columns declared type. Instead, SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. The declared type of a column is used to determine the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the column only.</source>
          <target state="translated">与大多数SQL数据库不同，SQLite并不基于声明的列类型限制可以插入到列中的数据类型。相反，SQLite使用&lt;a href=&quot;datatype3&quot;&gt;动态类型&lt;/a&gt;。列的声明类型仅用于确定列的&lt;a href=&quot;datatype3#affinity&quot;&gt;亲和力&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fc35fdda18e32589afbc6422311960ed986aa1d" translate="yes" xml:space="preserve">
          <source>Unlike most other SQL implementations, SQLite does not have a separate BOOLEAN data type. Instead, TRUE and FALSE are (normally) represented as integers 1 and 0, respectively. This does not seem to cause many problems, as we seldom get complaints about it. But it is important to recognize.</source>
          <target state="translated">与大多数其他SQL实现不同,SQLite没有单独的BOOLEAN数据类型。相反,TRUE和FALSE(通常)分别表示为整数1和0。这似乎不会引起很多问题,因为我们很少收到关于它的投诉。但认识到这一点很重要。</target>
        </trans-unit>
        <trans-unit id="19f905f254ee85ddda7a69f550a125cf0e71bdf9" translate="yes" xml:space="preserve">
          <source>Unlike option values and column names, SQL text literals intended as tokenizers must be quoted using single quote characters. For example:</source>
          <target state="translated">与选项值和列名不同,作为标记符的SQL文本字元必须使用单引号字符进行引用。例如</target>
        </trans-unit>
        <trans-unit id="4a575ebe60947d8ad09098452667c713c7ab1bb2" translate="yes" xml:space="preserve">
          <source>Unlike ordinary functions, window functions cannot use the DISTINCT keyword. Also, Window functions may only appear in the result set and in the ORDER BY clause of a SELECT statement.</source>
          <target state="translated">与普通函数不同,窗口函数不能使用DISTINCT关键字。另外,窗口函数只能出现在结果集和SELECT语句的ORDER BY子句中。</target>
        </trans-unit>
        <trans-unit id="2f67d962c33cac256671fd15a0b1070b30d60167" translate="yes" xml:space="preserve">
          <source>Unlike other OMIT options which make the SQLite library smaller, this option actually increases the size of SQLite and makes it run a little slower. Only use this option if SQLite is being built for an embedded target that does not support WSD.</source>
          <target state="translated">与其他OMIT选项使SQLite库变小不同,这个选项实际上增加了SQLite的大小,使其运行速度更慢一些。只有在为不支持 WSD 的嵌入式目标构建 SQLite 时才使用此选项。</target>
        </trans-unit>
        <trans-unit id="0fc95e0cae6fea6934c86fc94073155aecd6590f" translate="yes" xml:space="preserve">
          <source>Unlike the other journaling modes, &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt; is persistent. If a process sets WAL mode, then closes and reopens the database, the database will come back in WAL mode. In contrast, if a process sets (for example) PRAGMA journal_mode=TRUNCATE and then closes and reopens the database will come back up in the default rollback mode of DELETE rather than the previous TRUNCATE setting.</source>
          <target state="translated">与其他&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;日记&lt;/a&gt;记录模式不同，PRAGMA journal_mode = WAL是持久性的。如果进程设置了WAL模式，然后关闭并重新打开数据库，则数据库将恢复为WAL模式。相反，如果某个进程设置（例如）PRAGMA journal_mode = TRUNCATE，然后关闭然后重新打开，则数据库将以默认的DELETE回滚模式而不是先前的TRUNCATE设置恢复。</target>
        </trans-unit>
        <trans-unit id="3542ed2ff90a29869b311f3e2e4680675b20b4a0" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the master journal does not contain any original database page content. Instead, the master journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="translated">与回滚日志不同,主日志不包含任何原始数据库页面内容,而是包含参与事务的每个数据库的回滚日志的完整路径名。相反,主日志包含参与事务的每个数据库的回滚日志的完整路径名。</target>
        </trans-unit>
        <trans-unit id="3dcad4a4f47bac4601655442badbb882f7ce80cb" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the super-journal does not contain any original database page content. Instead, the super-journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b418069c25f685f24a747aa6e2e42a4b27661e" translate="yes" xml:space="preserve">
          <source>Unlike the xFilter argument, xConflict may not be passed NULL. The results of passing anything other than a valid function pointer as the xConflict argument are undefined.</source>
          <target state="translated">与xFilter参数不同的是,xConflict不能被传递为NULL。除了有效的函数指针之外,传递任何其他参数作为xConflict参数的结果都是未定义的。</target>
        </trans-unit>
        <trans-unit id="8cc38ff6e04932db1753dbe47e43a46b66cca7d3" translate="yes" xml:space="preserve">
          <source>Unlinked database files</source>
          <target state="translated">未链接的数据库文件</target>
        </trans-unit>
        <trans-unit id="2e66bd886206de5f2b17ce23c8df1ed8d25d65b5" translate="yes" xml:space="preserve">
          <source>Unlock Notification</source>
          <target state="translated">解锁通知</target>
        </trans-unit>
        <trans-unit id="1129dcb047456b603be7d9e26492484e1ef87d61" translate="yes" xml:space="preserve">
          <source>Unlock the btree to which cursor P1 is pointing so that it can be written by other cursors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc88710cf7a309e590112924b4f0f18efd64749f" translate="yes" xml:space="preserve">
          <source>Unnecessary OP_IsNull, OP_Affinity, and OP_MustBeInt VDBE opcodes are suppressed</source>
          <target state="translated">抑制不必要的OP_IsNull、OP_Affinity和OP_MustBeInt VDBE操作码。</target>
        </trans-unit>
        <trans-unit id="b028e3e382d48044cb8ac6852f58d5f9280df947" translate="yes" xml:space="preserve">
          <source>Unpinning a database page.</source>
          <target state="translated">解除对数据库页面的锁定。</target>
        </trans-unit>
        <trans-unit id="4d158e591edd9ba39fa4326da9d09c5874218ca5" translate="yes" xml:space="preserve">
          <source>Unregister a VFS with the sqlite3_vfs_unregister() interface. If the default VFS is unregistered, another VFS is chosen as the default. The choice for the new VFS is arbitrary.</source>
          <target state="translated">用sqlite3_vfs_unregister()接口取消注册一个VFS。如果默认的VFS被取消注册,那么会选择另一个VFS作为默认值。新VFS的选择是任意的。</target>
        </trans-unit>
        <trans-unit id="ef3bbadff8cc850c1a14d5bac3c132d39dd7aef1" translate="yes" xml:space="preserve">
          <source>Unsigned integer counter, incremented with each transaction</source>
          <target state="translated">无符号整数,每次交易时递增。</target>
        </trans-unit>
        <trans-unit id="3c2ab651c10dcd781af9d81861dc05c7e00cd0e4" translate="yes" xml:space="preserve">
          <source>Unused bytes of on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae451c5b9e60f30746c607b23e33192b93fe52d" translate="yes" xml:space="preserve">
          <source>Unused padding space. Must be zero.</source>
          <target state="translated">未使用的填充空间。必须为零。</target>
        </trans-unit>
        <trans-unit id="e3a057d9b649ee6d00a614b6de91fb18fda426f0" translate="yes" xml:space="preserve">
          <source>Unused pages in the database file are stored on a freelist. The 4-byte big-endian integer at offset 32 stores the page number of the first page of the freelist, or zero if the freelist is empty. The 4-byte big-endian integer at offset 36 stores stores the total number of pages on the freelist.</source>
          <target state="translated">数据库文件中未使用的页面被存储在自由列表中。位于偏移量32的4字节大整数,存储自由列表第一页的页码,如果自由列表为空,则存储0。偏移量36处的4字节大恩迪安整数存储了自由列表的总页数。</target>
        </trans-unit>
        <trans-unit id="533ec3a09a391d616af998c213244ec0a1e5a3cc" translate="yes" xml:space="preserve">
          <source>Unused space reserved for further expansion.</source>
          <target state="translated">为进一步扩展而保留的未使用空间。</target>
        </trans-unit>
        <trans-unit id="c494dd09b1047ff61f225fbdc40bf010e62739a8" translate="yes" xml:space="preserve">
          <source>Unused space set aside for 8 file locks.</source>
          <target state="translated">预留8个文件锁的未使用空间。</target>
        </trans-unit>
        <trans-unit id="6ccb1ae240f52b5b4ac6a0a3624ae84ecc9e72d1" translate="yes" xml:space="preserve">
          <source>Up to 32K columns in a table and unlimited rows</source>
          <target state="translated">在一个表格中最多可以有32K列,并且不限行数</target>
        </trans-unit>
        <trans-unit id="6b12c595d758d017b4f8b2df393f1e4bc59a0386" translate="yes" xml:space="preserve">
          <source>Up to 64-way joins</source>
          <target state="translated">最多64路连接</target>
        </trans-unit>
        <trans-unit id="cb305c54c2dd32659178ffaaae86eb202de286b0" translate="yes" xml:space="preserve">
          <source>Upcoming maintenance releases announced on the sqlite-users and sqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about two weeks prior to the anticipated release. Approximately one week prior to release, the lead developer declares &quot;pencils down&quot; after which only bug-fix check-ins are allowed on trunk. A new &lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; is created and updated as needed. As items of the checklist are verified, they are checked off and turn green. The release occurs when all elements of the checklist are green. That process normally takes about a week.</source>
          <target state="translated">在sqlite-users和sqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;邮件列表中&lt;/a&gt;宣布的即将发布的维护版本比预期版本提前约两周。大约在发布前一周，主要开发人员宣布&amp;ldquo;关闭铅笔&amp;rdquo;，之后仅允许在主干上进行错误修复检入。将创建一个新的&lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;发行清单&lt;/a&gt;，并根据需要进行更新。核对清单中的项目后，将其选中并变为绿色。当清单的所有元素均为绿色时，将发生释放。该过程通常需要大约一周的时间。</target>
        </trans-unit>
        <trans-unit id="8621615ea5e13954070618a81964dc62abe12dff" translate="yes" xml:space="preserve">
          <source>Update 2003-07-13:</source>
          <target state="translated">2003-07-13更新。</target>
        </trans-unit>
        <trans-unit id="e6d951c5abc007e402d1496a11b3024eba850b99" translate="yes" xml:space="preserve">
          <source>Update cygwin interfaces to omit deprecated API calls.</source>
          <target state="translated">更新cygwin接口,以省略过时的API调用。</target>
        </trans-unit>
        <trans-unit id="f8692a500a2140ecfbdf4ae0b2b2fa362f3e4d18" translate="yes" xml:space="preserve">
          <source>Update on 2018-11-24: This section was important when the NGQP was new. But five years have elapsed, the NGQP has been deployed successfully to billions of devices, and everyone has upgraded. The upgrade hazard has vanished. This section is retained for historical reference only. Modern reads can skip ahead to the &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt;.</source>
          <target state="translated">2018年11月24日更新：当NGQP是新的时，此部分很重要。但是五年过去了，NGQP已成功部署到数十亿台设备，并且每个人都进行了升级。升级的危险已消失。本节保留，仅供历史参考。现代读物可以跳到&lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;查询计划器清单&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7a5f87f2cf88e6e7e5e6ca7b270c03397b5d3d9" translate="yes" xml:space="preserve">
          <source>Update or delete the row in the parent table,</source>
          <target state="translated">更新或删除父表中的行。</target>
        </trans-unit>
        <trans-unit id="eadf20cb1fcf64b516be4d0e9aca0f806ea0946c" translate="yes" xml:space="preserve">
          <source>Update the &quot;.import&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to support multi-line fields and correct RFC-4180 quoting and to issue warning and/or error messages if the input text is not strictly RFC-4180 compliant.</source>
          <target state="translated">如果输入文本不严格符合RFC-4180 ，请在&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;更新&amp;ldquo; .import&amp;rdquo;命令以支持多行字段并更正RFC-4180引用，并发出警告和/或错误消息。</target>
        </trans-unit>
        <trans-unit id="95e555f2b3f8baa46d6d1c3fa11a385e51f02eb2" translate="yes" xml:space="preserve">
          <source>Update the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to make use of the enhanced virtual table interface.</source>
          <target state="translated">更新&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;以利用增强的虚拟表界面。</target>
        </trans-unit>
        <trans-unit id="afd4ef5f9984771affe8a02ef21dc1f52c746e3a" translate="yes" xml:space="preserve">
          <source>Update the NULL-handling documentation.</source>
          <target state="translated">更新NULL处理文档。</target>
        </trans-unit>
        <trans-unit id="8eb7bca41bb60469d609f31a7c94a8af987dd0b7" translate="yes" xml:space="preserve">
          <source>Update the _FILE_OFFSET_BITS macro so that builds work again on QNX.</source>
          <target state="translated">更新 _FILE_OFFSET_BITS 宏,以便在 QNX 上重新构建。</target>
        </trans-unit>
        <trans-unit id="83db802c5575f2f5c375cb1b62089d3a370412c6" translate="yes" xml:space="preserve">
          <source>Update the banner on the command-line shell to alert novice users when they are using an ephemeral in-memory database.</source>
          <target state="translated">更新命令行shell上的横幅,以提醒新手用户在使用短暂的内存数据库时。</target>
        </trans-unit>
        <trans-unit id="5deccb253aff130770ec3068052cf362ce9ebe27" translate="yes" xml:space="preserve">
          <source>Update the built-in &lt;a href=&quot;fts3&quot;&gt;FTS3/FTS4&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; virtual tables to support &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses and &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;.</source>
          <target state="translated">更新内置的&lt;a href=&quot;fts3&quot;&gt;FTS3 / FTS4&lt;/a&gt;和&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;虚拟表以支持&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;子句和&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b504122b8dfef94ab33eb2666fd1889d16053291" translate="yes" xml:space="preserve">
          <source>Update the text of error messages returned by &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; for some error codes.</source>
          <target state="translated">将&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;返回的错误消息文本更新为一些错误代码。</target>
        </trans-unit>
        <trans-unit id="f19ef97f712dc9336cd9881c1cc678760d93cdf8" translate="yes" xml:space="preserve">
          <source>Update: As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10) the use of AFL has been superceded by the new &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer described below.</source>
          <target state="translated">更新：从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;3.29.0版&lt;/a&gt;（2019-07-10）开始，AFL的使用已被下面所述的新&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz模糊&lt;/a&gt;器取代。</target>
        </trans-unit>
        <trans-unit id="c202e0c1d72e2322ab1803ee32b5877979d2de60" translate="yes" xml:space="preserve">
          <source>Update: New measurements for SQLite version 3.19.0 (2017-05-22) show that SQLite is about &lt;a href=&quot;fasterthanfs&quot;&gt;35% faster&lt;/a&gt; than direct disk I/O for both reads and writes of 10KB blobs.</source>
          <target state="translated">更新：SQLite 3.19.0版（2017-05-22）的新测量表明，对于10KB Blob的读取和写入，SQLite 比直接磁盘I / O &lt;a href=&quot;fasterthanfs&quot;&gt;快35％&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a960dbfb2b124d6ed06bf7e934a25380bb894d60" translate="yes" xml:space="preserve">
          <source>Update: The &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; command introduced in SQLite version 3.27.0 (2019-02-07) can serve as an alternative to the backup API.</source>
          <target state="translated">更新：SQLite版本3.27.0（2019-02-07）中引入的&lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt;命令可以替代备份API。</target>
        </trans-unit>
        <trans-unit id="ae9f91d2ff06391addf58fdcc8dd4af3777ab8ac" translate="yes" xml:space="preserve">
          <source>Updated the &quot;unix-dotfile&quot; &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to use locking directories with mkdir() and rmdir() instead of locking files with open() and unlink().</source>
          <target state="translated">更新了&amp;ldquo; unix-dotfile&amp;rdquo; &lt;a href=&quot;vfs&quot;&gt;VFS，&lt;/a&gt;以使用带有mkdir（）和rmdir（）的锁定目录，而不是带有open（）和unlink（）的锁定文件。</target>
        </trans-unit>
        <trans-unit id="9ecd4cacc54f9eb845eb05b8c1cec0b8deaabeb2" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it can be built using &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; and &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;.</source>
          <target state="translated">更新了&lt;a href=&quot;cli&quot;&gt;命令行外壳程序，&lt;/a&gt;以便可以使用&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;和&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;进行构建。</target>
        </trans-unit>
        <trans-unit id="ae68475963e11d8ffb9d1743f7f05f6343c16e81" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;nulls&quot;&gt;NULL-handling document&lt;/a&gt;.</source>
          <target state="translated">更新了&lt;a href=&quot;nulls&quot;&gt;NULL处理文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cc8e0782c7a9b456827f5ac2f3deff6afb93a61" translate="yes" xml:space="preserve">
          <source>Updated the documentation for due to the above change.</source>
          <target state="translated">由于上述变化,更新了文件。</target>
        </trans-unit>
        <trans-unit id="e10ae62e4bb036329cb9ea0d831ba16069afdf6b" translate="yes" xml:space="preserve">
          <source>Updates to &lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly()&lt;/a&gt; so that its result is well-defined for all prepared statements and so that it works with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">更新为&lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly（），&lt;/a&gt;以便为所有准备好的语句明确定义其结果，并使其与&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="611a149936e51e86e5dc517a30918e94113a5c96" translate="yes" xml:space="preserve">
          <source>Updates to comments and documentation.</source>
          <target state="translated">更新评论和文件。</target>
        </trans-unit>
        <trans-unit id="5cd9f8d0a6523c89d101b12728ca830f506daa93" translate="yes" xml:space="preserve">
          <source>Updates to the FAQ</source>
          <target state="translated">更新常见问题</target>
        </trans-unit>
        <trans-unit id="225b3af8e67127ee3d34043567f27a4b206ed152" translate="yes" xml:space="preserve">
          <source>Updates to the co-hosted &lt;a href=&quot;lemon&quot;&gt;Lemon LALR(1) parser generator&lt;/a&gt;. (These updates did not affect SQLite.)</source>
          <target state="translated">更新到共同托管的&lt;a href=&quot;lemon&quot;&gt;Lemon LALR（1）解析器生成器&lt;/a&gt;。（这些更新不影响SQLite。）</target>
        </trans-unit>
        <trans-unit id="5ff086f286850610a359720beb1814b02bde490c" translate="yes" xml:space="preserve">
          <source>Updates to the man page</source>
          <target state="translated">更新手册页面</target>
        </trans-unit>
        <trans-unit id="0b579189066ad6233ab9a30e75015931b715153e" translate="yes" xml:space="preserve">
          <source>Upgrade to an</source>
          <target state="translated">升级为</target>
        </trans-unit>
        <trans-unit id="fa23bdbf593290f21c99984edfe7206d0b3f48ab" translate="yes" xml:space="preserve">
          <source>Upgraded the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_parameter()&lt;/a&gt; function so that it works with the rollback journal or WAL filename in addition to the database filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e621618c30d2d51e0e7eb2f7c9980b70d460c6" translate="yes" xml:space="preserve">
          <source>Upgrading SQLite, Backwards Compatibility</source>
          <target state="translated">升级SQLite,向下兼容</target>
        </trans-unit>
        <trans-unit id="f63424e9ccf9758aa115a08c1ca29da89505f175" translate="yes" xml:space="preserve">
          <source>Upgrading to an Exclusive Lock</source>
          <target state="translated">升级到专属锁</target>
        </trans-unit>
        <trans-unit id="0b7b831bc0dc4db0969e61d108d5ed08e60a2a5a" translate="yes" xml:space="preserve">
          <source>Usable size</source>
          <target state="translated">可用尺寸</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="f7d660e7e185b02ed0b42d1ed9b98bb6209a9521" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; at the top of your source code files instead of &quot;&lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">在源代码文件的顶部使用&amp;ldquo; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &amp;rdquo;，而不是&amp;ldquo; &lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="62e753b43ef69616b1563515522f39fb45747e31" translate="yes" xml:space="preserve">
          <source>Use &quot;trunk&quot; for</source>
          <target state="translated">用 &quot;树干 &quot;表示</target>
        </trans-unit>
        <trans-unit id="237aa140efed61c820a219860ca38adb64fb7ec3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace()&lt;/a&gt; instead of &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; for escaping newline and carriage-return characters embedded in strings in the .dump output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace（）&lt;/a&gt;代替&lt;a href=&quot;lang_corefunc#char&quot;&gt;char（）&lt;/a&gt;来转义嵌入在&lt;a href=&quot;cli&quot;&gt;命令行shell&lt;/a&gt; .dump输出中字符串中的换行符和回车符。</target>
        </trans-unit>
        <trans-unit id="c7a8d415f6b6311567858afd10504aff2606d36c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;, and &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; to reconstruct indexes, triggers, and views associated with table X. Perhaps use the old format of the triggers, indexes, and views saved from step 3 above as a guide, making changes as appropriate for the alteration.</source>
          <target state="translated">使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;，&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;和&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;来重建与表X关联的索引，触发器和视图。也许可以使用上面第3步中保存的触发器，索引和视图的旧格式作为指导，进行相应的更改改变。</target>
        </trans-unit>
        <trans-unit id="536befb3634409293843309bd592f3735064b803" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; to construct a new table &quot;new_X&quot; that is in the desired revised format of table X. Make sure that the name &quot;new_X&quot; does not collide with any existing table name, of course.</source>
          <target state="translated">使用&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;构造一个新的表&amp;ldquo; new_X&amp;rdquo;，该表具有表X的所需修订格式。当然，请确保名称&amp;ldquo; new_X&amp;rdquo;不与任何现有表名冲突。</target>
        </trans-unit>
        <trans-unit id="4324752dc06a9ac4571627fdbc5052d079c7ceec" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement to create a new index on one or more expressions just like you would to create an index on columns. The only difference is that expressions are listed as the elements to be indexed rather than column names.</source>
          <target state="translated">使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句在一个或多个表达式上创建新索引，就像在列上创建索引一样。唯一的区别是表达式被列为要索引的元素，而不是列名。</target>
        </trans-unit>
        <trans-unit id="7496f7181dc9302ddc248c78082db1a132361364" translate="yes" xml:space="preserve">
          <source>Use a negative column width for right-justified columns.</source>
          <target state="translated">对右对齐的列使用负列宽。</target>
        </trans-unit>
        <trans-unit id="5ed5b81249d213d275afc651f4e6fd002e1e541a" translate="yes" xml:space="preserve">
          <source>Use a separate mutex on every inode in the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, rather than a single mutex shared among them all, for slightly better concurrency in multi-threaded environments.</source>
          <target state="translated">在unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;中的每个索引节点上使用单独的互斥锁，而不是在它们之间共享一个互斥锁，以便在多线程环境中更好地并发。</target>
        </trans-unit>
        <trans-unit id="de146a75582fa0d61aaa74e50c8ce2d58d1921c8" translate="yes" xml:space="preserve">
          <source>Use an index to satisfy an IS NULL operator in the WHERE clause</source>
          <target state="translated">在WHERE子句中使用索引来满足IS NULL操作符。</target>
        </trans-unit>
        <trans-unit id="6bdba762bb27236a6cb868fd917b885a3fb66243" translate="yes" xml:space="preserve">
          <source>Use compiler built-ins __builtin_sub_overflow(), __builtin_add_overflow(), and __builtin_mul_overflow() when available. (All compiler built-ins can be omitted with the &lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt; compile-time option.)</source>
          <target state="translated">使用编译器内置的__builtin_sub_overflow（），__ builtin_add_overflow（）和__builtin_mul_overflow（）。（可使用&lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt;编译时选项忽略所有编译器内置函数。）</target>
        </trans-unit>
        <trans-unit id="137cf73aa42452fce0415a41813408b4501767a7" translate="yes" xml:space="preserve">
          <source>Use either disk or memory storage for temporary files as determined by the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">使用&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数确定的临时文件使用磁盘或内存存储。</target>
        </trans-unit>
        <trans-unit id="2af669874066cde2346e922c573e9e835ac690a1" translate="yes" xml:space="preserve">
          <source>Use fdatasync() instead of fsync() where possible in order to speed up commits slightly</source>
          <target state="translated">尽可能使用fdatasync()代替fsync(),以稍微加快提交速度。</target>
        </trans-unit>
        <trans-unit id="50f06d5432236287d8673fac9ba31c9f7a72e979" translate="yes" xml:space="preserve">
          <source>Use files by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">默认情况下使用文件，但允许&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt;命令覆盖</target>
        </trans-unit>
        <trans-unit id="263a25f617f6abfd3d532ea4693a64ebfdbddfbe" translate="yes" xml:space="preserve">
          <source>Use heap space instead of stack space for large buffers in the pager - useful on embedded platforms with stack-space limitations.</source>
          <target state="translated">对寻呼机中的大缓冲区使用堆空间而不是栈空间--在有栈空间限制的嵌入式平台上很有用。</target>
        </trans-unit>
        <trans-unit id="3a48cc9a1a2d824c57ec5e25aeb6cff31334d1e8" translate="yes" xml:space="preserve">
          <source>Use indices to help with GLOB expressions and LIKE expressions too when the case_sensitive_like pragma is enabled</source>
          <target state="translated">当启用case_sensitive_like pragma时,使用索引来帮助GLOB表达式和LIKE表达式。</target>
        </trans-unit>
        <trans-unit id="bc1fcae1e921cce9fd520fbec66677338b3c72ed" translate="yes" xml:space="preserve">
          <source>Use less memory by not remembering CHECK constraints on read-only database connections.</source>
          <target state="translated">通过不记忆只读数据库连接上的CHECK约束,使用更少的内存。</target>
        </trans-unit>
        <trans-unit id="0f855b65765fc8c17befd3c681198b2b5b5c7616" translate="yes" xml:space="preserve">
          <source>Use memmove() instead of memcpy() when moving between memory regions that might overlap. Ticket #2334</source>
          <target state="translated">在可能重叠的内存区域之间移动时,使用 memmove()而不是 memcpy()。Ticket #2334</target>
        </trans-unit>
        <trans-unit id="469854fc5e213a56cb9e96864bf70b794360aa2e" translate="yes" xml:space="preserve">
          <source>Use memory by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">默认情况下使用内存，但允许&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt;命令覆盖</target>
        </trans-unit>
        <trans-unit id="48a8e3645a8edde160a5adbd651d1d588f3d82af" translate="yes" xml:space="preserve">
          <source>Use of the CROSS keyword in a join turns off the table reordering optimization</source>
          <target state="translated">在连接中使用CROSS关键字会关闭表的重新排序优化。</target>
        </trans-unit>
        <trans-unit id="4efb979f35de88aa03beb8b52191a1054ccebd97" translate="yes" xml:space="preserve">
          <source>Use single-quotes, not double-quotes, around string literals in SQL. This is what the SQL standard requires. Your WHERE clause expression should read: &lt;code&gt;column1='column1'&lt;/code&gt;</source>
          <target state="translated">在SQL的字符串文字中使用单引号而不是双引号。这就是SQL标准的要求。您的WHERE子句表达式应显示为： &lt;code&gt;column1='column1'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc43b1a2c6a31ffdd8561f57d1fbf734126319be" translate="yes" xml:space="preserve">
          <source>Use sqlite3_mprintf() instead of strdup() to avoid libc dependencies</source>
          <target state="translated">使用sqlite3_mprintf()代替strdup()来避免libc依赖性。</target>
        </trans-unit>
        <trans-unit id="b154d5767d626fe947b811cbac8223761d775253" translate="yes" xml:space="preserve">
          <source>Use the &quot;.dump&quot; command to convert the entire contents of a database into a single ASCII text file. This file can be converted back into a database by piping it back into &lt;b&gt;sqlite3&lt;/b&gt;.</source>
          <target state="translated">使用&amp;ldquo; .dump&amp;rdquo;命令将数据库的全部内容转换为单个ASCII文本文件。可以通过将其通过管道传输回&lt;b&gt;sqlite3&lt;/b&gt;来将其转换回数据库。</target>
        </trans-unit>
        <trans-unit id="031acdfcfcb7c6ac30666a1a6360f5fb4b5b9407" translate="yes" xml:space="preserve">
          <source>Use the &quot;.import&quot; command to import CSV (comma separated value) data into an SQLite table. The &quot;.import&quot; command takes two arguments which are the name of the disk file from which CSV data is to be read and the name of the SQLite table into which the CSV data is to be inserted.</source>
          <target state="translated">使用&quot;.import &quot;命令将CSV(逗号分隔值)数据导入到SQLite表中。&quot;.import &quot;命令有两个参数,分别是要读取CSV数据的磁盘文件的名称和要插入CSV数据的SQLite表的名称。</target>
        </trans-unit>
        <trans-unit id="1514a3f709961a8c5a81dddff2a1805d46c2a271" translate="yes" xml:space="preserve">
          <source>Use the &quot;.separator&quot; dot command to change the separator. For example, to change the separator to a comma and a space, you could do this:</source>
          <target state="translated">使用&quot;.separator &quot;点命令来改变分隔符。例如,要将分隔符改为逗号和空格,可以这样做。</target>
        </trans-unit>
        <trans-unit id="7e3a1db63b5ffcfa0304033285d6169940ca5e9f" translate="yes" xml:space="preserve">
          <source>Use the &quot;&lt;code&gt;fossil ui&lt;/code&gt;&quot; command from within the ~/sqlite checkout to bring up a local copy of the website.</source>
          <target state="translated">在〜/ sqlite结帐中，使用&amp;ldquo; &lt;code&gt;fossil ui&lt;/code&gt; &amp;rdquo;命令调出该网站的本地副本。</target>
        </trans-unit>
        <trans-unit id="2314ee65a646ac667a54b17ec0394586fd245f83" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">使用&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定打开的Blob的大小。此接口可能无法更改Blob的大小。使用&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL命令更改Blob的大小。</target>
        </trans-unit>
        <trans-unit id="36f9cf35dec4a270350f0bd2263a94cc3699ef47" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">使用&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定打开的Blob的大小。此接口可能无法更改Blob的大小。使用&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL命令更改Blob的大小。</target>
        </trans-unit>
        <trans-unit id="bd4ed3d4650cd4e7bc264eb1acc9e459a702bd1f" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter to selected the threading mode. If no &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter is present, then serialized mode is used. This can be made explicit with &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=1&lt;/a&gt;. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; the threading mode is single-thread. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=2&lt;/a&gt; the threading mode is multi-thread.</source>
          <target state="translated">使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;编译时参数选择线程模式。如果不存在&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;编译时参数，则使用序列化模式。可以使用&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 1&lt;/a&gt;使其明确。使用&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0时&lt;/a&gt;，线程模式为单线程。使用&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 2时&lt;/a&gt;，线程模式为多线程。</target>
        </trans-unit>
        <trans-unit id="274f4747a1320d774731188d128cb3683b032794" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; even if the right-hand side string contains no wildcards.</source>
          <target state="translated">即使右侧字符串不包含通配符，也请使用&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f4e51240cb42418de496e090c0f24ccbb024987" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; SQL statement to disable trusted schema. This has the same effect as the previous bullet, but does not require the use of C-code and hence can be performed in programs written in another programming language and that do not have access SQLite C-language APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5308e85c61acbd7495be650845b12311f9dc3964" translate="yes" xml:space="preserve">
          <source>Use the &lt;b&gt;sqlite_open&lt;/b&gt; function to open an existing SQLite database or to create a new SQLite database. The first argument is the database name. The second argument is intended to signal whether the database is going to be used for reading and writing or just for reading. But in the current implementation, the second argument to &lt;b&gt;sqlite_open&lt;/b&gt; is ignored. The third argument is a pointer to a string pointer. If the third argument is not NULL and an error occurs while trying to open the database, then an error message will be written to memory obtained from malloc() and *errmsg will be made to point to this error message. The calling function is responsible for freeing the memory when it has finished with it.</source>
          <target state="translated">使用&lt;b&gt;sqlite_open&lt;/b&gt;函数打开现有的SQLite数据库或创建新的SQLite数据库。第一个参数是数据库名称。第二个参数旨在表明该数据库是用于读取还是写入还是仅用于读取。但是在当前实现中，忽略&lt;b&gt;sqlite_open&lt;/b&gt;的第二个参数。第三个参数是指向字符串指针的指针。如果第三个参数不为NULL，并且在尝试打开数据库时发生错误，则错误消息将写入从malloc（）获得的内存中，并将使* errmsg指向此错误消息。调用函数负责在完成处理后释放内存。</target>
        </trans-unit>
        <trans-unit id="c6d46e33d7807116ac9add91d72550fca2ffbf23" translate="yes" xml:space="preserve">
          <source>Use the WHERE clause to reduce the size of a materialized VIEW in an UPDATE or DELETE statement. (Optimization)</source>
          <target state="translated">在UPDATE或DELETE语句中,使用WHERE子句来缩小物化VIEW的大小。(优化)</target>
        </trans-unit>
        <trans-unit id="efe8cfb25313b8ffdcda22d1d22b3397432240d2" translate="yes" xml:space="preserve">
          <source>Use the correct affinity for columns of automatic indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt;.</source>
          <target state="translated">对自动索引的列使用正确的相似性。票证&lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d6f456699b36362dd68589f9f76baf09757ec2f" translate="yes" xml:space="preserve">
          <source>Use the decimal_cmp(A,B) to compare two decimal values. The result will be negative, zero, or positive if A is less than, equal to, or greater than B, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8484df7605c1331750609f898da67fe4dcaeabf" translate="yes" xml:space="preserve">
          <source>Use the macro SQLITE_PRIVATE (defaulting to &quot;static&quot;) on all internal functions in the amalgamation.</source>
          <target state="translated">在合并中的所有内部函数上使用宏SQLITE_PRIVATE(默认为 &quot;静态&quot;)。</target>
        </trans-unit>
        <trans-unit id="bc78bf67fa7d6c1c485c06940843c7741c22f19b" translate="yes" xml:space="preserve">
          <source>Use the new &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface to improve the performance of FTS.</source>
          <target state="translated">使用新的&lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;接口来提高FTS的性能。</target>
        </trans-unit>
        <trans-unit id="3b2244da3774583cbb3fc1a48e72dfd44d3ab95d" translate="yes" xml:space="preserve">
          <source>Use the normal SQLite API to read and write to databases via the asynchronous IO VFS.</source>
          <target state="translated">使用普通的SQLite API通过异步IO VFS对数据库进行读写。</target>
        </trans-unit>
        <trans-unit id="26f92b5c0905f544db1bb7d8ca5ebd0ed63e16d8" translate="yes" xml:space="preserve">
          <source>Use the resulting &quot;kvtest&quot; program to generate a test database with 100,000 random uncompressible blobs, each with a random size between 8,000 and 12,000 bytes using a command like this:</source>
          <target state="translated">使用生成的 &quot;kvtest &quot;程序生成一个具有100,000个随机不可压缩的blobs的测试数据库,每个blobs的随机大小在8,000到12,000字节之间,使用这样的命令。</target>
        </trans-unit>
        <trans-unit id="7834abce7ece24f8701462e346703566e2de3e27" translate="yes" xml:space="preserve">
          <source>Use the schema-defined &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; instead of the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to pair rows in the source and destination database. (See additional explanation below.)</source>
          <target state="translated">使用模式定义的&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY（&lt;/a&gt;而不是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid）&lt;/a&gt;来配对源数据库和目标数据库中的行。（请参阅下面的其他说明。）</target>
        </trans-unit>
        <trans-unit id="02df1e951c416cb903ab43afc2694bfdea186be2" translate="yes" xml:space="preserve">
          <source>Use the strcspn() C-library routine to speed up the LIKE and GLOB operators.</source>
          <target state="translated">使用strcspn()C库例程来加快LIKE和GLOB运算符的速度。</target>
        </trans-unit>
        <trans-unit id="f1f443135d8d6987de124f0e64e3f9227d9a5c27" translate="yes" xml:space="preserve">
          <source>Use the transitive property to try to propagate constant values within the WHERE clause. For example, convert &quot;a=99 AND b=a&quot; into &quot;a=99 AND b=99&quot;.</source>
          <target state="translated">使用转置属性尝试在WHERE子句中传播常量值。例如,将 &quot;a=99 AND b=a &quot;转换为 &quot;a=99 AND b=99&quot;。</target>
        </trans-unit>
        <trans-unit id="0ea0700fa56071e98d4cc761a6e621b61eff1903" translate="yes" xml:space="preserve">
          <source>Use the unicode API in Windows</source>
          <target state="translated">在Windows中使用unicode API</target>
        </trans-unit>
        <trans-unit id="97776a8d79289b0d1017fb264bc954bd7ad83946" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#aggregate-function-invocation&quot;&gt;聚合函数调用&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;创建索引index-mt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;触发触发器-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;删除stmt-有限因&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;式选择-stmt &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;过滤器子句&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;框架规范&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;索引-列&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;加入约束&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;排序项&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;结果列&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;选择核心&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;简单函数调用&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;表约束&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-子句&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3cfe8ec4e623b595e4ac50171983c062621b492" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#aggregate-function-invocation&quot;&gt;聚合函数调用&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;窗口函数调用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9fa16a928ddc1dc237caf8ee5a2f33829abb8c95" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;创建表-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7605fd600c574fecb47de09ab5decde53c108336" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9d132b987e9571018a10419466ce9e4241f4144" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;编译指示值&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;类型名称&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6859f1dc44376fa95c8d38fdf3b6141e03d2c1ae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;表约束&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a380af02d8c9c93f329808cab4b27595f6a4a3c5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d289a73c451effafc4667d2bf1f3b0e030afac60" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a431a18a7738c53de3472c652954e2bc59958670" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;带子句的&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="224be4c1f3c548d22132987eb2bf278a86171468" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb141b71ecdf70ef024445a846b6364ea02ee67" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;删除stmt限制&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;简单选择stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;更新stmt受限&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab6cea255f6025204d21b009964174b973b40cd6" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;选择stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;简单选择stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9a35f3e8899c13b9a454dc09b2554a9fc11894f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;简单选择stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56b558cf19b1f43efb09e7c3cf6f834bdf6f9e08" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;表约束&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ed338e20414f7c9ffcbc59e0281f80cccd5a763" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b50a14ac773fa0a58261d63783e57e4cbe15c68" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed0705dac87c2b47586b5a816bab059a80c3dff1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#delete-stmt&quot;&gt;使用者&lt;/a&gt;：delete-stmt &lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fed14e0505bafc78d4d9d690a2b7426f9c8198b2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#delete-stmt&quot;&gt;用法&lt;/a&gt;：delete-stmt &lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a021ee5a9dccd79e0bc3acd62766c09cd9fb8cae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="082ab3c78daf3f012c8a8cd5f4c53643a071209a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09a6e3cc1f24c34ba4f2a0f20d3c51dbe35db3c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#insert-stmt&quot;&gt;使用者&lt;/a&gt;：insert-stmt</target>
        </trans-unit>
        <trans-unit id="97d8dfd0bb5c0f6552eb23078a3e1e860cc9a6c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed8783360dda42990afd13092353a2478b98c818" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4cd678b8b993f3438c0117dedb1f0fd21e9e1b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af677aaf273d3f1f76df6b503b77ba2fd60bed2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">用于：&lt;a href=&quot;#over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8079f3adf01a444617315e6ee69c27b2f0e4367b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#pragma-stmt&quot;&gt;使用者&lt;/a&gt;：pragma-stmt</target>
        </trans-unit>
        <trans-unit id="80938cb5970c9483ff312171cb2cce6f1c888a48" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#recursive-cte&quot;&gt;使用者&lt;/a&gt;：递归cte &lt;a href=&quot;#with-clause&quot;&gt;从句&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ae852a57048a30f81de513ccc896f0c0dd648fe" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3f7cbedd2f19d68e5c65e3a5494b079eb45e6d0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="589e0a5319c833b4b7bc5d107ed94b7fe1c7d8cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ea943fa5a24500d0b2de81bfcae0c263e9c947" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;窗口函数调用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6ef1477fa5df999acf552fb4e67164b37b0a48f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#sql-stmt&quot;&gt;使用者&lt;/a&gt;：sql-stmt</target>
        </trans-unit>
        <trans-unit id="b6d1945ca75963e8557621ed71f512d0d1f8a13e" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#sql-stmt-list&quot;&gt;使用者&lt;/a&gt;：sql-stmt-list</target>
        </trans-unit>
        <trans-unit id="1042aa6c3f092cc75f0c8a676be3f2d32a0e48e0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#update-stmt&quot;&gt;使用者&lt;/a&gt;：update-stmt &lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1f1be8756f8f6e3850d5a9e7441499016850919" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;aggregate-function-invocation&quot;&gt;聚合函数调用&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;创建索引index-mt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;触发触发器-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;删除stmt-有限因&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;式选择-stmt &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;过滤器子句&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;框架规范&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;索引-列&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;加入约束&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;排序项&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;结果列&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;选择核心&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;简单函数调用&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;表约束&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-子句&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dba34c5ead7ae94617f98c7cde1dd99c8cf20f1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;aggregate-function-invocation&quot;&gt;聚合函数调用&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;窗口函数调用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="307e140208125cd798472be7cbdee684ec27af23" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;创建表-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5caeae659f486a37e2e78f0f36394d00574f259" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a86521d0d079a24ae129812150a3753aecda3e41" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;编译指示值&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;类型名称&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4797572b6c11d132a08e6eb97c1346965d8c3891" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;表约束&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="530c72cf587d62fa294e2381602271f96f0f96d7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bae571e21875de9dbe7973158d01f4c614d8c361" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d621ef2d30a77aac0f67e4cb22f0496953330ae4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;带子句的&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7999cb7cebc65a8fd79ca0339c4bb490ea515b01" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0856e25a6da8ebb570311e60dcc92e62c9700b8" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;删除stmt限制&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;简单选择stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;更新stmt受限&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21f8541c9dc2a69fa16cf43b335b7b363315d397" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;选择stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;简单选择stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ab6ebc8f279a3034f0fdb604843d248415ee1bf" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;简单选择stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9b73b88651ef8bf860289b6de3757bded750bc5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;表约束&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f17754185255593ea4e239b7777c291185f4d22a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1250d862d07127e87b9840caf01bde3487514be4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ffe5f5730adb72eee0e8790e0d4f442453ca532" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;delete-stmt&quot;&gt;使用者&lt;/a&gt;：delete-stmt &lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b346b7bdc3d0ceef5715a064d5778a794c30fe18" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;delete-stmt&quot;&gt;使用者&lt;/a&gt;：delete-stmt &lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecd461adaec5db6b876f0dff52c7be72090d1b14" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d46198801b0b7bba9815dc12e4cdb3e29b72db5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79c1bf6cb1bf604130309cdb21b4f8fbff437aa3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;insert-stmt&quot;&gt;使用者&lt;/a&gt;：insert-stmt</target>
        </trans-unit>
        <trans-unit id="9892cdf8b7abbe2222939b3dd694fd626893c60f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8026c06ece9d695e8c405568f97c947f459d098" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e21ce3a84da1747a72ee6509dcd2b66aa22588d4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9280252176a18a8cad0168e3316dcfbe48390b81" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">用于：&lt;a href=&quot;over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98a46233f40109c7b176062c4c3a604629e49ee7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma-stmt&quot;&gt;使用者&lt;/a&gt;：pragma-stmt</target>
        </trans-unit>
        <trans-unit id="b50593211eada2909f681edc15211383687e61a9" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;recursive-cte&quot;&gt;使用者&lt;/a&gt;：递归cte &lt;a href=&quot;with-clause&quot;&gt;从句&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36f9352a3528ee1d344ab047f86be842bf862c8a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7939044785ba0a8ca2c0b2b3b645bfec873f9c5c" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8113b13214eea91b3a3368ba7da6ad54a4268b3b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd5b650bb8cb46f8defc106f0dfcc99d5b051cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;窗口函数调用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4594a38d58964e1e237c00459543be8431bc246" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;sql-stmt&quot;&gt;使用者&lt;/a&gt;：sql-stmt</target>
        </trans-unit>
        <trans-unit id="35b40c8cd50b969bfb81394dd732cd863e0cd4d1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;sql-stmt-list&quot;&gt;使用者&lt;/a&gt;：sql-stmt-list</target>
        </trans-unit>
        <trans-unit id="b23afd53b16f293ca94992760b0d75920c0db155" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;update-stmt&quot;&gt;使用者&lt;/a&gt;：update-stmt &lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a28142d94277b9f824e8d439d35c64935809cf" translate="yes" xml:space="preserve">
          <source>User Data For Functions</source>
          <target state="translated">功能的用户数据</target>
        </trans-unit>
        <trans-unit id="f87f9bec30fa447642063fa0c8666b7e8eb0bcd7" translate="yes" xml:space="preserve">
          <source>User defined functions can be created using the following routine:</source>
          <target state="translated">可以使用以下例程创建用户定义的函数。</target>
        </trans-unit>
        <trans-unit id="444756f6f1895c936bb10bab307f679e2df66fa7" translate="yes" xml:space="preserve">
          <source>User-definable text collating sequences.</source>
          <target state="translated">用户可自定义文本整理序列。</target>
        </trans-unit>
        <trans-unit id="41cabf87c0640a35632815a9c1c75379f4b103ed" translate="yes" xml:space="preserve">
          <source>User-defined Collating Sequences</source>
          <target state="translated">用户自定义整理序列</target>
        </trans-unit>
        <trans-unit id="679b4a0d57b60e54b747cb9aacd21774ca84d965" translate="yes" xml:space="preserve">
          <source>User-defined aggregate window functions may be created using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt;() API. Implementing an aggregate window function is very similar to an ordinary aggregate function. Any user-defined aggregate window function may also be used as an ordinary aggregate. To implement a user-defined aggregate window function the application must supply four callback functions:</source>
          <target state="translated">可以使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt;（）API 创建用户定义的聚合窗口函数。实现聚合窗口功能与普通聚合功能非常相似。任何用户定义的聚合窗口函数也可以用作普通聚合。要实现用户定义的聚合窗口函数，应用程序必须提供四个回调函数：</target>
        </trans-unit>
        <trans-unit id="8cb5450ed96e61339c7346965130b897dcacb151" translate="yes" xml:space="preserve">
          <source>User-defined text collating sequences.</source>
          <target state="translated">用户自定义文本整理序列。</target>
        </trans-unit>
        <trans-unit id="e6d26b2d97c6ea4098987a42caa6c50e042619be" translate="yes" xml:space="preserve">
          <source>Uses 9% fewer CPU cycles. (See the &lt;a href=&quot;cpu&quot;&gt;CPU performance measurement&lt;/a&gt; report for details on how this performance increase was computed.)</source>
          <target state="translated">使用的CPU周期减少了9％。（有关如何计算此性能提升的详细信息，请参阅&lt;a href=&quot;cpu&quot;&gt;CPU性能评估&lt;/a&gt;报告。）</target>
        </trans-unit>
        <trans-unit id="d0301d0d4694000bac42286a893da835217aae2d" translate="yes" xml:space="preserve">
          <source>Uses compiler built-ins (ex: __builtin_bswap32() or _byteswap_ulong()) for byteswapping when available.</source>
          <target state="translated">在可用的情况下,使用编译器内建(例如:__builtin_bswap32()或__byteswap_ulong())进行字节交换。</target>
        </trans-unit>
        <trans-unit id="f10225b09b2eddd2b69fc1125f1e8c1790100225" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; key/value access object instead of SQL for pulling content out of R-Tree nodes</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;键/值访问对象而不是SQL从R-Tree节点中提取内容</target>
        </trans-unit>
        <trans-unit id="bf6a8d8b0b161f49ba5a16ea51a640dcb0e4cfe4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt; and taking an application crash in the middle of a write transaction.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY&lt;/a&gt;并在写事务过程中使应用程序崩溃。</target>
        </trans-unit>
        <trans-unit id="1020c3daf5ee3d9c72ef57a803c58bd0586e47f7" translate="yes" xml:space="preserve">
          <source>Using CREATE or DROP to create or destroy a table or index is really the same as doing an INSERT or DELETE from the special &quot;sqlite_master&quot; table, at least from the point of view of the VDBE. The sqlite_master table is a special table that is automatically created for every SQLite database. It looks like this:</source>
          <target state="translated">使用CREATE或DROP来创建或销毁表或索引,其实和从特殊的 &quot;sqlite_master &quot;表进行INSERT或DELETE是一样的,至少从VDBE的角度来看是这样。sqlite_master表是一个特殊的表,它是为每个SQLite数据库自动创建的。它的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="4d2637c8d86cb85da8f8da94256a0cdc80d9b4c2" translate="yes" xml:space="preserve">
          <source>Using DDL or DML SQL statements, SQLite users may modify the contents and size of a database file. Exactly how changes to the logical database are translated to modifications to the database file is described in</source>
          <target state="translated">使用DDL或DML SQL语句,SQLite用户可以修改数据库文件的内容和大小。具体如何将对逻辑数据库的修改转化为对数据库文件的修改,将在下面描述。</target>
        </trans-unit>
        <trans-unit id="435c55e01cffb5570c6c79cda02f466b6061178b" translate="yes" xml:space="preserve">
          <source>Using Idx2 instead of Idx1 causes SQLite to examine a different set of rows, but it gets the same answer in the end (which is very important - remember that indices should never change the answer, only help SQLite to get to the answer more quickly) and it does the same amount of work. So the Idx2 index did not help performance in this case.</source>
          <target state="translated">使用Idx2而不是Idx1会导致SQLite检查一组不同的行,但最终得到的答案是一样的(这一点非常重要--请记住,索引永远不应该改变答案,只能帮助SQLite更快地得到答案),而且它做的工作量也是一样的。所以在这种情况下,Idx2索引对性能没有帮助。</target>
        </trans-unit>
        <trans-unit id="c7fd16dcb5fbd84cb48400bd250b2f97394100cb" translate="yes" xml:space="preserve">
          <source>Using Indexes To Speed Searching</source>
          <target state="translated">使用索引来加快搜索速度</target>
        </trans-unit>
        <trans-unit id="9f210fd1e7b63cdc7dd0138afd84809f14583a65" translate="yes" xml:space="preserve">
          <source>Using SELECT Statements As Terms In An Expression</source>
          <target state="translated">在表达式中使用SELECT语句作为术语。</target>
        </trans-unit>
        <trans-unit id="97437976ebeb573c52b13ddfd438d2c91bf1893b" translate="yes" xml:space="preserve">
          <source>Using SQLite In Multi-Threaded Applications</source>
          <target state="translated">在多线程应用程序中使用 SQLite</target>
        </trans-unit>
        <trans-unit id="307f31c1c11aebab82631ac4f8b0ab54eca6e078" translate="yes" xml:space="preserve">
          <source>Using a MATCH operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">在SELECT语句的WHERE子句中使用MATCH操作符,或</target>
        </trans-unit>
        <trans-unit id="3e68860fe2d2ad5dc9651e317f240eed014363dc" translate="yes" xml:space="preserve">
          <source>Using a built-in printf() implementation means that SQLite has one fewer dependency on the host environment, making it more portable.</source>
          <target state="translated">使用内置的printf()实现,意味着SQLite少了一个对主机环境的依赖,使其更具可移植性。</target>
        </trans-unit>
        <trans-unit id="c90117e39221737f02ea3e7e44c49c43210beeb3" translate="yes" xml:space="preserve">
          <source>Using a database file with 8+3 filenames in some cases while in other cases using long filenames is equivalent to &lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;deleting a hot journal&lt;/a&gt;.</source>
          <target state="translated">在某些情况下，使用文件名8 + 3的数据库文件，而在其他情况下，使用长文件名等效于&lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;删除热日志&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fb331fbfc19c9ad94dbe708335967012f83cb31" translate="yes" xml:space="preserve">
          <source>Using a dataset of American place names (derived from &lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt;) the query above returns 20 results beginning with:</source>
          <target state="translated">使用美国地名的数据集（源自&lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt;），上面的查询返回20个结果，开头为：</target>
        </trans-unit>
        <trans-unit id="cced5340290d93733d759f1a49ce8d467995399f" translate="yes" xml:space="preserve">
          <source>Using a single query such as the above, the application obtains a list of the slideIds for all slides in the presentation. The application then queries for the content of the first slide, and parses and displays that content, as before.</source>
          <target state="translated">使用像上面这样的单一查询,应用程序获得演示文稿中所有幻灯片的slideIds列表。然后,应用程序查询第一张幻灯片的内容,并像之前一样,解析和显示该内容。</target>
        </trans-unit>
        <trans-unit id="7dd3bf0fc645009566609bccf3a14f62d35a3f59" translate="yes" xml:space="preserve">
          <source>Using an equals (&quot;=&quot;) operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">在SELECT语句的WHERE子句中使用等价(&quot;=&quot;)操作符,或</target>
        </trans-unit>
        <trans-unit id="23bf7370fe569447da050d73459abb59d1093647" translate="yes" xml:space="preserve">
          <source>Using an ordinary disk file to provide shared memory has the disadvantage that it might actually do unnecessary disk I/O by writing the shared memory to disk. However, the developers do not think this is a major concern since the wal-index rarely exceeds 32 KiB in size and is never synced. Furthermore, the wal-index backing file is deleted when the last database connection disconnects, which often prevents any real disk I/O from ever happening.</source>
          <target state="translated">使用普通的磁盘文件来提供共享内存有一个缺点,那就是它实际上可能会通过将共享内存写入磁盘来进行不必要的磁盘I/O。然而,开发人员认为这不是一个主要的问题,因为wal-index的大小很少超过32 KiB,而且从不同步。此外,当最后一个数据库连接断开时,wal-index备份文件会被删除,这通常会阻止任何真正的磁盘I/O发生。</target>
        </trans-unit>
        <trans-unit id="314bb9e64d758d2b63c2c5acc0e1727dc6e61abf" translate="yes" xml:space="preserve">
          <source>Using an unnamed subquery in a FROM clause would cause a segfault.</source>
          <target state="translated">在FROM子句中使用未命名的子查询会导致segfault。</target>
        </trans-unit>
        <trans-unit id="9766cdfa57f62810ee226e9c3deec347064cc20b" translate="yes" xml:space="preserve">
          <source>Using gcov (or similar) to show that every branch instruction is taken at least once in both directions is good measure of test suite quality. But even better is showing that every branch instruction makes a difference in the output. In other words, we want to show not only that every branch instruction both jumps and falls through but also that every branch is doing useful work and that the test suite is able to detect and verify that work. When a branch is found that does not make a difference in the output, that suggests that the code associated the branch can be removed (reducing the size of the library and perhaps making it run faster) or that the test suite is inadequately testing the feature that the branch implements.</source>
          <target state="translated">使用gcov(或类似的)来显示每个分支指令在两个方向上至少被采取一次,是衡量测试套件质量的好方法。但更好的是显示每条分支指令都会使输出有所区别。换句话说,我们不仅要证明每条分支指令既跳转又落空,还要证明每条分支都在做有用的工作,并且测试套件能够检测和验证这些工作。当发现一个分支没有使输出产生差异时,这表明与该分支相关的代码可以被删除(减少库的大小,也许会使库运行得更快),或者测试套件对该分支实现的功能测试不足。</target>
        </trans-unit>
        <trans-unit id="db5729475276e1f07562cb2df1e724ad2371713c" translate="yes" xml:space="preserve">
          <source>Using one particular subset of the available TH3 test modules (the &quot;cov1&quot; tests) SQLite obtained &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt; and 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC/DC&lt;/a&gt; as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; on Linux x86 and x86_64 hardware. All releases of SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10) have been tested to this standard. The SQLite developers are committed to maintaining 100% branch coverage and MC/DC for all future releases of SQLite.</source>
          <target state="translated">使用可用的TH3测试模块的一个特定子集（&amp;ldquo; cov1&amp;rdquo;测试），SQLite 在Linux x86和x86_64硬件上通过&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;测量得出&lt;a href=&quot;testing#coverage&quot;&gt;100％的分支测试覆盖率&lt;/a&gt;和100％的&lt;a href=&quot;testing#mcdc&quot;&gt;MC / DC&lt;/a&gt;。自&lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;版本3.6.17&lt;/a&gt;（2009-08-10）起，SQLite的所有发行版均已按照此标准进行了测试。SQLite开发人员致力于为所有将来版本的SQLite保持100％的分支覆盖率和MC / DC。</target>
        </trans-unit>
        <trans-unit id="9270ae0408b0c691c7bbd964a691a187fe62e891" translate="yes" xml:space="preserve">
          <source>Using subtypes to identify valid pointers prevented the WebSQL exploit. But it turned out to be an incomplete solution.</source>
          <target state="translated">使用子类型来识别有效的指针,防止了WebSQL的漏洞。但事实证明这是一个不完整的解决方案。</target>
        </trans-unit>
        <trans-unit id="4b795c9ed4e93bd126c1058e30a1d247be674aba" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; and failing to manually keep the content in sync with the FTS4 inverted indices.</source>
          <target state="translated">使用&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4内容选项，&lt;/a&gt;并且无法手动使内容与FTS4倒排索引同步。</target>
        </trans-unit>
        <trans-unit id="c352b493b2f0901876aea8d20656c0d87ef6b6a9" translate="yes" xml:space="preserve">
          <source>Using the N+1 Query pattern in Fossil does not harm the application. But the N+1 Query pattern does have benefits. For one, the section of the code that creates the timeline query can be completely separate from the section that prepares each timeline entry for display. This provides a separation of responsibility that helps keep the code simple and easy to maintain. Secondly, the information needed for display, and the queries needed to extract that information, vary according to what type of objects to be shown. Check-ins need one set of queries. Tickets need another set of queries. Wiki pages need a different query. And so forth. By implementing these queries on-demand and in the part of the code dealing with the various entities, there is further separation of responsibility and simplification of the overall code base.</source>
          <target state="translated">在Fossil中使用N+1查询模式不会对应用造成伤害。但N+1查询模式确实有好处。首先,创建时间线查询的代码部分可以与准备显示每个时间线条目的部分完全分开。这提供了一种责任分离,有助于保持代码的简单和易于维护。其次,显示所需的信息,以及提取这些信息所需的查询,根据要显示的对象的类型而有所不同。签到需要一组查询。票务需要另一组查询。Wiki页面需要不同的查询。以此类推。通过在处理各种实体的代码部分按需实现这些查询,可以进一步分清责任,简化整个代码库。</target>
        </trans-unit>
        <trans-unit id="ed8c795d039e297badfdb934d5dad24eb9711fc6" translate="yes" xml:space="preserve">
          <source>Using the SQLite Online Backup API</source>
          <target state="translated">使用SQLite在线备份API</target>
        </trans-unit>
        <trans-unit id="702c33598d91f7511e11baf351b09ecd585c68e7" translate="yes" xml:space="preserve">
          <source>Using the VFS xAccess() method, SQLite queries the file-system to see if the journal file associated with the database exists. If it does not, then there is no hot-journal file.</source>
          <target state="translated">使用VFS xAccess()方法,SQLite查询文件系统,查看与数据库相关联的日志文件是否存在。如果不存在,则不存在热期刊文件。</target>
        </trans-unit>
        <trans-unit id="15a6ded3b6ea323ecf5d8ed10a9908901c0cf29c" translate="yes" xml:space="preserve">
          <source>Using the memcpy() function on overlapping buffers.</source>
          <target state="translated">在重叠的缓冲区上使用memcpy()函数。</target>
        </trans-unit>
        <trans-unit id="0ff71664481484af5340c1f4f2d1ad694ff3ab5e" translate="yes" xml:space="preserve">
          <source>Using the new Idx2 index on &quot;state&quot;, SQLite has another option for lookup up the price of California oranges: it can look up every row that contains fruit from California and filter out those rows that are not oranges.</source>
          <target state="translated">使用新的Idx2索引 &quot;state&quot;,SQLite有了另一个查询加州橙子价格的选项:它可以查询每一条包含加州水果的记录,并过滤掉那些不是橙子的记录。</target>
        </trans-unit>
        <trans-unit id="fcde00cc70debec35832ff9273a06512f95fa039" translate="yes" xml:space="preserve">
          <source>Using the sqlite3_unlock_notify() API</source>
          <target state="translated">使用sqlite3_unlock_notify()API。</target>
        </trans-unit>
        <trans-unit id="08fc370c39b7ca0e2248cedd981f211b8dabd8d8" translate="yes" xml:space="preserve">
          <source>Using the two routines above, it is simple for applications to insert new records into or extract existing records from an SQLite Archive. Insert a new into an SQLite Archive using code like this:</source>
          <target state="translated">使用以上两个例程,应用程序可以很简单地将新记录插入到SQLite Archive中或从SQLite Archive中提取现有记录。使用这样的代码将新的记录插入到SQLite Archive中。</target>
        </trans-unit>
        <trans-unit id="5881634960ec51d660f927c3ca27237c1640f650" translate="yes" xml:space="preserve">
          <source>Using the virtual table interface, new entries may be added to a zip archive by inserting new rows into the virtual table. Entries may be removed by deleting rows or modified by updating them.</source>
          <target state="translated">使用虚拟表界面,通过在虚拟表中插入新的行,可以将新的条目添加到 zip 档案中。可以通过删除行或更新行来删除条目。</target>
        </trans-unit>
        <trans-unit id="e7f12616ba6b09fc33431b9c20577f960596b4bb" translate="yes" xml:space="preserve">
          <source>Using the xFileSize() method of the file-handle opened on the database file, SQLite checks if the database file is 0 bytes in size. If it is, the journal file is not considered to be a</source>
          <target state="translated">使用在数据库文件上打开的文件柄的xFileSize()方法,SQLite检查数据库文件的大小是否为0字节。如果是,则不认为日志文件是一个新的文件。</target>
        </trans-unit>
        <trans-unit id="18744e7331495a3e5c139b339aa5a7dcf1c94f70" translate="yes" xml:space="preserve">
          <source>Usually (the exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) a PRIMARY KEY in an SQLite table is really the same as a UNIQUE constraint. Due to an historical oversight, the column values of such a PRIMARY KEY are allowed to be NULL. This is a bug, but by the time the problem was discovered there where so many databases in circulation that depended on the bug that the decision was made to support the bugging behavior moving forward.</source>
          <target state="translated">通常（例外是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;表和&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表），SQLite表中的PRIMARY KEY实际上与UNIQUE约束相同。由于历史上的疏忽，此类PRIMARY KEY的列值允许为NULL。这是一个错误，但是到那时发现问题的时候，由于存在大量依赖该错误的数据库，因此决定支持该错误行为。</target>
        </trans-unit>
        <trans-unit id="f79481390537aded0fd54463773aac91edd4e79c" translate="yes" xml:space="preserve">
          <source>Usually only a subset of the pages in the database file are read. In this example we are showing three pages out of eight being read. In a typical application, a database will have thousands of pages and a query will normally only touch a small percentage of those pages.</source>
          <target state="translated">通常,数据库文件中只有一部分页面被读取。在这个例子中,我们显示的是8个页面中的3个被读取。在一个典型的应用中,一个数据库会有成千上万的页面,而查询通常只会触及其中一小部分页面。</target>
        </trans-unit>
        <trans-unit id="27499120d97c0cbd6ba1013d6ea9b6e679141d60" translate="yes" xml:space="preserve">
          <source>Usually the b-trees for tables and indexes are slightly different. A table b-tree contains a 64-bit integer key and arbitrary data. The 64-bit integer key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. Index b-trees contain an arbitrary binary key and no data. So table b-trees and index b-trees are not directly compatible.</source>
          <target state="translated">通常，表和索引的b树略有不同。表b树包含一个64位整数键和任意数据。64位整数键是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;。索引b树包含任意二进制密钥，并且没有数据。因此表b树和索引b树不直接兼容。</target>
        </trans-unit>
        <trans-unit id="63880029448f25d934c11aa39c24fad9c0bb97f6" translate="yes" xml:space="preserve">
          <source>Usually, a new</source>
          <target state="translated">通常情况下,一个新的</target>
        </trans-unit>
        <trans-unit id="251e8707bded33b5cb244d2e22971c5ac18fc6ad" translate="yes" xml:space="preserve">
          <source>Usually, an &lt;a href=&quot;fts3&quot;&gt;FTS3 or FTS4&lt;/a&gt; table is an example of a virtual table with a rowid that works like a PRIMARY KEY. So, for the following FTS4 tables:</source>
          <target state="translated">通常，&lt;a href=&quot;fts3&quot;&gt;FTS3或FTS4&lt;/a&gt;表是虚拟表的示例，其虚拟行的行为类似于PRIMARY KEY。因此，对于以下FTS4表：</target>
        </trans-unit>
        <trans-unit id="016fa908ece58367a08159cc60971094eae348ed" translate="yes" xml:space="preserve">
          <source>Usually, it does not matter if the page-sizes of the source database and the destination database are different before the contents of the destination are overwritten. The page-size of the destination database is simply changed as part of the backup operation. The exception is if the destination database happens to be an in-memory database. In this case, if the page sizes are not the same at the start of the backup operation, then the operation fails with an SQLITE_READONLY error. Unfortunately, this could occur when loading a database image from a file into an in-memory database using function loadOrSaveDb().</source>
          <target state="translated">通常情况下,在覆盖目标数据库的内容之前,源数据库和目标数据库的页面大小是否不同并不重要。目标数据库的页面大小只是作为备份操作的一部分进行更改。如果目标数据库是内存数据库,则例外。在这种情况下,如果在备份操作开始时页面大小不一样,那么操作就会以 SQLITE_READONLY 错误失败。不幸的是,当使用函数 loadOrSaveDb()将数据库映像从文件加载到内存数据库时,可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="6590aa5b903de1376b91e1364c96b7ab1602da04" translate="yes" xml:space="preserve">
          <source>Usually, no data is actually written to the database file until the user commits the active</source>
          <target state="translated">通常情况下,在用户提交活动之前,不会向数据库文件实际写入任何数据。</target>
        </trans-unit>
        <trans-unit id="5bf501f181ccf2cf7d7e6317299b267cead1ee47" translate="yes" xml:space="preserve">
          <source>Usually, output parameter *piPhrase is set to the phrase number, *piCol to the column in which it occurs and *piOff the token offset of the first token of the phrase. Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">通常,输出参数*piPhrase设置为短语编号,*piCol设置为出现短语的列,*piOff设置为短语第一个标记的标记偏移量。如果成功,返回SQLITE_OK,如果发生错误,则返回错误代码(即SQLITE_NOMEM)。</target>
        </trans-unit>
        <trans-unit id="4375ef1d6cde5037d03b8ccb25b702b95cd0734d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">通常，SQLite提供的默认互斥量实现就足够了，但是应用程序可以选择用自定义实现来替代SQLite无法提供合适实现的专用部署或系统。在这种情况下，应用程序将创建并填充此结构的实例，以将其与&lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;选项一起传递给sqlite3_config（）。此外，在使用&lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt;选项向系统查询当前互斥量实现时，可以将此结构的实例用作输出变量。</target>
        </trans-unit>
        <trans-unit id="d9cb5f2ee721a0e054d3593ea56d06ca4f711a8d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">通常，SQLite提供的默认互斥量实现就足够了，但是应用程序可以选择用自定义实现来替代SQLite无法提供合适实现的专用部署或系统。在这种情况下，应用程序将创建并填充此结构的实例，以将其与&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;选项一起传递给sqlite3_config（）。此外，在使用&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt;选项向系统查询当前互斥量实现时，可以将此结构的实例用作输出变量。</target>
        </trans-unit>
        <trans-unit id="f67d8e98eea6d06da4e67ed9ebc795e5c21c27d3" translate="yes" xml:space="preserve">
          <source>Usually, the parent key of a foreign key constraint is the primary key of the parent table. If they are not the primary key, then the parent key columns must be collectively subject to a UNIQUE constraint or have a UNIQUE index. If the parent key columns have a UNIQUE index, then that index must use the collation sequences that are specified in the CREATE TABLE statement for the parent table. For example,</source>
          <target state="translated">通常,外键约束的父键是父表的主键。如果它们不是主键,那么父键列必须共同受制于一个UNIQUE约束,或者有一个UNIQUE索引。如果父键列有一个UNIQUE索引,那么该索引必须使用在父表的CREATE TABLE语句中指定的整理序列。例如</target>
        </trans-unit>
        <trans-unit id="6dab9ce5b9389cc793db1ee13d4fd8a8749eccd9" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">通常情况下，会话模块封装一个函数调用在执行apply_v2（）或apply_v2_strm（）的所有操作&lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;。如果成功应用了变更集或补丁集，则提交SAVEPOINT；如果发生错误，则回滚SAVEPOINT。指定此标志将导致会话模块忽略此保存点。在这种情况下，如果在调用apply_v2（）时调用方具有打开的事务或保存点，则可以回滚部分应用的变更集。</target>
        </trans-unit>
        <trans-unit id="651dad2d1a7cdde77afe8c8f6efa3556819be19f" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">通常情况下，会话模块封装一个函数调用在执行apply_v2（）或apply_v2_strm（）的所有操作&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;。如果成功应用了变更集或补丁集，则提交SAVEPOINT；如果发生错误，则回滚SAVEPOINT。指定此标志将导致会话模块忽略此保存点。在这种情况下，如果在调用apply_v2（）时调用方具有打开的事务或保存点，则可以回滚部分应用的变更集。</target>
        </trans-unit>
        <trans-unit id="a7c5b3a786dedb589ca7dfd4119dc946fad418cc" translate="yes" xml:space="preserve">
          <source>Usually, when a database in wal mode is closed or detached from a database handle, SQLite checks if this will mean that there are now no connections at all to the database. If so, it performs a checkpoint operation before closing the connection. This option may be used to override this behaviour. The first parameter passed to this operation is an integer - positive to disable checkpoints-on-close, or zero (the default) to enable them, and negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether checkpoints-on-close have been disabled - 0 if they are not disabled, 1 if they are.</source>
          <target state="translated">通常,当一个处于wal模式的数据库关闭或脱离数据库句柄时,SQLite会检查这是否会意味着现在与数据库完全没有连接。如果是这样,它会在关闭连接之前执行一个检查点操作。这个选项可以用来覆盖这个行为。传递给该操作的第一个参数是一个整数--正数表示禁用关闭时的检查点,零(默认)表示启用,负数表示保持设置不变。第二个参数是一个指向整数的指针,将0或1写入其中,表示是否禁用了关闭时检查点--0表示没有禁用,1表示禁用。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="998ce99ff7bc11e5fda480fd5bfcbe7172fa1458" translate="yes" xml:space="preserve">
          <source>Utter only truth from heart and mouth.</source>
          <target state="translated">只从心和口中说出真相。</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="338c2017b922c8c778a643c9a2bb9bb0d159e34d" translate="yes" xml:space="preserve">
          <source>VACUUM INTO</source>
          <target state="translated">真空进入</target>
        </trans-unit>
        <trans-unit id="204b6e5828ce2852bf6877318b1361fbae1e4020" translate="yes" xml:space="preserve">
          <source>VACUUM uses a temporary file in the official TEMP folder, not in the same directory as the original database</source>
          <target state="translated">VACUUM使用的是官方TEMP文件夹下的临时文件,而不是与原数据库在同一目录下的文件。</target>
        </trans-unit>
        <trans-unit id="eba0ca62d23c0aa5d1fd44639bb5b08cca16a456" translate="yes" xml:space="preserve">
          <source>VACUUM with an INTO clause</source>
          <target state="translated">带INTO子句的VACUUM</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="3893415f582da8528cfdc804ac3bee7e25a15ab1" translate="yes" xml:space="preserve">
          <source>VALUES clause</source>
          <target state="translated">VALUES条款</target>
        </trans-unit>
        <trans-unit id="2010132ce9d7ecb7ffcd8583e46eb6830b5b89ee" translate="yes" xml:space="preserve">
          <source>VARCHAR(255)</source>
          <target state="translated">VARCHAR(255)</target>
        </trans-unit>
        <trans-unit id="8e2934685262dc368f8941746e5ac5ff58123235" translate="yes" xml:space="preserve">
          <source>VARYING CHARACTER(255)</source>
          <target state="translated">变化的字符(255)</target>
        </trans-unit>
        <trans-unit id="efde179e9b49292e75991e12678580f142a070e1" translate="yes" xml:space="preserve">
          <source>VBegin</source>
          <target state="translated">VBegin</target>
        </trans-unit>
        <trans-unit id="d0eedafb13c92d47b81b7b056def9e323b6e493c" translate="yes" xml:space="preserve">
          <source>VColumn</source>
          <target state="translated">VColumn</target>
        </trans-unit>
        <trans-unit id="f84b9b0948754b7d110e0815c9837bdc1fddebe7" translate="yes" xml:space="preserve">
          <source>VCreate</source>
          <target state="translated">VCreate</target>
        </trans-unit>
        <trans-unit id="91b564dbaa1169fe6e48962a34cffa4f703f0be0" translate="yes" xml:space="preserve">
          <source>VDestroy</source>
          <target state="translated">VDestroy</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="9913e8aa2ef97f43053931ebe92afe906139c950" translate="yes" xml:space="preserve">
          <source>VFS</source>
          <target state="translated">VFS</target>
        </trans-unit>
        <trans-unit id="e0bba973b3126bd49629e5735098909a83c37fb8" translate="yes" xml:space="preserve">
          <source>VFS Adaptor Related Assumptions</source>
          <target state="translated">VFS适配器相关假设</target>
        </trans-unit>
        <trans-unit id="0427fe52d1301f469be76b38e86110229024c26c" translate="yes" xml:space="preserve">
          <source>VFS shim</source>
          <target state="translated">VFS垫片</target>
        </trans-unit>
        <trans-unit id="42c3d050c1ab4fc79ee66e794588a38879f87c59" translate="yes" xml:space="preserve">
          <source>VFilter</source>
          <target state="translated">VFilter</target>
        </trans-unit>
        <trans-unit id="0fa2ff5785952199b4086a34e015d691fb6f638e" translate="yes" xml:space="preserve">
          <source>VIEW</source>
          <target state="translated">VIEW</target>
        </trans-unit>
        <trans-unit id="d1ea68c099681d5006dd208d2e34db6600ee8c5a" translate="yes" xml:space="preserve">
          <source>VIEWs in SQLite are read-only. You may not execute a DELETE, INSERT, or UPDATE statement on a view. But you can create a trigger that fires on an attempt to DELETE, INSERT, or UPDATE a view and do what you need in the body of the trigger.</source>
          <target state="translated">SQLite中的视图是只读的。你不能在视图上执行DELETE、INSERT或UPDATE语句。但你可以创建一个触发器,在尝试DELETE、INSERT或UPDATE视图时触发,并在触发器的主体中执行你需要的操作。</target>
        </trans-unit>
        <trans-unit id="5fe4dd429e7ca82543f447d5b6e37edc0b0211f3" translate="yes" xml:space="preserve">
          <source>VIRTUAL</source>
          <target state="translated">VIRTUAL</target>
        </trans-unit>
        <trans-unit id="b9de5e41c6dc887dbc8f743605405fee0be8e279" translate="yes" xml:space="preserve">
          <source>VNext</source>
          <target state="translated">VNext</target>
        </trans-unit>
        <trans-unit id="348f1db286c8e9b47c43f2f013b0dd88171bf692" translate="yes" xml:space="preserve">
          <source>VOpen</source>
          <target state="translated">VOpen</target>
        </trans-unit>
        <trans-unit id="9741852a241ce6064f8f2d351b08520dd5847d98" translate="yes" xml:space="preserve">
          <source>VRename</source>
          <target state="translated">VRename</target>
        </trans-unit>
        <trans-unit id="4bce4ebd3cc132100d6cc36475c7b1294f94edb7" translate="yes" xml:space="preserve">
          <source>VUpdate</source>
          <target state="translated">VUpdate</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="27b07b92ebcc99b13cdafff029c3e3d22606bada" translate="yes" xml:space="preserve">
          <source>Vacuum the entire database P1. P1 is 0 for &quot;main&quot;, and 2 or more for an attached database. The &quot;temp&quot; database may not be vacuumed.</source>
          <target state="translated">真空整个数据库P1。P1对于 &quot;main &quot;为0,对于附属数据库为2或更多。&quot;temp &quot;数据库可以不吸尘。</target>
        </trans-unit>
        <trans-unit id="0819f8114e772508968d8c091f0521044cadc7f0" translate="yes" xml:space="preserve">
          <source>Valgrind analysis</source>
          <target state="translated">碾压分析</target>
        </trans-unit>
        <trans-unit id="4869177d0c589735a7d4b9114f8982fe5d26f899" translate="yes" xml:space="preserve">
          <source>Value is a BLOB that is (N-12)/2 bytes in length.</source>
          <target state="translated">值是一个长度为(N-12)/2字节的BLOB。</target>
        </trans-unit>
        <trans-unit id="5d5aa2bdd2060b855e479d53c2581cc8223ca5a6" translate="yes" xml:space="preserve">
          <source>Value is a NULL.</source>
          <target state="translated">值是一个NULL。</target>
        </trans-unit>
        <trans-unit id="c499129fd21c535eaa7f12c5970a992328cc9e08" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 16-bit twos-complement integer.</source>
          <target state="translated">值是一个大写的16位双补码整数。</target>
        </trans-unit>
        <trans-unit id="e70cb145efe11c54bff7a396cfac28a6df7474e8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 24-bit twos-complement integer.</source>
          <target state="translated">值是一个大写的24位双补码整数。</target>
        </trans-unit>
        <trans-unit id="5e8e5ccfe7344d0d3d0abc79f36a5fdb932a3b7c" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 32-bit twos-complement integer.</source>
          <target state="translated">值是一个大写的32位双补码整数。</target>
        </trans-unit>
        <trans-unit id="b3f234aeea73b3135246f413e61277eaccb53eb8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 48-bit twos-complement integer.</source>
          <target state="translated">值是一个48位双补码的大迭代整数。</target>
        </trans-unit>
        <trans-unit id="af2248db1aa0f6b54f70fbd4bad24187360977fd" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 64-bit twos-complement integer.</source>
          <target state="translated">值是一个64位的双补码大写字母整数。</target>
        </trans-unit>
        <trans-unit id="ae871c1581e8a49ebac1c7419a009e8fb57a2d5e" translate="yes" xml:space="preserve">
          <source>Value is a big-endian IEEE 754-2008 64-bit floating point number.</source>
          <target state="translated">值是一个大写的IEEE 754-2008 64位浮点数。</target>
        </trans-unit>
        <trans-unit id="02f41d10900d18e2f000b1b5a2e593cf69aeca4b" translate="yes" xml:space="preserve">
          <source>Value is a string in the &lt;a href=&quot;fileformat2#enc&quot;&gt;text encoding&lt;/a&gt; and (N-13)/2 bytes in length. The nul terminator is not stored.</source>
          <target state="translated">值是&lt;a href=&quot;fileformat2#enc&quot;&gt;文本编码&lt;/a&gt;的字符串，长度为（N-13）/ 2个字节。不存储nul终止符。</target>
        </trans-unit>
        <trans-unit id="d4c71d03558220fa7cbe0d35d7582077b87759fd" translate="yes" xml:space="preserve">
          <source>Value is an 8-bit twos-complement integer.</source>
          <target state="translated">值是一个8位双补整数。</target>
        </trans-unit>
        <trans-unit id="21a8bbbdb0477e77f764478e79099dc10eca1b5a" translate="yes" xml:space="preserve">
          <source>Value is the integer 0. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">值是整数0。（仅适用于&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;架构格式&lt;/a&gt; 4和更高版本。）</target>
        </trans-unit>
        <trans-unit id="4b218cb556caba65180a69703c18a8657584030f" translate="yes" xml:space="preserve">
          <source>Value is the integer 1. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">值是整数1。（仅适用于&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;架构格式&lt;/a&gt; 4和更高版本。）</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="b74a3f9a59a12c1f692032bcd73742874ff821bd" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config()</source>
          <target state="translated">sqlite3session_config()的值。</target>
        </trans-unit>
        <trans-unit id="bc12625ab4c97d74dcdc9d561aba55de6f3648e6" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config().</source>
          <target state="translated">sqlite3session_config()的值。</target>
        </trans-unit>
        <trans-unit id="21fb70cd308e717f82d11db0a79a04443511207e" translate="yes" xml:space="preserve">
          <source>Values of N between 100 and 1000 are recommended. Or, to disable the analysis limit, causing ANALYZE to do a complete scan of each index, set the analysis limit to 0. The default value for the analysis limit is 0 for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b975fa21a49b294e75ba8fe14419189c4abab11" translate="yes" xml:space="preserve">
          <source>Values stored in unindexed columns are not eligible to match MATCH operators. They do not influence the results of the offsets() or matchinfo() auxiliary functions. Nor will the snippet() function ever return a snippet based on a value stored in an unindexed column.</source>
          <target state="translated">存储在非索引列中的值没有资格匹配MATCH操作符。它们不会影响offsets()或matchinfo()辅助函数的结果。snippet()函数也不会返回一个基于存储在非索引列中的值的片段。</target>
        </trans-unit>
        <trans-unit id="c15b50c2bdb6ec892f0c03794f814403120328ad" translate="yes" xml:space="preserve">
          <source>Values that may be passed as the second argument to a conflict-handler.</source>
          <target state="translated">可作为第二个参数传递给冲突处理程序的值。</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="51a317c7ddc79a1154219a293b13d3647c7088e1" translate="yes" xml:space="preserve">
          <source>Various bug fixes and documentation updates.</source>
          <target state="translated">各种错误修复和文档更新。</target>
        </trans-unit>
        <trans-unit id="d5f06a4766a5315e31c33eb58743a7e83afa9adb" translate="yes" xml:space="preserve">
          <source>Various bug fixes and optimizations</source>
          <target state="translated">各种错误修复和优化</target>
        </trans-unit>
        <trans-unit id="85d7c8482bd4c4d0eab034cc91f2ea5f21b20d90" translate="yes" xml:space="preserve">
          <source>Various bug fixes in the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; tool.</source>
          <target state="translated">&lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;工具中的各种错误修复。</target>
        </trans-unit>
        <trans-unit id="ecec24b66500dbd17ba7725547d5521b2d6d2040" translate="yes" xml:space="preserve">
          <source>Various code refactorizations for performance</source>
          <target state="translated">为提高性能而进行的各种代码重构</target>
        </trans-unit>
        <trans-unit id="85976ded19739ce2942c54c82204b742186a7556" translate="yes" xml:space="preserve">
          <source>Various compiler compatibility fixes.</source>
          <target state="translated">各种编译器兼容性修复。</target>
        </trans-unit>
        <trans-unit id="ab65a12d6caf25bdc60a4edee517dc1ebef7b909" translate="yes" xml:space="preserve">
          <source>Various improvements in how the query planner uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information to estimate plan costs.</source>
          <target state="translated">查询计划程序如何使用&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;信息来估计计划成本，进行了各种改进。</target>
        </trans-unit>
        <trans-unit id="03823e5b502773a079a3bee8b39ca22cddaecb57" translate="yes" xml:space="preserve">
          <source>Various minor bug and documentation typo fixes and performance enhancements.</source>
          <target state="translated">各种小的bug和文档排版修复以及性能提升。</target>
        </trans-unit>
        <trans-unit id="10b44287786294b34c89472b1d33c638e18576ac" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes</source>
          <target state="translated">各种小错误修复</target>
        </trans-unit>
        <trans-unit id="3f779a48c89979c93ac37abe87c5a7687464bc7d" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and documentation enhancements.</source>
          <target state="translated">各种小的bug修复和文档增强。</target>
        </trans-unit>
        <trans-unit id="4847f53fde0fb417d8d4a76ab68b44562fd9a573" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and performance enhancements.</source>
          <target state="translated">各种小bug修复和性能提升。</target>
        </trans-unit>
        <trans-unit id="95ba96bcd2bbb545050ce738d48cb5ec939831b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes including fixes for tickets &lt;a href=&quot;https://www.sqlite.org/src/info/8f157e8010b22af0&quot;&gt;8f157e8010b22af0&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/9fb26d37cefaba40&quot;&gt;9fb26d37cefaba40&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/e367f31901ea8700&quot;&gt;e367f31901ea8700&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/b706351ce2ecf59a&quot;&gt;b706351ce2ecf59a&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/7c6d876f84e6e7e2&quot;&gt;7c6d876f84e6e7e2&lt;/a&gt;, and &lt;a href=&quot;https://www.sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;c8d3b9f0a750a529&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9299a31e992a8798950b9ee230e2efd3cac0b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes.</source>
          <target state="translated">各种小BUG的修复。</target>
        </trans-unit>
        <trans-unit id="2514c8b40a668dc1475dfd0f9f137b0141e179e2" translate="yes" xml:space="preserve">
          <source>Various performance improvements.</source>
          <target state="translated">各种性能改进。</target>
        </trans-unit>
        <trans-unit id="6342eea4c52b8714f01d87ea8795935f65636135" translate="yes" xml:space="preserve">
          <source>Verify that an Abort can happen. Assert if an Abort at this point might cause database corruption. This opcode only appears in debugging builds.</source>
          <target state="translated">验证是否会发生Abort。断言此时的Abort是否会导致数据库损坏。这个操作码只出现在调试构建中。</target>
        </trans-unit>
        <trans-unit id="0e121d547f14e098984e65cce93a4f32d31bdccc" translate="yes" xml:space="preserve">
          <source>Version 1.0.X of SQLite used the GDBM library as its backend interface to the disk. Beginning in version 2.0.0, GDBM was replaced by a custom B-Tree library written especially for SQLite. The new B-Tree backend is twice as fast as GDBM, supports atomic commits and rollback, and stores an entire database in a single disk file instead using a separate file for each table as GDBM does. The two file formats are not even remotely similar.</source>
          <target state="translated">1.0.X版本的SQLite使用GDBM库作为其与磁盘的后端接口。从2.0.0版本开始,GDBM被一个专门为SQLite编写的自定义B-Tree库所取代。新的B-Tree后端速度是GDBM的两倍,支持原子提交和回滚,并且将整个数据库存储在一个磁盘文件中,而不是像GDBM那样为每个表使用一个单独的文件。这两种文件格式根本没有任何相似之处。</target>
        </trans-unit>
        <trans-unit id="15147c06759c9052778bf2211d35cc6a76e87f68" translate="yes" xml:space="preserve">
          <source>Version 2.2.0 and later of the library will automatically detect when it is reading a 2.1.x database and will disable the new INTEGER PRIMARY KEY feature. In other words, version 2.2.x is backwards compatible to version 2.1.x. But version 2.1.x is not forward compatible with version 2.2.x. If you try to open a 2.2.x database with an older 2.1.x library and that database contains an INTEGER PRIMARY KEY, you will likely get a coredump. If the database schema does not contain any INTEGER PRIMARY KEYs, then the version 2.1.x and version 2.2.x database files will be identical and completely interchangeable.</source>
          <target state="translated">2.2.0及以后版本的库将自动检测到它正在读取2.1.x数据库,并将禁用新的INTEGER PRIMARY KEY功能。换句话说,2.2.x版本向后兼容2.1.x版本,但2.1.x版本与2.2.x版本不向前兼容。如果你试图用旧的2.1.x库打开一个2.2.x数据库,而该数据库包含一个INTEGER PRIMARY KEY,你可能会得到一个coredump。如果数据库模式不包含任何INTEGER PRIMARY KEY,那么2.1.x版本和2.2.x版本的数据库文件将是相同的,完全可以互换。</target>
        </trans-unit>
        <trans-unit id="0117d508d1c578c143be74741c597fcb4aa7a934" translate="yes" xml:space="preserve">
          <source>Version 2.6.0 or later of the library cannot open read-only database files from version 2.5.6 or earlier, since read-only files cannot be upgraded to the new format.</source>
          <target state="translated">2.6.0或更高版本的库不能打开2.5.6或更早版本的只读数据库文件,因为只读文件不能升级到新格式。</target>
        </trans-unit>
        <trans-unit id="b22eaca7a28d27b61c642146bfe60e035fc837b9" translate="yes" xml:space="preserve">
          <source>Version 2.8.0 introduces a change to the format of the rollback journal file. The main database file format is unchanged. Versions 2.7.6 and earlier can read and write 2.8.0 databases and vice versa. Version 2.8.0 can rollback a transaction that was started by version 2.7.6 and earlier. But version 2.7.6 and earlier cannot rollback a transaction started by version 2.8.0 or later.</source>
          <target state="translated">2.8.0版本对回滚日志文件的格式进行了修改。主数据库文件的格式没有变化。2.7.6及以前的版本可以读写2.8.0数据库,反之亦然。2.8.0版本可以回滚一个由2.7.6和更早版本启动的事务。但2.7.6和更早的版本不能回滚2.8.0或更早版本启动的事务。</target>
        </trans-unit>
        <trans-unit id="5ab1c612d2172f97ee17ccb094511130795e0e49" translate="yes" xml:space="preserve">
          <source>Version 3.0.0 is a major upgrade for SQLite that incorporates support for UTF-16, BLOBs, and a more compact encoding that results in database files that are typically 25% to 50% smaller. The new file format is very different and is completely incompatible with the version 2 file format.</source>
          <target state="translated">3.0.0版本是SQLite的重大升级,它加入了对UTF-16、BLOBs的支持,并采用了更紧凑的编码,使数据库文件通常减少25%到50%。新的文件格式与第2版的文件格式非常不同,完全不兼容。</target>
        </trans-unit>
        <trans-unit id="560474f7906b0238187c7f7b7f4ee43ef0381a4c" translate="yes" xml:space="preserve">
          <source>Version 3.10.0 introduced a case-folding bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator which is fixed by this patch release. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt;.</source>
          <target state="translated">版本3.10.0引入了&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符中的案例折叠错误，此补丁版本已修复该错误。机票&lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09330c4007db255bbeea2ef8f69d34761c5d8efc" translate="yes" xml:space="preserve">
          <source>Version 3.5.0 of SQLite changes the behavior of a few APIs in ways that are technically incompatible. However, these APIs are seldom used and even when they are used it is difficult to imagine a scenario where the change might break something. The changes actually makes these interface much more useful and powerful.</source>
          <target state="translated">SQLite 3.5.0版本改变了一些API的行为,在技术上是不兼容的。然而,这些API很少被使用,即使使用它们,也很难想象改变会破坏什么的场景。这些变化实际上让这些接口变得更加有用和强大。</target>
        </trans-unit>
        <trans-unit id="621e552e91497473887ee98c411a17ae0c22faad" translate="yes" xml:space="preserve">
          <source>Version Change</source>
          <target state="translated">版本变更</target>
        </trans-unit>
        <trans-unit id="57c774f0b39c0a5a2da04603c552cf0b2e97f635" translate="yes" xml:space="preserve">
          <source>Version Numbers in SQLite</source>
          <target state="translated">SQLite中的版本号</target>
        </trans-unit>
        <trans-unit id="92c5569b77b82f07b395294f1952d2ab591b5725" translate="yes" xml:space="preserve">
          <source>Version method</source>
          <target state="translated">版本方法</target>
        </trans-unit>
        <trans-unit id="12b0595bc53b8fdea788b66adfb5e6aeb225a99c" translate="yes" xml:space="preserve">
          <source>Versioning of the SQLite source code has transitioned from CVS to &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;.</source>
          <target state="translated">SQLite源代码的版本控制已从CVS过渡到&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b36ebe549ad7e57c9fee50024e4b91ba9111a84" translate="yes" xml:space="preserve">
          <source>Very few CVEs written about SQLite are real vulnerabilities in the sense that they do not give any new capabilities to an attacker. Consider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a826473d10edb3f601f04f14066361f0f7573c3" translate="yes" xml:space="preserve">
          <source>Via the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf()&lt;/a&gt; interfaces, the built-in printf() implementation supports the ability to render an arbitrary-length string into a memory buffer obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. This is safer and less error prone than trying to precompute an upper size limit on the result string, allocate an appropriately sized buffer, and then calling snprintf().</source>
          <target state="translated">通过&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;和&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf（）&lt;/a&gt;接口，内置的printf（）实现支持将任意长度的字符串呈现到从&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存缓冲区中的功能。与尝试对结果字符串的大小上限进行预先计算，分配适当大小的缓冲区然后调用snprintf（）相比，这种方法更安全且更不易出错。</target>
        </trans-unit>
        <trans-unit id="7661d9e884510184f3115feaa61daa7fb90ab554" translate="yes" xml:space="preserve">
          <source>Virtual File System Objects</source>
          <target state="translated">虚拟文件系统对象</target>
        </trans-unit>
        <trans-unit id="0f4f4c40c9b657d040c9a5a3549b3c5d32fbc234" translate="yes" xml:space="preserve">
          <source>Virtual Table Configuration Options</source>
          <target state="translated">虚拟表配置选项</target>
        </trans-unit>
        <trans-unit id="57189223b1eb8b14988a31c1f5a4ff48cc80e85d" translate="yes" xml:space="preserve">
          <source>Virtual Table Constraint Operator Codes</source>
          <target state="translated">虚拟表约束操作码</target>
        </trans-unit>
        <trans-unit id="d3cabefe217e8ae9513576669d0630c721003893" translate="yes" xml:space="preserve">
          <source>Virtual Table Cursor Object</source>
          <target state="translated">虚拟表光标对象</target>
        </trans-unit>
        <trans-unit id="02d05d9b66c15b554ca60cadbe6ddd8d5a77642f" translate="yes" xml:space="preserve">
          <source>Virtual Table Indexing Information</source>
          <target state="translated">虚拟表索引信息</target>
        </trans-unit>
        <trans-unit id="80548cb099ad243dfef606537d8cb425cbe7b21c" translate="yes" xml:space="preserve">
          <source>Virtual Table Instance Object</source>
          <target state="translated">虚拟表实例对象</target>
        </trans-unit>
        <trans-unit id="681b6ef1224b6badb83f1618372bb0a3a5b7009a" translate="yes" xml:space="preserve">
          <source>Virtual Table Interface Configuration</source>
          <target state="translated">虚拟表接口配置</target>
        </trans-unit>
        <trans-unit id="b4e32b4e8d0ccc9df7f37bef23928bcdb8c21a47" translate="yes" xml:space="preserve">
          <source>Virtual Table Mechanism</source>
          <target state="translated">虚拟表机制</target>
        </trans-unit>
        <trans-unit id="c7613e2461269638f02a689a01bdfb20ef96932a" translate="yes" xml:space="preserve">
          <source>Virtual Table Object</source>
          <target state="translated">虚拟表对象</target>
        </trans-unit>
        <trans-unit id="6fb2f6d632c98f78eae8aef07afc99de73e44e98" translate="yes" xml:space="preserve">
          <source>Virtual Table Scan Flags</source>
          <target state="translated">虚拟表扫描标志</target>
        </trans-unit>
        <trans-unit id="c6305adeaa93ffb40a0b3ae2ce131299d686cab8" translate="yes" xml:space="preserve">
          <source>Virtual machine stores 64-bit integer and floating point constants in binary instead of text for a performance boost.</source>
          <target state="translated">虚拟机以二进制而非文本方式存储64位整数和浮点常量,以提升性能。</target>
        </trans-unit>
        <trans-unit id="a4369e3d1e48bcfd676b740e0d14b603ed7287ae" translate="yes" xml:space="preserve">
          <source>Virtual table implementations are allowed to set the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.idxFlags field to some combination of these bits.</source>
          <target state="translated">允许虚拟表实现将&lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .idxFlags字段设置为这些位的某种组合。</target>
        </trans-unit>
        <trans-unit id="7e7d9ed7bcb125e908a8e59f746fb86a62ee768a" translate="yes" xml:space="preserve">
          <source>Virtual table implementations are allowed to set the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.idxFlags field to some combination of these bits.</source>
          <target state="translated">允许虚拟表实现将&lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .idxFlags字段设置为这些位的某种组合。</target>
        </trans-unit>
        <trans-unit id="1e1224e431f5f3956505068b6d1ec8eea58f8cfc" translate="yes" xml:space="preserve">
          <source>Virtual table implementations that are required to handle OR REPLACE must do so within the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method. If a call to the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; function indicates that the current ON CONFLICT policy is REPLACE, the virtual table implementation should silently replace the appropriate rows within the xUpdate callback and return SQLITE_OK. Or, if this is not possible, it may return SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT constraint handling.</source>
          <target state="translated">处理OR REPLACE所需的虚拟表实现必须在&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法中进行。如果对&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;函数的调用指示当前的ON CONFLICT策略为REPLACE，则虚拟表实现应静默替换xUpdate回调中的相应行并返回SQLITE_OK。或者，如果这不可能，则它可能返回SQLITE_CONSTRAINT，在这种情况下，SQLite将退回到OR ABORT约束处理。</target>
        </trans-unit>
        <trans-unit id="6fd2d8e7bee948b9df988a6ac379b263c059c2c5" translate="yes" xml:space="preserve">
          <source>Virtual table implementations that are required to handle OR REPLACE must do so within the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method. If a call to the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; function indicates that the current ON CONFLICT policy is REPLACE, the virtual table implementation should silently replace the appropriate rows within the xUpdate callback and return SQLITE_OK. Or, if this is not possible, it may return SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT constraint handling.</source>
          <target state="translated">处理OR REPLACE所需的虚拟表实现必须在&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法中进行。如果对&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;函数的调用指示当前的ON CONFLICT策略为REPLACE，则虚拟表实现应静默替换xUpdate回调中的相应行并返回SQLITE_OK。或者，如果这不可能，则它可能返回SQLITE_CONSTRAINT，在这种情况下，SQLite将退回到OR ABORT约束处理。</target>
        </trans-unit>
        <trans-unit id="81aaad6c6dfb9299173befc645c959005f239f65" translate="yes" xml:space="preserve">
          <source>Virtual table implementations will normally subclass this structure to add additional private and implementation-specific fields. The nRef field is used internally by the SQLite core and should not be altered by the virtual table implementation. The virtual table implementation may pass error message text to the core by putting an error message string in zErrMsg. Space to hold this error message string must be obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. Prior to assigning a new value to zErrMsg, the virtual table implementation must free any preexisting content of zErrMsg using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;. Failure to do this will result in a memory leak. The SQLite core will free and zero the content of zErrMsg when it delivers the error message text to the client application or when it destroys the virtual table. The virtual table implementation only needs to worry about freeing the zErrMsg content when it overwrites the content with a new, different error message.</source>
          <target state="translated">虚拟表实现通常将对该结构进行子类化，以添加其他私有字段和特定于实现的字段。 nRef字段由SQLite内核在内部使用，不应由虚拟表实现更改。通过将错误消息字符串放入zErrMsg，虚拟表实现可以将错误消息文本传递给核心。必须从SQLite内存分配函数（例如&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;或&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（））&lt;/a&gt;获取用于保存此错误消息字符串的空间。在为zErrMsg分配新值之前，虚拟表实现必须使用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放zErrMsg的任何先前存在的内容。。否则会导致内存泄漏。当SQLite内核将错误消息文本发送到客户端应用程序或销毁虚拟表时，它将释放zErrMsg的内容并将其内容清零。当虚拟表实现用新的不同错误消息覆盖内容时，只需要担心释放zErrMsg内容。</target>
        </trans-unit>
        <trans-unit id="40dd4a6572104b0d97f5845a7aa00abca493ea5c" translate="yes" xml:space="preserve">
          <source>Virtual tables</source>
          <target state="translated">虚拟表格</target>
        </trans-unit>
        <trans-unit id="9c69270878a43f4468e25b3717d6b2598ec3353a" translate="yes" xml:space="preserve">
          <source>Virtual tables are ignored by default by sqldiff. However, it is possible to explicitly create an RBU data_% table for a virtual table that features a rowid that functions like a primary key using a command such as:</source>
          <target state="translated">虚拟表默认被sqldiff忽略。然而,我们可以使用诸如以下命令为一个虚拟表显式地创建一个RBU data_%表,这个表的特征是它的rowid就像一个主键一样。</target>
        </trans-unit>
        <trans-unit id="4cb343842b9377b7930027e69fe1b4b95ab0bc54" translate="yes" xml:space="preserve">
          <source>Virtual tables can provide alternative implementations of functions using the &lt;a href=&quot;../vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; method of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. But global versions of those functions must exist in order to be overloaded.</source>
          <target state="translated">虚拟表可以使用&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;../vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt;方法提供功能的替代实现。但是必须存在这些函数的全局版本才能被重载。</target>
        </trans-unit>
        <trans-unit id="ea35a0ae0128b32ea2712f75cfcca274a0e301d3" translate="yes" xml:space="preserve">
          <source>Virtual tables can provide alternative implementations of functions using the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; method of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. But global versions of those functions must exist in order to be overloaded.</source>
          <target state="translated">虚拟表可以使用&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt;方法提供功能的替代实现。但是必须存在这些函数的全局版本才能被重载。</target>
        </trans-unit>
        <trans-unit id="17882224a33603a1de5faab8a2a01eaa906c2eb6" translate="yes" xml:space="preserve">
          <source>Virtual tables for which the &quot;rowid&quot; column does not function like a primary key value cannot be updated using RBU.</source>
          <target state="translated">对于那些 &quot;rowid &quot;列的功能不像主键值的虚拟表,不能使用RBU更新。</target>
        </trans-unit>
        <trans-unit id="d97bfa2f28319cd6ae1be60d2bddfa72a278a536" translate="yes" xml:space="preserve">
          <source>Virtual tables methods can set an error message by assigning a string obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; to zErrMsg. The method should take care that any prior string is freed by a call to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.</source>
          <target state="translated">通过将从&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;获得的字符串分配给zErrMsg，虚拟表方法可以设置错误消息。该方法应注意在将新字符串分配给zErrMsg之前，通过调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放任何先前的字符串。在错误消息传递到客户端应用程序之后，该字符串将由sqlite3_free（）自动释放，并且zErrMsg字段将被清零。</target>
        </trans-unit>
        <trans-unit id="f460e6a98df6a13dcf481c34d0a877733d497773" translate="yes" xml:space="preserve">
          <source>Virtual tables methods can set an error message by assigning a string obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; to zErrMsg. The method should take care that any prior string is freed by a call to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.</source>
          <target state="translated">通过将从&lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;获得的字符串分配给zErrMsg，虚拟表方法可以设置错误消息。该方法应注意在将新字符串分配给zErrMsg之前，通过调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放任何先前的字符串。在错误消息传递到客户端应用程序之后，该字符串将由sqlite3_free（）自动释放，并且zErrMsg字段将被清零。</target>
        </trans-unit>
        <trans-unit id="8dd3e411a2cd1cd0400ed8b91a5e2884ea85bf05" translate="yes" xml:space="preserve">
          <source>Virtual terms are used for analysis only and do not cause any byte-code to be generated. If both virtual terms end up being used as constraints on an index, then the original BETWEEN term is omitted and the corresponding test is not performed on input rows. Thus if the BETWEEN term ends up being used as an index constraint no tests are ever performed on that term. On the other hand, the virtual terms themselves never causes tests to be performed on input rows. Thus if the BETWEEN term is not used as an index constraint and instead must be used to test input rows, the</source>
          <target state="translated">虚拟项仅用于分析,不会导致任何字节码的生成。如果两个虚拟项最终都被用作索引的约束,那么原始的BETWEEN项就会被省略,相应的测试也不会在输入行上执行。因此,如果BETWEEN项最终被用作索引约束,则永远不会对该项进行测试。另一方面,虚拟项本身永远不会导致在输入行上执行测试。因此,如果BETWEEN项没有被用作索引约束,而是必须被用来测试输入行,那么这个</target>
        </trans-unit>
        <trans-unit id="69180499c91410d16271921874ed2a25a5b8ba2f" translate="yes" xml:space="preserve">
          <source>Visit the sick.</source>
          <target state="translated">探望病人。</target>
        </trans-unit>
        <trans-unit id="c18668323ee175259b4d33e74c3e8421bb9608b5" translate="yes" xml:space="preserve">
          <source>Vulnerabilities</source>
          <target state="translated">Vulnerabilities</target>
        </trans-unit>
        <trans-unit id="63fbb3bb789b808aff0169713cbc7f0fe8b26b33" translate="yes" xml:space="preserve">
          <source>WAL Frame Header Format</source>
          <target state="translated">WAL帧头格式</target>
        </trans-unit>
        <trans-unit id="744e2e67c24aa24ef2724e0cca0702b0e396b77b" translate="yes" xml:space="preserve">
          <source>WAL Header Format</source>
          <target state="translated">WAL标头格式</target>
        </trans-unit>
        <trans-unit id="06c6d5627eae51ea8b07e45901c927d0fff1639e" translate="yes" xml:space="preserve">
          <source>WAL backwards compatibility</source>
          <target state="translated">WAL向后兼容性</target>
        </trans-unit>
        <trans-unit id="7f3d7dac78ce17ee863e11b29dd77ba4c3b844b1" translate="yes" xml:space="preserve">
          <source>WAL checksum algorithm</source>
          <target state="translated">WAL校验和算法</target>
        </trans-unit>
        <trans-unit id="43394fc5704020bd91d68a3ea6cb25e34c7a31ef" translate="yes" xml:space="preserve">
          <source>WAL concurrency</source>
          <target state="translated">WAL并发量</target>
        </trans-unit>
        <trans-unit id="52a8587a456d98f221f4f9bce63c226fcda62f9a" translate="yes" xml:space="preserve">
          <source>WAL file</source>
          <target state="translated">WAL文件</target>
        </trans-unit>
        <trans-unit id="50ce9ea412cfc1994dee0ce8829cf26ea47867fa" translate="yes" xml:space="preserve">
          <source>WAL format</source>
          <target state="translated">WAL格式</target>
        </trans-unit>
        <trans-unit id="2c59f37be8a8a85d4967e8d84ff245b823d2c3d3" translate="yes" xml:space="preserve">
          <source>WAL is significantly faster in most scenarios.</source>
          <target state="translated">在大多数情况下,WAL的速度明显更快。</target>
        </trans-unit>
        <trans-unit id="df48eb81aeb4b91265bedea157514a68984a16d8" translate="yes" xml:space="preserve">
          <source>WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional rollback-journal approach in applications that do mostly reads and seldom write.</source>
          <target state="translated">在主要做读而很少做写的应用中,WAL可能会比传统的回滚日记方式慢非常一点点(可能慢1%或2%)。</target>
        </trans-unit>
        <trans-unit id="4a97139b7e130c0c8a433bdf669136c84f9136b7" translate="yes" xml:space="preserve">
          <source>WAL mode permits simultaneous readers and writers. It can do this because changes do not overwrite the original database file, but rather go into the separate write-ahead log file. That means that readers can continue to read the old, original, unaltered content from the original database file at the same time that the writer is appending to the write-ahead log. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, SQLite exhibits &quot;snapshot isolation&quot;. When a read transaction starts, that reader continues to see an unchanging &quot;snapshot&quot; of the database file as it existed at the moment in time when the read transaction started. Any write transactions that commit while the read transaction is active are still invisible to the read transaction, because the reader is seeing a snapshot of database file from a prior moment in time.</source>
          <target state="translated">WAL模式允许同时读写器。之所以可以这样做，是因为更改不会覆盖原始数据库文件，而是进入单独的预写日志文件。这意味着读者可以在编写者附加到预写日志的同时，继续从原始数据库文件中读取旧的，原始的，未更改的内容。在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;，SQLite表现为&amp;ldquo;快照隔离&amp;rdquo;。当读取事务开始时，该读取器继续看到数据库文件的不变快照，因为该文件在读取事务开始时存在。在读取事务处于活动状态时提交的所有写入事务对于读取事务仍然是不可见的，因为读取器正在查看前一时刻的数据库文件快照。</target>
        </trans-unit>
        <trans-unit id="cd8ce3e93d7ff89ed9c8371ea6e45fd8f37cf883" translate="yes" xml:space="preserve">
          <source>WAL mode with synchronous NORMAL,</source>
          <target state="translated">WAL模式与同步NORMAL。</target>
        </trans-unit>
        <trans-unit id="02d4a388313bcdd7b2c200b7ae8c4e65a2674e7c" translate="yes" xml:space="preserve">
          <source>WAL normally requires that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; support shared-memory primitives. (Exception: &lt;a href=&quot;wal#noshm&quot;&gt;WAL without shared memory&lt;/a&gt;) The built-in unix and windows VFSes support this but third-party extension VFSes for custom operating systems might not.</source>
          <target state="translated">WAL通常要求&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;支持共享内存原语。 （例外：&lt;a href=&quot;wal#noshm&quot;&gt;没有共享内存的WAL&lt;/a&gt;）内置的UNIX和Windows VFS支持此功能，但自定义操作系统的第三方扩展VFS可能不支持。</target>
        </trans-unit>
        <trans-unit id="773f18c2587f00153abb58a02a9105f99addd056" translate="yes" xml:space="preserve">
          <source>WAL provides more concurrency as readers do not block writers and a writer does not block readers. Reading and writing can proceed concurrently.</source>
          <target state="translated">WAL提供了更多的并发性,因为读者不会阻挡作家,作家也不会阻挡读者。阅读和写作可以同时进行。</target>
        </trans-unit>
        <trans-unit id="c92f6b05049160f00dd8c3ee0f71a3f765656c3a" translate="yes" xml:space="preserve">
          <source>WAL read algorithm</source>
          <target state="translated">WAL读算法</target>
        </trans-unit>
        <trans-unit id="ea6e19418d259cb4081e953d6c25797fc3b82935" translate="yes" xml:space="preserve">
          <source>WAL reset</source>
          <target state="translated">重置WAL</target>
        </trans-unit>
        <trans-unit id="ba93da00cc71fcc3b4f076052eaeb32eb6b9800c" translate="yes" xml:space="preserve">
          <source>WAL uses many fewer fsync() operations and is thus less vulnerable to problems on systems where the fsync() system call is broken.</source>
          <target state="translated">WAL使用较少的fsync()操作,因此在系统调用fsync()中断的情况下,不容易出现问题。</target>
        </trans-unit>
        <trans-unit id="935e3aae9a4d9f6fb670dd29df8a280f6a07053c" translate="yes" xml:space="preserve">
          <source>WAL without shared memory</source>
          <target state="translated">无共享内存的WAL</target>
        </trans-unit>
        <trans-unit id="c5c7bca44dc98aebaf5146b41dc5aa511b8a8aa6" translate="yes" xml:space="preserve">
          <source>WAL-Index Header Details</source>
          <target state="translated">WAL-Index标题详情</target>
        </trans-unit>
        <trans-unit id="e370010e43949311e2b789c1fcb72213cd69886b" translate="yes" xml:space="preserve">
          <source>WAL-Index Header Divisions</source>
          <target state="translated">WAL-Index标题分部</target>
        </trans-unit>
        <trans-unit id="738cab6ddeb95b98c824e2fa6c01b30e9dcb5952" translate="yes" xml:space="preserve">
          <source>WAL-Index Locks Controlled By xShmLock()</source>
          <target state="translated">由xShmLock()控制的WAL-Index锁。</target>
        </trans-unit>
        <trans-unit id="f9538dc159e3d4ee9069c606e83b7a548fc2f640" translate="yes" xml:space="preserve">
          <source>WAL-index format</source>
          <target state="translated">WAL-指数格式</target>
        </trans-unit>
        <trans-unit id="bfa5d0e78b2dc4651911fcb18213d8d8bcf10c94" translate="yes" xml:space="preserve">
          <source>WAL-mode File Format</source>
          <target state="translated">WAL模式文件格式</target>
        </trans-unit>
        <trans-unit id="de71e324c9bcbf886760fa79f3cdf3359f06f756" translate="yes" xml:space="preserve">
          <source>WAL-mode crash recovery</source>
          <target state="translated">WAL模式的崩溃恢复</target>
        </trans-unit>
        <trans-unit id="f45f2752fdcaf800e0a1910433e500b6102d9c5c" translate="yes" xml:space="preserve">
          <source>WAL-mode locks</source>
          <target state="translated">WAL模式锁定</target>
        </trans-unit>
        <trans-unit id="0e94e9cb4190e9d9687693e4eaf1537e92418a3d" translate="yes" xml:space="preserve">
          <source>WAL-mode read blocking</source>
          <target state="translated">WAL模式的读挡</target>
        </trans-unit>
        <trans-unit id="b20f2962509be83b4058f80a47d244e5b11196b8" translate="yes" xml:space="preserve">
          <source>WAL_CKPT_LOCK</source>
          <target state="translated">WAL_CKPT_LOCK</target>
        </trans-unit>
        <trans-unit id="7d8dca53c800f5b912f5029eb6c49020dba95f10" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(0)</source>
          <target state="translated">WAL_READ_LOCK(0)</target>
        </trans-unit>
        <trans-unit id="182225568ec6a131ef84113496e8619eaa0d74bc" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(1)</source>
          <target state="translated">WAL_READ_LOCK(1)</target>
        </trans-unit>
        <trans-unit id="e7da30047a308b88f352a994772f05755945376a" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(2)</source>
          <target state="translated">WAL_READ_LOCK(2)</target>
        </trans-unit>
        <trans-unit id="af1d79e6c2231524894cbc98a7822ed397be08ea" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(3)</source>
          <target state="translated">WAL_READ_LOCK(3)</target>
        </trans-unit>
        <trans-unit id="33fe625c4da68b4d223dd3cf41bf33912b01d2d2" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(4)</source>
          <target state="translated">WAL_READ_LOCK(4)</target>
        </trans-unit>
        <trans-unit id="5e15c21a39d31cebadee8ce801a0923d71efe684" translate="yes" xml:space="preserve">
          <source>WAL_RECOVER_LOCK</source>
          <target state="translated">WAL_RECOVER_LOCK</target>
        </trans-unit>
        <trans-unit id="97bb53df8b738f49899ec6f8612f4070a67257d9" translate="yes" xml:space="preserve">
          <source>WAL_WRITE_LOCK</source>
          <target state="translated">WAL_WRITE_LOCK</target>
        </trans-unit>
        <trans-unit id="962a5cebdb56ec36c6dbf4d84e53c7c677fcc3ab" translate="yes" xml:space="preserve">
          <source>WARNING/TODO: This function currently assumes that the input is a valid changeset. If it is not, the results are undefined.</source>
          <target state="translated">WARNING/TODO:这个函数目前假定输入是一个有效的变化集。如果不是,则结果未定义。</target>
        </trans-unit>
        <trans-unit id="66428bb1d785a8e164fb6679f1dcee0c10acabb5" translate="yes" xml:space="preserve">
          <source>WARNING: If this macro is defined, it will not be possible to open a database for which the schema contains VIEW objects.</source>
          <target state="translated">警告:如果定义了这个宏,将无法打开一个模式包含VIEW对象的数据库。</target>
        </trans-unit>
        <trans-unit id="e3eafa40a094c805daed78cdb48c723e5b81b9a1" translate="yes" xml:space="preserve">
          <source>WHEN</source>
          <target state="translated">WHEN</target>
        </trans-unit>
        <trans-unit id="1c255b91e71a2fddc2e75f8455387053d412a4c1" translate="yes" xml:space="preserve">
          <source>WHERE</source>
          <target state="translated">WHERE</target>
        </trans-unit>
        <trans-unit id="cfda4d41a395db406982a11851ae2e1bfcf9956d" translate="yes" xml:space="preserve">
          <source>WHERE clause</source>
          <target state="translated">凡条款</target>
        </trans-unit>
        <trans-unit id="f21acb9f8ec93625bf5c0906f54fc785624f93c0" translate="yes" xml:space="preserve">
          <source>WHERE clause constraints that are connected by OR instead of AND can be handled in two different ways. If a term consists of multiple subterms containing a common column name and separated by OR, like this:</source>
          <target state="translated">用OR而不是AND连接的WHERE子句约束可以用两种不同的方式处理。如果一个子项由多个子项组成,其中包含一个共同的列名,并用OR隔开,像这样。</target>
        </trans-unit>
        <trans-unit id="1e47856edce4197b9e0ea412ab9daf0c805ed99c" translate="yes" xml:space="preserve">
          <source>WHERE clause expressions using BETWEEN and OR are now candidates for optimization</source>
          <target state="translated">使用BETWEEN和OR的WHERE子句表达式现在是优化的候选对象。</target>
        </trans-unit>
        <trans-unit id="201f5bdde79034efdfb90c4b9a48c56dd51af9e1" translate="yes" xml:space="preserve">
          <source>WINDOW</source>
          <target state="translated">WINDOW</target>
        </trans-unit>
        <trans-unit id="7913945997a369e8ea6004dfc36b2844dceea418" translate="yes" xml:space="preserve">
          <source>WITH</source>
          <target state="translated">WITH</target>
        </trans-unit>
        <trans-unit id="9ced6ee9ff3324806557c62b472be54adbd37321" translate="yes" xml:space="preserve">
          <source>WITH clause</source>
          <target state="translated">与条款</target>
        </trans-unit>
        <trans-unit id="56fbadc8d9764a70500cf87f645a8260e6c6c396" translate="yes" xml:space="preserve">
          <source>WITHOUT</source>
          <target state="translated">WITHOUT</target>
        </trans-unit>
        <trans-unit id="80ce6a3273f099b101fd71e15344b4ac7f67fb42" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID is found only in SQLite and is not compatible with any other SQL database engine, as far as we know. In an elegant system, all tables would behave as WITHOUT ROWID tables even without the WITHOUT ROWID keyword. However, when SQLite was first designed, it used only integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowids&lt;/a&gt; for row keys to simplify the implementation. This approach worked well for many years. But as the demands on SQLite grew, the need for tables in which the PRIMARY KEY really did correspond to the underlying row key grew more acute. The WITHOUT ROWID concept was added in order to meet that need without breaking backwards compatibility with the billions of SQLite databases already in use at the time (circa 2013).</source>
          <target state="translated">据我们所知，WITHOUT ROWID仅在SQLite中找到，并且与任何其他SQL数据库引擎不兼容。在一个优雅的系统中，即使没有WITHOUT ROWID关键字，所有表也将表现为WITHOUT ROWID表。但是，当SQLite最初被设计时，它仅对行键使用整数&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;来简化实现。这种方法多年来一直有效。但是随着对SQLite的需求的增长，对真正符合主键与基础行键对应的表的需求变得越来越迫切。添加了WITHOUT ROWID概念来满足该需求，而又不破坏与当时已使用的数十亿个SQLite数据库的向后兼容性（大约2013年）。</target>
        </trans-unit>
        <trans-unit id="468208bc9196912bc7723c91a3fae9cc04615357" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID tables will work correctly (that is to say, they provide the correct answer) for tables with a single INTEGER PRIMARY KEY. However, ordinary rowid tables will run faster in that case. Hence, it is good design to avoid creating WITHOUT ROWID tables with single-column PRIMARY KEYs of type INTEGER.</source>
          <target state="translated">WITHOUT ROWID表对于只有一个INTEGER PRIMARY KEY的表来说,可以正确工作(也就是说,它们提供了正确的答案)。然而,普通的rowid表在这种情况下会运行得更快。因此,避免创建具有INTEGER类型的单列PRIMARY KEY的WITHOUT ROWID表是一个好的设计。</target>
        </trans-unit>
        <trans-unit id="a47008723e245eb9b8569a96c7a79d51a50cb56f" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID tables work best when individual rows are not too large. A good rule-of-thumb is that the average size of a single row in a WITHOUT ROWID table should be less than about 1/20th the size of a database page. That means that rows should not contain more than about 50 bytes each for a 1KiB page size or about 200 bytes each for 4KiB page size. WITHOUT ROWID tables will work (in the sense that they get the correct answer) for arbitrarily large rows - up to 2GB in size - but traditional rowid tables tend to work faster for large row sizes. This is because rowid tables are implemented as &lt;a href=&quot;fileformat2#btree&quot;&gt;B*-Trees&lt;/a&gt; where all content is stored in the leaves of the tree, whereas WITHOUT ROWID tables are implemented using ordinary B-Trees with content stored on both leaves and intermediate nodes. Storing content in intermediate nodes mean that each intermediate node entry takes up more space on the page and thus reduces the fan-out, increasing the search cost.</source>
          <target state="translated">当单个行不太大时，WITHOUT ROWID表最有效。一个好的经验法则是，WITHOUT ROWID表中单行的平均大小应小于数据库页面大小的约1/20。这意味着，对于1KiB页面大小，行中每个行所包含的字节数不应超过50个字节，对于4KiB页面大小，行中所包含的行数不应超过200个字节。 WITHROW ROWID表对于任意大的行（大小最大为2GB）将起作用（从某种意义上说，它们得到了正确的答案），但是传统的rowid表对于大的行大小倾向于更快地工作。这是因为rowid表被实现为&lt;a href=&quot;fileformat2#btree&quot;&gt;B *-树&lt;/a&gt;其中所有内容都存储在树的叶子中，而WITHROW ROWID表是使用普通B树实现的，其内容存储在叶子和中间节点上。在中间节点中存储内容意味着每个中间节点条目都在页面上占用更多空间，从而减少了扇出，增加了搜索成本。</target>
        </trans-unit>
        <trans-unit id="88d3b9ec414c3ffacd30f5fa1e3b51d5e7c1696c" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID virtual table</source>
          <target state="translated">WITHOUT ROWID 虚拟表</target>
        </trans-unit>
        <trans-unit id="bff1c33df73d6a6c2b628488a2bcad9b0fe90c82" translate="yes" xml:space="preserve">
          <source>Wait for the rolled back changes to be written onto persistent storage. This protects the integrity of the database in case another power failure or crash occurs.</source>
          <target state="translated">等待回滚的更改写入持久性存储中。这样可以在再次断电或崩溃时保护数据库的完整性。</target>
        </trans-unit>
        <trans-unit id="dd9635431d3610b419ecc620dedbc828ed50792c" translate="yes" xml:space="preserve">
          <source>Was generated by this script:</source>
          <target state="translated">是由这个剧本产生的。</target>
        </trans-unit>
        <trans-unit id="637f65e1bae93912cb8bee734b406fd7ee161d5f" translate="yes" xml:space="preserve">
          <source>We also run SQLite using &lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt; on Linux and verify that it detects no problems.</source>
          <target state="translated">我们还在Linux上使用&lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt;运行SQLite ，并验证它没有发现问题。</target>
        </trans-unit>
        <trans-unit id="2bac0ed4b37946dad20096d0b073432309bee989" translate="yes" xml:space="preserve">
          <source>We are aware of no other</source>
          <target state="translated">据我们所知,没有其他</target>
        </trans-unit>
        <trans-unit id="c52eb400cd855fce10ed2a5a6e3b50ba60a61275" translate="yes" xml:space="preserve">
          <source>We are told that in some flash memory controllers the wear-leveling logic can cause random filesystem damage if power is interrupted during a write. This can manifest, for example, as random changes in the middle of a file that was not even open at the time of the power loss. So, for example, a device would be writing content into an MP3 file in flash memory when a power loss occurs, and that could result in an SQLite database being corrupted even though the database was not even in use at the time of the power loss.</source>
          <target state="translated">据悉,在一些闪存控制器中,如果在写入过程中断电,损耗均衡逻辑会造成随机文件系统损坏。例如,这可能表现为在断电时根本没有打开的文件中间发生随机变化。因此,举例来说,当断电时,设备会将内容写入闪存中的MP3文件中,这可能会导致SQLite数据库被破坏,即使在断电时数据库甚至没有被使用。</target>
        </trans-unit>
        <trans-unit id="3cba495c2a4fa9e3aad438fbdcf0294c4dcb9df3" translate="yes" xml:space="preserve">
          <source>We assume that disk is written in chunks which we call a &quot;sector&quot;. It is not possible to modify any part of the disk smaller than a sector. To change a part of the disk smaller than a sector, you have to read in the full sector that contains the part you want to change, make the change, then write back out the complete sector.</source>
          <target state="translated">我们假设磁盘是以块为单位写入的,我们称之为 &quot;扇区&quot;。不可能修改磁盘中小于扇区的任何部分。要修改磁盘中小于扇区的部分,必须读入包含要修改的部分的完整扇区,进行修改,然后写回完整的扇区。</target>
        </trans-unit>
        <trans-unit id="6dd2d15ae4f93de39a47cf41448e74b994733012" translate="yes" xml:space="preserve">
          <source>We begin with a problem that can be solved using a VDBE program that is only a few instructions long. Suppose we have an SQL table that was created like this:</source>
          <target state="translated">我们先用一个只有几条指令的VDBE程序来解决这个问题。假设我们有一张SQL表,是这样创建的。</target>
        </trans-unit>
        <trans-unit id="db9e6f9dd85fc9f8e31996438093b69f82ad2ed0" translate="yes" xml:space="preserve">
          <source>We begin with an overview of the steps SQLite takes in order to perform an atomic commit of a transaction against a single database file. The details of file formats used to guard against damage from power failures and techniques for performing an atomic commit across multiple databases are discussed in later sections.</source>
          <target state="translated">我们首先概述了SQLite对单个数据库文件执行事务原子提交的步骤。后面的章节将讨论用于防止断电损坏的文件格式的细节,以及在多个数据库中执行原子提交的技术。</target>
        </trans-unit>
        <trans-unit id="38bf89df215372375d066b70f4b36998e95fafff" translate="yes" xml:space="preserve">
          <source>We believe that most modern disk drives implement atomic sector writes. When power is lost, the drive uses energy stored in capacitors and/or the angular momentum of the disk platter to provide power to complete any operation in progress. Nevertheless, there are so many layers in between the write system call and the on-board disk drive electronics that we take the safe approach in both Unix and w32 VFS implementations and assume that sector writes are not atomic. On the other hand, device manufacturers with more control over their filesystems might want to consider enabling the atomic write property of xDeviceCharacteristics if their hardware really does do atomic writes.</source>
          <target state="translated">我们认为,大多数现代磁盘驱动器都实现了原子扇区写入。当电源丢失时,驱动器使用存储在电容器中的能量和/或磁盘盘片的角动量来提供电源,以完成正在进行的任何操作。尽管如此,在写系统调用和板载磁盘驱动器电子器件之间有许多层,因此我们在Unix和w32 VFS实现中采取安全的方法,并假设扇区写入不是原子的。另一方面,对文件系统有更多控制权的设备制造商可能会考虑启用xDeviceCharacteristics的原子写入属性,如果他们的硬件真的可以进行原子写入。</target>
        </trans-unit>
        <trans-unit id="586e6ff48cacbcb2ddee486b19c44489728dbf7f" translate="yes" xml:space="preserve">
          <source>We call custom modifications to the SQLite source code that are held for the use of a single application a &quot;private branch&quot;. When a private branch becomes necessary, the application developer must take on the task of keeping the private branch in synchronization with the public SQLite sources. This is tedious. It can also be tricky, since while the SQLite file format and published interfaces are very stable, the internal implementation of SQLite changes quite rapidly. Hundreds or thousands of lines of code might change for any given SQLite point release.</source>
          <target state="translated">我们把对SQLite源码的自定义修改称为 &quot;私有分支&quot;,这些修改是为单个应用程序的使用而举行的。当私有分支成为必要时,应用程序开发人员必须承担起保持私有分支与公共SQLite源码同步的任务。这是很繁琐的。这也很棘手,因为虽然SQLite文件格式和发布的接口非常稳定,但SQLite的内部实现变化相当快。对于任何一个给定的SQLite点发布,可能会有几百或几千行代码发生变化。</target>
        </trans-unit>
        <trans-unit id="2cfeb2a347fa38b180ceb6f0fe6a37a3de052a3a" translate="yes" xml:space="preserve">
          <source>We call this kind of index usage a &quot;skip-scan&quot; because the database engine is basically doing a full scan of the index but it optimizes the scan (making it less than &quot;full&quot;) by occasionally skipping ahead to the next candidate value.</source>
          <target state="translated">我们把这种索引使用方式称为 &quot;跳过扫描&quot;,因为数据库引擎基本上是在对索引进行全面扫描,但它通过偶尔提前跳到下一个候选值来优化扫描(使其不那么 &quot;全面&quot;)。</target>
        </trans-unit>
        <trans-unit id="d8c54ecc5dbd9d71e35248692355648775c7c06a" translate="yes" xml:space="preserve">
          <source>We can see the VDBE program that SQLite uses to implement this INSERT using the &lt;b&gt;sqlite&lt;/b&gt; command-line utility. First start up &lt;b&gt;sqlite&lt;/b&gt; on a new, empty database, then create the table. Next change the output format of &lt;b&gt;sqlite&lt;/b&gt; to a form that is designed to work with VDBE program dumps by entering the &quot;.explain&quot; command. Finally, enter the [INSERT] statement shown above, but precede the [INSERT] with the special keyword [EXPLAIN]. The [EXPLAIN] keyword will cause &lt;b&gt;sqlite&lt;/b&gt; to print the VDBE program rather than execute it. We have:</source>
          <target state="translated">我们可以看到SQLite使用&lt;b&gt;sqlite&lt;/b&gt;命令行实用工具来实现此INSERT的VDBE程序。首先在一个新的空数据库上启动&lt;b&gt;sqlite&lt;/b&gt;，然后创建表。接下来，通过输入&amp;ldquo; .explain&amp;rdquo;命令将&lt;b&gt;sqlite&lt;/b&gt;的输出格式更改为旨在与VDBE程序转储一起使用的格式。最后，输入上面显示的[INSERT]语句，但在[INSERT]之前加上特殊关键字[EXPLAIN]。 [EXPLAIN]关键字将导致&lt;b&gt;sqlite&lt;/b&gt;打印VDBE程序而不是执行它。我们有：</target>
        </trans-unit>
        <trans-unit id="ec7be355019068bf92f7d741482fdf6ee1c56c3e" translate="yes" xml:space="preserve">
          <source>We can see the process in action in the following query:</source>
          <target state="translated">我们可以在下面的查询中看到这个过程。</target>
        </trans-unit>
        <trans-unit id="a73853b7ca854f99ebc56a8da7248062e4f92563" translate="yes" xml:space="preserve">
          <source>We deduce the following rules of thumb from the matrix above:</source>
          <target state="translated">我们从上述矩阵推导出以下经验法则。</target>
        </trans-unit>
        <trans-unit id="84f5304369a052a144aa55c526df651c94e44de3" translate="yes" xml:space="preserve">
          <source>We emphasis that most applications are well-served by the built-in default implementations of the SQLite interface subsystems. Developers are encouraged to use the default built-in implementations whenever possible and to build SQLite without any special compile-time options or parameters. However, some highly specialized applications may benefit from substituting or modifying one or more of these built-in SQLite interface subsystems. Or, if SQLite is used on an operating system other than Unix (Linux or Mac OS X), Windows (Win32 or WinCE), or OS/2 then none of the interface subsystems that come built into SQLite will work and the application will need to provide alternative implementations suitable for the target platform.</source>
          <target state="translated">我们强调,大多数应用程序都可以通过SQLite接口子系统的内置默认实现得到很好的服务。我们鼓励开发者尽可能地使用默认的内置实现,并且在没有任何特殊编译时选项或参数的情况下构建SQLite。然而,一些高度专业化的应用程序可能会从替换或修改一个或多个内置的SQLite接口子系统中受益。或者,如果在Unix(Linux或Mac OS X)、Windows(Win32或WinCE)或OS/2以外的操作系统上使用SQLite,那么SQLite内置的接口子系统都将无法工作,应用程序需要提供适合目标平台的替代实现。</target>
        </trans-unit>
        <trans-unit id="6885829b70a7aa6d03abf4dbc376f359d84e8896" translate="yes" xml:space="preserve">
          <source>We emphasize again that these steps are not intended to be the only acceptable method for maintaining private branch. This approach is one of many. Use this document as a baseline for preparing project-specific procedures. Do not be afraid to experiment.</source>
          <target state="translated">我们再次强调,这些步骤并不是为了成为维持私人部门的唯一可接受的方法。这种方法是众多方法中的一种。将本文档作为编制项目特定程序的基线。不要害怕试验。</target>
        </trans-unit>
        <trans-unit id="55e740e8153135385200d1c2a44c0a166232d431" translate="yes" xml:space="preserve">
          <source>We have received reports of implementations of both Windows network filesystems and NFS in which locking was subtly broken. We can not verify these reports, but as locking is difficult to get right on a network filesystem we have no reason to doubt them. You are advised to avoid using SQLite on a network filesystem in the first place, since performance will be slow. But if you must use a network filesystem to store SQLite database files, consider using a secondary locking mechanism to prevent simultaneous writes to the same database even if the native filesystem locking mechanism malfunctions.</source>
          <target state="translated">我们收到了关于Windows网络文件系统和NFS的实施的报告,其中锁定被巧妙地破坏了。我们无法验证这些报告,但由于锁定在网络文件系统上很难做到正确,我们没有理由怀疑它们。我们建议你首先避免在网络文件系统上使用SQLite,因为性能会很慢。但如果你必须使用网络文件系统来存储SQLite数据库文件,请考虑使用辅助锁定机制,以防止在原生文件系统锁定机制发生故障的情况下同时写入同一个数据库。</target>
        </trans-unit>
        <trans-unit id="e3e45a07ed13dbd9549a67862a5bea3d84d72898" translate="yes" xml:space="preserve">
          <source>We have seen multiple cases where a file descriptor was open on a file, then that file descriptor was closed and reopened on an SQLite database. Later, some other thread continued to write into the old file descriptor, not realizing that the original file had been closed already. But because the file descriptor had been reopened by SQLite, the information that was intended to go into the original file ended up overwriting parts of the SQLite database, leading to corruption of the database.</source>
          <target state="translated">我们见过多个案例,在一个文件上打开了一个文件描述符,然后这个文件描述符被关闭,在SQLite数据库上重新打开。后来,其他一些线程继续向旧的文件描述符中写入,而不知道原来的文件已经被关闭了。但是由于文件描述符已经被SQLite重新打开了,所以原本要进入原文件的信息最终覆盖了SQLite数据库的部分内容,导致数据库的损坏。</target>
        </trans-unit>
        <trans-unit id="776084395b585bc0c28bd248aca15b6e574ec177" translate="yes" xml:space="preserve">
          <source>We here restate and amplify the previous sentence for emphasis: All changes within a single transaction in SQLite either occur completely or not at all, even if the act of writing the change out to the disk is interrupted by</source>
          <target state="translated">我们在这里重述和放大上一句话以示强调。在SQLite中,一个事务中的所有变化要么完全发生,要么根本不发生 即使将变化写到磁盘上的行为被中断,也是如此</target>
        </trans-unit>
        <trans-unit id="285d3238c6a1bf77e9e62067e7f260bf0b08d8c7" translate="yes" xml:space="preserve">
          <source>We know of no way to use the standard library printf() C interface to implement the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; feature of SQLite. The built-in printf() implementation can be easily adapted to that task, however.</source>
          <target state="translated">我们知道无法使用标准库printf（）C接口来实现SQLite 的&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL函数&lt;/a&gt;功能。但是，内置的printf（）实现可以轻松地适应该任务。</target>
        </trans-unit>
        <trans-unit id="e3b0138457bb49851f251d195b698d479cac5033" translate="yes" xml:space="preserve">
          <source>We make a distinction between a &quot;file format&quot; and an &quot;application format&quot;. A file format is used to store a single object. So, for example, a GIF or JPEG file stores a single image, and an XHTML file stores text, so those are &quot;file formats&quot; and not &quot;application formats&quot;. An EPUB file, in contrast, stores both text and images (as contained XHTML and GIF/JPEG files) and so it is considered an &quot;application format&quot;. This article is about &quot;application formats&quot;.</source>
          <target state="translated">我们对 &quot;文件格式 &quot;和 &quot;应用程序格式 &quot;进行了区分。文件格式是用来存储单个对象的。因此,例如,GIF或JPEG文件存储一个单一的图像,和XHTML文件存储文本,所以这些都是 &quot;文件格式&quot;,而不是 &quot;应用程序格式&quot;。相比之下,一个EPUB文件,同时存储文本和图像(如包含XHTML和GIF/JPEG文件),所以它被认为是一个 &quot;应用程序格式&quot;。这篇文章是关于 &quot;应用格式&quot;。</target>
        </trans-unit>
        <trans-unit id="8909441e4d410050a1ceb2a957053ae17d1136a8" translate="yes" xml:space="preserve">
          <source>We propose to use the &lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;fossil software configuration management&lt;/a&gt; system to set up two branches. One branch (the &quot;public branch&quot; or &quot;trunk&quot;) contains the published SQLite sources and the other branch is the private branch which contains the code that is customized for the project. Whenever a new public release of SQLite is made, that release is added to the public branch and then the changes are merged into the private branch.</source>
          <target state="translated">我们建议使用&lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;化石软件配置管理&lt;/a&gt;系统来建立两个分支。一个分支（&amp;ldquo;公共分支&amp;rdquo;或&amp;ldquo;树干&amp;rdquo;）包含已发布的SQLite源，另一个分支是私有分支，其中包含为项目定制的代码。每当创建新的SQLite公共版本时，都会将该版本添加到public分支中，然后将更改合并到private分支中。</target>
        </trans-unit>
        <trans-unit id="cdfe5941cfa327faeee1a3aa77e06f6d937ec10c" translate="yes" xml:space="preserve">
          <source>We say that a system has the powersafe overwrite property if the following statement is true:</source>
          <target state="translated">如果下面的陈述为真,我们就说一个系统具有 powersafe overwrite 属性。</target>
        </trans-unit>
        <trans-unit id="5b1e50114d6654d737309df661bca3d508073d97" translate="yes" xml:space="preserve">
          <source>We say that algorithm-1 is &quot;faster&quot;, but this is not strictly true. Algorithm-1 is faster in common repositories, but it is possible to construct a repository in which every check-in is on a different uniquely-named branch and all check-ins are children of the root check-in. In that case, TAGXREF_I1 would become more selective than PLINK_I1 and algorithm-2 really would be the faster choice. However such repositories are very unlikely to appear in practice and so hard-coding the loop nested order using the CROSS JOIN syntax is a reasonable solution to the problem in this case.</source>
          <target state="translated">我们说算法-1 &quot;更快&quot;,但这并不是严格的事实。算法-1在普通的存储库中更快,但也有可能构建一个存储库,在这个存储库中,每个签入都在不同的唯一命名的分支上,而所有签入都是根签入的子代。在这种情况下,TAGXREF_I1将变得比PLINK_I1更有选择性,算法-2确实是更快的选择。然而这样的资源库在实际中出现的可能性很小,所以在这种情况下,使用CROSS JOIN语法对循环嵌套顺序进行硬编码是一个合理的解决方案。</target>
        </trans-unit>
        <trans-unit id="4ae339abf0ab672c65bdd6ccb60aabe5af32c503" translate="yes" xml:space="preserve">
          <source>We suspect that a common failure mode for SQLite recovery happens like this: A power failure occurs. After power is restored, a well-meaning user or system administrator begins looking around on the disk for damage. They see their database file named &quot;important.data&quot;. This file is perhaps familiar to them. But after the crash, there is also a hot journal named &quot;important.data-journal&quot;. The user then deletes the hot journal, thinking that they are helping to cleanup the system. We know of no way to prevent this other than user education.</source>
          <target state="translated">我们怀疑,SQLite恢复的常见故障模式是这样的。发生断电 在电源恢复后,一个好心的用户或系统管理员开始在磁盘上寻找损坏的地方。他们看到自己的数据库文件名为 &quot;important.data&quot;。这个文件也许他们很熟悉。但是在崩溃之后,还有一个名为 &quot;import.data-journal &quot;的热日志。然后,用户删除了热日志,认为他们在帮助清理系统。我们知道除了用户教育之外,没有办法防止这种情况的发生。</target>
        </trans-unit>
        <trans-unit id="00a0dbc2ebcd051c964b8bf428dbc0b4e94c1fd5" translate="yes" xml:space="preserve">
          <source>We want to know the twenty most recent ancestors in time (out of the thousands and thousands of ancestors in the whole DAG) for checkin &quot;@BASELINE&quot;. (A query similar to this is used by the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; VCS to show the N most recent ancestors of a check. For example: &lt;a href=&quot;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&quot;&gt;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&lt;/a&gt;.)</source>
          <target state="translated">我们想及时了解二十个最近的祖先（在整个DAG中成千上万的祖先中），以进行&amp;ldquo; @BASELINE&amp;rdquo;签入。（&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; VCS 使用与此类似的查询来显示N个最近的支票祖先。例如：&lt;a href=&quot;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&quot;&gt;http&lt;/a&gt; : //www.sqlite.org/src/timeline?p= trunk&amp;amp;n =30。）</target>
        </trans-unit>
        <trans-unit id="351c0b2917fd27c07d1575c325d6c434bf485fe8" translate="yes" xml:space="preserve">
          <source>Website Keyword Index</source>
          <target state="translated">网站关键词指数</target>
        </trans-unit>
        <trans-unit id="856955a1acaac17d20fdfd7478c48b194daa4307" translate="yes" xml:space="preserve">
          <source>Well-commented source code with &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">注释良好的源代码，具有&lt;a href=&quot;testing#coverage&quot;&gt;100％的分支测试覆盖率&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fd93ad7c9151c213e1c81e636ad41e187dfdf3a" translate="yes" xml:space="preserve">
          <source>What If OpenDocument Used SQLite?</source>
          <target state="translated">如果OpenDocument使用SQLite怎么办?</target>
        </trans-unit>
        <trans-unit id="d1c91decdb314d1f98700dd1bdf20618d03adb15" translate="yes" xml:space="preserve">
          <source>What Is An Application File Format?</source>
          <target state="translated">什么是应用文件格式?</target>
        </trans-unit>
        <trans-unit id="8eafc9293497bf8d5a3b149b033e2c04c50289e4" translate="yes" xml:space="preserve">
          <source>What datatypes does SQLite support?</source>
          <target state="translated">SQLite支持哪些数据类型?</target>
        </trans-unit>
        <trans-unit id="7ca20dfb510b956d12b7de007ce4f96db962811f" translate="yes" xml:space="preserve">
          <source>What harm could come of that, you ask? The SQLite developers (including this author) wondered the same thing. But then security researchers pointed out that knowledge of pointers can help attackers to circumvent address-space randomization defenses. This is called a &quot;pointer leak&quot;. A pointer leak is not itself a vulnerability, but it can aid an attacker in effectively exploiting other vulnerabilities.</source>
          <target state="translated">你问这有什么坏处?SQLite开发人员(包括本作者)也想知道同样的事情。但后来安全研究人员指出,对指针的了解可以帮助攻击者规避地址空间随机化防御。这就是所谓的 &quot;指针泄露&quot;。指针泄漏本身并不是一个漏洞,但它可以帮助攻击者有效利用其他漏洞。</target>
        </trans-unit>
        <trans-unit id="09ddbcfffc504cb584adaf832caf679c81ed102d" translate="yes" xml:space="preserve">
          <source>What is an SQLITE_CORRUPT error? What does it mean for the database to be &quot;malformed&quot;? Why am I getting this error?</source>
          <target state="translated">什么是SQLITE_CORRUPT错误?数据库 &quot;畸形 &quot;是什么意思?为什么我得到这个错误?</target>
        </trans-unit>
        <trans-unit id="e5264a2f32d0c974ba717f0941d074614666d5ea" translate="yes" xml:space="preserve">
          <source>What is an SQLITE_SCHEMA error, and why am I getting one?</source>
          <target state="translated">什么是SQLITE_SCHEMA错误,为什么我得到一个错误?</target>
        </trans-unit>
        <trans-unit id="cb018b89b59e298a68db86ff80fc9eea140ccdd3" translate="yes" xml:space="preserve">
          <source>What is the Export Control Classification Number (ECCN) for SQLite?</source>
          <target state="translated">什么是SQLite的出口管制分类号(ECCN)?</target>
        </trans-unit>
        <trans-unit id="61fca1595cf614e3a194bfd194191403183b57e8" translate="yes" xml:space="preserve">
          <source>What is the maximum size of a VARCHAR in SQLite?</source>
          <target state="translated">SQLite中VARCHAR的最大大小是多少?</target>
        </trans-unit>
        <trans-unit id="e213b22ce22925686c52aad4a90dd069f0962434" translate="yes" xml:space="preserve">
          <source>What is the total size of all files in the archive whose names end in &quot;.h&quot; or &quot;.cpp&quot;?</source>
          <target state="translated">归档中所有名字以&quot;.h &quot;或&quot;.cpp &quot;结尾的文件的总大小是多少?</target>
        </trans-unit>
        <trans-unit id="3888afad2b88cfc56a74bc460d038e108bfb5e98" translate="yes" xml:space="preserve">
          <source>What others say about Fossil and Git</source>
          <target state="translated">其他人对 Fossil 和 Git 的评价</target>
        </trans-unit>
        <trans-unit id="f9f3ab382e9485e7278404c856bf161ccd6b2df4" translate="yes" xml:space="preserve">
          <source>What percentage of the files are compressed by less than 25%?</source>
          <target state="translated">压缩率低于25%的文件有多少?</target>
        </trans-unit>
        <trans-unit id="b5461625f1011b3e4b6508b082fdfa963ef833c0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; is used to prepare a statement, the statement might be re-prepared during &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; due to a schema change. Hence, the application should ensure that the correct authorizer callback remains in place during the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">当使用&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;准备一条语句时，由于架构更改，该语句可能在&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间重新准备。因此，应用程序应确保在&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间保留正确的授权者回调。</target>
        </trans-unit>
        <trans-unit id="78fe376fe612030dba8e993e1e6346105acb51d4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode=EXCLUSIVE&lt;/a&gt; (exclusive locking mode) is set, only a single client is allowed to have the database open at one time. Since only a single client can use the database, the shm file is omitted. The single client uses a buffer in heap memory as a substitute for the memory-mapped shm file.</source>
          <target state="translated">设置&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMAlocking_mode = EXCLUSIVE&lt;/a&gt;（排他锁定模式）时，仅允许单个客户端一次打开数据库。由于只有一个客户端可以使用该数据库，因此将省略shm文件。单个客户端使用堆内存中的缓冲区代替内存映射的shm文件。</target>
        </trans-unit>
        <trans-unit id="9abb811ba43f82c87eea517150f407f49b9906ac" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; is used to prepare a statement, the statement might be re-prepared during &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; due to a schema change. Hence, the application should ensure that the correct authorizer callback remains in place during the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">当使用&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;准备一条语句时，由于架构更改，该语句可能在&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间重新准备。因此，应用程序应确保在&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间保留正确的授权者回调。</target>
        </trans-unit>
        <trans-unit id="c3c4a10f39f154fb9afe1cc905a05f1b736c3877" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are used, the &quot;cache&quot; query parameter can be used to specify whether or not the database will use shared cache. Use &quot;cache=shared&quot; to enable shared cache and &quot;cache=private&quot; to disable shared cache. The ability to use URI query parameters to specify the cache sharing behavior of a database connection allows cache sharing to be controlled in &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. For example:</source>
          <target state="translated">使用&lt;a href=&quot;uri&quot;&gt;URI文件名时&lt;/a&gt;，&amp;ldquo; cache&amp;rdquo;查询参数可用于指定数据库是否将使用共享缓存。使用&amp;ldquo; cache = shared&amp;rdquo;启用共享缓存，使用&amp;ldquo; cache = private&amp;rdquo;禁用共享缓存。使用URI查询参数来指定数据库连接的缓存共享行为的功能允许在&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中控制缓存共享。例如：</target>
        </trans-unit>
        <trans-unit id="b0e9fc2254d872ac23aeae318057b6aa62d769dc" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;sqlite_step&lt;/b&gt; returns SQLITE_DONE or SQLITE_ERROR, the *pN and *pazColName values are set to the number of columns in the result set and to the names of the columns, just as they are for an SQLITE_ROW return. This allows the calling code to find the number of result columns and the column names and datatypes even if the result set is empty. The *pazValue parameter is always set to NULL when the return codes is SQLITE_DONE or SQLITE_ERROR. If the SQL being executed is a statement that does not return a result (such as an INSERT or an UPDATE) then *pN will be set to zero and *pazColName will be set to NULL.</source>
          <target state="translated">当&lt;b&gt;sqlite_step&lt;/b&gt;返回SQLITE_DONE或SQLITE_ERROR时，将* pN和* pazColName值设置为结果集中的列数和列名，就像返回SQLITE_ROW时一样。这样，即使结果集为空，调用代码也可以找到结果列的数量以及列名和数据类型。当返回码为SQLITE_DONE或SQLITE_ERROR时，* pazValue参数始终设置为NULL。如果正在执行的SQL是不返回结果的语句（例如INSERT或UPDATE），则* pN将设置为零，而* pazColName将设置为NULL。</target>
        </trans-unit>
        <trans-unit id="a738765e6d76b084ca79459e28b3c9bfca412130" translate="yes" xml:space="preserve">
          <source>When I want to see what has been happening on SQLite (or any of about a dozen other projects that I work on) I visit the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;timeline&lt;/a&gt; and in a single screen I can see a quick summary of all the latest changes, on all branches. In a few clicks, I can drill down to see as much detail as I want. I can even do this from a phone.</source>
          <target state="translated">当我想查看SQLite（或我正在处理的其他十几个项目中的任何一个）发生了什么时，我访问了&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;时间轴，&lt;/a&gt;并在一个屏幕上可以快速查看所有分支上所有最新更改的摘要。只需单击几下，我就可以深入查看所需的详细信息。我什至可以通过电话做到这一点。</target>
        </trans-unit>
        <trans-unit id="3038431e6823ccdef12d1f539d0c61f30867d530" translate="yes" xml:space="preserve">
          <source>When RAISE(IGNORE) is called, the remainder of the current trigger program, the statement that caused the trigger program to execute and any subsequent trigger programs that would have been executed are abandoned. No database changes are rolled back. If the statement that caused the trigger program to execute is itself part of a trigger program, then that trigger program resumes execution at the beginning of the next step.</source>
          <target state="translated">当调用RAISE(IGNORE)时,当前触发程序的剩余部分、导致触发程序执行的语句以及任何后续的本应执行的触发程序都会被放弃。没有数据库的变化被回滚。如果导致触发程序执行的语句本身是触发程序的一部分,那么该触发程序将在下一步开始时恢复执行。</target>
        </trans-unit>
        <trans-unit id="3b714e2ab0d85ccd85c4bb15bba20b0ece19aa26" translate="yes" xml:space="preserve">
          <source>When SQLITE_ENABLE_SORTER_REFERENCES is enabled, the records passed to the sorter often contain only a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; value. Such records are much smaller. This means the sorter has much less &quot;payload&quot; to deal with and can run faster. After sorting has occurred, the ROWID is used to look up the output column values in the original table. That requires another search into the table, and could potentially result in a slowdown. Or, it might be a performance win, depending on how large the values are.</source>
          <target state="translated">启用S​​QLITE_ENABLE_SORTER_REFERENCES时，传递给排序器的记录通常仅包含&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;值。这样的记录要小得多。这意味着分拣机需要处理的&amp;ldquo;有效负载&amp;rdquo;少得多，并且运行速度更快。发生排序后，将使用ROWID在原始表中查找输出列的值。这需要对表进行另一次搜索，并有可能导致速度降低。或者，可能取决于性能值，这取决于性能值。</target>
        </trans-unit>
        <trans-unit id="22e2481654b7e499f20f0d8a14ccb29b23b47522" translate="yes" xml:space="preserve">
          <source>When SQLite calls the xTruncate() method, the cache must discard all existing cache entries with page numbers (keys) greater than or equal to the value of the iLimit parameter passed to xTruncate(). If any of these pages are pinned, they are implicitly unpinned, meaning that they can be safely discarded.</source>
          <target state="translated">当SQLite调用xTruncate()方法时,缓存必须丢弃所有现有的缓存条目,其页码(键)大于或等于传递给xTruncate()的iLimit参数的值。如果这些页面中的任何页面被钉住,它们就会被隐式地取消钉住,这意味着它们可以被安全地丢弃。</target>
        </trans-unit>
        <trans-unit id="35ff55b55b3144279fa7594a0e19885043618a48" translate="yes" xml:space="preserve">
          <source>When SQLite compares two strings, it uses a collating sequence or collating function (two words for the same thing) to determine which string is greater or if the two strings are equal. SQLite has three built-in collating functions: BINARY, NOCASE, and RTRIM.</source>
          <target state="translated">当SQLite比较两个字符串时,它使用一个整理序列或整理函数(两个词代表同一事物)来确定哪个字符串更大或两个字符串是否相等。SQLite有三个内置的整理函数。BINARY、NOCASE和RTRIM。</target>
        </trans-unit>
        <trans-unit id="df3602b4706fda192f1a7fee5a1fd5a14d6046e0" translate="yes" xml:space="preserve">
          <source>When SQLite has been compiled with SQLITE_THREADSAFE=1 or SQLITE_THREADSAFE=2 then the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; can be altered at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface together with one of these verbs:</source>
          <target state="translated">使用SQLITE_THREADSAFE = 1或SQLITE_THREADSAFE = 2编译SQLite时，可以在运行时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口以及以下动词之一来更改&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="447f302ea851392a6eb166989220e6263326e6b8" translate="yes" xml:space="preserve">
          <source>When SQLite invokes the xSync() method of an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object it uses a combination of these integer values as the second argument.</source>
          <target state="translated">当SQLite调用&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xSync（）方法时，它将使用这些整数值的组合作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="68d87b5a5c9475d95e19a08651c92859f1a25fae" translate="yes" xml:space="preserve">
          <source>When SQLite invokes the xSync() method of an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object it uses a combination of these integer values as the second argument.</source>
          <target state="translated">当SQLite调用&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xSync（）方法时，它将使用这些整数值的组合作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="d35292160ae7a274b67325cfcd829f7632f2415b" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, extra &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; commands are available that are useful for debugging and for exploring the operation of the VDBE. For example the &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt; pragma can be enabled to cause a disassembly of each VDBE opcode to be printed on standard output as the opcode is executed. These debugging pragmas include:</source>
          <target state="translated">当使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译SQLite 时，将提供额外的&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;命令，这些命令对于调试和探索VDBE的操作很有用。例如，可以启用&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace杂&lt;/a&gt;注，以在执行操作码时将每个VDBE操作码的反汇编打印在标准输出上。这些调试实用程序包括：</target>
        </trans-unit>
        <trans-unit id="c9b995e894f1bbf11af15b50811aafd3b796ef85" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; option, an alternative memory allocator that does not use malloc() is included in the build. The SQLite developers refer to this alternative memory allocator as &quot;memsys5&quot;. Even when it is included in the build, memsys5 is disabled by default. To enable memsys5, the application must invoke the following SQLite interface at start-time:</source>
          <target state="translated">当使用&lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt;选项编译SQLite时，构建中将包含一个不使用malloc（）的备用内存分配器。SQLite开发人员将此替代内存分配器称为&amp;ldquo; memsys5&amp;rdquo;。即使将其包含在构建中，memsys5也会默认禁用。要启用memsys5，应用程序必须在启动时调用以下SQLite接口：</target>
        </trans-unit>
        <trans-unit id="84ef8ebae9f557b2e5ae28bc7ed5746f2af208db" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the SQLITE_MUTEX_APPDEF=1 option, it completely omits the implementation of its &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex primitive functions&lt;/a&gt;. But the SQLite library still attempts to call these functions where necessary, so the application must itself implement the &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex primitive functions&lt;/a&gt; and link them together with SQLite.</source>
          <target state="translated">当使用SQLITE_MUTEX_APPDEF = 1选项编译SQLite时，它将完全省略其&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;互斥体基元函数的实现&lt;/a&gt;。但是，SQLite库仍在必要时尝试调用这些函数，因此应用程序本身必须实现&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;互斥体基元函数&lt;/a&gt;，并将其与SQLite链接在一起。</target>
        </trans-unit>
        <trans-unit id="7f137b8f0298a3c2c2e18d67228fddc4346fc04c" translate="yes" xml:space="preserve">
          <source>When SQLite is ported to new operating systems (operating systems other than Unix, Windows, and OS/2 for which ports are provided together with the core) two new functions, &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt;, must be provided as part of the port.</source>
          <target state="translated">当将SQLite移植到新的操作系统（与内核一起提供端口的Unix，Windows和OS / 2以外的其他操作系统&lt;a href=&quot;c3ref/initialize&quot;&gt;）时&lt;/a&gt;，必须提供两个新函数&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;和sqlite3_os_end（），作为港口。</target>
        </trans-unit>
        <trans-unit id="07b5adba013870fc7dc891a2821a51ae6a59171f" translate="yes" xml:space="preserve">
          <source>When SQLite tries to access a file that is locked by another process, the default behavior is to return SQLITE_BUSY. You can adjust this behavior from C code using the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; or &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; API functions.</source>
          <target state="translated">当SQLite尝试访问被另一个进程锁定的文件时，默认行为是返回SQLITE_BUSY。您可以使用&lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;或&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt; API函数从C代码调整此行为。</target>
        </trans-unit>
        <trans-unit id="77327b5e49ebfcc1acf07f15eb4bc6a41abc04ea" translate="yes" xml:space="preserve">
          <source>When SQLite tries to open a database and finds that it is locked, it can optionally delay for a short while and try to open the file again. This process repeats until the query times out and SQLite returns a failure. The timeout is adjustable. It is set to 0 by default so that if the database is locked, the SQL statement fails immediately. But you can use the &quot;timeout&quot; method to change the timeout value to a positive number. For example:</source>
          <target state="translated">当SQLite试图打开一个数据库并发现它被锁定时,它可以选择性地延迟一小段时间,然后再次尝试打开文件。这个过程重复进行,直到查询超时,SQLite返回失败。超时时间是可以调整的。它默认设置为0,这样如果数据库被锁定,SQL语句就会立即失败。但你可以使用 &quot;timeout &quot;方法将超时值改为正数。例如:&quot;超时&quot;。</target>
        </trans-unit>
        <trans-unit id="a804ec7f0a4b84d1b0a408e0b54447cf6ce4d1f8" translate="yes" xml:space="preserve">
          <source>When SQLite version 2.7.0 or later opens a 2.6.3 or earlier database, it assumes all columns of all tables have type &quot;numeric&quot;. For 2.7.0 and later databases, columns have type &quot;text&quot; if their datatype string contains the substrings &quot;char&quot; or &quot;clob&quot; or &quot;blob&quot; or &quot;text&quot;. Otherwise they are of type &quot;numeric&quot;.</source>
          <target state="translated">当SQLite 2.7.0或更高版本打开2.6.3或更早版本的数据库时,它假设所有表的所有列的类型为 &quot;数字&quot;。对于2.7.0及更高版本的数据库,如果其数据类型字符串包含子串 &quot;char &quot;或 &quot;clob &quot;或 &quot;blob &quot;或 &quot;text&quot;,则列的类型为 &quot;text&quot;。否则它们的类型为 &quot;数字&quot;。</target>
        </trans-unit>
        <trans-unit id="a13408a2bfc81e3d04562db93d8a2fee6642da62" translate="yes" xml:space="preserve">
          <source>When SQLite was first being developed, Java was a young and immature language. C++ was older, but was undergoing such growing pains that it was difficult to find any two C++ compilers that worked the same way. So C was definitely a better choice back when SQLite was first being developed. The situation is less stark now, but there is little to no benefit in recoding SQLite at this point.</source>
          <target state="translated">当SQLite刚被开发出来的时候,Java是一种年轻而不成熟的语言。而C++虽然历史较长,但正经历着成长的阵痛,很难找到两个工作方式相同的C++编译器。所以,在SQLite刚开始开发的时候,C语言无疑是更好的选择。现在情况已经不那么严峻了,但现在重新编码SQLite几乎没有什么好处。</target>
        </trans-unit>
        <trans-unit id="dd3d6234851cf7360a0faea15fc7c5c549469738" translate="yes" xml:space="preserve">
          <source>When a</source>
          <target state="translated">当一个</target>
        </trans-unit>
        <trans-unit id="b177e9320f32426fce848e5e150f059f226858de" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraint violation occurs, the REPLACE algorithm deletes pre-existing rows that are causing the constraint violation prior to inserting or updating the current row and the command continues executing normally. If a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; constraint violation occurs, the REPLACE conflict resolution replaces the NULL value with the default value for that column, or if the column has no default value, then the ABORT algorithm is used. If a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation occurs, the REPLACE conflict resolution algorithm works like ABORT.</source>
          <target state="translated">当发生&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束冲突时，REPLACE算法会在插入或更新当前行之前删除导致约束冲突的先前存在的行，并且该命令将继续正常执行。如果发生&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NOT NULL&lt;/a&gt;约束冲突，则REPLACE冲突解决方案将NULL值替换为该列的默认值，或者如果该列没有默认值，则使用ABORT算法。如果发生&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;或&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;冲突，则REPLACE冲突解决算法的工作方式类似于ABORT。</target>
        </trans-unit>
        <trans-unit id="e40cfe4f4a2672a463b5e9153a546fd55dd2ffa8" translate="yes" xml:space="preserve">
          <source>When a UNIQUE constraint violation occurs, the pre-existing row that caused the constraint violation is removed prior to inserting or updating the current row. Thus the insert or update always occurs. The command continues executing normally. No error is returned.</source>
          <target state="translated">当发生UNIQUE约束违规时,在插入或更新当前行之前,会先删除导致约束违规的已有行。因此,插入或更新总是发生。命令继续正常执行。没有错误返回。</target>
        </trans-unit>
        <trans-unit id="f0f8ec6207370b712331444906a15edac7bd9982" translate="yes" xml:space="preserve">
          <source>When a WAL mode database is in active use, all three of the above files usually exist. Except, the Wal-Index file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set.</source>
          <target state="translated">在积极使用WAL模式数据库时，以上三个文件通常都存在。除非设置了&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;独占锁定模式，&lt;/a&gt;否则将省略Wal-Index文件。</target>
        </trans-unit>
        <trans-unit id="88f7d29bc8b807cc4618404ebf6e68af0b14195c" translate="yes" xml:space="preserve">
          <source>When a blocking connection's transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda8b145f23c6a0bb85ff0a12c0706d7475482c1" translate="yes" xml:space="preserve">
          <source>When a blocking connections transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.</source>
          <target state="translated">当一个阻塞连接事务结束时,可能有一个以上的阻塞连接已经注册了解锁-通知回调。如果两个或多个这样的阻塞连接指定了相同的回调函数,那么就不会多次调用回调函数,而是将阻塞连接指定的void*上下文指针集捆绑在一起,调用一次。这样,应用程序就有机会优先处理与未被阻塞的数据库连接集相关的任何操作。</target>
        </trans-unit>
        <trans-unit id="b1623124138a1a453c5d32a837bf66762d013ccd" translate="yes" xml:space="preserve">
          <source>When a call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no &quot;blocking connection&quot;, so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; query, an infinite loop might be the result.</source>
          <target state="translated">当调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回SQLITE_LOCKED时，几乎总是适合调用sqlite3_unlock_notify（）。但是，有一个例外。当执行&amp;ldquo; DROP TABLE&amp;rdquo;或&amp;ldquo; DROP INDEX&amp;rdquo;语句时，SQLite检查当前是否有任何执行的SELECT语句属于同一连接。如果存在，则返回SQLITE_LOCKED。在这种情况下，没有&amp;ldquo;阻塞连接&amp;rdquo;，因此调用sqlite3_unlock_notify（）会导致立即调用unlock-notify回调。如果应用程序随后再次尝试&amp;ldquo; DROP TABLE&amp;rdquo;或&amp;ldquo; DROP INDEX&amp;rdquo;查询，则可能会导致无限循环。</target>
        </trans-unit>
        <trans-unit id="96fd9fb18740d68a037d0a53dc8f7e543ce5815d" translate="yes" xml:space="preserve">
          <source>When a call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no &quot;blocking connection&quot;, so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; query, an infinite loop might be the result.</source>
          <target state="translated">当调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回SQLITE_LOCKED时，几乎总是适合调用sqlite3_unlock_notify（）。但是，有一个例外。当执行&amp;ldquo; DROP TABLE&amp;rdquo;或&amp;ldquo; DROP INDEX&amp;rdquo;语句时，SQLite检查当前是否有任何执行的SELECT语句属于同一连接。如果存在，则返回SQLITE_LOCKED。在这种情况下，没有&amp;ldquo;阻塞连接&amp;rdquo;，因此调用sqlite3_unlock_notify（）会导致立即调用unlock-notify回调。如果应用程序随后再次尝试&amp;ldquo; DROP TABLE&amp;rdquo;或&amp;ldquo; DROP INDEX&amp;rdquo;查询，则可能会导致无限循环。</target>
        </trans-unit>
        <trans-unit id="4b27c6df7f370b95df53fb6af6deaef3ac0ea82c" translate="yes" xml:space="preserve">
          <source>When a changeset or patchset is applied to a database, an attempt is made to insert a new row for each INSERT change, remove a row for each DELETE change and modify a row for each UPDATE change. If the target database is in the same state as the original database that the changeset was recorded on, this is a simple matter. However, if the contents of the target database is not in exactly this state, conflicts can occur when applying the changeset or patchset.</source>
          <target state="translated">当一个变化集或补丁集被应用到数据库时,会尝试为每一个INSERT变化插入一条新的记录,为每一个DELETE变化删除一条记录,为每一个UPDATE变化修改一条记录。如果目标数据库与记录更改集的原始数据库处于相同的状态,这是个简单的问题。但是,如果目标数据库的内容不完全是这种状态,那么在应用变更集或补丁集时就会发生冲突。</target>
        </trans-unit>
        <trans-unit id="af13c24a93516a02da3d5819b6d5ee382b394c0c" translate="yes" xml:space="preserve">
          <source>When a checkpoint runs, if it sees a lock on WAL_READ_LOCK(N), then it must not move WAL content into the main database for more than the first read-mark[N] frames. Were it to do so, it would overwrite content that the process holding the lock was expecting to be able to read out of the main database file. A consequence of if this is that f the WAL file contains more than read-mark[N] frames (if mxFrame&amp;gt;read-mark[N] for any read-mark for which WAL_READ_LOCK(N) is held by another process), then the checkpoint cannot run to completion.</source>
          <target state="translated">当检查点运行时，如果看到WAL_READ_LOCK（N）上的锁，则它不得将WAL内容移入主数据库的时间超过最初的read-mark [N]帧。如果这样做，它将覆盖持有锁的进程希望能够从主数据库文件中读取的内容。如果这样的结果是：如果WAL文件包含多个读取标记[N]帧（如果mxFrame&amp;gt; read-mark [N]对于由另一个进程持有WAL_READ_LOCK（N）的任何读取标记），则检查点无法运行完成。</target>
        </trans-unit>
        <trans-unit id="483ce2f4112b751479cd3313b5725fa8eedbb3fc" translate="yes" xml:space="preserve">
          <source>When a configuration option is set, sqlite3_config() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">设置配置选项后，sqlite3_config（）返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果选项未知或SQLite无法设置选项，则此例程将返回非零&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42a829c41f1de7dff832e7bd4aea25619f81edf9" translate="yes" xml:space="preserve">
          <source>When a configuration option is set, sqlite3_config() returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">设置配置选项后，sqlite3_config（）返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果选项未知或SQLite无法设置选项，则此例程将返回非零&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ec6b6ac63fbc35d1df0b3e9fb9cdbeeef10333e" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a34b978574691e0c575f3f24ebbf266179b4d2f" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connections transaction.</source>
          <target state="translated">当连接（称为阻止的连接）无法获取共享缓存锁并且SQLITE_LOCKED返回给调用方时，已锁定所需资源的数据库连接（阻止的连接）的标识将存储在内部。应用程序收到SQLITE_LOCKED错误后，可以调用带有阻塞连接句柄的sqlite3_unlock_notify（）方法作为第一个参数来注册将在阻塞连接当前事务结束时调用的回调。从结束阻塞连接事务的&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;或&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt;调用中调用该回调。</target>
        </trans-unit>
        <trans-unit id="58820b450842a3b35138dd7706fb343d060de1de" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b71c21ec59e3320b31da28e6f5087ad7dce22a" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connections transaction.</source>
          <target state="translated">当连接（称为阻止的连接）无法获取共享缓存锁并且SQLITE_LOCKED返回给调用方时，已锁定所需资源的数据库连接（阻止的连接）的标识将存储在内部。应用程序收到SQLITE_LOCKED错误后，可以调用带有阻塞连接句柄的sqlite3_unlock_notify（）方法作为第一个参数来注册将在阻塞连接当前事务结束时调用的回调。从结束阻塞连接事务的&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;或&lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt;调用中调用该回调。</target>
        </trans-unit>
        <trans-unit id="2d95de74c44ccc79daba549c33cfe91ac9ee60b3" translate="yes" xml:space="preserve">
          <source>When a connection holds a shared lock on WAL_READ_LOCK(N), that is a promise by the connection that it will use the WAL and not the database file for any database pages that are modified by the first read-mark[N] entries in the WAL. The read-mark[0] is always zero. If a connection holds a shared lock on WAL_READ_LOCK(0), that means the connection expects to be able to ignore the WAL and read any content it wants from the main database. If N&amp;gt;0 then the connection is free to use more of the WAL file beyond read-mark[N] if it wants to, up to the first mxFrame frames. But when a connection holds a shared lock on WAL_READ_LOCK(0), that is a promise that it will never read content from the WAL and will acquire all content directly from the main database.</source>
          <target state="translated">当一个连接持有WAL_READ_LOCK（N）上的共享锁时，即由该连接保证，它将使用WAL而不是数据库文件中被第一个read-mark [N]条目修改的任何数据库页面的数据库文件。沃尔。读取标记[0]始终为零。如果连接持有WAL_READ_LOCK（0）上的共享锁，则意味着该连接希望能够忽略WAL并从主数据库中读取其想要的任何内容。如果N&amp;gt; 0，则连接可以自由使用WAL文件中的更多WAL文件（如果需要的话），最多可以读取前mxFrame帧。但是，当一个连接持有WAL_READ_LOCK（0）上的共享锁时，这将保证它永远不会从WAL中读取内容，并将直接从主数据库中获取所有内容。</target>
        </trans-unit>
        <trans-unit id="e114c32681a6d0ab6fee9545fa50582f6c054845" translate="yes" xml:space="preserve">
          <source>When a connection is holding a SHARED lock on the main database, that will prevent any other connection from acquiring the EXCLUSIVE lock, which in turn prevents the WAL-index and WAL files from being deleted out from under other users, and prevents a transition out of WAL-mode while other users are accessing the database in WAL-mode.</source>
          <target state="translated">当一个连接在主数据库上持有一个SHARED锁时,将阻止任何其他连接获得EXCLUSIVE锁,从而防止WAL-index和WAL文件从其他用户下删除,并防止其他用户在WAL模式下访问数据库时过渡出WAL模式。</target>
        </trans-unit>
        <trans-unit id="12c1255cc9a16f21fccefe2ac6a059ed783c7d20" translate="yes" xml:space="preserve">
          <source>When a connection using asynchronous IO begins a database transaction, the database is locked immediately. However the lock is not released until after all relevant operations in the write-queue have been flushed to disk. This means (for example) that the database may remain locked for some time after a &quot;&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;&quot; is issued.</source>
          <target state="translated">当使用异步IO的连接开始数据库事务时，数据库立即被锁定。但是，只有在写入队列中的所有相关操作都已刷新到磁盘之后，才会释放锁定。例如，这意味着在发出&amp;ldquo; &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; &amp;rdquo;或&amp;ldquo; &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; &amp;rdquo; 之后，数据库可能会保持锁定一段时间。</target>
        </trans-unit>
        <trans-unit id="ddb7b3f482852f424ece2e0896d73a04a9d957e4" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, an immediate ROLLBACK occurs, thus ending the current transaction, and the command aborts with a return code of SQLITE_CONSTRAINT. If no transaction is active (other than the implied transaction that is created on every command) then this algorithm works the same as ABORT.</source>
          <target state="translated">当发生约束违反时,会立即发生ROLLBACK,从而结束当前事务,命令以返回代码SQLITE_CONSTRAINT中止。如果没有活动的事务(除了在每个命令上创建的隐含事务外),那么这个算法的工作原理和ABORT一样。</target>
        </trans-unit>
        <trans-unit id="933e3d0ae1663c35b2ff70117a98cacf0e4923d6" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the command aborts with a return code SQLITE_CONSTRAINT. But any changes to the database that the command made prior to encountering the constraint violation are preserved and are not backed out. For example, if an UPDATE statement encountered a constraint violation on the 100th row that it attempts to update, then the first 99 row changes are preserved but change to rows 100 and beyond never occur.</source>
          <target state="translated">当发生约束违反时,命令会以返回代码SQLITE_CONSTRAINT中止。但命令在遇到约束违反之前对数据库所做的任何修改都会被保留,不会被回退。例如,如果一条UPDATE语句在它试图更新的第100行上遇到了约束违规,那么前99行的更改会被保留,但对100行及以后的更改永远不会发生。</target>
        </trans-unit>
        <trans-unit id="6397f8d4479c4b84e08676c10c54e0afd51f843f" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the command backs out any prior changes it might have made and aborts with a return code of SQLITE_CONSTRAINT. But no ROLLBACK is executed so changes from prior commands within the same transaction are preserved. This is the default behavior for SQLite.</source>
          <target state="translated">当发生违反约束的情况时,该命令会回退之前可能已经做的任何更改,并以SQLITE_CONSTRAINT的返回代码中止。但是没有执行ROLLBACK,所以同一事务中先前命令的更改会被保留下来。这是SQLite的默认行为。</target>
        </trans-unit>
        <trans-unit id="39dcfeb5298d9a69a9dfd10b897e4e703da8e46b" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the one row that contains the constraint violation is not inserted or changed. But the command continues executing normally. Other rows before and after the row that contained the constraint violation continue to be inserted or updated normally. No error is returned.</source>
          <target state="translated">当发生约束违规时,包含约束违规的一条记录不会被插入或更改。但是命令会继续正常执行。在包含违反约束的那条记录之前和之后的其他记录可以继续正常插入或更新。不返回任何错误。</target>
        </trans-unit>
        <trans-unit id="d77ac0a4b71596448d90ef0386a9797d90b3dad6" translate="yes" xml:space="preserve">
          <source>When a database connection closes (via &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; or &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;), an attempt is made to acquire SQLITE_LOCK_EXCLUSIVE. If this attempt is successful, that means the connection that is closing is the last connection to the database. In that case, it is desirable to clean up the WAL and WAL-index files, so the closing connection runs a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; (while holding SQLITE_LOCK_EXCLUSIVE) and the deletes both the WAL and WAL-index files. The SQLITE_LOCK_EXCLUSIVE is not released until after both the WAL and WAL-index files have been deleted.</source>
          <target state="translated">当数据库连接关闭时（通过&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;或&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2（）&lt;/a&gt;），将尝试获取SQLITE_LOCK_EXCLUSIVE。如果此尝试成功，则意味着正在关闭的连接是与数据库的最后一个连接。在那种情况下，最好清理WAL和WAL-index文件，因此关闭的连接运行一个&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;（在保持SQLITE_LOCK_EXCLUSIVE的同时），并删除WAL和WAL-index文件。在删除WAL和WAL索引文件之后，才释放SQLITE_LOCK_EXCLUSIVE。</target>
        </trans-unit>
        <trans-unit id="20a6ff534ce9652a9eda05b6d0935e6cf08856e6" translate="yes" xml:space="preserve">
          <source>When a directory is inserted, if the &quot;name&quot; value does not end with a '/' character, the zipfile module appends one. This is necessary for compatibility with other programs (most notably &quot;info-zip&quot;) that manipulate zip archives.</source>
          <target state="translated">当插入一个目录时,如果 &quot;name &quot;的值没有以'/'结尾,zipfile模块会附加一个字符。这对于与其他程序(最著名的是 &quot;info-zip&quot;)的兼容性是必要的,因为这些程序可以操作压缩文件。</target>
        </trans-unit>
        <trans-unit id="26801f7dad030d0d12374b8b8d55040830791b46" translate="yes" xml:space="preserve">
          <source>When a file-handle open on a database file is unlocked, if the</source>
          <target state="translated">当在数据库文件上打开的文件柄被解锁时,如果在数据库文件上的</target>
        </trans-unit>
        <trans-unit id="70b05b0c4ad89d4e7f94cf5e4dedf4b6997bc209" translate="yes" xml:space="preserve">
          <source>When a function uses a column from a virtual table as its first argument, this method is called to see if the virtual table would like to overload the function. The first three parameters are inputs: the virtual table, the number of arguments to the function, and the name of the function. If no overloading is desired, this method returns 0. To overload the function, this method writes the new function implementation into *pxFunc and writes user data into *ppArg and returns either 1 or a number between &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; and 255.</source>
          <target state="translated">当函数使用虚拟表中的列作为其第一个参数时，将调用此方法以查看虚拟表是否要重载该函数。前三个参数是输入：虚拟表，函数参数的数量和函数的名称。如果不需要重载，则此方法返回0。要重载该函数，此方法将新函数实现写入* pxFunc并将用户数据写入* ppArg，并返回1或&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;与255 之间的数字。</target>
        </trans-unit>
        <trans-unit id="8365620f1c717c4826d64a41ab8d38dd2fc7b98d" translate="yes" xml:space="preserve">
          <source>When a new</source>
          <target state="translated">当一个新的</target>
        </trans-unit>
        <trans-unit id="699fe2196c054a2761ad370d04849c2f40137718" translate="yes" xml:space="preserve">
          <source>When a new database is created, SQLite assigns a page size to the database based on platform and filesystem. For many years, the default page size was almost always 1024 bytes, but beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; (2016-03-29), the default page size increased to 4096. The default page size is recommended for most applications.</source>
          <target state="translated">创建新数据库时，SQLite将基于平台和文件系统为数据库分配页面大小。多年来，默认页面大小几乎总是1024字节，但是从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;版本3.12.0&lt;/a&gt;（2016-03-29）开始，默认页面大小增加到4096。对于大多数应用程序，建议使用默认页面大小。</target>
        </trans-unit>
        <trans-unit id="45fd9923f092fbfb6768ecc3efe603fb1851939b" translate="yes" xml:space="preserve">
          <source>When a new database page is appended to a database file, there is no requirement to add a record to the</source>
          <target state="translated">当一个新的数据库页面被添加到数据库文件中时,不需要在数据库文件中添加记录。</target>
        </trans-unit>
        <trans-unit id="b08473c5ea155814010ebff8331980504b3653e4" translate="yes" xml:space="preserve">
          <source>When a new file is created, most desktop operating systems (Windows, Linux, Mac OS X) will not actually write anything to disk. The new file is created in the operating systems disk cache only. The file is not created on mass storage until sometime later, when the operating system has a spare moment. This creates the impression to users that I/O is happening much faster than is possible when doing real disk I/O. We illustrate this idea in the diagram to the right by showing that the new rollback journal appears in the operating system disk cache only and not on the disk itself.</source>
          <target state="translated">当创建一个新文件时,大多数桌面操作系统(Windows、Linux、Mac OS X)实际上不会向磁盘写入任何东西。新文件只在操作系统的磁盘缓存中创建。直到一段时间后,当操作系统有空闲的时候,才会在大容量存储上创建文件。这给用户造成的印象是,I/O发生的速度比真正进行磁盘I/O时快得多。我们在右图中通过显示新的回滚日志只出现在操作系统磁盘缓存中,而不是在磁盘本身上来说明这个想法。</target>
        </trans-unit>
        <trans-unit id="0a07f6d8079bf577cb3fe5588a8b9770dc9fc5d1" translate="yes" xml:space="preserve">
          <source>When a new row is inserted into an SQLite table, the ROWID can either be specified as part of the INSERT statement or it can be assigned automatically by the database engine. To specify a ROWID manually, just include it in the list of values to be inserted. For example:</source>
          <target state="translated">当一条新的记录被插入到一个SQLite表中时,ROWID可以作为INSERT语句的一部分被指定,也可以由数据库引擎自动分配。要手动指定一个ROWID,只需将其包含在要插入的值列表中即可。例如</target>
        </trans-unit>
        <trans-unit id="0f0ce235c557e884c10fe9cff8d86b46112c91c8" translate="yes" xml:space="preserve">
          <source>When a process wants to change a database file (and it is not in &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode), it first records the original unchanged database content in a &lt;em&gt;rollback journal&lt;/em&gt;. The rollback journal is an ordinary disk file that is always located in the same directory or folder as the database file and has the same name as the database file with the addition of a &lt;code&gt;-journal&lt;/code&gt; suffix. The rollback journal also records the initial size of the database so that if the database file grows it can be truncated back to its original size on a rollback.</source>
          <target state="translated">当进程想要更改数据库文件（并且它不在&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;模式下）时，它首先将原始未更改的数据库内容记录在&lt;em&gt;回滚日志中&lt;/em&gt;。回滚日志是普通磁盘文件，始终与数据库文件位于同一目录或文件夹中，并具有与数据库文件相同的名称，并带有 &lt;code&gt;-journal&lt;/code&gt; 后缀。回滚日志还记录了数据库的初始大小，因此，如果数据库文件增长，则可以在回滚时将其截断为原始大小。</target>
        </trans-unit>
        <trans-unit id="4bd80d03aa6d2b960c4978ddc8751bef460c3fb0" translate="yes" xml:space="preserve">
          <source>When a process wants to read from a database file, it followed the following sequence of steps:</source>
          <target state="translated">当一个进程想从数据库文件中读取数据时,它遵循以下一系列步骤。</target>
        </trans-unit>
        <trans-unit id="577306227dff9ce8975b3fcaaa51b9a6b5656983" translate="yes" xml:space="preserve">
          <source>When a read operation begins on a WAL-mode database, it first remembers the location of the last valid commit record in the WAL. Call this point the &quot;end mark&quot;. Because the WAL can be growing and adding new commit records while various readers connect to the database, each reader can potentially have its own end mark. But for any particular reader, the end mark is unchanged for the duration of the transaction, thus ensuring that a single read transaction only sees the database content as it existed at a single point in time.</source>
          <target state="translated">当对WAL模式的数据库开始读取操作时,首先会记住WAL中最后一条有效提交记录的位置。把这个点称为 &quot;结束标记&quot;。由于WAL在不同的读者连接到数据库的时候,WAL会不断地增长和增加新的提交记录,所以每个读者都有可能拥有自己的结束标记。但对于任何一个特定的读者来说,在事务的持续时间内,结束标记都是不变的,从而保证了单次读取事务只看到数据库内容在单一时间点上存在的样子。</target>
        </trans-unit>
        <trans-unit id="6c0dd2ac1af5d6880101af98898ac515a0c331fe" translate="yes" xml:space="preserve">
          <source>When a reader needs a page of content, it first checks the WAL to see if that page appears there, and if so it pulls in the last copy of the page that occurs in the WAL prior to the reader's end mark. If no copy of the page exists in the WAL prior to the reader's end mark, then the page is read from the original database file. Readers can exist in separate processes, so to avoid forcing every reader to scan the entire WAL looking for pages (the WAL file can grow to multiple megabytes, depending on how often checkpoints are run), a data structure called the &quot;wal-index&quot; is maintained in shared memory which helps readers locate pages in the WAL quickly and with a minimum of I/O. The wal-index greatly improves the performance of readers, but the use of shared memory means that all readers must exist on the same machine. This is why the write-ahead log implementation will not work on a network filesystem.</source>
          <target state="translated">当读者需要某页内容时,它首先检查WAL,看该页是否出现在那里,如果出现,它就会拉入WAL中在读者结束标记之前出现的最后一个页面副本。如果在读取器结束标记之前,WAL中没有该页的副本存在,那么就从原始数据库文件中读取该页。读取器可以存在于单独的进程中,因此为了避免强迫每个读取器扫描整个WAL寻找页面(WAL文件可能会增长到多兆字节,这取决于运行检查点的频率),在共享内存中维护了一个称为 &quot;wal-index &quot;的数据结构,它可以帮助读取器以最少的I/O快速定位WAL中的页面。wal-index极大地提高了阅读器的性能,但共享内存的使用意味着所有阅读器必须存在于同一台机器上。这就是为什么写前日志的实现不能在网络文件系统上工作的原因。</target>
        </trans-unit>
        <trans-unit id="730f5bd701321fbbb693ce5b184d905999894efe" translate="yes" xml:space="preserve">
          <source>When a row is deleted from an external content FTS4 table, FTS4 needs to retrieve the column values of the row being deleted from the content table. This is so that FTS4 can update the full-text index entries for each token that occurs within the deleted row to indicate that row has been deleted. If the content table row cannot be found, or if it contains values inconsistent with the contents of the FTS index, the results can be difficult to predict. The FTS index may be left containing entries corresponding to the deleted row, which can lead to seemingly nonsensical results being returned by subsequent SELECT queries. The same applies when a row is updated, as internally an UPDATE is the same as a DELETE followed by an INSERT.</source>
          <target state="translated">当从外部内容FTS4表中删除一行时,FTS4需要从内容表中检索被删除行的列值。这样,FTS4才能更新被删除行内出现的每个标记的全文索引条目,以表明该行已被删除。如果找不到内容表行,或者它所包含的值与FTS索引的内容不一致,结果就很难预测。FTS索引可能会留下与被删除的行相对应的条目,这可能会导致后续的SELECT查询返回看似无意义的结果。同样的情况也适用于更新行的时候,因为在内部,UPDATE和DELETE之后的INSERT是一样的。</target>
        </trans-unit>
        <trans-unit id="c5bdbf38f9947ad2a93dddd10975fb895dc64e45" translate="yes" xml:space="preserve">
          <source>When a schema change occurs that requires a prepared statement to be reparsed and reprepared, that event is logged with the error code SQLITE_SCHEMA. The reparse and reprepare is normally automatic (assuming that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; has been used to prepared the statements originally, which is recommended) and so these logging events are normally the only way to know that reprepares are taking place.</source>
          <target state="translated">当发生架构更改而需要重新准备和重新准备一条准备好的语句时，该事件将记录为错误代码SQLITE_SCHEMA。 reparse和reprepare通常是自动的（假定最初使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;来准备语句，建议这样做），因此这些日志记录事件通常是知道正在进行重新准备的唯一方法。</target>
        </trans-unit>
        <trans-unit id="19333c5294fb7ef73ead50d971608427e5e277b4" translate="yes" xml:space="preserve">
          <source>When a search request occurs and pending documents are indexed for the first time, the ftsdocs table must be updated by setting the idxed column to true and also filling in several other columns with information pertinent to the search. That other information is obtained from a join. The query is this:</source>
          <target state="translated">当搜索请求发生,待处理文件第一次被编入索引时,必须更新ftsdocs表,将idxed列设置为true,并在其他几列中填写与搜索有关的信息。这其他信息是从联接中获得的。查询的内容是这样的。</target>
        </trans-unit>
        <trans-unit id="5a34c7922c5247a2a858115497a487644ed495d8" translate="yes" xml:space="preserve">
          <source>When a session object is disabled (see the &lt;a href=&quot;#sqlite3session_enable&quot;&gt;sqlite3session_enable()&lt;/a&gt; API), it does not accumulate records when rows are inserted, updated or deleted. This may appear to have some counter-intuitive effects if a single row is written to more than once during a session. For example, if a row is inserted while a session object is enabled, then later deleted while the same session object is disabled, no INSERT record will appear in the changeset, even though the delete took place while the session was disabled. Or, if one field of a row is updated while a session is disabled, and another field of the same row is updated while the session is enabled, the resulting changeset will contain an UPDATE change that updates both fields.</source>
          <target state="translated">禁用会话对象时（请参见&lt;a href=&quot;#sqlite3session_enable&quot;&gt;sqlite3session_enable（）&lt;/a&gt; API），当插入，更新或删除行时，该对象不会累积记录。如果在会话期间多次写入单个行，这可能会产生一些违反直觉的效果。例如，如果在启用会话对象的同时插入一行，然后在禁用同一会话对象的情况下删除该行，则即使删除是在禁用会话的情况下进行的，更改集也不会出现INSERT记录。或者，如果在禁用会话的同时更新了一行的一个字段，而在启用会话的同时更新了同一行的另一个字段，则结果更改集将包含一个更新两个字段的UPDATE更改。</target>
        </trans-unit>
        <trans-unit id="4f45d6d9d609e68af4097ec8d881bf58ab9f2d1b" translate="yes" xml:space="preserve">
          <source>When a session object is disabled (see the &lt;a href=&quot;sqlite3session_enable&quot;&gt;sqlite3session_enable()&lt;/a&gt; API), it does not accumulate records when rows are inserted, updated or deleted. This may appear to have some counter-intuitive effects if a single row is written to more than once during a session. For example, if a row is inserted while a session object is enabled, then later deleted while the same session object is disabled, no INSERT record will appear in the changeset, even though the delete took place while the session was disabled. Or, if one field of a row is updated while a session is disabled, and another field of the same row is updated while the session is enabled, the resulting changeset will contain an UPDATE change that updates both fields.</source>
          <target state="translated">禁用会话对象时（请参见&lt;a href=&quot;sqlite3session_enable&quot;&gt;sqlite3session_enable（）&lt;/a&gt; API），当插入，更新或删除行时，该对象不会累积记录。如果在会话期间多次写入单个行，这可能会产生一些违反直觉的效果。例如，如果在启用会话对象的同时插入一行，然后在禁用同一会话对象的情况下删除该行，则即使删除是在禁用会话的情况下进行的，更改集也不会出现INSERT记录。或者，如果在禁用会话的同时更新了一行的一个字段，而在启用会话的同时更新了同一行的另一个字段，则结果更改集将包含一个更新两个字段的UPDATE更改。</target>
        </trans-unit>
        <trans-unit id="0c5e9130632720140f5680108f22eb0b1e949a18" translate="yes" xml:space="preserve">
          <source>When a string containing SQL statements is to be evaluated it is first sent to the tokenizer. The tokenizer breaks the SQL text into tokens and hands those tokens one by one to the parser. The tokenizer is hand-coded in the file</source>
          <target state="translated">当一个包含SQL语句的字符串要被评估时,首先会被发送到tokenizer。tokenizer将SQL文本分解成标记,并将这些标记一个一个地交给解析器。记号器在文件中手工编码。</target>
        </trans-unit>
        <trans-unit id="784cd84ee25201af9adae4be302f69e70ce7fa77" translate="yes" xml:space="preserve">
          <source>When a subquery is implemented as a co-routine, byte-code is generated to implement the subquery as if it were a standalone query, except instead of returning rows of results back to the application, the co-routine yields control back to the caller after each row is computed. The caller can then use that one computed row as part of its computation, then invoke the co-routine again when it is ready for the next row.</source>
          <target state="translated">当一个子查询被实现为共例程时,会生成字节代码来实现子查询,就像它是一个独立的查询一样,只是共例程不是将结果行返回给应用程序,而是在计算完每一行后将控制权交还给调用者。然后,调用者可以使用这一条计算行作为其计算的一部分,然后当它准备好下一条行时,再次调用该协程序。</target>
        </trans-unit>
        <trans-unit id="de44a27c9eba79e888eaebdda88d807698edb9ba" translate="yes" xml:space="preserve">
          <source>When a subquery occurs in the FROM clause of a SELECT, the simplest behavior is to evaluate the subquery into a transient table, then run the outer SELECT against the transient table. But such a plan can be suboptimal since the transient table will not have any indices and the outer query (which is likely a join) will be forced to do a full table scan on the transient table.</source>
          <target state="translated">当一个子查询发生在一个SELECT的FROM子句中时,最简单的行为是将子查询评估到一个瞬时表中,然后针对瞬时表运行外部SELECT。但这样的计划可能是次优的,因为瞬时表不会有任何索引,而外部查询(很可能是连接)将被迫对瞬时表进行全表扫描。</target>
        </trans-unit>
        <trans-unit id="e127ffb4e1dc5538bc1d8c98212bc64075d04dc4" translate="yes" xml:space="preserve">
          <source>When a users query on the FTS table requires a column value other than docid, FTS attempts to read the requested value from the corresponding column of the row in the content table with a rowid value equal to the current FTS docid. Only the subset of content-table columns duplicated in the FTS/34 table declaration can be queried for - to retrieve values from any other columns the content table must be queried directly. Or, if such a row cannot be found in the content table, a NULL value is used instead. For example:</source>
          <target state="translated">当用户在FTS表上查询需要docid以外的列值时,FTS会尝试从内容表中行的相应列中读取所要求的值,该列的rowid值等于当前FTS的docid。只有在FTS/34表声明中重复的内容表列子集可以被查询--要从任何其他列中检索值,必须直接查询内容表。或者,如果在内容表中找不到这样的行,则使用NULL值代替。例如:</target>
        </trans-unit>
        <trans-unit id="923cfb28292cf33d9bcc64415e1180bd974cc8fa" translate="yes" xml:space="preserve">
          <source>When a writer is ready to commit its changes, it executes the following steps:</source>
          <target state="translated">当作者准备好提交其更改时,它会执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="90c74b5a55e525d529484d187152a575e9bdd449" translate="yes" xml:space="preserve">
          <source>When a writer wants to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt;, it must ensure that there are no locks on WAL_READ_LOCK(N) for N&amp;gt;0 because such locks indicate that some other connection is still using the current WAL file and a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; would delete content out from those other connections. It is ok for a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; to occur if other connections are holding WAL_READ_LOCK(0) because by holding WAL_READ_LOCK(0), those other connections are promising not to use any content from the WAL.</source>
          <target state="translated">当编写者想要&lt;a href=&quot;fileformat2#walreset&quot;&gt;重置WAL时&lt;/a&gt;，它必须确保WAL_READ_LOCK（N）上没有N&amp;gt; 0的锁定，因为此类锁定表明某些其他连接仍在使用当前WAL文件，并且&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL重置&lt;/a&gt;将从其中删除内容其他联系。如果其他连接保持WAL_READ_LOCK（0），则可以进行&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL重置&lt;/a&gt;，因为通过保持WAL_READ_LOCK（0），其他连接将保证不使用WAL中的任何内容。</target>
        </trans-unit>
        <trans-unit id="7d5748b3589eba141bc319d180f2ba5724a213ca" translate="yes" xml:space="preserve">
          <source>When all of the recommended compile-time options above are used, the SQLite library will be approximately 3% smaller and use about 5% fewer CPU cycles. So these options do not make a huge difference. But in some design situations, every little bit helps.</source>
          <target state="translated">当以上推荐的编译时选项都被使用时,SQLite库将缩小约3%,使用的CPU周期减少约5%。所以这些选项并不会产生巨大的差异。但在某些设计情况下,每一点都有帮助。</target>
        </trans-unit>
        <trans-unit id="07429870ba57300bd363c85117e03fbff3fb9b62" translate="yes" xml:space="preserve">
          <source>When all processing is complete, &lt;b&gt;sqlite_step&lt;/b&gt; will return either SQLITE_DONE or SQLITE_ERROR. SQLITE_DONE indicates that the statement completed successfully and SQLITE_ERROR indicates that there was a run-time error. (The details of the error are obtained from &lt;b&gt;sqlite_finalize&lt;/b&gt;.) It is a misuse of the library to attempt to call &lt;b&gt;sqlite_step&lt;/b&gt; again after it has returned SQLITE_DONE or SQLITE_ERROR.</source>
          <target state="translated">完成所有处理后，&lt;b&gt;sqlite_step&lt;/b&gt;将返回SQLITE_DONE或SQLITE_ERROR。 SQLITE_DONE指示语句成功完成，SQLITE_ERROR指示存在运行时错误。 （错误的细节，从获得&lt;b&gt;sqlite_finalize&lt;/b&gt;）。它是图书馆的滥用尝试调用&lt;b&gt;sqlite_step&lt;/b&gt;它再次返回SQLITE_DONE或SQLITE_ERROR之后。</target>
        </trans-unit>
        <trans-unit id="9464a70b807f00dabcb5c4da75acd44d0a619fea" translate="yes" xml:space="preserve">
          <source>When all the INSERTs are put in a transaction, SQLite no longer has to close and reopen the database or invalidate its cache between each statement. It also does not have to do any fsync()s until the very end. When unshackled in this way, SQLite is much faster than either PostgreSQL and MySQL.</source>
          <target state="translated">当所有的INSERT都放在一个事务中时,SQLite不再需要在每条语句之间关闭和重新打开数据库或使其缓存无效。它也不需要做任何fsync(),直到最后。当以这种方式解锁时,SQLite比PostgreSQL和MySQL都要快得多。</target>
        </trans-unit>
        <trans-unit id="83a11d4701cb9320d2bf4587af27d26604be7f83" translate="yes" xml:space="preserve">
          <source>When an FTS table accumulates 16 b-tree segments at the same level, the next INSERT into that table will cause all 16 segments to be merged into a single b-tree segment at the next higher level. The effect of these level merges is that most INSERTs into an FTS table are very fast and take minimal memory, but an occasional INSERT is slow and generates a large transaction because of the need to do merging. This results in &quot;spiky&quot; performance of INSERTs.</source>
          <target state="translated">当一个FTS表在同一级别上积累了16个b树段时,下一次对该表的INSERT将导致所有16个段在下一个更高的级别上合并成一个b树段。这些级别合并的效果是,大多数对FTS表的INSERT速度非常快,占用的内存最小,但偶尔的INSERT速度很慢,而且由于需要进行合并,会产生一个大的事务。这就造成了INSERT的 &quot;尖峰 &quot;性能。</target>
        </trans-unit>
        <trans-unit id="c3b65790b6c542323caaa50e227caf3d370e16fb" translate="yes" xml:space="preserve">
          <source>When an FTS5 table uses the custom tokenizer, the FTS5 core calls xCreate() once to create a tokenizer, then xTokenize() zero or more times to tokenize strings, then xDelete() to free any resources allocated by xCreate(). More specifically:</source>
          <target state="translated">当FTS5表使用自定义标记器时,FTS5内核调用xCreate()一次来创建标记器,然后调用xTokenize()零次或多次来标记字符串,然后调用xDelete()来释放xCreate()分配的任何资源。更具体地说。</target>
        </trans-unit>
        <trans-unit id="09202e860e734da0abbd632a5204a2fbedb299ae" translate="yes" xml:space="preserve">
          <source>When an FTS5 virtual table is created in a database, between 3 and 5 real tables are created in the database. These are known as &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;, and are used by the virtual table module to store persistent data. They should not be accessed directly by the user. Many other virtual table modules, including &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt;, also create and use shadow tables.</source>
          <target state="translated">在数据库中创建FTS5虚拟表时，将在数据库中创建3到5个真实表。这些被称为&amp;ldquo; &lt;a href=&quot;vtab#xshadowname&quot;&gt;影子表&lt;/a&gt; &amp;rdquo;，由虚拟表模块用于存储持久性数据。用户不应直接访问它们。许多其他虚拟表模块，包括&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;和&lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt;，也可以创建和使用影子表。</target>
        </trans-unit>
        <trans-unit id="8a38c7dc316e7e37718537bdea61961f91a6e323" translate="yes" xml:space="preserve">
          <source>When an SQL program is submitted to SQLite, the first step is to split the source text into &quot;tokens&quot;. A token might be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b898f19b28eed6509a35351ba88f244733f8458f" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the ABORT resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and backs out any changes made by the current SQL statement; but changes caused by prior SQL statements within the same transaction are preserved and the transaction remains active. This is the default behavior and the behavior specified by the SQL standard.</source>
          <target state="translated">当发生适用的约束违反时,ABORT解析算法会以SQLITE_CONSTRAINT错误中止当前SQL语句,并回退当前SQL语句所做的任何更改;但同一事务中先前的SQL语句引起的更改会被保留,事务仍然处于活动状态。这是默认行为,也是SQL标准指定的行为。</target>
        </trans-unit>
        <trans-unit id="58bad3c331711aff15946bd280d303d43eef796f" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the FAIL resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error. But the FAIL resolution does not back out prior changes of the SQL statement that failed nor does it end the transaction. For example, if an UPDATE statement encountered a constraint violation on the 100th row that it attempts to update, then the first 99 row changes are preserved but changes to rows 100 and beyond never occur.</source>
          <target state="translated">当发生适用的约束违反时,FAIL解析算法会以SQLITE_CONSTRAINT错误中止当前的SQL语句。但是FAIL解析并不会回退失败的SQL语句之前的修改,也不会结束事务。例如,如果一条UPDATE语句在它试图更新的第100行遇到了约束违规,那么前99行的更改会被保留,但第100行及以后的更改永远不会发生。</target>
        </trans-unit>
        <trans-unit id="1b4aa81c65115bc42996b729bd361c5c8fafeff0" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the IGNORE resolution algorithm skips the one row that contains the constraint violation and continues processing subsequent rows of the SQL statement as if nothing went wrong. Other rows before and after the row that contained the constraint violation are inserted or updated normally. No error is returned for uniqueness, NOT NULL, and UNIQUE constraint errors when the IGNORE conflict resolution algorithm is used. However, the IGNORE conflict resolution algorithm works like ABORT for &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; errors.</source>
          <target state="translated">当发生适用的约束违例时，IGNORE解析算法将跳过包含约束违例的一行，并继续处理SQL语句的后续行，就好像什么都没出错。包含约束违例的行之前和之后的其他行将正常插入或更新。使用IGNORE冲突解决算法时，不针对唯一性，NOT NULL和UNIQUE约束错误返回任何错误。但是，对于&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;错误，IGNORE冲突解决算法的工作方式类似于ABORT 。</target>
        </trans-unit>
        <trans-unit id="a5ad08c0ccf1a58d1c588bdc448e26465adfe8be" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the ROLLBACK resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and rolls back the current transaction. If no transaction is active (other than the implied transaction that is created on every command) then the ROLLBACK resolution algorithm works the same as the ABORT algorithm.</source>
          <target state="translated">当发生适用的约束违反时,ROLLBACK解析算法会以SQLITE_CONSTRAINT错误中止当前SQL语句,并回滚当前事务。如果没有活动的事务(除了在每条命令上创建的隐含事务外),那么ROLLBACK解析算法的工作原理与ABORT算法相同。</target>
        </trans-unit>
        <trans-unit id="df9a570011a02f30ad10c7c02dfbae7f79c1d8bc" translate="yes" xml:space="preserve">
          <source>When an attempt is made to read the 100 byte</source>
          <target state="translated">当试图读取100个字节的</target>
        </trans-unit>
        <trans-unit id="e571fd87d73f16df54e68558314d212f85e9756b" translate="yes" xml:space="preserve">
          <source>When an error occurs, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will return one of the detailed &lt;a href=&quot;rescode&quot;&gt;error codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. The legacy behavior was that &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; would only return a generic &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; result code and the application would have to make a second call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; in order to find the underlying cause of the problem. With the &quot;v2&quot; prepare interfaces, the underlying reason for the error is returned immediately.</source>
          <target state="translated">发生错误时，&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;将返回详细的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展的错误代码之一&lt;/a&gt;。传统行为是&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;仅返回通用&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;结果代码，并且应用程序必须再次调用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;才能找到问题的根本原因。使用&amp;ldquo; v2&amp;rdquo; prepare接口，立即返回错误的根本原因。</target>
        </trans-unit>
        <trans-unit id="ccab92f3619cb54ee4858ee94848a4ee81189c29" translate="yes" xml:space="preserve">
          <source>When an error occurs, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will return one of the detailed &lt;a href=&quot;../rescode&quot;&gt;error codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. The legacy behavior was that &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; would only return a generic &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; result code and the application would have to make a second call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; in order to find the underlying cause of the problem. With the &quot;v2&quot; prepare interfaces, the underlying reason for the error is returned immediately.</source>
          <target state="translated">发生错误时，&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;将返回详细的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展的错误代码之一&lt;/a&gt;。传统行为是&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;仅返回通用&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;结果代码，并且应用程序必须再次调用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;才能找到问题的根本原因。使用&amp;ldquo; v2&amp;rdquo; prepare接口，立即返回错误的根本原因。</target>
        </trans-unit>
        <trans-unit id="5d56e138a3f9cc682aa13f997335180c0fb3034f" translate="yes" xml:space="preserve">
          <source>When an expression is a simple reference to a column of a real table (not a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or subquery) then the expression has the same affinity as the table column.</source>
          <target state="translated">当表达式是对实际表的列（而不是&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;或子查询）的简单引用时，则表达式具有与表列相同的相似性。</target>
        </trans-unit>
        <trans-unit id="6e0bc34d56cd507e6524dea6d88364c2053501fb" translate="yes" xml:space="preserve">
          <source>When an in-memory database is named in this way, it will only share its cache with another connection that uses exactly the same name.</source>
          <target state="translated">当一个内存数据库以这种方式命名时,它将只与另一个使用完全相同名称的连接共享其缓存。</target>
        </trans-unit>
        <trans-unit id="a4bc24ec2391f7a4a80ebd40d7eacec7ec5836a6" translate="yes" xml:space="preserve">
          <source>When an index contains all of the data needed for a query and when the original table never needs to be consulted, we call that index a &quot;covering index&quot;.</source>
          <target state="translated">当一个索引包含了查询所需的所有数据,而原始表永远不需要被查询时,我们把这个索引称为 &quot;覆盖索引&quot;。</target>
        </trans-unit>
        <trans-unit id="82ebd13a345482eaf43922980ab28662ac5f3021" translate="yes" xml:space="preserve">
          <source>When an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked. However, the signature of the callback function allows SQLite to pass it an array of void* context pointers. The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array.</source>
          <target state="translated">当注册了一个解锁通知回调时,应用程序提供了一个单一的void*指针,当它被调用时,会传递给回调函数。然而,回调函数的签名允许SQLite将一个void*上下文指针数组传递给它。传递给解锁-通知回调的第一个参数是指向一个void*指针数组的指针,第二个参数是数组中的条目数。</target>
        </trans-unit>
        <trans-unit id="52b75d8996a29266548750270878024301ed32e8" translate="yes" xml:space="preserve">
          <source>When attempting to open a file, the SQLITE_NOTADB error indicates that the file being opened does not appear to be an SQLite database file.</source>
          <target state="translated">当试图打开一个文件时,SQLITE_NOTADB错误表示正在打开的文件似乎不是一个SQLite数据库文件。</target>
        </trans-unit>
        <trans-unit id="9105d0e8a7ab7b349bd2fbe878c8275b8882d52a" translate="yes" xml:space="preserve">
          <source>When both the SQLite core and the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt; (CLI) are both compiled with this option, then the CLI provides an extra command named &quot;.iotrace&quot; that provides a low-level log of I/O activity. This option is experimental and may be discontinued in a future release.</source>
          <target state="translated">当同时使用此选项编译SQLite核心和&lt;a href=&quot;cli&quot;&gt;命令行界面&lt;/a&gt;（CLI）时，CLI将提供一个名为&amp;ldquo; .iotrace&amp;rdquo;的额外命令，该命令可提供I / O活动的低级日志。此选项是试验性的，在将来的版本中可能会停止使用。</target>
        </trans-unit>
        <trans-unit id="36f9015046bd06c8d94d98831683d6a650fd53ca" translate="yes" xml:space="preserve">
          <source>When building the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;, it is helpful, but not required, to have the following third-party libraries on hand:</source>
          <target state="translated">构建&lt;a href=&quot;cli&quot;&gt;CLI时&lt;/a&gt;，手头准备以下第三方库很有帮助，但不是必需的：</target>
        </trans-unit>
        <trans-unit id="ba9eeb759b581addc9af410a4bf9f2616522ac5b" translate="yes" xml:space="preserve">
          <source>When building with MSVC on Windows systems, one can put the zlib source code in the compat/zlib subdirectory of the source tree and then add the USE_ZLIB=1 option to the nmake command to cause the The Makefile.msc to automatically build and use an appropriate zlib library implementation.</source>
          <target state="translated">在 Windows 系统上使用 MSVC 构建时,可以将 zlib 源代码放在源代码树的 compat/zlib 子目录中,然后在 nmake 命令中添加 USE_ZLIB=1 选项,以使 The Makefile.msc 自动构建并使用适当的 zlib 库实现。</target>
        </trans-unit>
        <trans-unit id="e30f7cd9c75ce2c6c161c9108a391a6b6c55986e" translate="yes" xml:space="preserve">
          <source>When casting a BLOB value to INTEGER, the value is first converted to TEXT.</source>
          <target state="translated">当将BLOB值转换为INTEGER时,首先要将该值转换为TEXT。</target>
        </trans-unit>
        <trans-unit id="5c0c597294629f9542feb4df0871368a01531b6a" translate="yes" xml:space="preserve">
          <source>When casting a BLOB value to a REAL, the value is first converted to TEXT.</source>
          <target state="translated">当把一个BLOB值转换为REAL时,首先要把该值转换为TEXT。</target>
        </trans-unit>
        <trans-unit id="5067d93cc1cb86aa6af9bcf672584d0b1585ff55" translate="yes" xml:space="preserve">
          <source>When casting a TEXT value to INTEGER, the longest possible prefix of the value that can be interpreted as an integer number is extracted from the TEXT value and the remainder ignored. Any leading spaces in the TEXT value when converting from TEXT to INTEGER are ignored. If there is no prefix that can be interpreted as an integer number, the result of the conversion is 0. If the prefix integer is greater than +9223372036854775807 then the result of the cast is exactly +9223372036854775807. Similarly, if the prefix integer is less than -9223372036854775808 then the result of the cast is exactly -9223372036854775808.</source>
          <target state="translated">当把一个TEXT值转换为INTEGER时,从TEXT值中提取可以解释为整数的值的最长前缀,其余部分被忽略。当从TEXT转换为INTEGER时,TEXT值中的任何前导空格都会被忽略。如果没有可以解释为整数的前缀,那么转换的结果就是0,如果前缀整数大于+9223372036854775807,那么投掷的结果正好是+9223372036854775807。同理,如果前缀整数小于-9223372036854775808,那么投掷的结果正好是-9223372036854775808。</target>
        </trans-unit>
        <trans-unit id="65da0fa3bb91d9ed81f980bbc2df26063662f53c" translate="yes" xml:space="preserve">
          <source>When casting a TEXT value to REAL, the longest possible prefix of the value that can be interpreted as a real number is extracted from the TEXT value and the remainder ignored. Any leading spaces in the TEXT value are ignored when converging from TEXT to REAL. If there is no prefix that can be interpreted as a real number, the result of the conversion is 0.0.</source>
          <target state="translated">当将TEXT值转换为REAL时,从TEXT值中提取出可以解释为实数的最长前缀,其余部分被忽略。当从TEXT值转换为REAL时,TEXT值中的任何前导空格都会被忽略。如果没有可以解释为实数的前缀,转换的结果是0.0。</target>
        </trans-unit>
        <trans-unit id="46e82821742f6cd2f96bd6126debacd8be0bdcfb" translate="yes" xml:space="preserve">
          <source>When casting to INTEGER, if the text looks like a floating point value with an exponent, the exponent will be ignored because it is no part of the integer prefix. For example, &quot;(CAST '123e+5' AS INTEGER)&quot; results in 123, not in 12300000.</source>
          <target state="translated">当转换为INTEGER时,如果文本看起来像一个带指数的浮点值,指数将被忽略,因为它不是整数前缀的一部分。例如,&quot;(CAST '123e+5' AS INTEGER)&quot;的结果是123,而不是12300000。</target>
        </trans-unit>
        <trans-unit id="39d5e03e61b6bf8d9e7be24acbf923224eccdb8e" translate="yes" xml:space="preserve">
          <source>When checking for the WHERE-clause push-down optimization, verify that all terms of the compound inner SELECT are non-aggregate, not just the last term. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f7f8c97e97597&quot;&gt;f7f8c97e97597&lt;/a&gt;.</source>
          <target state="translated">在检查WHERE子句下推优化时，请确认复合内部SELECT的所有项都是非聚合的，而不仅仅是最后一项。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/f7f8c97e97597&quot;&gt;f7f8c97e97597&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95988d2f9a83f35536e66d62cf26515907b72996" translate="yes" xml:space="preserve">
          <source>When compared with SQLite's built-in VACUUM command, RBU Vacuum has the following limitations:</source>
          <target state="translated">与SQLite内置的VACUUM命令相比,RBU真空有以下限制。</target>
        </trans-unit>
        <trans-unit id="71ec8021f2a78c2f5787e61e104c092e2cf0b2cc" translate="yes" xml:space="preserve">
          <source>When comparing a base expression against a WHEN expression, the same collating sequence, affinity, and NULL-handling rules apply as if the base expression and WHEN expression are respectively the left- and right-hand operands of an</source>
          <target state="translated">当比较一个基础表达式和一个WHEN表达式时,同样的整理序列、亲和力和NULL处理规则适用于基础表达式和WHEN表达式,就像基础表达式和WHEN表达式分别是左手和右手操作数一样。</target>
        </trans-unit>
        <trans-unit id="8a8e8bf765d052cbbdbda4e8360051200aec0343" translate="yes" xml:space="preserve">
          <source>When comparing text values, the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; associated with the parent key column is always used.</source>
          <target state="translated">比较文本值时，始终使用与父键列关联的&lt;a href=&quot;datatype3#collation&quot;&gt;整理顺序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8bd6464f68b9918a029c67f18300aa6bddf2bf88" translate="yes" xml:space="preserve">
          <source>When comparing values, if the parent key column has an &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt;, then that affinity is applied to the child key value before the comparison is performed.</source>
          <target state="translated">比较值时，如果父键列具有&lt;a href=&quot;datatype3#affinity&quot;&gt;亲和力&lt;/a&gt;，则在执行比较之前，该亲和力将应用于子键值。</target>
        </trans-unit>
        <trans-unit id="8a8c1f258ce77d3b0b1a04487b470e53840cc8d0" translate="yes" xml:space="preserve">
          <source>When compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;, SQLite includes routines that will print out various internal parse tree structures as ASCII-art graphs. This can be very useful in a debugging in order to understand the variables that SQLite is working with.</source>
          <target state="translated">当使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG进行&lt;/a&gt;编译时，SQLite包含的例程将以ASCII图形形式打印出各种内部解析树结构。这在调试中非常有用，以了解SQLite正在使用的变量。</target>
        </trans-unit>
        <trans-unit id="b440573f54c675131665957f45fa09226296363a" translate="yes" xml:space="preserve">
          <source>When compiling with this option, it will normally be necessary to add a linker option to include the zlib library in the build. Normal this option is &quot;-lz&quot; but might be different on different systems.</source>
          <target state="translated">当使用这个选项编译时,通常需要添加一个链接器选项来将zlib库包含在编译中。通常这个选项是&quot;-lz&quot;,但在不同的系统上可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="c300eac9b0ba20d1c5f0548bea68bd1985408338" translate="yes" xml:space="preserve">
          <source>When computing the cost of the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;, take into account the fact that multiple seeks are required.</source>
          <target state="translated">在计算&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化&lt;/a&gt;的成本时，请考虑到需要多次搜索的事实。</target>
        </trans-unit>
        <trans-unit id="0f31671e641184fdff6ce2920c28181e45773893" translate="yes" xml:space="preserve">
          <source>When confronted with OR-connected terms in a WHERE clause, SQLite examines each OR term separately and tries to use an index to find the rowids associated with each term. It then takes the union of the resulting rowid sets to find the end result. The following figure illustrates this process:</source>
          <target state="translated">当面对WHERE子句中的OR连接项时,SQLite会分别检查每个OR项,并尝试使用索引来查找与每个项相关的rowid。然后,它将所产生的rowid集的联合来找到最终结果。下图说明了这个过程。</target>
        </trans-unit>
        <trans-unit id="80acebb0e2681ada8eda5ed06d14fb5c6e654492" translate="yes" xml:space="preserve">
          <source>When content is deleted from an SQLite database, pages that are no longer used are added to a free list and are reused to hold content added by subsequent inserts. A bug in SQLite that was present in version 3.6.16 through 3.7.2 might cause pages to go missing out of the free list when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; was used. This would not cause data loss. But it would result in the database file being larger than necessary. And it would cause the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; to report pages missing from the free list.</source>
          <target state="translated">从SQLite数据库中删除内容后，不再使用的页面将被添加到空闲列表中，并被重复使用以容纳后续插入添加的内容。在使用3.6.16到3.7.2版本的SQLite中存在一个错误，使用&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;增量&lt;/a&gt; _真空时，页面可能会从可用列表中丢失。这不会导致数据丢失。但这将导致数据库文件大于必需的文件。这将导致&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;完整性检查杂物&lt;/a&gt;报告空闲列表中缺少的页面。</target>
        </trans-unit>
        <trans-unit id="ec68acb5aee4ac70ffc0e427ed46e7978d7d9aaa" translate="yes" xml:space="preserve">
          <source>When content is deleted from an SQLite database, the content is not usually erased but rather the space used to hold the content is marked as being available for reuse. This can allow deleted content to be recovered by a hacker or by forensic analysis. Running VACUUM will clean the database of all traces of deleted content, thus preventing an adversary from recovering deleted content. Using VACUUM in this way is an alternative to setting &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete=ON&lt;/a&gt;.</source>
          <target state="translated">从SQLite数据库中删除内容时，通常不会删除内容，而是将用于保存内容的空间标记为可重复使用。这可以允许黑客或通过取证分析来恢复已删除的内容。运行VACUUM将清除数据库中所有已删除内容的痕迹，从而防止对手恢复已删除内容。以这种方式使用VACUUM是设置&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete = ON&lt;/a&gt;的替代方法。</target>
        </trans-unit>
        <trans-unit id="3ef3b5e9abd6cdd13cd5d387ea4a3c929af66232" translate="yes" xml:space="preserve">
          <source>When converting BLOB to TEXT, use the text encoding of the main database. Ticket #2349</source>
          <target state="translated">将BLOB转换为TEXT时,使用主数据库的文本编码。Ticket #2349</target>
        </trans-unit>
        <trans-unit id="114a59b6e420f398fe8acae2dbbd380f2c338748" translate="yes" xml:space="preserve">
          <source>When creating a new database file during &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; on unix systems, SQLite will try to set the permissions of the new database file to match the existing file &quot;</source>
          <target state="translated">在unix系统上的&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;期间创建新的数据库文件时，SQLite将尝试设置新数据库文件的权限以匹配现有文件&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bb5190d7ef1fca8d42df7043f112c5cb64984b8e" translate="yes" xml:space="preserve">
          <source>When creating new user-defined SQL functions and collating sequences, each function or collating sequence can specify if it works with UTF-8, UTF-16be, or UTF-16le. Separate implementations can be registered for each encoding. If an SQL function or collating sequence is required but a version for the current text encoding is not available, then the text is automatically converted. As before, this conversion takes computation time, so programmers are advised to pick a single encoding and stick with it in order to minimize the amount of unnecessary format juggling.</source>
          <target state="translated">当创建新的用户定义的SQL函数和整理序列时,每个函数或整理序列都可以指定是否使用UTF-8、UTF-16be或UTF-16le。可以为每种编码注册单独的实现。如果需要一个SQL函数或整理序列,但当前文本编码的版本不可用,那么文本将被自动转换。和之前一样,这种转换需要计算时间,所以建议程序员选择一种编码并坚持使用,以减少不必要的格式杂耍。</target>
        </trans-unit>
        <trans-unit id="6a02367c161ead06f619b074aecd9b89d2c0cc40" translate="yes" xml:space="preserve">
          <source>When data is appended to the end of the rollback journal, SQLite normally makes the pessimistic assumption that the file is first extended with invalid &quot;garbage&quot; data and that afterwards the correct data replaces the garbage. In other words, SQLite assumes that the file size is increased first and then afterwards the content is written into the file. If a power failure occurs after the file size has been increased but before the file content has been written, the rollback journal can be left containing garbage data. If after power is restored, another SQLite process sees the rollback journal containing the garbage data and tries to roll it back into the original database file, it might copy some of the garbage into the database file and thus corrupt the database file.</source>
          <target state="translated">当数据被追加到回滚日志的末尾时,SQLite通常会做一个悲观的假设,即先用无效的 &quot;垃圾 &quot;数据扩展文件,之后用正确的数据替换垃圾。换句话说,SQLite假设先增加文件大小,之后再将内容写入文件。如果在文件大小增加之后,但在文件内容写入之前发生了断电,那么回滚日志中可能会留下包含垃圾数据的数据。如果在电源恢复后,另一个SQLite进程看到了包含垃圾数据的回滚日志,并试图将其回滚到原来的数据库文件中,可能会将部分垃圾复制到数据库文件中,从而破坏数据库文件。</target>
        </trans-unit>
        <trans-unit id="6e1728b3880c31067245341a957998cb64468579" translate="yes" xml:space="preserve">
          <source>When database corruption is detected, an SQLITE_CORRUPT error logger callback is invoked. As with I/O errors, the error message text contains the line number in the original source code where the error was first detected.</source>
          <target state="translated">当检测到数据库损坏时,会调用SQLITE_CORRUPT错误记录器回调。与I/O错误一样,错误信息文本包含最初检测到错误的原始源代码中的行号。</target>
        </trans-unit>
        <trans-unit id="5ec353b1e7bb6a3ecdd47f7ae7473e801761839f" translate="yes" xml:space="preserve">
          <source>When dates are stored this way, row value comparisons provide a convenient way to compare dates:</source>
          <target state="translated">当日期以这种方式存储时,行值比较提供了一种方便的方式来比较日期。</target>
        </trans-unit>
        <trans-unit id="db590fa9b88387884339466c341a1e3e6a784a7d" translate="yes" xml:space="preserve">
          <source>When debugging the &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; generator, it is often useful to know where a particular opcode is being generated. To find this easily, run the script in a debugger. Set a breakpoint on the &quot;test_addoptrace&quot; routine. Then run the &quot;PRAGMA vdbe_addoptrace=ON;&quot; followed by the SQL statement in question. Each opcode will be displayed as it is appended to the VDBE program, and the breakpoint will fire immediately thereafter. Step until reaching the opcode then look backwards in the stack to see where and how it was generated.</source>
          <target state="translated">在调试&lt;a href=&quot;opcode&quot;&gt;字节码&lt;/a&gt;生成器时，了解在何处生成特定操作码通常很有用。为了轻松找到它，请在调试器中运行脚本。在&amp;ldquo; test_addoptrace&amp;rdquo;例程上设置一个断点。然后运行&amp;ldquo; PRAGMA vdbe_addoptrace = ON;&amp;rdquo;然后是有问题的SQL语句。每个操作码都将在添加到VDBE程序后显示，并且断点将在此后立即触发。逐步执行直到到达操作码，然后在堆栈中向后看以查看其生成位置和方式。</target>
        </trans-unit>
        <trans-unit id="d36e8b2fe095f3dcf16b488533e2eea81261ce34" translate="yes" xml:space="preserve">
          <source>When deciding between two plans with the same estimated cost, bias the selection toward the one that does not use the sorter.</source>
          <target state="translated">当在两个具有相同估计成本的计划之间做出决定时,要偏向于选择不使用分拣机的那一个。</target>
        </trans-unit>
        <trans-unit id="bf93f718a16c4baf24f9f9cd0779c38e6d7918df" translate="yes" xml:space="preserve">
          <source>When defined, this C-preprocessor macro activates extra code that attempts to detect misuse of the SQLite API, such as passing in NULL pointers to required parameters or using objects after they have been destroyed.</source>
          <target state="translated">当定义时,这个C-预处理器宏会激活额外的代码,这些代码试图检测SQLite API的滥用,例如向所需参数传递NULL指针或在对象被销毁后使用它们。</target>
        </trans-unit>
        <trans-unit id="1548f1f2e91ad07dfb5ee921f08a77e6a373fb3e" translate="yes" xml:space="preserve">
          <source>When defining a TEMP trigger on a non-TEMP table, it is important to specify the database holding the non-TEMP table. For example, in the following statement, it is important to say &quot;main.tab1&quot; instead of just &quot;tab1&quot;:</source>
          <target state="translated">在非腾博会登录表上定义腾博会登录触发器时,必须指定持有非腾博会登录表的数据库。例如,在下面的语句中,必须说 &quot;main.tab1&quot;,而不是只说 &quot;tab1&quot;。</target>
        </trans-unit>
        <trans-unit id="08cdbd4cf4d969a92be0666ae36716558d90ece0" translate="yes" xml:space="preserve">
          <source>When doing DELETE and UPDATE, the library used to write the record numbers of records to be deleted or updated into a temporary file. This is changed so that the record numbers are held in memory.</source>
          <target state="translated">在进行DELETE和UPDATE时,库中曾经把要删除或更新的记录的记录号写入一个临时文件中。现在改变了这种情况,使记录号保存在内存中。</target>
        </trans-unit>
        <trans-unit id="3cda947ba0235d70ea9379c938638b6e342ed7b3" translate="yes" xml:space="preserve">
          <source>When doing an indexed lookup of a row, the usual procedure is to do a binary search on the index to find the index entry, then extract the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; from the index and use that &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to do a binary search on the original table. Thus a typical indexed lookup involves two binary searches. If, however, all columns that were to be fetched from the table are already available in the index itself, SQLite will use the values contained in the index and will never look up the original table row. This saves one binary search for each row and can make many queries run twice as fast.</source>
          <target state="translated">对行进行索引查找时，通常的过程是对索引进行二进制搜索以找到索引条目，然后从索引中提取行&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt;，然后使用该行&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt;对原始表进行二进制搜索。因此，典型的索引查找涉及两个二进制搜索。但是，如果要从表中获取的所有列在索引本身中已经可用，则SQLite将使用索引中包含的值，并且将永远不会查找原始表行。这样可以为每一行节省一个二进制搜索，并且可以使许多查询的运行速度快两倍。</target>
        </trans-unit>
        <trans-unit id="9904bf6d42a19655ef67955a4a94073b0eae876b" translate="yes" xml:space="preserve">
          <source>When doing an insert without a rowid (argc&amp;gt;1, argv[1] is an SQL NULL), on a virtual table that uses ROWID (but not on a &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID virtual table&lt;/a&gt;), the implementation must set *pRowid to the rowid of the newly inserted row; this will become the value returned by the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function. Setting this value in all the other cases is a harmless no-op; the SQLite engine ignores the *pRowid return value if argc==1 or argv[1] is not an SQL NULL.</source>
          <target state="translated">在不使用rowid的情况下进行插入（argc&amp;gt; 1，argv [1]为SQL NULL）时，在使用ROWID的虚拟表上（而不在&lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID虚拟表上&lt;/a&gt;），实现必须将* pRowid设置为新插入的行；这将成为&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数返回的值。在所有其他情况下，将此值设置为无害操作即可；如果argc == 1或argv [1]不是SQL NULL，则SQLite引擎将忽略* pRowid返回值。</target>
        </trans-unit>
        <trans-unit id="1c8dd9af0591131c94abbb3f55e35333a90c2bb5" translate="yes" xml:space="preserve">
          <source>When enabled, this PRAGMA causes many &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements without an ORDER BY clause to emit their results in the reverse order from what they normally would. This can help debug applications that are making invalid assumptions about the result order. The reverse_unordered_selects pragma works for most SELECT statements, however the query planner may sometimes choose an algorithm that is not easily reversed, in which case the output will appear in the same order regardless of the reverse_unordered_selects setting.</source>
          <target state="translated">启用后，此PRAGMA会导致许多没有ORDER BY子句的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句以与通常相反的顺序发出结果。这可以帮助调试对结果顺序做出无效假设的应用程序。reverse_unordered_selects编译指示适用于大多数SELECT语句，但是查询计划程序有时可能会选择一种不容易逆转的算法，在这种情况下，无论reverse_unordered_selects设置如何，输出都将以相同的顺序出现。</target>
        </trans-unit>
        <trans-unit id="17ef63392395a1e6663e404dcadfba942c11b299" translate="yes" xml:space="preserve">
          <source>When faced with a choice of two or more indices, SQLite tries to estimate the total amount of work needed to perform the query using each option. It then selects the option that gives the least estimated work.</source>
          <target state="translated">当面临两个或多个索引的选择时,SQLite会尝试估计使用每个选项执行查询所需的总工作量。然后,它选择估计工作量最小的选项。</target>
        </trans-unit>
        <trans-unit id="393ffe20ba1bb6822b853fbdd74f36cd0864d018" translate="yes" xml:space="preserve">
          <source>When files opened with the asynchronous VFS are read from (using the vfs xRead() method), the data is read from the file on disk and the write-queue, so that from the point of view of the vfs reader the xWrite() appears to have already completed.</source>
          <target state="translated">当用异步VFS打开的文件被读取时(使用vfs xRead()方法),数据是从磁盘上的文件和写入队列中读取的,因此从vfs阅读器的角度看,xWrite()似乎已经完成。</target>
        </trans-unit>
        <trans-unit id="c7d3d8950c12709e47c72758e22cf2a9146592d1" translate="yes" xml:space="preserve">
          <source>When generating individual loops for each ORed term of an OR scan, move any constant WHERE expressions outside of the loop, as is done for top-level loops.</source>
          <target state="translated">当为OR扫描的每个ORed项生成单个循环时,将任何常量WHERE表达式移到循环之外,就像对顶层循环所做的那样。</target>
        </trans-unit>
        <trans-unit id="509726027c6ee1ed12b9f77062dac2b144897c56" translate="yes" xml:space="preserve">
          <source>When grouping values with the GROUP BY clause values with different storage classes are considered distinct, except for INTEGER and REAL values which are considered equal if they are numerically equal. No affinities are applied to any values as the result of a GROUP by clause.</source>
          <target state="translated">当使用GROUP BY子句对不同存储类别的值进行分组时,除了INTEGER和REAL值在数值上相等外,其他的值都被认为是不同的。作为GROUP BY子句的结果,任何值都不会有亲缘关系。</target>
        </trans-unit>
        <trans-unit id="f5be44df47344688e11692055f71bde95bd3d10c" translate="yes" xml:space="preserve">
          <source>When implementing the compress and uncompress functions it is important to pay attention to data types. Specifically, when a user reads a value from a compressed FTS table, the value returned by FTS is exactly the same as the value returned by the uncompress function, including the data type. If that data type is not the same as the data type of the original value as passed to the compress function (for example if the uncompress function is returning BLOB when compress was originally passed TEXT), then the users query may not function as expected.</source>
          <target state="translated">在实现压缩和解压函数时,必须注意数据类型。具体来说,当用户从压缩后的FTS表中读取一个值时,FTS返回的值与解压缩函数返回的值完全相同,包括数据类型。如果该数据类型与传递给压缩函数的原始值的数据类型不一样(例如,如果解压缩函数返回的是BLOB,而压缩最初传递的是TEXT),那么用户的查询就可能达不到预期的功能。</target>
        </trans-unit>
        <trans-unit id="9aa85d5d53872aab853201ddf44e7a88440d444e" translate="yes" xml:space="preserve">
          <source>When in active use, the state of a WAL mode database is described by three separate files:</source>
          <target state="translated">当处于使用状态时,WAL模式数据库的状态由三个独立的文件描述。</target>
        </trans-unit>
        <trans-unit id="2d85294d594836a84f09ae35993c5315f3443a88" translate="yes" xml:space="preserve">
          <source>When information is deleted from an SQLite database, the pages used to hold the deleted information are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot;. Subsequent inserts will draw pages off of this freelist rather than expanding the database file.</source>
          <target state="translated">从SQLite数据库中删除信息时，用于保存已删除信息的页面将添加到&amp;ldquo; &lt;a href=&quot;fileformat2#freelist&quot;&gt;自由列表&lt;/a&gt; &amp;rdquo;中。随后的插入将使页面脱离此空闲列表，而不是扩展数据库文件。</target>
        </trans-unit>
        <trans-unit id="e58c2028dd3a68f355f0f948fe1f1f5ac6f262b7" translate="yes" xml:space="preserve">
          <source>When initially opened, the cursor is in an undefined state. The SQLite core will invoke the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method on the cursor prior to any attempt to position or read from the cursor.</source>
          <target state="translated">最初打开时，游标处于未定义状态。在尝试定位或读取游标之前，SQLite核心将在游标上调用&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="4ec1014aface212f1273d4c0983ab7820ffd9ca0" translate="yes" xml:space="preserve">
          <source>When inserting an explicit NULL into an INTEGER PRIMARY KEY, convert the NULL value into a unique key automatically.</source>
          <target state="translated">当在INTEGER PRIMARY KEY中插入显式NULL时,自动将NULL值转换为唯一键。</target>
        </trans-unit>
        <trans-unit id="643f10feaaa38e7180b2d82bb59e6a7c32281c82" translate="yes" xml:space="preserve">
          <source>When looking for memory allocation problems (memory leaks, use-after-free errors, buffer overflows, etc) it is sometimes useful to disable the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; then run the test under valgrind or MSAN or some other heap memory debugging tool. The lookaside memory allocator can be disabled at start-time using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; interface. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will use that interface to disable lookaside if it is started with the &quot;--lookaside 0 0&quot; command line option.</source>
          <target state="translated">在寻找内存分配问题（内存泄漏，释放后使用错误，缓冲区溢出等）时，有时禁用&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器，&lt;/a&gt;然后在valgrind或MSAN或某些其他堆内存调试工具下运行测试，这很有用。后备内存分配器可以在启动时使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;接口禁用。如果&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;以&amp;ldquo; --lookaside 0 0&amp;rdquo;命令行选项启动，则它将使用该界面禁用后备功能。</target>
        </trans-unit>
        <trans-unit id="42fe685cb985a24b50ac506fdd29223838c245b8" translate="yes" xml:space="preserve">
          <source>When measuring test coverage, these macros are defined to be constant truth values so that they do not generate assembly language branch instructions, and hence do not come into play when calculating the branch coverage:</source>
          <target state="translated">在测量测试覆盖率时,这些宏被定义为恒定的真值,因此它们不会产生汇编语言分支指令,因此在计算分支覆盖率时不会发挥作用。</target>
        </trans-unit>
        <trans-unit id="37b8b518e60139042da23ec309a2db4382dae010" translate="yes" xml:space="preserve">
          <source>When more than two tables are joined together as part of a FROM clause, the join operations are processed in order from left to right. In other words, the FROM clause (A join-op-1 B join-op-2 C) is computed as ((A join-op-1 B) join-op-2 C).</source>
          <target state="translated">当两个以上的表作为FROM子句的一部分被连接在一起时,连接操作按照从左到右的顺序进行处理。换句话说,FROM子句(A join-op-1 B join-op-2 C)的计算方式是((A join-op-1 B)join-op-2 C)。</target>
        </trans-unit>
        <trans-unit id="87981e247df4872c2958ce96479f7f548dab13e8" translate="yes" xml:space="preserve">
          <source>When multiple database connections share the same cache, changing the secure-delete flag on one database connection changes it for them all.</source>
          <target state="translated">当多个数据库连接共享同一个缓存时,改变一个数据库连接上的安全删除标志会改变所有连接的安全删除标志。</target>
        </trans-unit>
        <trans-unit id="cff16baa2216647f9ba74dc7c006fb34b16c7df6" translate="yes" xml:space="preserve">
          <source>When multiple database files are involved in a transaction, each database has its own rollback journal and each database is locked separately. The diagram at the right shows a scenario where three different database files have been modified within one transaction. The situation at this step is analogous to the single-file transaction scenario at &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Each database file has a reserved lock. For each database, the original content of pages that are being changed have been written into the rollback journal for that database, but the content of the journals have not yet been flushed to disk. No changes have been made to the database file itself yet, though presumably there are changes being held in user memory.</source>
          <target state="translated">当事务中涉及多个数据库文件时，每个数据库都有其自己的回退日志，并且每个数据库都被分别锁定。右图显示了在一个事务中修改了三个不同数据库文件的情况。此步骤中的情况类似于&lt;a href=&quot;#section_3_6&quot;&gt;步骤3.6中&lt;/a&gt;的单文件事务处理情况。每个数据库文件都有一个保留锁。对于每个数据库，要更改的页面的原始内容已写入该数据库的回滚日志中，但是日志的内容尚未刷新到磁盘上。尽管可能已在用户存储器中保存了更改，但尚未对数据库文件本身进行任何更改。</target>
        </trans-unit>
        <trans-unit id="594f4bededce2bfb4a7467d0259050d544509cc0" translate="yes" xml:space="preserve">
          <source>When mxFrame field is zero, it indicates that the WAL is empty and that all content should be obtained directly from the database file.</source>
          <target state="translated">当mxFrame字段为零时,表示WAL为空,所有内容应直接从数据库文件中获取。</target>
        </trans-unit>
        <trans-unit id="1e88c1e1b6e3eb28ff7f2a97dc557877c5de44f1" translate="yes" xml:space="preserve">
          <source>When mxFrame is equal to &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;, that indicates that all content in the WAL has been written back into the database. In that case, all content can be read directly from the database. Furthermore, the next writer is free to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if no other connections hold locks on WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">当mxFrame等于&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;时，表明WAL中的所有内容都已写回到数据库中。在这种情况下，所有内容都可以直接从数据库中读取。此外，如果没有其他连接在WAL_READ_LOCK（N）上保持N&amp;gt; 0的锁，则下一个编写器可以自由&lt;a href=&quot;fileformat2#walreset&quot;&gt;重置WAL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d7dccde63e1547be27c7ca87cdd1931b0750828" translate="yes" xml:space="preserve">
          <source>When new tables are created using CREATE TABLE ... AS SELECT ... the datatype of the columns is the simplified SQLite datatype (TEXT, INT, REAL, NUMERIC, or BLOB) instead of a copy of the original datatype from the source table.</source>
          <target state="translated">当使用CREATE TABLE......创建新的表时。AS SELECT ......列的数据类型是简化的SQLite数据类型(TEXT、INT、REAL、NUMERIC或BLOB),而不是源表的原始数据类型的拷贝。</target>
        </trans-unit>
        <trans-unit id="a55aa5700dcf1b282b21e4844d72874dc0872eb0" translate="yes" xml:space="preserve">
          <source>When no appropriate indices are available, a query with an ORDER BY clause must be sorted as a separate step. Consider this query:</source>
          <target state="translated">当没有合适的索引时,必须将带有ORDER BY子句的查询作为一个单独的步骤进行排序。考虑这个查询。</target>
        </trans-unit>
        <trans-unit id="390a0c90ac5f7c87fa004dbc08670c0d9227649a" translate="yes" xml:space="preserve">
          <source>When no indices are available to aid the evaluation of a query, SQLite might create an automatic index that lasts only for the duration of a single SQL statement. Since the cost of constructing the automatic index is O(NlogN) (where N is the number of entries in the table) and the cost of doing a full table scan is only O(N), an automatic index will only be created if SQLite expects that the lookup will be run more than logN times during the course of the SQL statement. Consider an example:</source>
          <target state="translated">当没有可用的索引来帮助评估查询时,SQLite可能会创建一个自动索引,这个索引只在一条SQL语句的持续时间内持续。由于构造自动索引的成本是O(NlogN)(其中N是表的条目数),而做一次完整的表扫描的成本只有O(N),因此,只有当SQLite预计在SQL语句的过程中,查找将被运行超过logN次时,才会创建自动索引。考虑一个例子。</target>
        </trans-unit>
        <trans-unit id="540aa517907a8d449dfe0e0b35e5509aa40924c4" translate="yes" xml:space="preserve">
          <source>When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed and the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e54fe7f1e563760a880b88a508db483dfbb6a4e" translate="yes" xml:space="preserve">
          <source>When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</source>
          <target state="translated">在触发程序执行期间调用RAISE（ROLLBACK，...），RAISE（ABORT，...）或RAISE（FAIL，...）之一时，将执行指定的&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;处理，当前查询终止。&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;的错误代码将与指定的错误消息一起返回给应用程序。</target>
        </trans-unit>
        <trans-unit id="01227fb935ccfc1f5f31820ba60592508e753c65" translate="yes" xml:space="preserve">
          <source>When opening a file, if the command-line client discovers that the file is ZIP archive instead of an SQLite database, it actually opens an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and then in that in-memory database it creates an instance of the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; that is attached to the ZIP archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4362aeea9635659d5b4cd64a35ff28fb52ad1831" translate="yes" xml:space="preserve">
          <source>When operating in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, all SQLite database connections associated with the same database file need to share some memory that is used as an index for the WAL file. In most implementations, this shared memory is implemented by calling mmap() on a file created for this sole purpose: the shared-memory file. The shared-memory file, if it exists, is located in the same directory as the database file and has the same name as the database file except with the 4 characters &quot;&lt;b&gt;-shm&lt;/b&gt;&quot; appended. Shared memory files only exist while running in WAL mode.</source>
          <target state="translated">在&lt;a href=&quot;wal&quot;&gt;WAL模式下操作时&lt;/a&gt;，与同一数据库文件关联的所有SQLite数据库连接都需要共享一些内存，该内存用作WAL文件的索引。在大多数实现中，此共享内存是通过在为此目的而创建的文件：共享内存文件上调用mmap（）来实现的。共享内存文件（如果存在）与数据库文件位于同一目录中，并且与数据库文件具有相同的名称，但附加了4个字符&amp;ldquo; &lt;b&gt;-shm&lt;/b&gt; &amp;rdquo;。共享内存文件仅在WAL模式下运行时存在。</target>
        </trans-unit>
        <trans-unit id="6bb4007f1d52b792a142259284926e062c686eaf" translate="yes" xml:space="preserve">
          <source>When optimized for size, the whole SQLite library with everything enabled is &lt;a href=&quot;footprint&quot;&gt;less than 500KiB in size&lt;/a&gt; (as measured on an ix86 using the &quot;size&quot; utility from the GNU compiler suite.) Unneeded features can be disabled at compile-time to further reduce the size of the library to under 300KiB if desired.</source>
          <target state="translated">如果对大小进行了优化，则启用了所有功能的整个SQLite库的大小都&lt;a href=&quot;footprint&quot;&gt;小于500KiB&lt;/a&gt;（根据使用GNU编译器套件的&amp;ldquo; size&amp;rdquo;实用程序在ix86上进行的测量。）可以在编译时禁用不需要的功能，以进一步减少如果需要，库的大小应小于300KiB。</target>
        </trans-unit>
        <trans-unit id="36556333a18e7240b5e2f86d71ec1605e3df5074" translate="yes" xml:space="preserve">
          <source>When porting SQLite to a new operating system, it is usually necessary to completely replace the built-in mutex subsystem with an alternative built around the mutex primitives of the new operating system. This is accomplished by compiling SQLite with the following option:</source>
          <target state="translated">在将SQLite移植到新的操作系统时,通常需要用围绕新操作系统的mutex基元构建的替代系统完全替换内置的mutex子系统。这可以通过使用以下选项编译SQLite来实现。</target>
        </trans-unit>
        <trans-unit id="ef28302f8a0daea79bec53d89c73ea8d20c2af92" translate="yes" xml:space="preserve">
          <source>When processing a &lt;b&gt;DELETE&lt;/b&gt; change, the following conflicts may be detected:</source>
          <target state="translated">处理&lt;b&gt;DELETE&lt;/b&gt;更改时，可能会检测到以下冲突：</target>
        </trans-unit>
        <trans-unit id="feb3e5a5d3242cd110b456009cbca7b6fb677c07" translate="yes" xml:space="preserve">
          <source>When processing a SELECT (or other) statement, SQLite may retrieve data from database tables in a variety of ways. It may scan through all the records in a table (a full-table scan), scan a contiguous subset of the records in a table based on the rowid index, scan a contiguous subset of the entries in a database &lt;a href=&quot;lang_createtable&quot;&gt;index&lt;/a&gt;, or use a combination of the above strategies in a single scan. The various ways in which SQLite may retrieve data from a table or index are described in detail &lt;a href=&quot;queryplanner#searching&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">在处理SELECT（或其他）语句时，SQLite可以通过多种方式从数据库表中检索数据。它可以扫描表中的所有记录（全表扫描），基于rowid索引扫描表中记录的连续子集，扫描数据库&lt;a href=&quot;lang_createtable&quot;&gt;索引中&lt;/a&gt;条目的连续子集或组合使用一次扫描即可查看以上策略。在其中的SQLite可以从表或索引中检索数据的各种方式进行详细说明&lt;a href=&quot;queryplanner#searching&quot;&gt;这里&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e6fe17803083dfa07e4b417bb2b4cf1a4c64242" translate="yes" xml:space="preserve">
          <source>When processing an &lt;b&gt;INSERT&lt;/b&gt; change, the following conflicts can occur:</source>
          <target state="translated">处理&lt;b&gt;INSERT&lt;/b&gt;更改时，可能会发生以下冲突：</target>
        </trans-unit>
        <trans-unit id="22eb80162f6ab8bb9c9904d675b35465735f18b1" translate="yes" xml:space="preserve">
          <source>When processing an &lt;b&gt;UPDATE&lt;/b&gt; change, the following conflicts may be detected:</source>
          <target state="translated">处理&lt;b&gt;UPDATE&lt;/b&gt;更改时，可能会检测到以下冲突：</target>
        </trans-unit>
        <trans-unit id="96dc4d2d808bddd461eb35740cb2e242c1a91b3e" translate="yes" xml:space="preserve">
          <source>When processing queries that feature more than one token, FTS5 is sometimes able to determine that the query can be answered by inspecting a subset of a large instance-list. FTS3/4 almost always has to traverse entire instance-lists.</source>
          <target state="translated">当处理具有多个令牌的查询时,FTS5有时能够确定查询可以通过检查一个大型实例列表的子集来回答。FTS3/4几乎总是要遍历整个实例列表。</target>
        </trans-unit>
        <trans-unit id="b4456c24b4cd85849eb2f816e79572b467a2fc07" translate="yes" xml:space="preserve">
          <source>When query results are sorted by an ORDER BY clause, values with storage class NULL come first, followed by INTEGER and REAL values interspersed in numeric order, followed by TEXT values in collating sequence order, and finally BLOB values in memcmp() order. No storage class conversions occur before the sort.</source>
          <target state="translated">当查询结果按ORDER BY子句排序时,存储类为NULL的值排在前面,其次是按数字顺序穿插的INTEGER和REAL值,然后是按整理顺序排列的TEXT值,最后是按memcmp()顺序排列的BLOB值。排序前不发生存储类转换。</target>
        </trans-unit>
        <trans-unit id="e91e22fc8ff638a8787ffecd5d5f0df9da8787f3" translate="yes" xml:space="preserve">
          <source>When required to</source>
          <target state="translated">需要时</target>
        </trans-unit>
        <trans-unit id="78c613e6d682faec6496ee4d9048bbcfd6d7d464" translate="yes" xml:space="preserve">
          <source>When required to append a</source>
          <target state="translated">当需要附加一个</target>
        </trans-unit>
        <trans-unit id="798519ed2b08664b52737ffba7c81753837b1259" translate="yes" xml:space="preserve">
          <source>When required to append a new database page to the database file, SQLite shall create a new</source>
          <target state="translated">当需要在数据库文件中附加一个新的数据库页面时,SQLite应创建一个新的</target>
        </trans-unit>
        <trans-unit id="6dcc88fffc3fe69f52028c8e6091eebcfd48e874" translate="yes" xml:space="preserve">
          <source>When required to attempt to detect a</source>
          <target state="translated">当需要试图检测</target>
        </trans-unit>
        <trans-unit id="82187b34c5d14ea3c6cc853ad766ba3268f5b299" translate="yes" xml:space="preserve">
          <source>When required to end a</source>
          <target state="translated">需要结束时</target>
        </trans-unit>
        <trans-unit id="baf01cea17946b2cb417992fd85480056f55712b" translate="yes" xml:space="preserve">
          <source>When required to modify the contents of an existing database page that existed and was not a</source>
          <target state="translated">当需要修改现有数据库页面的内容时,如果该页面已经存在,并且不是一个新的数据库页面,那么就需要修改该页面的内容。</target>
        </trans-unit>
        <trans-unit id="ea12960936b78c03e66e4654443a0f13383a7001" translate="yes" xml:space="preserve">
          <source>When required to modify the contents of an existing database page, SQLite shall update the cached version of the database page content stored as part of the</source>
          <target state="translated">当需要修改现有数据库页面的内容时,SQLite应更新数据库页面内容的缓存版本,作为存储在</target>
        </trans-unit>
        <trans-unit id="72b58d5840f56734164db642d70a3df517a5e160" translate="yes" xml:space="preserve">
          <source>When required to open a</source>
          <target state="translated">当需要打开一个</target>
        </trans-unit>
        <trans-unit id="202f6940a3123823f29cdd85bae8600a952bce22" translate="yes" xml:space="preserve">
          <source>When required to perform</source>
          <target state="translated">需要执行时</target>
        </trans-unit>
        <trans-unit id="49e57edc72b2554b07e6deee46ce3f790b869e23" translate="yes" xml:space="preserve">
          <source>When required to purge a</source>
          <target state="translated">当需要清除一个</target>
        </trans-unit>
        <trans-unit id="96b4b0dc1d589faf2e657c0bc5a3a75b7b82c7c8" translate="yes" xml:space="preserve">
          <source>When required to truncate (remove) a database page that existed and was not a</source>
          <target state="translated">当需要截断(删除)已存在的数据库页面时,如果该页面不是一个数据库,那么就会被删除。</target>
        </trans-unit>
        <trans-unit id="24c9b9293e0d1ee15b7fdaf8a59c9a8d10fd1c44" translate="yes" xml:space="preserve">
          <source>When required to truncate a database page from the end of the database file, SQLite shall discard the associated</source>
          <target state="translated">当需要从数据库文件的末尾截断数据库页面时,SQLite应丢弃相关的</target>
        </trans-unit>
        <trans-unit id="150a8fe0ea2f86237f4f58257c9a767ee7e2a25a" translate="yes" xml:space="preserve">
          <source>When required to upgrade to an</source>
          <target state="translated">当需要升级到</target>
        </trans-unit>
        <trans-unit id="fcba2e5b4c05a2548f809c299faee545560dd767" translate="yes" xml:space="preserve">
          <source>When running in shared-cache mode, a database operation may fail with an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See &lt;a href=&quot;sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-preprocessor symbol defined.</source>
          <target state="translated">在共享缓存模式下运行时，如果无法获得共享缓存上所需的锁或共享缓存内的各个表，则数据库操作可能会失败并显示&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;错误。有关共享缓存锁定的说明，请参见&lt;a href=&quot;sharedcache&quot;&gt;SQLite共享缓存模式&lt;/a&gt;。当当前持有所需锁的连接放弃该调用时，该API可用于注册SQLite将调用的回调。仅当库是使用已定义的&lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C预处理器符号编译的时，此API才可用。</target>
        </trans-unit>
        <trans-unit id="b02906105894d89f6847bc0868bb9a109b4e3e2a" translate="yes" xml:space="preserve">
          <source>When running in shared-cache mode, a database operation may fail with an &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See &lt;a href=&quot;../sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the &lt;a href=&quot;../compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-preprocessor symbol defined.</source>
          <target state="translated">在共享缓存模式下运行时，如果无法获得共享缓存上所需的锁或共享缓存内的各个表，则数据库操作可能会失败并显示&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;错误。有关共享缓存锁定的说明，请参见&lt;a href=&quot;../sharedcache&quot;&gt;SQLite共享缓存模式&lt;/a&gt;。当当前持有所需锁的连接放弃该调用时，该API可用于注册SQLite将调用的回调。仅当库是使用已定义的&lt;a href=&quot;../compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C预处理器符号编译的时，此API才可用。</target>
        </trans-unit>
        <trans-unit id="2af0cef1a0b15f9849e9b4a326164320a983e665" translate="yes" xml:space="preserve">
          <source>When running on QNX, it is recommended that &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; never be used. Furthermore, to use &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, it is recommended that applications employ the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; in order to use &lt;a href=&quot;wal#noshm&quot;&gt;WAL without shared memory&lt;/a&gt;.</source>
          <target state="translated">当QNX运行，建议&lt;a href=&quot;mmap&quot;&gt;内存映射I / O&lt;/a&gt;永远不会被使用。此外，要使用&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;，建议应用程序使用&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他锁定模式&lt;/a&gt;，以便在&lt;a href=&quot;wal#noshm&quot;&gt;没有共享内存的情况下&lt;/a&gt;使用WAL。</target>
        </trans-unit>
        <trans-unit id="d6885131949093b9f2e26719d9e197b2addf166d" translate="yes" xml:space="preserve">
          <source>When safe append semantics are indicated for a filesystem, SQLite always stores the special value of -1 for the page count in the header of the rollback journal. The -1 page count value tells any process attempting to rollback the journal that the number of pages in the journal should be computed from the journal size. This -1 value is never changed. So that when a commit occurs, we save a single flush operation and a sector write of the first page of the journal file. Furthermore, when a cache spill occurs we no longer need to append a new journal header to the end of the journal; we can simply continue appending new pages to the end of the existing journal.</source>
          <target state="translated">当为文件系统指明安全追加语义时,SQLite总是在回滚日志的页数头中存储特殊值-1。页数-1值告诉任何试图回滚日志的进程,日志中的页数应根据日志大小计算。这个-1值永远不会被改变。这样,当发生提交时,我们就会保存一次刷新操作和日记文件第一页的扇区写入。此外,当发生缓存溢出时,我们不再需要在日记本的末尾追加一个新的日记本头,我们只需在现有日记本的末尾继续追加新的页面即可。</target>
        </trans-unit>
        <trans-unit id="c52209ae5a29283cfe5cb3dad1ce0ecd4b45279f" translate="yes" xml:space="preserve">
          <source>When sector writes are atomic and the page size of a database is the same as a sector size, and when there is a database change that only touches a single database page, then SQLite skips the whole journaling and syncing process and simply writes the modified page directly into the database file. The change counter in the first page of the database file is modified separately since no harm is done if power is lost before the change counter can be updated.</source>
          <target state="translated">当扇区写入是原子性的,数据库的页面大小与扇区大小相同时,当数据库变化只触及单个数据库页面时,那么SQLite就会跳过整个日记和同步过程,直接将修改后的页面写入数据库文件中。数据库文件第一页中的变更计数器是单独修改的,因为在更新变更计数器之前,如果断电也不会有什么危害。</target>
        </trans-unit>
        <trans-unit id="340896b0a1241236bc1bf669ed9b704188faab52" translate="yes" xml:space="preserve">
          <source>When selecting the order of tables in a join, SQLite uses an efficient polynomial-time algorithm. Because of this, SQLite is able to plan queries with 50- or 60-way joins in a matter of microseconds</source>
          <target state="translated">在选择连接中表的顺序时,SQLite使用了一种高效的多项式时间算法。正因为如此,SQLite能够在几微秒内规划50或60路连接的查询。</target>
        </trans-unit>
        <trans-unit id="1aebe3c7de990f7af4ad0100f2e7e450c502bae1" translate="yes" xml:space="preserve">
          <source>When set to the value &quot;fts3&quot;, the matchinfo option reduces the amount of information stored by FTS4 with the consequence that the &quot;l&quot; option of &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; is no longer available.</source>
          <target state="translated">当设置为值&amp;ldquo; fts3&amp;rdquo;时，matchinfo选项会减少FTS4存储的信息量，结果是&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;的&amp;ldquo; l&amp;rdquo;选项不再可用。</target>
        </trans-unit>
        <trans-unit id="637783b2ffcae0b4a42a6035522c7dbcf1ec705e" translate="yes" xml:space="preserve">
          <source>When specifying insert mode, you have to give an extra argument which is the name of the table to be inserted into. For example:</source>
          <target state="translated">当指定插入模式时,你必须给出一个额外的参数,即要插入的表的名称。例如</target>
        </trans-unit>
        <trans-unit id="1b258d1afb6dda622a0743a2a73308bdb7445718" translate="yes" xml:space="preserve">
          <source>When sqlite3_backup_step() has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or when the application wishes to abandon the backup operation, the application should destroy the &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; by passing it to sqlite3_backup_finish(). The sqlite3_backup_finish() interfaces releases all resources associated with the &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. If sqlite3_backup_step() has not yet returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, then any active write-transaction on the destination database is rolled back. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object is invalid and may not be used following a call to sqlite3_backup_finish().</source>
          <target state="translated">当sqlite3_backup_step（）返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE时&lt;/a&gt;，或者当应用程序希望放弃备份操作时，应用程序应通过将&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;传递给sqlite3_backup_finish（）来销毁它。 sqlite3_backup_finish（）接口释放与&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象关联的所有资源。如果sqlite3_backup_step（）尚未返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，则将回滚目标数据库上的任何活动写事务。&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象无效，调用sqlite3_backup_finish（）后可能无法使用该对象。</target>
        </trans-unit>
        <trans-unit id="ff3c33367e6881dcf5fe599ab4cc7d4d94774505" translate="yes" xml:space="preserve">
          <source>When sqlite3_backup_step() has returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or when the application wishes to abandon the backup operation, the application should destroy the &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; by passing it to sqlite3_backup_finish(). The sqlite3_backup_finish() interfaces releases all resources associated with the &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. If sqlite3_backup_step() has not yet returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, then any active write-transaction on the destination database is rolled back. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object is invalid and may not be used following a call to sqlite3_backup_finish().</source>
          <target state="translated">当sqlite3_backup_step（）返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE时&lt;/a&gt;，或者当应用程序希望放弃备份操作时，应用程序应通过将&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;传递给sqlite3_backup_finish（）来销毁它。 sqlite3_backup_finish（）接口释放与&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象关联的所有资源。如果sqlite3_backup_step（）尚未返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，则将回滚目标数据库上的任何活动写事务。&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象无效，调用sqlite3_backup_finish（）后可能无法使用该对象。</target>
        </trans-unit>
        <trans-unit id="f11c5f277ff9a9bea3d1538e42d008cd96e6371c" translate="yes" xml:space="preserve">
          <source>When synchronous is FULL (2), the SQLite database engine will use the xSync method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to ensure that all content is safely written to the disk surface prior to continuing. This ensures that an operating system crash or power failure will not corrupt the database. FULL synchronous is very safe, but it is also slower. FULL is the most commonly used synchronous setting when not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">当sync为FULL（2）时，SQLite数据库引擎将使用&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xSync方法来确保在继续操作之前将所有内容安全地写入磁盘表面。这样可以确保操作系统崩溃或电源故障不会损坏数据库。全同步非常安全，但速度也较慢。不处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;时，FULL是最常用的同步设置。</target>
        </trans-unit>
        <trans-unit id="43aa9a49bc45ba6ec32647dc1c08a8d6748123c3" translate="yes" xml:space="preserve">
          <source>When synchronous is NORMAL (1), the SQLite database engine will still sync at the most critical moments, but less often than in FULL mode. There is a very small (though non-zero) chance that a power failure at just the wrong time could corrupt the database in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;=DELETE on an older filesystem. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is safe from corruption with synchronous=NORMAL, and probably DELETE mode is safe too on modern filesystems. WAL mode is always consistent with synchronous=NORMAL, but WAL mode does lose durability. A transaction committed in WAL mode with synchronous=NORMAL might roll back following a power loss or system crash. Transactions are durable across application crashes regardless of the synchronous setting or journal mode. The synchronous=NORMAL setting is a good choice for most applications running in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">当&amp;ldquo;同步&amp;rdquo;为&amp;ldquo;正常&amp;rdquo;（1）时，SQLite数据库引擎仍将在最关键的时刻进行同步，但同步的频率要低于&amp;ldquo;全&amp;rdquo;模式。在错误的时间出现电源故障的机会很小（尽管非零），这可能会破坏旧文件系统上&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; = DELETE 的数据库。&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;使用sync = NORMAL可以防止损坏，并且在现代文件系统上DELETE模式也很安全。 WAL模式始终与sync = NORMAL一致，但是WAL模式确实会失去耐久性。在WAL模式下以syncon = NORMAL提交的事务可能会在断电或系统崩溃后回滚。无论应用程序崩溃是同步设置还是日志模式，事务都可以持久保存。对于大多数以&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;运行的应用程序来说，sync = NORMAL设置是一个不错的选择。</target>
        </trans-unit>
        <trans-unit id="1221ac9ca537e39eaf7a9c102f123b50e4ccafe2" translate="yes" xml:space="preserve">
          <source>When the &quot;write_version&quot; value of the database header is larger than what the library understands, make the database read-only instead of unreadable.</source>
          <target state="translated">当数据库头的 &quot;write_version &quot;值大于库所理解的值时,使数据库只读而不是不可读。</target>
        </trans-unit>
        <trans-unit id="14c5bdcdfec2d165a19969db87c59339f98d6d50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#eval&quot;&gt;eval method&lt;/a&gt; sees a named SQL parameter such as &quot;$abc&quot; or &quot;:def&quot; or &quot;@ghi&quot; in an SQL statement, it tries to look up a TCL variable with the same name, and it binds the value of that TCL variable to the SQL parameter. If no such TCL variable exists, the default behavior is to bind an SQL NULL value to the parameter. However, if a bind_fallback proc is specified, then that proc is invoked with the name of the SQL parameter and the return value from the proc is bound to the SQL parameter. Or if the proc returns an error, then the SQL statement aborts with that error. If the proc returns with some code other than TCL_OK or TCL_ERROR, then the SQL parameter is bound to NULL, as it would be by default.</source>
          <target state="translated">当&lt;a href=&quot;#eval&quot;&gt;eval方法&lt;/a&gt;在SQL语句中看到命名的SQL参数（例如&amp;ldquo; $ abc&amp;rdquo;或&amp;ldquo;：def&amp;rdquo;或&amp;ldquo; @ghi&amp;rdquo;）时，它将尝试查找具有相同名称的TCL变量，并将其值绑定TCL变量为SQL参数。如果不存在这样的TCL变量，则默认行为是将SQL NULL值绑定到该参数。但是，如果指定了bind_fallback proc，则将使用SQL参数的名称调用该proc，并将proc的返回值绑定到SQL参数。或者，如果proc返回错误，则SQL语句将因该错误而中止。如果proc返回的代码不是TCL_OK或TCL_ERROR，则SQL参数绑定为NULL，这与默认情况相同。</target>
        </trans-unit>
        <trans-unit id="e9681f846afb85497f8c3e1e346505a1d05e091c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt; aggregate functions are used in an aggregate query, all bare columns in the result set take values from the input row which also contains the minimum or maximum. So in the query above, the value of the &quot;b&quot; column in the output will be the value of the &quot;b&quot; column in the input row that has the largest &quot;c&quot; value. There is still an ambiguity if two or more of the input rows have the same minimum or maximum value or if the query contains more than one min() and/or max() aggregate function. Only the built-in &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;min()&lt;/a&gt; and &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; functions work this way.</source>
          <target state="translated">在聚合查询中使用&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min（）&lt;/a&gt;或&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max（）&lt;/a&gt;聚合函数时，结果集中的所有裸列都从输入行中获取值，该行还包含最小值或最大值。因此，在上面的查询中，输出中&amp;ldquo; b&amp;rdquo;列的值将是输入行中具有最大&amp;ldquo; c&amp;rdquo;值的&amp;ldquo; b&amp;rdquo;列的值。如果两个或多个输入行的最小值或最大值相同，或者查询包含多个min（）和/或max（）聚合函数，则仍然存在歧义。只有内置的&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;min（）&lt;/a&gt;和&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max（）&lt;/a&gt;函数以这种方式工作。</target>
        </trans-unit>
        <trans-unit id="56141e1c0fb6b7c512062b7753a9277ae3973fa7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement to which the UPSERT is attached takes its values from a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement, there is a potential parsing ambiguity. The parser might not be able to tell if the &quot;ON&quot; keyword is introducing the UPSERT or if it is the ON clause of a join. To work around this, the SELECT statement should always include a WHERE clause, even if that WHERE clause is just &quot;WHERE true&quot;.</source>
          <target state="translated">当UPSERT附加到的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句从&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句获取其值时，可能存在语法歧义。解析器可能无法判断&amp;ldquo; ON&amp;rdquo;关键字是否正在引入UPSERT或它是否是联接的ON子句。若要解决此问题，即使该WHERE子句只是&amp;ldquo; WHERE true&amp;rdquo;，SELECT语句也应始终包含WHERE子句。</target>
        </trans-unit>
        <trans-unit id="9d27fd39dc19689d64d7d12f5a355d4c7bb83355" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery is a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; then the affinity of each supposed column of the VIEW or subquery will be the affinity of the corresponding result column for one of the individual SELECT statements that make up the compound. However, it is indeterminate which of the SELECT statements will be used to determine affinity. Different constituent SELECT statements might be used to determine affinity at different times during query evaluation. Best practice is to avoid mixing affinities in a compound SELECT.</source>
          <target state="translated">如果实现&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;或FROM子句的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句是&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT，&lt;/a&gt;则VIEW或子查询的每个假定列的亲和力将是组成该复合的单个SELECT语句之一的相应结果列的亲和力。 。但是，不确定使用哪个SELECT语句来确定亲和力。在查询评估期间，可以使用不同的SELECT语句来确定不同时间的相似性。最佳实践是避免在化合物SELECT中混合亲和力。</target>
        </trans-unit>
        <trans-unit id="06ddddedda26385f60e680a5388eae9aa1b1f989" translate="yes" xml:space="preserve">
          <source>When the D parameter is not NULL, that means that ownership of the pointer is being transferred to SQLite. SQLite will take responsibility for freeing resources associated with the pointer when it has finished using the pointer. If the D parameter is NULL, that means that ownership of the pointer remains with the caller and the caller is responsible for disposing of the pointer.</source>
          <target state="translated">当D参数不是NULL时,意味着指针的所有权正在转移给SQLite。当SQLite使用完该指针后,将负责释放与该指针相关的资源。如果D参数为NULL,则意味着指针的所有权仍然属于调用者,调用者负责处置指针。</target>
        </trans-unit>
        <trans-unit id="821f9322e2541019ba56eda61e1f81487c5db2ed" translate="yes" xml:space="preserve">
          <source>When the EXPLAIN keyword appears by itself it causes the statement to behave as a query that returns the sequence of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; it would have used to execute the command had the EXPLAIN keyword not been present. When the EXPLAIN QUERY PLAN phrase appears, the statement returns high-level information regarding the query plan that would have been used.</source>
          <target state="translated">当EXPLAIN关键字本身出现时，它将使该语句充当查询的角色，返回不存在EXPLAIN关键字的&lt;a href=&quot;opcode&quot;&gt;虚拟机指令&lt;/a&gt;序列。当出现EXPLAIN QUERY PLAN短语时，该语句返回有关将要使用的查询计划的高级信息。</target>
        </trans-unit>
        <trans-unit id="0322a186c7875e9599006050d189bbd4680c31ba" translate="yes" xml:space="preserve">
          <source>When the ORDER BY clause is omitted from the recursive-select, the queue behaves as a FIFO, which results in a breadth-first search.</source>
          <target state="translated">当递归选择中省略ORDER BY子句时,队列的行为就像一个FIFO,这就导致了广度优先搜索。</target>
        </trans-unit>
        <trans-unit id="6f6a426144bea68a6a8caf2439e46959412cc8bf" translate="yes" xml:space="preserve">
          <source>When the PRAGMA vdbe_trace=ON is set, correctly print the P3 operand value when it is a pointer to a structure rather than a pointer to a string.</source>
          <target state="translated">当设置PRAGMA vdbe_trace=ON时,当P3操作数是指向结构体的指针而不是指向字符串的指针时,正确打印P3操作数的值。</target>
        </trans-unit>
        <trans-unit id="de58aafb2b793ff0f7f439bee5ca0476571bc42c" translate="yes" xml:space="preserve">
          <source>When the Query Planner Stability Guarantee (QPSG) is enabled SQLite will always pick the same query plan for any given SQL statement as long as:</source>
          <target state="translated">当启用查询计划器稳定性保证(QPSG)时,SQLite将始终为任何给定的SQL语句挑选相同的查询计划,只要。</target>
        </trans-unit>
        <trans-unit id="ea89f7d473effa3c1f787520608ed6a1d3dd75bc" translate="yes" xml:space="preserve">
          <source>When the REPLACE conflict resolution strategy deletes rows in order to satisfy a constraint, &lt;a href=&quot;lang_createtrigger&quot;&gt;delete triggers&lt;/a&gt; fire if and only if &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;recursive triggers&lt;/a&gt; are enabled.</source>
          <target state="translated">当REPLACE冲突解决策略为了满足约束条件而删除行时，仅当启用了&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;递归触发器时&lt;/a&gt;，&lt;a href=&quot;lang_createtrigger&quot;&gt;delete触发器&lt;/a&gt;才会触发。</target>
        </trans-unit>
        <trans-unit id="4ca0d858dd9858ff95b9e784a094d5524fe9f00c" translate="yes" xml:space="preserve">
          <source>When the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION compile-time option is activated, SQLite will suppress &quot;unknown function&quot; errors when running an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; or &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;. Instead of throwing an error, SQLite will insert a substitute no-op function named &quot;unknown()&quot;. The substitution of &quot;unknown()&quot; in place of unrecognized functions only occurs on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;, not on ordinary statements.</source>
          <target state="translated">激活SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION编译时选项后，SQLite将在运行&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;或&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;时抑制&amp;ldquo;未知函数&amp;rdquo;错误。 SQLite不会引发错误，而是会插入一个名为&amp;ldquo; unknown（）&amp;rdquo;的替代无操作函数。仅在&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;和&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;上发生&amp;ldquo; unknown（）&amp;rdquo;代替无法识别的函数的替换，而不是在普通语句上发生。</target>
        </trans-unit>
        <trans-unit id="18d1211c78f050ab2271d9386344a3bea2c6f673" translate="yes" xml:space="preserve">
          <source>When the SQLITE_SYNC_DATAONLY flag is used, it means that the sync operation only needs to flush data to mass storage. Inode information need not be flushed. If the lower four bits of the flag equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics. If the lower four bits equal SQLITE_SYNC_FULL, that means to use Mac OS X style fullsync instead of fsync().</source>
          <target state="translated">当使用SQLITE_SYNC_DATAONLY标志时,意味着同步操作只需要将数据刷新到大容量存储。不需要刷新节点信息。如果标志的低四位等于SQLITE_SYNC_NORMAL,表示要使用正常的fsync()语义。如果标志的低四位等于SQLITE_SYNC_FULL,表示使用Mac OS X风格的fullsync代替fsync()。</target>
        </trans-unit>
        <trans-unit id="985e39e22f124ec3b4d15128274a9355a9afbb19" translate="yes" xml:space="preserve">
          <source>When the WHERE is omitted from a DELETE statement and the table being deleted has no triggers, SQLite uses an optimization to erase the entire table content without having to visit each row of the table individually. This &quot;truncate&quot; optimization makes the delete run much faster. Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;version 3.6.5&lt;/a&gt; (2008-11-12), the truncate optimization also meant that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; will not actually return the number of deleted rows. That problem has been fixed as of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;version 3.6.5&lt;/a&gt; (2008-11-12).</source>
          <target state="translated">当从DELETE语句中省略WHERE并且被删除的表没有触发器时，SQLite使用优化来擦除整个表内容，而不必单独访问表的每一行。这种&amp;ldquo;截断&amp;rdquo;优化使删除运行更快。在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;版本3.6.5&lt;/a&gt;（2008-11-12）之前，截断优化还意味着&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;和&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口以及&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes编译指示&lt;/a&gt;实际上不会返回已删除的行数。从&lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;3.6.5版&lt;/a&gt;（2008-11-12）开始，此问题已修复。</target>
        </trans-unit>
        <trans-unit id="ed1319f0bc1a6521bcf2196280e7316235700141" translate="yes" xml:space="preserve">
          <source>When the above CREATE VIRTUAL TABLE statement is executed, swarmvtab binds the text value &quot;/home/user/app/databases/&quot; to the :dir parameter of the SQL statement before executing it.</source>
          <target state="translated">当执行上述CREATE VIRTUAL TABLE语句时,swarmvtab在执行前会将文本值&quot;/home/user/app/databases/&quot;绑定到SQL语句的:dir参数中。</target>
        </trans-unit>
        <trans-unit id="af84afd9d831ba7532e3be1008b7a2fa2d6de72c" translate="yes" xml:space="preserve">
          <source>When the auto-vacuum mode is 1 or &quot;full&quot;, the freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages at every transaction commit. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse.</source>
          <target state="translated">当自动真空模式为1或&amp;ldquo;完全&amp;rdquo;时，将空闲列表页面移到数据库文件的末尾，并且在每次事务提交时，数据库文件将被截断以删除空闲列表页面。但是请注意，自动清空只会截断文件中的空闲列表页面。自动真空不会像&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令那样对数据库进行碎片整理或重新打包单个数据库页面。实际上，由于自动抽真空会在文件内四处移动页面，因此实际上会使碎片变得更糟。</target>
        </trans-unit>
        <trans-unit id="ef4d832eb7039ef85ce7ded8003003dd3cc72641" translate="yes" xml:space="preserve">
          <source>When the auto_vacuum pragma is invoked with no arguments, it returns the current auto_vacuum mode.</source>
          <target state="translated">当调用auto_vacuum pragma时没有任何参数,它会返回当前的auto_vacuum模式。</target>
        </trans-unit>
        <trans-unit id="f2ce457b213b80c33d7ab3d10e7347a9c292b2e3" translate="yes" xml:space="preserve">
          <source>When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16(). The second argument is the database connection. The third argument is one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;, indicating the most desirable form of the collation sequence function required. The fourth parameter is the name of the required collation sequence.</source>
          <target state="translated">调用回调时，传递的第一个参数是第二个参数到sqlite3_collat​​ion_needed（）或sqlite3_collat​​ion_needed16（）的副本。第二个参数是数据库连接。第三个参数是&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE之一&lt;/a&gt;，指示所需的排序规则序列函数的最理想形式。第四个参数是所需整理顺序的名称。</target>
        </trans-unit>
        <trans-unit id="7ee3c7dd196b6cbe2c4c2e3d7d3e7a9d7a6a2b67" translate="yes" xml:space="preserve">
          <source>When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16(). The second argument is the database connection. The third argument is one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;, indicating the most desirable form of the collation sequence function required. The fourth parameter is the name of the required collation sequence.</source>
          <target state="translated">调用回调时，传递的第一个参数是第二个参数到sqlite3_collat​​ion_needed（）或sqlite3_collat​​ion_needed16（）的副本。第二个参数是数据库连接。第三个参数是&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE之一&lt;/a&gt;，指示所需的排序规则序列函数的最理想形式。第四个参数是所需整理顺序的名称。</target>
        </trans-unit>
        <trans-unit id="f0027db967a591c65d48dbd0afc84a797aef3887" translate="yes" xml:space="preserve">
          <source>When the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, that means the operation requested is ok. When the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.</source>
          <target state="translated">当回调返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;时，表示请求的操作正常。当回调返回&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY时&lt;/a&gt;，触发授权者的&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效调用将失败，并显示一条错误消息，说明访问被拒绝。</target>
        </trans-unit>
        <trans-unit id="1bae5c6c86ffd7028029909efdc71f4e4f816633" translate="yes" xml:space="preserve">
          <source>When the callback returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, that means the operation requested is ok. When the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt;, the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.</source>
          <target state="translated">当回调返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;时，表示请求的操作正常。当回调返回&lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY时&lt;/a&gt;，触发授权者的&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效调用将失败，并显示一条错误消息，说明访问被拒绝。</target>
        </trans-unit>
        <trans-unit id="2fc4782b077cfef78fd1da131f206927c4488a10" translate="yes" xml:space="preserve">
          <source>When the command-line shell and the core SQLite library are both compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; and SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE, then the shell has two commands used to turn on debugging facilities for the most intricate parts of the code generator - the logic dealing with SELECT statements and WHERE clauses, respectively. The &quot;.selecttrace&quot; and &quot;.wheretrace&quot; commands each take a numeric argument which can be expressed in hexadecimal. Each bit turns on various parts of debugging. Values of &quot;0xfff&quot; and &quot;0xff&quot; are commonly used. Use an argument of &quot;0&quot; to turn all tracing output back off.</source>
          <target state="translated">当命令行外壳程序和核心SQLite库都使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;和SQLITE_ENABLE_SELECTTRACE和SQLITE_ENABLE_WHERETRACE 编译时，外壳程序将使用两个命令打开代码生成器最复杂部分的调试功能-处理SELECT语句和分别是WHERE子句。 &amp;ldquo; .selecttrace&amp;rdquo;和&amp;ldquo; .wheretrace&amp;rdquo;命令均采用一个数字参数，该参数可以用十六进制表示。每一位都打开调试的各个部分。通常使用&amp;ldquo; 0xfff&amp;rdquo;和&amp;ldquo; 0xff&amp;rdquo;的值。使用参数&amp;ldquo; 0&amp;rdquo;关闭所有跟踪输出。</target>
        </trans-unit>
        <trans-unit id="b723658445ef923fc3e6ed08d931b577b65bc748" translate="yes" xml:space="preserve">
          <source>When the commit hook callback routine returns zero, the &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operation is allowed to continue normally. If the commit hook returns non-zero, then the &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; is converted into a &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.</source>
          <target state="translated">当提交挂钩回调例程返回零时，将允许&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作正常继续。如果提交钩子返回非零值，则将&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;转换为&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;。回滚钩在回滚上调用，回滚是由提交钩子返回非零而导致的，就像其他任何回滚一样。</target>
        </trans-unit>
        <trans-unit id="cc0bc375382d425cd0a289c0d31fef27fb453ac2" translate="yes" xml:space="preserve">
          <source>When the commit hook callback routine returns zero, the &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operation is allowed to continue normally. If the commit hook returns non-zero, then the &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; is converted into a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.</source>
          <target state="translated">当提交挂钩回调例程返回零时，将允许&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作正常继续。如果提交钩子返回非零值，则将&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;转换为&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;。回滚钩在回滚上调用，回滚是由提交钩子返回非零而导致的，就像其他任何回滚一样。</target>
        </trans-unit>
        <trans-unit id="ebd93d5d1aa49a1f19ce4e8d40b4dcf35920ce66" translate="yes" xml:space="preserve">
          <source>When the defer_foreign_keys &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is on, enforcement of all &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; is delayed until the outermost transaction is committed. The defer_foreign_keys pragma defaults to OFF so that foreign key constraints are only deferred if they are created as &quot;DEFERRABLE INITIALLY DEFERRED&quot;. The defer_foreign_keys pragma is automatically switched off at each COMMIT or ROLLBACK. Hence, the defer_foreign_keys pragma must be separately enabled for each transaction. This pragma is only meaningful if foreign key constraints are enabled, of course.</source>
          <target state="translated">当defer_foreign_keys &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;处于打开状态时，所有&lt;a href=&quot;foreignkeys&quot;&gt;外键约束的实施&lt;/a&gt;都会延迟到最外层事务提交之前。 defer_foreign_keys编译指示默认为OFF，以便仅在将外键约束创建为&amp;ldquo; DEFERRABLE INITIALIALDEFERRED&amp;rdquo;时才将其推迟。在每个COMMIT或ROLLBACK处，都会自动关闭defer_foreign_keys编译指示。因此，必须为每个事务分别启用defer_foreign_keys编译指示。当然，只有在启用了外键约束的情况下，这种编译指示才有意义。</target>
        </trans-unit>
        <trans-unit id="f4cc14d79785a0eab23a6d9f7db6c91e125bbb70" translate="yes" xml:space="preserve">
          <source>When the end-user executes a DML or DDL SQL statement to modify the database schema or content, SQLite is required to update the database file image to reflect the new database state. This involves modifying the content of, appending or truncating one of more database file pages. Instead of modifying the database file directly using the VFS interface, changes are first buffered within the</source>
          <target state="translated">当终端用户执行DML或DDL SQL语句来修改数据库模式或内容时,需要SQLite更新数据库文件映像以反映新的数据库状态。这涉及到修改、追加或截断一个或多个数据库文件页的内容。不直接使用VFS接口修改数据库文件,而是先将修改内容缓冲在</target>
        </trans-unit>
        <trans-unit id="e72b791ecc5f4b31b8f87177039bb7c97a3857b6" translate="yes" xml:space="preserve">
          <source>When the languageid option is present, it specifies the name of another &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; that is added to the FTS4 table and which is used to specify the language stored in each row of the FTS4 table. The name of the languageid hidden column must be distinct from all other column names in the FTS4 table. Example:</source>
          <target state="translated">当languageid选项存在时，它指定添加到FTS4表的另一个&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏列&lt;/a&gt;的名称，该列用于指定存储在FTS4表的每一行中的语言。languageid隐藏列的名称必须与FTS4表中的所有其他列名称不同。例：</target>
        </trans-unit>
        <trans-unit id="b1e38f0c1dabd3714310eefb8d8a6cff4de89d44" translate="yes" xml:space="preserve">
          <source>When the languageid option is used, SQLite invokes the xLanguageid() on the sqlite3_tokenizer_module object immediately after the object is created in order to pass in the language id that the tokenizer should use. The xLanguageid() method will never be called more than once for any single tokenizer object. The fact that different languages might be tokenized differently is one reason why no single FTS query can return rows with different languageid values.</source>
          <target state="translated">当使用 languageid 选项时,SQLite 会在创建 sqlite3_tokenizer_module 对象后立即调用 xLanguageid()方法,以传递 tokenizer 应该使用的语言 id。xLanguageid()方法对于任何一个tokenizer对象都不会被调用超过一次。不同的语言可能会有不同的标记,这也是为什么没有一个FTS查询可以返回不同languageid值的记录的原因之一。</target>
        </trans-unit>
        <trans-unit id="9aa0a1cde451597b6df45b6c556052ff5eb9c927" translate="yes" xml:space="preserve">
          <source>When the last connection to a particular database is closing, that connection will acquire an exclusive lock for a short time while it cleans up the WAL and shared-memory files. If a second database tries to open and query the database while the first connection is still in the middle of its cleanup process, the second connection might get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">与特定数据库的最后一个连接关闭时，该连接将在清除WAL和共享内存文件的同时获得排他锁一小段时间。如果在第一个连接仍处于其清理过程的中间时，另一个数据库尝试打开并查询该数据库，则第二个连接可能会收到&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="721a001d639a4fa0bf082ab41646b624fe82e4a7" translate="yes" xml:space="preserve">
          <source>When the legacy_file_format pragma is issued with no argument, it returns the setting of the flag. This pragma does &lt;u&gt;not&lt;/u&gt; tell which file format the current database is using; it tells what format will be used by any newly created databases.</source>
          <target state="translated">当不带任何参数发出legacy_file_format编译指示时，它将返回标志的设置。该编译并&lt;u&gt;没有&lt;/u&gt;告诉它的文件格式，当前数据库是使用; 它告诉新创建的数据库将使用哪种格式。</target>
        </trans-unit>
        <trans-unit id="6a4f25a9dc00e5fa108cea204a933cd9b0d930ee" translate="yes" xml:space="preserve">
          <source>When the locking_mode pragma specifies a particular database, for example:</source>
          <target state="translated">当 locking_mode pragma 指定了一个特定的数据库时,例如。</target>
        </trans-unit>
        <trans-unit id="65958bd909cd29c71d7062800a7ff7cb762631b5" translate="yes" xml:space="preserve">
          <source>When the name of the database file handed to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; is an empty string, then a new temporary file is created to hold the database.</source>
          <target state="translated">当传递给&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;或&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;的数据库文件的名称为空字符串时，则会创建一个新的临时文件来保存数据库。</target>
        </trans-unit>
        <trans-unit id="a5261e01bfb3de59bf05674e0d1d120422019175" translate="yes" xml:space="preserve">
          <source>When the original content of a database page is written into the rollback journal (as shown in &lt;a href=&quot;#section_3_5&quot;&gt;section 3.5&lt;/a&gt;), SQLite always writes a complete sector of data, even if the page size of the database is smaller than the sector size. Historically, the sector size in SQLite has been hard coded to 512 bytes and since the minimum page size is also 512 bytes, this has never been an issue. But beginning with SQLite version 3.3.14, it is possible for SQLite to use mass storage devices with a sector size larger than 512 bytes. So, beginning with version 3.3.14, whenever any page within a sector is written into the journal file, all pages in that same sector are stored with it.</source>
          <target state="translated">当数据库页面的原始内容写入回滚日志（如&lt;a href=&quot;#section_3_5&quot;&gt;第3.5节&lt;/a&gt;所示）时，即使数据库的页面大小小于扇区大小，SQLite也会始终写入完整的数据扇区。从历史上看，SQLite中的扇区大小已被硬编码为512字节，并且由于最小页面大小也是512字节，所以这从来就不是问题。但是从SQLite版本3.3.14开始，SQLite可以使用扇区大小大于512字节的大容量存储设备。因此，从版本3.3.14开始，每将一个扇区中的任何页面写入日记文件，该扇区中的所有页面都将与该文件一起存储。</target>
        </trans-unit>
        <trans-unit id="24eb3cec7d166e89084624729f4f076ba57699a6" translate="yes" xml:space="preserve">
          <source>When the payload of a b-tree cell is too large for the b-tree page, the surplus is spilled onto overflow pages. Overflow pages form a linked list. The first four bytes of each overflow page are a big-endian integer which is the page number of the next page in the chain, or zero for the final page in the chain. The fifth byte through the last usable byte are used to hold overflow content.</source>
          <target state="translated">当b树单元格的有效载荷对b树页来说过大时,多余的部分会溢出到溢出页上。溢出页形成一个链接列表。每一个溢出页的前四个字节是一个大字节整数,它是链中下一页的页码,或链中最后一页的页码为0。第五个字节到最后一个可用字节用于保存溢出内容。</target>
        </trans-unit>
        <trans-unit id="7a9dfbcbb999703cb3d0ac4b512f0bf41cd8632a" translate="yes" xml:space="preserve">
          <source>When the private repository is created by cloning, incorporating new public SQLite releases becomes much easier too. To pull in all of the latest changes from the public SQLite repository, simply move into the open check-out and do:</source>
          <target state="translated">当私有仓库是通过克隆创建的时候,纳入新的公共SQLite版本也变得更加容易。要从公共SQLite仓库中拉入所有最新的变化,只需移入开放的签出,然后做。</target>
        </trans-unit>
        <trans-unit id="5be9656f401ac8804b83b6da6efba9e4ec09be72" translate="yes" xml:space="preserve">
          <source>When the result of a sub-select is a scalar, a single private memory cell can be used, as shown in the previous example. But when the result of a sub-select is a vector, such as when the sub-select is the right-hand operand of IN or NOT IN, a different approach is needed. In this case, the result of the sub-select is stored in a transient table and the contents of that table are tested using the Found or NotFound operators. Consider this example:</source>
          <target state="translated">当一个子选择的结果是一个标量时,可以使用一个私有内存单元,如前面的例子所示。但是当子选择的结果是一个向量时,例如当子选择是IN或NOT IN的右手操作数时,就需要采用不同的方法。在这种情况下,子选择的结果被存储在一个瞬时表中,并使用Found或NotFound操作符测试该表的内容。考虑这个例子。</target>
        </trans-unit>
        <trans-unit id="7f4bad19a801621b1eda251a27bffb8486beb1b2" translate="yes" xml:space="preserve">
          <source>When the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces. When that happens, the second error will be reported since these interfaces always report the most recent result. To avoid this, each thread can obtain exclusive use of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D by invoking &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;(&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) before beginning to use D and invoking &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;(&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) after all calls to the interfaces listed here are completed.</source>
          <target state="translated">当使用串行化&lt;a href=&quot;../threadsafe&quot;&gt;线程模式时&lt;/a&gt;，可能是在第一个错误的时间和对这些接口的调用之间的另一个线程上发生了第二个错误。发生这种情况时，将报告第二个错误，因为这些接口始终报告最新结果。为了避免这种情况，每个线程都可以获取独占使用的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接，&lt;/a&gt;通过调用d &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;（&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;开始使用d和调用之前（d））&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;（&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;来完成这里列出的接口的所有调用后，（d））。</target>
        </trans-unit>
        <trans-unit id="6ad35aaaabcdc79e64145d3f60787d98e09a5e23" translate="yes" xml:space="preserve">
          <source>When the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces. When that happens, the second error will be reported since these interfaces always report the most recent result. To avoid this, each thread can obtain exclusive use of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D by invoking &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;(&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) before beginning to use D and invoking &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;(&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) after all calls to the interfaces listed here are completed.</source>
          <target state="translated">当使用串行化&lt;a href=&quot;threadsafe&quot;&gt;线程模式时&lt;/a&gt;，可能是在第一个错误的时间和对这些接口的调用之间的另一个线程上发生了第二个错误。发生这种情况时，将报告第二个错误，因为这些接口始终报告最新结果。为了避免这种情况，每个线程都可以获取独占使用的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接，&lt;/a&gt;通过调用d &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;（&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;开始使用d和调用之前（d））&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;（&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;来完成这里列出的接口的所有调用后，（d））。</target>
        </trans-unit>
        <trans-unit id="ae5d894865b3485bb3f0df9031d208d9c0c832c5" translate="yes" xml:space="preserve">
          <source>When the size of payload for a cell exceeds a certain threshold (to be defined later) then only the first few bytes of the payload are stored on the b-tree page and the balance is stored in a linked list of content overflow pages.</source>
          <target state="translated">当一个单元格的有效载荷大小超过一定的阈值(稍后定义)时,那么只有有效载荷的前几个字节存储在b树页面上,其余的字节存储在内容溢出页面的链接列表中。</target>
        </trans-unit>
        <trans-unit id="959baafa9a7af49bb6654912e390fd8adf72f9f7" translate="yes" xml:space="preserve">
          <source>When the steps above are used, SQLite will shorten filename extensions by only using the last 3 characters of the extension. Thus, for example, a file that would normally be called &quot;&lt;code&gt;app.db-journal&lt;/code&gt;&quot; is shortened to just &quot;&lt;code&gt;app.nal&lt;/code&gt;&quot;. Similarly, &quot;&lt;code&gt;app.db-wal&lt;/code&gt;&quot; will become &quot;&lt;code&gt;app.wal&lt;/code&gt;&quot; and &quot;&lt;code&gt;app.db-shm&lt;/code&gt;&quot; becomes &quot;&lt;code&gt;app.shm&lt;/code&gt;&quot;.</source>
          <target state="translated">使用上述步骤时，SQLite将仅使用扩展名的后3个字符来缩短文件扩展名。因此，例如，通常称为&amp;ldquo; &lt;code&gt;app.db-journal&lt;/code&gt; &amp;rdquo; 的文件将缩短为&amp;ldquo; &lt;code&gt;app.nal&lt;/code&gt; &amp;rdquo;。同样，&amp;ldquo; &lt;code&gt;app.db-wal&lt;/code&gt; &amp;rdquo;将变为&amp;ldquo; &lt;code&gt;app.wal&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;app.db-shm&lt;/code&gt; &amp;rdquo;将变为&amp;ldquo; &lt;code&gt;app.shm&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d643d5a9185e437164a5f2a6216624f98b3e6f19" translate="yes" xml:space="preserve">
          <source>When the temp_store_directory setting is changed, all existing temporary tables, indices, triggers, and viewers in the database connection that issued the pragma are immediately deleted. In practice, temp_store_directory should be set immediately after the first database connection for a process is opened. If the temp_store_directory is changed for one database connection while other database connections are open in the same process, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">当temp_store_directory设置被改变时,发出该pragma的数据库连接中所有现有的临时表、索引、触发器和查看器都会被立即删除。在实践中,temp_store_directory应该在进程的第一个数据库连接被打开后立即设置。如果一个数据库连接的temp_store_directory被改变,而同一进程中的其他数据库连接还在打开,那么这种行为是没有定义的,而且可能是不可取的。</target>
        </trans-unit>
        <trans-unit id="343b5a2825eceb4a3f5768433d668b582d6b47c5" translate="yes" xml:space="preserve">
          <source>When the unlock-notify callback is invoked, which may be before the thread that called &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; begins waiting for the asynchronous signal, it does the following:</source>
          <target state="translated">当调用解锁通知回调时（可能在调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;的线程开始等待异步信号之前），它将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b97add61bb2e4ac375ed3ff0cd6f248d8d0b370d" translate="yes" xml:space="preserve">
          <source>When the unlock-notify callback is issued, it is issued from within a call to sqlite3_step() (or sqlite3_close()) associated with the blocking connection. It is illegal to invoke any sqlite3_XXX() API functions from within an unlock-notify callback. The expected use is that the unlock-notify callback will signal some other waiting thread or schedule some action to take place later.</source>
          <target state="translated">当解锁通知回调被发出时,它是从与阻塞连接相关联的sqlite3_step()(或sqlite3_close())的调用中发出的。从解锁通知回调中调用任何sqlite3_XXX()API函数都是非法的。预期的用途是解锁-通知回调将向其他等待的线程发出信号,或者安排稍后进行的一些操作。</target>
        </trans-unit>
        <trans-unit id="c2be91d4a681af8f031fb2096b9f2fe184670aea" translate="yes" xml:space="preserve">
          <source>When the user does a &quot;File/Save&quot;, instead of overwriting the modified slides, the application can now make new entries in the SLIDE table for just those slides that have been added or altered. Then it creates a new entry in the VERSION table containing the revised manifest.</source>
          <target state="translated">当用户进行 &quot;文件/保存 &quot;时,应用程序现在可以在SLIDE表中为新增或更改的幻灯片创建新条目,而不是覆盖修改后的幻灯片。然后,它在 &quot;版本 &quot;表中创建一个新条目,其中包含修改后的清单。</target>
        </trans-unit>
        <trans-unit id="f5e82ec54c65035c07f8ba3e1f179ebb03a74e94" translate="yes" xml:space="preserve">
          <source>When the user presses the Undo button, invoke undo::undo. Invoke undo::redo when the user presses the Redo button.</source>
          <target state="translated">当用户按下Undo按钮时,调用undo::undo。当用户按下重做按钮时,调用undo::redo。</target>
        </trans-unit>
        <trans-unit id="1add060c475b241a7872da34e121430f601e3935" translate="yes" xml:space="preserve">
          <source>When the user scrolls down, the application needs to find the second set of 7 entries. One way to do this is to use the OFFSET clause:</source>
          <target state="translated">当用户向下滚动时,应用程序需要找到第二组7个条目。一种方法是使用OFFSET子句。</target>
        </trans-unit>
        <trans-unit id="591f64272639e3cef4d6af5b9d0166c866e319e8" translate="yes" xml:space="preserve">
          <source>When the value of auto-vacuum is 2 or &quot;incremental&quot; then the additional information needed to do auto-vacuuming is stored in the database file but auto-vacuuming does not occur automatically at each commit as it does with auto_vacuum=full. In incremental mode, the separate &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; pragma must be invoked to cause the auto-vacuum to occur.</source>
          <target state="translated">当auto-vacuum的值为2或&amp;ldquo; incremental&amp;rdquo;时，执行自动真空处理所需的其他信息存储在数据库文件中，但是自动提交不会像auto_vacuum = full那样在每次提交时自动发生。在增量模式下，必须调用单独的&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;增量&lt;/a&gt;变量_vacuum才能导致自动真空发生。</target>
        </trans-unit>
        <trans-unit id="681fab88c0ae33e7ccdb7976051e9eb1cbf3ae58" translate="yes" xml:space="preserve">
          <source>When the value returned to V is a string, space to hold that string is managed by the prepared statement S and will be automatically freed when S is finalized.</source>
          <target state="translated">当返回给V的值是一个字符串时,存放该字符串的空间由准备好的语句S管理,当S最终确定时将自动释放。</target>
        </trans-unit>
        <trans-unit id="676274b5ee061976c65b6934ef4f5a4fbd2b341f" translate="yes" xml:space="preserve">
          <source>When the wait_for_unlock_notify() thread is ready to begin waiting for the unlock-notify callback to arrive, it:</source>
          <target state="translated">当wait_for_unlock_notify()线程准备好开始等待解锁回调的到来时,它。</target>
        </trans-unit>
        <trans-unit id="10e245699dbb244b04267cf604539f618d05ec7d" translate="yes" xml:space="preserve">
          <source>When there are &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt; and no database is specified in the pragma, all databases have their secure-delete setting altered. The secure-delete setting for newly attached databases is the setting of the main database at the time the ATTACH command is evaluated.</source>
          <target state="translated">如果存在&lt;a href=&quot;lang_attach&quot;&gt;附加数据库&lt;/a&gt;，但在编译指示中未指定任何数据库，则所有数据库的安全删除设置都会更改。新连接的数据库的安全删除设置是评估ATTACH命令时主数据库的设置。</target>
        </trans-unit>
        <trans-unit id="0e9e3d42daf92400d82986bf5b6a37eceed3828b" translate="yes" xml:space="preserve">
          <source>When this C-preprocessor macro is defined, SQLite includes some additional APIs that provide convenient access to meta-data about tables and queries. The APIs that are enabled by this option are:</source>
          <target state="translated">当定义了这个C-预处理器宏后,SQLite包含了一些额外的API,可以方便地访问有关表和查询的元数据。该选项启用的API有:?</target>
        </trans-unit>
        <trans-unit id="80b17e344d3336c6d06fda5d24a646acabeba334" translate="yes" xml:space="preserve">
          <source>When this function is called, the requested changeset is created using both the accumulated records and the current contents of the database file. Specifically:</source>
          <target state="translated">调用该函数时,使用累积的记录和数据库文件的当前内容创建所要求的变更集。具体来说。</target>
        </trans-unit>
        <trans-unit id="bb6586ef4ac72fe83222f833701701fa936feb91" translate="yes" xml:space="preserve">
          <source>When this is defined, the library does not respect the special database name &quot;:memory:&quot; (normally used to create an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt;). If &quot;:memory:&quot; is passed to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, a file with this name will be opened or created.</source>
          <target state="translated">定义此名称后，库将不遵守特殊的数据库名称&amp;ldquo;：memory：&amp;rdquo;（通常用于创建&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;）。如果将&amp;ldquo;：memory：&amp;rdquo;传递给&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;，则将打开或创建具有该名称的文件。</target>
        </trans-unit>
        <trans-unit id="9dadcf039e49017d2804dcadcaa92a2ed3ad29c4" translate="yes" xml:space="preserve">
          <source>When this is done, no disk file is opened. Instead, a new database is created purely in memory. The database ceases to exist as soon as the database connection is closed. Every :memory: database is distinct from every other. So, opening two database connections each with the filename &quot;:memory:&quot; will create two independent in-memory databases.</source>
          <target state="translated">当这样做的时候,没有打开任何磁盘文件,而是纯粹在内存中创建一个新的数据库。而是纯粹在内存中创建一个新的数据库。一旦关闭数据库连接,数据库就不复存在。每一个:内存:数据库都与其他数据库不同。因此,打开两个数据库连接,每个连接的文件名都是&quot;:memory:&quot;,将创建两个独立的内存数据库。</target>
        </trans-unit>
        <trans-unit id="3c612857bb421bf9acf60c3aa66716a6889b3ef9" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, the &lt;a href=&quot;geopoly&quot;&gt;Geopoly extension&lt;/a&gt; is included in the build.</source>
          <target state="translated">当这个选项在定义&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;时，&lt;a href=&quot;geopoly&quot;&gt;Geopoly扩展&lt;/a&gt;包含在构建中。</target>
        </trans-unit>
        <trans-unit id="63b0e43097f54c25e3fe1c915efb4112c36433a7" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, the &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt; are added to the build automatically.</source>
          <target state="translated">当在&lt;a href=&quot;amalgamation&quot;&gt;amalgamation中&lt;/a&gt;定义此选项时，&lt;a href=&quot;json1&quot;&gt;JSON SQL函数&lt;/a&gt;将自动添加到构建中。</target>
        </trans-unit>
        <trans-unit id="e638c666c14acfed829f561f8cba0197feda3c02" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, version 3 of the full-text search engine is added to the build automatically.</source>
          <target state="translated">在&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;定义了此选项后，全文搜索引擎的版本3将自动添加到构建中。</target>
        </trans-unit>
        <trans-unit id="4a19c3b55092d529dbfec770d25a58e2ca349990" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, versions 3 and 4 of the full-text search engine is added to the build automatically.</source>
          <target state="translated">当在&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;定义了此选项时，全文搜索引擎的版本3和4将自动添加到构建中。</target>
        </trans-unit>
        <trans-unit id="818c376822c0fec952ac59c4332327f0b7edf7db" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, versions 5 of the full-text search engine (&lt;a href=&quot;fts5&quot;&gt;fts5&lt;/a&gt;) is added to the build automatically.</source>
          <target state="translated">在&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;定义此选项后，全文搜索引擎（&lt;a href=&quot;fts5&quot;&gt;fts5&lt;/a&gt;）的版本5 将自动添加到构建中。</target>
        </trans-unit>
        <trans-unit id="6540ae2c93aba220c991dfe94132dd0f63e59810" translate="yes" xml:space="preserve">
          <source>When this option is defined, an optimization that accelerates counting all entries in a table (in other words, an optimization that helps &quot;SELECT count(*) FROM table&quot; run faster) is omitted.</source>
          <target state="translated">当定义这个选项时,会省略一个加速计算表中所有条目的优化(换句话说,是帮助 &quot;SELECT count(*)FROM表 &quot;运行速度更快的优化)。</target>
        </trans-unit>
        <trans-unit id="53f492f476a20550a057a12a97c6de3049506d26" translate="yes" xml:space="preserve">
          <source>When this option is defined, it is not possible to specify a blob in an SQL statement using the X'ABCD' syntax.</source>
          <target state="translated">当定义了这个选项后,就不能在SQL语句中使用X'ABCD'语法指定blob。</target>
        </trans-unit>
        <trans-unit id="afad8ea069f34c202a3e893171214a5aee9a0bc0" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command is not included in the library. Executing an &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">定义此选项后，&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令不包含在库中。执行&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;语句会导致解析错误。</target>
        </trans-unit>
        <trans-unit id="523431ac75b0212a06c55ac385d13beeedacb305" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is omitted from the build.</source>
          <target state="translated">定义此选项后，构建中将省略&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="594c7ba3832aba3180a92cd74c6f75ba44ce7aaf" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands are omitted from the build.</source>
          <target state="translated">定义此选项后，将在构建中省略&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;和&lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="8c1b711bd5c9246457da19791ca7b6dcb97ca5d2" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; command is not included in the library. Executing a &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">定义此选项后，&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;命令不包括在库中。执行&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;语句会导致解析错误。</target>
        </trans-unit>
        <trans-unit id="d2955f48905e9a8f58404484936cbf538b367034" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is not included in the library. Executing a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">定义此选项后，&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令不包含在库中。执行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;语句会导致解析错误。</target>
        </trans-unit>
        <trans-unit id="f189302742f5abf29172e2258e929a776e965db1" translate="yes" xml:space="preserve">
          <source>When this option is present, content contained in &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; of the database file is read directly from disk, bypassing the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;page cache&lt;/a&gt;, during read transactions. In applications that do a lot of reads of large BLOBs, this option might improve read performance.</source>
          <target state="translated">如果存在此选项，则在读取事务期间，绕过&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;页面缓存&lt;/a&gt;直接从磁盘直接读取数据库文件&lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;溢出页面&lt;/a&gt;中包含的内容。在对大型BLOB进行大量读取的应用程序中，此选项可能会提高读取性能。</target>
        </trans-unit>
        <trans-unit id="05b6e594e4163ec73c013e9bc0bd201fec26dfcd" translate="yes" xml:space="preserve">
          <source>When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</source>
          <target state="translated">当此编译指示打开并且&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;标志关闭时，可以使用普通的&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句更改&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;表。&lt;b&gt;警告：&lt;/b&gt;滥用该编译指示很容易导致&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;数据库文件损坏&lt;/a&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="155915a2fa0e144a28d6f3909aae6b1d4f21b4e3" translate="yes" xml:space="preserve">
          <source>When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24dad918c280682da96633e2cfedee92e2eb063" translate="yes" xml:space="preserve">
          <source>When three or more simple SELECTs are connected into a compound SELECT, they group from left to right. In other words, if &quot;A&quot;, &quot;B&quot; and &quot;C&quot; are all simple SELECT statements, (A op B op C) is processed as ((A op B) op C).</source>
          <target state="translated">当三个或三个以上的简单SELECT连接成一个复合SELECT时,它们从左到右进行分组。换句话说,如果 &quot;A&quot;、&quot;B&quot;、&quot;C &quot;都是简单的SELECT语句,则(A op B op C)处理为((A op B)op C)。</target>
        </trans-unit>
        <trans-unit id="356d225c15feaa12023968822303a920dbc04787" translate="yes" xml:space="preserve">
          <source>When to use WITHOUT ROWID</source>
          <target state="translated">何时使用 WITHOUT ROWID</target>
        </trans-unit>
        <trans-unit id="dde1df06f3e28fa2c213af6dc7ee811081acdcc1" translate="yes" xml:space="preserve">
          <source>When two BLOB values are compared, the result is determined using memcmp().</source>
          <target state="translated">当比较两个BLOB值时,使用memcmp()确定结果。</target>
        </trans-unit>
        <trans-unit id="3b7477ad4142a17a91342e502a66554eeeaf182c" translate="yes" xml:space="preserve">
          <source>When two or more connections access the same database in shared-cache mode, read and write (shared and exclusive) locks on individual tables are used to ensure that concurrently executing transactions are kept isolated. Before writing to a table, a write (exclusive) lock must be obtained on that table. Before reading, a read (shared) lock must be obtained. A connection releases all held table locks when it concludes its transaction. If a connection cannot obtain a required lock, then the call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED.</source>
          <target state="translated">当两个或多个连接以共享缓存模式访问同一数据库时，将使用单个表上的读写锁（共享和互斥）来确保并发执行的事务保持隔离。写入表之前，必须在该表上获得写（独占）锁。在读取之前，必须获得读取（共享）锁。连接在结束事务时将释放所有保留的表锁。如果连接无法获得所需的锁定，则对&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;的调用将返回SQLITE_LOCKED。</target>
        </trans-unit>
        <trans-unit id="384b14b240303a8eaa803ae4a95a246eb3eb3a95" translate="yes" xml:space="preserve">
          <source>When two or more connections use a shared-cache, locks are used to serialize concurrent access attempts on a per-table basis. Tables support two types of locks, &quot;read-locks&quot; and &quot;write-locks&quot;. Locks are granted to connections - at any one time, each database connection has either a read-lock, write-lock or no lock on each database table.</source>
          <target state="translated">当两个或多个连接使用共享缓存时,锁用于在每个表的基础上序列化并发访问尝试。表支持两种类型的锁,&quot;读-锁 &quot;和 &quot;写-锁&quot;。锁被授予连接--在任何时候,每个数据库连接在每个数据库表上都有读锁、写锁或无锁。</target>
        </trans-unit>
        <trans-unit id="9ef3f52e6658347244503cf695a84d552443a0f6" translate="yes" xml:space="preserve">
          <source>When unlocking, the same SHARED or EXCLUSIVE flag must be supplied as was given on the corresponding lock.</source>
          <target state="translated">当解锁时,必须提供与对应的锁相同的SHARED或EXCLUSIVE标志。</target>
        </trans-unit>
        <trans-unit id="c942e92dfd8f19ebf7cd74cbba74f891e087e57f" translate="yes" xml:space="preserve">
          <source>When updating the database file, SQLite always makes a copy of the page content into heap memory before modifying the page. This is necessary for two reasons. First, changes to the database are not supposed to be visible to other processes until after the transaction commits and so the changes must occur in private memory. Second, SQLite uses a read-only memory map to prevent stray pointers in the application from overwriting and corrupting the database file.</source>
          <target state="translated">在更新数据库文件时,SQLite总是在修改页面之前将页面内容复制到堆内存中。这是必要的,原因有二。首先,对数据库的修改在事务提交后才应该对其他进程可见,因此修改必须发生在私有内存中。其次,SQLite使用只读内存映射,以防止应用程序中的杂散指针覆盖和破坏数据库文件。</target>
        </trans-unit>
        <trans-unit id="321ab4dcceec298b077cdbf468b4b448206d5be8" translate="yes" xml:space="preserve">
          <source>When used in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION feature allows SQL text that contains application-defined functions to be pasted into the shell for analysis and debugging without having to create and load an extension that implements the application-defined functions.</source>
          <target state="translated">当在&lt;a href=&quot;cli&quot;&gt;命令行外壳中使用时&lt;/a&gt;，SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION功能允许将包含应用程序定义的函数的SQL文本粘贴到外壳中进行分析和调试，而不必创建和加载实现应用程序定义的函数的扩展。</target>
        </trans-unit>
        <trans-unit id="4fb531d1e034498892c1e8ba5b02ac3bc138fb71" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; map the database file read-only so that stray pointers and/or array overruns in the application cannot accidentally modify the database file.</source>
          <target state="translated">使用&lt;a href=&quot;mmap&quot;&gt;内存映射的I / O&lt;/a&gt;映射时，数据库文件是只读的，因此应用程序中的杂散指针和/或数组溢出不会意外地修改数据库文件。</target>
        </trans-unit>
        <trans-unit id="6bcae413d7ef24ed4791d379c4695938ecb30984" translate="yes" xml:space="preserve">
          <source>When using FTS4, specifying a column name that contains an &quot;=&quot; character and is not either a &quot;tokenize=*&quot; specification or a recognized FTS4 option is an error. With FTS3, the first token in the unrecognized directive is interpreted as a column name. Similarly, specifying multiple &quot;tokenize=*&quot; directives in a single table declaration is an error when using FTS4, whereas the second and subsequent &quot;tokenize=*&quot; directives are interpreted as column names by FTS3. For example:</source>
          <target state="translated">当使用FTS4时,如果指定的列名包含&quot;=&quot;字符,并且不是 &quot;tokenize=*&quot;规范或公认的FTS4选项,则会出现错误。在使用FTS3时,未被认可的指令中的第一个token会被解释为列名。同样,在一个表声明中指定多个 &quot;tokenize=*&quot;指令,在使用FTS4时也是一个错误,而FTS3会将第二个和后续的 &quot;tokenize=*&quot;指令解释为列名。例如</target>
        </trans-unit>
        <trans-unit id="a2854ef2a0e9879ca0973bfbdbeb94518a7782b5" translate="yes" xml:space="preserve">
          <source>When using SQLite as a shared library, an application can test to see whether or not mutexes have been disabled using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; API. Applications that link against SQLite at run-time and use SQLite from multiple threads should probably check this API to make sure they did not accidentally get linked against a version of the SQLite library that has its mutexes disabled. Single-threaded applications will, of course, work correctly regardless of whether or not SQLite is configured to be threadsafe, though they will be a little bit faster when using versions of SQLite with mutexes disabled.</source>
          <target state="translated">将SQLite用作共享库时，应用程序可以测试使用&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt; API 是否禁用了互斥锁。在运行时链接到SQLite并从多个线程使用SQLite的应用程序可能应该检查此API，以确保它们不会意外地链接到已禁用其互斥锁的SQLite库的版本。当然，单线程应用程序将正确运行，而不管SQLite是否配置为线程安全的，尽管使用禁用互斥锁的SQLite版本时，单线程应用程序的运行速度会快一些。</target>
        </trans-unit>
        <trans-unit id="baabf02615564e01474304f4466f9fe87599218a" translate="yes" xml:space="preserve">
          <source>When using an index on an expression, try to use expression values already available in the index, rather than loading the original columns and recomputing the expression.</source>
          <target state="translated">在表达式上使用索引时,尽量使用索引中已有的表达式值,而不是加载原始列并重新计算表达式。</target>
        </trans-unit>
        <trans-unit id="468b6859516cde0950db73781d0176e06ba0111f" translate="yes" xml:space="preserve">
          <source>When using methods (2) or (3), it is important that the tokenizer only provide synonyms when tokenizing document text (method (2)) or query text (method (3)), not both. Doing so will not cause any errors, but is inefficient.</source>
          <target state="translated">当使用方法(2)或(3)时,重要的是tokenizer只在标记文档文本(方法(2))或查询文本(方法(3))时提供同义词,而不是同时提供。这样做不会造成任何错误,但效率很低。</target>
        </trans-unit>
        <trans-unit id="88fac7db3e9db07076df4610515cb23f9340b834" translate="yes" xml:space="preserve">
          <source>When using the enhanced query syntax, parenthesis may be used to override the default precedence of the various operators. For example:</source>
          <target state="translated">当使用增强型查询语法时,可以使用括号来覆盖各种运算符的默认优先级。例如:</target>
        </trans-unit>
        <trans-unit id="1505c3324cb54c87924929ab65d11580dc89a0fd" translate="yes" xml:space="preserve">
          <source>When wrongful thoughts come into your heart, dash them against Christ immediately.</source>
          <target state="translated">当错误的念头进入你的心里时,要立即将它们冲向基督。</target>
        </trans-unit>
        <trans-unit id="5d95aef3b20c2c80bafbf5f8ecbb1090e555f684" translate="yes" xml:space="preserve">
          <source>When xSavepoint(X,N) is invoked, that is a signal to the virtual table X that it should save its current state as savepoint N. A subsequent call to xRollbackTo(X,R) means that the state of the virtual table should return to what it was when xSavepoint(X,R) was last called. The call to xRollbackTo(X,R) will invalidate all savepoints with N&amp;gt;R; none of the invalided savepoints will be rolled back or released without first being reinitialized by a call to xSavepoint(). A call to xRelease(X,M) invalidates all savepoints where N&amp;gt;=M.</source>
          <target state="translated">调用xSavepoint（X，N）时，这是向虚拟表X发出的信号，它应将其当前状态保存为保存点N。后续对xRollbackTo（X，R）的调用意味着虚拟表的状态应返回到最后一次调用xSavepoint（X，R）时的状态。调用xRollbackTo（X，R）将使所有保存点的N&amp;gt; R无效；任何无效的保存点都不会回滚或释放，而无需先通过调用xSavepoint（）进行重新初始化。调用xRelease（X，M）会使N&amp;gt; = M的所有保存点无效。</target>
        </trans-unit>
        <trans-unit id="d7bf837f933ca19d45d60aebd942c6f51001215f" translate="yes" xml:space="preserve">
          <source>When you change the cache size using the cache_size pragma, the change only endures for the current session. The cache size reverts to the default value when the database is closed and reopened.</source>
          <target state="translated">当你使用cache_size pragma改变缓存大小时,这个改变只在当前会话中有效。当数据库关闭和重新打开时,缓存大小会恢复到默认值。</target>
        </trans-unit>
        <trans-unit id="b0e87a05754f1ec62d9fdd0b9342f0b467aa6d5b" translate="yes" xml:space="preserve">
          <source>When you do an insert into a table that does not have an INTEGER PRIMARY KEY column, or if the table does have an INTEGER PRIMARY KEY but the value for that column is not specified in the VALUES clause of the insert, then the key is automatically generated. You can find the value of the key for the most recent INSERT statement using the &lt;b&gt;sqlite_last_insert_rowid&lt;/b&gt; API function.</source>
          <target state="translated">当您对不具有INTEGER PRIMARY KEY列的表进行插入时，或者如果表中确实具有INTEGER PRIMARY KEY，但未在插入的VALUES子句中指定该列的值，则该键将自动产生。您可以使用&lt;b&gt;sqlite_last_insert_rowid&lt;/b&gt; API函数找到最新INSERT语句的键值。</target>
        </trans-unit>
        <trans-unit id="4e2ed89fd7ed9aabab05210ebf19395404532e3b" translate="yes" xml:space="preserve">
          <source>When you have a SQL script that you are debugging or trying to understand, it is often useful to run it in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; with the &quot;.eqp full&quot; setting. When &quot;.eqp&quot; is set to FULL, the shell automatically shows the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output for each command prior to actually running that command.</source>
          <target state="translated">当您具有要调试或尝试理解的SQL脚本时，通常在带有&amp;ldquo; .eqp full&amp;rdquo;设置的&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;运行它很有用。当&amp;ldquo; .eqp&amp;rdquo;设置为FULL时，Shell会在实际运行该命令之前自动为每个命令显示&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;和&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;输出。</target>
        </trans-unit>
        <trans-unit id="9a469065895a09048073186621e6fa156f1d430f" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;../pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; statement is parsed, an &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is sent to the open &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object corresponding to the database file to which the pragma statement refers. The argument to the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control can optionally make the first element of the char** argument point to a string obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, then normal &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; processing continues. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns any result code other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, that means that the VFS encountered an error while handling the &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; and the compilation of the PRAGMA fails with an error. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control occurs at the beginning of pragma statement analysis and so it is able to override built-in &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements.</source>
          <target state="translated">每当解析&lt;a href=&quot;../pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt;语句时，都会将&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件发送到与pragma语句所引用的数据库文件相对应的打开的&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;对象。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件的参数是一个指向字符串（char **）的指针的数组，其中数组的第二个元素是编译指示的名称，第三个元素是编译指示的参数，如果该编译指示没有，则为NULL论据。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件的处理程序可以选择使char **参数的第一个元素指向从&lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;获得的字符串。或等效字符串，如果该编译指示失败，则该字符串将成为该编译指示或错误消息的结果。如果&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件返回&lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;，则正常的&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;处理将继续。如果&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;，则解析器假定VFS已处理PRAGMA本身，并且如果结果字符串为NULL，则解析器将生成无操作准备好的语句；如果该字符串为非，则解析器将返回结果字符串的副本。 -空值。如果&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;或&lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;以外的任何结果代码，这意味着VFS在处理&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA时&lt;/a&gt;遇到错误，并且PRAGMA的编译失败并显示错误。该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控制发生在编译报表分析的开始，所以它能够覆盖内置&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="4f29909c26f83db47f3f77fe2f91d6b21b9cfb6d" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; statement is parsed, an &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is sent to the open &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object corresponding to the database file to which the pragma statement refers. The argument to the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control can optionally make the first element of the char** argument point to a string obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, then normal &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; processing continues. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns any result code other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, that means that the VFS encountered an error while handling the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; and the compilation of the PRAGMA fails with an error. The &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control occurs at the beginning of pragma statement analysis and so it is able to override built-in &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements.</source>
          <target state="translated">每当解析&lt;a href=&quot;pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt;语句时，都会将&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件发送到与pragma语句所引用的数据库文件相对应的打开的&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;对象。&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件的参数是一个指向字符串（char **）的指针的数组，其中数组的第二个元素是编译指示的名称，第三个元素是编译指示的参数，如果该编译指示没有，则为NULL论据。&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件的处理程序可以选择使char **参数的第一个元素指向从&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;获得的字符串。或等效字符串，如果该编译指示失败，则该字符串将成为该编译指示或错误消息的结果。如果&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;，则正常的&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;处理将继续。如果&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;，则解析器假定VFS已处理PRAGMA本身，并且如果结果字符串为NULL，则解析器将生成无操作准备好的语句；如果该字符串为非，则解析器将返回结果字符串的副本。 -空值。如果&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;以外的任何结果代码，这意味着VFS在处理&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA时&lt;/a&gt;遇到错误，并且PRAGMA的编译失败并显示错误。该&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控制发生在编译报表分析的开始，所以它能够覆盖内置&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="7da0d908dd494a51e46851fa8be237351c85f11a" translate="yes" xml:space="preserve">
          <source>Whenever a bug is reported against SQLite, that bug is not considered fixed until new test cases that would exhibit the bug have been added to either the TCL or TH3 test suites. Over the years, this has resulted in thousands and thousands of new tests. These regression tests ensure that bugs that have been fixed in the past are not reintroduced into future versions of SQLite.</source>
          <target state="translated">每当报告了一个针对SQLite的bug,在TCL或TH3测试套件中添加了新的测试用例之前,这个bug不会被认为是修复了。多年来,这导致了成千上万的新测试。这些回归测试确保了过去已经修复的错误不会被重新引入到SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="33e01584f09cbc3030c7fddae4886376aff67c9e" translate="yes" xml:space="preserve">
          <source>Whenever a database is opened, the entire schema is scanned and parsed and a parse tree for the schema is held in memory. That means that database connection startup time and initial memory usage is proportional to the size of the schema.</source>
          <target state="translated">每当打开一个数据库时,整个模式都会被扫描和解析,并且模式的解析树会保存在内存中。这意味着数据库连接启动时间和初始内存使用量与模式的大小成正比。</target>
        </trans-unit>
        <trans-unit id="497ecda91e171119dde556e568de3183a8cb8f6e" translate="yes" xml:space="preserve">
          <source>Whenever a row in the parent table of a foreign key constraint is deleted, or when the values stored in the parent key column or columns are modified, the logical sequence of events is:</source>
          <target state="translated">每当删除外键约束的父表中的一条记录,或者修改父键列或列中存储的值时,事件的逻辑顺序是:。</target>
        </trans-unit>
        <trans-unit id="0a37cacf0c7e51e3db57f63b99d51f003b150071" translate="yes" xml:space="preserve">
          <source>Whenever a write operation occurs, the writer checks how much progress the checkpointer has made, and if the entire WAL has been transferred into the database and synced and if no readers are making use of the WAL, then the writer will rewind the WAL back to the beginning and start putting new transactions at the beginning of the WAL. This mechanism prevents a WAL file from growing without bound.</source>
          <target state="translated">每当发生写操作时,写入者都会检查检查指针的进度,如果整个WAL已经转移到数据库中并同步,而且没有读者在利用WAL,那么写入者就会把WAL倒回起点,并在WAL的开头开始放新的事务。这种机制可以防止WAL文件无约束的增长。</target>
        </trans-unit>
        <trans-unit id="343d6f171b30e5570b4ea710189ea4bcc234b168" translate="yes" xml:space="preserve">
          <source>Whenever another row of result data is available, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_ROW. The row data is stored in an array of pointers to strings and the 2nd parameter is made to point to this array.</source>
          <target state="translated">每当另一行结果数据可用时，&lt;b&gt;sqlite_step&lt;/b&gt;将返回SQLITE_ROW。行数据存储在指向字符串的指针数组中，并使第二个参数指向该数组。</target>
        </trans-unit>
        <trans-unit id="be09d2acec84e8312793d7710565bb42fe503a39" translate="yes" xml:space="preserve">
          <source>Whenever comparing SQLite to other SQL database engines like SQL Server, PostgreSQL, MySQL, or Oracle, it is important first of all to realize that SQLite is not intended as a replacement or competitor to any of those systems. SQLite is &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt;. There is no separate server process that manages the database. An application interacts with the database engine using function calls, not by sending messages to a separate process or thread.</source>
          <target state="translated">每当将SQLite与其他SQL数据库引擎（如SQL Server，PostgreSQL，MySQL或Oracle）进行比较时，首先重要的是要认识到SQLite并不打算替代或替代任何这些系统。 SQLite是&lt;a href=&quot;serverless&quot;&gt;无服务器的&lt;/a&gt;。没有单独的服务器进程可以管理数据库。应用程序使用函数调用与数据库引擎进行交互，而不是通过将消息发送到单独的进程或线程来进行交互。</target>
        </trans-unit>
        <trans-unit id="17a11b6e3fb65c86a99e26ed1e561497e95a4bf4" translate="yes" xml:space="preserve">
          <source>Whenever the database schema changes, prepared statements are automatically reprepared to accommodate the new schema. There is a race condition here in that if one thread is constantly changing the schema, another thread might spin on reparses and repreparations of a prepared statement and never get any real work done. This parameter prevents an infinite loop by forcing the spinning thread to give up after a fixed number of attempts at recompiling the prepared statement. The default setting is 50 which is more than adequate for most applications.</source>
          <target state="translated">每当数据库模式发生变化时,准备好的语句会自动重新准备以适应新的模式。这里有一个竞赛条件,即如果一个线程不断地改变模式,另一个线程可能会在重述和重新准备已准备好的语句上打转,而永远无法完成任何实际工作。这个参数通过迫使旋转的线程在尝试重新编译准备好的语句的固定次数后放弃,从而防止无限循环。默认设置为50次,对于大多数应用来说已经足够了。</target>
        </trans-unit>
        <trans-unit id="5bd2a09557636d477221b6346f70a36e1b45532a" translate="yes" xml:space="preserve">
          <source>Where &quot;column&quot; is a column in the virtual table, OP is an operator like &quot;=&quot; or &quot;&amp;lt;&quot;, and EXPR is an arbitrary expression. So, for example, if the WHERE clause contained a term like this:</source>
          <target state="translated">其中&amp;ldquo; column&amp;rdquo;是虚拟表中的列，OP是诸如&amp;ldquo; =&amp;rdquo;或&amp;ldquo; &amp;lt;&amp;rdquo;之类的运算符，而EXPR是任意表达式。因此，例如，如果WHERE子句包含这样的术语：</target>
        </trans-unit>
        <trans-unit id="43f8cd7ec518821d99337a406b14b6ad25458172" translate="yes" xml:space="preserve">
          <source>Where &amp;lt;tokenizer-name&amp;gt; is &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; to which a string is bound using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text()&lt;/a&gt; where the string identifies the tokenizer and &amp;lt;sqlite3_tokenizer_module ptr&amp;gt; is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; to which a BLOB is bound using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt; where the value of the BLOB is a pointer to an sqlite3_tokenizer_module structure. If the second argument is present, it is registered as tokenizer &amp;lt;tokenizer-name&amp;gt; and a copy of it returned. If only one argument is passed, a pointer to the tokenizer implementation currently registered as &amp;lt;tokenizer-name&amp;gt; is returned, encoded as a blob. Or, if no such tokenizer exists, an SQL exception (error) is raised.</source>
          <target state="translated">其中&amp;lt;tokenizer-name&amp;gt;是使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text（）&lt;/a&gt;绑定到字符串的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;，其中字符串标识令牌生成器，而&amp;lt;sqlite3_tokenizer_module ptr&amp;gt;是使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob（）&lt;/a&gt;绑定BLOB 的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;，其中BLOB 的值是a指向sqlite3_tokenizer_module结构的指针。如果存在第二个参数，则将其注册为令牌生成器&amp;lt;tokenizer-name&amp;gt;并返回其副本。如果仅传递一个参数，则返回指向当前注册为&amp;lt;tokenizer-name&amp;gt;的令牌生成器实现的指针，并将其编码为Blob。或者，如果不存在这样的令牌生成器，则会引发SQL异常（错误）。</target>
        </trans-unit>
        <trans-unit id="fe664b79065efef56eb19d94f1c82054f533c78c" translate="yes" xml:space="preserve">
          <source>Where VERSION can be a branch name (like &quot;trunk&quot; or &quot;session&quot;) to get the latest check-in on a specific branch, or VERSION can be a SHA1 hash or a prefix of a SHA1 hash for a specific check-in, or VERSION can be a tag such as &quot;version-3.8.8&quot;. Every time you run &quot;fossil update&quot; it will automatically reach out to the original repository at http://www.sqlite.org/cgi/src to obtain new check-ins that might have been made by others since your previous update.</source>
          <target state="translated">其中 VERSION 可以是一个分支名(如 &quot;trunk &quot;或 &quot;session&quot;)来获取特定分支的最新签入,或者 VERSION 可以是一个 SHA1 哈希值或 SHA1 哈希值的前缀,或者 VERSION 可以是一个标签,如 &quot;version-3.8.8&quot;。每次你运行 &quot;fossil update &quot;时,它都会自动联系到原始仓库 http://www.sqlite.org/cgi/src,以获取自你上次更新后其他人可能做的新签入。</target>
        </trans-unit>
        <trans-unit id="62f2d871248b60ca56135b923987b70f9385647b" translate="yes" xml:space="preserve">
          <source>Where this ends up causing problems is when developers do some initial coding work using SQLite and get their application working, but then try to convert to another database like PostgreSQL or SQL Server for deployment. If the application is initially taking advantage of SQLite's flexible typing, then it will fail when moved to another database that uses a more rigid and unforgiving type enforcement policy.</source>
          <target state="translated">这最终导致问题的地方是,当开发人员使用SQLite进行一些初始编码工作,并让他们的应用程序工作,但随后试图转换到另一个数据库,如PostgreSQL或SQL Server进行部署。如果应用程序最初利用的是SQLite的灵活类型,那么当它转移到另一个使用更严格、更无情的类型执行策略的数据库时,就会失败。</target>
        </trans-unit>
        <trans-unit id="c5d4b5d864c31b29da8aa7f64d89028ed5c76cfd" translate="yes" xml:space="preserve">
          <source>Whether it is parsing document or query text, any call to xToken that specifies a</source>
          <target state="translated">无论是解析文档还是查询文本,任何对xToken的调用,只要指定一个</target>
        </trans-unit>
        <trans-unit id="79b58773d42ad0674454e81345e3b00864854d60" translate="yes" xml:space="preserve">
          <source>Whether or not &quot;char&quot; variables are signed or unsigned.</source>
          <target state="translated">&quot;char &quot;变量是否为有符号或无符号变量。</target>
        </trans-unit>
        <trans-unit id="927824fe8759e5b1e1a630b01c62f6b1e890e24a" translate="yes" xml:space="preserve">
          <source>Whether or not an error occurs when it is opened, resources associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle should be released by passing it to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt; when it is no longer required.</source>
          <target state="translated">无论打开时是否发生错误，与&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄关联的资源都应通过在不再需要时将其传递给&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="568677ded3b331843b99c68cc439cfb12004ddef" translate="yes" xml:space="preserve">
          <source>Whether or not an error occurs when it is opened, resources associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle should be released by passing it to &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt; when it is no longer required.</source>
          <target state="translated">无论打开时是否发生错误，与&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄关联的资源都应通过在不再需要时将其传递给&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="bb05885439d11af94b4bcc3db20e0753f97a131e" translate="yes" xml:space="preserve">
          <source>Whether or not an index or &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; is used.</source>
          <target state="translated">是否使用索引或&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35e3585051eb4909e3fe069dd52d9c306b089c84" translate="yes" xml:space="preserve">
          <source>Whether or not the &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; optimization applies.</source>
          <target state="translated">无论是否&lt;a href=&quot;queryplanner#covidx&quot;&gt;覆盖索引&lt;/a&gt;优化应用。</target>
        </trans-unit>
        <trans-unit id="3f452c9d36fa06b25992734adfdfc328c0c7c82f" translate="yes" xml:space="preserve">
          <source>Whether or not the backup process is restarted as a result of writes to the source database mid-backup, the user can be sure that when the backup operation is completed the backup database contains a consistent and up-to-date snapshot of the original. However:</source>
          <target state="translated">无论备份过程是否因中途对源数据库的写入而重新启动,用户都可以确信当备份操作完成后,备份数据库包含了原始数据库的一致的最新快照。然而。</target>
        </trans-unit>
        <trans-unit id="805314d6ba3c8452666efff3bc4e2e9c11e54c17" translate="yes" xml:space="preserve">
          <source>Whether the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table.</source>
          <target state="translated">该表是否为&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表。</target>
        </trans-unit>
        <trans-unit id="15cc066f01fd0a8910ef52b96a08c5f23129c75a" translate="yes" xml:space="preserve">
          <source>Which module, FTS3 or FTS4, should you use in your application? FTS4 is sometimes significantly faster than FTS3, even orders of magnitude faster depending on the query, though in the common case the performance of the two modules is similar. FTS4 also offers the enhanced &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; outputs which can be useful in ranking the results of a &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; operation. On the other hand, in the absence of a &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo=fts3&lt;/a&gt; directive FTS4 requires a little more disk space than FTS3, though only a percent of two in most cases.</source>
          <target state="translated">您应在应用程序中使用哪个模块FTS3或FTS4？ FTS4有时会比FTS3快很多，甚至快几个数量级（取决于查询），尽管在通常情况下，两个模块的性能是相似的。 FTS4还提供了增强的&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;输出，可用于对&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt;操作的结果进行排名。另一方面，在缺少&lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo = fts3&lt;/a&gt;指令的情况下，FTS4比FTS3需要更多的磁盘空间，尽管在大多数情况下仅占百分之二。</target>
        </trans-unit>
        <trans-unit id="1eaf1dfe15540108a1d6bb4cc98824a6bb754fe0" translate="yes" xml:space="preserve">
          <source>Which of those columns are PRIMARY KEY columns.</source>
          <target state="translated">其中哪些列是PRIMARY KEY列。</target>
        </trans-unit>
        <trans-unit id="2bf977231fee9d5a01c1d56cb42302f6abc78241" translate="yes" xml:space="preserve">
          <source>Which of those columns make up the tables PRIMARY KEY.</source>
          <target state="translated">其中哪些列组成了表的primary key。</target>
        </trans-unit>
        <trans-unit id="65190c6c06c3156a5ce50576cd97088b8788cba3" translate="yes" xml:space="preserve">
          <source>Which terms of the WHERE clause are used for indexing.</source>
          <target state="translated">WHERE子句的哪些条款是用于索引的。</target>
        </trans-unit>
        <trans-unit id="7d607a9e2bbeeff588fac8037da7b126ad5bde90" translate="yes" xml:space="preserve">
          <source>Which works out to be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5778f90619b883572d8c026a15fd3403dfe6662c" translate="yes" xml:space="preserve">
          <source>While SQL is a programming language, it is different from other programming languages like C, Javascript, Python, or Go in that SQL is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarative language&lt;/a&gt; where the others are &lt;a href=&quot;https://en.wikipedia.org/wiki/Imperative_programming&quot;&gt;imperative languages&lt;/a&gt;. This is an important difference that has implications for the design of the compiler used to translate program source text into an executable format. However, those details should not detract from the fact that SQL is really just another programming language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ada2cef428bad4df299c966d8cc7b1305373853" translate="yes" xml:space="preserve">
          <source>While a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is open on a WAL-mode database, SQLite maintains an extra journal file called a &quot;Write Ahead Log&quot; or &quot;WAL File&quot;. The name of this file on disk is usually the name of the database file with an extra &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; suffix, though different naming rules may apply if SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES&lt;/a&gt;.</source>
          <target state="translated">在WAL模式数据库上打开&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接时&lt;/a&gt;，SQLite维护一个额外的日志文件，称为&amp;ldquo;预写日志&amp;rdquo;或&amp;ldquo; WAL文件&amp;rdquo;。磁盘上此文件的名称通常是后缀为 &lt;code&gt;-wal&lt;/code&gt; 的数据库文件的名称，但是如果使用&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES&lt;/a&gt;编译SQLite可能会应用不同的命名规则。</target>
        </trans-unit>
        <trans-unit id="d7e2ba9f3191758fdb3ad9b114fa10eb9a4ed3b0" translate="yes" xml:space="preserve">
          <source>While a read transaction is active, any changes to the database that are implemented by separate database connections will not be seen by the database connection that started the read transaction. If database connection X is holding a read transaction, it is possible that some other database connection Y might change the content of the database while X's transaction is still open, however X will not be able to see those changes until after the transaction ends. While its read transaction is active, X will continue to see an historic snapshot of the database prior to the changes implemented by Y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffdc80fe0f26846179a6aaa2eb484325f365e70" translate="yes" xml:space="preserve">
          <source>While a read transaction is active, any changes to the database that are implemented by separate database connections will not be seen by the database connection that started the read transaction. If database connection X is holding a read transaction, it is possible that some other database connection Y might change the content of the database while X's transaction is still open, however X will not be able to see those changes until after the transaction ends. While its read transaction is active, X will continue to see an historic snapshot the database prior to the changes implemented by Y.</source>
          <target state="translated">当一个读事务处于活动状态时,任何由单独的数据库连接实现的对数据库的更改都不会被启动读事务的数据库连接看到。如果数据库连接X持有一个读事务,当X的事务还在打开时,其他一些数据库连接Y有可能会改变数据库的内容,然而X在事务结束后才能看到这些改变。当它的读事务处于活动状态时,X将继续看到Y实施更改之前的数据库历史快照。</target>
        </trans-unit>
        <trans-unit id="3fc81a6b9eff77dec03d524ff1a744befb138ec8" translate="yes" xml:space="preserve">
          <source>While compiling a single SQL query, the SQLite core might call xBestIndex multiple times with different settings in &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;. The SQLite core will then select the combination that appears to give the best performance.</source>
          <target state="translated">在编译单个SQL查询时，SQLite核心可能使用&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info中的&lt;/a&gt;不同设置多次调用xBestIndex 。然后，SQLite核心将选择看起来能够提供最佳性能的组合。</target>
        </trans-unit>
        <trans-unit id="d6f8e366ea836d249425f55c0048ab7dd0869350" translate="yes" xml:space="preserve">
          <source>While fuzz testing and 100% MC/DC testing are in tension, they are not completely at cross-purposes. The fact that the SQlite test suite does test to 100% MC/DC means that when fuzzers do find problems, those problems can be fixed quickly and with little risk of introducing new errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84aa771f4f176659ae1924e0a87ff5ad8203b073" translate="yes" xml:space="preserve">
          <source>While opening a</source>
          <target state="translated">当打开一个</target>
        </trans-unit>
        <trans-unit id="9b36f93bab56bb7da15a9179ec0943945f846c1b" translate="yes" xml:space="preserve">
          <source>While performing</source>
          <target state="translated">表演时</target>
        </trans-unit>
        <trans-unit id="96921c80759d36f4a04b6a82e193c5ddf054ac5c" translate="yes" xml:space="preserve">
          <source>While the original idea being CVEs is sound, the current processes for creating and managing CVEs are inadequate. There are countless grey-hat hackers running fuzzers against a wide-variety of open-source software products (SQLite as well as many others) and writing up CVEs against any problems they find. The grey-hats are rewarded, sometimes with prestige and sometimes financially, by the number and severity of the CVEs they write. This incentive results in a proliferation of CVEs which are often not well-vetted and which can have exaggerated impact claims. The quality-control procedures for CVEs are unable to cope with this flood of inputs, making it difficult to correct exaggerated, misleading, omitted, or inaccurate claims.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a93a15284084502a7f86f4c9b90c793ee720848" translate="yes" xml:space="preserve">
          <source>While the queue is not empty:</source>
          <target state="translated">当队列不是空的时候。</target>
        </trans-unit>
        <trans-unit id="31d87d7be7b237cc74cece1001ddf141c8c0c304" translate="yes" xml:space="preserve">
          <source>Whitespace and comment tokens are discarded. All other tokens are fed into an &lt;a href=&quot;https://en.wikipedia.org/wiki/LALR_parser&quot;&gt;LALR(1) Parser&lt;/a&gt; that analysis the structure of the input program and generates an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;Abstract Syntax Tree (AST)&lt;/a&gt; for the input program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b875e5298cf6263e72c1bc4d0e00a3e4a13f0a5d" translate="yes" xml:space="preserve">
          <source>Whitespace or comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2467596fdde02a218277dc3baed1d04b31fd9e" translate="yes" xml:space="preserve">
          <source>Why ALTER TABLE is so difficult</source>
          <target state="translated">为什么ALTER TABLE这么难?</target>
        </trans-unit>
        <trans-unit id="a66e4df98a00d586d77ff8cbda05b1bb33741627" translate="yes" xml:space="preserve">
          <source>Why ALTER TABLE is such a problem for SQLite</source>
          <target state="translated">为什么ALTER TABLE对SQLite来说是这样一个问题?</target>
        </trans-unit>
        <trans-unit id="51671cd80abfeae9d7b51e113f2b9ee1f5d2c38e" translate="yes" xml:space="preserve">
          <source>Why Is SQLite Coded In C</source>
          <target state="translated">为什么SQLite要用C语言编码</target>
        </trans-unit>
        <trans-unit id="a50fb31b169e8e4d9b4a6643f7f8608e036bc60b" translate="yes" xml:space="preserve">
          <source>Why SQLite Does Not Use Git</source>
          <target state="translated">为什么SQLite不使用Git</target>
        </trans-unit>
        <trans-unit id="cf48c0996bab18f4950cd87af9617143917f12a9" translate="yes" xml:space="preserve">
          <source>Why didn't the legacy query planner choose algorithm-2? Easy: because the NN algorithm never even considered algorithm-2. Graphs of the planning problem look like this:</source>
          <target state="translated">为什么传统的查询规划器没有选择算法-2?很简单:因为NN算法根本没有考虑过算法-2。规划问题的图形是这样的。</target>
        </trans-unit>
        <trans-unit id="f9ddc1f9321acc62d313f21bd009fd732a7ca677" translate="yes" xml:space="preserve">
          <source>Why does ROUND(9.95,1) return 9.9 instead of 10.0? Shouldn't 9.95 round up?</source>
          <target state="translated">为什么ROUND(9.95,1)返回9.9而不是10.0?9.95不是应该四舍五入吗?</target>
        </trans-unit>
        <trans-unit id="cf08e93e3998487d5a4514d0ec927b65fe1810fa" translate="yes" xml:space="preserve">
          <source>Why does SQLite have its own private built-in printf() implementation? Why not use the printf() implementation from the standard C library? Several reasons:</source>
          <target state="translated">为什么SQLite有自己的私有内置printf()实现?为什么不使用标准C库中的printf()实现?有几个原因。</target>
        </trans-unit>
        <trans-unit id="1ec9acf7734149243e8c44660fc685f0eb23a630" translate="yes" xml:space="preserve">
          <source>Why doesn't SQLite allow me to use '0' and '0.0' as the primary key on two different rows of the same table?</source>
          <target state="translated">为什么SQLite不允许我在同一张表的两个不同行上使用'0'和'0.0'作为主键?</target>
        </trans-unit>
        <trans-unit id="02275b1d64f346b7ea26ca7a800967bbade4e5f6" translate="yes" xml:space="preserve">
          <source>Win32 Directory Types</source>
          <target state="translated">Win32目录类型</target>
        </trans-unit>
        <trans-unit id="0463d1ccc9613d5098c42774fc7e43131ce95d1e" translate="yes" xml:space="preserve">
          <source>Win32 Specific Interface</source>
          <target state="translated">Win32特定接口</target>
        </trans-unit>
        <trans-unit id="f8b7523500f54721211a692b3d6b968bab3101a5" translate="yes" xml:space="preserve">
          <source>Win32 native memory allocator</source>
          <target state="translated">Win32本地内存分配器</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">窗口功能</target>
        </trans-unit>
        <trans-unit id="7973e6ebbc857b7bb0de6b349ffa9e99bc62f773" translate="yes" xml:space="preserve">
          <source>Window chaining</source>
          <target state="translated">窗链</target>
        </trans-unit>
        <trans-unit id="99565b4d7904c206a1623d09463276b2f7b9b151" translate="yes" xml:space="preserve">
          <source>Window chaining is a shorthand that allows one window to be defined in terms of another. Specifically, the shorthand allows the new window to implicitly copy the PARTITION BY and optionally ORDER BY clauses of the base window. For example, in the following:</source>
          <target state="translated">窗口链是一种速记,它允许用一个窗口来定义另一个窗口。具体来说,该速记允许新窗口隐式复制基础窗口的 PARTITION BY 和可选的 ORDER BY 子句。例如,在下面的例子中。</target>
        </trans-unit>
        <trans-unit id="34aa1477a928d2146e07a6620c66855ebe78ae81" translate="yes" xml:space="preserve">
          <source>Window function support was first added to SQLite with release &lt;a href=&quot;https://sqlite.org/releaselog/3_25_0.html&quot;&gt;version 3.25.0&lt;/a&gt; (2018-09-15). The SQLite developers used the &lt;a href=&quot;http://www.postgresql.org&quot;&gt;PostgreSQL&lt;/a&gt; window function documentation as their primary reference for how window functions ought to behave. Many test cases have been run against PostgreSQL to ensure that window functions operate the same way in both SQLite and PostgreSQL.</source>
          <target state="translated">窗口功能支持最初是在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_25_0.html&quot;&gt;版本3.25.0&lt;/a&gt;（2018-09-15）中添加的。 SQLite开发人员使用&lt;a href=&quot;http://www.postgresql.org&quot;&gt;PostgreSQL&lt;/a&gt;窗口函数文档作为窗口函数应如何工作的主要参考。已经针对PostgreSQL运行了许多测试用例，以确保窗口函数在SQLite和PostgreSQL中的运行方式相同。</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="translated">窗口功能</target>
        </trans-unit>
        <trans-unit id="b37157f249f48370ca58b2cacca1806dc4feec9b" translate="yes" xml:space="preserve">
          <source>Window functions are distinguished from other SQL functions by the presence of an OVER clause. If a function has an OVER clause, then it is a window function. If it lacks an OVER clause, then it is an ordinary aggregate or scalar function. Window functions might also have a FILTER clause in between the function and the OVER clause.</source>
          <target state="translated">窗口函数与其他SQL函数的区别在于是否存在OVER子句。如果一个函数有一个OVER子句,那么它就是一个窗口函数。如果它没有OVER子句,那么它就是一个普通的集合或标量函数。窗口函数也可能在函数和OVER子句之间有一个FILTER子句。</target>
        </trans-unit>
        <trans-unit id="768669bfb2a31bdc0b9e7999f08750dacabe9b82" translate="yes" xml:space="preserve">
          <source>Window functions come in two varieties: &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt; and &lt;a href=&quot;windowfunctions#builtins&quot;&gt;built-in window functions&lt;/a&gt;. Every aggregate window function can also work as a ordinary aggregate function, simply by omitting the OVER and FILTER clauses. Furthermore, all of the built-in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; of SQLite can be used as an aggregate window function by adding an appropriate OVER clause. Applications can register new aggregate window functions using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function()&lt;/a&gt; interface. The built-in window functions, however, require special-case handling in the query planner and hence new window functions that exhibit the exceptional properties found in the built-in window functions cannot be added by the application.</source>
          <target state="translated">窗口函数有两种：&lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;聚合窗口函数&lt;/a&gt;和&lt;a href=&quot;windowfunctions#builtins&quot;&gt;内置窗口函数&lt;/a&gt;。每个聚合窗口函数也可以像普通的聚合函数一样工作，只需省略OVER和FILTER子句即可。此外，通过添加适当的OVER子句，SQLite的所有内置&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合函数&lt;/a&gt;都可以用作聚合窗口函数。应用程序可以使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function（）&lt;/a&gt;接口注册新的聚合窗口函数。但是，内置窗口函数需要在查询计划程序中进行特殊处理，因此应用程序无法添加新窗口函数，这些新窗口函数显示出内置窗口函数中发现的特殊属性。</target>
        </trans-unit>
        <trans-unit id="b69a0cc5bc93433662122b7ab877cc01de2fc8c1" translate="yes" xml:space="preserve">
          <source>Windows DLL exports symbols Tclsqlite_Init and Sqlite_Init</source>
          <target state="translated">Windows DLL导出符号Tclsqlite_Init和Sqlite_Init。</target>
        </trans-unit>
        <trans-unit id="a3320dd4ff96aeb28c32b1c618d2fdc870a0f410" translate="yes" xml:space="preserve">
          <source>Windows builds also come with multiple built-in VFSes. The default Windows VFS is called &quot;win32&quot; and is used in most applications. Other VFSes that might be found on windows builds include:</source>
          <target state="translated">Windows构建也有多个内置的VFS。默认的Windows VFS被称为 &quot;win32&quot;,在大多数应用程序中使用。其他可能在windows构建中找到的VFS包括。</target>
        </trans-unit>
        <trans-unit id="84eca34acba80a1cc2933e50280e69e2f20b7bbc" translate="yes" xml:space="preserve">
          <source>Windows is unable to truncate a memory-mapped file. Hence, on Windows, if an operation such as &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; tries to reduce the size of a memory-mapped database file, the size reduction attempt will silently fail, leaving unused space at the end of the database file. No data is lost due to this problem, and the unused space will be reused again the next time the database grows. However if a version of SQLite prior to 3.7.0 runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on such a database, it will (incorrectly) report database corruption due to the unused space at the end. Or if a version of SQLite prior to 3.7.0 writes to the database while it still has unused space at the end, it may make that unused space inaccessible and unavailable for reuse until after the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">Windows无法截断内存映射文件。因此，在Windows上，如果诸如&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum之&lt;/a&gt;类的操作试图减小内存映射的数据库文件的大小，则减小大小的尝试将无提示地失败，从而在数据库文件的末尾保留未使用的空间。由于此问题，不会丢失任何数据，并且下次数据库增长时，未使用的空间将再次被重用。但是，如果3.7.0之前的SQLite版本在这样的数据库上运行&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;，则由于结尾处未使用的空间，它将（错误地）报告数据库损坏。或者，如果3.7.0之前的SQLite版本在最后仍具有未使用空间的情况下写入数据库，则可能会使该未使用空间无法访问，并且无法使用，直到下一个之后&lt;a href=&quot;lang_vacuum&quot;&gt;真空&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b7712d1cb131a2adfefe7d588175fadb48dafa7" translate="yes" xml:space="preserve">
          <source>Windows only: Open the file &quot;data.db&quot; on fred's desktop on drive C:. Note that the %20 escaping in this example is not strictly necessary - space characters can be used literally in URI filenames.</source>
          <target state="translated">仅限Windows系统。在fred的桌面上打开文件 &quot;data.db&quot;,位于C:。请注意,本例中的%20转义并不是严格必要的--空格字符可以在URI文件名中使用。</target>
        </trans-unit>
        <trans-unit id="31aeba611599f329aa343c65bc0c86921ffe7f9d" translate="yes" xml:space="preserve">
          <source>Windows users can double-click on the &lt;b&gt;sqlite3.exe&lt;/b&gt; icon to cause the command-line shell to pop-up a terminal window running SQLite. However, because double-clicking starts the sqlite3.exe without command-line arguments, no database file will have been specified, so SQLite will use a temporary database that is deleted when the session exits. To use a persistent disk file as the database, enter the &quot;.open&quot; command immediately after the terminal window starts up:</source>
          <target state="translated">Windows用户可以双击&lt;b&gt;sqlite3.exe&lt;/b&gt;图标，使命令行外壳弹出运行SQLite的终端窗口。但是，由于双击时将启动sqlite3.exe，而没有命令行参数，因此将没有指定数据库文件，因此SQLite将使用在会话退出时删除的临时数据库。要将永久磁盘文件用作数据库，请在终端窗口启动后立即输入&amp;ldquo; .open&amp;rdquo;命令：</target>
        </trans-unit>
        <trans-unit id="46ae0e9a494aaadddce1ec0fa75065f4b23d237d" translate="yes" xml:space="preserve">
          <source>With SQLite (but not any other SQL implementation that we know of) if an aggregate query contains a single min() or max() function, then the values of columns used in the output are taken from the row where the min() or max() value was achieved. If two or more rows have the same min() or max() value, then the columns values will be chosen arbitrarily from one of those rows.</source>
          <target state="translated">在SQLite中(但不是我们所知道的任何其他SQL实现),如果一个聚合查询包含一个单一的min()或max()函数,那么输出中使用的列值将从实现min()或max()值的行中抽取。如果两条或两条以上的行具有相同的min()或max()值,那么列值将从其中的一条行中任意选择。</target>
        </trans-unit>
        <trans-unit id="72d650183743377687d259d65b2b0b1477f3b0e4" translate="yes" xml:space="preserve">
          <source>With a covering index, SQLite can simply walk the index from one end to the other and deliver the output in time proportional to N and without having allocate a large buffer to hold the result set.</source>
          <target state="translated">通过覆盖索引,SQLite可以简单地将索引从一端走到另一端,并在与N成正比的时间内提供输出,而无需分配一个大的缓冲区来存放结果集。</target>
        </trans-unit>
        <trans-unit id="ffbb132debbaa76f4f42bce9a72aacb1ba449100" translate="yes" xml:space="preserve">
          <source>With a single allocation size, the &lt;b&gt;n&lt;/b&gt; parameter in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; is 1, and the total memory space required by the allocator (&lt;b&gt;N&lt;/b&gt;) is exactly equal to maximum memory used (&lt;b&gt;M&lt;/b&gt;). No additional memory is required to cover fragmentation overhead, thus reducing memory requirements. This is particularly important for the page cache memory since the page cache constitutes the largest component of the memory needs of SQLite.</source>
          <target state="translated">对于单个分配大小，&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson证明中&lt;/a&gt;的&lt;b&gt;n&lt;/b&gt;参数为1，分配器所需的总存储空间（&lt;b&gt;N&lt;/b&gt;）等于使用的最大内存（&lt;b&gt;M&lt;/b&gt;）。不需要额外的内存来覆盖碎片开销，从而减少了内存需求。这对于页面缓存内存尤其重要，因为页面缓存是SQLite内存需求的最大组成部分。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a552e4d61e6c98e72a1a99aa574976a695fc5369" translate="yes" xml:space="preserve">
          <source>With asynchronous I/O, write requests are handled by a separate thread running in the background. This means that the thread that initiates a database write does not have to wait for (sometimes slow) disk I/O to occur. The write seems to happen very quickly, though in reality it is happening at its usual slow pace in the background.</source>
          <target state="translated">使用异步I/O,写请求由一个单独的线程在后台运行处理。这意味着发起数据库写入的线程不必等待(有时是缓慢的)磁盘I/O的发生。写入似乎发生得非常快,尽管实际上它是以平常缓慢的速度在后台发生的。</target>
        </trans-unit>
        <trans-unit id="ab9e7dc76b3ad69724eb79aea2faff0ba6d5b557" translate="yes" xml:space="preserve">
          <source>With client/server databases like PostgreSQL or Oracle, users and developers tend to think of the database as a service or a &quot;node&quot;, not as an object. This is because the database content is spread out across multiple files on the server, or possibly across multiple servers in a service cluster. One cannot point to a single file or even a single directory and say &quot;this is the database&quot;.</source>
          <target state="translated">对于像PostgreSQL或Oracle这样的客户/服务器数据库,用户和开发人员倾向于将数据库视为一个服务或一个 &quot;节点&quot;,而不是一个对象。这是因为数据库的内容分布在服务器上的多个文件中,或者可能分布在服务集群的多个服务器上。人们不能指着一个文件甚至一个目录说 &quot;这就是数据库&quot;。</target>
        </trans-unit>
        <trans-unit id="9f913fbcf0e843248e92480f5555045919a3653f" translate="yes" xml:space="preserve">
          <source>With one exception noted below, if a rowid table has a primary key that consists of a single column and the declared type of that column is &quot;INTEGER&quot; in any mixture of upper and lower case, then the column becomes an alias for the rowid. Such a column is usually referred to as an &quot;integer primary key&quot;. A PRIMARY KEY column only becomes an integer primary key if the declared type name is exactly &quot;INTEGER&quot;. Other integer type names like &quot;INT&quot; or &quot;BIGINT&quot; or &quot;SHORT INTEGER&quot; or &quot;UNSIGNED INTEGER&quot; causes the primary key column to behave as an ordinary table column with integer &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; and a unique index, not as an alias for the rowid.</source>
          <target state="translated">除了下面提到的一个例外，如果rowid表的主键由单个列组成，并且该列的声明类型为大写和小写的&amp;ldquo; INTEGER&amp;rdquo;，则该列将成为rowid的别名。这样的列通常称为&amp;ldquo;整数主键&amp;rdquo;。仅当声明的类型名称恰好是&amp;ldquo; INTEGER&amp;rdquo;时，PRIMARY KEY列才成为整数主键。其他整数类型名称（例如&amp;ldquo; INT&amp;rdquo;或&amp;ldquo; BIGINT&amp;rdquo;或&amp;ldquo; SHORT INTEGER&amp;rdquo;或&amp;ldquo; UNSIGNED INTEGER&amp;rdquo;）会导致主键列的行为与具有整数&lt;a href=&quot;datatype3#affinity&quot;&gt;相似性&lt;/a&gt;和唯一索引的普通表列相同，而不是作为rowid的别名。</target>
        </trans-unit>
        <trans-unit id="6d08bbd760872d68db33d3c86cf4e679c7a2ebc9" translate="yes" xml:space="preserve">
          <source>With release 3.8.0 (2013-08-26), the SQLite query planner was reimplemented as the &lt;a href=&quot;queryplanner-ng&quot;&gt;Next Generation Query Planner&lt;/a&gt; or &quot;NGQP&quot;. All of the features, techniques, and algorithms described in this document are applicable to both the pre-3.8.0 legacy query planner and to the NGQP. For further information on how the NGQP differs from the legacy query planner, see the &lt;a href=&quot;queryplanner-ng&quot;&gt;detailed description of the NGQP&lt;/a&gt;.</source>
          <target state="translated">在版本3.8.0（2013-08-26）中，SQLite查询计划程序已重新实现为&lt;a href=&quot;queryplanner-ng&quot;&gt;下一代查询计划程序&lt;/a&gt;或&amp;ldquo; NGQP&amp;rdquo;。本文档中描述的所有功能，技术和算法均适用于3.8.0之前的旧版查询计划程序和NGQP。有关NGQP与传统查询计划程序的不同之处的更多信息，请参见&lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;的详细说明。</target>
        </trans-unit>
        <trans-unit id="d1d01005af669e498a6d79c05e376c2142afd701" translate="yes" xml:space="preserve">
          <source>With some (arbitrary) data, such a table might be logically stored on disk as shown in figure 1:</source>
          <target state="translated">对于一些(任意的)数据,这样的表可能会被逻辑地存储在磁盘上,如图1所示。</target>
        </trans-unit>
        <trans-unit id="fd1021b066f8f1badfb5950e8af5b888b38dc724" translate="yes" xml:space="preserve">
          <source>With source code files in the working directory, a DLL can be generated using MSVC with the following command:</source>
          <target state="translated">有了工作目录下的源代码文件,就可以用MSVC用以下命令生成DLL。</target>
        </trans-unit>
        <trans-unit id="0f39e53b1be71b4fb78a20a47e590c12ddf0bcbb" translate="yes" xml:space="preserve">
          <source>With such a schema, the application would no longer need to make periodic backups of the unsaved changes to a separate file to avoid lost work in the event of a crash. Instead, a special &quot;pending&quot; version could be allocated and unsaved changes could be written into the pending version. Because only changes would need to be written, not the entire document, saving the pending changes would only involve writing a few kilobytes of content, not multiple megabytes, and would take milliseconds instead of seconds, and so it could be done frequently and silently in the background. Then when a crash occurs and the user reboots, all (or almost all) of their work is retained. If the user decides to discard unsaved changes, they simply go back to the previous version.</source>
          <target state="translated">有了这样的模式,应用程序将不再需要将未保存的更改定期备份到一个单独的文件中,以避免在发生崩溃时丢失工作。取而代之的是,一个特殊的 &quot;待定 &quot;版本可以被分配,未保存的更改可以被写入待定版本中。因为只需要写入修改,而不是整个文档,所以保存待处理的修改只需要写入几千字节的内容,而不是多兆字节,而且需要几毫秒而不是几秒,所以可以在后台频繁地悄悄进行。然后,当崩溃发生,用户重启时,他们所有(或几乎所有)的工作都会被保留下来。如果用户决定放弃未保存的更改,他们只需回到以前的版本。</target>
        </trans-unit>
        <trans-unit id="1152f09445e7a27bd0f86b5f6b1e7dc6ef22ecb9" translate="yes" xml:space="preserve">
          <source>With synchronous OFF (0), SQLite continues without syncing as soon as it has handed data off to the operating system. If the application running SQLite crashes, the data will be safe, but the database &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;might become corrupted&lt;/a&gt; if the operating system crashes or the computer loses power before that data has been written to the disk surface. On the other hand, commits can be orders of magnitude faster with synchronous OFF.</source>
          <target state="translated">使用同步关闭（0），一旦将数据交给操作系统，SQLite将立即继续而不进行同步。如果运行SQLite的应用程序崩溃，数据将是安全的，但是如果操作系统崩溃或计算机在将数据写入磁盘表面之前断电，则数据库&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;可能会损坏&lt;/a&gt;。另一方面，通过同步关闭，提交可以快几个数量级。</target>
        </trans-unit>
        <trans-unit id="6e05518cdffbac366023e6a7a1a6316fad89e6a6" translate="yes" xml:space="preserve">
          <source>With the Idx3 index on both columns that are constrained by the WHERE clause, SQLite can do a single binary search against Idx3 to find the one rowid for California oranges, then do a single binary search to find the price for that item in the original table. There are no dead-ends and no wasted binary searches. This is a more efficient query.</source>
          <target state="translated">在两个列上的Idx3索引都被WHERE子句约束,SQLite可以对Idx3进行一次二进制搜索,找到加州橙子的一个rowid,然后再进行一次二进制搜索,找到原表中该商品的价格。没有死角,也不会浪费二进制搜索。这是一种更高效的查询方式。</target>
        </trans-unit>
        <trans-unit id="d0ccef83367809507d68fd8adf10ab43756d4053" translate="yes" xml:space="preserve">
          <source>With the following provisos, each series of tokens in the FTS table that matches one of the matchable phrases in the query expression is known as a &quot;phrase match&quot;:</source>
          <target state="translated">在以下但书的情况下,FTS表中与查询表达式中的一个可匹配短语相匹配的每一个系列令牌称为 &quot;短语匹配&quot;。</target>
        </trans-unit>
        <trans-unit id="6be83cc240990bde696822c8c968c954935effd4" translate="yes" xml:space="preserve">
          <source>With the schema above, a statement of the form:</source>
          <target state="translated">有了上面的模式,一个形式的声明:</target>
        </trans-unit>
        <trans-unit id="ce7e1668aa6ca5e4002b24e2ec5db69485e9af33" translate="yes" xml:space="preserve">
          <source>With this pattern, the overall system is still client/server: clients send requests to the server and get back replies over the network. But instead of sending generic SQL and getting back raw table content, the client requests and server responses are high-level and application-specific. The server translates requests into multiple SQL queries, gathers the results, does post-processing, filtering, and analysis, then constructs a high-level reply containing only the essential information.</source>
          <target state="translated">在这种模式下,整个系统仍然是客户机/服务器:客户机向服务器发送请求,并通过网络得到回复。但是,客户端的请求和服务器的回复不是发送通用的SQL,而是返回原始的表内容,而是高级的、针对应用的。服务器将请求翻译成多个SQL查询,收集结果,进行后处理、过滤和分析,然后构造一个只包含基本信息的高级回复。</target>
        </trans-unit>
        <trans-unit id="a6cde545c87cfe9cdf5083a11aa7253d12946e88" translate="yes" xml:space="preserve">
          <source>With this table, the statement</source>
          <target state="translated">有了这个表,语句</target>
        </trans-unit>
        <trans-unit id="e3d30043cb29ededf7f5c7d45d7c85af41b7ac41" translate="yes" xml:space="preserve">
          <source>With this trigger installed, executing the statement:</source>
          <target state="translated">安装了这个触发器后,执行语句。</target>
        </trans-unit>
        <trans-unit id="b738f8fb3971eaf9d8b4464f7e01335910aa51fd" translate="yes" xml:space="preserve">
          <source>With tracing mode on, the VDBE prints each instruction prior to executing it. After the instruction is executed, the top few entries in the stack are displayed. The stack display is omitted if the stack is empty.</source>
          <target state="translated">开启跟踪模式后,VDBE在执行每条指令前都会打印出指令。指令执行后,显示堆栈中的前几个条目。如果堆栈为空,则省略堆栈显示。</target>
        </trans-unit>
        <trans-unit id="bdf14e9c4b4688dcd43209a6bc661b4142ea27d9" translate="yes" xml:space="preserve">
          <source>With two exceptions, a</source>
          <target state="translated">除了两个例外,a</target>
        </trans-unit>
        <trans-unit id="bb5693991e33e1156b62932972a48bb594da454a" translate="yes" xml:space="preserve">
          <source>Within a changeset generated by this function, all changes related to a single table are grouped together. In other words, when iterating through a changeset or when applying a changeset to a database, all changes related to a single table are processed before moving on to the next table. Tables are sorted in the same order in which they were attached (or auto-attached) to the sqlite3_session object. The order in which the changes related to a single table are stored is undefined.</source>
          <target state="translated">在这个函数生成的变化集中,所有与单张表相关的变化都被归为一组。换句话说,当迭代一个变化集或者将一个变化集应用到数据库中时,所有与一个表相关的变化都会在进入下一个表之前被处理。表会按照它们被附加(或自动附加)到sqlite3_session对象的顺序进行排序。与单个表相关的更改的存储顺序是未定义的。</target>
        </trans-unit>
        <trans-unit id="e69d76786ab7b8d267ef6f99888893212d52b234" translate="yes" xml:space="preserve">
          <source>Within a single database connection X, a SELECT statement always sees all changes to the database that are completed prior to the start of the SELECT statement, whether committed or uncommitted. And the SELECT statement obviously does not see any changes that occur after the SELECT statement completes. But what about changes that occur while the SELECT statement is running? What if a SELECT statement is started and the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface steps through roughly half of its output, then some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements are run by the application that modify the table that the SELECT statement is reading, then more calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; are made to finish out the SELECT statement? Will the later steps of the SELECT statement see the changes made by the UPDATE or not? The answer is that this behavior is undefined. In particular, whether or not the SELECT statement sees the concurrent changes depends on which release of SQLite is running, the schema of the database file, whether or not &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run, and the details of the query. In some cases, it might depend on the content of the database file, too. There is no good way to know whether or not a SELECT statement will see changes that were made to the database by the same database connection after the SELECT statement was started. And hence, developers should diligently avoid writing applications that make assumptions about what will occur in that circumstance.</source>
          <target state="translated">在单个数据库连接X中，SELECT语句始终会看到在SELECT语句开始之前完成的所有数据库更改，无论是已提交还是未提交。 SELECT语句显然看不到SELECT语句完成后发生的任何更改。但是，在SELECT语句运行时发生的更改又如何呢？如果启动了SELECT语句，并且&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口大致遍历了其输出的一半，那么应用程序将对某些&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句进行修改，这些操作将修改SELECT语句正在读取的表，然后再调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;完成SELECT语句？ SELECT语句的后续步骤是否会看到UPDATE所做的更改？答案是这种行为是不确定的。特别是，SELECT语句是否看到并发更改取决于正在运行的SQLite版本，数据库文件的架构，是否已运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;以及查询的详细信息。在某些情况下，它也可能取决于数据库文件的内容。没有什么好方法可以知道SELECT语句在启动SELECT语句后是否会看到同一数据库连接对数据库所做的更改。因此，开发人员应努力避免编写对这种情况下将要发生的情况进行假设的应用程序。</target>
        </trans-unit>
        <trans-unit id="f64c1e27b35be2c65501356f86b040f4e01382a8" translate="yes" xml:space="preserve">
          <source>Within a trigger program each INSERT, UPDATE and DELETE statement sets the value returned by sqlite3_changes() upon completion as normal. Of course, this value will not include any changes performed by sub-triggers, as the sqlite3_changes() value will be saved and restored after each sub-trigger has run.</source>
          <target state="translated">在触发器程序中,每个INSERT、UPDATE和DELETE语句在完成后都会像正常情况一样设置sqlite3_changes()返回的值。当然,这个值不包括任何由子触发器执行的更改,因为sqlite3_changes()的值将在每个子触发器运行后被保存和恢复。</target>
        </trans-unit>
        <trans-unit id="a4a4a7b77632610d5c03098170087135a035d198" translate="yes" xml:space="preserve">
          <source>Within an FTS expression a &lt;b&gt;string&lt;/b&gt; may be specified in one of two ways:</source>
          <target state="translated">在FTS表达式中，可以通过以下两种方式之一指定&lt;b&gt;字符串&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="b69cb3df5f10a8834e6c84cc69fe995f5e513c1e" translate="yes" xml:space="preserve">
          <source>Within an interior b-tree page, each key and the pointer to its immediate left are combined into a structure called a &quot;cell&quot;. The right-most pointer is held separately. A leaf b-tree page has no pointers, but it still uses the cell structure to hold keys for index b-trees or keys and content for table b-trees. Data is also contained in the cell.</source>
          <target state="translated">在一个内部的b树页中,每个键和紧挨着它左边的指针都被组合成一个结构,称为 &quot;单元格&quot;。最右边的指针是单独持有的。叶子b树页没有指针,但它仍然使用单元格结构来保存索引b树的键或表b树的键和内容。数据也包含在单元格中。</target>
        </trans-unit>
        <trans-unit id="e7e979d6674438107ff98232bc172bfe9db221b4" translate="yes" xml:space="preserve">
          <source>Within the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried &lt;a href=&quot;vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and found that the column was unchanging). Within an &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method call for an UPDATE statement, then the return value is arbitrary and meaningless.</source>
          <target state="translated">内&lt;a href=&quot;../vtab#xupdate&quot;&gt;的XUpdate&lt;/a&gt;一个的方法&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;中，sqlite3_value_nochange（X）接口返回true当且仅当相应于X的列是由更新操作，所述的XUpdate方法调用被调用来实现和保持不变，如果和现有&lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法调用被调用以提取返回的该列的值而未设置结果（可能是因为它查询了&lt;a href=&quot;vtab_nochange&quot;&gt;sqlite3_vtab_nochange（）&lt;/a&gt;并发现该列未更改）。在&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法中，在所有其他方面，sqlite3_value_nochange（X）为true的任何值都将显示为NULL值。如果在&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;之外的任何地方调用sqlite3_value_nochange（X）方法调用UPDATE语句，则返回值是任意的且无意义。</target>
        </trans-unit>
        <trans-unit id="6789b1bae7cd2bb76c0159019d7d9fbb4d93f85d" translate="yes" xml:space="preserve">
          <source>Within the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried &lt;a href=&quot;#sqlite3_vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and found that the column was unchanging). Within an &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method call for an UPDATE statement, then the return value is arbitrary and meaningless.</source>
          <target state="translated">内&lt;a href=&quot;vtab#xupdate&quot;&gt;的XUpdate&lt;/a&gt;一个的方法&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;中，sqlite3_value_nochange（X）接口返回true当且仅当相应于X的列是由更新操作，所述的XUpdate方法调用被调用来实现和保持不变，如果和现有&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;方法调用被调用以提取返回的该列的值而未设置结果（可能是因为它查询了&lt;a href=&quot;#sqlite3_vtab_nochange&quot;&gt;sqlite3_vtab_nochange（）&lt;/a&gt;并发现该列未更改）。在&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法中，在所有其他方面，sqlite3_value_nochange（X）为true的任何值都将显示为NULL值。如果在&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;之外的任何地方调用sqlite3_value_nochange（X）方法调用UPDATE语句，则返回值是任意的且无意义。</target>
        </trans-unit>
        <trans-unit id="51af27804794d9726418547af1ae4968a5ef7a8d" translate="yes" xml:space="preserve">
          <source>Within this document, the term</source>
          <target state="translated">在本文件中,术语</target>
        </trans-unit>
        <trans-unit id="2abd7cfa8c19071145244fc329440378e98735a8" translate="yes" xml:space="preserve">
          <source>Within this document, the term &lt;b&gt;&lt;i&gt;non-writable dirty page&lt;/i&gt;&lt;/b&gt; is used specifically to refer to a</source>
          <target state="translated">在本文档中，术语&amp;ldquo; &lt;b&gt;&lt;i&gt;不可写脏页&amp;rdquo;&lt;/i&gt;&lt;/b&gt;专门用于指代</target>
        </trans-unit>
        <trans-unit id="9c7aa2ef11bbb00024927734567cd7e8fb651be6" translate="yes" xml:space="preserve">
          <source>Within your application, call the procedure implemented in the last step above as part of your initialization process before any database connections are opened.</source>
          <target state="translated">在您的应用程序中,在打开任何数据库连接之前,调用上面最后一步中实现的过程,作为初始化过程的一部分。</target>
        </trans-unit>
        <trans-unit id="d2b321aabd394218d6d71b6b8d179118941b9c02" translate="yes" xml:space="preserve">
          <source>Without the master journal, the transaction commit on a multi-database transaction would be atomic for each database individually, but it would not be atomic across all databases. In other words, if the commit were interrupted in the middle by a crash or power loss, then the changes to one of the databases might complete while the changes to another database might roll back. The master journal causes all changes in all databases to either rollback or commit together.</source>
          <target state="translated">如果没有主日志,多数据库事务的事务提交对每个数据库来说都是原子的,但对所有数据库来说却不是原子的。换句话说,如果提交中途因为崩溃或断电而中断,那么其中一个数据库的更改可能会完成,而另一个数据库的更改可能会回滚。主日志会使所有数据库的所有更改一起回滚或提交。</target>
        </trans-unit>
        <trans-unit id="7c3fafa3b408ed62c81a7e1dcfba262f7d167cb3" translate="yes" xml:space="preserve">
          <source>Without the super-journal, the transaction commit on a multi-database transaction would be atomic for each database individually, but it would not be atomic across all databases. In other words, if the commit were interrupted in the middle by a crash or power loss, then the changes to one of the databases might complete while the changes to another database might roll back. The super-journal causes all changes in all databases to either rollback or commit together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6dd78a3d415f93746301f9a57f0de1998136848" translate="yes" xml:space="preserve">
          <source>Words beginning with &quot;wr&quot; versus &quot;r&quot;: write vs. rite</source>
          <target state="translated">以 &quot;wr &quot;开头的词与 &quot;r &quot;开头的词:写与礼。</target>
        </trans-unit>
        <trans-unit id="87bffc88b4c4749365cee3251faa81be81f0ebe9" translate="yes" xml:space="preserve">
          <source>Work around a C-preprocessor macro conflict that breaks the build for some configurations with Microsoft Visual Studio.</source>
          <target state="translated">解决C-预处理器宏冲突的问题,该冲突破坏了Microsoft Visual Studio的某些配置的构建。</target>
        </trans-unit>
        <trans-unit id="50aee533edd4e21305ef90f99451cd9467951df2" translate="yes" xml:space="preserve">
          <source>Work around a GCC optimizer bug (for gcc 4.2.1 on MacOS 10.7) that caused the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to compute incorrect results when compiled with -O3.</source>
          <target state="translated">解决GCC优化器错误（适用于MacOS 10.7上的gcc 4.2.1），该错误导致&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;使用-O3编译时无法计算正确的结果。</target>
        </trans-unit>
        <trans-unit id="dfd059bf7f3cb496ecc6f63b39e721653d7d6b6d" translate="yes" xml:space="preserve">
          <source>Work around a bug in the optimizer in the VisualStudio-2012 compiler that causes invalid code to be generated when compiling SQLite on ARM.</source>
          <target state="translated">解决了 VisualStudio-2012 编译器中的优化器中的一个错误,该错误会导致在 ARM 上编译 SQLite 时生成无效代码。</target>
        </trans-unit>
        <trans-unit id="05fe4e3a69bacc20ca972b8ceb1bc5a0e767ed20" translate="yes" xml:space="preserve">
          <source>Work around a sign-extension bug in the optimizer of the HP C compiler on HP/UX. &lt;a href=&quot;https://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=869c95b0fc73026d&amp;amp;v2=232c242a0ccb3d67&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">解决HP / UX上HP C编译器优化器中的符号扩展错误。&lt;a href=&quot;https://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=869c95b0fc73026d&amp;amp;v2=232c242a0ccb3d67&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f7e0b96e4d5af469559bc4b5418e841b0585e67" translate="yes" xml:space="preserve">
          <source>Work around a win2k problem so that SQLite can use single-character database file names</source>
          <target state="translated">解决win2k中的一个问题,使SQLite可以使用单字符数据库文件名。</target>
        </trans-unit>
        <trans-unit id="620ea823b219e2193e9c0c9d76d068c0c91681bb" translate="yes" xml:space="preserve">
          <source>Work around an optimizer bug in the MSVC compiler when targeting ARM.</source>
          <target state="translated">绕过 MSVC 编译器中针对 ARM 时的一个优化器错误。</target>
        </trans-unit>
        <trans-unit id="c7a3e9e586b4abc65bd66b99ca41670f3c121bb4" translate="yes" xml:space="preserve">
          <source>Work-around for &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32575&quot;&gt;GCC bug 32575&lt;/a&gt;.</source>
          <target state="translated">解决&lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32575&quot;&gt;GCC错误32575的方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cebdf47773b9831e663aaa2b137f8c46c76becbf" translate="yes" xml:space="preserve">
          <source>Would be rewritten using query flattening as:</source>
          <target state="translated">将使用查询扁平化重写为。</target>
        </trans-unit>
        <trans-unit id="adefeee85f8390b904f622c9dadd9084253d11b9" translate="yes" xml:space="preserve">
          <source>Wrap SQL output in a single large transaction</source>
          <target state="translated">将SQL输出包在一个大事务中</target>
        </trans-unit>
        <trans-unit id="a38083e109d2e7a4d69cbaa3489444f640acbb5f" translate="yes" xml:space="preserve">
          <source>Write Data Into A BLOB Incrementally</source>
          <target state="translated">以递增方式将数据写入BLOB中。</target>
        </trans-unit>
        <trans-unit id="d7f59c7d18e98edd2a33e30c67d681015a12865e" translate="yes" xml:space="preserve">
          <source>Write P4 on the statement trace output if statement tracing is enabled.</source>
          <target state="translated">如果启用语句跟踪,则在语句跟踪输出上写入P4。</target>
        </trans-unit>
        <trans-unit id="01ecf2ccbe2bc061336d1857718a14b0b49fee20" translate="yes" xml:space="preserve">
          <source>Write Programs That Use SQLite</source>
          <target state="translated">编写使用SQLite的程序</target>
        </trans-unit>
        <trans-unit id="57477c30051b84c96ed41136ab16ff89bef76c1e" translate="yes" xml:space="preserve">
          <source>Write Transactions</source>
          <target state="translated">写交易</target>
        </trans-unit>
        <trans-unit id="7792ea49e68a0636ee3df8abc86c43dc971f4500" translate="yes" xml:space="preserve">
          <source>Write a NULL into registers P2. If P3 greater than P2, then also write NULL into register P3 and every register in between P2 and P3. If P3 is less than P2 (typically P3 is zero) then only register P2 is set to NULL.</source>
          <target state="translated">向寄存器P2中写入一个NULL。如果P3大于P2,那么也将NULL写入寄存器P3以及P2和P3之间的每个寄存器。如果P3小于P2(通常P3为0),那么只有寄存器P2被设置为NULL。</target>
        </trans-unit>
        <trans-unit id="4b067f7f133cef5bf8ac788b6955ee101e88869d" translate="yes" xml:space="preserve">
          <source>Write a string containing the final journal-mode to register P2.</source>
          <target state="translated">写一个包含最终日志模式的字符串来注册P2。</target>
        </trans-unit>
        <trans-unit id="b758b03a1915378a4790dfdd86b8e50a7bacf82d" translate="yes" xml:space="preserve">
          <source>Write all necessary methods.</source>
          <target state="translated">写出所有必要的方法。</target>
        </trans-unit>
        <trans-unit id="96dcd721393f2668fc3f8e665d514a96620cfebb" translate="yes" xml:space="preserve">
          <source>Write all page modifications currently held in memory out to the original database disk file.</source>
          <target state="translated">将当前保存在内存中的所有页面修改写出到原数据库磁盘文件中。</target>
        </trans-unit>
        <trans-unit id="1687a8d3ed30cb7eb791ed33a931d8ace68eaab0" translate="yes" xml:space="preserve">
          <source>Write an entry into the table of cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The data is the value MEM_Blob stored in register number P2. The key is stored in register P3. The key must be a MEM_Int.</source>
          <target state="translated">在游标P1的表中写入一个条目。如果一个新的条目还不存在,那么就创建一个新的条目,或者覆盖现有条目的数据。数据是存储在寄存器P2号中的值MEM_Blob。密钥存储在寄存器P3中。键必须是一个MEM_Int。</target>
        </trans-unit>
        <trans-unit id="d5c23fb528e11a09e4afc8b5a2e279f79a841784" translate="yes" xml:space="preserve">
          <source>Write into register P2 an integer which is the last entry in the record at the end of the index key pointed to by cursor P1. This integer should be the rowid of the table entry to which this index entry points.</source>
          <target state="translated">在寄存器P2中写入一个整数,这个整数是游标P1所指向的索引键末尾的最后一个记录。这个整数应该是这个索引项所指向的表项的行号。</target>
        </trans-unit>
        <trans-unit id="845ccbd564d152c911058efd13330cea72170f39" translate="yes" xml:space="preserve">
          <source>Write into register P2 the complete row content for the row at which cursor P1 is currently pointing. There is no interpretation of the data. It is just copied onto the P2 register exactly as it is found in the database file.</source>
          <target state="translated">将游标P1当前指向的行的完整行内容写入寄存器P2。没有对数据的解释,只是将数据复制到P2寄存器中,与数据库文件中的内容一模一样。它只是复制到P2寄存器中,与数据库文件中的数据一模一样。</target>
        </trans-unit>
        <trans-unit id="d4da38aa74dee90d46d653efba3b56536b2cc5d2" translate="yes" xml:space="preserve">
          <source>Write into register P2 the current sorter data for sorter cursor P1. Then clear the column header cache on cursor P3.</source>
          <target state="translated">将当前分拣机游标P1的分拣机数据写入寄存器P2。然后清除游标P3上的列头缓存。</target>
        </trans-unit>
        <trans-unit id="4e60b462188e6078fccee2b0f7f0c97876c061b9" translate="yes" xml:space="preserve">
          <source>Write performance measurements were made by replacing (overwriting) an entire blob with a different blob. All of the blobs in these experiment are random and incompressible. Because writes are so much slower than reads, only 10,000 of the 100,000 blobs in the database are replaced. The blobs to be replaced are selected at random and are in no particular order.</source>
          <target state="translated">通过用不同的blob替换(覆盖)整个blob来进行写入性能测量。这些实验中的所有blob都是随机的、不可压缩的。因为写比读慢得多,所以数据库中10万个blob中只有1万个被替换。被替换的blob是随机选择的,没有特定的顺序。</target>
        </trans-unit>
        <trans-unit id="97d379c9ca883f0cc777a01b05087d4f85759f23" translate="yes" xml:space="preserve">
          <source>Write the current address onto register P1 and then jump to address P2.</source>
          <target state="translated">将当前地址写入寄存器P1,然后跳转到地址P2。</target>
        </trans-unit>
        <trans-unit id="b9ace1191ba47c3313a30683407724719ddd8866" translate="yes" xml:space="preserve">
          <source>Write the current number of pages in database P1 to memory cell P2.</source>
          <target state="translated">将数据库P1中的当前页数写入存储单元P2。</target>
        </trans-unit>
        <trans-unit id="91954b8458d0e00b292061c02fc82b69cf42b6c1" translate="yes" xml:space="preserve">
          <source>Write the integer value P3 into cookie number P2 of database P1. P2==1 is the schema version. P2==2 is the database format. P2==3 is the recommended pager cache size, and so forth. P1==0 is the main database file and P1==1 is the database file used to store temporary tables.</source>
          <target state="translated">将整数值P3写入数据库P1的cookie号P2中。P2==1为模式版本。P2==2是数据库格式。P2==3是推荐的寻呼机缓存大小,以此类推。P1==0 是主数据库文件,P1==1 是用于存储临时表的数据库文件。</target>
        </trans-unit>
        <trans-unit id="4f557ab176f965a00361710b6f978bd703c87e93" translate="yes" xml:space="preserve">
          <source>Write the name of the master journal into all individual journals (in space set aside for that purpose in the headers of the individual journals) and flush the contents of the individual journals to disk and wait for those changes to reach the disk surface.</source>
          <target state="translated">将主日志的名称写入所有的单个日志中(在单个日志的标题中为此预留的空间中),并将单个日志的内容冲入磁盘,等待这些变化到达磁盘表面。</target>
        </trans-unit>
        <trans-unit id="461c6fd84d21b2e1e58564d3f66dc64dc514f582" translate="yes" xml:space="preserve">
          <source>Write the name of the super-journal into all individual journals (in space set aside for that purpose in the headers of the individual journals) and flush the contents of the individual journals to disk and wait for those changes to reach the disk surface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7664f788d5d10d956cebf109c73130c0a103849" translate="yes" xml:space="preserve">
          <source>Write transactions are very fast since they only involve writing the content once (versus twice for rollback-journal transactions) and because the writes are all sequential. Further, syncing the content to the disk is not required, as long as the application is willing to sacrifice durability following a power loss or hard reboot. (Writers sync the WAL on every transaction commit if &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to FULL but omit this sync if &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to NORMAL.)</source>
          <target state="translated">写事务非常快，因为它们只涉及一次写入内容（对于回滚日志事务而言则是两次），并且由于写入都是顺序的。此外，只要应用程序愿意在断电或硬重启后牺牲耐用性，就不需要将内容同步到磁盘。 （如果将&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为FULL，则写入程序将在每次事务提交时同步WAL，但如果将&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为NORMAL，则编写者将忽略此同步。）</target>
        </trans-unit>
        <trans-unit id="9df19c54f436b6a77ec7817a689a3cb7a8863393" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Commit Hook</source>
          <target state="translated">预写日志提交钩子</target>
        </trans-unit>
        <trans-unit id="7012a3c8e49b82c45441c8c9cad604aa604cafd1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Logging</source>
          <target state="translated">预写记录</target>
        </trans-unit>
        <trans-unit id="0e7776631ee4a8b853c6c06ce06a6006cefcda96" translate="yes" xml:space="preserve">
          <source>Write-ahead Log (WAL) files</source>
          <target state="translated">预写日志(WAL)文件</target>
        </trans-unit>
        <trans-unit id="e1b6c7d9217381e4c29658c4e3841e70686fb388" translate="yes" xml:space="preserve">
          <source>Writer starvation</source>
          <target state="translated">作家饥渴症</target>
        </trans-unit>
        <trans-unit id="e447e06606fdc13a8e426bfdd192c63a84795c86" translate="yes" xml:space="preserve">
          <source>Writers merely append new content to the end of the WAL file. Because writers do nothing that would interfere with the actions of readers, writers and readers can run at the same time. However, since there is only one WAL file, there can only be one writer at a time.</source>
          <target state="translated">写手只是将新的内容附加到WAL文件的末尾。因为写手不做任何会干扰读者行动的事情,所以写手和读者可以同时运行。但是,由于只有一个WAL文件,所以一次只能有一个写手。</target>
        </trans-unit>
        <trans-unit id="51a81481b69a429427cf443afa9b0e120124c1b5" translate="yes" xml:space="preserve">
          <source>Writes are slower. On all systems, using both direct I/O and SQLite, write performance is between 5 and 15 times slower than reads.</source>
          <target state="translated">写入速度较慢。在所有系统中,使用直接I/O和SQLite,写的性能比读慢5到15倍。</target>
        </trans-unit>
        <trans-unit id="a90f9ae1890da2882ef529c18fb80a5589473876" translate="yes" xml:space="preserve">
          <source>Writes to an in-memory source database, or writes to a file-based source database by an external process or thread using a database connection other than pDb are significantly more expensive than writes made to a file-based source database using pDb (as the entire backup operation must be restarted in the former two cases).</source>
          <target state="translated">向内存源数据库写入数据,或由外部进程或线程使用 pDb 以外的数据库连接向基于文件的源数据库写入数据,比使用 pDb 向基于文件的源数据库写入数据要贵得多(因为在前两种情况下必须重新启动整个备份操作)。</target>
        </trans-unit>
        <trans-unit id="347af0bc198470df77e05081b38d5bcb19f95263" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;a href=&quot;../dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; virtual table.</source>
          <target state="translated">写入&lt;a href=&quot;../dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt;虚拟表。</target>
        </trans-unit>
        <trans-unit id="caebec0b3978142dd7d784c5a70a27f827c0fc87" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; virtual table.</source>
          <target state="translated">写入&lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt;虚拟表。</target>
        </trans-unit>
        <trans-unit id="9e632869f49afb8aba3986c578bc41023c0edd69" translate="yes" xml:space="preserve">
          <source>Writing Data</source>
          <target state="translated">编写数据</target>
        </trans-unit>
        <trans-unit id="46bd9ed0bb52c21d70902da8961ddf970beec522" translate="yes" xml:space="preserve">
          <source>Writing a Journal Header</source>
          <target state="translated">撰写日志标题</target>
        </trans-unit>
        <trans-unit id="563ef87c29c874b30c909b9cb710bc0c375b3734" translate="yes" xml:space="preserve">
          <source>Writing a good query planner is more art than science. The query planner must work with incomplete information. It cannot determine how long any particular plan will take without actually running that plan. So when comparing two or more plans to figure out which is &quot;best&quot;, the query planner has to make some guesses and assumptions and those guesses and assumptions will sometimes be wrong. A good query planner is one that will find the correct solution often enough that application programmers rarely need to get involved.</source>
          <target state="translated">编写一个好的查询计划书是艺术多于科学。查询规划师必须在不完整的信息下工作。在没有实际运行该计划的情况下,它无法确定任何特定计划需要多长时间。因此,当比较两个或更多的计划以找出哪个是 &quot;最好的 &quot;时,查询规划师必须做出一些猜测和假设,而这些猜测和假设有时会是错误的。一个好的查询规划器是会经常找到正确的解决方案,以至于应用程序员很少需要参与。</target>
        </trans-unit>
        <trans-unit id="0cde81e7d9009da11d97881af257b1563f71fbed" translate="yes" xml:space="preserve">
          <source>Writing the code for a new VFS involves constructing a subclass for the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object and then registering that VFS object using a call to &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. The VFS implementation also provides subclasses for &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; and &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; but those objects are not registered directly with SQLite. Instead, the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is returned from the xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; and the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object points to an instance of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">为新的VFS编写代码涉及为&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象构造一个子类，然后使用对&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;的调用来注册该VFS对象。VFS实现还为&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;和&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;提供了子类，但这些对象未直接在SQLite中注册。相反，&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象从的XOPEN方法返回&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;和&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象指向的一个实例&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="7fdb521941b3e5056a81c587e69b7f19860828e9" translate="yes" xml:space="preserve">
          <source>Written in ANSI-C. &lt;a href=&quot;tclsqlite&quot;&gt;TCL bindings&lt;/a&gt; included. Bindings for dozens of other languages available separately.</source>
          <target state="translated">用ANSI-C编写。包括&lt;a href=&quot;tclsqlite&quot;&gt;TCL绑定&lt;/a&gt;。数十种其他语言的绑定分别可用。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="ab87b9a32f29182878ebb3a6891a6c4a1092d9ec" translate="yes" xml:space="preserve">
          <source>X is U-35 for table btree leaf pages or ((U-12)*64/255)-23 for index pages.</source>
          <target state="translated">表树叶页的X为U-35,索引页为((U-12)*64/255)-23。</target>
        </trans-unit>
        <trans-unit id="a43e2726d178277e17345f240dc4baecfd6ece05" translate="yes" xml:space="preserve">
          <source>XLS - Microsoft Excel Spreadsheet</source>
          <target state="translated">XLS-微软Excel电子表格</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="d3f8f7b810c4b08f0b4ac4e47fdf8d265a10d869" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD</source>
          <target state="translated">YYYY-MM-DD</target>
        </trans-unit>
        <trans-unit id="52249b595b705e3022543f7da9fd802190e92e98" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM</source>
          <target state="translated">YYYY-MM-DD HH:MM</target>
        </trans-unit>
        <trans-unit id="5d7d8fa1d70072dde246c61070188c4587305f0a" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM:SS</source>
          <target state="translated">YYYY-MM-DD HH:MM:SS</target>
        </trans-unit>
        <trans-unit id="c73c8c3ce69182be88dad37758ba32a3fc0f8563" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM:SS.SSS</source>
          <target state="translated">YYYY-MM-DD HH:MM:SS.SSS。</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="5374d3a8e418edba680d4a07da2c6ab36a4e8962" translate="yes" xml:space="preserve">
          <source>Yes. SQLite is in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. No claim of ownership is made to any part of the code. You can do anything you want with it.</source>
          <target state="translated">是。SQLite在&lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;公共领域&lt;/a&gt;。不对代码的任何部分主张所有权。您可以用它做任何您想做的事情。</target>
        </trans-unit>
        <trans-unit id="33b0fd0f74faa27daf44c1c690d408e467aa0dd1" translate="yes" xml:space="preserve">
          <source>Yield</source>
          <target state="translated">Yield</target>
        </trans-unit>
        <trans-unit id="84033aeb092c1214f0c2cb3aece38e6ba6958175" translate="yes" xml:space="preserve">
          <source>Yields 20 results beginning with:</source>
          <target state="translated">产生20个结果,开头是:</target>
        </trans-unit>
        <trans-unit id="0e3a778de9e9a5f44253370ab8c9e4efcbf47122" translate="yes" xml:space="preserve">
          <source>You can access the ROWID of an SQLite table using one of the special column names ROWID, _ROWID_, or OID. Except if you declare an ordinary table column to use one of those special names, then the use of that name will refer to the declared column not to the internal ROWID.</source>
          <target state="translated">可以使用特殊列名ROWID、_ROWID_或OID中的一个来访问SQLite表的ROWID。除了如果你声明一个普通表列使用这些特殊名称之一,那么使用该名称将指的是声明的列而不是内部的ROWID。</target>
        </trans-unit>
        <trans-unit id="f9617c865e05039ea284590d342ff395b566aa5e" translate="yes" xml:space="preserve">
          <source>You can add new custom &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766fd041e7449721a800b8d56d1a550c8e84e175" translate="yes" xml:space="preserve">
          <source>You can add new custom &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</source>
          <target state="translated">您可以在运行时使用&amp;ldquo; .load&amp;rdquo;命令将新的自定义&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;，&lt;a href=&quot;datatype3#collation&quot;&gt;排序序列&lt;/a&gt;，&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;和&lt;a href=&quot;vfs&quot;&gt;VFS添加&lt;/a&gt;到命令行外壳。首先，将扩展转换为DLL或共享库（如&amp;ldquo; &lt;a href=&quot;loadext&quot;&gt;运行时可加载扩展&amp;rdquo;&lt;/a&gt;文档中所述），然后键入：</target>
        </trans-unit>
        <trans-unit id="f503e6243f11ce8864a2a2815733bb53ffb62dce" translate="yes" xml:space="preserve">
          <source>You can also process the results of a query one row at a time by specifying the name of an array variable and a script following the SQL code. For each row of the query result, the values of all columns will be inserted into the array variable and the script will be executed. For instance:</source>
          <target state="translated">你也可以通过指定一个数组变量的名称和SQL代码后的脚本,一次只处理一行的查询结果。对于查询结果的每一行,所有列的值都会被插入数组变量中,并执行脚本。例如</target>
        </trans-unit>
        <trans-unit id="cff814001d9391d1134a9599b4429c6538fee547" translate="yes" xml:space="preserve">
          <source>You can also provide the virtual table with a &quot;rank&quot; for each word. The &quot;rank&quot; is an estimate of how common the word is. Larger numbers mean the word is more common. If you omit the rank when populating the table, then a rank of 1 is assumed. But if you have rank information, you can supply it and the virtual table will show a slight preference for selecting more commonly used terms. To populate the rank from an fts4aux table &quot;search_aux&quot; do something like this:</source>
          <target state="translated">您还可以为虚拟表格提供每个单词的 &quot;等级&quot;。&quot;等级 &quot;是对该词常见程度的估计。数字越大表示该词越常见。如果您在填充表格时省略了等级,那么假定等级为1。但如果您有等级信息,您可以提供它,虚拟表格将显示出选择更常用的术语的轻微偏好。要从fts4aux表 &quot;search_aux &quot;中填充rank,可以这样做。</target>
        </trans-unit>
        <trans-unit id="adf32fc901d0b3c9c4d8f663c01fbe75c182af0b" translate="yes" xml:space="preserve">
          <source>You can also request a reverse-order sort like this:</source>
          <target state="translated">你也可以申请这样的倒序排序。</target>
        </trans-unit>
        <trans-unit id="6faf0acbd59c9b880e0b1c9b8cab39235a6257e9" translate="yes" xml:space="preserve">
          <source>You can call your project anything you like. The &quot;&lt;code&gt;.fossil&lt;/code&gt;&quot; suffix is optional. For this document, we will continue to call the project &quot;&lt;code&gt;private-project.fossil&lt;/code&gt;&quot;. Note that &lt;code&gt;private-project.fossil&lt;/code&gt; is an ordinary disk file (actually an SQLite database) that will contain your complete project history. You can make a backup of the project simply by making a copy of that one file.</source>
          <target state="translated">您可以随心所欲地调用项目。后缀&amp;ldquo; &lt;code&gt;.fossil&lt;/code&gt; &amp;rdquo;是可选的。对于本文档，我们将继续将项目称为&amp;ldquo; &lt;code&gt;private-project.fossil&lt;/code&gt; &amp;rdquo;。请注意， &lt;code&gt;private-project.fossil&lt;/code&gt; 是一个普通的磁盘文件（实际上是一个SQLite数据库），它将包含您的完整项目历史记录。您只需复制该文件即可对项目进行备份。</target>
        </trans-unit>
        <trans-unit id="a7e393b006953ea5c66642b8797a473726aa00ab" translate="yes" xml:space="preserve">
          <source>You can have multiple checkouts of the same project if you want. And you can &quot;clone&quot; the repository to different machines so that multiple developers can use it. See the fossil website for further information.</source>
          <target state="translated">如果你想的话,你可以对同一个项目进行多个签出。而且你可以把仓库 &quot;克隆 &quot;到不同的机器上,这样多个开发者就可以使用它。更多信息请参见化石网站。</target>
        </trans-unit>
        <trans-unit id="0eaaecfbb43e45dd392f3506c8da0516ce5d97d1" translate="yes" xml:space="preserve">
          <source>You can run the &quot;info&quot; command again to verify that you are on the private branch. To go back to the public branch, type:</source>
          <target state="translated">你可以再次运行 &quot;info &quot;命令来验证你是否在私有分支上。要回到公共分支,键入。</target>
        </trans-unit>
        <trans-unit id="445e03eebf2a496b04ef2b41a7e5575686b7c24c" translate="yes" xml:space="preserve">
          <source>You can see how SQLite constructs nested loops in the following example:</source>
          <target state="translated">你可以在下面的例子中看到SQLite如何构造嵌套循环。</target>
        </trans-unit>
        <trans-unit id="64e589fcb69790fd074e7b79362cd1b733d9786f" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to do a thorough but time intensive test of the database integrity.</source>
          <target state="translated">您可以使用&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;对数据库完整性进行彻底但耗时的测试。</target>
        </trans-unit>
        <trans-unit id="89132b9f9cffd74c2cdc7fb086ca8110533325a1" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; to do a faster but less thorough test of the database integrity.</source>
          <target state="translated">您可以使用&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;对数据库完整性进行更快但不太彻底的测试。</target>
        </trans-unit>
        <trans-unit id="322edc4ffe1c2dcc35efd77efa0d7e1857777962" translate="yes" xml:space="preserve">
          <source>You can use the &quot;.mode&quot; dot command to switch between these output formats. &amp;gt;The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92aed886574f82b46aed1073eadf0a43514f93b" translate="yes" xml:space="preserve">
          <source>You cannot &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; a view. Views are read-only in SQLite. However, in many cases you can use an &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF trigger&lt;/a&gt; on the view to accomplish the same thing. Views are removed with the &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; command.</source>
          <target state="translated">您不能&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;或&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;视图。在SQLite中，视图是只读的。但是，在许多情况下，您可以在视图上使用&lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF触发器&lt;/a&gt;来完成相同的操作。使用&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;命令删除视图。</target>
        </trans-unit>
        <trans-unit id="e3029ec6343085341759c5984c721d08ac8eda9c" translate="yes" xml:space="preserve">
          <source>You lose Durability with asynchronous I/O, but you still retain the other parts of ACID: Atomic, Consistent, and Isolated. Many applications get along fine without the Durability.</source>
          <target state="translated">你失去了异步I/O的耐用性,但你仍然保留了ACID的其他部分:原子的、一致的和隔离的。许多应用在没有Durability的情况下也能正常运行。</target>
        </trans-unit>
        <trans-unit id="2edf5e92e2eb8b4ae5fa4b416e11d2c19ee0f6b2" translate="yes" xml:space="preserve">
          <source>You may want to add additional compiler options, of course, according to the needs of your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd05146b6c50e8243d5d884c39ba78d8eacc3ab" translate="yes" xml:space="preserve">
          <source>You might also want to implement your new virtual table as a &lt;a href=&quot;c3ref/load_extension&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">您可能还希望将新的虚拟表实现为&lt;a href=&quot;c3ref/load_extension&quot;&gt;可加载扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5967e28677480dfa358973a1823f7ea8ef646b1f" translate="yes" xml:space="preserve">
          <source>You might also want to implement your new virtual table as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0efe31561de911c0e8b4a9d062c5a0f356df3b" translate="yes" xml:space="preserve">
          <source>You should not assume that a CVE about SQLite contains authoritative information. CVEs often contain inaccuracies. The SQLite developers have attempted to add clarifications and corrections to CVEs about SQLite, but without success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bedd0d05da99d3f3471d33a570e1e743621d6387" translate="yes" xml:space="preserve">
          <source>You will be prompted for a check-in comment. Say whatever you like. After the commit completes, your baseline will be part of the repository. The following command, if you like, to see this on the &quot;timeline&quot;:</source>
          <target state="translated">系统会提示你进行签到评论。你可以说任何你想说的。提交完成后,你的基线将成为版本库的一部分。如果你愿意,可以用下面的命令在 &quot;时间轴 &quot;上查看。</target>
        </trans-unit>
        <trans-unit id="fd47b0381210b18fb651f05af57837f2ec742bdf" translate="yes" xml:space="preserve">
          <source>You will be prompted once again to enter a commit describing your changes. Then the commit will occur. The commit creates a new checkin in the repository that corresponds to circle (3) in the diagram above.</source>
          <target state="translated">你会再次被提示输入一个描述你的修改的提交。然后提交就会发生。提交会在版本库中创建一个新的签入,对应上图中的圆圈(3)。</target>
        </trans-unit>
        <trans-unit id="d5cd5e33edb7ba1f8da45a2c106b29f5d941a815" translate="yes" xml:space="preserve">
          <source>You will do well to customize the name of your entry point to correspond to the name of the shared library you will be generating, rather than using the generic &quot;sqlite3_extension_init&quot; name. Giving your extension a custom entry point name will enable you to statically link two or more extensions into the same program without a linker conflict, if you later decide to use static linking rather than run-time linking. If your shared library ends up being named &quot;YourCode.so&quot; or &quot;YourCode.dll&quot; or &quot;YourCode.dylib&quot; as shown in the compiler examples above, then the correct entry point name would be &quot;sqlite3_yourcode_init&quot;.</source>
          <target state="translated">你最好自定义你的入口点的名称,使其与你将要生成的共享库的名称相对应,而不是使用通用的 &quot;sqlite3_extension_init &quot;名称。给你的扩展取一个自定义的入口点名称,将使你能够将两个或多个扩展静态地链接到同一个程序中,而不会发生链接器冲突,如果你以后决定使用静态链接而不是运行时链接的话。如果你的共享库最终被命名为 &quot;YourCode.so &quot;或 &quot;YourCode.dll &quot;或 &quot;YourCode.dylib&quot;,如上面的编译器示例所示,那么正确的入口点名称应该是 &quot;sqlite3_yourcode_init&quot;。</target>
        </trans-unit>
        <trans-unit id="7ea7cb4b66409b042916564a60165ee172534600" translate="yes" xml:space="preserve">
          <source>You will notice that there is no &quot;sort&quot; box anywhere in the above diagram. The ORDER BY clause of the query has become a no-op. No sorting has to be done here because the output order is by the state column and the state column also happens to be the first column after the fruit column in the index. So, if we scan entries of the index that have the same value for the fruit column from top to bottom, those index entries are guaranteed to be ordered by the state column.</source>
          <target state="translated">你会注意到,上图中任何地方都没有 &quot;排序 &quot;框。查询中的ORDER BY子句已经变成了一个无选项。这里不需要进行排序,因为输出顺序是按状态列,而状态列也正好是索引中水果列之后的第一列。所以,如果我们从上到下扫描索引中果列值相同的条目,这些索引条目保证按状态列排序。</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="de7c952ac8080a02c7ac9ceb0a498a6696e8a4ba" translate="yes" xml:space="preserve">
          <source>ZIP Archive (using &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;)</source>
          <target state="translated">ZIP存档（使用&lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="aed9db86a6be4caef2cf6fe06f1642f420130c81" translate="yes" xml:space="preserve">
          <source>ZIP Archive (using Info-ZIP 3.0)</source>
          <target state="translated">ZIP档案(使用Info-ZIP 3.0)</target>
        </trans-unit>
        <trans-unit id="02df620236f2819dde38ac784010df88429081e2" translate="yes" xml:space="preserve">
          <source>Zero Scan-Status Counters</source>
          <target state="translated">零扫描状态计数器</target>
        </trans-unit>
        <trans-unit id="1c76cf24ab11047f65399e2ad41b068487b4d36e" translate="yes" xml:space="preserve">
          <source>Zero all &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; related event counters.</source>
          <target state="translated">将所有与&lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（）&lt;/a&gt;相关的事件计数器清零。</target>
        </trans-unit>
        <trans-unit id="0189ea1500b8f88a4d451f2fe03811a0d2084600" translate="yes" xml:space="preserve">
          <source>Zero all &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; related event counters.</source>
          <target state="translated">将所有与&lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（）&lt;/a&gt;相关的事件计数器清零。</target>
        </trans-unit>
        <trans-unit id="3ab2b2e76dc0457f3573e771bc76b7e1dc6d462e" translate="yes" xml:space="preserve">
          <source>Zero or more changesets (or patchsets) are added to the object by calling sqlite3changegroup_add().</source>
          <target state="translated">通过调用sqlite3changegroup_add()将零个或多个变化集(或补丁集)添加到对象中。</target>
        </trans-unit>
        <trans-unit id="ec69186fcac6fdc7aea5f5bb931cc915fc4d16f5" translate="yes" xml:space="preserve">
          <source>Zero or more escape sequences of the form &quot;&lt;b&gt;%&lt;i&gt;HH&lt;/i&gt;&lt;/b&gt;&quot; (where &lt;b&gt;&lt;i&gt;H&lt;/i&gt;&lt;/b&gt; represents any hexadecimal digit) can occur in the path, query string, or fragment.</source>
          <target state="translated">路径，查询字符串或片段中可能出现零个或多个&amp;ldquo; &lt;b&gt;％&lt;i&gt;HH&lt;/i&gt;&lt;/b&gt; &amp;rdquo; 形式的转义序列（其中&lt;b&gt;&lt;i&gt;H&lt;/i&gt;&lt;/b&gt;代表任何十六进制数字）。</target>
        </trans-unit>
        <trans-unit id="de6b47760256c38c352e812a03525532f246ee01" translate="yes" xml:space="preserve">
          <source>Zero or more of the following constants can be OR-ed together for the F argument to &lt;a href=&quot;#sqlite3_serialize&quot;&gt;sqlite3_serialize(D,S,P,F)&lt;/a&gt;.</source>
          <target state="translated">对于&lt;a href=&quot;#sqlite3_serialize&quot;&gt;sqlite3_serialize（D，S，P，F）&lt;/a&gt;的F参数，可以将以下常量中的零个或更多个常量进行或运算。</target>
        </trans-unit>
        <trans-unit id="9f8269aa118af918f1a488e66741b01a907d6b33" translate="yes" xml:space="preserve">
          <source>Zero or more of the following constants can be OR-ed together for the F argument to &lt;a href=&quot;serialize&quot;&gt;sqlite3_serialize(D,S,P,F)&lt;/a&gt;.</source>
          <target state="translated">对于&lt;a href=&quot;serialize&quot;&gt;sqlite3_serialize（D，S，P，F）&lt;/a&gt;的F参数，可以将以下常量中的零个或更多个常量进行或运算。</target>
        </trans-unit>
        <trans-unit id="38a2e2f1db1e01b0a7b783b044e5fd65c8987a39" translate="yes" xml:space="preserve">
          <source>Zero or more term-offset lists. A term-offset list is present for each column of the FTS virtual table that contains the term. A term-offset list consists of the following:</source>
          <target state="translated">零个或多个术语偏移列表。FTS虚拟表中包含术语的每一列都有一个术语偏移列表。术语偏移列表包括以下内容:</target>
        </trans-unit>
        <trans-unit id="2515b49203ae7509e436f1b0d49f1c8ee6f4b1c9" translate="yes" xml:space="preserve">
          <source>Zero-Configuration</source>
          <target state="translated">Zero-Configuration</target>
        </trans-unit>
        <trans-unit id="eb706c03a671590ecb5597ee5876c02079a3bb36" translate="yes" xml:space="preserve">
          <source>Zipfile is included in most builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Zipfile包含在大多数&lt;a href=&quot;cli&quot;&gt;命令行Shell中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17013934d72000f10774f09cdfd9e948aabb0622" translate="yes" xml:space="preserve">
          <source>[+-]HH:MM</source>
          <target state="translated">[+-]HH:MM</target>
        </trans-unit>
        <trans-unit id="41cd6acf1ea38a1aa799ac385ce472b7a37c5a7c" translate="yes" xml:space="preserve">
          <source>[Top]</source>
          <target state="translated">[Top]</target>
        </trans-unit>
        <trans-unit id="6eb6de05767c9dc240cdb86a107e8527d6654c55" translate="yes" xml:space="preserve">
          <source>]&quot;.</source>
          <target state="translated">]&quot;.</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="c8cfbdcc11a659b37fda2e901e339fc12d9d6f46" translate="yes" xml:space="preserve">
          <source>a file causes all modifications to the file up until that point to be committed to persistent storage.</source>
          <target state="translated">导致所有对文件的修改都会被提交到持久化存储中。</target>
        </trans-unit>
        <trans-unit id="99cb3c351b6439359c3dacbec2f049764ce3028c" translate="yes" xml:space="preserve">
          <source>a journal file may contain. Following the</source>
          <target state="translated">日志文件可能包含的内容。遵循</target>
        </trans-unit>
        <trans-unit id="5cc80862da2aa33790fc037208b79509f1c557d6" translate="yes" xml:space="preserve">
          <source>a power failure.</source>
          <target state="translated">断电。</target>
        </trans-unit>
        <trans-unit id="2d1a9beeff6f7710a34b3c2405a0c15a35e9231d" translate="yes" xml:space="preserve">
          <source>a program crash,</source>
          <target state="translated">程序崩溃。</target>
        </trans-unit>
        <trans-unit id="044751c5b1c31e8b348678fdf3c4db6f20debbf5" translate="yes" xml:space="preserve">
          <source>a working VFS implementation.</source>
          <target state="translated">一个有效的VFS实施。</target>
        </trans-unit>
        <trans-unit id="b66efa612eeb7d14f8d4f699c7f42ef4efb2b728" translate="yes" xml:space="preserve">
          <source>a working memory allocation subsystem (assuming it lacks malloc() in its standard library), and</source>
          <target state="translated">工作内存分配子系统(假设它的标准库中没有malloc()),以及</target>
        </trans-unit>
        <trans-unit id="f0125a8f48ac7cbf3a0fa6f9e607bcb1e7c92c25" translate="yes" xml:space="preserve">
          <source>a working mutex subsystem (but only if it is multithreaded),</source>
          <target state="translated">工作的mutex子系统(但必须是多线程的)。</target>
        </trans-unit>
        <trans-unit id="2708db21dcd7430a52e6469ee28e1cfe107f6d3c" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c!=25</source>
          <target state="translated">a&amp;gt; b &amp;amp;&amp;amp; c！= 25</target>
        </trans-unit>
        <trans-unit id="4df530c1726c0c2dee72ae091abc6bd6366e8d88" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c==25</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52869f9771a308e55286d56b7765c30b708737a" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c==25 =b&amp;gt;</source>
          <target state="translated">a&amp;gt; b &amp;amp;&amp;amp; c == 25 = b&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5ba16853ba475b847e9429658486a0e661f3bc0e" translate="yes" xml:space="preserve">
          <source>a&amp;lt;=b</source>
          <target state="translated">a&amp;lt;=b</target>
        </trans-unit>
        <trans-unit id="9e998d733fc47f01798c218ccb15b1375f8ca7c0" translate="yes" xml:space="preserve">
          <source>aAtomically releases the mutex and begins waiting for the asynchronous signal. When the signal arrives, continue.</source>
          <target state="translated">a原子释放mutex,开始等待异步信号。当信号到达时,继续。</target>
        </trans-unit>
        <trans-unit id="d068232ae7c98b60d3a07f78329a8f8cd2f26cec" translate="yes" xml:space="preserve">
          <source>aCksum</source>
          <target state="translated">aCksum</target>
        </trans-unit>
        <trans-unit id="a28254579c1920fcb23f28e750841b8ea01ece0f" translate="yes" xml:space="preserve">
          <source>aFrameCksum</source>
          <target state="translated">aFrameCksum</target>
        </trans-unit>
        <trans-unit id="8c9e7345f56d0515bc5b2a5a870c41d7b20d851a" translate="yes" xml:space="preserve">
          <source>aSalt</source>
          <target state="translated">aSalt</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="3e0d398e9ad5183bd74b0f22b3607f6d2d47ead6" translate="yes" xml:space="preserve">
          <source>abort() if X is false</source>
          <target state="translated">abort(),如果X为false</target>
        </trans-unit>
        <trans-unit id="c9f50c848be6913a38840cd508defd4c03582b92" translate="yes" xml:space="preserve">
          <source>abort() if X is true</source>
          <target state="translated">abort(),如果X为真</target>
        </trans-unit>
        <trans-unit id="f486f320564a8de306d258d39e1ac70a94dc6b0b" translate="yes" xml:space="preserve">
          <source>abs()</source>
          <target state="translated">abs()</target>
        </trans-unit>
        <trans-unit id="175250e2ace0eb1ce52a755c70fb5f1e848bdc1d" translate="yes" xml:space="preserve">
          <source>abs(X)</source>
          <target state="translated">abs(X)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="e026c9e0723fb491279a1eff3c805402a81d6cd2" translate="yes" xml:space="preserve">
          <source>ad hoc</source>
          <target state="translated">特设</target>
        </trans-unit>
        <trans-unit id="3cfcd3a79bc61923da5dfbb696d2409e4b2955e4" translate="yes" xml:space="preserve">
          <source>added to the journal file since the header was written.</source>
          <target state="translated">在写完标题后,添加到日志文件中。</target>
        </trans-unit>
        <trans-unit id="e62854369199d65b6a66cd90fe8203ac4d5be26c" translate="yes" xml:space="preserve">
          <source>advanced</source>
          <target state="translated">advanced</target>
        </trans-unit>
        <trans-unit id="9fca44c2ac1801310ef43bc3ad99ef04caf5190c" translate="yes" xml:space="preserve">
          <source>against the next row in the partition. Or, if there is no next row (because the current row is the last), NULL.</source>
          <target state="translated">对照分区中的下一行。或者,如果没有下一行(因为当前行是最后一行),则为NULL。</target>
        </trans-unit>
        <trans-unit id="fc7e290f7ebb032393569e65485ec8d9e70de97a" translate="yes" xml:space="preserve">
          <source>against the previous row in the partition. Or, if there is no previous row (because the current row is the first), NULL.</source>
          <target state="translated">对照分区中的前一行。或者,如果没有前一行(因为当前行是第一行),则为NULL。</target>
        </trans-unit>
        <trans-unit id="deb7d98201c161da24f10c309ec91b3c307e1924" translate="yes" xml:space="preserve">
          <source>against the row</source>
          <target state="translated">靠排</target>
        </trans-unit>
        <trans-unit id="bccf7370fc6bc7e65ebb00bcd447b407dc6e3ec1" translate="yes" xml:space="preserve">
          <source>aggregate functions</source>
          <target state="translated">汇总函数</target>
        </trans-unit>
        <trans-unit id="c0b3f3a802faf343304cca8929b77fc1f241297f" translate="yes" xml:space="preserve">
          <source>aggregate-function-invocation</source>
          <target state="translated">aggregate-function-invocation</target>
        </trans-unit>
        <trans-unit id="17422272e67559a3f7043ba681f79c857b96e811" translate="yes" xml:space="preserve">
          <source>aggregate-function-invocation:</source>
          <target state="translated">aggregate-function-invocation:</target>
        </trans-unit>
        <trans-unit id="0ce6198cbd869f28abe7f6b1573ce0dca8a6170f" translate="yes" xml:space="preserve">
          <source>aligned offset. If the</source>
          <target state="translated">对齐的偏移量。如果</target>
        </trans-unit>
        <trans-unit id="82f012d8e89e96e64b5b43b4004cf3ddd68b00da" translate="yes" xml:space="preserve">
          <source>aligned offset. To achieve this, unused space may be left between the start of the second and subsequent</source>
          <target state="translated">对齐的偏移量。为了实现这一点,可以在第二个和后续的开始之间留下未使用的空间。</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="e5a003eeac959723c3ac098ade590d12e2399fce" translate="yes" xml:space="preserve">
          <source>all compound operators must be UNION ALL, and</source>
          <target state="translated">所有复合运算符必须是UNION ALL,并且</target>
        </trans-unit>
        <trans-unit id="00c64f4edd51735ee4805d2cd8ebddb9e26e5786" translate="yes" xml:space="preserve">
          <source>along with a check-sum and some well known values that allow the</source>
          <target state="translated">以及一个校验和和一些众所周知的值,使</target>
        </trans-unit>
        <trans-unit id="4279d9254704eb29ea44fb0e50a8ddb988cb2a74" translate="yes" xml:space="preserve">
          <source>alter-table-stmt</source>
          <target state="translated">alter-table-stmt</target>
        </trans-unit>
        <trans-unit id="c11a9c425781e80397705cfadef04d01cc8571d9" translate="yes" xml:space="preserve">
          <source>alter-table-stmt:</source>
          <target state="translated">alter-table-stmt:</target>
        </trans-unit>
        <trans-unit id="c3869211fefbf6b6e81eafcd0da03d8e0475ead7" translate="yes" xml:space="preserve">
          <source>always contain NULL values. For detail=none FTS5 tables, there is one row in the fts5vocab table for each unique term/doc combination.</source>
          <target state="translated">总是包含NULL值。对于detail=none的FTS5表,在fts5vocab表中,每一个独特的术语/文件组合都有一行。</target>
        </trans-unit>
        <trans-unit id="78cf975130f01cdd3fb405501316e890ca5febeb" translate="yes" xml:space="preserve">
          <source>always false</source>
          <target state="translated">总是假的</target>
        </trans-unit>
        <trans-unit id="6cef04a132263fde51363b40fa3650c95beaa2e8" translate="yes" xml:space="preserve">
          <source>always occurs immediately after</source>
          <target state="translated">始终发生在</target>
        </trans-unit>
        <trans-unit id="8d366ac66fb75ef6f601b4c82844cb7dabd40b61" translate="yes" xml:space="preserve">
          <source>always true</source>
          <target state="translated">始终如一</target>
        </trans-unit>
        <trans-unit id="99d26625ec46b669549bed203aadeeb8e64a4713" translate="yes" xml:space="preserve">
          <source>an operating system crash, or</source>
          <target state="translated">操作系统崩溃,或</target>
        </trans-unit>
        <trans-unit id="e8db58b357be34c74707754f9ca1081a83143c52" translate="yes" xml:space="preserve">
          <source>analysis_limit</source>
          <target state="translated">analysis_limit</target>
        </trans-unit>
        <trans-unit id="1350a1a764c20c868eadef7c58ee7702c2de5903" translate="yes" xml:space="preserve">
          <source>analyze-stmt</source>
          <target state="translated">analyze-stmt</target>
        </trans-unit>
        <trans-unit id="09eeed07e3a7b9306cc98d6241ef6473440a058c" translate="yes" xml:space="preserve">
          <source>analyze-stmt:</source>
          <target state="translated">analyze-stmt:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="c6138c4ccbaf04ec977b0820c3026e263f957c37" translate="yes" xml:space="preserve">
          <source>and close the file handle opened on the</source>
          <target state="translated">并关闭在</target>
        </trans-unit>
        <trans-unit id="6a33f8ae1b5e041f1c572480c32c63e5cf451da7" translate="yes" xml:space="preserve">
          <source>and delete the</source>
          <target state="translated">并删除</target>
        </trans-unit>
        <trans-unit id="b548e44c6b3e17d130e04633195b82b65a7a2d94" translate="yes" xml:space="preserve">
          <source>and must not be rolled back.</source>
          <target state="translated">且不得回滚。</target>
        </trans-unit>
        <trans-unit id="9daed09ae8efcee7e50da2fbe84487fe3eebb5b9" translate="yes" xml:space="preserve">
          <source>and optionally a</source>
          <target state="translated">和可选的a</target>
        </trans-unit>
        <trans-unit id="52d79db62a2014940054db6b52cb55b0ffc7318b" translate="yes" xml:space="preserve">
          <source>and query</source>
          <target state="translated">和查询</target>
        </trans-unit>
        <trans-unit id="95a8e5d9020987b9a76b684159376ad45fec7409" translate="yes" xml:space="preserve">
          <source>and read data from a database file.</source>
          <target state="translated">并从数据库文件中读取数据。</target>
        </trans-unit>
        <trans-unit id="8b160fc621bf3b69e2326873b90cc01b0f9a0064" translate="yes" xml:space="preserve">
          <source>and so on. There is no limit to the number of</source>
          <target state="translated">以此类推。没有限制的</target>
        </trans-unit>
        <trans-unit id="38d402cb5ba5ced669d83f33b900f232ec58d72a" translate="yes" xml:space="preserve">
          <source>and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b8b92104263669b82872f84cf196bc98a98eb5" translate="yes" xml:space="preserve">
          <source>and the UPDATE statement has an ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are sorted according to the ORDER BY and the first</source>
          <target state="translated">和UPDATE语句有一个ORDER BY子句,那么在没有LIMIT子句的情况下,所有要更新的记录都会根据ORDER BY和第一个的</target>
        </trans-unit>
        <trans-unit id="05afb116d83a9696122e3d48be2ae0cf378a78fa" translate="yes" xml:space="preserve">
          <source>and the attempt to gain the</source>
          <target state="translated">和试图获得</target>
        </trans-unit>
        <trans-unit id="968ca042b5e705040bbdcde637032bd9d2191fa8" translate="yes" xml:space="preserve">
          <source>and the conflict resolution is REPLACE, then the INSERT change is removed from the local changeset (it was overridden). Or, if the conflict resolution was &quot;OMIT&quot;, then the local changeset is modified to instead contain:</source>
          <target state="translated">而冲突解决方式是 REPLACE,那么 INSERT 变更就会从本地变更集中移除(它被覆盖了)。或者,如果冲突决议是 &quot;OMIT&quot;,那么本地变更集被修改为包含。</target>
        </trans-unit>
        <trans-unit id="46ef05dae314b8dc0b295ce6a15936ec49d9c864" translate="yes" xml:space="preserve">
          <source>and the document:</source>
          <target state="translated">和文件。</target>
        </trans-unit>
        <trans-unit id="774d2fc3c7699ba3973db3b85b93a125fa1ced04" translate="yes" xml:space="preserve">
          <source>and the end of the</source>
          <target state="translated">和末尾</target>
        </trans-unit>
        <trans-unit id="fb25e092bff28e2eaa8cec1baf32904bb2e25d70" translate="yes" xml:space="preserve">
          <source>and the following statement to be compiled:</source>
          <target state="translated">并编制以下报表。</target>
        </trans-unit>
        <trans-unit id="0fc5d26e62acc1fc0ed886776026281e0524d63b" translate="yes" xml:space="preserve">
          <source>and the start of the</source>
          <target state="translated">和开始</target>
        </trans-unit>
        <trans-unit id="27af5c77771c98d19d67acedd038a87f8e2d9d7c" translate="yes" xml:space="preserve">
          <source>and the user queries the swarmvtab table for the row with rowid value 25. The swarmvtab table will open database file &quot;test.db3&quot; and read the data to return from table &quot;t1&quot; (as 25 falls within the range of rowids assigned to table &quot;t1&quot; in &quot;test.db3&quot;).</source>
          <target state="translated">和用户查询swarmvtab表的rowid值为25的行。swarmvtab表将打开数据库文件 &quot;test.db3&quot;,并读取从表 &quot;t1 &quot;返回的数据(因为25在 &quot;test.db3 &quot;中分配给表 &quot;t1 &quot;的行数范围内)。</target>
        </trans-unit>
        <trans-unit id="de0be95e333d30a19f869ffbb56d16bebe7fe727" translate="yes" xml:space="preserve">
          <source>and the value of every 200th byte of page data interpreted as an 8-bit unsigned integer, starting with the (</source>
          <target state="translated">和页面数据的第200个字节的值,解释为一个8位无符号整数,从(</target>
        </trans-unit>
        <trans-unit id="16e461131871bd88245e8305df882aa6184b6089" translate="yes" xml:space="preserve">
          <source>and their accompanying sets of</source>
          <target state="translated">及其所附的各套</target>
        </trans-unit>
        <trans-unit id="f26fbdb7a04f5b991f74b3d08c9ab8e827a0dee5" translate="yes" xml:space="preserve">
          <source>and write data to a database file.</source>
          <target state="translated">并将数据写入数据库文件。</target>
        </trans-unit>
        <trans-unit id="b766070cd38845876a6730a003cdf53665805c86" translate="yes" xml:space="preserve">
          <source>any file within the file system flushes all write operations on all files (not just the</source>
          <target state="translated">文件系统中的任何文件都会刷新所有文件的所有写操作(不仅仅是在</target>
        </trans-unit>
        <trans-unit id="86ebc97823e01049b3c5c82c964e3321c30d3460" translate="yes" xml:space="preserve">
          <source>any terms that begin with a specified prefix,</source>
          <target state="translated">任何以指定前缀开头的术语。</target>
        </trans-unit>
        <trans-unit id="20446ce193d349d88c1cb603fe2bfda6dd0fed46" translate="yes" xml:space="preserve">
          <source>appears to be an atomic event.</source>
          <target state="translated">似乎是一个原子事件。</target>
        </trans-unit>
        <trans-unit id="c0fabcb2564734cccb39fbb1003542faa693274f" translate="yes" xml:space="preserve">
          <source>append a new database page to the database file image, or</source>
          <target state="translated">将一个新的数据库页面添加到数据库文件映像中,或</target>
        </trans-unit>
        <trans-unit id="569e0c3e863ebdf5f2408ee1670ad397e2af3c31" translate="yes" xml:space="preserve">
          <source>application_id</source>
          <target state="translated">application_id</target>
        </trans-unit>
        <trans-unit id="bc7b492ad938673fdc3f7dd2d39d9a5b1a1313c5" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;atomic&lt;/b&gt; is the most complex task required of the system. In this case,</source>
          <target state="translated">是&lt;b&gt;原子&lt;/b&gt;是系统所需要的最复杂的任务。在这种情况下，</target>
        </trans-unit>
        <trans-unit id="1657250024276d885f227f57c87321ab8a021f1e" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;durable&lt;/b&gt; in the face of a system failure, SQLite executes a</source>
          <target state="translated">面对系统故障是&lt;b&gt;持久&lt;/b&gt;的，SQLite执行</target>
        </trans-unit>
        <trans-unit id="97b47e4a3bed52672d52be489b68d62ee41fad83" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;isolated&lt;/b&gt;, before beginning to modify the contents of the database file to reflect the results of a</source>
          <target state="translated">是&lt;b&gt;隔离的&lt;/b&gt;，在开始修改数据库文件的内容以反映一个结果之前</target>
        </trans-unit>
        <trans-unit id="d8439b6ce689a8c1e42407d9870989374b7c1510" translate="yes" xml:space="preserve">
          <source>are all fine. The foreign key declared as part of table</source>
          <target state="translated">都可以。作为表的一部分声明的外键</target>
        </trans-unit>
        <trans-unit id="1e602c1c2b5b75b949e9cd5732b604bdf14a97ae" translate="yes" xml:space="preserve">
          <source>are applied.</source>
          <target state="translated">是适用的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
