<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">重要的是要验证gcov测试运行和第二个实际测试运行是否都给出了相同的输出。任何输出的差异都表明在SQLite代码中使用了未定义或不确定的行为(因此是一个bug),或者是编译器中的一个bug。请注意,在过去的十年中,SQLite在GCC、Clang和MSVC中都遇到了bug。编译器的bug虽然很少,但确实会发生,这就是为什么在已交付的配置中测试代码是如此重要。</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">我们不可能测试SQLite的每一个可能的编译时选项组合。但下面这组编译时选项是一个总是经过全面测试的配置。</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">当然，使用实际电源故障进行崩溃测试是不切实际的，因此崩溃测试是在仿真中完成的。插入了备用的&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;，该虚拟文件系统允许测试工具在崩溃后模拟数据库文件的状态。</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">如果命名的表在数据库中不存在,这并不是一个错误,如果命名的表没有PRIMARY KEY,也不是一个错误。如果命名的表没有PRIMARY KEY,也不是错误。但是,在这两种情况下都不会记录任何变化。</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">创建与现有&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;同名的表不是错误。</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">多次评估&lt;em&gt;完全相同的&lt;/em&gt; SQL语句通常没有用。通常，人们想评估类似的陈述。例如，您可能想使用不同的值多次评估INSERT语句。或者，您可能想使用WHERE子句中的不同键多次评估同一查询。为了适应这种情况，SQLite允许SQL语句包含在评估之前&amp;ldquo;绑定&amp;rdquo;到值的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。以后可以更改这些值，并且可以使用新值再次评估相同的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">在Git中找到签到的后代并非不可能。这只是困难。例如，有一个&lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow页面，&lt;/a&gt;显示用于在unix中查找签入后代的命令序列：</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">索引的每一列都不必出现在WHERE子句项中才能使用该索引。但是使用的索引列中不能有空白。因此，对于上面的示例索引，如果没有约束列c的WHERE子句，则约束列a和b的术语可以与索引一起使用，而不约束d到z的术语。同样，如果索引列位于仅受不等式约束的列的右侧，则通常将不使用（出于索引目的）。 （有关例外情况，请参见下面的&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">从会话集中提取变更集或补丁集后，无需删除会话对象。可以将其保留在数据库句柄上，并将像以前一样继续监视已配置表上的更改。但是，如果&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;再次&lt;/a&gt;在会话对象上调用sqlite3session_changeset（）或&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;，则更改集或补丁集将包含自创建会话以来在连接上进行的&lt;em&gt;所有&lt;/em&gt;更改。换句话说，通过调用sqlite3session_changeset（）或sqlite3session_patchset（）不会重置会话对象或将其清零。</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">对于第一次事务后的事务,没有必要在数据库头中增加更改计数器。这样做往往可以节省对回滚日志和主数据库文件的第一页的写入。</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">检索数据不需要用sqlite3_column_type()指定的格式,如果要求不同的格式,数据会自动转换。如果要求使用不同的格式,数据会自动转换。</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">单个FTS查询不可能返回具有不同languageid值的行。未添加使用其他运算符（例如lid！= 5或lid &amp;lt;= 5）的WHERE子句的结果。</target>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">不可能对存储在无内容的FTS4表中的记录进行UPDATE或DELETE。试图这样做是一个错误。</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">进入WAL模式后，无论是在空数据库上，还是使用&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;或使用&lt;a href=&quot;backup&quot;&gt;备份API&lt;/a&gt;从备份中还原，都无法更改&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;。您必须处于回滚日志模式才能更改页面大小。</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">在&lt;a href=&quot;lang_transaction&quot;&gt;多语句事务&lt;/a&gt;的中间（当SQLite不在&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;自动提交模式时&lt;/a&gt;），不能启用或禁用外键约束。尝试这样做不会返回错误；它根本没有效果。</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">不可能使用 &quot;ALTER TABLE ...ADD COLUMN &quot;语法来添加一个包含REFERENCES子句的列,除非新列的默认值是NULL。试图这样做会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">一次在多个线程中读取或修改此变量是不安全的。如果在单独的线程中同时使用&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接，&lt;/a&gt;则不安全地读取或修改此变量。打算在进程初始化过程中以及在调用任何SQLite接口例程之前，一次设置此变量，此后此变量保持不变。</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">一次在多个线程中读取或修改此变量是不安全的。如果在单独的线程中同时使用&lt;a href=&quot;sqlite3&quot;&gt;数据库连接，&lt;/a&gt;则不安全地读取或修改此变量。打算在进程初始化过程中以及在调用任何SQLite接口例程之前，一次设置此变量，此后此变量保持不变。</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">可以为同一个单词建立多个条目,只要每个条目有不同的soundslike值。注意,如果没有指定soundslike值,soundslike默认为单词本身。</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">如果要静态链接两个或多个扩展,使用基于扩展文件名的入口点名称,而不是通用的 &quot;sqlite3_extension_init &quot;入口点名称尤为重要。如果你使用通用的名称,就会出现同一个符号的多个定义,链接就会失败。</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">允许注册同一函数的多个实现,名称相同,但参数数量不同,或首选文本编码不同。SQLite将使用最接近SQL函数使用方式的实现。一个具有非负的nArg参数的函数实现比一个具有负的nArg的函数实现更匹配。一个首选文本编码与数据库编码相匹配的函数,比编码不同的函数更匹配。编码差异在UTF16le和UTF16be之间的函数比编码差异在UTF8和UTF16之间的函数匹配度更高。</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">库编译时C预处理程序符号&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;可能会覆盖此编译指示设置。下表总结了&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;预处理程序宏和temp_store编译指示的交互：</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">证明者将来的增强可能使它能够认识到某些内置函数的NULL输入始终会导致NULL答案。但是并非所有内置函数都具有该属性（例如，&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;），并且当然，证明者将永远无法推理&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">可以建立一种特殊的&lt;a href=&quot;amalgamation&quot;&gt;合并方法&lt;/a&gt;，该方法可以与一组预定的SQLITE_OMIT _...选项一起使用。有关说明，请参见&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">可以在一个数据库句柄上创建多个会话对象。</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">当然,也可以扩展自定义或文件堆格式,但做起来往往要困难得多。如果添加了索引,那么所有修改相应表的应用程序代码都必须定位和修改,以保持这些索引的更新。如果增加了列,那么必须找到并修改所有访问相应表的应用代码,以考虑到新的列。</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">只要函数的两种形式的参数数量不同，就有可能具有与简单函数同名的聚合函数。例如，带有单个参数的&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max（）&lt;/a&gt;函数是一个聚合，带有两个或多个参数的&lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max（）&lt;/a&gt;函数是一个简单函数。集合函数通常也可以用作窗口函数。</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">为了SELECT DISTINCT和UNION的目的，可以使SQLite将NULL区别对待。为此，应在 &lt;code&gt;sqliteInt.h&lt;/code&gt; 源文件中更改NULL_ALWAYS_DISTINCT #define的值，然后重新编译。</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">通过在执行命令之前和之后检查&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; API 返回的值，可以判断'merge'命令是否找到了要合并的b树。如果两个值之间的差为2或更大，则执行工作。如果差异小于2，则&amp;ldquo;合并&amp;rdquo;命令为无操作。在这种情况下，至少在下一次更新FTS表之前，没有理由再次执行相同的&amp;ldquo;合并&amp;rdquo;命令。</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">可以向 &quot;t2 &quot;表写入,从而改变索引的内容。但是这样做会使 &quot;t1bc &quot;索引与其父表 &quot;t1 &quot;不同步。一个不同步的索引会导致不正确的查询结果。</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">建议应用程序通过明确地发出ROLLBACK命令来响应上述错误。如果事务已经被错误响应自动回滚,那么ROLLBACK命令就会以错误失败,但不会因此造成伤害。</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">从不同于当前正在运行数据库操作的线程的线程中调用此例程是安全的。但是，在sqlite3_interrupt（）返回之前已关闭或可能已关闭的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;中调用此例程并不安全。</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">从不同于当前正在运行数据库操作的线程的线程中调用此例程是安全的。但是，在sqlite3_interrupt（）返回之前已关闭或可能已关闭的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;中调用此例程并不安全。</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">在xConflict回调中执行SQL语句是安全的,包括那些写到回调相关的表的语句。这可以用来进一步定制应用程序的冲突解决策略。</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">有时,SQLite扩展可以方便地在子组件之间或扩展与应用程序之间进行非SQL值的通信。以下是一些例子。</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">用户仍有责任确保外部内容FTS5表的内容与内容表保持一致。一种方法是用触发器来实现。例如:</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">调用该函数成功后,调用者有责任最终在*ppOut指针上调用sqlite3_free()来释放缓冲区分配。</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">调用者有责任通过将迭代器传递给&lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）&lt;/a&gt;来最终销毁该迭代器。包含变更集（pChangeset）的缓冲区必须保持有效，直到销毁迭代器为止。</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">调用者有责任通过将迭代器传递给&lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）&lt;/a&gt;来最终销毁该迭代器。包含变更集（pChangeset）的缓冲区必须保持有效，直到销毁迭代器为止。</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">的确,应用程序有时会从不受信任的来源导入完整的二进制SQLite数据库文件,这种导入可能会带来一个可能的攻击载体。然而,SQLite中的那些代码路径是有限的,并且经过了极好的测试。而且对于想要读取不受信任数据库的应用程序来说,预验证例程可以帮助在使用前检测可能的攻击。</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">如果试图在数据库中创建一个新的表,而这个表已经包含了一个同名的表、索引或视图,这通常是一个错误。但是,如果在CREATE TABLE语句中指定了 &quot;IF NOT EXISTS &quot;子句,而同名的表或视图已经存在,那么CREATE TABLE命令就没有任何效果(也不会返回错误信息)。如果因为存在索引而无法创建表,即使指定了 &quot;IF NOT EXISTS &quot;子句,仍然会返回错误信息。</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">不能在包含&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;的数据库上使用它。</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">可能是合并中出现了冲突。当同一行代码在圈(1)和圈(4)与圈(2)和圈(3)之间被以不同的方式修改时,就会发生冲突。合并命令将宣布任何冲突,并在输出中包含冲突行的两个版本。你需要调出包含冲突的文件并手动解决冲突。</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">一定不能通过在左侧有一个数值(而不是字符串或blob)来使LIKE或GLOB操作符为真。这意味着,无论是。</target>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">有必要转移到3.0版本来实现这些功能,因为每个功能都需要对数据库文件格式进行不兼容的修改。其他不兼容的变化,如清理API,也是同时引入的,因为理论上最好一次就把不兼容的变化全部解决掉。</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">它适用于unicode(UTF8)文本。</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">它的主日志存在,或者主日志名称是一个空字符串,以及</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">其大小大于512字节,并且</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.M.Robson。&quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;。</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON支持</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">加盟顺序</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">联接重新排序是自动的，通常效果很好，程序员不必考虑它，特别是如果使用&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;来收集有关可用索引的统计信息时。但是有时需要程序员的一些提示。例如，考虑以下架构：</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">日志文件格式</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">日志头格式</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">日志记录格式</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">计算机协会杂志</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">记录数据库页面</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">编写一页日记</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">阴历日数</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">如果寄存器P1中的值为False,则跳转到P2。如果它的数值为零,则认为是false,如果P3为非零,则跳转到P2。如果P1中的数值为NULL,那么只有当P3为非零时才进行跳转。</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">如果寄存器P1中的值为NULL,则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">如果寄存器P1中的值不是NULL,则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">如果寄存器P1中的值为真,则跳转到P2。如果该值是数值且非零,则认为是真。如果P1中的值为NULL,那么只有当P3为非零时才进行跳转。</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">取决于在最新的&lt;a href=&quot;opcode#Compare&quot;&gt;比较&lt;/a&gt;指令中P1向量分别小于等于还是大于P2向量，跳转到地址P1，P2或P3的指令。</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">跳转到寄存器P1中的地址之后的下一条指令。跳转后,寄存器P1变为未定义。</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">就像有用于管理ZIP存档的&amp;ldquo; zip&amp;rdquo;程序和用于管理Tarball的&amp;ldquo; tar&amp;rdquo;程序一样，也存在用于管理SQL存档的&lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&amp;ldquo; sqlar&amp;rdquo;程序&lt;/a&gt;。&amp;ldquo; sqlar&amp;rdquo;程序能够创建新的SQLite存档，列出现有存档的内容，从存档中添加或删除文件和/或从存档中提取文件。一个单独的&amp;ldquo; sqlarfs&amp;rdquo;程序能够将SQLite存档作为&lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse文件系统&lt;/a&gt;挂载。</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">要时刻警惕自己的生活行为。</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">每天把死亡放在眼前。</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">在转换为 NUMERIC 时,保持整数的全精度(如果可能的话)。票据 #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">关键点:</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">本篇文章的主要收获。</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">原始数据库文件内容的键/值存储。键是页码,值是二进制页面内容。</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">关键字参数可以选择用引号引起来。（例如： &lt;code&gt;'yes' [FALSE]&lt;/code&gt; 。）某些编译指示将字符串文字作为参数。当pragma使用关键字参数时，通常也将使用数值等效项。例如，&amp;ldquo; 0&amp;rdquo;和&amp;ldquo;否&amp;rdquo;与&amp;ldquo; 1&amp;rdquo;和&amp;ldquo;是&amp;rdquo;含义相同。查询设置的值时，许多编译指示会返回数字而不是关键字。</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">要知道,上帝到处都能看到你。</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">左键加入</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">LEFT JOIN消除经常出现的情况是在视图里面使用LEFT JOIN,然后视图在使用时,LEFT JOIN的右侧表的列都没有引用。</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">LEFT JOIN强度降低优化</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">实现了LEFT OUTER JOIN,但没有实现RIGHT OUTER JOIN或FULL OUTER JOIN。</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">喜欢优化</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">LIKE优化现在适用于带有 COLLATE NOCASE 的列。</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0现在不显示行。使用LIMIT-1可以看到所有的行。</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0现在适用于子查询</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">大型WAL文件</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">最后一次插入Rowid</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">后来,SQLite 3.6.16版本发布,如图中圆圈(4)所示。在这一点上,私有分支维护者做了一个合并,把从(1)到(4)的所有变化都应用到(3)中。结果是版本(5),也就是SQLite 3.6.16加上编辑。</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">前面的空格被去掉了。</target>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">叶子有效载荷分数。必须是32。</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">左操作数</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">找到左操作数</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">左对齐输出中的值。默认情况下是右对齐。如果宽度为零,或者小于被替换的值的长度,那么就没有填充,&quot;-&quot;标志是不行的。</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">旧版本(比3.22.0旧)的session模块不能捕获对sqlite_stat1表的修改。旧版本的sqlite3changeset_apply()函数会默默地忽略任何对sqlite_stat1表的修改,这些修改是变化集或补丁集的一部分。</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">Lemon没有自己的源码库。相反,Lemon由SQLite源代码树中的几个文件组成。</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">Lemon生成LALR（1）解析器。它的操作类似于更熟悉的工具&lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;，但是Lemon增加了重要的改进，包括：</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">Lemon有一个 &quot;后备 &quot;标记的概念。SQL语言中包含大量的关键字,这些关键字有可能与标识符名称发生碰撞。Lemon有能力指定一些关键字有能够 &quot;回落 &quot;到一个标识符。如果关键字出现在输入令牌流中,否则会出现语法错误的上下文,那么在语法错误产生之前,该令牌会自动转化为其回退。这个特性使得解析器对用作标识符的保留词非常宽容,这也是SQL语言中经常出现的问题。</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">Lemon有一个非终端析构器的概念,它可以用来在语法错误或其他中止的解析后回收内存或其他资源。</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">Lemon还用于为&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;扩展中的查询模式表达式生成解析。在这种情况下，输入语法文件是&lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">Lemon在SQLite中的两个地方使用。</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemon支持对语法文件规则进行有条件的编译,这样就可以根据编译时的选项生成不同的解析器。</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Lemon是由D.Richard Hipp(也是SQLite的创建者)在1987年到1992年期间在杜克大学读研究生时原创的。Lemon最初的创建日期已经丢失,但可能是1990年左右的某个时间。Lemon生成了一个LALR(1)解析器。曾有配套的LL(1)解析器生成工具名为 &quot;Lime&quot;,但Lime的源代码已经丢失。</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">长度规格</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">更少的管理意味着程序员将更多的时间用在软件上(在这里是SQLite),而不是在版本控制系统上大费周章。</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">少用内存</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">设K为M+((P-M)%(U-4))。</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">让X为((U-12)*64/255)-23。如果有效载荷大小P小于或等于X,那么整个有效载荷都存储在b树页上。让M为((U-12)*32/255)-23,让K为M+((P-M)%(U-4))。若P大于X,则索引b树页上存储的字节数为K,若K小于或等于X,否则为M。索引页上存储的字节数永远不会小于M。</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">让X为U-35。如果有效载荷大小P小于或等于X,那么整个有效载荷都存储在b树叶页上。让M为((U-12)*32/255)-23,让K为M+((P-M)%(U-4))。若P大于X,则表b树叶页上存储的字节数为K,若K小于或等于X,否则为M。叶页上存储的字节数永远不会小于M。</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">令X为部分索引的WHERE子句中的表达式，令W为使用索引表的查询的WHERE子句。然后，如果W&amp;rArr;X，则允许查询使用部分索引，其中&amp;rArr;运算符（通常发音为&amp;ldquo; implies&amp;rdquo;）等于&amp;ldquo; X or not W&amp;rdquo;的逻辑运算符。因此，确定部分索引在特定查询中是否可用减少了证明一阶逻辑的定理。</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">让X是最大的连续整数集{h,h+1,h+2,...,h+N},这样对于X中的每一个j,aPgno[j%8192]!=0.如果aPgno[h%8192]==0,X集将是空的。 X集很容易计算,从值h%8192开始,将h%8192加到X中,然后递增h,直到遇到第一个aPgno[h%8192]条目为零。</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">让数据库的页面大小(日记头偏移量24处的整数值)为N,那么页面记录的格式如下。</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">让数据类型 &quot;u8&quot;、&quot;u16 &quot;和 &quot;u32 &quot;分别表示长度为8、16和32位的无符号整数。那么,shm文件的第一个32768字节的单元组织如下。</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">设alice节点的数量为M,bob节点的数量为N,考虑两种情况。在第一种情况下,M和N都是2,但每个节点上有数千条边。在这种情况下,首选方案1。在方案1下,内循环检查一对节点之间是否存在边缘,如果发现就输出结果。但是由于alice和bob节点各只有2个,所以内循环只需要运行4次,查询速度非常快。方案2在这里需要的时间会更长。方案2的外循环只执行两次,但是因为每个alice节点有大量的边离开,所以中间的循环要迭代好几千次。速度会慢很多。所以在第一种情况下,我们更倾向于使用方案1。</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">让日记头中偏移量8处的页数值为M,如果M大于零,那么在M页记录后,日记文件可能会被零填充到扇区大小的下一个倍数,然后插入另一个日记头。同一日记本中的所有日记本头必须包含相同的数据库页面大小和扇区大小。</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">让我们假设你使用的是合并源码。将基线添加到你的项目中,如下所示。</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">假设OpenDocument没有使用ZIP存档来存储文件,而是使用了一个非常简单的SQLite数据库,其单表模式如下。</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">让我们使用下面的记法(与罗布森的记法相似但不相同)。</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">让我们成为现实。很少有人会严重质疑Git提供次佳的用户体验。许多底层实现都显示在用户界面中。界面是如此糟糕，以至于甚至有一个模仿网站都会生成&lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;伪造的git手册页&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">让我们再仔细看看这里发生了什么。第一个SELECT是由指令5到10的循环实现的。指令5通过重绕其光标来初始化循环。指令6从 &quot;examp &quot;中提取 &quot;two &quot;列的值,指令7将其转换为行。指令8将一个空字符串推到堆栈中。最后,指令9将该行写入临时表。但是请记住,PutStrKey操作码使用栈顶作为记录数据,栈上的下一个作为键。对于INSERT语句来说,MakeRecord操作码生成的行是记录数据,记录键是NewRecno操作码创建的整数。但是这里的角色是相反的,MakeRecord创建的行是记录键,记录数据只是一个空字符串。</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">用C语言编写的库没有巨大的运行时依赖性。在其最低配置中,SQLite只需要标准C库中的以下例程。</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">用C++或Java编写的库一般只能被用同一种语言编写的应用程序使用。要让一个用Haskell或Java编写的应用程序调用一个用C++编写的库是很困难的。另一方面,用C语言编写的库可以从任何编程语言中调用。</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">库大小优化。</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">像--file一样，将文件FILE用作存档，但是使用&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt;打开文件，以便在FILE已经存在的情况下将存档附加到FILE的末尾。</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">与无内容表一样,外部内容表不支持REPLACE冲突处理。任何指定REPLACE冲突处理的操作都会使用ABORT处理。</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">像其他虚拟表类型一样，使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句创建新的FTS表。在USING关键字之后的模块名称为&amp;ldquo; fts3&amp;rdquo;或&amp;ldquo; fts4&amp;rdquo;。虚拟表模块自变量可以保留为空，在这种情况下，将创建带有单个用户定义列名为&amp;ldquo; content&amp;rdquo;的FTS表。可选地，可以向模块自变量传递以逗号分隔的列名称的列表。</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">和sqlite3rbu_step()一样,如果真空操作已经完成,sqlite3rbu_close()返回SQLITE_DONE。如果真空操作没有完成,但没有发生错误,则返回SQLITE_OK。或者,如果发生了错误,则返回一个SQLite错误代码。如果在之前调用sqlite3rbu_step()的过程中发生了错误,sqlite3rbu_close()将返回相同的错误代码。</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">与&quot;.dump &quot;命令一样,&quot;.recover &quot;试图将数据库文件的全部内容转换为文本。不同的是,&quot;.recover &quot;不是使用正常的SQL数据库接口读取数据,而是试图根据直接从尽可能多的数据库页面中提取的数据来重新组合数据库。如果数据库已经损坏,&quot;.recover &quot;通常能够从数据库所有未损坏的部分恢复数据,而&quot;.dump &quot;则在遇到第一个损坏迹象时停止。</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">极限设置</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">限制&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;生成的输出量。</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">限制JSON对象和数组的递归深度，以避免递归下降解析器中过多的堆栈使用。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">限制和注意事项</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">OpenDocument演示格式的局限性</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">SQLite中的限制</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">以 &quot;#&quot;开头的行和不在SQL语句中间的行被解释为注释。</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">将SQLite与一个测试程序进行链接,该程序运行约30,000条代表典型工作负载的SQL语句。</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">2006-06-27,Linus Torvalds在Git邮件列表中用不同的词来表达同样的意思。</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">常量清单:</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">功能清单:</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">对象列表:</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">PRAGMAs清单</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">SQLite常量列表</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">SQLite函数列表</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">SQLite对象列表</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">虚拟表列表</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">在处理过程中列出每个文件。</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">列出归档的内容,如果没有指定参数,则列出所有文件。如果没有指定参数,则列出所有文件。否则,只有那些指定为参数的文件才会被列出。目前,--verbose选项不会改变此命令的行为。将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">列出存档中的文件。</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">IN右侧的列表值被视为必须具体化的子查询。换句话说,前一条语句的行为就像。</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">下面列出了一些情况下,可能有意义的添加额外的soundlike条目。具体的条目将取决于应用程序和目标语言。</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">心甘情愿地聆听圣洁的读书声。</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">字面值(常量)</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">字面价值</target>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">LoC建议的存储格式</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">加载延长线</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">将表之间的差异加载到一个会话中。</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">在计算差异之前，将共享库或DLL文件LIBRARY加载到SQLite中。这可用于添加架构所需的应用程序定义的&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">可加载的扩展通克</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">可加载的扩展是C代码。要在大多数类似unix的操作系统上编译它们,通常的命令是这样的。</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">本地删除</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">本地插入</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">本地更新</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">当地时间修改器</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">锁名</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">锁定偏移</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">锁定和并发</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">锁定和并发控制由&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;寻呼机模块&lt;/a&gt;处理。传呼机模块负责使SQLite成为&amp;ldquo; ACID&amp;rdquo;（原子，一致，隔离和持久）。分页器模块确保所有更改都立即发生，或者所有更改都发生，或者所有更改都没有发生，两个或多个进程不会尝试以不兼容的方式同时访问数据库，并且一旦写入更改，它们坚持到明确删除为止。分页器还提供磁盘文件某些内容的内存缓存。</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">多头期权</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">长期支持</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">长式和短式可以混合选择。例如,以下是等价的:</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">更长的答案：如果您将表的某列声明为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，则每当您在表的该列中插入NULL时，该NULL都会自动转换为一个整数，该整数比该列的最大值大1表中的所有其他行；如果表为空，则为1。或者，如果正在使用最大的现有整数键9223372036854775807，则随机选择一个未使用的键值。例如，假设您有一个像这样的表：</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">新&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接的&lt;/a&gt;后备缓冲区分配。</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">旁观者内存分配器</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">大量的BUG修复。</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">很多小bug的修复。</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">爱惜贞操。</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">爱吃斋。</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">爱你的敌人。</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">爱你的小辈们。</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">数据库文件的低级控制</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">低级系统错误代码</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">最低优先级(最松散的分组)。</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">M总是((U-12)*32/255)-23。</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">MASK位0x02被设置。</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Mac类似于unix,但它们并不遵循通常的共享库惯例。要在Mac上编译一个共享库,请使用类似这样的命令。</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">在API函数&lt;b&gt;const中&lt;/b&gt;选择参数。这应该是完全向后兼容的。</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">使&lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop模糊器&lt;/a&gt;成为SQLite &lt;a href=&quot;testing&quot;&gt;测试策略&lt;/a&gt;的标准部分。</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">使CACHE_SIZE pragma持久化。</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">神奇的数字。0x377f0682 或 0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">维持100％的MC / DC既费力又费时。对于典型的应用程序而言，维持全覆盖测试所需的精力水平可能并不划算。但是，我们认为完全覆盖的测试对于像SQLite这样&lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;广泛部署的&lt;/a&gt;基础结构库是有道理的，尤其是对于数据库库，由于其本质，它可以&amp;ldquo;记住&amp;rdquo;过去的错误。</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">维护SQLite的私有分支</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">使&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt;响应&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">在WinCE中把AreFileApisANSI()作为一个无操作的宏,因为WinCE不支持这个函数。</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">使命令行shell的CSV(逗号分隔值)输出更符合公认的做法。</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">让LIMIT在复合SELECT语句上工作。</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">将寄存器P1...P1+P3复制到寄存器P2...P2+P3中。</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">排序时要区分数字值和文本值。文本值根据memcmp()进行排序。数字值按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">将寄存器P1浅层复制到寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">尽力分配一个新的页面。只有在不可能分配新页面的情况下才返回NULL。</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">在太阳落山之前,与你的对手和平相处。</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">即使使用降序索引实现DISTINCT运算符，也请确保ORDER BY将行按升序排列。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">确保在外壳中的&lt;b&gt;.dump&lt;/b&gt;命令的输出中在对应的TABLE之后创建VIEW 。</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">确保所有单独的数据库文件都有一个EXCLUSIVE锁和一个有效的日志。</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">确保所有的回滚日志数据已经实际写入磁盘表面(而不仅仅是保存在操作系统或磁盘控制器的缓存中),这样如果发生电源故障,数据在电源恢复后仍然存在。</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">确保INSERT的VALUES子句中的函数表达式是正确的。</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">确保数据库文件名遵循8+3的文件名格式,并且没有空名或扩展名。换句话说,数据库文件名的基本名称必须包含1到8个字符,扩展名必须包含1到3个字符。不允许使用空白的扩展名。</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">确保当一个连接阻塞在一个RESERVES锁上时,它能够在锁被释放后继续。(Ticket #3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">确保单个语句中来自多个触发器的&lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata（）&lt;/a&gt;值不会相互干扰。票证&lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">如果缓冲区大小小于1，请确保&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;接口不会使缓冲区零终止。票号＃2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">确保MIN()和MAX()优化在子查询中工作。</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">确保ORDER BY LIMIT优化（从签入&lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;）与INTEGER PRIMARY KEY上的IN运算符一起使用。修复票务&lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96C1454C&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">确保TCL语言接口在64位机器上与64位整数正确工作。</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">如果malloc()失败,请确保内存后端响应理智。</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">确保查询优化器检查复合SELECT语句的所有术语的依赖性。Ticket #2640.</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">确保你在每条SQL命令的结尾处输入一个分号!sqlite3程序会在你的SQL命令完成时寻找分号。sqlite3程序会寻找分号来知道你的SQL命令何时完成。如果你省略了分号,sqlite3会给你一个继续提示,并等待你输入更多的文本添加到当前的SQL命令中。这个功能允许你输入跨越多行的SQL命令。例如</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">让这个脚本可以执行,并把它放在你的$PATH上。然后编译 kvtest 程序如下。</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">再把 &quot;AS &quot;这个关键词变成可选的。</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">使用&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;选项进行编译时，使&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;成为标准构建的一部分。</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">使GLOB和LIKE运算符成为可以被程序员覆盖的函数。例如,可以将LIKE运算符改为区分大小写。</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">使LIMIT子句对子查询有效。(虽然ORDER BY仍然不能工作。)</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">让库的线程安全。(代码是存在的,似乎可以工作,但没有强调。)</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">使 os.h 头文件在检测何时为 Windows 编译和何时为 Unix 编译时更加强大。</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">在Windows &lt;a href=&quot;vfs&quot;&gt;VFS中&lt;/a&gt;使用OVERLAPPED 可以避免某些系统调用，从而提高性能。</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">在适当的地方，使用&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;中的一遍UPDATE和DELETE查询计划。</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Makefile更新</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Makefile更新和杂项错误修复。</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">A.Rottmann的Makefile更新。</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">进行其他类型的表模式更改</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">畸形数据库测试</target>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">从命令行管理SQLite档案</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">支持Manifest Typing和BLOB。</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">支持Manifest typing和BLOB。</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">使用CROSS JOIN手动控制查询计划。</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">使用SQLITE_STAT表手动控制查询计划。</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">许多SQLITE_OMIT_宏插入,在编译时省略功能,减少库的占用。</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">许多SQLite函数都会从这里显示的集合中返回一个整数结果代码,以表示成功或失败。</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">在SQLite中,很多小的查询都是高效的</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">许多应用程序在关闭时通过调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;破坏其&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。或者，例如，使用SQLite作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式的应用程序&lt;/a&gt;可能会响应于File / Open菜单操作而打开&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;，然后响应于File / Close菜单而销毁相应的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">许多应用程序使用SQLite作为来自企业RDBMS的相关内容的缓存。这减少了延迟,因为现在大多数查询都是针对本地缓存进行的,避免了网络往返。它还降低了网络和中央数据库服务器的负载。在许多情况下,这意味着客户端应用程序可以在网络中断期间继续运行。</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">许多代码简化和模糊的错误修复，以支持提供&lt;a href=&quot;testing#coverage&quot;&gt;100％的分支测试覆盖率&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">许多文件更新</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">在&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;子目录的SQLite源代码树中可以看到许多完整且可用的可扩展扩展的示例。该目录中的每个文件都是一个单独的扩展名。文档由文件的标题注释提供。这是&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;子目录中一些扩展的简要说明：</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">对配置脚本进行了许多改进和清理。</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">壳的许多改进和提高。</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">测试套件的许多改进。测试覆盖率现在超过98%。</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">与以前的版本相比，许多微优化导致相同数量的CPU周期的工作量增加了20.3％。自&lt;a href=&quot;#version_3_8_0&quot;&gt;3.8.0版&lt;/a&gt;以来，累积性能提高了61％。（在具有gcc 4.8.1和-Os的Ubuntu 13.10 x64 上的&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt;工作负载上使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;进行测量。您的性能可能会有所不同。）</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">很多微优化,使得库的速度比之前的版本更快。</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">许多小的错误修复</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">修复了许多烦人的BUG。</target>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C语言接口&lt;/a&gt;中的许多例程都返回数字结果代码，它们指示成功或失败，并且在失败的情况下，提供了一些导致失败的原因的想法。本文档致力于解释每个数字结果代码的含义。</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">许多操作,特别是I/O密集型操作,由于内容确实需要在内核空间和用户空间之间复制,因此可以更快。</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">许多程序使用&lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen（）&lt;/a&gt;，&lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread（）&lt;/a&gt;和&lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite（）&lt;/a&gt;来创建和管理本地格式的数据文件。SQLite可以很好地替代这些</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">许多读者推荐了各种Git的第三方GUI,它们或许能更好地显示历史开发活动。也许其中一些确实比原生Git和/或GitHub更好用,尽管它们都会因为Git不能在同步中保存历史分支名而受到影响。即使这些其他工具更好,但必须通过第三方工具才能获得所需信息的事实也不能说明核心系统的好坏。</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">许多小的性能优化。</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">很多很多的bug修复和兼容性增强。</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">许多,许多小的错误修复和文档更新。</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">主日志指针</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">主日志</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">主期刊</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">如果query1和query2都匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">如果query1或query2匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">如果query1匹配而query2不匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">Matchinfo b旗</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">Matchinfo x flag</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">Matchinfo和旗帜</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">视图和子查询的具体化</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">数学运算符（+，-，*，/，％，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，＆和|）将两个操作数都视为数字。 STRING或BLOB操作数会自动转换为REAL或INTEGER值。如果STRING或BLOB看起来像实数（如果它具有小数点或指数），或者该值超出了可以表示为64位有符号整数的范围，则它将转换为REAL。否则，操作数将转换为INTEGER。数学操作数的隐式类型转换与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST到NUMERIC&lt;/a&gt;略有不同，因为字符串和看起来像实数但没有小数部分的BLOB值保持为REAL而不是像&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST到NUMERIC&lt;/a&gt;那样转换为INTEGER。即使是有损且不可逆的，也要执行从STRING或BLOB到REAL或INTEGER的转换。一些数学运算符（％，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;和＆|）期望使用INTEGER操作数。对于那些运算符，将REAL操作数转换为INTEGER的方式与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER的&lt;/a&gt;方式相同。 &amp;lt;&amp;lt;，&amp;gt;&amp;gt;，＆和|运算符始终返回INTEGER（或NULL）结果，但是％运算符根据其操作数的类型返回INTEGER或REAL（或NULL）。数学运算符上的NULL操作数将产生NULL结果。数学运算符上的操作数将不会以任何形式出现且不是NULL，将转换为0或0.0。除以零的结果为NULL。</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">最大内嵌有效载荷分数。必须是64。</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">最大行数</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">最大xShmLock指数</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">最大开放参数</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">愿你行善不作恶</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">愿你为自己找到宽恕,也为他人找到宽恕。</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">愿你能自由分享,永远不取多于付出。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">使用这些命令测量从数据库和从单个文件读取 blobs 的性能。</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">通过添加--update选项来衡量写入性能。这将导致 blobs 被另一个大小完全相同的随机 blob 覆写。</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">在Ubuntu 16.04的x64上使用gcc 5.4.0和-Os的cachegrind进行测量。</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">以上测量是使用&lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;2017&lt;/a&gt;年10月8日的SQLite版本5594a121bf132a98进行的。</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">测量和降低SQLite中的CPU使用率</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">内存分配例程</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">内存分配子系统</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">内存分配器统计</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">記憶體插槽</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">结合使用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，...）开始时间选项和&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;编译时间选项，可以禁用内存记帐。</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">结合使用&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，...）开始时间选项和&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;编译时间选项，可以禁用内存记帐。</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">除非使用&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0 编译SQLite，否则默认情况下将启用内存分配统计信息，在这种情况下，默认情况下将禁用内存分配统计信息。</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">除非使用&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0 编译SQLite，否则默认情况下将启用内存分配统计信息，在这种情况下，默认情况下将禁用内存分配统计信息。</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">内存分配，无大小写的字符串比较例程，可移植的文本数字转换例程以及其他实用程序位于&lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c中&lt;/a&gt;。解析器使用的符号表由&lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c中的&lt;/a&gt;哈希表维护。该&lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt;源文件包含Unicode转换子程序。 SQLite的有它自己的私有实现的&lt;a href=&quot;printf&quot;&gt;（）的printf&lt;/a&gt;（标有一些扩展）&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;并在其自己的伪随机数生成器（PRNG）&lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">内存统计</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">从malloc（）获得用于保存&lt;b&gt;sqlite_get_table&lt;/b&gt;返回的信息的内存。但是调用函数不应尝试直接释放此信息。相反，当不再需要该表时，请将完整的表传递给&lt;b&gt;sqlite_free_table&lt;/b&gt;。可以安全地使用NULL指针调用&lt;b&gt;sqlite_free_table&lt;/b&gt;，如果结果集为空，则将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">内存映射I/O</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4和memsys6是2007年左右推出的实验性内存分配器,后来在2008年左右从源树中删除,因为它们显然没有增加新的价值。</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">将开发变更合并到主干中。未来使用BTree文件结构的工作将使用一个单独的CVS源代码树。这个CVS树将继续只支持GDBM版本的SQLite。</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatch可以添加，修改或删除JSON对象的元素，因此对于JSON对象，json_patch（）例程是&lt;a href=&quot;json1#jset&quot;&gt;json_set（）&lt;/a&gt;和&lt;a href=&quot;json1#jrm&quot;&gt;json_remove（）&lt;/a&gt;的通用替代。但是，MergePatch将JSON数组对象视为原子对象。MergePatch不能追加到数组，也不能修改数组的单个元素。它只能作为单个单元插入，替换或删除整个阵列。因此，当处理包含数组的JSON时，json_patch（）并不有用，尤其是具有很多子结构的数组。</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">合并的&lt;a href=&quot;sessionintro&quot;&gt;会议&lt;/a&gt;延长到躯干。</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">元数据通过写入作为该函数第5个和后续参数传递的内存位置来返回。这些参数中的任何一个都可以是NULL,在这种情况下,相应的元数据元素将被省略。</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">方法(2)提供了(1)和(3)之间的中间点。使用这种方法,像 &quot;1s*&quot;这样的查询将匹配包含字面标记 &quot;1st &quot;但不包含 &quot;first &quot;的文档(假设标记器不能提供前缀的同义词)。然而,像 &quot;1st &quot;这样的非前缀查询将与 &quot;1st &quot;和 &quot;first &quot;匹配。这种方法不需要额外的磁盘空间,因为没有额外的条目被添加到FTS索引中。另一方面,运行MATCH查询可能需要更多的CPU周期,因为每个同义词都需要单独查询FTS索引。</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;，&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;，&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;，&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;，&lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;，&lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">数以百万计的测试案例</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">最小内嵌有效载荷分数。必须是32。</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">最小行数</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">对网站进行小幅修改。</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">小幅修改语法以支持更多的编译器。</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">对其他代码进行小幅调整,使其运行速度更快一些。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">其他&lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt;减少约2.1％的CPU使用率。</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">杂项代码大小优化和错误修复。</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">杂项文件的改进。</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">各种微优化使普通工作负载的CPU使用率降低了7％以上。此版本中的大多数优化都在前端（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;）上进行。</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">与以前的版本相比，在相同的CPU周期数下，其他各种微优化导致的工作量增加了22.3％。SQLite现在的运行速度是&lt;a href=&quot;#version_3_8_0&quot;&gt;3.8.0版的&lt;/a&gt;两倍，是&lt;a href=&quot;#version_3_3_9&quot;&gt;3.3.9版的&lt;/a&gt;三倍。（在具有gcc 4.8.2和-Os的Ubuntu 14.04 x64 上的&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt;工作负载上使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;进行测量。您的性能可能会有所不同。）</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">杂项小错误修复</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">其他优化可将&lt;a href=&quot;cpu&quot;&gt;使用的CPU周期&lt;/a&gt;减少2％。</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">杂项性能改进</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">&quot;债&quot;、&quot;孓&quot;、&quot;阮&quot;、&quot;万奴 &quot;等杂问题词。</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">缺少回调</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">当磁盘访问是顺序访问时，现代文件系统运行得更快。因此，如果数据库文件的内容在连续页面上，SQLite将运行得更快。要找出数据库中哪些页面是连续的（从而获得度量值，这对于确定何时使用&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;可能有用），请运行如下查询：</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">修改&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;接口以支持更广泛的嵌入式系统。有关更多信息，请参见&lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt;。***可能不兼容的更改***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">对&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器的&lt;/a&gt;修改，使解析器表小4倍。</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">修改了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH，&lt;/a&gt;以在缓冲区大小计算中删除&amp;ldquo; +4&amp;rdquo;幻数。</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell程序，以便在显式请求的情况下为内置SQLITE_MASTER表打印模式。</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell程序以使用新的接口例程。</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell，以使用新的sqlite_get_table（）API来打印多列的表列表，类似于&amp;ldquo; ls&amp;rdquo;打印文件名的方式。</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell，以在&amp;ldquo; .schema&amp;rdquo;命令的输出中的每个CREATE语句的末尾打印分号。</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">修改了B-Tree和Pager模块,使不包含真实数据的磁盘页(空闲页)不写日记,当它们发生变化时,不从内存写回磁盘。这并不影响数据库的完整性,因为这些页面不包含真实数据,但它确实使大型INSERT操作快了约2.5倍,大型DELETE快了约5倍。</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">修改了日志文件格式,使其更能抵御操作系统崩溃或断电后可能出现的损坏。</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">修改TCL接口以使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">修改测试脚本,以确定依赖于系统负载和处理器速度的测试,并警告用户,这些(罕见的)测试之一的失败并不一定意味着库发生了故障。不修改代码。</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">修改数据库页面的内容。</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">修改、添加或截断数据库页面。</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">更激进的&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">当一边或另一边总是假的时候,更积极地优化AND运算符。</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">比较复杂的查询可能采用查询扁平化,也可能不采用查询扁平化来避免临时表。查询能否被扁平化取决于子查询或外层查询是否包含聚合函数、ORDER BY或GROUP BY子句、LIMIT子句等因素。什么情况下查询可以扁平化,什么情况下不能扁平化,这些规则非常复杂,不在本文的讨论范围之内。</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">更有效地对布尔值进行编码,从而使数据库文件更小。</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">更有效地处理&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;，尤其是在应用程序定义数百或数千个自定义函数的情况下。</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">在 Windows 下更高效地实现 sqliteFileExists()。(作者:Joel Luscy)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">更强大的内存外错误处理。</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">更多建议...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">在一个查询中可能会出现一个以上的NEAR操作符。在这种情况下,由NEAR操作符分隔的每一对术语或短语必须出现在文档中指定的相邻范围内。使用与上述示例块中相同的表格和数据。</target>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">大多数R*Tree查询都使用深度优先搜索。这是通过将rScore设置为iLevel来实现的。深度优先搜索通常是首选,因为它可以使优先级队列中的元素数量最小化,从而减少内存需求并加快处理速度。然而,一些应用程序可能更喜欢广度优先搜索,这可以通过将rScore设置为mxLevel-iLevel来实现。通过为rScore创建更复杂的公式,应用程序可以对搜索子树和返回R*Tree叶子条目的顺序进行详细控制。例如,在一个有数百万个 R*Tree 条目的应用程序中,rScore 可能会被安排为首先返回最大或最重要的条目,使应用程序能够快速显示最重要的信息,并在它们可用时填写较小和不太重要的细节。</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">大多数SQL数据库引擎(据我们所知,除了SQLite之外的所有SQL数据库引擎)都使用静态的、刚性的类型。通过静态类型化,一个值的数据类型由它的容器--存储该值的特定列决定。</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">大多数SQL数据库引擎都是基于客户端/服务器的。在那些无服务器的数据库引擎中,SQLite是笔者所知的唯一一个允许多个应用程序同时访问同一个数据库的引擎。</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">大多数SQL数据库引擎都是基于客户端/服务器的。在那些无服务器的数据库引擎中,SQLite是笔者所知的唯一一个允许多个应用程序同时访问同一个数据库的引擎。</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">大多数SQL数据库引擎是作为一个独立的服务器进程来实现的。想要访问数据库的程序使用某种进程间通信(通常是TCP/IP)与服务器通信,向服务器发送请求并接收返回的结果。SQLite不是这样工作的。在SQLite中,想要访问数据库的进程直接从磁盘上的数据库文件进行读写。没有中间的服务器进程。</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">大多数SQL数据库引擎将已经解析好的模式存储在各种系统表中。在这些数据库引擎上,ALTER TABLE只需要对相应的系统表进行修改即可。</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">大多数SQL数据库引擎都使用静态类型。一个数据类型与表中的每一列相关联,并且只允许在该列中存储该特定数据类型的值。SQLite通过使用manifest typing放宽了这种限制。在manifest typing中,数据类型是值本身的一个属性,而不是存储值的列的属性。因此,SQLite允许用户将任何数据类型的值存储到任何列中,而不管该列的声明类型是什么。(这个规则也有一些例外。一个INTEGER PRIMARY KEY列只能存储整数。而且SQLite试图在可以的情况下,将值胁迫到该列的声明数据类型中。)</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">大多数应用格式都符合这三类中的一类。</target>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">大多数应用程序将只使用上一节中描述的会话模块功能。然而,以下附加功能可用于使用和操作更改集和补丁集 blobs。</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">大多数应用程序都可以在默认配置下使用SQLite，并且无需特殊的编译时配置。大多数开发人员应该能够完全忽略该文档，而无需进行任何特殊知识并且无需采取任何特殊措施即可简单地从&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;构建SQLite 。</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">大多数构建还使用系统内存分配例程。</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">大多数内置窗口函数都会忽略frame-spec,例外情况是first_value()、last_value()和nth_value()。将 FILTER 子句指定为内置窗口函数调用的一部分是语法错误。</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">大多数内存统计都是全局的,因此对统计的跟踪必须用mutex序列化。统计功能在默认情况下是打开的,但存在一个选项可以禁用它们。通过禁用内存统计,SQLite避免了在每次内存分配和deallocation时进入和离开一个mutex。在Mutex操作成本很高的系统中,这种节约是很明显的。要禁用内存统计,在启动时使用以下接口。</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">大多数对象引用只能解析为特定类型的对象（例如，作为DROP TABLE语句一部分的引用只能解析为表对象，而不是索引，触发器或视图）。但是，在某些情况下（例如&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;），对象引用可以解析为一种以上类型的对象。在数据库模式中搜索命名对象时，总是会忽略在引用上下文中无法使用的类型的对象。</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">SQLite源代码树中的大多数代码纯粹用于&lt;a href=&quot;testing&quot;&gt;测试和验证&lt;/a&gt;。可靠性对SQLite很重要。测试基础结构的任务之一是确保SQLite不会滥用动态分配的内存，SQLite不会泄漏内存，并且SQLite能够正确响应动态内存分配失败。</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">大多数情况下,sqlite3只是读取输入行,并将其传递给SQLite库执行。但是以点(&quot;.&quot;)开头的输入行会被sqlite3程序本身拦截和解释。这些 &quot;点命令 &quot;通常用来改变查询的输出格式,或者执行某些预包装的查询语句。最初的点命令只有几个,但经过多年的发展,积累了许多新的功能,所以今天已经有60多个。</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">大多数时候,SQLite中的查询规划器做得很好。然而,查询规划器需要索引来工作。这些索引通常必须由程序员添加。罕见的情况下,查询规划器AI会做出一个次优的算法选择。在这些情况下,程序员可能要提供额外的提示,以帮助查询规划器做得更好。</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">大多数其他SQL数据库引擎为大多数表的每一行分配了固定的磁盘空间。它们在处理BLOB和CLOB时玩了一些特殊的技巧,这些BLOB和CLOB的长度可能大不相同。但是对于大多数表来说,如果你声明一个列是VARCHAR(100),那么无论你在该列中实际存储了多少信息,数据库引擎都会分配100字节的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">大多数其他SQL数据库引擎都比这个大得多。IBM吹嘘其最近发布的CloudScape数据库引擎 &quot;只有 &quot;2MiB的jar文件--即使经过压缩,也比SQLite大了一个数量级!而Firebird则吹嘘其客户端库只有350KiB。Firebird吹嘘其客户端库只有350KiB。这和SQLite一样大,甚至不包含数据库引擎。Oracle的Berkeley DB库是450KiB,它省略了对SQL的支持,只给程序员提供简单的键/值对。</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">大多数其他SQL数据库引擎在从一个平台转移到另一个平台时,以及在升级到一个较新版本的软件时,经常要求你转储和恢复数据库。</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">大多数程序员使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;功能将SQLite编译到其应用程序中。该&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;是C代码，但它不是&amp;ldquo;源代码&amp;rdquo;。该&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;被从源代码由脚本生成。</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">SQLite中的大多数表由零个或多个行组成，带有唯一的整数键（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;），后跟内容。（&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表除外）。逻辑上，按行号递增的顺序存储行。例如，本文使用一个名为&amp;ldquo; FruitsForSale&amp;rdquo;的表，该表将各种水果与它们的种植州和市场单价相关。模式是这样的：</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">在典型的SQLite数据库模式中,大多数表都是rowid表。</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">大多数 swarmvtab 的用户只会使用上面描述的功能。本节介绍了为更深奥的用例设计的功能。这些特性都涉及到在SQL语句后面指定额外的可选参数,作为CREATE VIRTUAL TABLE命令的一部分。一个可选的参数是用它的名字来指定的,后面是一个&quot;=&quot;字符,然后是一个可以选择引用的值。名字、&quot;=&quot;字符和值之间可以用空格隔开。例如,在参数名称后面加上&quot;=&quot;字符,然后再加上引号。</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">将一个BLOB手柄移动到新的行。</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">将寄存器P1...P1+P3-1中的P3值移到寄存器P2...P2+P3-1中。寄存器P1...P1+P3-1保持一个NULL。寄存器范围P1...P1+P3-1和P2...P2+P3-1重叠是错误的。P3小于1时错误。</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">将光标P1移动到空行。当光标在空行上时发生的任何&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;操作都将始终写入NULL。</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">将网站和文档文件从源目录树移到&lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;单独的CM系统中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">将CVS仓库移至www.sqlite.org。</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">从SQLite 3.4.2移动到3.5.0</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">从SQLite 3.5.9迁移到3.6.0</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">将日志文件从一个数据库移动到另一个数据库。</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">尽管某些例程分散在其他文件中，但它们可以访问具有文件范围的数据结构，但是许多&lt;a href=&quot;c3ref/intro&quot;&gt;C语言接口&lt;/a&gt;都可以在源文件&lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;，&lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;和&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c中&lt;/a&gt;找到。该&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;例程中实现&lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;。该&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;程序中发现的&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;。所述&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;接口处于&lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;。在&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口&lt;/a&gt;是通过实施&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">多文件交易</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">多字符的插入、删除和替换可以在成本表中列举出来。</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">多列索引</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">多列索引只有在查询的WHERE子句中的约束条件通过AND连接时才起作用。因此,当搜索的项目既是橙子又生长在加州时,Idx3和Idx4是很有帮助的,但是如果我们想要所有的项目都是橙子,那么这两个索引就没有那么有用了。</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">多种编程语言</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">可以同时注册多个VFS。每个VFS都有一个唯一的名称。同一进程中的单独&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;可以同时使用不同的VFS。因此，如果单个数据库连接使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令打开了多个数据库文件，则每个连接的数据库可能正在使用不同的VFS。</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">使用多个b树结构代替单个b树,以降低在FTS表中插入记录的成本。当一条新记录插入到已经包含大量数据的FTS表中时,新记录中的许多术语很可能已经存在于大量的现有记录中。如果使用单一的b-tree,那么就必须从数据库中加载大型的doclist结构,修改为包含新的docid和术语偏移列表,然后再写回数据库。使用多个b-tree表可以通过创建一个新的b-tree来避免这种情况,这个新的b-tree可以在以后与现有的b-tree(或b-树)合并。b-tree结构的合并可以作为后台任务来执行,或者一旦积累了一定数量的独立b-tree结构,就可以进行合并。当然,这种方案会使查询的成本增加(因为FTS代码可能需要在多个b树中查找单个术语并合并结果),但人们发现,在实践中这种开销往往可以忽略不计。</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">3.15.0版引入了对&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;逻辑的多个错误修复。</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">多位评论者表示希望指针类型使用动态字符串,并希望SQLite拥有类型字符串的所有权,并在使用完毕后自动释放类型字符串。该设计被拒绝,原因如下。</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">来自一个进程内的多个连接,如果使用这种异步IO的实现,可以并发访问一个数据库文件。从用户的角度来看,如果所有的连接都来自于一个进程内,那么 &quot;普通 &quot;SQLite和使用异步后端的SQLite所提供的并发性没有任何区别。</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">多个连接可能同时持有一个读锁。如果许多线程都在获取重叠的读锁,那么可能会出现至少一个线程始终持有读锁的情况。那么等待写锁的表将永远等待。这种情况被称为 &quot;写手饥饿&quot;。</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上的多个数据库</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">多个进程可以附加到同一个应用文件上,并且可以互相读写,互不干扰。</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">多个进程可以同时打开同一个数据库。多个进程可以同时进行SELECT。但在任何时刻只能有一个进程对数据库进行修改,但是。</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">多个小排序集体使用的CPU周期比单个大排序少。</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">将寄存器P1中的值乘以寄存器P2中的值,并将结果存储在寄存器P3中。如果任一输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">将null乘以0,得到null</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">突变测试脚本</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">突变测试可能会很慢,因为在快速工作站上,每次测试可能需要5分钟,而且每个分支指令有两次测试,有超过2万条分支指令。为了加快操作速度,我们做出了努力。例如,TH3的编译方式是一旦发现第一个错误就立即退出,由于许多突变很容易被检测到,所以许多循环只发生在几秒钟内。尽管如此,mutation-test.tcl脚本包含命令行选项,可以限制测试的代码行的范围,这样突变测试只需要对最近改变的代码块进行。</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">互换手柄</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Mutex方法对象</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">互换类型</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">Mutex验证例程</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">互斥虽然便宜,但也不是免费的,所以完全禁用互斥后,性能会更好。由此产生的库足迹也会更小一些。在编译时禁用mutexes是一种推荐的优化,适用于有意义的应用。</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">互斥使用&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">互斥使用&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">我的WHERE子句表达式 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; 不起作用。这将导致返回表的每一行，而不仅仅是返回column1值为&amp;ldquo; column1&amp;rdquo;的行。</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">我的查询没有返回我期望的列名。这是一个错误吗?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL 3.23.41版本不支持UNION。</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12甚至</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13且为奇数</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1(费用:5.52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2(费用:5.52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1(费用:11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">本土人物(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB:这个扩展已经过时了,建议用[WAL模式]代替。推荐使用[WAL模式]作为替代。</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">近距离查询</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">近距离查询不可用。</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">新的和旧的引用都是有效的</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">新的参考资料有效</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN天</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN小时</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN分钟</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN月</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN年</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNN.NNNN秒</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">NOT EXISIS操作者</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">不在运营商</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">非空约束</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL限制被尊重。</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLite中的NULL处理</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">SQLite中的NULL处理与其他数据库引擎的比较</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL值(序列类型0)先排序。</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL值现在会以NULL指针而不是空字符串的形式报告给回调。</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">NULLS LAST</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLs优先排序</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">主机参数名称</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">保存数据库文件的文件夹名称</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">保存临时文件的文件夹名称</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">默认整理序列的名称</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">也可以使用WINDOW子句将命名的window-defn子句添加到SELECT语句中,然后在window函数调用中通过名称来引用。例如,下面的SELECT语句包含两个命名的window-defs子句,&quot;win1 &quot;和 &quot;win2&quot;。</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">命名变更</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">几乎所有的系统都能调用用C语言编写的库,其他实现语言则不然。</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">&quot;.width &quot;命令中的负数会导致右对齐。</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;，&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;和&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO的&lt;/a&gt;嵌套事务</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">千万不要对上帝的仁慈绝望。</target>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">但是，建议应用程序开发人员监视内存分配子系统的状态，并在内存使用率接近或超过Robson限制时发出警报。这样，该应用程序将在发生故障之前为操作员提供大量警告。SQLite 的&lt;a href=&quot;malloc#memstatus&quot;&gt;内存统计信息&lt;/a&gt;接口为应用程序提供了完成此任务的监视部分所需的所有机制。</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">尽管如此,错误还是发生了。如果你正在编写一个向SQLite发送不受信任的SQL输入或数据库文件的应用程序,你可以采取一些额外的措施来帮助减少攻击面,并防止由未检测到的bug引起的零日漏洞。</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">尽管如此,在计算内存分配大小时的整数溢出是SQLite希望处理的问题。为了防止出现问题,所有的SQLite内部内存分配都是使用瘦包装函数来进行的,这些瘦包装函数取一个64位有符号的整数大小参数。SQLite源码经过审计,确保所有大小计算也使用64位有符号的整数进行。SQLite会拒绝一次性分配超过约2GB的内存。(在通常的使用中,SQLite很少会一次分配超过8KB左右的内存,所以2GB的分配限制并不是一个负担)。所以64位大小参数为检测溢出提供了很大的空间。同样的审计也验证了所有大小计算都是以64位有符号整数的方式进行的,也验证了64位整数在计算过程中不可能溢出。</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">尽管如此,没有任何软件是100%完美的。在SQLite中曾出现过一些历史性的错误(现在已经修复),可能会导致数据库损坏。而且可能还有一些未被发现的错误。由于SQLite的广泛测试和广泛使用,导致数据库损坏的bug往往是非常隐蔽的。一个应用程序遇到SQLite bug的可能性很小。为了说明这一点,下面对2009-04-01至2013-04-15这四年期间在SQLite中发现的所有数据库损坏bug进行了说明。这个说明应该能让读者直观地了解到SQLite中哪些类型的bug会设法通过测试程序溜走,并将其发布到版本中。</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">添加了新的&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt;编译时选项</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">新变化</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">新文件格式</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">为内置的日期/时间函数添加新的HH:MM:SS修饰符。</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">新的VFSes用sqlite3_vfs_register()注册。如果makeDflt标志被设置,每个新的VFS都会成为默认的VFS。同一个VFS可以被注册多次而不会受到伤害。要使一个现有的VFS成为默认的VFS,需要在makeDflt标志被设置的情况下再次注册它。如果注册了两个同名的不同VFS,行为是未定义的。如果注册的VFS的名称是NULL或空字符串,那么行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">新应用程序应始终调用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;而不是&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;。保留较旧的&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;是为了向后兼容。但是&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;提供了一个更好的接口。</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的返回码，以确保调用能够正常进行。所述&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;../rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的返回码，以确保调用能够正常进行。所述&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;../rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">默认情况下，SQLite创建的新数据库文件使用格式4。该&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format编译指示&lt;/a&gt;可以用来引起的SQLite通过设置使用格式1来创建新的数据库文件的格式的版本号可以以默认被制成1代替4- &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;在编译时间= 1。</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">在未来的SQLite版本中可能会添加新的错误代码。</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">新的分机。</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">新的文件格式,对于典型的使用来说,体积缩小了25%到35%。</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">在未来的SQLite版本中可能会添加新的标志。</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">新接口&lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;返回已调用应用程序定义的SQL函数的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">新接口&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;允许在每个连接的基础上和在运行时设置大小和长度限制。</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">新接口:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c附加模块中增加了新的接口。</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">新的内部模式对象名称,总是以 &quot;sqlite_&quot;开头,可能会在未来的版本中加入SQLite文件格式。</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">新的内存分配器不必是SQLite源树的一部分，也不必包含在sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;。各个应用程序可以在启动时向SQLite提供其自己的内存分配器。</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">用于配置辅助内存使用的&lt;a href=&quot;cli&quot;&gt;命令行外壳的&lt;/a&gt;新选项：--pagecache，--lookaside和--scratch。</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">新的查询优化。</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">在未来的版本中可能会增加新的运行时间限制类别。</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">新的状态参数可能会不时增加。</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">新测试添加到测试套件中。</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">在未来对SQLite的增强中,新的文本标记可能会被添加到统计列的结尾。出于兼容性考虑,统计列末尾未识别的标记将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">在未来的版本中可能会添加新的跟踪常数。</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的动词。现有的动词可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;如果一个中断或不支持的动词被调用接口将返回非零错误代码。</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的动词。现有的动词可能会中断。应用程序应检查来自&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;如果一个中断或不支持的动词被调用接口将返回非零错误代码。</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">新的压缩包可以使用 zipfile()aggregate 函数完全在内存中构建。聚合函数所访问的每一行都会给zip存档添加一个条目。返回的值是一个包含整个存档图像的blob。</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">但是，较新的磁盘驱动器已开始使用4096字节的扇区。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;版本3.7.10&lt;/a&gt;（2012-01-16）开始，SQLite开发团队进行了实验，对xSectorSize进行了更改，以将4096字节报告为爆炸半径。这样的结果是增加了许多数据库的写开销。对于&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt;为1024（一个非常常见的选择）的数据库，现在更改到数据库中的单个页面需要SQLite将其他三个相邻页面备份到回滚日志中，而以前只需要备份一个在改变。在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;，必须将每个事务填充到WAL文件中的下一个4096字节边界，而不是下一个512字节边界，从而导致每个事务写入数千个额外的字节。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">接下来,使用这样的命令将所有的 blobs 复制到目录中的各个文件中。</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">接下来,将生成的kvtest-android可执行文件移动到Android设备上。</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">接下来,假设你想查询的不是任何橙子的价格,而是特别想查询加州种植的橙子的价格。适当的查询方式如下。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">否(注1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">同一数据库连接上的操作之间没有隔离。</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">不需要编写和调试应用文件I/O代码。</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">无变化</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">没有提供当前或冲突的行信息。唯一可以在提供的sqlite3_changeset_iter句柄上调用的函数是sqlite3changeset_fk_conflicts()。</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">如果发出了未知的pragma,不会产生错误信息。未知pragma会被直接忽略。这意味着如果一个pragma语句中出现了错别字,库不会通知用户这个事实。</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">无锁定方式。如果以上都不能支持,则采用这种锁定方式。不使用数据库锁定机制。使用该系统时,单个数据库被多个客户端访问是不安全的。</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">数据库上没有锁。数据库既不能读也不能写。任何内部缓存的数据都被认为是可疑的,在使用前要对数据库文件进行核查。其他进程可以在自己的锁定状态允许的情况下,读取或写入数据库。这是默认状态。</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">不再使用。</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">不再使用。</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">没有人被要求遵守The Rule,了解The Rule,甚至认为The Rule是个好主意。SQLite的创始人认为,任何遵守The Rule的人都会过得更快乐、更有成就感,但个人可以根据自己的意愿对这一建议提出异议或置之不理。</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">没有其他进程可以更改数据库,所以永远不需要在事务开始时检查更改计数器和清除用户空间缓存。</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">在应用 RBU 更新时,目标数据库上不得发生其他写操作。为了防止这种情况,目标数据库上有一个读锁。</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">除在事务内外，不会发生读取或写入。如果一个数据库尚未生效，那么任何访问数据库的命令（基本上是任何SQL命令，除了几个&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句除外）都将自动启动一个事务。最后一条SQL语句完成时，将提交自动启动的事务。</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">在union-vtab中,任何表都不能包含不在由</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">当你从SQLite数据库中删除信息时,未使用的磁盘空间会被添加到一个内部的 &quot;自由列表 &quot;中,并在下次插入数据时重新使用。磁盘空间不会丢失。但也不会返还给操作系统。</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">非ASCII码范围的字符(即大于127的unicode码点),或</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">非Vista的Windows平台只支持一套DST规则。Vista 只支持两套。因此,在这些平台上,历史上的DST计算将是不正确的。例如,在美国,2007 年的 DST 规则发生了变化。非Vista的Windows平台将2007年新的DST规则应用于之前的所有年份。Vista平台在正确计算1986年的结果方面做得更好,因为当时的规则也发生了变化。</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">非确定性函数可能会在每次调用时给出不同的答案,即使参数总是相同。以下是非确定性函数的例子。</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">非流式等价物</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">接受变化集(或补丁集)作为输入的非流函数要求整个变化集被存储在内存中的一个缓冲区中。类似的,那些返回变化集或补丁集的函数通过返回一个指针到一个用sqlite3_malloc()分配的大缓冲区。通常这很方便。然而,如果一个在低内存环境中运行的应用程序需要处理非常大的变化集,那么所需的大的连续内存分配就会变得很麻烦。</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">在SQLite存在的前10年,没有一种安全的编程语言存在。SQLite可以用Go或Rust重新编码,但这样做可能会引入更多的bug,而不是修复的bug,而且似乎也可能导致代码更慢。</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">除了在调用xBegin()和xCommit()或xRollbackTo()之间,xSavepoint()、xRelease()或xRollbackTo()方法都不会被调用。</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">普通函数只指定xFunc,并将xStep和xFinal设置为NULL。Aggregate函数只指定xStep和xFinal,并将xFunc设置为NULL。没有单独的 sqlite3_create_aggregate()API。</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">通常，FTS5在数据库内维护一个特殊的备用表，该表将每个列值的大小存储在插入到单独表中的主FTS5表中的令牌中。该支持表由&lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API函数&lt;/a&gt;使用，而xColumnSize API函数又由内置&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25排名函数使用&lt;/a&gt;（并且可能对其他排名函数也很有用）。</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">通常情况下，NULL SQL结果存储使用在阵列中&lt;a href=&quot;#nullvalue&quot;&gt;NullValue属性&lt;/a&gt;设置。但是，如果使用&lt;b&gt;-withoutnulls&lt;/b&gt;选项，则NULL SQL值将导致未设置相应的数组元素。</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">通常情况下,SQLite假设在更新扇区任何部分时发生断电,那么恢复后整个设备扇区的内容都是可疑的。在对文件内的扇区的任何部分进行写入后,假设修改后的扇区内容被保存在系统内的某个易失性缓冲区(主内存、磁盘缓存等)。SQLite不会假设更新后的数据已经到达了持久性存储介质,直到它成功地实现了</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">通常情况下,令牌或令牌前缀查询会与MATCH操作符左侧指定的FTS表列进行匹配。或者,如果指定了与FTS表本身同名的特殊列,则与所有列匹配。这可以通过在基本术语查询前指定列名后跟一个&quot;:&quot;字符来覆盖。在&quot;:&quot;和要查询的术语之间可以有空格,但在列名和&quot;:&quot;字符之间不能有空格。例如:&quot;:&quot;字样。</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">通常情况下,SQL索引会引用表的列,但也可以在涉及表列的表达式上形成索引。但是索引也可以在涉及表列的表达式上形成。</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">一般情况下,化石在私有分支和公共分支之间切换时,会修改你结账中的所有文件。但此时,两个分支中的文件是相同的,所以不需要修改。</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">通常，全文查询不区分大小写。但是，这取决于要查询的FTS表使用的特定&lt;a href=&quot;fts3#tokenizer&quot;&gt;标记&lt;/a&gt;器。有关详细信息，请参阅关于分&lt;a href=&quot;fts3#tokenizer&quot;&gt;词器&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">通常情况下,FTS模块会对表中所有列的所有术语进行倒置索引。这个选项用来指定不应该在索引中添加条目的列名。可以使用多个 &quot;notindexed &quot;选项来指定从索引中省略多个列。例如:&quot;notindexed &quot;选项用于指定多个列的名称,这些列不应被添加到索引中。</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">通常，必须在实际创建数据库文件之前配置数据库的&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;以及数据库是否支持&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;。但是，当不在&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;模式下时，可以使用&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;和/或&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt;编译指示来更改现有数据库的&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;和/或&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;属性，然后立即对数据库进行VACUUM。在&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;模式下，只能使用VACUUM更改&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;支持属性。</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">通常情况下,当SQLite向数据库文件写入时,它会等到写入操作完成后才将控制权返回给调用应用程序。由于向文件系统写操作与CPU绑定的操作相比,通常非常慢,这可能是一个性能瓶颈。异步I/O后端是一个扩展,它使SQLite使用一个单独的线程在后台运行来执行所有的写请求。虽然这并没有减少整体的系统资源(CPU、磁盘带宽等),但它允许SQLite即使在向数据库写入时也能快速将控制权返回给调用者。</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">通常情况下,当一行插入到FTS5表中时,以及各种全文索引条目和其他数据,该行的副本被存储在FTS5模块管理的私有表中。当用户或辅助功能实现从FTS5表中请求列值时,它们将从这个私有表中读取。&quot;内容 &quot;选项可以用来创建一个只存储FTS全文索引项的FTS5表。由于列值本身通常比相关的全文索引条目大得多,因此可以节省大量的数据库空间。</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">并非所有的应用都符合这些条件。幸运的是,即使没有这些条件,NGQP通常仍然会找到好的查询计划。然而,确实会出现(很少)性能倒退的情况。</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">并非所有的测试用例都可以这样处理。有些测试用例通过计算查询过程中发生的磁盘访问次数、排序操作、全扫描步骤或其他处理步骤来检查验证优化是否真的减少了计算量。当优化被禁用时,这些测试用例会出现失败。但大多数测试用例只是检查是否得到了正确的答案,所有这些用例都可以在有优化和没有优化的情况下成功运行,以表明优化不会导致故障。</target>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">在上面的示例中未显示的是，还有一些&lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;选项&lt;/a&gt;可以作为CREATE VIRTUAL TABLE语句的一部分提供给FTS5，以配置新表的各个方面。这些可用于修改FTS5表从文档和查询中提取术语的方式，在磁盘上创建额外的索引以加快前缀查询的速度，或用于创建FTS5表作为对其他位置存储的内容的索引。</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Nota bene:</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">还要注意，在添加&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束时&lt;/a&gt;，不会针对表的现有行测试CHECK约束。这可能导致表中包含违反CHECK约束的数据。将来的SQLite版本可能会更改以验证添加时的CHECK约束。</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">请注意,&quot;单调递增 &quot;并不意味着ROWID总是正好增加1。1是通常的增量。但是,如果由于(例如)唯一性约束导致插入失败,那么失败的插入尝试的ROWID可能不会在后续的插入中被重复使用,导致ROWID序列出现空白。AUTOINCREMENT保证自动选择的ROWID会不断增加,但不保证它们是有顺序的。</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">请注意，&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;可能会间接影响数据库的副作用。例如，如果应用程序定义了调用&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的函数&amp;ldquo; eval（）&amp;rdquo; ，则以下SQL语句将通过副作用更改数据库文件：</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">请注意，默认情况下，&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;被认为是不确定的，除非在注册函数时使用&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志，否则不得在CREATE INDEX语句中使用该函数。</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">请注意，&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;可能会间接影响数据库的副作用。例如，如果应用程序定义了调用&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的函数&amp;ldquo; eval（）&amp;rdquo; ，则以下SQL语句将通过副作用更改数据库文件：</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">请注意，Idx3包含与原始&lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;相同的所有信息。因此，如果我们拥有Idx3，我们将不再真正需要Idx1。只需忽略Idx3的&amp;ldquo;状态&amp;rdquo;列，就可以使用Idx3满足&amp;ldquo;桃子的价格&amp;rdquo;查询：</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">请注意,MinGW只生成32位DLL。有一个单独的MinGW64项目可以用来生成64位DLL。大概命令行语法是类似的。还需要注意的是,MSVC的最新版本生成的DLL不能在WinXP和早期版本的Windows上工作。所以为了使你生成的DLL具有最大的兼容性,建议使用MinGW。一个好的经验法则是使用MinGW生成32位DLL,使用MSVC生成64位DLL。</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，SQLITE_IGNORE也用作从&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;接口返回的&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;冲突解决模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，SQLITE_IGNORE也用作从&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;接口返回的&lt;a href=&quot;c_fail&quot;&gt;冲突解决模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">请注意,SQLite允许IN或NOT IN操作符右侧的标量值的括号列表是一个空列表,但大多数其他SQL数据库数据库引擎和SQL92标准要求该列表至少包含一个元素。</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">请注意,SQLite会自动在扩展名中添加适当的扩展名后缀(在windows下为&quot;.dll&quot;,在Mac上为&quot;.dylib&quot;,在大多数其他unixes上为&quot;.so&quot;)。一般来说,指定扩展名的完整路径名是个好主意。</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">请注意，SQLite附带了几个&lt;a href=&quot;../malloc#altalloc&quot;&gt;内置的内存分配器&lt;/a&gt;，它们完全适合绝大多数应用程序，并且该对象仅对极少数具有特殊内存分配要求的应用程序有用。在测试SQLite期间，也使用此对象，以指定模拟内存不足条件的备用内存分配器，以验证SQLite是否可以从此类条件正常恢复。</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">请注意，SQLite附带了几个&lt;a href=&quot;malloc#altalloc&quot;&gt;内置的内存分配器&lt;/a&gt;，它们完全适合绝大多数应用程序，并且该对象仅对极少数具有特殊内存分配要求的应用程序有用。在测试SQLite期间，也使用此对象，以指定模拟内存不足条件的备用内存分配器，以验证SQLite是否可以从此类条件正常恢复。</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">请注意,SQLite不强制执行without ROWID虚拟表的PRIMARY KEY。执行是底层虚拟表实现的责任。但是SQLite确实假设PRIMARY KEY约束是有效的,即所确定的列确实是UNIQUE而非NULL,并且它使用该假设来优化对虚拟表的查询。</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">请注意，无论操作系统和硬件如何告知SQLite，SQLite都必须相信同步请求的状态。 SQLite无法检测到两者都在说谎，并且写操作可能是乱序发生的。但是，与默认回滚日志模式相比，&lt;a href=&quot;wal&quot;&gt;WAL模式下的&lt;/a&gt; SQLite 更能容忍无序写入。在WAL模式下，失败的同步操作可能导致数据库损坏的唯一时间是在&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作期间。 COMMIT期间的同步失败可能会导致持久性损失，但不会导致数据库文件损坏。因此，防止由于同步操作失败而导致数据库损坏的一道防线是在WAL模式下使用SQLite并尽可能不频繁地检查点。</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">请注意,SQLite使用b树,b树是一种排序的数据结构,所以当SELECT语句的WHERE子句包含平等或不平等的测试时,可以使用索引。像下面这样的查询,如果有索引,就可以使用索引。</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">请注意,声明的 &quot;FLOATING POINT &quot;类型会给出INTEGER亲和力,而不是REAL亲和力,因为 &quot;POINT &quot;的末尾有 &quot;INT&quot;。而声明的 &quot;STRING &quot;类型的亲和力是NUMERIC,而不是TEXT。</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">请注意，翻转多边形的转换可能导致顶点顺序颠倒。换句话说，该变换可能导致顶点以顺时针方向而不是逆时针方向循环。可以通过在转换后通过&lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw（）&lt;/a&gt;函数发送结果来纠正此问题。</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">请注意,一个内部事务可能会提交(使用RELEASE命令),但随后会被外部事务中的ROLLBACK命令撤销。断电、程序崩溃或操作系统崩溃都会导致最外层的事务回滚,从而撤销在该外层事务中发生的所有更改,甚至包括那些被RELEASE命令 &quot;提交 &quot;的更改。在最外层事务提交之前,磁盘上的内容并没有实际提交。</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">请注意,来自多个远程更改集的冲突解决是在每个字段的基础上合并的,而不是每个行。这意味着,在多个远程UPDATE操作的情况下,单个本地变更的一些字段可能会被重新基于REPLACE,而其他字段会被重新基于OMIT。</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">请注意,UTF-16be和UTF-16le之间的转换总是在原地进行的,不会使先前的指针无效,当然先前指针指向的缓冲区的内容会被修改。其他类型的转换在可能的情况下会在原地进行,但有时不可能,在这种情况下,先前的指针会失效。</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">请注意,从 zip 存档中删除记录并不能收回存档中使用的空间--它只是从存档的 &quot;中央目录结构 &quot;中删除了一个条目,使得该条目无法访问。绕过这种低效率的一种方法是根据已编辑的归档内容创建一个新的 zip 归档。例如,在编辑了通过虚拟表 temp.zzz 访问的归档后。</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，不同的操作系统为其共享库使用不同的文件名后缀。Windows使用&amp;ldquo; .dll&amp;rdquo;，Mac使用&amp;ldquo; .dylib&amp;rdquo;，除Mac之外的大多数Unix使用&amp;ldquo; .so&amp;rdquo;。如果要使代码可移植，则可以从共享库文件名中省略后缀，并且适当的后缀将由&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口自动添加。</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">请注意,shm文件中每个32768字节的单元都有自己的aHash和aPgno数组。单个单元的aHash数组只对查找同一单元的aPgno条目有帮助。整体的FindFrame(P,M)函数需要从最新的单元开始进行哈希查找,并向后查找最老的单元,直到找到答案。</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">请注意,启用FTS3也会使FTS4可用。没有单独的SQLITE_ENABLE_FTS4编译时选项。一个SQLite的构建要么同时支持FTS3和FTS4,要么两者都不支持。</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">请注意,除了上面详述的一些角码差异外,WITHOUT ROWID表和rowid表的工作原理是一样的。给予相同的SQL语句,它们都会产生相同的答案。因此,在开发周期的后期,在应用程序上运行实验,测试使用without rowid表是否会有帮助,是一件很简单的事情。一个好的策略是,在产品开发接近尾声之前,干脆不担心WITHOUT ROWID的问题,然后回过头来运行测试,看看在具有非整数PRIMARY KEY的表上添加WITHOUT ROWID是帮助还是伤害性能,只有在那些有帮助的情况下才保留WITHOUT ROWID。</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">请注意,geopoly使用传统的右手卡提斯坐标系,原点在左下方,而SVG使用左手坐标系,原点在左上方。geopoly_svg()例程没有尝试转换坐标系,所以显示的图像是以镜像和旋转的方式显示的。如果不希望出现这种情况,可以使用geopoly_xform()例程在将多边形传入geopoly_svg()之前,将输出从卡提斯坐标转换为SVG坐标。</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">请注意，如果使用&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标记了不确定性函数，并且该函数最终在&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句或&lt;a href=&quot;expridx&quot;&gt;表达式索引中使用&lt;/a&gt;，则当该函数开始返回不同的答案时，关联的索引可能会损坏。如果SQL函数几乎是确定性的（也就是说，如果它很少改变，例如&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）&lt;/a&gt;），并且在已损坏的索引中使用它，则可以通过运行&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;来修复损坏。</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">请注意,如果使用了动态mutex参数之一(SQLITE_MUTEX_FAST或SQLITE_MUTEX_RECURSIVE),那么sqlite3_mutex_alloc()在每次调用时都会返回一个不同的mutex。对于静态的mutex类型,在每次调用时都会返回相同类型号的mutex。</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">请注意,如果你没有在WHERE子句中包含 &quot;langid=N&quot;,那么搜索将针对语言0(在上面的例子中是英语)。没有办法同时搜索所有语言。</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">请注意,在大多数情况下,SQLite只会为查询的FROM子句中的每个表使用一个索引。这里介绍的第二个OR-clause优化是这个规则的例外。对于OR-clause,可能会为OR-clause中的每个子项使用不同的索引。</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">请注意,为了使特殊的&quot;:memory:&quot;名称适用,并创建一个纯内存数据库,文件名中必须没有额外的文本。因此,可以在文件中通过预先添加一个路径名来创建基于磁盘的数据库,比如这样。&quot;./:内存:&quot;.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">请注意,在上图中,我们将私人编辑显示为一次提交。这只是为了清晰地展示。没有什么能阻止你做几十个或几百个单独的小改动,并分别提交。事实上,做许多小改动是首选的工作方式。在一次提交中完成所有修改的唯一原因是,这样可以使图更容易绘制。</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">请注意，在此设计中，令牌生成器调用解析器。熟悉YACC和BISON的人可能习惯于以相反的方式进行操作-让解析器调用令牌生成器。但是，让分词器调用解析器会更好，因为可以将其设置为线程安全的，并且运行速度更快。</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">请注意，中缀函数（&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;，&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;，&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;和&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;）反转其参数的顺序。因此，&amp;ldquo; like（A，B）&amp;rdquo;等效于&amp;ldquo; B like A&amp;rdquo;。对于形式为&amp;ldquo;像A一样的B&amp;rdquo;，将B项视为函数的第一个参数。但是对于&amp;ldquo; like（A，B）&amp;rdquo;，A项被认为是第一个参数。</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">请注意,在运行&quot;.import &quot;命令之前,必须将 &quot;mode &quot;设置为 &quot;csv&quot;。这对于防止命令行shell试图将输入文件文本解释为其他格式是必要的。</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">请注意,为了使索引搜索效率高,并不一定要对 R*Tree 索引中的所有坐标进行约束。例如,人们可能希望查询所有与第35条平行线重叠的对象。</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">请注意,不需要引用$bigstring的值。这是自动发生的。如果$bigstring是一个大的字符串或二进制对象,这种技术不仅更容易写,而且更有效率,因为它避免了复制$bigstring的内容。</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">请注意,两个或多个线程使用SQLite库访问同一个SQLite数据库文件是完全安全的。SQLite的unix驱动程序知道POSIX咨询锁定的怪癖,并能绕过它们。只有当一个线程试图绕过SQLite库,直接读取数据库文件时,才会出现这个问题。</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">请注意，数据库文件名具有某种扩展名非常重要。如果没有扩展名，则SQLite会通过附加到文件的基本名称来创建辅助文件名。因此，一个名为&amp;ldquo; &lt;code&gt;db01&lt;/code&gt; &amp;rdquo; 的数据库将具有一个名为&amp;ldquo; &lt;code&gt;db01-journal&lt;/code&gt; &amp;rdquo; 的&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;文件。并且由于该文件名没有扩展名，不能缩短到3个字符，因此将按原样使用，并且会违反8 + 3命名规则。</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">请注意，在&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）之前，SQLite在调用xCreate方法之前未检查其是否为NULL。因此，如果在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;版本3.8.11.1&lt;/a&gt;（2015-07-29）或更早版本中注册了仅具名的虚拟表，并且对该虚拟表模块尝试了&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;命令，则会发生跳转到NULL指针的情况，从而导致崩溃</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">请注意，使用gcov运行SQLite并不是对SQLite的测试，而是对测试套件的测试。gcov运行不会测试SQLite，因为-fprofile-args和-ftest-coverage选项使编译器生成不同的代码。gcov运行仅验证测试套件是否提供100％的分支测试覆盖率。gcov运行是测试的测试-元测试。</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;常量也用作&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;回调的潜在返回值，并且&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;也是&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">请注意，&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;和&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口不计算INSTEAD OF触发器触发，但是&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes编译指示&lt;/a&gt;确实计算INSTEAD OF触发器触发。</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;常量也用作&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;回调的潜在返回值，并且&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;也是&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">请注意,DO UPDATE子句只作用于在INSERT过程中发生约束错误的那一条记录。没有必要包含一个WHERE子句,将操作限制在这一条记录上。在DO UPDATE结尾的WHERE子句的唯一用途是根据原始值和/或新的值,选择性地将DO UPDATE改为no-op。例如</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">请注意,SQLITE_TEXT常量在SQLite版本2中也使用过,意义完全不同。同时针对SQLite版本2和SQLite版本3进行链接的软件应该使用SQLITE3_TEXT,而不是SQLITE_TEXT。</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">请注意,SQLite解析器不会总是生成使用索引的代码,即使可以这样做。以下查询目前不会使用索引。</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">请注意,复合查询的UNION ALL操作符本身并不使用瞬时索引(当然,UNION ALL的左右子查询可能会使用瞬时索引,这取决于它们是如何组成的)。</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">请注意，仅在&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体期间调用授权者回调。在&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;中的语句评估期间不会执行授权，除非如前一段所述，否则sqlite3_step（）会在架构更改后调用sqlite3_prepare_v2（）来重新声明语句。</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">请注意，仅在&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体期间调用授权者回调。在&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;中的语句评估期间不会执行授权，除非如前一段所述，否则sqlite3_step（）会在架构更改后调用sqlite3_prepare_v2（）来重新声明语句。</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">请注意，SQLite使用的字符编码机制无法在运行时更改。这仅是编译时选项。该&lt;b&gt;sqlite_encoding&lt;/b&gt;字符串只是告诉你该库是如何被编译。</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">请注意,如果同步设置为FULL,则不需要回滚日志中的校验和。只有当同步设置为NORMAL时,我们才需要用到校验和。尽管如此,校验和值不会有任何影响,因此无论同步设置如何,校验和值都会被包含在回滚日志中。</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">请注意，命令行Shell程序已经为您启用了扩展加载（通过在安装过程中调用&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;接口作为其安装的一部分），因此上述命令可以正常运行，而无需任何特殊的开关，安装或其他复杂操作。</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">需要注意的是,析产函数D是针对指针值P的,而不是针对类型字符串T的,类型字符串T应该是一个寿命无限的静态字符串。</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">请注意，整数键比插入之前表中的最大键大一。新键在表中当前的所有键上都是唯一的，但是它可能与以前从表中删除的键重叠。要创建在表的生命周期内唯一的键，请将&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;关键字添加到&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;声明中。这样，所选密钥将比该表中曾经存在的最大密钥多一。如果该表中先前已存在最大的可能密钥，则&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;将失败，并显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误代码。</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">请注意，&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;的journal_mode为MEMORY或OFF，并且不能更改为其他值。将&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;的journal_mode更改为除MEMORY或OFF以外的任何设置的尝试都将被忽略。还请注意，事务处于活动状态时，不能更改journal_mode。</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">请注意，上面的例程列表是概念性的，而不是实际的。其中许多例程有多个版本。例如，上面的列表显示了一个名为&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）的&lt;/a&gt;例程，而实际上有三个单独的例程以略有不同的方式完成同一件事：&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;。该列表提到了&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;，而实际上不存在这样的例程。列表中显示的&amp;ldquo; sqlite3_column（）&amp;rdquo;是整个例程系列的占位符，这些例程会在各种数据类型中额外增加列数据。</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">请注意,即使在使用OOM覆盖时,内存泄漏检测逻辑也会继续工作。这就验证了SQLite即使在遇到内存分配错误时也不会泄漏内存。还请注意,OOM覆盖可以与任何底层内存分配器一起工作,包括检查内存分配错误的工具化内存分配器。通过这种方式可以验证OOM错误不会诱发其他类型的内存使用错误。</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">请注意，SQLite可以理解的关键字数量可能取决于编译时选项。例如，如果使用&lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;选项编译SQLite，则&amp;ldquo; VACUUM&amp;rdquo;不是关键字。此外，新的关键字可能会添加到SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">请注意，SQLite可以理解的关键字数量可能取决于编译时选项。例如，如果使用&lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;选项编译SQLite，则&amp;ldquo; VACUUM&amp;rdquo;不是关键字。此外，新的关键字可能会添加到SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">请注意,确定列亲和力的规则顺序很重要。一个声明类型为 &quot;CHARINT &quot;的列将同时符合规则1和规则2,但第一条规则优先,因此列的亲和性将是INTEGER。</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">请注意,主结果代码总是扩展结果代码的一部分。给定一个完整的32位扩展结果代码,应用程序总是可以通过提取扩展结果代码中最不重要的8位来找到相应的主要结果代码。</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">请注意,这个SELECT查询的程序没有包含INSERT例子中使用的Transaction和Commit指令。因为SELECT是一个不改变数据库的读操作,所以它不需要事务。</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">请注意，readfile（X）和writefile（X，Y）函数是扩展函数，并且未内置在核心SQLite库中。这些例程在&lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite源代码存储库&lt;/a&gt;中的&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt;源文件中可用作&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">请注意，根据数据库&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;编码&lt;/a&gt;是UTF-8，UTF-16be还是UTF-16le ，将任何非BLOB值转换为BLOB的结果以及将任何BLOB值转换为非BLOB的结果可能会有所不同。。</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">请注意，sqlite3changeset_apply_v2（）API仍处于&lt;b&gt;试验阶段&lt;/b&gt;，因此可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">请注意，sqlite3changeset_start_v2（）API仍处于&lt;b&gt;试验阶段&lt;/b&gt;，因此可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">请注意，一元* + *运算符还会从表达式中删除&lt;a href=&quot;datatype3#affinity&quot;&gt;类型相似性&lt;/a&gt;，在某些情况下，这可能导致表达式含义发生细微变化。在上面的示例中，如果列* x *具有&lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT关联性，&lt;/a&gt;则比较&amp;ldquo; x = 5&amp;rdquo;将作为文本完成。但是* + *运算符会删除相似性。因此，比较&amp;ldquo; + x = 5&amp;rdquo;会将* x *列中的文本与数值5进行比较，并且始终为false。</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">请注意,在语法图中,有些路径在实践中是不允许的。以下是一些例子:</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">注意,等号和不等号运算符有两种变化。等号可以是</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">请注意,这只是一个思想实验。我们并不是建议改变OpenDocument。本文也不是对当前OpenDocument设计的批评。本文的目的是提出改进未来文件格式设计的方法。</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">请注意,只有在试图获取锁的过程中导致I/O错误时才会出现这个问题。如果锁只是没有被授予(因为其他线程或进程已经持有一个冲突的锁),那么永远不会发生损坏。我们不知道有任何操作系统会在尝试获取共享内存上的文件锁时出现I/O错误而失败。因此,这是一个理论问题,而不是一个真正的问题。不用说,这个问题从未在野外观察到过。这个问题是在模拟I/O错误的测试线束中对SQLite进行压力测试时发现的。</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">请注意，此例程在匹配时返回零，在字符串不匹配时返回非零，与&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">请注意，此例程在匹配时返回零，在字符串不匹配时返回非零，与&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;和&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">请注意,当关联的表被删除时,触发器会自动被删除。</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">请注意，当使用SQLITE_THREADSAFE = 0编译SQLite时，构建过程中将省略使SQLite线程安全的代码。发生这种情况时，不可能在启动时或运行时更改&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">请注意，如果LIKE或GLOB运算符的右侧是&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数，&lt;/a&gt;并且使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;准备了该语句，则在每次运行的第一个&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中，该语句将自动重新分析和重新编译。自上次运行以来，与右侧参数的绑定已更改。这种重新解析和重新编译本质上是与架构更改后发生的相同操作。重新编译是必需的，以便查询计划者可以检查绑定到LIKE或GLOB运算符右侧的新值，并确定是否采用上述优化方法。</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">请注意,当类型转换发生时,之前调用sqlite3_column_blob()、sqlite3_column_text()和/或sqlite3_column_text16()返回的指针可能会失效。在以下情况下,可能会发生类型转换和指针无效的情况。</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">请注意，在&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为NORMAL的情况下，检查点是唯一发出I / O屏障或同步操作的操作（unix上的fsync（）或Windows上的FlushFileBuffers（））。因此，如果应用程序在单独的线程或进程中运行检查点，则执行数据库查询和更新的主线程或进程将永远不会阻塞同步操作。这有助于防止在繁忙的磁盘驱动器上运行的应用程序中出现&amp;ldquo;闩锁&amp;rdquo;。此配置的缺点是事务不再持久，并且可能在电源故障或硬重置后回滚。</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">需要注意的是,使用analyze时,成本估算与实际情况比较吻合,NN和N3都选择了算法-1。</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">请注意，xBestIndex将始终在&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;之前调用，因为xBestIndex的idxNum和idxStr输出是xFilter的必需输入。但是，不能保证成功执行xBestIndex之后将调用xFilter。</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">请注意虚拟表名称(&quot;stat&quot;)前的 &quot;temp.&quot;限定词。这个限定词会导致虚拟表是临时的--只在当前数据库连接期间存在。这是推荐的方法。</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">请特别注意最后一项。sqlite3_set_auxdata(C,N,P,X)中的析构器X可能会在 sqlite3_set_auxdata()接口返回之前立即被调用。因此,sqlite3_set_auxdata()应该在函数实现接近尾声的时候调用,并且在调用了sqlite3_set_auxdata()之后,函数实现不应该对P进行任何使用。</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">注意在这些触发器中使用&lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote（）SQL函数&lt;/a&gt;。quote（）函数将其参数转换为适合包含在SQL语句中的形式。数值不变。在字符串前后添加单引号，并且转义任何内部单引号。BLOB值使用SQL标准十六进制BLOB表示法呈现。使用quote（）函数可确保用于撤消和重做的SQL语句始终对SQL注入安全。</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">请注意&amp;ldquo; estimatedRows&amp;rdquo;，&amp;ldquo; idxFlags&amp;rdquo;和colUsed字段上的警告。这些字段分别与SQLite版本3.8.2、3.9.0和3.10.0一起添加。读取或写入这些字段的任何扩展都必须首先检查所使用的SQLite库的版本是否大于或等于适当的版本-也许将&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值与常量3008002、3009000和/或3010000进行比较。尝试访问由较旧版本的SQLite创建的sqlite3_index_info结构中的这些字段的结果未定义。</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注意：标有&amp;ldquo;功能&lt;small&gt;&lt;i&gt;（EXP）&lt;/i&gt;&lt;/small&gt; &amp;rdquo;的&lt;a href=&quot;capi3ref&quot;&gt;实验性&lt;/a&gt;和功能，其名称是&lt;s&gt;通过撞击&lt;/s&gt;被&lt;a href=&quot;capi3ref&quot;&gt;弃用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注意：标有&amp;ldquo;功能&lt;small&gt;&lt;i&gt;（EXP）&lt;/i&gt;&lt;/small&gt; &amp;rdquo;的&lt;a href=&quot;experimental&quot;&gt;实验性&lt;/a&gt;和功能，其名称是&lt;s&gt;通过撞击&lt;/s&gt;被&lt;a href=&quot;experimental&quot;&gt;弃用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">注意：添加了本文的第2.0节和第3.0节，以响应对&lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt;和&lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit的&lt;/a&gt;评论。</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注意：此方法在MacOS X 10.7和iOS版本5.0上被禁用，并且将始终返回SQLITE_MISUSE。在这些系统上，应通过&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;通过数据库的每个连接启用共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注意：此方法在MacOS X 10.7和iOS版本5.0上被禁用，并且将始终返回SQLITE_MISUSE。在这些系统上，应通过&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;通过数据库的每个连接启用共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;optoverview&quot;&gt;查询优化器的说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">注意LIKE操作符是如何实现的。在SQLite中,它是一个用户定义的函数,所以在P3中指定了它的函数定义地址。操作数P1是它要从堆栈中获取的函数参数数。在本例中,LIKE()函数需要2个参数。参数从堆栈中以相反的顺序(从右到左)取下,所以要匹配的模式是堆栈最上面的元素,下一个元素是要比较的数据。返回值被推到堆栈上。</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">注意上面的查询是如何工作的。R*Tree索引在外循环中运行,以查找包含在经度-81...-79.6和纬度35.0...36.2的边界框内的条目。对于找到的每个对象标识符,SQLite都会在demo_data表中查找相应的条目。然后,它将demo_data表中的边界字段作为con contained_in()函数的参数,如果该函数返回true,则将demo_data表中的objname字段作为下一行查询结果返回。</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">注意,所有其他的日期和时间函数都可以用strftime()来表示。</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">请注意,使用SQLite表将内容划分为更小的部分,这为实现提供了灵活性。应用程序可以选择在启动时将所有内容读入内存。或者它可以只将几个页面读取到内存中,并将其余的内容保存在磁盘上。或者它可以每次只将单页内容读入内存。而且不同版本的应用程序可以做出不同的选择,而不需要对文件格式进行任何修改。当所有的内容都在ZIP档案中的一个大的XML文件中时,这样的选项是不可用的。</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">注意,&quot;dummy &quot;记录的 &quot;host &quot;值是NULL,所以结果[]数组在该槽中包含一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">请注意,现在函数的参数是指向 sqlite3_value 结构的指针,而不是像 SQLite 2.X 版本那样指向字符串的指针,以下例程用于从这些 &quot;值 &quot;中提取有用的信息。</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">注意,共享锁是在操作系统的磁盘缓存上,而不是在磁盘本身。文件锁其实只是操作系统内核内的标志,通常。(具体细节取决于具体的操作系统层接口。)因此,如果操作系统崩溃或断电,锁会立即消失。通常情况下,如果创建锁的进程退出,锁也会消失。</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">请注意，fts3tokenize虚拟表的结果集中的令牌已根据令牌生成器的规则进行了转换。由于此示例使用了&amp;ldquo; porter&amp;rdquo;标记器，因此&amp;ldquo; This&amp;rdquo;标记被转换为&amp;ldquo; thi&amp;rdquo;。如果需要令牌的原始文本，则可以使用&lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr（）&lt;/a&gt;函数的&amp;ldquo; start&amp;rdquo;和&amp;ldquo; end&amp;rdquo;列来检索令牌。例如：</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">注意ListRead和Next指令之间的相似性。这两个操作都是按照这个规则工作的。</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">还要注意的是,在平均读性能和平均写性能之间有一个权衡。为了最大限度地提高读性能,我们希望尽可能地保持WAL小,因此要频繁地运行检查点,可能和每次COMMIT一样频繁。为了最大限度地提高写性能,我们希望将每个检查点的成本摊到尽可能多的写中,这意味着我们希望不频繁地运行检查点,并在每个检查点之前让WAL尽可能地增长。因此,根据应用程序的相对读写性能要求,决定运行检查点的频率可能因应用程序而异。默认的策略是一旦WAL达到1000页就运行一个检查点,这个策略在工作站上的测试应用中似乎很好,但其他策略在不同的平台上或对于不同的工作负载可能会更好。</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">现在又可以在MSVC++6上编译了</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">现在可以在Solaris和OpenBSD以及其他缺乏fdatasync()函数的Unix变体上编译。</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">现在考虑一个查询,以找到组织中身高180cm以上的每个人的名字。</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">现在考虑M和N都是3500的情况。爱丽丝节点很多。但假设这些节点中的每一个节点都只由一条或两条边连接。在这种情况下,方案2是首选。如果采用方案2,外循环仍然要运行3500次,但是中循环每一次外循环只运行一到两次,而内循环每一次中循环只运行一次,如果有的话。所以内循环的总迭代次数在7000次左右。而方案一,它的外循环和中循环各要运行3500次,因此中循环的迭代次数为1200万次。因此在第二种情况下,方案2比方案1快了近2000倍。</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">现在是时候对SQLite进行私有的，自定义的修改了，这是本练习的重点。使用&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo;命令切换到私有分支（如果您还没有的话），然后在文本编辑器中调出源文件并进行任何您想进行的更改。完成更改后，请使用以下命令提交这些更改：</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">现在我们来看看如何使用这个索引。考虑下面的查询。</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">现在假设如果用户只有一个电话号码,则user.phone字段包含纯文本,如果用户有多个电话号码,则包含一个JSON数组。提出同样的问题。&quot;哪些用户有704区号的电话号码?&quot; 但现在json_each()函数只能调用那些有两个或多个电话号码的用户,因为json_each()需要格式良好的JSON作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">现在，公共分支机构和私有分支机构不同，您可以运行&amp;ldquo; &lt;code&gt;fossil update trunk&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo;命令，并看到在分支之间来回切换时，化石确实确实改变了结帐中的文件。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-indicator是一个可选的字符串,表示列值为空。默认值是一个空字符串。请注意,列分隔符和null-indicator是可选的位置参数;如果指定了null-indicator,则必须指定列分隔符参数,并在null-indicator参数之前使用。</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">结果集中的列数</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQL参数数量</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">已被以前的检查站回填到数据库中的WAL帧的数量。</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">试图回填但可能没有成功回填的WAL框架的数量。</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">有效载荷的字节数</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">结果集中的列数</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WAL文件中的有效和已提交的帧数。</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">数字和文本类型对DISTINCT关键字也有影响。</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">数字值(序列类型1至9)在NULLs之后按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">数字值按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">大量的错误修复和文档更新。</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">大量的代码优化,特别是为了使代码占用更小而设计的优化。</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">大量的小错误修复</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">众多其他性能的提升</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice和其他机构使用的开放文档演示格式。</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice和其他机构使用的开放文档格式。</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">对于没有FROM子句的查询，将忽略OFFSET子句。门票&lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET给出了正确答案。但是,OFFSET需要的时间与偏移值成正比。&quot;LIMIT x OFFSET y &quot;真正发生的情况是,SQLite将查询计算为 &quot;LIMIT x+y&quot;,并丢弃第一个y值,而不将其返回给应用程序。所以随着窗口向长列表的底部滚动,y值越来越大,连续的偏移计算需要的时间越来越多。</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">旧的参考资料有效</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">关于冲突条款</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM测试是通过模拟OOM错误来完成的。 SQLite允许应用程序使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;替代替代的malloc（）实现，...）界面。 TCL和TH3测试工具都能够插入修改后的malloc（）版本，该版本可以操纵一定数量的分配后失败。可以将这些检测到的malloc设置为仅失败一次，然后再次开始工作，或者在第一次失败后继续失败。 OOM测试是循环完成的。在循环的第一次迭代中，检测到的malloc被装配为在第一次分配时失败。然后执行一些SQLite操作并进行检查以确保SQLite正确处理了OOM错误。然后，已检测的malloc上的故障时间计数器增加一，并重复测试。循环一直进行到整个操作完成为止，而不会遇到模拟的OOM故障。这样的测试运行两次，一次将设置的malloc设置为仅失败一次，而再次将设置的malloc设置为在首次失败后连续失败。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">排序方式</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BY和GROUP BY现在使用有界内存。</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">如果查询具有相同的GROUP BY，则忽略ORDER BY。门票&lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY适用于子选择</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">操作系统接口</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">操作系统接口文件虚拟方法对象</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">操作系统接口对象</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">操作系统界面打开文件手柄</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">凡事都要听从上帝派给你们的掌权者的命令,即使他们(上帝所不允许的)有别的行为,也要注意主的戒律:&quot;照他们所说的去做,而不是照他们所做的去做&quot;。</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">面向对象的设计</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">面向对象是一种设计模式,而不是一种编程语言。你可以用任何你想要的语言进行面向对象编程,包括汇编语言。有些语言(如:C++或Java)让面向对象变得更容易。但你仍然可以用C语言等语言来做面向对象的编程。</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">面向对象不是唯一有效的设计模式。许多程序员被教导要纯粹从对象的角度来思考问题。而且,公平地说,对象通常是分解问题的好方法。但对象并不是唯一的方式,也不总是分解问题的最佳方式。有时候,老式的程序化代码比面向对象的代码更容易写,更容易维护和理解,而且速度更快。</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">触发器的模糊错误修复（&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">过时文件</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">从变更组中获取复合变更组</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">获取聚合函数上下文</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">从Changeset迭代器中获取冲突的行值。</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">从变化集迭代器中获取当前操作。</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">获取表的主键定义</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">获取URI参数的值</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">在数据库文件上获得一个PENDING锁,然后再获得一个EXCLUSIVE锁。如果其他进程仍有共享锁,写作者可能要等到这些共享锁清除后才能获得EXCLUSIVE锁。</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">获得一个缓冲区,其中包含一个代表变化组当前内容的变化集(或补丁集)。如果输入到changegroup的内容本身就是变化集,那么输出就是一个变化集。或者,如果输入是补丁集,输出也是一个补丁集。</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">获取一个包含对作为第一个参数传递的会话对象所附表的更改的更改集。如果成功,在返回SQLITE_OK之前,将*ppChangeset设置为指向一个包含变化集的缓冲区,将*pnChangeset设置为变化集的字节数。如果发生错误,将*ppChangeset和*pnChangeset都设置为0,并返回一个SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">获得特定表的锁。该指令仅在启用共享缓存功能时使用。</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">获得数据库文件上的EXCLUSIVE锁,并确保所有的内存变化都被写入数据库文件,使用上述步骤1-3的算法。</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">从变化集迭代器中获取new.*值。</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">从Changeset迭代器中获取old.*值。</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">从fossil中获取最新的SQLite代码。</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">获取SQL值</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">获取</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">获取mutex。</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">偶尔会发现一个严重的问题,必须针对常规的维护版本发布一个小的 &quot;补丁 &quot;版本。补丁与维护版本的不同之处在于,与上一个版本相比,补丁所修改的代码行数非常少。我们尽一切努力避免发布补丁,确保维护版本没有错误。</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">当然,只有当你的数据库中首先有大量的内容时,ANALYZE才会有效地发挥作用。当创建一个新的数据库时,你期望积累大量的数据,你可以运行命令 &quot;ANALYZE sqlite_master &quot;来创建SQLITE_STAT1表,然后在SQLITE_STAT1表中预先填充描述你的应用程序的典型数据库的内容(使用普通的INSERT语句)--也许是你在实验室中在一个填充良好的模板数据库上运行ANALYZE后提取的内容。</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">当然,在尝试上述4个步骤中的任何一个步骤时,都可能发生错误。如果发生这种情况,那么</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">当然,普通的SQLite表也会针对它的整数主键进行高效的查询,所以前面的内容也没什么大不了的。使用R*Tree的真正原因是为了可以高效地针对坐标范围做不等式查询。如果要找到索引中所有包含在北卡罗来纳州夏洛特市附近的元素,可以这样做。</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">当然,也有可能是系统恢复后确实存在。</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">当然,通常不可能原子化地应用一个项目所需的所有变化。</target>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">当然,人们希望最终能将WAL文件中追加的所有事务转移回原数据库中。将WAL文件中的事务转移回数据库的过程称为&quot;</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">当然,用rowid来排序查询的输出是很少有用的。通常,我们希望通过其他列来对输出进行排序。</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">当然,用所需的索引和冒名表的名字来代替例子中的 &quot;t1bc &quot;和 &quot;t2&quot;。&quot;.imposter &quot;命令读取 &quot;t1bc &quot;索引的模式,使用该信息为冒名表构造一个兼容的CREATE TABLE语句,然后进行所有必要的调用,自动创建瞬时冒名表。</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">当然,上述两个查询并不完全等同。例如LIKE查询会匹配包含 &quot;linuxophobe &quot;或 &quot;EnterpriseLinux &quot;等术语的行(恰好安然E-Mail数据集实际上并不包含任何此类术语),而FTS3表的MATCH查询则只选择包含 &quot;linux &quot;这一离散标记的行。两种搜索都是不区分大小写的。FTS3表在磁盘上的消耗量约为2006MB,而普通表的消耗量仅为1453MB。使用相同的硬件配置来执行上面的SELECT查询,FTS3表的填充只需要不到31分钟,而普通表则需要25分钟。</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">当然,根据硬件、文件系统和操作系统的不同,您的里程数可能会有所不同。在进行特定设计之前,请仔细检查目标硬件上的这些数据。</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">在这些改动中,只有1a和2a到2c是任何形式意义上的不兼容。但是,之前对SQLite源码进行过自定义修改(例如为嵌入式硬件添加自定义操作系统层)的用户可能会发现,这些改动的影响较大。另一方面,这些改动的一个重要目标是使定制SQLite在不同操作系统上的使用更加容易。</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">较旧版本的SQLite无法读取只读的WAL模式数据库。换句话说，为了读取WAL模式数据库，需要写访问权限。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;3.22.0&lt;/a&gt;（2018-01-22）开始，此约束已放松。</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">旧版本的firebird在SELECT DISTINCT和UNION中省略了所有的NULLs。</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">在makefile中省略所有的 &quot;awk&quot;,以方便MSVC用户的开发。</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">省略的参数采用默认值。STEP默认为1。END默认为9223372036854775807。START默认为0。</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">据悉,在安卓系统上,有很多服务会盲目运行从互联网可疑角落下载的不值得信任的应用程序传递给他们的任意SQL。Android服务对于运行来自未经审核的SQL应该是比较警惕的。笔者没有任何具体的例子可以证明,但也听到过存在这种情况的传言。即使所有的Android服务都比较谨慎,对其运行的所有SQL进行适当的审核,也很难对所有的SQL进行审核,以验证它们是否安全。因此,有安全意识的人非常希望通过传递任意的SQL文本来确保没有漏洞的可能。</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">在Linux和其他unix系统上,你需要输入类似这样的内容。</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">在Win32上,当试图删除一个不存在的文件时,不要返回错误。</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">在Windows系统中,文件夹的搜索顺序如下。</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">在使用MSVC的Windows中,使用nmake与Makefile.msc。</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">在Windows上,输入。</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">在&lt;a href=&quot;wal#ckpt&quot;&gt;检查点上&lt;/a&gt;，首先使用&lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;的xSync方法将WAL刷新到持久性存储中。然后，将WAL的有效内容传输到数据库文件中。最后，使用另一个xSync方法调用将数据库刷新到持久性存储。xSync操作充当写障碍-在xSync开始后启动的所有写操作之前，必须先完成在xSync之前启动的所有写操作。</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">在使用索引的DISTINCT查询中,当有合适的索引时,尝试使用索引跳转到下一个不同的条目,而不是跳过行。</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">在传统的旋转磁盘上,一个扇区是读写两个方向的最小传输单位。但在闪存上,读的最小量通常比写的最小量小得多。SQLite只关心最小的写入量,所以在本文中,当我们说 &quot;扇区 &quot;时,我们指的是一次可以写入大容量存储的最小数据量。</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">在&lt;a href=&quot;lang_insert&quot;&gt;INSERT上&lt;/a&gt;，如果未明确为ROWID或INTEGER PRIMARY KEY列提供值，则它将自动用未使用的整数填充，该整数通常比当前使用的最大ROWID多一。无论是否使用AUTOINCREMENT关键字，都是如此。</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">在UPSERT上，如果重新排列了约束检查的顺序，请确保对插入内容的亲和力转换发生在任何约束检查之前。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e的问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">在每次调用 undo::undo 或 undo::redo 时,undo/redo 模块会自动调用所有 toplevel 命名空间中的方法 status_refresh 和 reload_all。这些方法应该被定义为重建显示或以其他方式根据数据库的未做/重做更改来更新程序的状态。</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">在有同步文件系统的嵌入式系统中,TRUNCATE的行为比PERSIST慢。提交操作的速度是一样的。但是在TRUNCATE之后,后续的事务处理速度会变慢,因为覆盖现有内容比追加到文件末尾要快。新的日志文件条目总是在TRUNCATE之后追加,但通常会被PERSIST覆盖。</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">在大多数系统中,malloc()系统调用会返回一个对齐到8字节边界的缓冲区。但在某些系统上(如:windows),malloc()会返回4字节对齐的指针。在从malloc()返回4字节对齐指针的系统上必须使用这个编译时选项。</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">在新版本的SQLite上,只要满足以下一个或多个条件,在只读介质上的WAL模式数据库,或者缺乏写权限的WAL模式数据库,仍然可以被读取。</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">在启动时，&lt;b&gt;sqlite3&lt;/b&gt;程序将显示一条简短的标语消息，然后提示您输入SQL。输入SQL语句（以分号终止），然后按&amp;ldquo; Enter&amp;rdquo;，将执行SQL。</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">在启动时,应用程序首先决定要显示哪个版本。由于versionId会随着时间的推移而自然增加,通常人们会希望看到最新的版本,因此一个合适的查询可能是:。</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功后，将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;并将新的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;存储在* ppBlob中。否则，将返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;，除非错误代码为SQLITE_MISUSE，否则* ppBlob设置为NULL。这意味着，只要不滥用该API，在返回该函数后，始终可以在* ppBlob上调用&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;始终是安全的。</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功后，将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;并将新的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;存储在* ppBlob中。否则，将返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;，除非错误代码为SQLITE_MISUSE，否则* ppBlob设置为NULL。这意味着，只要不滥用该API，在返回该函数后，始终可以在* ppBlob上调用&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;始终是安全的。</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">成功时，&lt;b&gt;sqlite_compile&lt;/b&gt;返回SQLITE_OK。否则，将返回错误代码。</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功时，sqlite3_blob_read（）返回SQLITE_OK。否则，将返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功时，sqlite3_blob_read（）返回SQLITE_OK。否则，将返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功时，sqlite3_blob_write（）返回SQLITE_OK。否则，将返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。除非返回SQLITE_MISUSE，否则此函数将设置可通过&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;及相关函数访问的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功时，sqlite3_blob_write（）返回SQLITE_OK。否则，将返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。除非返回SQLITE_MISUSE，否则此函数将设置可通过&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;及相关函数访问的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功后，sqlite3_prepare（）例程系列将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;；否则返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功后，sqlite3_prepare（）例程系列将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;；否则返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">在Mac上,你可以设置这个pragma。</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">另一方面,使用服务器的数据库引擎可以提供更好的保护,防止客户端应用中的bug--客户端中的游离指针无法破坏服务器上的内存。而且由于服务器是一个单一的持久化进程,它能够更精确地控制数据库的访问,从而实现更细粒度的锁定和更好的并发性。</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">另一方面,使用服务器的数据库引擎可以提供更好的保护,防止客户端应用中的错误--客户端中的游离指针无法破坏服务器上的内存。而且由于服务器是一个单一的持久化进程,它能够更精确地控制数据库访问,从而实现更细粒度的锁定和更好的并发性。</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">另一方面,RBU真空比普通的SQLite VACUUM使用更多的CPU--在一项测试中高达5倍。出于这个原因,在相同的条件下,RBU真空往往比SQLite VACUUM慢得多。</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">另一方面,丢表并不是一个很常见的操作,所以如果SQLite需要的时间长一点,也不会被视为一个大问题。</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">另一方面,如果子查询的结果必须多次扫描(因为,例如,它只是join中的一张表),那么最好使用瞬时表来记住子查询的全部结果,以避免多次计算子查询。</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">另一方面,随着WAL文件大小的增加,读取性能变差,因为每个读者必须检查WAL文件的内容,而检查WAL文件所需的时间与WAL文件的大小成正比。wal-index有助于更快地找到WAL文件中的内容,但随着WAL文件大小的增加,性能还是会下降。因此,为了保持良好的读取性能,通过定期运行检查点来降低WAL文件的大小非常重要。</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">在堆栈显示中，大多数条目都显示有前缀，以告诉该堆栈条目的数据类型。整数以&amp;ldquo; &lt;code&gt;i:&lt;/code&gt; &amp;rdquo; 开头。浮点值以&amp;ldquo; &lt;code&gt;r:&lt;/code&gt; &amp;rdquo; 开头。 （&amp;ldquo; r&amp;rdquo;代表&amp;ldquo;实数&amp;rdquo;。）字符串以&amp;ldquo; &lt;code&gt;s:&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;t:&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;e:&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;z:&lt;/code&gt; &amp;rdquo; 开头。字符串前缀之间的差异是由它们的内存分配方式引起的。 z：字符串存储在从&lt;b&gt;malloc（）&lt;/b&gt;获得的&lt;b&gt;内存中&lt;/b&gt;。 t：字符串是静态分配的。 e：字符串是短暂的。所有其他字符串都带有s：前缀。观察者，这对您没有任何影响，但是对于VDBE来说至关重要，因为z：字符串需要传递给&lt;b&gt;&lt;/b&gt;弹出它们时的&lt;b&gt;free（）&lt;/b&gt;以避免内存泄漏。请注意，仅显示字符串值的前10个字符，并且将二进制值（例如MakeRecord指令的结果）视为字符串。可以存储在VDBE堆栈上的唯一其他数据类型是NULL，它不带前缀显示为简单的&amp;ldquo; &lt;code&gt;NULL&lt;/code&gt; &amp;rdquo;。如果整数同时作为整数和字符串放置在堆栈中，则其前缀为&amp;ldquo; &lt;code&gt;si:&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">在unix系统上(或者在Windows系统上使用cygwin或mingw+msys),命令通常看起来像这样。</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">在unix上,如果打开了数据库文件的符号链接,那么对应的日志文件是基于实际的文件名,而不是符号链接名。</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">在类似unix的系统中,目录的搜索顺序如下。</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">仅在Windows上，将所有&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;字符转换为&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">仅在Windows上，如果文件名以驱动器号开头，请在前面加上一个&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">每年一次</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">一旦注册了VFS，就永远不能对其进行修改。如果需要更改行为，则应注册一个新的VFS。该应用程序可能使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;定位旧的VFS，将旧的VFS的副本复制到新的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象中，对新的VFS进行所需的修改，取消注册旧的VFS，然后在其中注册新的VFS。地点。即使已注销，现有的数据库连接也将继续使用旧的VFS，但是新的数据库连接将使用新的VFS。</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">一旦连接获得了表锁,在当前事务(读或写)结束之前,它不会被释放。</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">一旦一个进程获得了独占锁,它就被允许向数据库文件写入。然后,它从回滚日志中读取页面的原始内容,并将这些内容写回数据库文件中的原处。回想一下,回滚日志的页眉记录了中止事务开始之前数据库文件的原始大小。在不完整事务导致数据库增长的情况下,SQLite使用该信息将数据库文件截断回其原始大小。在这一步骤结束时,数据库的大小应该与中止事务开始前的大小相同,包含的信息也相同。</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">一旦表被附加到会话对象上,会话对象就会记录插入到表中的所有新行的主键值。它还记录任何被删除或更新的行的原始主键和其他列值。对于每个唯一的主键值,数据只记录一次--在会话的生命周期中,第一次插入、更新或删除带有所述主键的行时。</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">一旦事务被打开,从数据库连接中读取数据是一个简单的操作。使用数据库文件上打开的文件柄的xRead()方法,一次读取所需的数据库文件页。SQLite从不读取部分页面,总是对每个所需页面使用一次对xRead()的调用。</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">一旦创建了虚拟表，就可以像其他任何表一样使用该表，但上面提到的例外情况除外，并由特定的虚拟表实现实施。使用普通的&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;语法销毁虚拟表。</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">再次,实际的实现可能会对这个结构进行子类化,以增加额外的私有字段。</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">再一次,SQL语句生成的字节码完全相同,因此以完全相同的方式完成了相同的工作。但第二种形式通过将查询参数归纳为一个单一的行值,而不是将它们分散在WHERE子句中,使人类更容易阅读。</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">当所有回滚日志文件被刷新到磁盘后,就可以安全地开始更新数据库文件了。在写入更改之前,我们必须获得所有数据库文件的专属锁。在所有的更改写完后,必须将更改冲到磁盘上,这样在断电或操作系统崩溃时,这些更改就会被保存下来。</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">一旦一个SQLite数据库被打开,就可以通过使用</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">一旦为数据库设置了编码,就不能更改。</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">一旦独占锁被持有,我们就知道没有其他进程从数据库文件中读取,向数据库文件写入更改是安全的。通常这些更改只到操作系统的磁盘缓存,不会一直到大容量存储。</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">一旦发生了任何转换,并且两个值都不是NULL,就会对这些值进行比较。如果两个值都是blobs,那么就用memcmp()来确定比较的结果,如果两个值都是文本,那么就用P4中指定的整理函数进行比较。如果两个值都是文本,则使用P4中指定的适当的整理函数进行比较。如果没有指定P4,那么就用memcmp()来比较文本字符串,如果两个值都是数字,那么就用P4中指定的整理函数来比较。如果两个值都是数值,则使用数值比较。如果两个值的类型不同,那么数字被认为小于字符串,字符串被认为小于blobs。</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">一切准备就绪后，请运行&amp;ldquo; &lt;code&gt;fossil commit&lt;/code&gt; &amp;rdquo;命令以检查更改。这将在上图中创建圆（4）。</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">一旦人们对单独存储每张幻灯片的概念感到满意,那么支持演示文稿的版本化就是一小步。考虑以下模式。</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">一旦填充,有三种方法可以针对FTS5表的内容执行全文查询。</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">一旦被清除的脏页可以写,就会简单地写入数据库文件中。</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">一旦来自FROM子句的输入数据被WHERE子句表达式(如果有的话)过滤,简单SELECT的结果行集就会被计算出来。具体如何计算取决于简单的SELECT是集合查询还是非集合查询,以及是否指定了GROUP BY子句。</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">一旦项目仓库被创建,通过移动到你想保存所有项目源代码的目录并键入,创建一个项目的开放检查。</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">一旦spellfix1扩展被加载,spellfix1虚拟表的实例就会像这样创建。</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">一旦测试程序生成,它将在没有参数的情况下运行,以执行测试。进度信息以及错误诊断出现在标准输出上。(对于缺乏标准输出通道的嵌入式设备,可以使用编译时选项进行替代输出安排)。如果没有错误,程序返回零,如果检测到任何问题,则返回非零。</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">一旦创建了虚拟表,就可以进行如下查询。</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">一旦你找到了一个特定的版本,点击该版本的超链接,就可以看到 &quot;签到信息页&quot;。然后点击 &quot;Tarball &quot;链接或 &quot;ZIP archive &quot;链接,下载完整的源代码树。</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">此查询的一种方法是使用WHERE子句的fruit ='Orange'术语查找涉及橙子的所有行，然后通过拒绝来自加利福尼亚州以外州的任何行来过滤这些行。上面的&lt;a href=&quot;#fig7&quot;&gt;图7&lt;/a&gt;显示了此过程。在大多数情况下，这是一种完全合理的方法。是的，数据库引擎确实必须对后来被拒绝的佛罗里达橙行进行额外的二进制搜索，因此它的效率不如我们希望的那样，尽管对于许多应用程序来说，它的效率已足够。</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">我们也可以在模块名称后面为模块提供逗号分隔的参数。</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">也可以使用&amp;ldquo; .eqp on&amp;rdquo;命令将&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;设置为自动EXPLAIN QUERY PLAN模式：</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">我们也可以把保存点看作是事务时间轴上的 &quot;标记&quot;。在这个视图中,SAVEPOINT命令创建了一个新的标记,ROLLBACK TO命令将时间轴倒退到命名标记之后的一个点,而RELEASE命令则从时间轴上删除了标记,而实际上并没有对数据库做任何改变。</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">可以使用类似这样的pragma明确地改变WAL模式。</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">我们可以看到OR-by-UNION技术是如何被利用的,在WHERE子句的术语由AND连接的查询中,通过使用一个intersect操作符来代替union,来使用多个索引。许多SQL数据库引擎都会这样做。但与只使用单个索引相比,性能的提升是微乎其微的,所以SQLite目前没有实现这种技术。不过,未来的版本SQLite可能会增强对AND-by-INTERSECT的支持。</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">不能在虚拟表上创建一个触发器。</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">不能在虚拟表上创建其他索引。（虚拟表可以具有索引，但是必须将其内置到虚拟表实现中。不能使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句单独添加索引。）</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">人们无法使用通用工具轻松查看、更改或提取OpenDocument演示文稿的内容。唯一合理的查看或编辑OpenDocument文档的方法是使用专门为读写OpenDocument而设计的应用程序打开它(读:LibreOffice或它的一个兄弟)。情况可能更糟。人们可以使用 &quot;zip &quot;存档工具从演示文稿中提取和查看单个图像(比如)。但从幻灯片中提取文本是不合理的。请记住,所有的内容都存储在一个单一的 &quot;context.xml &quot;文件中。该文件是XML,所以它是一个文本文件。但它不是一个文本文件,可以用普通的文本编辑器来管理。对于上面的例子演示,content.xml文件正好由两行组成。文件的第一行只是。</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">无法对虚拟表运行&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Next和ListRead的一个区别是它们对 &quot;事物 &quot;的概念。Next指令的 &quot;事物 &quot;是数据库文件中的记录。ListRead的 &quot;东西 &quot;是一个列表中的整数键。另一个区别是,如果没有下一个 &quot;事物&quot;,是跳转还是跌过。在这种情况下,Next落空,ListRead跳转。后面我们会看到其他的循环指令(NextIdx和SortNext),它们的操作原理是一样的。</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">其中一个示例发生在2013年8月30日左右的&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;规范存储库中。在那种情况下，文件描述符2（标准错误）在&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;之前被错误地关闭了（我们怀疑是&lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel &lt;/a&gt;），因此用于存储库数据库文件的文件描述符为2。后来，一个应用程序错误引起了assert（ ）语句通过调用write（2，...）发出错误消息。但是由于文件描述符2现在已连接到数据库文件，因此错误消息覆盖了数据库的一部分。为防止此类问题，SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;版本3.8.1&lt;/a&gt;（2013-10-17）及更高版本拒绝为数据库文件使用低编号的文件描述符。（请参见&lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; 有关其他信息。）</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">SQLite的无类型性的一个例外是一个类型为INTEGER PRIMARY KEY的列。(而且你必须使用 &quot;INTEGER &quot;而不是 &quot;INT&quot;。类型为INT PRIMARY KEY的列和其他列一样是无类型的)。)INTEGER PRIMARY KEY列必须包含一个32位有符号的整数。任何插入非整数数据的尝试都会导致错误。</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">上面的一个含义是,如果在一个会话中进行了更改,然后又取消了更改(例如,如果一行被插入,然后又被删除),会话模块根本不会报告任何更改。或者,如果一行在同一个会话中被更新了多次,那么所有的更新都会在任何变化集或补丁集blob中被合并成一个单一的更新。</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">也许有人会说,在这个多千兆字节的台式机时代,把整个文件读到内存中是可以的。但这是不行的。首先,使用的内存量远远超过了磁盘上的(压缩)文件大小。所以一个50MB的演示文稿可能要占用200MB甚至更多的内存。如果一次只编辑一个文件,这还是没有问题的。但是在做演讲时,本作者通常会有10个或15个不同的演示文稿同时出现(以方便复制/粘贴过去演示文稿中的幻灯片),因此需要千兆内存。再加上一两个打开的网页浏览器和其他一些桌面应用,突然间磁盘就呼呼作响,机器也在不停地交换。而在一台加装了Ubuntu的廉价Chromebook上工作时,即使只有一个文档也是个问题。使用更少的内存总是更好。</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">可能需要提供其他&lt;a href=&quot;compile&quot;&gt;编译时选项，&lt;/a&gt;例如&lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt;或&lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt;用于全文搜索，&lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt;用于R * Tree搜索引擎扩展，&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;包括&lt;a href=&quot;json1&quot;&gt;JSON SQL函数&lt;/a&gt;，或&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;用于&lt;a href=&quot;dbstat&quot;&gt;dbstat&lt;/a&gt;。为了在&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;列表中查看更多评论，请添加&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;选项。在Unix系统上，如果主机支持usleep（）系统调用，请添加-DHAVE_USLEEP = 1。添加-DHAVE_READLINE以及-lreadline和-inccurses库以获得命令行编辑支持。可能还需要指定一些编译器优化开关。 （可从SQLite网站下载的预编译CLI使用&amp;ldquo; -Os&amp;rdquo;。）这里有无数可能的变化。编译全功能shell的命令可能类似于以下内容：</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">将内容分割成小块的一个小缺点是,压缩在较短的文本上效果不佳,因此文档的大小可能会增加。但是,由于文档空间的大部分用于存储图像,文本内容压缩效率的小幅下降几乎不会被察觉,这是为改善用户体验而付出的小代价。</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">10个十进制字符中的一个ASCII字符或</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">52个大写和小写ASCII字符中的一个,即</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">SQLite 的&lt;a href=&quot;different&quot;&gt;独特功能&lt;/a&gt;之一是数据库由单个磁盘文件组成。因为移动或备份数据库就像复制单个文件一样简单，所以这简化了SQLite的使用。它还使SQLite适合用作&lt;a href=&quot;whentouse#appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;。但是，虽然完整的数据库保存在单个磁盘文件中，但SQLite确实在处理数据库的过程中使用了许多临时文件。</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">在简单的SELECT语句中，ALL或DISTINCT关键字之一可以紧跟SELECT关键字。如果简单SELECT是SELECT ALL，则SELECT返回整个结果行集。如果ALL或DISTINCT都不存在，则行为就像指定了ALL。如果简单的SELECT是SELECT DISTINCT，则在返回结果行之前，将从结果行集中删除重复的行。为了检测重复的行，两个NULL值被认为是相等的。在&lt;a href=&quot;datatype3#colrules&quot;&gt;通常的规则&lt;/a&gt;适用于选择归类序列比较文本值。</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">作为项目的一部分托管代码生成器工具的优势之一是,可以优化工具以服务于整个项目的特定需求。Lemon就得益于这种效果。多年来,Lemon解析器生成器一直在扩展和增强,以向SQLite提供新的功能和改进的性能。Lemon专门为SQLite使用而设计的一些具体增强功能包括:。</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">VFS界面有趣的功能之一是SQLite可以同时支持多个VFS。在首次使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;打开连接时，每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;都必须选择一个VFS供其使用。但是，如果一个进程包含多个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接，则&lt;/a&gt;每个进程都可以选择不同的VFS。可以在运行时使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;接口添加VFS 。</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossil提供的众多报告之一是对单个分支进行更改的时间表，其中显示了该分支内外的所有合并。有关此类报告的典型示例，请参见&lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt;。生成此类报告通常只需几毫秒。但是在升级到NGQP之后，我们注意到该报告对存储库主干的花费接近10秒。</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">SQLite为确保事务在系统崩溃和电源故障时是原子性的，要做的一件事是在更改数据库之前将所有更改写入回滚日志文件。 TCL测试工具包含一个可选的&lt;a href=&quot;vfs&quot;&gt;OS后端&lt;/a&gt;实现，有助于验证此操作是否正确发生。 &amp;ldquo; journal-test VFS&amp;rdquo;监视数据库文件和回滚日志之间的所有磁盘I / O流量，检查以确保没有任何内容写入数据库文件，而该文件尚未被首先写入并同步到回滚日志。如果发现任何差异，则会引发断言错误。</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">自上次运行ANALYZE以来，当前未对表的一个或多个索引进行分析，&lt;em&gt;或者&lt;/em&gt;表中的行数增加了25倍或更多。</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">自从当前的wal文件在磁盘上创建以来,必须有一个或多个事务被写入该文件(通过任何连接)。这意味着不能在第一次打开没有wal文件的wal模式数据库后立即进行快照。必须先向它写入至少一个事务。</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">一种解决方案是在数据库模式中添加一个SQL外键约束,以强制执行与</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">解决此问题的一种方法是更改​​SQLite，以详尽搜索最佳路径。但是穷举搜索需要与K成正比的时间！（其中K是联接中的表数），因此当您超出10路&lt;a href=&quot;c3ref/prepare&quot;&gt;联接&lt;/a&gt;时，运行sqlite3_prepare（）的时间将变得非常大。</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">避免全表扫描的一种技术是按rowid（或等效的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;）进行查找。要查询桃子的价格，可以查询rowid为4的条目：</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">Git和Fossil的一个用户都&lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;在HN中写道&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">在SQLite上使用的一种验证技术是,将整个测试套件运行两次,一次是在优化保持开启的情况下,第二次是在优化关闭的情况下,验证两次得到的输出是否相同。这表明优化不会引入错误。</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">一种非常简单的方案可能是计算每个结果文档中用户搜索词的实例数。那些包含多个术语实例的文档被认为比每个术语具有少量实例的文档更相关。在FTS应用程序中，可以通过对&lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt;函数的返回值中的整数进行计数来确定每个结果中的术语实例数。以下示例显示了一个查询，该查询可用于获取用户输入的查询的十个最相关的结果：</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">解决这个问题的一个方法是检查 sqlite3_step()调用返回的扩展错误代码。如果存在阻塞连接,那么扩展错误代码就被设置为SQLITE_LOCKED_SHAREDCACHE。否则,在特殊的 &quot;DROP TABLE/INDEX &quot;情况下,扩展错误代码只是SQLITE_LOCKED。</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">计算FindFrame(P,M)的一种方法是扫描aPgno数组,从第M个条目开始,向后退,返回J,其中aPgno[J]==P。这样的算法是可行的,而且比搜索整个WAL文件中最新的页数P的帧要快得多。</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">创建冒牌表的一种方法是直接编辑sqlite_master表,插入一条新的描述表的记录。例如,假设模式是这样的。</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">在shell脚本中使用sqlite3的一种方法是使用 &quot;echo &quot;或 &quot;cat &quot;在一个文件中生成一个命令序列,然后调用sqlite3,同时从生成的命令文件中重定向输入。这样做很好,在很多情况下都是合适的。但是作为一种额外的方便,sqlite3允许在命令行中输入一条SQL命令作为数据库名称后的第二个参数。当sqlite3程序以两个参数启动时,第二个参数被传给SQLite库进行处理,查询结果以列表模式打印在标准输出上,然后程序退出。这种机制的设计是为了使sqlite3与 &quot;awk &quot;等程序结合使用,非常方便。例如</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">如果不使用R*Tree索引,使用以下更简单的查询也能得到同样的答案。</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">一步式查询执行界面</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">在线备份API</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">在线备份API。</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">在线备份对象</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">这里只测量CPU周期数。CPU周期数是能源消耗的良好代表,但并不一定与现实世界的时间有很好的相关性。做I/O的时间并没有反映在CPU周期数中,而I/O时间在许多SQLite使用场景中占主导地位。</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">一个数据库连接上一次只能有一个授权者。每次调用sqlite3_set_authorizer都会覆盖之前的调用。通过安装一个NULL回调来禁用授权器。默认情况下,授权器是被禁用的。</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">每个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;一次只能定义一个进度处理程序；设置新的进度处理程序将取消旧的进度处理程序。将参数X设置为NULL将禁用进度处理程序。通过将N设置为小于1的值，也会禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">每个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;一次只能定义一个进度处理程序；设置新的进度处理程序将取消旧的进度处理程序。将参数X设置为NULL将禁用进度处理程序。通过将N设置为小于1的值，也会禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">仅考虑由INSERT，UPDATE或DELETE语句直接进行的更改- 不计算由&lt;a href=&quot;../lang_createtrigger&quot;&gt;触发器&lt;/a&gt;，&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;外键操作&lt;/a&gt;或&lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt;约束解析引起的辅助更改。</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">仅考虑由INSERT，UPDATE或DELETE语句直接进行的更改- 不计算由&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;，&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外键操作&lt;/a&gt;或&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;约束解析引起的辅助更改。</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">只有索引的a列和b列是可用的。d列不能用,因为c列没有约束,而且在索引可用的列集中不能有空隙。</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">只有索引的a、b和c列是可用的。d列不能用,因为它出现在c的右边,而c只受不等式的限制。</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">仅当两个或多个附加数据库都被修改，没有将&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为OFF，也没有将&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;设置为OFF，MEMORY或WAL时，才创建&lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;主日记&lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">仅在其大小超过阈值时创建&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;语句日记&lt;/a&gt;文件。否则，日记将保留在内存中，并且不会发生I / O。可在编译时使用&lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;或在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;）配置阈值。</target>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">只有WHERE子句评价为true的表的行才会被包含在索引中。如果表的某些行的WHERE子句表达式评价为NULL或false,那么这些行将从索引中被省略。</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">只搜索词汇中具有匹配 langid 的词汇。因此,同一个表可以包含多种语言的词条,并且只使用所要求的语言。默认的langid为0。</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">只有 &quot;ll &quot;长度修饰符对SQLite有影响。而且只有在使用C语言接口的时候才会有所区别。</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">只支持ALTER TABLE命令的RENAME TABLE、ADD COLUMN和RENAME COLUMN变体。其他类型的ALTER TABLE操作,如DROP COLUMN、ALTER COLUMN、ADD CONSTRAINT等都被省略。</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">仅支持隐式版本的AND运算符。指定字符串 &quot;AND &quot;作为标准查询语法查询的一部分,会被解释为对包含术语 &quot;and &quot;的文档集的术语查询。</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">使用SQLite只需要1.0节中描述的三个核心例程。但还有许多其他函数提供了有用的接口。这些扩展例程如下。</target>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">如果COLLATE正确，则仅使用基于表达式的索引来优化ORDER BY或GROUP BY。门票&lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">操作码名称</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">操作码定义</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">打开一个增量I/O的BLOB。</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">打开光标进入要查询的表。</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">打开一个新的光标P1，它指向与光标P2相同的临时表。P2游标必须已由先前的&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;操作码打开。仅临时光标可以重复。</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">打开一个新游标P1到瞬时表。即使主数据库是只读,游标也总是被打开读/写。当游标关闭时,暂存表会被自动删除。</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">打开一个新的游标,该游标指向一个假表,该表中包含了一行数据。这一行的内容就是内存寄存器P2的内容。换句话说,游标P1成为寄存器P2中包含的MEM_Blob内容的别名。</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">在数据库文件中为根表为P2的数据库表打开一个只读游标。数据库文件由P3确定。P3 == 0表示主数据库，P3 == 1表示用于临时表的数据库，P3&amp;gt; 1表示使用相应的附加数据库。给新光标一个标识符P1。P1值不必是连续的，但所有P1值都应该是小整数。P1为负是错误的。</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">在表或索引上打开一个名为P1的读/写游标,该游标的根页是P2(如果在P5中设置了OPFLAG_P2ISREG位,则其根页被保存在寄存器P2中--见下文)。</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">使用 sqlite3rbu_open(T,A,S)函数打开一个 RBU 句柄。</target>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">打开文件&quot;/home/fred/data.db&quot;。使用特殊的VFS &quot;unix-dotfile&quot;,它使用点文件来代替posix咨询锁定。</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">打开当前目录下的文件 &quot;data.db &quot;进行只读访问。无论默认情况下是否启用共享缓存模式,都要使用私有缓存。</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">打开数据库文件&quot;/home/fred/data.db&quot;。</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">打开数据库文件,获取一个SHARED锁。如果不能获得SHARED锁,则立即失败并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">打开当前目录下的文件 &quot;data.db&quot;。</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">打开两个游标,分别指向被查询的两个表。</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">根据P1的值,打开、释放或回滚由参数P4命名的保存点。要打开一个新的保存点,设置P1==0 (SAVEPOINT_BEGIN)。要释放(提交)一个现有的保存点,设置 P1==1 (SAVEPOINT_RELEASE)。要回滚现有的保存点,设置 P1==2 (SAVEPOINT_ROLLBACK)。</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">开闭回调</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">打开一个新的数据库连接</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">打开一个新的连接</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">打开一个只读交易</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">打开一个连接。</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">打开一个新的数据库连接是一个两步走的过程。</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">开启一个只读交易。</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">开启读写交易。</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">开立报表交易。</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">操作数P1必须是0x7fffffff,P2必须是正数。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">优化：在具有&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;的表上执行&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;时，如果表达式索引未引用要更新的表的任何列，则不要更新表达式索引。</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">对sqlite_mprintf()例程进行优化。</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">优化&lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#length&quot;&gt;length（）&lt;/a&gt; SQL函数，以便避免不必要地从磁盘读取数据库内容。</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">优化器在使用指数来满足ORDER BY子句,对整数主键进行排序方面做得比较好。</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">优化程序的增强：当LIKE运算符的RHS上的绑定发生更改或&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;下的任何范围约束发生更改时，&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;将自动重新编译。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">选择1:</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">备选方案2:</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">可选的限制和排序条款</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">可选LIMIT和ORDER BY条款</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">当数据库连接共享一个公共缓存时,可选择READ UNCOMMITTED隔离(而不是默认的SERIALIZABLE隔离级别)和表级锁定。</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">可选地,表的主键。同时支持单列和复合(多列)主键。</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">&lt;b&gt;sqlite3&lt;/b&gt;命令可理解的选项包括：</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">或者考虑这些相同的查询。</target>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">或者在Windows上使用MSVC。</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">或优化</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
