<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="d664cf7cb7a8aa891620cace778bbb7e18301125" translate="yes" xml:space="preserve">
          <source>Improved optimization of queries containing aggregate min() or max().</source>
          <target state="translated">改进了对包含集合min()或max()的查询的优化。</target>
        </trans-unit>
        <trans-unit id="85221cb8e52f1982bf5ad92049ab6c11d2f8041b" translate="yes" xml:space="preserve">
          <source>Improved performance of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; locking primitives in cases where there are hundreds of connections all accessing the same database file at once.</source>
          <target state="translated">在有数百个连接都一次访问同一数据库文件的情况下，&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;锁定原语的性能得到了改善。</target>
        </trans-unit>
        <trans-unit id="aa1222b8dcd6d3acb1bb29b90eb9192b7d6106ad" translate="yes" xml:space="preserve">
          <source>Improved performance of queries like &quot;SELECT min(x) FROM t WHERE y IN (?,?,?)&quot; assuming an index on t(x,y).</source>
          <target state="translated">改进了 &quot;SELECT min(x)FROM t WHERE y IN (?,?,?)&quot;这样的查询的性能,假设t(x,y)上有索引。</target>
        </trans-unit>
        <trans-unit id="84a557fad116fe49221d1a9424a92f1e575e49e1" translate="yes" xml:space="preserve">
          <source>Improved performance of queries with many OR-connected terms in the WHERE clause that can all be indexed.</source>
          <target state="translated">提高了在WHERE子句中有许多OR连接词的查询性能,这些词都可以被索引。</target>
        </trans-unit>
        <trans-unit id="fc268c97ccbef9521d6905694e7c21645578065f" translate="yes" xml:space="preserve">
          <source>Improved pthreads detection in configure scripts.</source>
          <target state="translated">改进了配置脚本中的pthreads检测。</target>
        </trans-unit>
        <trans-unit id="17ac50232b81e80729264e903268e1bebc9e53d7" translate="yes" xml:space="preserve">
          <source>Improved query plan optimization when the DISTINCT keyword is present.</source>
          <target state="translated">当存在DISTINCT关键字时,改进了查询计划优化。</target>
        </trans-unit>
        <trans-unit id="59b96d30821cc9cbdef8a394c82f7fd97d223fd7" translate="yes" xml:space="preserve">
          <source>Improved resistance against goofy query planner decisions caused by incomplete or incorrect modifications to the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; table by the application.</source>
          <target state="translated">改进了对应用程序对&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;表的不完整或不正确修改导致的愚蠢查询计划者决策的抵抗力。</target>
        </trans-unit>
        <trans-unit id="6b8ef39e97edafb5ec621a586930697f00cfaa0e" translate="yes" xml:space="preserve">
          <source>Improved response to out-of-memory errors</source>
          <target state="translated">改善对内存外错误的反应</target>
        </trans-unit>
        <trans-unit id="5ae15f37694ee149c6eea70b18fae46fd07528e4" translate="yes" xml:space="preserve">
          <source>Improved robustness against corrupt database files.</source>
          <target state="translated">提高了对数据库文件损坏的鲁棒性。</target>
        </trans-unit>
        <trans-unit id="166028811fd163330b2455278e9c44de42779fbe" translate="yes" xml:space="preserve">
          <source>Improved support for Cygwin.</source>
          <target state="translated">改进对Cygwin的支持。</target>
        </trans-unit>
        <trans-unit id="4c53e2cba5a1410927dfe514c0901b0fd71f140c" translate="yes" xml:space="preserve">
          <source>Improved support for using the STDCALL calling convention in winsqlite3.dll.</source>
          <target state="translated">改进了对winsqlite3.dll中STDCALL调用约定的支持。</target>
        </trans-unit>
        <trans-unit id="92763dc3583bdd282b9026c7f80e9e51775413fc" translate="yes" xml:space="preserve">
          <source>Improved syntax error messages in the parser</source>
          <target state="translated">改进了解析器中的语法错误信息。</target>
        </trans-unit>
        <trans-unit id="35f950df2561f1db8f684a7b33f41fde15c8c04c" translate="yes" xml:space="preserve">
          <source>Improved test coverage</source>
          <target state="translated">提高测试覆盖率</target>
        </trans-unit>
        <trans-unit id="6fb91ee1a232fc876617f991f25282c326c1cf11" translate="yes" xml:space="preserve">
          <source>Improved test coverage. Fixed a few obscure bugs found by the improved tests.</source>
          <target state="translated">提高了测试覆盖率。修正了改进后的测试所发现的一些不明显的错误。</target>
        </trans-unit>
        <trans-unit id="5177fb86b97cfe6466bc589640835c3dab84ade3" translate="yes" xml:space="preserve">
          <source>Improved the cost estimation for an index scan which includes a WHERE clause that can be partially or fully evaluated using columns in the index and without having to do a table lookup. This fixes a performance regression that occurred for some obscure queries following the ORDER BY LIMIT optimization introduced in &lt;a href=&quot;#version_3_12_0&quot;&gt;version 3.12.0&lt;/a&gt;.</source>
          <target state="translated">改进了包含WHERE子句的索引扫描的成本估算，该索引可以使用索引中的列进行部分或完全评估，而无需执行表查找。这修复了在&lt;a href=&quot;#version_3_12_0&quot;&gt;3.12.0版中&lt;/a&gt;引入的ORDER BY LIMIT优化之后某些晦涩的查询所发生的性能下降。</target>
        </trans-unit>
        <trans-unit id="9737446abc238ba64625d047b10e2ea194379924" translate="yes" xml:space="preserve">
          <source>Improved the query planner so that the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; can be used on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if one or more of the disjuncts use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operators.</source>
          <target state="translated">改进了查询计划程序，以便即使一个或多个析取项使用&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;，&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;，&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;，&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;运算符，也可以在&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;上使用&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c7991b90a25fa494ea7173ba16f41d0e843c78b" translate="yes" xml:space="preserve">
          <source>Improved the windows VFS to better defend against interference from anti-virus software.</source>
          <target state="translated">改进了windows VFS,更好地抵御反病毒软件的干扰。</target>
        </trans-unit>
        <trans-unit id="6c9542942225b685370a9ff791f1911ab55a40d4" translate="yes" xml:space="preserve">
          <source>Improved tracing and debugging facilities in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Windows &lt;a href=&quot;vfs&quot;&gt;VFS中&lt;/a&gt;改进的跟踪和调试功能。</target>
        </trans-unit>
        <trans-unit id="c1ee9a0442382c4cebcfe1b576c0d1fff396e4cb" translate="yes" xml:space="preserve">
          <source>Improved unicode filename handling in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on Windows.</source>
          <target state="translated">Windows &lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;改进的unicode文件名处理。</target>
        </trans-unit>
        <trans-unit id="09e6f225ca0ca885645a927e0763b14b484dc7f0" translate="yes" xml:space="preserve">
          <source>Improvements and bug-fixes in support for &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;.</source>
          <target state="translated">支持&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT的&lt;/a&gt;改进和错误修复。</target>
        </trans-unit>
        <trans-unit id="c4b534f7c6c26f504f16d9c38af50fef3ae45002" translate="yes" xml:space="preserve">
          <source>Improvements to &quot;dot-command&quot; handling in the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">改进了&lt;a href=&quot;cli&quot;&gt;命令行界面中&lt;/a&gt; &amp;ldquo;点命令&amp;rdquo;的处理。</target>
        </trans-unit>
        <trans-unit id="47099268e1cc1a7d37272d0a960d324c9d2e5b20" translate="yes" xml:space="preserve">
          <source>Improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">对&lt;a href=&quot;fts3&quot;&gt;FTS3的&lt;/a&gt;改进。</target>
        </trans-unit>
        <trans-unit id="18fe2fab208a9bdfd95bd5b0724b7f338ba76be8" translate="yes" xml:space="preserve">
          <source>Improvements to cost estimates for the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化的&lt;/a&gt;成本估算的改进。</target>
        </trans-unit>
        <trans-unit id="f56d95c4feb425fac688efbe211f20dca39f2585" translate="yes" xml:space="preserve">
          <source>Improvements to rounding behavior, so that the results of rounding binary numbers using the &lt;a href=&quot;lang_corefunc#round&quot;&gt;round()&lt;/a&gt; function are closer to what people who are used to thinking in decimal actually expect.</source>
          <target state="translated">舍入行为的改进，以便使用&lt;a href=&quot;lang_corefunc#round&quot;&gt;round（）&lt;/a&gt;函数对二进制数进行舍入的结果更接近于习惯于以十进制思考的人们的实际期望。</target>
        </trans-unit>
        <trans-unit id="5353c2af79675cc29c5733088967c970c2cbd2d3" translate="yes" xml:space="preserve">
          <source>Improvements to test coverage, other minor bugs fixed, memory leaks plugged, code refactored and/or recommended in places for easier reading.</source>
          <target state="translated">改进了测试覆盖率,修复了其他小bug,堵住了内存泄漏,重构了代码和/或推荐的地方,方便阅读。</target>
        </trans-unit>
        <trans-unit id="1672d028ed8042c2cdc755bd4feb4bfb1a305542" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;.help&quot; command.</source>
          <target state="translated">改进&quot;.help &quot;命令。</target>
        </trans-unit>
        <trans-unit id="9829e00db8ef5babdf62ad53520c9aed14ba5d0e" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;PRAGMA integrity_check&quot; command</source>
          <target state="translated">改进 &quot;PRAGMA integrity_check &quot;命令。</target>
        </trans-unit>
        <trans-unit id="e5c25ee1584b55a6798dccb371f9de65d6e26320" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;命令行外壳的&lt;/a&gt;改进：</target>
        </trans-unit>
        <trans-unit id="7bd7a08c86f6e2927260bf75b7f206267bdb5a66" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt; in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it recovers more content from corrupt database files.</source>
          <target state="translated">改进了&lt;a href=&quot;cli&quot;&gt;CLI中&lt;/a&gt;的&lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt;，以便从损坏的数据库文件中恢复更多内容。</target>
        </trans-unit>
        <trans-unit id="56bedeb29e748e173925f592478fb7224bd2a9a7" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge command&lt;/a&gt; of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to better control the index size for a full-text index that is subject to a large number of updates.</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;的&lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge命令&lt;/a&gt;的改进，可以更好地控制全文索引的索引大小，该全文索引需要进行大量更新。</target>
        </trans-unit>
        <trans-unit id="4f8a0d7434e9fa0e3d93bd594ec2f731beeeee4c" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;:</source>
          <target state="translated">对&lt;a href=&quot;optoverview&quot;&gt;查询计划程序的&lt;/a&gt;改进：</target>
        </trans-unit>
        <trans-unit id="64a384308e143ce85fad7f48be7bf89bd88826a0" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax bubble diagrams&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;syntaxdiagrams&quot;&gt;语法气泡图的&lt;/a&gt;改进</target>
        </trans-unit>
        <trans-unit id="444f392b3ac06b6a270033461a34681437b33fc9" translate="yes" xml:space="preserve">
          <source>Improvements to the Makefiles and build scripts used by VisualStudio.</source>
          <target state="translated">改进VisualStudio使用的Makefile和构建脚本。</target>
        </trans-unit>
        <trans-unit id="187c307e740f14eb7715914261b63385a7891140" translate="yes" xml:space="preserve">
          <source>Improvements to the amalgamation generator script so that all symbols are prefixed with either SQLITE_PRIVATE or SQLITE_API.</source>
          <target state="translated">对合并生成器脚本进行了改进,使所有符号都以 SQLITE_PRIVATE 或 SQLITE_API 为前缀。</target>
        </trans-unit>
        <trans-unit id="8487f548381bd47de49bbe554c9e3c26fcef5a1f" translate="yes" xml:space="preserve">
          <source>Improvements to the comments in the VDBE byte-code display when running &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">运行&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;时，改进了VDBE字节码显示中的注释。</target>
        </trans-unit>
        <trans-unit id="e6a8494de38f18f2b5e148ff117a682e5366a648" translate="yes" xml:space="preserve">
          <source>Improvements to the effectiveness and accuracy of the &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; SQL hint functions.</source>
          <target state="translated">改进了SQL提示函数&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;似然（）&lt;/a&gt;，&lt;a href=&quot;lang_corefunc#likely&quot;&gt;可能性（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不太&lt;/a&gt;可能（）的有效性和准确性。</target>
        </trans-unit>
        <trans-unit id="fb078db70835b73a43d340944c34ddf931e04436" translate="yes" xml:space="preserve">
          <source>Improvements to the handling of CSV inputs in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">改进了&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;中CSV输入的处理</target>
        </trans-unit>
        <trans-unit id="35621122cb25f12ea29297b200f9cd7f54653df0" translate="yes" xml:space="preserve">
          <source>Improvements to the query planner so that it makes better estimates of plan costs and hence does a better job of choosing the right plan, especially when &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; is used.</source>
          <target state="translated">对查询计划程序的改进，使其可以更好地估算计划成本，从而更好地选择正确的计划，尤其是在使用&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;时。</target>
        </trans-unit>
        <trans-unit id="b56408ef9cd6514cec8e529db1c7c154a8214dac" translate="yes" xml:space="preserve">
          <source>Improvements to the windows makefiles and build processes.</source>
          <target state="translated">改进windows的makefiles和构建过程。</target>
        </trans-unit>
        <trans-unit id="01c7395c54005792d7fd39d556adb0b44131f473" translate="yes" xml:space="preserve">
          <source>In &quot;column&quot; mode (and also in &quot;box&quot;, &quot;table&quot;, and &quot;markdown&quot; modes) the width of columns adjusts automatically. But you can override this, providing a minimum width for each column using the &quot;.width&quot; command. The arguments to &quot;.width&quot; are integers which are the minimum number of spaces to devote to each column. Negative numbers mean right-justify. Thus:</source>
          <target state="translated">在 &quot;列 &quot;模式下(在 &quot;框&quot;、&quot;表 &quot;和 &quot;标记 &quot;模式下也是如此),列的宽度会自动调整,但你可以覆盖这一点,使用&quot;.width &quot;命令为每个列提供最小宽度。但是你可以覆盖这一点,使用&quot;.width &quot;命令为每一列提供一个最小宽度。&quot;.width &quot;的参数是整数,也就是每列的最小空格数。负数意味着右对齐。因此,&quot;.width &quot;的参数为</target>
        </trans-unit>
        <trans-unit id="b24a3b4f842f4beb9d0cf338bd2105050638be32" translate="yes" xml:space="preserve">
          <source>In &quot;line&quot; mode, each column in a row of the database is shown on a line by itself. Each line consists of the column name, an equal sign and the column data. Successive records are separated by a blank line. Here is an example of line mode output:</source>
          <target state="translated">在 &quot;行 &quot;模式下,数据库一行中的每一列都单独显示在一行上。每一行由列名、等号和列数据组成。连续的记录之间用空行隔开。下面是一个行模式输出的例子。</target>
        </trans-unit>
        <trans-unit id="ba464cb54f172ce24a6d088a3cb06af2c611f784" translate="yes" xml:space="preserve">
          <source>In &quot;quote&quot; mode, the output is formatted as SQL literals. Strings are enclosed in single-quotes and internal single-quotes are escaped by doubling. Blobs are displayed in hexadecimal blob literal notation (Ex: x'abcd'). Numbers are displayed as ASCII text and NULL values are shown as &quot;NULL&quot;. All columns are separated from each other by a comma (or whatever alternative character is selected using &quot;.separator&quot;).</source>
          <target state="translated">在 &quot;引号 &quot;模式下,输出的格式为SQL字元。字符串用单引号括起来,内部单引号用双引号转义。块以十六进制的块文字符号显示(例如:x'abcd')。数字显示为ASCII文本,NULL值显示为 &quot;NULL&quot;。所有列之间用逗号(或用&quot;.分隔符 &quot;选择的任何替代字符)分隔。</target>
        </trans-unit>
        <trans-unit id="e70135d1b4c87e02724b6a6725f67c0cdcedb6a8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">在&lt;a href=&quot;../wal&quot;&gt;WAL模式下&lt;/a&gt;，在同一个数据库文件上打开的多个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;可以各自读取数据库文件的不同历史版本。当&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;开始读取事务时，该连接将看到数据库的不变副本，因为该副本在事务首次启动时存在。在启动新的读取事务之前，读取器将看不到其他连接对数据库的后续更改。</target>
        </trans-unit>
        <trans-unit id="545faac3a749c9fbe686ac2c42b0a8ce0746bb4b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), shared-cache mode was modified so that the same cache can be shared across an entire process rather than just within a single thread. Prior to this change, there were restrictions on passing database connections between threads. Those restrictions were dropped in 3.5.0 update. This document describes shared-cache mode as of version 3.5.0.</source>
          <target state="translated">在&lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;3.5.0版&lt;/a&gt;（2007-09-04）中，修改了共享缓存模式，以便可以在整个进程中共享同一缓存，而不仅仅是在单个线程中共享。在进行此更改之前，在线程之间传递数据库连接受到限制。这些限制在3.5.0更新中被删除。本文档介绍了自3.5.0版开始的共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="8b22aada76f514795f041039b72ce60807690314" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; mode, call fsync() immediately after truncating the journal file to ensure that the transaction is durable across a power loss.</source>
          <target state="translated">在&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = TRUNCATE&lt;/a&gt;模式下，在截断日志文件后立即调用fsync（），以确保事务在断电后仍可持久。</target>
        </trans-unit>
        <trans-unit id="b06cad3e4dffb16827f43add94eb56f4465695b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, attempting to attach the same database file more than once results in an error.</source>
          <target state="translated">在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;，尝试多次附加同一数据库文件会导致错误。</target>
        </trans-unit>
        <trans-unit id="9f41922c2aa21a0c294b4cbf9d4bf48e3b8e9e1c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, if a writer crashes and leaves the &lt;a href=&quot;walformat#shm&quot;&gt;shm file&lt;/a&gt; in an inconsistent state, subsequent transactions are now able to recover the shm file even if there are active read transactions. Before this enhancement, shm file recovery that scenario would result in an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error.</source>
          <target state="translated">在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;，如果写入器崩溃并使&lt;a href=&quot;walformat#shm&quot;&gt;shm文件&lt;/a&gt;处于不一致状态，那么即使存在活动的读取事务，后续事务现在也可以恢复shm文件。在进行此增强之前，该情况下的shm文件恢复将导致&lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="4d45c296410a6677088e7e7ac84b1e93a1f22edc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;，在同一个数据库文件上打开的多个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;可以各自读取数据库文件的不同历史版本。当&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;开始读取事务时，该连接将看到数据库的不变副本，因为该副本在事务首次启动时存在。在启动新的读取事务之前，读取器将看不到其他连接对数据库的后续更改。</target>
        </trans-unit>
        <trans-unit id="ddd420dd1a1ef7aee27736d7c043708aacde1ceb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode when synchronous is NORMAL (1), the WAL file is synchronized before each &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the database file is synchronized after each completed &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the WAL file header is synchronized when a WAL file begins to be reused after a checkpoint, but no sync operations occur during most transactions. With synchronous=FULL in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction help ensure that transactions are durable across a power loss. Transactions are consistent with or without the extra syncs provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL is normally all one needs in WAL mode.</source>
          <target state="translated">在&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;模式下，当sync为NORMAL（1）时，将在每个&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;之前对WAL文件进行同步，而在每个完成的&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;之后对数据库文件进行同步，并且在检查点之后开始重新使用WAL文件时，将对WAL文件头进行同步。同步操作发生在大多数事务中。在WAL模式下，当sync = FULL时，在每次事务提交之后，都会对WAL文件进行额外的同步操作。每笔交易之后的额外WAL同步有助于确保交易在断电后具有持久性。事务是否与sync = FULL提供的额外同步一致，也可以不同步。如果不考虑耐久性，那么在WAL模式下通常只需要sync = NORMAL。</target>
        </trans-unit>
        <trans-unit id="5a4b7cd3ba1686efa11d9b9c015db21adcf22977" translate="yes" xml:space="preserve">
          <source>In CHECK constraints of a table definition.</source>
          <target state="translated">在表定义的CHECK约束中。</target>
        </trans-unit>
        <trans-unit id="1207ec4eb27468881c3e5a75c509547ec16346af" translate="yes" xml:space="preserve">
          <source>In DDL</source>
          <target state="translated">在DDL中</target>
        </trans-unit>
        <trans-unit id="06bb676fb43ba64638eb5aba12a8d226fa52bf86" translate="yes" xml:space="preserve">
          <source>In DEFAULT constraints of a table definition.</source>
          <target state="translated">在表定义的DEFAULT约束中。</target>
        </trans-unit>
        <trans-unit id="0fc22d3edb7a25933470b0fc98cd018feb112e2e" translate="yes" xml:space="preserve">
          <source>In DML</source>
          <target state="translated">在DML</target>
        </trans-unit>
        <trans-unit id="805c25b267572c14bae2116b6611f039f1f80c5c" translate="yes" xml:space="preserve">
          <source>In I/O error tests, after the I/O error simulation failure mechanism is disabled, the database is examined using &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to make sure that the I/O error has not introduced database corruption.</source>
          <target state="translated">在I / O错误测试中，禁用I / O错误模拟失败机制后，将使用&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;检查数据库，以确保I / O错误未引起数据库损坏。</target>
        </trans-unit>
        <trans-unit id="0f2cfcdcfc92b4b01bee8dec645ecb5ceaaa8098" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table.</source>
          <target state="translated">在Lemon中，分词器调用解析器。Yacc以相反的方式操作，解析器调用标记器。Lemon方法是可重入且线程安全的，而Yacc使用全局变量，因此两者都不是。对于SQLite，重入性尤其重要，因为某些SQL语句对解析器进行递归调用。例如，当解析CREATE TABLE语句时，SQLite递归调用解析器以生成INSERT语句，以在&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;表中添加新条目。</target>
        </trans-unit>
        <trans-unit id="830b24ce26b7fcd4a09816d124ab8737256342ba" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table.</source>
          <target state="translated">在Lemon中，分词器调用解析器。 Yacc以相反的方式操作，解析器调用标记器。 Lemon方法是可重入且线程安全的，而Yacc使用全局变量，因此两者都不是。对于SQLite，重入性尤其重要，因为某些SQL语句对解析器进行递归调用。例如，当解析CREATE TABLE语句时，SQLite递归调用解析器以生成INSERT语句以在&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;表中添加新条目。</target>
        </trans-unit>
        <trans-unit id="d3369588aeb6a765cf20a5709a06e66a042c401f" translate="yes" xml:space="preserve">
          <source>In NORMAL locking-mode (the default unless overridden at compile-time using &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;), a database connection unlocks the database file at the conclusion of each read or write transaction. When the locking-mode is set to EXCLUSIVE, the database connection never releases file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock is obtained and held. The first time the database is written, an exclusive lock is obtained and held.</source>
          <target state="translated">在NORMAL锁定模式下（除非使用&lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;在编译时进行覆盖，否则默认为默认模式），数据库连接将在每次​​读取或写入事务结束时解锁数据库文件。当锁定模式设置为EXCLUSIVE时，数据库连接永远不会释放文件锁。第一次以EXCLUSIVE模式读取数据库时，将获取并保留一个共享锁。第一次写入数据库时​​，将获得并保留排他锁。</target>
        </trans-unit>
        <trans-unit id="f8c693ba3fad2e1d7df97dd42327c19b66a284bb" translate="yes" xml:space="preserve">
          <source>In SQLite</source>
          <target state="translated">在SQLite中</target>
        </trans-unit>
        <trans-unit id="e298a84cbd8720f440fc21a95dd67ebcefa40857" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06) and later, the colUsed field is available to indicate which fields of the virtual table are actually used by the statement being prepared. If the lowest bit of colUsed is set, that means that the first column is used. The second lowest bit corresponds to the second column. And so forth. If the most significant bit of colUsed is set, that means that one or more columns other than the first 63 columns are used. If column usage information is needed by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method, then the required bits must be encoded into either the idxNum or idxStr output fields.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;版本3.10.0&lt;/a&gt;（2016-01-06）和更高版本中，colUsed字段可用于指示所准备的语句实际使用虚拟表的哪些字段。如果设置了colUsed的最低位，则表示使用了第一列。第二最低位对应于第二列。依此类推。如果设置了colUsed的最高有效位，则表示使用了前63列以外的一个或多个列。如果&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法需要列使用情况信息，则必须将所需的位编码为idxNum或idxStr输出字段。</target>
        </trans-unit>
        <trans-unit id="828bdde156beec9d0455bf5a047ac9dedf77b343" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;version 3.28.0&lt;/a&gt; (2019-04-16), windows function support was extended to include the EXCLUDE clause, GROUPS frame types, window chaining, and support for &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; and &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot; boundaries in RANGE frames.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;版本3.28.0&lt;/a&gt;（2019-04-16）中，对Windows函数的支持进行了扩展，以包括EXCLUDE子句，GROUPS框架类型，窗口链接以及对Windows中的&amp;ldquo; &amp;lt;expr&amp;gt; PRECEDING&amp;rdquo;和&amp;ldquo; &amp;lt;expr&amp;gt; FOLLOWING&amp;rdquo;边界的支持。 RANGE帧。</target>
        </trans-unit>
        <trans-unit id="7a9dbb486e8961eb98612eeeff0292e2cdc9f06c" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26) and earlier, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; used to always return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it was invoked again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; without an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. This caused problems on some poorly written smartphone applications which did not correctly handle the &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; and &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error returns. Rather than fix the many defective smartphone applications, the behavior of SQLite was changed in 3.6.23.2 to automatically reset the prepared statement. But that changed caused issues in other improperly implemented applications that were actually looking for an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return to terminate their query loops. (Anytime an application gets an SQLITE_MISUSE error code from SQLite, that means the application is misusing the SQLite interface and is thus incorrectly implemented.) The SQLITE_OMIT_AUTORESET interface was added to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;version 3.7.5&lt;/a&gt; (2011-02-01) in an effort to get all of the (broken) applications to work again without having to actually fix the applications.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;3.6.23.1&lt;/a&gt;（2010-03-26）及更早版本中，如果在返回&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;以外的任何内容之后再次调用&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;，而没有中间调用&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;，则&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;总是返回SQLITE_MISUSE。这在一些编写不正确的智能手机应用程序上引起了问题，这些应用程序不能正确处理&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;和&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误返回。不是修复许多有缺陷的智能手机应用程序，而是在3.6.23.2中更改了SQLite的行为，以自动重置准备好的语句。但是这种变化导致了其他未正确实施的应用程序中的问题，这些应用程序实际上正在寻找&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;返回以终止其查询循环。（每当应用程序从SQLite获取SQLITE_MISUSE错误代码，这意味着该应用程序滥用SQLite接口，因此实现不正确。）SQLITE_OMIT_AUTORESET接口已添加到SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;版本3.7.5&lt;/a&gt;（2011-02-01）中，以期使所有（损坏的）应用程序再次运行，而无需实际修复应用程序。</target>
        </trans-unit>
        <trans-unit id="69f5fb95e32697faf43d50fb7301e963589e0bce" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indexes in the schema.</source>
          <target state="translated">在SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;版本3.8.0&lt;/a&gt;（2013-08-26）和更高版本中，每次准备使用自动索引的语句时，都会将&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt;消息发送到&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;。应用程序开发人员可以并且应该使用这些警告来确定对架构中新的持久索引的需求。</target>
        </trans-unit>
        <trans-unit id="ae75dbb8c6b830d21fb52ab24e85cf97f8c0d055" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indices in the schema.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;版本3.8.0&lt;/a&gt;（2013-08-26）及更高版本中，每次准备使用自动索引的语句时，都会向&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;发送一条&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt;消息。应用程序开发人员可以并且应该使用这些警告来确定对架构中新的持久索引的需求。</target>
        </trans-unit>
        <trans-unit id="311b836bebf13bf229bfb5d427d7d61edb397191" translate="yes" xml:space="preserve">
          <source>In SQLite Version 3</source>
          <target state="translated">在SQLite 3版本中</target>
        </trans-unit>
        <trans-unit id="44b0d77bd3716352e42cf5f2569dabd7987b859f" translate="yes" xml:space="preserve">
          <source>In SQLite version 2</source>
          <target state="translated">在SQLite 2版本中</target>
        </trans-unit>
        <trans-unit id="ab1b358df4951321dec42436274a7fc7055620c8" translate="yes" xml:space="preserve">
          <source>In SQLite version 2, if many processes are reading from the database, it might be the case that there is never a time when there are no active readers. And if there is always at least one read lock on the database, no process would ever be able to make changes to the database because it would be impossible to acquire a write lock. This situation is called &lt;em&gt;writer starvation&lt;/em&gt;.</source>
          <target state="translated">在SQLite版本2中，如果有许多进程正在从数据库中读取数据，则可能是从来没有时间没有活动的读取器。而且，如果数据库上始终至少有一个读锁，则任何进程都将无法对数据库进行更改，因为将不可能获得写锁。这种情况称为&lt;em&gt;作家饥饿&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0e7545ebfe6eb34f26f31fe8304f6f550663c8e8" translate="yes" xml:space="preserve">
          <source>In SQLite version 3, the sqlite3_exec routine is just a wrapper around calls to the prepared statement interface.</source>
          <target state="translated">在SQLite第3版中,sqlite3_exec例程只是对准备好的语句接口调用的一个包装器。</target>
        </trans-unit>
        <trans-unit id="e7a56207acc60b29c6f42211f54c5ca8f6e54fa3" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.0, the rowid is a 64-bit signed integer. This is an expansion of SQLite version 2.8 which only permitted rowids of 32-bits.</source>
          <target state="translated">在SQLite 3.0版本中,rowid是一个64位有符号的整数。这是对SQLite 2.8版本的扩展,该版本只允许32位的rowid。</target>
        </trans-unit>
        <trans-unit id="eade6a0b14d85e68f1dde5969cd3e571c5e3e4f6" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted. That capability is no longer provided. Only built-in memory allocators can be used.</source>
          <target state="translated">在SQLite 3.5.0和3.5.1版本中,可以定义SQLITE_OMIT_MEMORY_ALLOCATION,这将导致这些例程的内置实现被省略。现在不再提供这种功能。只能使用内置的内存分配器。</target>
        </trans-unit>
        <trans-unit id="7278a0046b6c686e7491a606645054d45ac6a9da" translate="yes" xml:space="preserve">
          <source>In SQLite versions 3.3.0 through 3.4.2 when shared-cache mode is enabled, a database connection may only be used by the thread that called &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create it. And a connection could only share cache with another connection in the same thread. These restrictions were dropped beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04).</source>
          <target state="translated">在启用共享缓存模式的SQLite 3.3.0至3.4.2版本中，数据库连接只能由调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;的线程创建。一个连接只能与同一线程中的另一个连接共享缓存。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;3.5.0&lt;/a&gt;（2007-09-04）开始删除了这些限制。</target>
        </trans-unit>
        <trans-unit id="4af0e6be92f4dba4280a2c7e3664bbca74929393" translate="yes" xml:space="preserve">
          <source>In SQLite, a column with type INTEGER PRIMARY KEY is an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (except in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) which is always a 64-bit signed integer.</source>
          <target state="translated">在SQLite中，类型为INTEGER PRIMARY KEY的列是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;的别名（在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中除外），该别名始终是64位有符号整数。</target>
        </trans-unit>
        <trans-unit id="d48f1e4d1dbe48d61b2a0bc14d1d629523402032" translate="yes" xml:space="preserve">
          <source>In SQLite, a database object (a table, index, trigger or view) is identified by the name of the object and the name of the database that it resides in. Database objects may reside in the main database, the temp database, or in an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;.</source>
          <target state="translated">在SQLite中，数据库对象（表，索引，触发器或视图）由对象名称和其所在数据库的名称标识。数据库对象可以位于主数据库，临时数据库或一个&lt;a href=&quot;lang_attach&quot;&gt;附加的数据库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d037fc285a8e821543df8fc13d9f7837388fd3a" translate="yes" xml:space="preserve">
          <source>In SQLite, table rows normally have a 64-bit signed integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; which is unique among all rows in the same table. (&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are the exception.)</source>
          <target state="translated">在SQLite中，表行通常具有64位带符号整数&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;，该ID在同一表的所有行中都是唯一的。（&lt;a href=&quot;withoutrowid&quot;&gt;没有ROWID&lt;/a&gt;表是例外。）</target>
        </trans-unit>
        <trans-unit id="fe38d7c32db7d9028a7337d49fe5d30adb864ee5" translate="yes" xml:space="preserve">
          <source>In SQLite, the answer to the previous question is &quot;no&quot;. For testing purposes, the SQLite source code defines macros called ALWAYS() and NEVER(). The ALWAYS() macro surrounds conditions which are expected to always evaluate as true and NEVER() surrounds conditions that are always evaluated to false. These macros serve as comments to indicate that the conditions are defensive code. In release builds, these macros are pass-throughs:</source>
          <target state="translated">在SQLite中,前一个问题的答案是 &quot;没有&quot;。为了测试的目的,SQLite源代码定义了名为ALWAYS()和NEVER()的宏。ALWAYS()宏包围了那些预期总是被评估为真的条件,而NEVER()包围了那些总是被评估为假的条件。这些宏作为注释,表明这些条件是防御性代码。在发行版构建中,这些宏是通证。</target>
        </trans-unit>
        <trans-unit id="f43676df6968c4bb63677e4842db7886283fb3e7" translate="yes" xml:space="preserve">
          <source>In SQLite, the presence of assert(X) means that the developers have a proof that X is always true. Readers can depend upon X being true to help them reason about the code. An assert(X) is a strong statement about the truth of X. There is no doubt.</source>
          <target state="translated">在SQLite中,assert(X)的存在意味着开发者可以证明X总是真。读者可以依靠X为真来帮助他们推理代码。assert(X)是一个关于X的真实性的有力声明,没有任何疑问。</target>
        </trans-unit>
        <trans-unit id="afc867db69a6f0ff03a7d5c74a860a19b5e1f763" translate="yes" xml:space="preserve">
          <source>In WAL mode, changes to the database are detected using the wal-index and so the change counter is not needed. Hence, the change counter might not be incremented on each transaction in WAL mode.</source>
          <target state="translated">在WAL模式下,数据库的变化是通过wal-index来检测的,所以不需要变化计数器。因此,在WAL模式下,变化计数器可能不会在每个事务中递增。</target>
        </trans-unit>
        <trans-unit id="56b4d5a656b5f1cb948b72fc909adc62f6fce99b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, all ORDER BY expressions are handled as aliases for one of the result columns of the compound. If an ORDER BY expression is not an integer alias, then SQLite searches the left-most SELECT in the compound for a result column that matches either the second or third rules above. If a match is found, the search stops and the expression is handled as an alias for the result column that it has been matched against. Otherwise, the next SELECT to the right is tried, and so on. If no matching expression can be found in the result columns of any constituent SELECT, it is an error. Each term of the ORDER BY clause is processed separately and may be matched against result columns from different SELECT statements in the compound.</source>
          <target state="translated">在&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT&lt;/a&gt;语句中，所有ORDER BY表达式均作为复合结果列之一的别名处理。如果ORDER BY表达式不是整数别名，则SQLite会在化合物中最左边的SELECT中搜索与上述第二或第三条规则匹配的结果列。如果找到匹配项，则搜索将停止，并且该表达式将作为已与其匹配的结果列的别名进行处理。否则，将尝试右边的下一个SELECT，依此类推。如果在任何组成的SELECT的结果列中找不到匹配的表达式，则为错误。 ORDER BY子句的每个术语都单独处理，并且可以与复合物中不同SELECT语句的结果列进行匹配。</target>
        </trans-unit>
        <trans-unit id="7e23feed60f0ebed492861c5dd540e487916faa3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may have an ORDER BY clause. That ORDER BY clause will apply across all elements of the compound. If the right-most element of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause, then no ORDER BY clause is allowed on that statement.</source>
          <target state="translated">在&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT&lt;/a&gt;语句中，只有最后一个或最右边的&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单SELECT&lt;/a&gt;可以具有ORDER BY子句。该ORDER BY子句将应用于该化合物的所有元素。如果&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT&lt;/a&gt;的最右边的元素是&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;子句，则该语句上不允许使用ORDER BY子句。</target>
        </trans-unit>
        <trans-unit id="60dd93ddbe8f5275cb023ced823e2e72128039a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may contain a LIMIT clause. In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, the LIMIT clause applies to the entire compound, not just the final SELECT. If the right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; then no LIMIT clause is allowed.</source>
          <target state="translated">在&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT中&lt;/a&gt;，只有最后一个或最右边的&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单SELECT&lt;/a&gt;可以包含LIMIT子句。在&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECT中&lt;/a&gt;，LIMIT子句适用于整个复合，而不仅仅是最终的SELECT。如果最右边的&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单SELECT&lt;/a&gt;是&lt;a href=&quot;lang_select#values&quot;&gt;VALUES子句，&lt;/a&gt;则不允许LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="4a8149bd98030a655ea899de201ec17546792e89" translate="yes" xml:space="preserve">
          <source>In a CASE with a base expression, the base expression is evaluated just once and the result is compared against the evaluation of each WHEN expression from left to right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression for which the comparison is true. Or, if none of the WHEN expressions evaluate to a value equal to the base expression, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions produce a result equal to the base expression, the overall result is NULL.</source>
          <target state="translated">在带有基础表达式的CASE中,基础表达式只被评价一次,其结果与从左到右的每个WHEN表达式的评价进行比较。CASE表达式的结果是与比较为真的第一个WHEN表达式对应的THEN表达式的评价。或者,如果没有一个WHEN表达式的值等于基础表达式,则是评价ELSE表达式(如果有)的结果。如果没有ELSE表达式,并且没有一个WHEN表达式产生的结果等于基础表达式,则整体结果为NULL。</target>
        </trans-unit>
        <trans-unit id="9908cac3e7af8453ade042a08abc46157b47dbc8" translate="yes" xml:space="preserve">
          <source>In a CASE without a base expression, each WHEN expression is evaluated and the result treated as a boolean, starting with the leftmost and continuing to the right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression that evaluates to true. Or, if none of the WHEN expressions evaluate to true, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions are true, then the overall result is NULL.</source>
          <target state="translated">在没有基础表达式的CASE中,每个WHEN表达式都会被评估,结果被当作布尔值处理,从最左边开始,一直到右边。CASE表达式的结果是与第一个WHEN表达式对应的THEN表达式的评价,该表达式的评价结果为真。或者,如果没有一个WHEN表达式评价为真,则是评价ELSE表达式(如果有)的结果。如果没有ELSE表达式,而且WHEN表达式都不为真,那么总体结果为NULL。</target>
        </trans-unit>
        <trans-unit id="6181d4389ce1218d0117e383d6876208b5204220" translate="yes" xml:space="preserve">
          <source>In a compound SELECT, all the constituent SELECTs must return the same number of result columns. As the components of a compound SELECT must be simple SELECT statements, they may not contain &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses. &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses may only occur at the end of the entire compound SELECT, and then only if the final element of the compound is not a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause.</source>
          <target state="translated">在复合SELECT中，所有组成的SELECT必须返回相同数量的结果列。由于复合SELECT的组件必须是简单的SELECT语句，因此它们可能不包含&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;或&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;子句。&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;和&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;子句只能在整个复合SELECT的末尾出现，然后仅在该复合词的最后一个元素不是&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;子句时才出现。</target>
        </trans-unit>
        <trans-unit id="78d71ac8fe601725ccb2ce14d7f5ff1b4e551c1c" translate="yes" xml:space="preserve">
          <source>In a custom format defined by the RBU application.</source>
          <target state="translated">以RBU应用程序定义的自定义格式。</target>
        </trans-unit>
        <trans-unit id="c01843d896cd964dc56835ee2c755615d047e3ab" translate="yes" xml:space="preserve">
          <source>In a database that uses ptrmap pages, all pages at locations identified by the computation in the previous paragraph must be ptrmap page and no other page may be a ptrmap page. Except, if the byte-lock page happens to fall on the same page number as a ptrmap page, then the ptrmap is moved to the following page for that one case.</source>
          <target state="translated">在使用ptrmap页的数据库中,上一段计算确定的位置的所有页面必须是ptrmap页,其他页面不得是ptrmap页。只是,如果字节锁页恰好和ptrmap页落在同一个页码上,那么这一个情况下,ptrmap就会被移到下一个页面。</target>
        </trans-unit>
        <trans-unit id="27e8a07a53d50d810a0832f44496263b4918565d" translate="yes" xml:space="preserve">
          <source>In a database with ptrmap pages, the first ptrmap page is page 2. A ptrmap page consists of an array of 5-byte entries. Let J be the number of 5-byte entries that will fit in the usable space of a page. (In other words, J=U/5.) The first ptrmap page will contain back pointer information for pages 3 through J+2, inclusive. The second pointer map page will be on page J+3 and that ptrmap page will provide back pointer information for pages J+4 through 2*J+3 inclusive. And so forth for the entire database file.</source>
          <target state="translated">在一个有ptrmap页的数据库中,第一个ptrmap页是第2页。一个ptrmap页由一个5字节的条目数组组成。让J是一个页的可用空间中可以容纳的5字节条目的数量,(换句话说,J=U/5)。(换句话说,J=U/5。)第一个ptrmap页将包含第3页到J+2页(含)的后指针信息。第二个指针图页将在J+3页上,该ptrmap页将提供J+4到2*J+3(含)页的后指针信息。以此类推整个数据库文件。</target>
        </trans-unit>
        <trans-unit id="413d5f86aecfe4e03a70ec087a2506b07314a985" translate="yes" xml:space="preserve">
          <source>In a general query, dependencies need not be on a single loop, and hence the matrix of dependencies might not be representable as a graph. For example, one of the WHERE clause constraints might be S.a=L.b+P.c, implying that the S loop must be an inner loop of both L and P. Such dependencies cannot be drawn as a graph since there is no way for an arc to originate at two or more nodes at once.</source>
          <target state="translated">在一般的查询中,依赖关系不需要在一个单一的循环上,因此依赖关系的矩阵可能不能用图来表示。例如,其中一个WHERE子句约束条件可能是S.a=L.b+P.c,这意味着S循环必须是L和P的内部循环。这样的依赖关系不能画成图,因为没有办法让一个弧线同时起源于两个或多个节点。</target>
        </trans-unit>
        <trans-unit id="3cba367e5a45e9ef327972801946d29ebc579596" translate="yes" xml:space="preserve">
          <source>In a join, two or more tables are combined to generate a single result. The result table consists of every possible combination of rows from the tables being joined. The easiest and most natural way to implement this is with nested loops.</source>
          <target state="translated">在联接中,两个或多个表被结合起来,生成一个结果。结果表由被连接表的所有可能的行组合组成。最简单、最自然的实现方式是使用嵌套循环。</target>
        </trans-unit>
        <trans-unit id="ea43a43981be0da7d2383a4a8fa8f578ad332998" translate="yes" xml:space="preserve">
          <source>In a more complete build, SQLite also uses library routines like malloc() and free() and operating system interfaces for opening, reading, writing, and closing files. But even then, the number of dependencies is very small. Other &quot;modern&quot; language, in contrast, often require multi-megabyte runtimes loaded with thousands and thousands of interfaces.</source>
          <target state="translated">在更完整的构建中,SQLite还使用了malloc()和free()等库例程,以及打开、读取、写入和关闭文件的操作系统接口。但即便如此,依赖的数量也非常少。相比之下,其他的 &quot;现代 &quot;语言往往需要多兆字节的运行时,加载成千上万的接口。</target>
        </trans-unit>
        <trans-unit id="84d7fa8dbd084f79299c977c5d7f182884242ce4" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, access to the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; is serialized if and only if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is enabled. If &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled then the methods in &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; must take care of their own serialization needs.</source>
          <target state="translated">在多线程应用程序中，只有在启用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS的&lt;/a&gt;情况下，对&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods的&lt;/a&gt;访问才被序列化。如果禁用了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS，&lt;/a&gt;则&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods中&lt;/a&gt;的方法必须照顾自己的序列化需求。</target>
        </trans-unit>
        <trans-unit id="f07ff4f6d979804b51470d547e3016d910de27f0" translate="yes" xml:space="preserve">
          <source>In a multithreaded environment, SQLite uses mutexes to serialize access to shared resources. The mutex subsystem is only required for applications that access SQLite from multiple threads. For single-threaded applications, or applications which only call SQLite from a single thread, the mutex subsystem can be completely disabled by recompiling with the following option:</source>
          <target state="translated">在多线程环境中,SQLite使用mutexes来序列化对共享资源的访问。只有从多个线程访问SQLite的应用程序才需要使用mutex子系统。对于单线程应用程序,或者只从单线程调用SQLite的应用程序,可以通过使用以下选项重新编译来完全禁用mutex子系统。</target>
        </trans-unit>
        <trans-unit id="4d4533ee698cc81c52715976a896f4db12f7a8cf" translate="yes" xml:space="preserve">
          <source>In a normal index, there is a one-to-one mapping between rows in a table and entries in each index associated with that table. However, in a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, the index b-tree only contains entries corresponding to table rows for which the WHERE clause expression on the CREATE INDEX statement is true. Corresponding rows in the index and table b-trees share the same rowid or primary key values and contain the same value for all indexed columns.</source>
          <target state="translated">在普通索引中，表中的行与与该表关联的每个索引中的条目之间存在一对一的映射。但是，在&lt;a href=&quot;partialindex&quot;&gt;部分索引中&lt;/a&gt;，索引b树仅包含与CREATE INDEX语句上的WHERE子句表达式为true的表行相对应的条目。索引树b和表b树中的相应行共享相同的rowid或主键值，并且对于所有索引列都包含相同的值。</target>
        </trans-unit>
        <trans-unit id="ce9e9da4042a8b1a6fff277efdbca241b2bb44b8" translate="yes" xml:space="preserve">
          <source>In a prefix search, the matchlen is the number of characters in the string that match against the prefix. For a non-prefix search, this is the same as length(word).</source>
          <target state="translated">在前缀搜索中,matchlen是字符串中与前缀匹配的字符数。对于非前缀搜索,这与 length(word)相同。</target>
        </trans-unit>
        <trans-unit id="540eb7e11b15dfedf16222538153a627d93ae118" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat3 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if the entry with left-most column S1 is earlier in the index b-tree than the entry with left-most column S2, then in the sqlite_stat3 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">在一个完善的 sqlite_stat3 表中,任何一个索引的样本必须按照它们在索引中出现的顺序出现。换句话说,如果在索引b树中,最左列S1的条目比最左列S2的条目要早,那么在sqlite_stat3表中,样本S1的rowid必须比样本S2小。</target>
        </trans-unit>
        <trans-unit id="471a1674cd89ff60cc26aaa2e09dcb5715c114d4" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat4 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if entry S1 is earlier in the index b-tree than entry S2, then in the sqlite_stat4 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">在一个完善的sqlite_stat4表中,任何一个单一索引的样本必须按照它们在索引中出现的顺序出现。换句话说,如果条目S1在索引b树中比条目S2更早,那么在sqlite_stat4表中,样本S1的rowid必须比样本S2小。</target>
        </trans-unit>
        <trans-unit id="211f3f65b2d350ffdf823361c3c94beeb6b3685e" translate="yes" xml:space="preserve">
          <source>In addition to &quot;supporting&quot; SQLite through the year 2050, the developers also promise to keep the SQLite &lt;a href=&quot;cintro&quot;&gt;C-language API&lt;/a&gt; and &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt; fully backwards compatible. This means that application written to use SQLite today should be able to link against and use future versions of SQLite released decades in the future.</source>
          <target state="translated">除了在2050年之前&amp;ldquo;支持&amp;rdquo; SQLite，开发人员还承诺保持SQLite &lt;a href=&quot;cintro&quot;&gt;C语言API&lt;/a&gt;和&lt;a href=&quot;fileformat2&quot;&gt;磁盘格式&lt;/a&gt;完全向后兼容。这意味着今天编写的使用SQLite的应用程序应该能够链接并使用几十年后发布的SQLite的将来版本。</target>
        </trans-unit>
        <trans-unit id="2d62e10830dbc04e04eb1ce98ea4d36c1849dd6d" translate="yes" xml:space="preserve">
          <source>In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex method about the ORDER BY clause. (In an aggregate query, the SQLite core might put in GROUP BY clause information in place of the ORDER BY clause information, but this fact should not make any difference to the xBestIndex method.) If all terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify the column for each term in the order by clause and whether or not that column is ASC or DESC.</source>
          <target state="translated">除了WHERE子句约束外,SQLite核心还告诉xBestIndex方法有关ORDER BY子句的信息。(在集合查询中,SQLite核心可能会放入GROUP BY子句信息来代替ORDER BY子句信息,但这个事实应该不会对xBestIndex方法产生任何影响)。如果ORDER BY子句的所有条款都是虚拟表中的列,那么nOrderBy将是ORDER BY子句中的条款数,aOrderBy[]数组将标识每个条款在order by子句中的列,以及该列是ASC还是DESC。</target>
        </trans-unit>
        <trans-unit id="ae32760f149e6ccbf9d662c3e5f266d79f8381ea" translate="yes" xml:space="preserve">
          <source>In addition to being a result code, the SQLITE_ABORT value is also used as a &lt;a href=&quot;c3ref/c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">除了作为结果代码之外，SQLITE_ABORT值还用作从&lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;接口返回的&lt;a href=&quot;c3ref/c_fail&quot;&gt;冲突解决模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bf173fd8743d9addd4d23da77cbd1023dcac612" translate="yes" xml:space="preserve">
          <source>In addition to locking this byte, a connection running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; also gets an exclusive lock on all other WAL locks except for WAL_READ_LOCK(0).</source>
          <target state="translated">除了锁定该​​字节外，运行连接&lt;a href=&quot;walformat#recovery&quot;&gt;恢复&lt;/a&gt;的连接还将获得除WAL_READ_LOCK（0）以外的所有其他WAL锁的排他锁。</target>
        </trans-unit>
        <trans-unit id="cb3414acfc85a9001c1b555d3204dd8c38c36eeb" translate="yes" xml:space="preserve">
          <source>In addition to making SQLite easier to incorporate into other projects, the amalgamation also makes it run faster. Many compilers are able to do additional optimizations on code when it is contained with in a single translation unit such as it is in the amalgamation. We have measured performance improvements of between 5 and 10% when we use the amalgamation to compile SQLite rather than individual source files. The downside of this is that the additional optimizations often take the form of function inlining which tends to make the size of the resulting binary image larger.</source>
          <target state="translated">除了让SQLite更容易融入其他项目之外,合并也让它运行得更快。当代码被包含在一个单一的翻译单元中时,许多编译器能够对代码进行额外的优化,例如amalgamation中的代码。我们已经测量到,当我们使用amalgamation编译SQLite而不是单个源文件时,性能提高了5到10%。这样做的缺点是,额外的优化通常采取函数内联的形式,这往往会使生成的二进制图像的大小变大。</target>
        </trans-unit>
        <trans-unit id="dc82fe62c10524b3d4ccdfbeed7cfd03442b0fdf" translate="yes" xml:space="preserve">
          <source>In addition to providing built-in &quot;simple&quot;, &quot;porter&quot; and (possibly) &quot;icu&quot; and &quot;unicode61&quot; tokenizers, FTS provides an interface for applications to implement and register custom tokenizers written in C. The interface used to create a new tokenizer is defined and described in the fts3_tokenizer.h source file.</source>
          <target state="translated">除了提供内置的 &quot;simple&quot;、&quot;porter &quot;和(可能是)&quot;icu &quot;和 &quot;unicode61 &quot;tokenizer之外,FTS还提供了一个接口,供应用程序实现和注册用C语言编写的自定义tokenizer。用于创建新tokenizer的接口在fts3_tokenizer.h源文件中进行了定义和描述。</target>
        </trans-unit>
        <trans-unit id="96c71370cd3f6550d6c5dcd90baa2ddaf820ea27" translate="yes" xml:space="preserve">
          <source>In addition to reading and writing SQLite database files, the &lt;b&gt;sqlite3&lt;/b&gt; program will also read and write ZIP archives. Simply specify a ZIP archive filename in place of an SQLite database filename on the initial command line, or in the &quot;.open&quot; command, and &lt;b&gt;sqlite3&lt;/b&gt; will automatically detect that the file is a ZIP archive instead of an SQLite database and will open it as such. This works regardless of file suffix. So you can open JAR, DOCX, and ODP files and any other file format that is really a ZIP archive and SQLite will read it for you.</source>
          <target state="translated">除了读写SQLite数据库文件外，&lt;b&gt;sqlite3&lt;/b&gt;程序还将读写ZIP归档文件。只需在初始命令行或&amp;ldquo; .open&amp;rdquo;命令中指定一个ZIP存档文件名来代替SQLite数据库文件名，&lt;b&gt;sqlite3&lt;/b&gt;将自动检测该文件是ZIP存档而不是SQLite数据库，并将其打开为这样的。无论文件后缀如何，此方法均有效。因此，您可以打开JAR，DOCX和ODP文件以及任何其他真正为ZIP存档的文件格式，SQLite会为您读取它。</target>
        </trans-unit>
        <trans-unit id="73759a104c50187a5dc43c3f84c36657f75e9027" translate="yes" xml:space="preserve">
          <source>In addition to the four main test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">除了四个主要的测试线束外,还有其他几个小程序可以实现专门的测试。</target>
        </trans-unit>
        <trans-unit id="7ffa68d498101dd69c9fe08bfcd580625d879a08" translate="yes" xml:space="preserve">
          <source>In addition to the incompatible changes listed above, SQLite version 3.6.0 adds the following backwards compatible changes and enhancements:</source>
          <target state="translated">除了上面列出的不兼容变化外,SQLite 3.6.0版本还增加了以下向后兼容的变化和增强功能。</target>
        </trans-unit>
        <trans-unit id="8f29eabb94163c908fdf9ce75645a4e743012d26" translate="yes" xml:space="preserve">
          <source>In addition to the official repositories, the developers typically keep complete clones of all software on their personal machines. And there are uncountable clones scattered about the internet.</source>
          <target state="translated">除了官方的软件库,开发者一般会在个人机器上保存所有软件的完整克隆。而互联网上散落着难以计数的克隆软件。</target>
        </trans-unit>
        <trans-unit id="7d07efab2f131a863a93f94a25375b6ef4bc7a4a" translate="yes" xml:space="preserve">
          <source>In addition to the primary vdbe.c source code file, there are other helper code files in the source tree, all of whose names begin with &quot;vdbe&quot; - short for &quot;Virtual DataBase Engine&quot;.</source>
          <target state="translated">除了主要的vdbe.c源码文件,在源码树中还有其他的帮助代码文件,它们的名字都是以 &quot;vdbe &quot;开头的--&quot;Virtual DataBase Engine &quot;的缩写。</target>
        </trans-unit>
        <trans-unit id="e225e51508417bb108b16321c68b3adb1795c7b9" translate="yes" xml:space="preserve">
          <source>In addition to the required flags, the following optional flags are also supported:</source>
          <target state="translated">除了必要的标志外,还支持以下可选标志。</target>
        </trans-unit>
        <trans-unit id="77b9657ef03e307e851c2e7bae3bdd3ad8613131" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_master table may contain zero or more entries for</source>
          <target state="translated">除了应用程序和/或开发人员使用CREATE语句SQL创建的表、索引、视图和触发器之外,sqlite_master表还可能包含零个或多个条目,用于以下情况</target>
        </trans-unit>
        <trans-unit id="52a812fb18ec964152fad4865c6ca9189ffdf18b" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_schema table may contain zero or more entries for</source>
          <target state="translated">除了应用程序和/或开发人员使用CREATE语句SQL创建的表、索引、视图和触发器之外,sqlite_schema表还可以包含0个或更多的条目,这些条目用于</target>
        </trans-unit>
        <trans-unit id="a409c2d7a3384bc3f57eb2c0537e46f7868645bd" translate="yes" xml:space="preserve">
          <source>In addition to the three major test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">除了三大测试线束外,还有其他几个小程序实现专门的测试。</target>
        </trans-unit>
        <trans-unit id="0718e6fdf0cd1e299f6d920f46595f0908dd4b09" translate="yes" xml:space="preserve">
          <source>In addition, there are some defined constants:</source>
          <target state="translated">此外,还有一些确定的常数。</target>
        </trans-unit>
        <trans-unit id="db8b6c04e401904429f7905ea6f3cbc5116fbe03" translate="yes" xml:space="preserve">
          <source>In all cases, if if any discrepancies are found, the command fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="translated">在所有情况下，如果发现任何差异，该命令都会失败，并显示&lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="fbb8e299adb3ff32a155642d73390e9d9fa9566c" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="translated">在上述所有情况下，如果F不是从SQLite核心传递到VFS的数据库，日志或WAL文件名，并且F不是&lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;的返回值，则结果是不确定的，可能是内存访问冲突。</target>
        </trans-unit>
        <trans-unit id="0a6f4780ac68779fff537a2221e3188df1c6d53f" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="translated">在上述所有情况下，如果F不是从SQLite核心传递到VFS的数据库，日志或WAL文件名，并且F不是&lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;的返回值，则结果是不确定的，可能是内存访问冲突。</target>
        </trans-unit>
        <trans-unit id="650bcf7f3c9667b8bca2e9d81188fd4ca62bdf99" translate="yes" xml:space="preserve">
          <source>In all of the full-text queries above, the right-hand operand of the MATCH operator is a string consisting of a single term. In this case, the MATCH expression evaluates to true for all documents that contain one or more instances of the specified word (&quot;sqlite&quot;, &quot;search&quot; or &quot;database&quot;, depending on which example you look at). Specifying a single term as the right-hand operand of the MATCH operator results in the simplest and most common type of full-text query possible. However more complicated queries are possible, including phrase searches, term-prefix searches and searches for documents containing combinations of terms occurring within a defined proximity of each other. The various ways in which the full-text index may be queried are &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">在上面所有的全文查询中，MATCH运算符的右侧操作数是由单个术语组成的字符串。在这种情况下，对于包含一个或多个指定单词实例（&amp;ldquo; sqlite&amp;rdquo;，&amp;ldquo; search&amp;rdquo;或&amp;ldquo; database&amp;rdquo;，取决于您查看的示例）的所有文档，MATCH表达式的计算结果均为true。指定单个术语作为MATCH运算符的右侧操作数会导致最简单和最常见的全文查询类型。但是，更复杂的查询是可能的，包括短语搜索，术语前缀搜索以及对包含在彼此定义的邻近范围内出现的术语组合的文档的搜索。&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;下面描述&lt;/a&gt;查询全文索引的各种方式。</target>
        </trans-unit>
        <trans-unit id="fec3ea71809f1fd12bdd320ecfb2400479f6f909" translate="yes" xml:space="preserve">
          <source>In all of the write tests, it is important to disable anti-virus software prior to running the direct-to-disk performance tests. We found that anti-virus software slows down direct-to-disk by an order of magnitude whereas it impacts SQLite writes very little. This is probably due to the fact that direct-to-disk changes thousands of separate files which all need to be checked by anti-virus, whereas SQLite writes only changes the single database file.</source>
          <target state="translated">在所有的写入测试中,在运行直接到磁盘的性能测试之前,禁用防病毒软件是很重要的。我们发现,防病毒软件会使直接到磁盘的速度降低一个数量级,而它对SQLite写入的影响却很小。这可能是由于direct-to-disk会改变成千上万个独立的文件,这些文件都需要防病毒软件检查,而SQLite写入只改变单个数据库文件。</target>
        </trans-unit>
        <trans-unit id="19fd1c2e26ad6ba4190cb1ba85655e3d415fb1a9" translate="yes" xml:space="preserve">
          <source>In all other cases this function returns SQLITE_MISUSE.</source>
          <target state="translated">在所有其他情况下,该函数返回SQLITE_MISUSE。</target>
        </trans-unit>
        <trans-unit id="a9b1d686d80c16cbd892850ec817e33e118fdb64" translate="yes" xml:space="preserve">
          <source>In all the examples above, there has only been a single SELECT statement. If a query contains sub-selects, those are shown as being children of the outer SELECT. For example:</source>
          <target state="translated">在上面所有的例子中,只有一条SELECT语句。如果一个查询包含子选择,那么这些子选择就会被显示为外层SELECT的子选择。例如:</target>
        </trans-unit>
        <trans-unit id="c9c18ce865540a24f1f5ee5d4ef74324465c3e44" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement, a list of column names can be set to a row value of the same size.</source>
          <target state="translated">在&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句中，可以将列名列表设置为相同大小的行值。</target>
        </trans-unit>
        <trans-unit id="34ecd17e630ff3ecf740af54bcb0cb9af6e271db" translate="yes" xml:space="preserve">
          <source>In an expression used as part of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;.</source>
          <target state="translated">在用作&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;一部分的表达式中。</target>
        </trans-unit>
        <trans-unit id="68e31982331dd4f44aeeef7efedd25a5db6a0a14" translate="yes" xml:space="preserve">
          <source>In an index on a WITHOUT ROWID table, if a column of the PRIMARY KEY is also a column in the index and has a matching collating sequence, then the indexed column is not repeated in the table-key suffix on the end of the index record. As an example, consider the following SQL:</source>
          <target state="translated">在WITHOUT ROWID表的索引中,如果PRIMARY KEY的某一列也是索引中的一列,并且有匹配的整理序列,那么索引记录末尾的表-键后缀就不会重复。作为一个例子,考虑以下SQL。</target>
        </trans-unit>
        <trans-unit id="b98eca53cbed3b51f01e882fbf03443737203ad3" translate="yes" xml:space="preserve">
          <source>In an interior b-tree page, the pointers and keys logically alternate with a pointer on both ends. (The previous sentence is to be understood conceptually - the actual layout of the keys and pointers within the page is more complicated and will be described in the sequel.) All keys within the same page are unique and are logically organized in ascending order from left to right. (Again, this ordering is logical, not physical. The actual location of keys within the page is arbitrary.) For any key X, pointers to the left of a X refer to b-tree pages on which all keys are less than or equal to X. Pointers to the right of X refer to pages where all keys are greater than X.</source>
          <target state="translated">在一个内部b树页面中,指针和键在逻辑上是交替排列的,两端都有一个指针。前面的句子要从概念上理解--页面内键和指针的实际布局比较复杂,将在后文中描述)。同一页面内的所有键都是唯一的,并且在逻辑上是按照从左到右的升序组织的。(同样,这种排序是逻辑上的,而不是物理上的。键在页面中的实际位置是任意的。)对于任何键X,指向X左边的指针指的是所有键小于或等于X的b树页面,指向X右边的指针指的是所有键大于X的页面。</target>
        </trans-unit>
        <trans-unit id="39488c0191328e370ea86a4f1833476c2e9dc423" translate="yes" xml:space="preserve">
          <source>In an ordinary SQLite table, the PRIMARY KEY is really just a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; index. The key used to look up records on disk is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. The special &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; column type in ordinary SQLite tables causes the column to be an alias for the rowid, and so an INTEGER PRIMARY KEY is a true PRIMARY KEY. But any other kind of PRIMARY KEYs, including &quot;INT PRIMARY KEY&quot; are just unique indexes in an ordinary rowid table.</source>
          <target state="translated">在普通的SQLite表中，PRIMARY KEY实际上只是一个&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;索引。用于查找磁盘上记录的键是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。普通SQLite表中特殊的&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &amp;rdquo;列类型使该列成为rowid的别名，因此INTEGER PRIMARY KEY是真实的PRIMARY KEY。但是任何其他类型的PRIMARY KEY（包括&amp;ldquo; INT PRIMARY KEY&amp;rdquo;）都只是普通rowid表中的唯一索引。</target>
        </trans-unit>
        <trans-unit id="2602231eda03cd82b0bfe3849f20e2339713b36f" translate="yes" xml:space="preserve">
          <source>In any aggregate function that takes a single argument, that argument can be preceded by the keyword DISTINCT. In such cases, duplicate elements are filtered before being passed into the aggregate function. For example, the function &quot;count(distinct X)&quot; will return the number of distinct values of column X instead of the total number of non-null values in column X.</source>
          <target state="translated">在任何接受单一参数的聚合函数中,该参数前面可以加上关键字DISTINCT。在这种情况下,重复的元素在被传递到聚合函数之前会被过滤掉。例如,函数 &quot;count(distinct X)&quot;将返回列X的独特值的数量,而不是列X中非空值的总数。</target>
        </trans-unit>
        <trans-unit id="15eb51d3758bed15da54f5c0830882a735d49cb2" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_master table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_master table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">在任何包含ptrmap页的数据库文件中,所有b树根页必须排在任何非根b树页、单元格有效载荷溢出页或自由列表页之前。这个限制保证了在自动抽真空或增量抽真空的过程中,根页面永远不会被移动。自动清空逻辑不知道如何更新sqlite_master表的root_page字段,因此为了保持sqlite_master表的完整性,必须防止在自动清空期间移动根页面。通过CREATE TABLE、CREATE INDEX、DROP TABLE、DROP INDEX等操作,将根页移动到数据库文件的开头。</target>
        </trans-unit>
        <trans-unit id="d9bc87111dc7feda77c011e8d21c00fc7e80e539" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_schema table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_schema table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">在任何包含ptrmap页的数据库文件中,所有b树根页必须排在任何非根b树页、单元格有效载荷溢出页或自由列表页之前。这个限制保证了在自动抽真空或增量抽真空的过程中,根页面永远不会被移动。自动清空逻辑不知道如何更新sqlite_schema表的root_page字段,因此为了保持sqlite_schema表的完整性,必须防止在自动清空期间移动根页面。通过CREATE TABLE、CREATE INDEX、DROP TABLE、DROP INDEX等操作,将根页移到数据库文件的开头。</target>
        </trans-unit>
        <trans-unit id="016fc239bf2f87e674a823e588afff2d09643b5a" translate="yes" xml:space="preserve">
          <source>In automatic EXPLAIN QUERY PLAN mode, the shell automatically runs a separate EXPLAIN QUERY PLAN query for each statement you enter and displays the result before actually running the query. Use the &quot;.eqp off&quot; command to turn automatic EXPLAIN QUERY PLAN mode back off.</source>
          <target state="translated">在自动 EXPLAIN QUERY PLAN 模式下,shell 会为您输入的每一条语句自动运行一个单独的 EXPLAIN QUERY PLAN 查询,并在实际运行查询之前显示结果。使用&quot;.eqp off &quot;命令来关闭自动EXPLAIN查询计划模式。</target>
        </trans-unit>
        <trans-unit id="a0296b5facf2017142e185ec710adebd650dd374" translate="yes" xml:space="preserve">
          <source>In batch-mode operation, where an FTS table is initially built up using a large number of INSERT operations, then queried repeatedly without further changes, it is often a good idea to run &quot;optimize&quot; after the last INSERT and before the first query.</source>
          <target state="translated">在批处理模式的操作中,一个FTS表最初是通过大量的INSERT操作建立起来的,然后在没有进一步修改的情况下反复查询,在最后一次INSERT之后、第一次查询之前运行 &quot;优化 &quot;通常是一个好主意。</target>
        </trans-unit>
        <trans-unit id="0f704787571a999cc9c3b84bb71144a5bcf64e37" translate="yes" xml:space="preserve">
          <source>In both cases, the split amalgamation can be obtained by substituting &quot;sqlite3-all.c&quot; for &quot;sqlite3.c&quot; as the make target.</source>
          <target state="translated">在这两种情况下,将 &quot;sqlite3-all.c &quot;替换为 &quot;sqlite3.c &quot;作为make目标,就可以得到拆分合并。</target>
        </trans-unit>
        <trans-unit id="fc2950d0c83c287a896b8aadaea3a0c15a77bfa3" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">简而言之，sqlite3_wal_checkpoint（D，X）导致&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的数据库 X的&lt;a href=&quot;../wal&quot;&gt;预写日志中&lt;/a&gt;的内容被传输到数据库文件中，并且预写日志被重置。有关更多信息，请参见&lt;a href=&quot;../wal#ckpt&quot;&gt;检查点&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="05e7a053b7377f3e594b4b5661cacef3a8037473" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">简而言之，sqlite3_wal_checkpoint（D，X）导致&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的数据库 X的&lt;a href=&quot;wal&quot;&gt;预写日志中&lt;/a&gt;的内容被传输到数据库文件中，并且预写日志被重置。有关更多信息，请参见&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="9c00ece9c1ea98470c62a3e9e8dcd9514aa371cf" translate="yes" xml:space="preserve">
          <source>In brief, the CPU performance of SQLite is measured as follows:</source>
          <target state="translated">简单来说,SQLite的CPU性能测评如下。</target>
        </trans-unit>
        <trans-unit id="9e64879e9d401b77adebcff06d6d47d07d757ab4" translate="yes" xml:space="preserve">
          <source>In cases where it is complicated, the complications in applying a changeset lie in conflict resolution. Refer to the API documentation linked above for details.</source>
          <target state="translated">在复杂的情况下,应用变化集的复杂性在于解决冲突。详情请参考上面链接的API文档。</target>
        </trans-unit>
        <trans-unit id="0d808e9f43de5ebbcabce2337be4b9dd05f38065" translate="yes" xml:space="preserve">
          <source>In cases where two or more phrase instances overlap (share one or more tokens in common), a single open and close marker is inserted for each set of overlapping phrases. For example:</source>
          <target state="translated">在两个或多个短语实例重叠的情况下(有一个或多个共同的标记),为每一组重叠的短语插入一个开闭标记。例如:</target>
        </trans-unit>
        <trans-unit id="c541beea5651ea9308221a19ef6bad8134493156" translate="yes" xml:space="preserve">
          <source>In column mode, each record is shown on a separate line with the data aligned in columns. For example:</source>
          <target state="translated">在列模式下,每条记录都显示在单独的一行上,数据按列排列。例如:</target>
        </trans-unit>
        <trans-unit id="27dcedbb38ae9d16b71fde759bf65bb67ce0f587" translate="yes" xml:space="preserve">
          <source>In common use, SQLite databases tend to range in size from a few kilobytes to a few gigabytes, though terabyte-size SQLite databases are known to exist in production.</source>
          <target state="translated">在通常的使用中,SQLite数据库的大小往往从几千字节到几千兆字节不等,尽管已知生产中存在TB大小的SQLite数据库。</target>
        </trans-unit>
        <trans-unit id="15ec9746d32bfb65e8d0e42717374e59fcc87690" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil is a single standalone binary which is installed by putting it on $PATH. That one binary contains all the functionality of core Git and also GitHub and/or GitLab. It manages a community server with wiki, bug tracking, and forums, provides packaged downloads for consumers, login managements, and so forth, with no extra software required.</source>
          <target state="translated">相比之下,Fossil 是一个独立的二进制文件,只要把它放在 $PATH 上就可以安装。这一个二进制文件包含了核心 Git 的所有功能,也包含了 GitHub 和/或 GitLab。它管理着一个包含 wiki、bug 跟踪和论坛的社区服务器,为消费者提供打包下载、登录管理等等,不需要额外的软件。</target>
        </trans-unit>
        <trans-unit id="b26360f9266d08eeb61923fd0c3bf7dd26b34599" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil offers displays such as &lt;a href=&quot;https://sqlite.org/src/timeline?df=release&quot;&gt;https://sqlite.org/src/timeline?df=release&lt;/a&gt; to show all check-ins that are derived from the most recent release.</source>
          <target state="translated">相反，Fossil提供了诸如&lt;a href=&quot;https://sqlite.org/src/timeline?df=release&quot;&gt;https://sqlite.org/src/timeline?df=release之类的&lt;/a&gt;显示，以显示从最新版本派生的所有签入。</target>
        </trans-unit>
        <trans-unit id="a51fb2bb312c4e04f9b038dff963c7e47c882987" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil users only need to think about their working directory and the check-in they are working on. That is 60% less distraction. Every developer has a finite number of brain-cycles. Fossil requires fewer brain-cycles to operate, thus freeing up intellectual resources to focus on the software under development.</source>
          <target state="translated">相比之下,Fossil用户只需要考虑自己的工作目录和正在进行的签到。这就减少了60%的分心。每个开发者的脑力循环是有限的。Fossil需要更少的脑循环来操作,从而释放出智力资源,专注于开发中的软件。</target>
        </trans-unit>
        <trans-unit id="0fcdb16d38afda3fa9a7a2e8625220ffc33d6191" translate="yes" xml:space="preserve">
          <source>In either case, if performance problems do arise in an SQLite application those problems can often be resolved by adding one or two &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements to the schema or perhaps running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; one time and without having to touch a single line of application code. But if a performance problem comes up in a custom or pile-of-files format, the fix will often require extensive changes to application code to add and maintain new indices or to extract information using different algorithms.</source>
          <target state="translated">无论哪种情况，如果在SQLite应用程序中确实出现性能问题，通常可以通过向架构中添加一个或两个&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句或运行一次&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;而无需触摸任何一行应用程序代码来解决这些问题。但是，如果以自定义或文件堆格式出现性能问题，则此修复程序通常需要对应用程序代码进行大量更改，以添加和维护新索引或使用不同算法提取信息。</target>
        </trans-unit>
        <trans-unit id="25aa68ecfd2b0c4f0ec2db607f906e4651bce4ef" translate="yes" xml:space="preserve">
          <source>In every case, the pager cache size was adjusted to keep the amount of cache memory at about 2MB. For example, a 2000 page cache was used for 1024 byte pages and a 31 page cache was used for 65536 byte pages. The BLOB values were read in a random order.</source>
          <target state="translated">在每一种情况下,都对寻呼机缓存大小进行了调整,使缓存内存量保持在2MB左右。例如,2000页的缓存用于1024字节的页面,31页的缓存用于65536字节的页面。BLOB值的读取顺序是随机的。</target>
        </trans-unit>
        <trans-unit id="cf40b39d63a8fb0ce771e83c7921ec57173f92f8" translate="yes" xml:space="preserve">
          <source>In extreme cases, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors, rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">在极端情况下，请考虑使用&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;选项编译SQLite，然后通过&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;）接口为SQLite提供固定的内存块以用作其堆。这将防止恶意SQL通过使用过多的内存来执行拒绝服务攻击。如果（例如）提供了5 MB的内存供SQLite使用，那么一旦消耗了这么多内存，SQLite将开始返回SQLITE_NOMEM错误，而不是占用应用程序其他部分所需的内存。这也将SQLite的内存沙箱化，以使应用程序其他部分的写后写错误不会对SQLite造成问题，反之亦然。</target>
        </trans-unit>
        <trans-unit id="b60127a70276716ca6ce96b164af1caff22c34ff" translate="yes" xml:space="preserve">
          <source>In fairness to PostgreSQL, it started thrashing on this test. A knowledgeable administrator might be able to get PostgreSQL to run a lot faster here by tweaking and tuning the server a little.</source>
          <target state="translated">为了公平起见,PostgreSQL在这次测试中开始暴走。一个知识渊博的管理员也许可以通过调整一下服务器,让PostgreSQL运行得更快。</target>
        </trans-unit>
        <trans-unit id="776b2a0854afad2e6c812aae004c09f148d516c9" translate="yes" xml:space="preserve">
          <source>In fairness, having a built-in implementation of printf() also comes with some disadvantages. To wit:</source>
          <target state="translated">平心而论,内置printf()的实现也有一些缺点。大意是:</target>
        </trans-unit>
        <trans-unit id="c2fda1dfe98bf18ac7aa5572676942f62e5e1fe2" translate="yes" xml:space="preserve">
          <source>In first form, if the main database has already been created, then this pragma returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le' (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If the main database has not already been created, then the value returned is the text encoding that will be used to create the main database, if it is created by this session.</source>
          <target state="translated">在第一种形式中,如果主数据库已经创建,那么这个pragma将返回主数据库使用的文本编码,即 &quot;UTF-8&quot;、&quot;UTF-16le&quot;(little-endian UTF-16编码)或 &quot;UTF-16be&quot;(big-endian UTF-16编码)中的一种。如果主数据库还没有被创建,那么返回的值是将用于创建主数据库的文本编码,如果主数据库是由这个会话创建的话。</target>
        </trans-unit>
        <trans-unit id="b4265b09e5ee96a8a7b2a30c889a0bcc8a3fb773" translate="yes" xml:space="preserve">
          <source>In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number.</source>
          <target state="translated">在格式 4、7 和 10 中,小数秒值 SS.SSS 可以在小数点后有一个或多个数字。在例子中显示的是三位数字,因为只有前三位数字对结果很重要,但输入字符串可以有更少或更多的三位数字,日期/时间函数仍将正确运行。同样,格式12显示的是10位有意义的数字,但日期/时间函数将真正接受表示Julian日数所需的任何数字或少数数字。</target>
        </trans-unit>
        <trans-unit id="af29b68f8112f5b3ba3c7546feb616bd5c5cfef7" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as a floating point value.</source>
          <target state="translated">按照&lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601的&lt;/a&gt;要求，在格式5到7中，&amp;ldquo; T&amp;rdquo;是分隔日期和时间的文字字符。仅指定时间的格式8到10假定日期为2000-01-01。格式11（字符串&amp;ldquo; now&amp;rdquo;）将转换为当前日期和时间，该日期和时间是从所使用的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xCurrentTime方法获得的。日期和时间函数的'now'参数对于同一&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中的多次调用始终返回完全相同的值。&lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;使用世界标准时间（UTC）&lt;/a&gt;。格式12是&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;儒略日数字，&lt;/a&gt;表示为浮点值。</target>
        </trans-unit>
        <trans-unit id="6d5b683fb78e2961a927a0de31b24ecad02f2548" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;https://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as an integer or floating point value.</source>
          <target state="translated">按照&lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601的&lt;/a&gt;要求，在格式5到7中，&amp;ldquo; T&amp;rdquo;是分隔日期和时间的文字字符。仅指定时间的格式8到10假定日期为2000-01-01。格式11（字符串&amp;ldquo; now&amp;rdquo;）将转换为当前日期和时间，该日期和时间是从所使用的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xCurrentTime方法获得的。日期和时间函数的'now'参数对于同一&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中的多次调用始终返回完全相同的值。&lt;a href=&quot;https://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;使用世界标准时间（UTC）&lt;/a&gt;。格式12是&lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;儒略日数字，&lt;/a&gt;表示为整数或浮点值。</target>
        </trans-unit>
        <trans-unit id="f289b58633d51c42244b9615eefef812e48059b3" translate="yes" xml:space="preserve">
          <source>In general, you can do anything with a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that can be done with an ordinary table, except that you cannot create indices or triggers on a virtual table. Some virtual table implementations might impose additional restrictions. For example, many virtual tables are read-only.</source>
          <target state="translated">通常，除了不能在虚拟表上创建索引或触发器之外，您可以使用&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;执行任何操作，而该操作可以使用普通表完成。某些虚拟表实现可能会施加其他限制。例如，许多虚拟表是只读的。</target>
        </trans-unit>
        <trans-unit id="eeca88e5ce04c05464f766d95ff0eeb5cfc7eabb" translate="yes" xml:space="preserve">
          <source>In hindsight, we should not have tried to make SQLite accept MySQL 3.x syntax, and should have never allowed double-quoted string literals. However, there are countless applications that make use of double-quoted string literals and so we continue to support that capability to avoid breaking legacy.</source>
          <target state="translated">事后看来,我们不应该试图让SQLite接受MySQL 3.x语法,也不应该允许双引号字符串字面。然而,有无数的应用程序使用双引号字符串字面,因此我们继续支持这种能力,以避免打破传统。</target>
        </trans-unit>
        <trans-unit id="5bb614f9a4728b882cfa854761e8ce05293a6c53" translate="yes" xml:space="preserve">
          <source>In in TRIGGERSs.</source>
          <target state="translated">在TRIGGERSs中。</target>
        </trans-unit>
        <trans-unit id="dc71bff31ad5848828d3dd9115d5b5dfb6294eb3" translate="yes" xml:space="preserve">
          <source>In in VIEWs.</source>
          <target state="translated">在views中。</target>
        </trans-unit>
        <trans-unit id="b8391805f21124b7f78b7878689397e781e990db" translate="yes" xml:space="preserve">
          <source>In interactive mode, sqlite3 reads input text (either SQL statements or &lt;a href=&quot;cli#dotcmd&quot;&gt;dot-commands&lt;/a&gt;) from the keyboard. You can also redirect input from a file when you launch sqlite3, of course, but then you do not have the ability to interact with the program. Sometimes it is useful to run an SQL script contained in a file entering other commands from the command-line. For this, the &quot;.read&quot; dot-command is provided.</source>
          <target state="translated">在交互模式下，sqlite3从键盘读取输入文本（SQL语句或&lt;a href=&quot;cli#dotcmd&quot;&gt;点命令&lt;/a&gt;）。当然，当您启动sqlite3时，也可以从文件重定向输入，但是这样您就无法与该程序进行交互。有时，运行包含在文件中的SQL脚本很有用，该脚本从命令行输入其他命令。为此，提供了&amp;ldquo; .read&amp;rdquo;点命令。</target>
        </trans-unit>
        <trans-unit id="f3caa4201cfb419be724f72954ef422185458de8" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">在默认配置下，SQLite API例程返回30个整数&lt;a href=&quot;../rescode&quot;&gt;结果代码之一&lt;/a&gt;。但是，经验表明，这些结果代码中的许多结果都过于粗糙。他们没有提供程序员可能想要的那样多的问题信息。为了解决这个问题，较新版本的SQLite（版本3.3.8 2006-10-09和更高版本）包括对其他结果代码的支持，这些结果代码提供有关错误的更详细信息。这些&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;使用&lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt; API 在每个数据库连接的基础上启用或禁用。或者，可以使用&lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;获得最新错误的扩展代码。</target>
        </trans-unit>
        <trans-unit id="3039a66b6632d9561c27b79f80cd7bfba4d1c329" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">在默认配置下，SQLite API例程返回30个整数&lt;a href=&quot;rescode&quot;&gt;结果代码之一&lt;/a&gt;。但是，经验表明，这些结果代码中的许多结果都过于粗糙。他们没有提供程序员可能想要的那样多的问题信息。为了解决这个问题，较新版本的SQLite（版本3.3.8 2006-10-09和更高版本）包括对其他结果代码的支持，这些结果代码提供有关错误的更详细信息。这些&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;使用&lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt; API 在每个数据库连接的基础上启用或禁用。或者，可以使用&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;获得最新错误的扩展代码。</target>
        </trans-unit>
        <trans-unit id="c851426635cb37e8f1ffc6284cb9e22ec511a9f4" translate="yes" xml:space="preserve">
          <source>In keeping with the pile-of-files theme, OpenDocument stores all slide content in a single big XML file named &quot;content.xml&quot;. LibreOffice reads and parses this entire file just to display the first slide. LibreOffice also seems to read all images into memory as well, which makes sense seeing as when the user does &quot;File/Save&quot; it is going to have to write them all back out again, even though none of them changed. The net effect is that start-up is slow. Double-clicking an OpenDocument file brings up a progress bar rather than the first slide. This results in a bad user experience. The situation grows ever more annoying as the document size increases.</source>
          <target state="translated">为了与文件堆主题保持一致,OpenDocument将所有幻灯片内容存储在一个名为 &quot;content.xml &quot;的大XML文件中。LibreOffice读取和解析这整个文件只是为了显示第一张幻灯片。LibreOffice似乎也会把所有的图片读到内存中,这是有道理的,因为当用户进行 &quot;文件/保存 &quot;时,它将不得不再次把它们全部写回来,即使它们都没有改变。最终的效果是启动速度很慢。双击一个OpenDocument文件会弹出一个进度条,而不是第一张幻灯片。这导致了糟糕的用户体验。随着文件大小的增加,这种情况越来越烦人。</target>
        </trans-unit>
        <trans-unit id="c55972e777545acb2431d05db4c4023b23be4d2b" translate="yes" xml:space="preserve">
          <source>In many cases, method (1) above is the best approach. It does not add extra data to the FTS index or require FTS5 to query for multiple terms, so it is efficient in terms of disk space and query speed. However, it does not support prefix queries very well. If, as suggested above, the token &quot;first&quot; is substituted for &quot;1st&quot; by the tokenizer, then the query:</source>
          <target state="translated">在很多情况下,上述方法(1)是最好的方法。它不会给FTS索引增加额外的数据,也不需要FTS5查询多个术语,所以在磁盘空间和查询速度上都很高效。但是,它不能很好地支持前缀查询。如果按照上面的建议,用tokenizer将 &quot;first &quot;替换成 &quot;1st&quot;,那么查询。</target>
        </trans-unit>
        <trans-unit id="5d477280cde1f0cb61a1a86eeb18153043aeb432" translate="yes" xml:space="preserve">
          <source>In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</source>
          <target state="translated">In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</target>
        </trans-unit>
        <trans-unit id="a92a8e52f2222eb943cf97b12f1b58ee960571a6" translate="yes" xml:space="preserve">
          <source>In most SQL implementations, output columns of an aggregate query may only reference aggregate functions or columns named in the GROUP BY clause. It does not make good sense to reference an ordinary column in an aggregate query because each output row might be composed from two or more rows in the input table(s).</source>
          <target state="translated">在大多数SQL实现中,聚合查询的输出列只能引用聚合函数或GROUP BY子句中命名的列。在聚合查询中引用一个普通的列是没有意义的,因为每条输出行可能是由输入表中的两条或多条记录组成的。</target>
        </trans-unit>
        <trans-unit id="ebf21aed9282198e08f544c4b59f1cde35658d89" translate="yes" xml:space="preserve">
          <source>In most applications, the database page cache subsystem within SQLite uses more dynamically allocated memory than all other parts of SQLite combined. It is not unusual to see the database page cache consume over 10 times more memory than the rest of SQLite combined.</source>
          <target state="translated">在大多数应用程序中,SQLite内的数据库页面缓存子系统使用的动态分配内存比SQLite的所有其他部分加起来还要多。数据库页面缓存所消耗的内存是SQLite其他部分加起来的10倍以上,这种情况并不少见。</target>
        </trans-unit>
        <trans-unit id="ea5d93a0bdef6b6a869ec9bc6ec20416d6dd4af5" translate="yes" xml:space="preserve">
          <source>In most applications, the number of columns is small - a few dozen. There are places in the SQLite code generator that use algorithms that are O(N&amp;sup2;) where N is the number of columns. So if you redefine SQLITE_MAX_COLUMN to be a really huge number and you generate SQL that uses a large number of columns, you may find that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; runs slowly.</source>
          <target state="translated">在大多数应用程序中，列数很少-几十列。SQLite代码生成器中的某些地方使用的算法是O（N&amp;sup2;），其中N是列数。因此，如果将SQLITE_MAX_COLUMN重新定义为一个非常大的数字，并且生成使用大量列的SQL，则可能会发现&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;运行缓慢。</target>
        </trans-unit>
        <trans-unit id="5715db4d1b11556e8f8726b68f211a79da84d8fd" translate="yes" xml:space="preserve">
          <source>In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating a unique index in the database. (The exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and PRIMARY KEYs on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) Hence, the following schemas are logically equivalent:</source>
          <target state="translated">在大多数情况下，通过在数据库中创建唯一索引来实现UNIQUE和PRIMARY KEY约束。（例外是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表上的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;和PRIMARY KEY 。）因此，以下模式在逻辑上是等效的：</target>
        </trans-unit>
        <trans-unit id="5a1cd73f371732c3b6f817956ff2682bb7f1000a" translate="yes" xml:space="preserve">
          <source>In most cases, you will want to supplement the basic commands above with &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; appropriate for your application. Commonly used compile-time options include:</source>
          <target state="translated">在大多数情况下，您将需要使用适合您的应用程序的&lt;a href=&quot;compile&quot;&gt;编译时选项&lt;/a&gt;来补充上述基本命令。常用的编译时选项包括：</target>
        </trans-unit>
        <trans-unit id="97ef5a309f4aafbcba4ef803b72a915f31e696d6" translate="yes" xml:space="preserve">
          <source>In most contexts, the special &quot;rowid&quot; column of normal tables can also be called &quot;oid&quot; or &quot;_rowid_&quot;. However, only &quot;rowid&quot; works as the keyword in the CREATE TABLE statement.</source>
          <target state="translated">在大多数情况下,普通表的特殊 &quot;rowid &quot;列也可以称为 &quot;oid &quot;或&quot;_rowid_&quot;。但是,只有 &quot;rowid &quot;可以作为CREATE TABLE语句中的关键字。</target>
        </trans-unit>
        <trans-unit id="08bdbf2096af9fe45fd4ac595bd3e0c7bb6e8da7" translate="yes" xml:space="preserve">
          <source>In most other SQL database engines the datatype is associated with the table column that holds the data - with the data container. In SQLite 3.0, the datatype is associated with the data itself, not with its container. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Paul Graham&lt;/a&gt; in his book</source>
          <target state="translated">在大多数其他SQL数据库引擎中，数据类型与保存数据的表列相关联-与数据容器相关联。在SQLite 3.0中，数据类型与数据本身关联，而不与容器关联。&lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;保罗&amp;middot;格雷厄姆&lt;/a&gt;（Paul Graham）在他的书中</target>
        </trans-unit>
        <trans-unit id="9b4441386a86e2d230e048847afd960634eadb47" translate="yes" xml:space="preserve">
          <source>In normal cases, new content is appended to the WAL file until the WAL file accumulates about 1000 pages (and is thus about 4MB in size) at which point a checkpoint is automatically run and the WAL file is recycled. The checkpoint does not normally truncate the WAL file (unless the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt; is set). Instead, it merely causes SQLite to start overwriting the WAL file from the beginning. This is done because it is normally faster to overwrite an existing file than to append. When the last connection to a database closes, that connection does one last checkpoint and then deletes the WAL and its associated shared-memory file, to clean up the disk.</source>
          <target state="translated">在正常情况下，新内容会附加到WAL文件中，直到WAL文件累积约1000页（因此大小约为4MB），此时自动运行检查点并回收WAL文件。检查点通常不会截断WAL文件（除非设置了&lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit杂注&lt;/a&gt;）。相反，它仅使SQLite从头开始覆盖WAL文件。这样做是因为覆盖现有文件通常比添加文件快。与数据库的最后一个连接关闭时，该连接将执行最后一个检查点，然后删除WAL及其关联的共享内存文件，以清理磁盘。</target>
        </trans-unit>
        <trans-unit id="9b10dbf3c620afa11c457409454feda884f8c775" translate="yes" xml:space="preserve">
          <source>In older versions of SQLite, shared cache mode could not be used together with virtual tables. This restriction was removed in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10).</source>
          <target state="translated">在旧版本的SQLite中，共享缓存模式不能与虚拟表一起使用。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;版本3.6.17&lt;/a&gt;（2009-08-10）中删除了此限制。</target>
        </trans-unit>
        <trans-unit id="c0ec8617fee4e8f946bad89174a49f940e3f428d" translate="yes" xml:space="preserve">
          <source>In one test that indexed a large set of emails (1636 MiB on disk), the FTS index was 743 MiB on disk with detail=full, 340 MiB with detail=column and 134 MiB with detail=none.</source>
          <target state="translated">在一项对一大组邮件进行索引的测试中(磁盘上有1636 MiB),FTS索引在磁盘上有743 MiB,detail=full,340 MiB,detail=column,134 MiB,detail=none。</target>
        </trans-unit>
        <trans-unit id="79708a29f43e4b6af877ac3750b35c58a6cfa4a6" translate="yes" xml:space="preserve">
          <source>In order for an application to &lt;a href=&quot;fts5#extending_fts5&quot;&gt;add new extensions to FTS5&lt;/a&gt;, such as new tokenizers, the application needs a pointer to the &quot;fts5_api&quot; object.</source>
          <target state="translated">为了使应用程序向&lt;a href=&quot;fts5#extending_fts5&quot;&gt;FTS5添加新的扩展名&lt;/a&gt;，例如新的标记器，该应用程序需要一个指向&amp;ldquo; fts5_api&amp;rdquo;对象的指针。</target>
        </trans-unit>
        <trans-unit id="28a836bfad6faf09ee027032e5467aeee1a64f66" translate="yes" xml:space="preserve">
          <source>In order for the OR-by-UNION technique shown above to be useful, there must be an index available that helps resolve every OR-connected term in the WHERE clause. If even a single OR-connected term is not indexed, then a full table scan would have to be done in order to find the rowids generated by the one term, and if SQLite has to do a full table scan, it might as well do it on the original table and get all of the results in a single pass without having to mess with union operations and follow-on binary searches.</source>
          <target state="translated">为了使上面显示的OR-by-UNION技术有用,必须有一个索引可以帮助解析WHERE子句中的每一个OR连接项。如果连一个OR连接项都没有索引,那么就必须进行全表扫描,才能找到这一个项产生的rowids,如果SQLite必须进行全表扫描,还不如在原表上进行扫描,一次就能得到所有的结果,而不用再去搞联合操作和后续的二元搜索。</target>
        </trans-unit>
        <trans-unit id="eb3713c378b1d1ce3d9a0c47d48cd2eaea6cff83" translate="yes" xml:space="preserve">
          <source>In order to allow multiple threads to use the same database connection at the same time, SQLite must make extensive use of mutexes. And for this reason a new mutex subsystem as been added. The mutex subsystem as the following interface:</source>
          <target state="translated">为了允许多个线程同时使用同一个数据库连接,SQLite必须大量使用mutexes。为此,我们添加了一个新的mutex子系统。该mutex子系统为以下接口。</target>
        </trans-unit>
        <trans-unit id="2b5d71d84c9eba5a8b5eeb690db9b2671be986f0" translate="yes" xml:space="preserve">
          <source>In order to avoid this problem, instead of a single large buffer, input is passed to a streaming API functions by way of a callback function that the sessions module invokes to incrementally request input data as it is required. In all cases, a pair of API function parameters such as</source>
          <target state="translated">为了避免这个问题,输入不是单一的大缓冲区,而是通过回调函数的方式传递给流式API函数,会话模块在需要时调用该函数来递增请求输入数据。在所有情况下,一对API函数参数,如</target>
        </trans-unit>
        <trans-unit id="4b125f2963fbbbf781a2aacf5295274d0ac9b884" translate="yes" xml:space="preserve">
          <source>In order to calculate a documents score, the full-text query is separated into its component phrases. The bm25 score for document</source>
          <target state="translated">为了计算文档得分,全文查询被分离成其组成短语。文件的bm25得分</target>
        </trans-unit>
        <trans-unit id="7154e5ea3dd269ef8c7a3c815659cc160be40ee6" translate="yes" xml:space="preserve">
          <source>In order to change the mapping of the rank column for a single query, a term similar to either of the following is added to the WHERE clause of a query:</source>
          <target state="translated">为了改变单个查询的rank列的映射,在查询的WHERE子句中添加一个类似于以下任一术语。</target>
        </trans-unit>
        <trans-unit id="2abb792779e09d00b7b2cceff1ab43c73c0ae359" translate="yes" xml:space="preserve">
          <source>In order to create an FTS4 table that does not store a copy of the indexed documents at all, the content option should be set to an empty string. For example, the following SQL creates such an FTS4 table with three columns - &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;:</source>
          <target state="translated">为了创建一个完全不存储索引文档副本的FTS4表,内容选项应该设置为空字符串。例如,下面的SQL创建了这样一个有三列--&quot;a&quot;、&quot;b &quot;和 &quot;c &quot;的FTS4表。</target>
        </trans-unit>
        <trans-unit id="dfa1c414109c4c2ee027ceb1647c28553c0a4044" translate="yes" xml:space="preserve">
          <source>In order to create or modify an existing zip file, a &quot;zipfile&quot; virtual table must be created in the database schema. The CREATE VIRTUAL TABLE statement expects a path to the zip file as its only argument. For example, to write to zip file &quot;test.zip&quot; in the current directory, a zipfile table may be created using:</source>
          <target state="translated">为了创建或修改一个现有的 zip 文件,必须在数据库模式中创建一个 &quot;zipfile &quot;虚拟表。CREATE VIRTUAL TABLE 语句要求使用 zip 文件的路径作为唯一的参数。例如,要向当前目录下的zip文件 &quot;test.zip &quot;写入数据,可以使用以下语句创建一个zipfile表。</target>
        </trans-unit>
        <trans-unit id="46eb456df96a41735386e11e34c4d6e23c625078" translate="yes" xml:space="preserve">
          <source>In order to determine whether or not the database file has changed, SQLite uses a counter in the database header (in bytes 24 through 27) which is incremented during every change operation. SQLite saves a copy of this counter prior to releasing its database lock. Then after acquiring the next database lock it compares the saved counter value against the current counter value and erases the cache if the values are different, or reuses the cache if they are the same.</source>
          <target state="translated">为了确定数据库文件是否发生了变化,SQLite在数据库头中使用了一个计数器(字节24到27),这个计数器在每次变化操作时都会递增。SQLite在释放数据库锁之前,会保存这个计数器的副本。然后在获取下一个数据库锁后,它将保存的计数器值与当前的计数器值进行比较,如果数值不同,则清除缓存,如果数值相同,则重新使用缓存。</target>
        </trans-unit>
        <trans-unit id="c5338f8b41864bbeb0f4c2c2e58a285f7e7a5717" translate="yes" xml:space="preserve">
          <source>In order to gain experience with the main ideas surrounding asynchronous IO, this implementation is deliberately kept simple. Additional capabilities may be added in the future.</source>
          <target state="translated">为了获得围绕异步IO的主要思想的经验,这个实现刻意保持简单。将来可能会增加额外的功能。</target>
        </trans-unit>
        <trans-unit id="a809ecf69a6ad9ffe3bc78cfb9dbeacb5971a731" translate="yes" xml:space="preserve">
          <source>In order to guarantee that database files are always consistent, SQLite will occasionally ask the operating system to flush all pending writes to persistent storage then wait for that flush to complete. This is accomplished using the &lt;code&gt;fsync()&lt;/code&gt; system call under unix and &lt;code&gt;FlushFileBuffers()&lt;/code&gt; under Windows. We call this flush of pending writes a &quot;sync&quot;.</source>
          <target state="translated">为了确保数据库文件始终保持一致，SQLite有时会要求操作系统将所有未完成的写入刷新到持久性存储，然后等待该刷新完成。这是通过在Windows 下使用unix下的 &lt;code&gt;fsync()&lt;/code&gt; 系统调用和在Windows 下使用 &lt;code&gt;FlushFileBuffers()&lt;/code&gt; 来完成的。我们称此未完成写入为&amp;ldquo;同步&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="78171183b8bae18fcaabb772e335a2f85feaf3a5" translate="yes" xml:space="preserve">
          <source>In order to maintain backwards compatibility, this setting is ON by default. There are advantages to turning it off, and most applications will be unaffected if it is turned off. For that reason, all applications are encouraged to switch this setting off on every database connection as soon as that connection is opened.</source>
          <target state="translated">为了保持向后的兼容性,该设置默认为ON。关闭它有一些好处,如果关闭它,大多数应用程序将不受影响。因此,我们鼓励所有应用程序在每个数据库连接打开后立即关闭该设置。</target>
        </trans-unit>
        <trans-unit id="3d3d52a785446942df482ef9658c77840bb31674" translate="yes" xml:space="preserve">
          <source>In order to maintain full backwards compatibility for legacy applications, the URI filename capability is disabled by default. URI filenames can be enabled or disabled using the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=1&lt;/a&gt; or &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=0&lt;/a&gt; compile-time options. The compile-time setting for URI filenames can be changed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,0) configuration calls. Regardless of the compile-time or start-time settings, URI filenames can be enabled for individual database connections by including the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; bit in the set of bits passed as the F parameter to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2(N,P,F,V)&lt;/a&gt;.</source>
          <target state="translated">为了保持对旧应用程序的完全向后兼容性，默认情况下禁用URI文件名功能。可以使用&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 1&lt;/a&gt;或&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 0&lt;/a&gt;编译时选项来启用或禁用URI文件名。可以在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;，1）或&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;，0）配置调用在开始时更改URI文件名的编译时设置。无论编译时间或启动时间设置如何，都可以通过将&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;位包含在作为F参数传递给&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（N，P，F，V）&lt;/a&gt;的位集中来为单个数据库连接启用URI文件名。。</target>
        </trans-unit>
        <trans-unit id="ee9ce9696c9f5b398459fe9fa5003d871b602ba2" translate="yes" xml:space="preserve">
          <source>In order to maximize compatibility between SQLite and other database engines, and so that the example above will work on SQLite as it does on other SQL database engines, SQLite supports the concept of &quot;type affinity&quot; on columns. The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required. Any column can still store any type of data. It is just that some columns, given the choice, will prefer to use one storage class over another. The preferred storage class for a column is called its &quot;affinity&quot;.</source>
          <target state="translated">为了最大限度地提高SQLite和其他数据库引擎之间的兼容性,使上面的例子在SQLite上能像在其他SQL数据库引擎上一样工作,SQLite在列上支持 &quot;类型亲和性 &quot;的概念。列的类型亲和性是指该列中存储的数据的推荐类型。这里的重要思想是,类型是推荐的,而不是要求的。任何列仍然可以存储任何类型的数据。只是有些列在有选择的情况下,会优先使用一种存储类而不是另一种。一个列的首选存储类被称为它的 &quot;亲和力&quot;。</target>
        </trans-unit>
        <trans-unit id="c4c58e4d4912a4704b0cbb27832e1afdc4578e5c" translate="yes" xml:space="preserve">
          <source>In order to port SQLite to a new operating system - an operating system not supported by default - the application must provide...</source>
          <target state="translated">为了将SQLite移植到新的操作系统--默认情况下不支持的操作系统--应用程序必须提供。</target>
        </trans-unit>
        <trans-unit id="9139039adfb729ff69195002226ce412be58a20b" translate="yes" xml:space="preserve">
          <source>In order to prevent the number of b-trees in the database from becoming too large (slowing down queries), smaller b-trees are periodically merged into single larger b-trees containing the same data. By default, this happens automatically within INSERT, UPDATE or DELETE statements that modify the full-text index. The 'automerge' parameter determines how many smaller b-trees are merged together at a time. Setting it to a small value can speed up queries (as they have to query and merge the results from fewer b-trees), but can also slow down writing to the database (as each INSERT, UPDATE or DELETE statement has to do more work as part of the automatic merging process).</source>
          <target state="translated">为了防止数据库中b树的数量变得过大(减慢查询速度),较小的b树会定期合并成包含相同数据的较大b树。默认情况下,这将在修改全文索引的INSERT、UPDATE或DELETE语句中自动发生。automerge &quot;参数决定了每次合并多少个较小的b树。将它设置为一个小值可以加快查询速度(因为它们必须查询和合并来自较少b-trees的结果),但也会减慢对数据库的写入速度(因为作为自动合并过程的一部分,每个INSERT、UPDATE或DELETE语句必须做更多的工作)。</target>
        </trans-unit>
        <trans-unit id="3d48be902e74206d36d33669d85fb41c800c7878" translate="yes" xml:space="preserve">
          <source>In order to provide portability between across operating systems, SQLite uses abstract object called the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Each VFS provides methods for opening, read, writing, and closing files on disk, and for other OS-specific task such as finding the current time, or obtaining randomness to initialize the built-in pseudo-random number generator. SQLite currently provides VFSes for unix (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; file) and Windows (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; file).</source>
          <target state="translated">为了提供跨操作系统的可移植性，SQLite使用了称为&lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;抽象对象。每个VFS提供用于打开，读取，写入和关闭磁盘上文件的方法，以及用于其他特定于OS的任务的方法，例如查找当前时间或获取随机性以初始化内置的伪随机数生成器。 SQLite当前为UNIX（在&lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;文件中）和Windows（在&lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt;文件中）提供VFS。</target>
        </trans-unit>
        <trans-unit id="31ad990efe0b69348774fca33a1caeca8003e9e6" translate="yes" xml:space="preserve">
          <source>In order to rebase a local changeset, the remote changeset must first be applied to the local database using sqlite3changeset_apply_v2() and the buffer of rebase information captured. Then:</source>
          <target state="translated">为了对本地的变更集进行重基,首先必须使用sqlite3changeset_apply_v2()将远程的变更集应用到本地数据库中,并捕获重基信息的缓冲区。然后。</target>
        </trans-unit>
        <trans-unit id="aa098185ca802c3d4bb821bfd07089d8121f87d8" translate="yes" xml:space="preserve">
          <source>In order to return data from the database to the user, for example as the results of a SELECT query, SQLite must at some point read data from the database file. Usually, data is read from the database file in aligned blocks of</source>
          <target state="translated">为了将数据库中的数据返回给用户,例如作为一个SELECT查询的结果,SQLite必须在某个时刻从数据库文件中读取数据。通常情况下,数据是以对齐的块从数据库文件中读取的。</target>
        </trans-unit>
        <trans-unit id="fbe7b2f0d6747492938cc0cedd14f11e91e462ca" translate="yes" xml:space="preserve">
          <source>In order to save space, this backing table may be omitted by setting the columnsize option to zero. For example:</source>
          <target state="translated">为了节省空间,可以通过将列大小选项设置为零来省略这个支持表。例如:</target>
        </trans-unit>
        <trans-unit id="1dc49d196adf92707040503b638c58b0d1b51283" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">为了成功，调用&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（D，S，P）&lt;/a&gt;时，数据库连接不得处于&lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;自动提交模式&lt;/a&gt;。如果已在模式S上打开读取事务，则数据库句柄必须没有活动语句（已传递给sqlite3_step（）的SELECT语句，但没有传递给sqlite3_reset（）或sqlite3_finalize（）的语句）。如果违反这些条件之一，或者模式S不存在，或者快照对象无效，则返回SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="4bcc91176e8c72eef945e65a5e94e40093e70723" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">为了成功，调用&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（D，S，P）&lt;/a&gt;时，数据库连接不得处于&lt;a href=&quot;get_autocommit&quot;&gt;自动提交模式&lt;/a&gt;。如果已在模式S上打开读取事务，则数据库句柄必须没有活动语句（已传递给sqlite3_step（）的SELECT语句，但没有传递给sqlite3_reset（）或sqlite3_finalize（）的语句）。如果违反这些条件之一，或者模式S不存在，或者快照对象无效，则返回SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="3885c40685a2b0fc9bd29a3371e31ed82a66178a" translate="yes" xml:space="preserve">
          <source>In order to use FTS5 instead of FTS3 or FTS4, applications usually require minimal modifications. Most of these fall into three categories - changes required to the CREATE VIRTUAL TABLE statement used to create the FTS table, changes required to SELECT queries used to execute queries against the table, and changes required to applications that use &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">为了使用FTS5代替FTS3或FTS4，应用程序通常需要进行最少的修改。其中大多数分为三类-用于创建FTS表的CREATE VIRTUAL TABLE语句所需的更改，用于执行对该表的查询的SELECT查询所需的更改以及使用&lt;a href=&quot;fts3#snippet&quot;&gt;FTS辅助功能的&lt;/a&gt;应用程序所需的更改。</target>
        </trans-unit>
        <trans-unit id="362a80a01b0db13fb3dac03d2ae8d3c5e2853e16" translate="yes" xml:space="preserve">
          <source>In order to use foreign key constraints in SQLite, the library must be compiled with neither &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined. If SQLITE_OMIT_TRIGGER is defined but SQLITE_OMIT_FOREIGN_KEY is not, then SQLite behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14) - foreign key definitions are parsed and may be queried using &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;, but foreign key constraints are not enforced. The &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command is a no-op in this configuration. If OMIT_FOREIGN_KEY is defined, then foreign key definitions cannot even be parsed (attempting to specify a foreign key definition is a syntax error).</source>
          <target state="translated">为了在SQLite中使用外键约束，必须在&lt;a href=&quot;compile#omit_foreign_key&quot;&gt;未定义SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt;或&lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER的情况下&lt;/a&gt;编译库。如果定义了SQLITE_OMIT_TRIGGER但未定义SQLITE_OMIT_FOREIGN_KEY，则SQLite的行为与&lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;版本3.6.19&lt;/a&gt;（2009-10-14）之前的行为相同-将解析外键定义，并可以使用&lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;对其进行查询，但不会强制执行外键约束。在此配置中，&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;命令是no-op。如果定义了OMIT_FOREIGN_KEY，则甚至无法解析外键定义（试图指定外键定义是语法错误）。</target>
        </trans-unit>
        <trans-unit id="2a10b918ff09134ab69409cf683db7b4a9557318" translate="yes" xml:space="preserve">
          <source>In order to use this command to delete a row, the text value 'delete' must be inserted into the special column with the same name as the table. The rowid of the row to delete is inserted into the rowid column. The values inserted into the other columns must match the values currently stored in the table. For example:</source>
          <target state="translated">为了使用这条命令删除一条记录,必须在与表同名的特殊列中插入文本值 &quot;delete&quot;。要删除的行的rowid被插入到rowid列中。插入到其他列中的值必须与当前存储在表中的值相匹配。例如:</target>
        </trans-unit>
        <trans-unit id="18acf9de092948631a77a8a7268e93e0863d7575" translate="yes" xml:space="preserve">
          <source>In ordinary indexes, there is exactly one entry in the index for every row in the table. In partial indexes, only some subset of the rows in the table have corresponding index entries. For example, a partial index might omit entries for which the column being indexed is NULL. When used judiciously, partial indexes can result in smaller database files and improvements in both query and write performance.</source>
          <target state="translated">在普通索引中,表中的每一行正好有一个索引条目。在部分索引中,表中只有部分子集的行有相应的索引条目。例如,部分索引可能会省略那些被索引的列是NULL的条目。如果明智地使用,部分索引可以使数据库文件更小,并改善查询和写入性能。</target>
        </trans-unit>
        <trans-unit id="2aff0a10aa915dae8ca55cc20203451ac3b580cc" translate="yes" xml:space="preserve">
          <source>In other words, an SQLite database can do everything that a pile-of-files or wrapped pile-of-files format can do, plus much more, and with greater lucidity. An SQLite database is a more versatile container than key/value filesystem or a ZIP archive. (For a detailed example, see the &lt;a href=&quot;affcase1&quot;&gt;OpenOffice case study&lt;/a&gt; essay.)</source>
          <target state="translated">换句话说，SQLite数据库可以完成文件堆或包装文件堆格式可以做的所有事情，而且功能更多，而且更加清晰。与键/值文件系统或ZIP存档相比，SQLite数据库是一种用途更广泛的容器。 （有关详细示例，请参阅&lt;a href=&quot;affcase1&quot;&gt;OpenOffice案例研究&lt;/a&gt;文章。）</target>
        </trans-unit>
        <trans-unit id="a0407b322bda5c84932b9210d6c9dd55dfaff1cd" translate="yes" xml:space="preserve">
          <source>In other words, if X begins a write transaction using &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; then issues one or more &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and/or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements, then those changes are visible to subsequent &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that are evaluated in database connection X. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements on a different database connection Y will show no changes until the X transaction commits. But &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements in X will show the changes prior to the commit.</source>
          <target state="translated">换句话说，如果X使用开始的写入事务&lt;a href=&quot;lang_transaction#immediate&quot;&gt;立即开始&lt;/a&gt;然后发出一个或多个&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，和/或&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句，那么这些改变都随后可见&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;，在数据库连接X.评价语句&lt;a href=&quot;lang_select&quot;&gt;选择&lt;/a&gt;在不同的发言在X事务提交之前，数据库连接Y不会显示任何更改。但是X中的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句将在提交之前显示更改。</target>
        </trans-unit>
        <trans-unit id="b76e19862dad40faf099a9e663056c35b57f6bbd" translate="yes" xml:space="preserve">
          <source>In other words, make the same sqlite3_test_control() call except change the last two parameters to zero.</source>
          <target state="translated">换句话说,进行同样的sqlite3_test_control()调用,只是将最后两个参数改为0。</target>
        </trans-unit>
        <trans-unit id="a943abceb2efdd003ead8aa4530811df4446fd2f" translate="yes" xml:space="preserve">
          <source>In other words, opening and using a database file that has two or more names results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">换句话说,打开和使用一个有两个或更多名字的数据库文件会导致未定义的行为,而且可能是不可取的。</target>
        </trans-unit>
        <trans-unit id="5f5d40599d0989dfe7615dba1f4690adcb6d4ca6" translate="yes" xml:space="preserve">
          <source>In other words, powersafe overwrite means that there is no &quot;collateral damage&quot; when a power loss occurs while writing. Only those bytes actually being written might be damaged.</source>
          <target state="translated">换句话说,powerafe overwrite意味着在写的过程中发生断电时,没有 &quot;附带损害&quot;。只有那些实际被写入的字节才可能被损坏。</target>
        </trans-unit>
        <trans-unit id="ebd1e3e7febed4c7b9b73c22b3802bc322206c02" translate="yes" xml:space="preserve">
          <source>In other words, since 2004 all SQLite releases have been backwards compatible, though not necessarily forwards compatible.</source>
          <target state="translated">换句话说,从2004年开始,所有的SQLite版本都是向后兼容的,尽管不一定是向前兼容。</target>
        </trans-unit>
        <trans-unit id="1f360548804fb547b2c55aa98cf2f1549c641a34" translate="yes" xml:space="preserve">
          <source>In other words, the session extension provides a facility for SQLite database files that is similar to the unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;patch&lt;/a&gt; utility program, or to the &quot;merge&quot; capabilities of version control systems such as &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;, &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;, or &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;.</source>
          <target state="translated">换句话说，会话扩展为SQLite数据库文件提供了一种工具，该工具与unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;修补&lt;/a&gt;程序实用程序或版本控制系统（如&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;，&lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;或&lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial）&lt;/a&gt;的&amp;ldquo;合并&amp;rdquo;功能类似。</target>
        </trans-unit>
        <trans-unit id="c9d46649fb7fd18d588f4a5f73a3e3c10dcafa53" translate="yes" xml:space="preserve">
          <source>In other words, unlinking or renaming an open database file results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">换句话说,取消链接或重命名一个打开的数据库文件会导致未定义的行为,而且可能是不可取的。</target>
        </trans-unit>
        <trans-unit id="a8fad5ad802fc08a8688a68301e637bb10e07021" translate="yes" xml:space="preserve">
          <source>In other words, you should call sqlite3_column_text(), sqlite3_column_blob(), or sqlite3_column_text16() first to force the result into the desired format, then invoke sqlite3_column_bytes() or sqlite3_column_bytes16() to find the size of the result. Do not mix calls to sqlite3_column_text() or sqlite3_column_blob() with calls to sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16() with calls to sqlite3_column_bytes().</source>
          <target state="translated">换句话说,应该先调用sqlite3_column_text()、sqlite3_column_blob()或sqlite3_column_text16()来强制将结果转换成所需的格式,然后调用sqlite3_column_bytes()或sqlite3_column_bytes16()来查找结果的大小。不要将调用sqlite3_column_text()或sqlite3_column_blob()与调用sqlite3_column_bytes16()混合使用,也不要将调用sqlite3_column_text16()与调用sqlite3_column_bytes()混合使用。</target>
        </trans-unit>
        <trans-unit id="456e92a6a9d74515a6d36409e4455702906122d6" translate="yes" xml:space="preserve">
          <source>In practical terms, what the powersafe write property means is that when the disk controller detects an impending power loss, it finishes writing whatever sector it is working on prior to parking the heads. It means that individual sector writes will complete once started, even if there is a power loss.</source>
          <target state="translated">在实际操作中,powerafe write属性的意思是,当磁盘控制器检测到即将断电时,它将在停放磁头之前完成它正在进行的任何扇区的写入。这意味着单个扇区的写入一旦开始就会完成,即使出现断电。</target>
        </trans-unit>
        <trans-unit id="9fe8084319ab239e87ac8042e3d629376c48f43e" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">实际上，元数据是在函数调用的函数调用之间保留的，这些函数参数是编译时常量，包括文字值和&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;以及由它们组成的表达式。</target>
        </trans-unit>
        <trans-unit id="553ff79ef31136314c6f3a02cf8b8c9de3d93346" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">实际上，元数据是在函数调用的函数调用之间保留的，这些函数参数是编译时常量，包括文字值和&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;以及由它们组成的表达式。</target>
        </trans-unit>
        <trans-unit id="235238a95713f71f096fe2094b1d8d70514424be" translate="yes" xml:space="preserve">
          <source>In precompiled SQLite libraries available on the website, the Unix versions are compiled with THREADSAFE turned off but the Windows versions are compiled with THREADSAFE turned on. If you need something different that this you will have to recompile.</source>
          <target state="translated">在网站上提供的预编译SQLite库中,Unix版本在编译时关闭了THREADSAFE,但Windows版本在编译时打开了THREADSAFE。如果你需要不同的东西,你将不得不重新编译。</target>
        </trans-unit>
        <trans-unit id="49d7b0c7067454bf2994ce5482f78c23710e1d3a" translate="yes" xml:space="preserve">
          <source>In prior discussion, it was assumed that each SQL statement is prepared once, evaluated, then destroyed. However, SQLite allows the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; to be evaluated multiple times. This is accomplished using the following routines:</source>
          <target state="translated">在前面的讨论中，假设每个SQL语句仅准备一次，评估然后销毁。但是，SQLite允许对同一条&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;进行多次评估。使用以下例程可以完成此操作：</target>
        </trans-unit>
        <trans-unit id="86c3b83aa53c8f50b7b8f707247a7f27be6c0dc8" translate="yes" xml:space="preserve">
          <source>In processing the query above, SQLite invokes the sumint callbacks as follows:</source>
          <target state="translated">在处理上述查询时,SQLite调用sumint回调如下。</target>
        </trans-unit>
        <trans-unit id="59cf5532e18c9ee34b181fd5de97a560addf74bf" translate="yes" xml:space="preserve">
          <source>In queries that are driven by a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, avoid unnecessary tests of the constraint named in the WHERE clause of the partial index, since we know that constraint must always be true.</source>
          <target state="translated">在由&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;驱动的查询中，请避免对部分索引的WHERE子句中命名的约束进行不必要的测试，因为我们知道约束必须始终为true。</target>
        </trans-unit>
        <trans-unit id="82246b58b2662ec98735d83b367a59b70f82fb40" translate="yes" xml:space="preserve">
          <source>In rollback mode, SQLite implements isolation by locking the database file and preventing any reads by other database connections while each write transaction is underway. Readers can be be active at the beginning of a write, before any content is flushed to disk and while all changes are still held in the writer's private memory space. But before any changes are made to the database file on disk, all readers must be (temporally) expelled in order to give the writer exclusive access to the database file. Hence, readers are prohibited from seeing incomplete transactions by virtue of being locked out of the database while the transaction is being written to disk. Only after the transaction is completely written and synced to disk and commits are the readers allowed back into the database. Hence readers never get a chance to see partially written changes.</source>
          <target state="translated">在回滚模式下,SQLite通过锁定数据库文件,并在每个写事务进行时防止其他数据库连接的任何读取来实现隔离。读取器可以在写入开始时,在任何内容被刷新到磁盘之前,并且当所有的更改仍然保存在写入器的私有内存空间中时,读取器是活跃的。但是在对磁盘上的数据库文件进行任何修改之前,所有的读取器必须(暂时)被驱逐,以便让写入者独占数据库文件。因此,在事务写入磁盘时,由于被锁定在数据库之外,禁止读者看到不完整的事务。只有在事务完全写入磁盘并同步到磁盘并提交之后,读者才被允许回到数据库中。因此读者永远没有机会看到部分写入的更改。</target>
        </trans-unit>
        <trans-unit id="068d2699f531d0825115d300a0cccce10e48a71e" translate="yes" xml:space="preserve">
          <source>In spite of the disadvantages, the developers believe that having a built-in printf() implementation inside of SQLite is a net positive.</source>
          <target state="translated">尽管存在缺点,但开发者认为在SQLite内部有一个内置的printf()实现是一个积极的因素。</target>
        </trans-unit>
        <trans-unit id="cf039b1afa32ebe62123ae1292d3fdd466d22e3b" translate="yes" xml:space="preserve">
          <source>In step 2 of the procedure above, the database file is not locked before it is read from. This is the only exception to the locking rules described in section</source>
          <target state="translated">在上述过程的第2步中,数据库文件在被读取之前没有被锁定。这是在第2步中描述的锁定规则的唯一例外。</target>
        </trans-unit>
        <trans-unit id="8ea8892717935eea12390eaf98af13ff334785db" translate="yes" xml:space="preserve">
          <source>In summary then, any query with aggregate functions is implemented by two loops. The first loop scans the input table and computes aggregate information into buckets and the second loop scans through all the buckets to compute the final result.</source>
          <target state="translated">那么总的来说,任何带有聚合函数的查询都是由两个循环来实现的。第一个循环扫描输入表,并将聚合信息计算到桶中,第二个循环扫描所有桶,计算最终结果。</target>
        </trans-unit>
        <trans-unit id="2fe8cccc0c3831ee16f379b0a96fc3ebe090262e" translate="yes" xml:space="preserve">
          <source>In summary, the claim of this essay is that using SQLite as a container for an application file format like OpenDocument and storing lots of smaller objects in that container works out much better than using a ZIP archive holding a few larger objects. To wit:</source>
          <target state="translated">总而言之,这篇文章的主张是,使用SQLite作为OpenDocument这样的应用文件格式的容器,并在这个容器中存储大量的小对象,比使用ZIP存档存放一些大对象的效果要好得多。大意是:</target>
        </trans-unit>
        <trans-unit id="14368b74fc6cabbc46f6b11af62f68ec319ac0f1" translate="yes" xml:space="preserve">
          <source>In support of the &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; goal for SQLite, the parser code generated by Lemon has no unreachable branches, and contains extra (compile-time selected) instrumentation useful for measuring test coverage.</source>
          <target state="translated">为了支持SQLite 的&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DC测试&lt;/a&gt;目标，Lemon生成的解析器代码没有不可达的分支，并且包含用于测量测试覆盖率的额外（选择的编译时）工具。</target>
        </trans-unit>
        <trans-unit id="aad3b77ed5e3adba0d4656a1d99071301ddd4bc1" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;http://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="translated">采用&amp;ldquo;化石三角洲&amp;rdquo;格式&lt;a href=&quot;http://fossil-scm.org&quot;&gt;-Fossil源代码管理系统&lt;/a&gt;用于blob三角洲的格式，或者</target>
        </trans-unit>
        <trans-unit id="55105fedb19d062cb7afdaefe48e3eb4675905c5" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;https://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="translated">采用&amp;ldquo;化石三角洲&amp;rdquo;格式&lt;a href=&quot;https://fossil-scm.org&quot;&gt;-Fossil源代码管理系统&lt;/a&gt;用于blob三角洲的格式，或者</target>
        </trans-unit>
        <trans-unit id="30519768573ed5dd959ec460751bfce418bf4435" translate="yes" xml:space="preserve">
          <source>In the &quot;without ANALYZE&quot; case on the left, the NN algorithm chooses loop P (PLINK) as the outer loop because 4.9 is less than 5.2, resulting in path P-T which is algorithm-1. NN only looks at the single best choice at each step so it completely misses the fact that 5.2+4.4 makes a slightly cheaper plan than 4.9+4.8. But the N3 algorithm keeps track of the 5 best paths for a 2-way join, so it ends up selecting path T-P because of its slightly lower overall cost. Path T-P is algorithm-2.</source>
          <target state="translated">在左边的 &quot;没有ANALYZE &quot;的情况下,NN算法选择循环P(PLINK)作为外循环,因为4.9小于5.2,结果路径P-T是算法-1。NN只看每一步的单项最佳选择,所以它完全忽略了5.2+4.4比4.9+4.8做出的方案略微便宜。但是N3算法会跟踪2-way join的5条最佳路径,所以它最终选择路径T-P,因为它的总体成本略低。路径T-P是算法-2。</target>
        </trans-unit>
        <trans-unit id="88edd036016e74b41ab30f363489bc8baf2ff243" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt;, the application needs to tell the extension the location of a C-language array that contains the data for the table-valued function that the extension implements.</source>
          <target state="translated">在&lt;a href=&quot;carray&quot;&gt;CARRAY扩展程序中&lt;/a&gt;，应用程序需要告知扩展程序C语言数组的位置，该数组包含扩展程序实现的表值函数的数据。</target>
        </trans-unit>
        <trans-unit id="0673453ee376202611f58f23515a709feb8d4034" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, enhance the &quot;.mode&quot; command so that it restores the default column and row separators for modes &quot;line&quot;, &quot;list&quot;, &quot;column&quot;, and &quot;tcl&quot;.</source>
          <target state="translated">在&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;，增强&amp;ldquo; .mode&amp;rdquo;命令，以便它恢复模式&amp;ldquo; line&amp;rdquo;，&amp;ldquo; list&amp;rdquo;，&amp;ldquo; column&amp;rdquo;和&amp;ldquo; tcl&amp;rdquo;的默认列和行分隔符。</target>
        </trans-unit>
        <trans-unit id="c5b3d2f7e7ec64c2ea66a15e4b9de436ddc07a10" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH operator&lt;/a&gt; (which does the full-text search) needs to communicate details of matching entries to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; functions so that those functions can convert the details of the match into useful output.</source>
          <target state="translated">在&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;扩展中，&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH运算符&lt;/a&gt;（进行全文搜索）需要将匹配条目的详细信息传递给&lt;a href=&quot;fts3#snippet&quot;&gt;snippet（）&lt;/a&gt;，&lt;a href=&quot;fts3#offsets&quot;&gt;offsets（）&lt;/a&gt;和&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;函数，以便这些函数可以转换匹配项的细节。转换成有用的输出。</target>
        </trans-unit>
        <trans-unit id="7f5a2150475db6cefe817c8c9175290580ea2ad7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;json1&quot;&gt;JSON extension&lt;/a&gt;, fix the JSON validator so that it correctly rejects invalid backslash escapes within strings.</source>
          <target state="translated">在&lt;a href=&quot;json1&quot;&gt;JSON扩展名中&lt;/a&gt;，修复JSON验证程序，使其正确拒绝字符串中无效的反斜杠转义符。</target>
        </trans-unit>
        <trans-unit id="29cf2e016ded4e45037d7dd8bd42e21681c156af" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;, add extra sync operations to avoid the possibility of corruption following a power failure.</source>
          <target state="translated">在&lt;a href=&quot;rbu&quot;&gt;RBU扩展中&lt;/a&gt;，添加额外的同步操作以避免电源故障后损坏的可能性。</target>
        </trans-unit>
        <trans-unit id="11f2b4a17490be52b1b76c1ff6aa70a95cb65d46" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension, when rounding 64-bit floating point numbers to 32-bit for storage, always round in a direction that causes the bounding box to get larger.</source>
          <target state="translated">在&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;扩展中，将64位浮点数四舍五入为32位用于存储时，请始终沿导致边界框变大的方向四舍五入。</target>
        </trans-unit>
        <trans-unit id="240fef4158af161eb22e60a820c151dc84eafe1e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;, add the -uri option to the &quot;sqlite3&quot; TCL command used for creating new database connection objects.</source>
          <target state="translated">在&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口中&lt;/a&gt;，将-uri选项添加到用于创建新数据库连接对象的&amp;ldquo; sqlite3&amp;rdquo; TCL命令中。</target>
        </trans-unit>
        <trans-unit id="156e69c7f61ba1dcce1a1142af151766e801c151" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL language interface&lt;/a&gt;, &quot;@variable&quot; instead of &quot;$variable&quot; always binds as a blob.</source>
          <target state="translated">在&lt;a href=&quot;tclsqlite&quot;&gt;TCL语言界面中&lt;/a&gt;，&amp;ldquo; @ variable&amp;rdquo;而不是&amp;ldquo; $ variable&amp;rdquo;始终绑定为斑点。</target>
        </trans-unit>
        <trans-unit id="7ed9b7e87f45e28428e0b4c11b7a622203b8e9d6" translate="yes" xml:space="preserve">
          <source>In the BLOB output, you can clearly see the NUL character as the 4th character in the 7-character string.</source>
          <target state="translated">在BLOB的输出中,你可以清楚地看到NUL字符是7字符字符串中的第4个字符。</target>
        </trans-unit>
        <trans-unit id="d3bfa67674bb524ce3387e6563f15051a77fe593" translate="yes" xml:space="preserve">
          <source>In the C programming language where &lt;b&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;||&lt;/code&gt;&lt;/b&gt; are &quot;short-circuit&quot; operators, MC/DC and branch coverage are very nearly the same thing. The primary difference is in boolean vector tests. One can test for any of several bits in bit-vector and still obtain 100% branch test coverage even though the second element of MC/DC - the requirement that each condition in a decision take on every possible outcome - might not be satisfied.</source>
          <target state="translated">在C编程语言中，&lt;b&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/b&gt;和&lt;b&gt; &lt;code&gt;||&lt;/code&gt; &lt;/b&gt;是&amp;ldquo;短路&amp;rdquo;运算符，MC / DC和分支覆盖范围几乎是同一件事。主要区别在于布尔向量测试。即使可能不满足MC / DC的第二个元素（决定中的每个条件都考虑所有可能结果的要求），也可以测试位向量中的任何几位，并且仍然获得100％的分支测试覆盖率。</target>
        </trans-unit>
        <trans-unit id="a49a291dae627f989ba703462ee2c7e1bcc8b060" translate="yes" xml:space="preserve">
          <source>In the C programming language, it is very easy to write code that has &quot;undefined&quot; or &quot;implementation defined&quot; behavior. That means that the code might work during development, but then give a different answer on a different system, or when recompiled using different compiler options. Examples of undefined and implementation-defined behavior in ANSI C include:</source>
          <target state="translated">在C语言编程中,很容易写出具有 &quot;未定义 &quot;或 &quot;实现定义 &quot;行为的代码。这意味着代码在开发过程中可能会工作,但在不同的系统上,或者使用不同的编译器选项重新编译时,会给出不同的答案。在ANSI C中,未定义和实现定义的行为的例子包括。</target>
        </trans-unit>
        <trans-unit id="c817a7331349197e219cdd351370db507b5f89c0" translate="yes" xml:space="preserve">
          <source>In the COPY command, backslash can now be used to escape a newline.</source>
          <target state="translated">在COPY命令中,现在可以使用反斜杠来转义换行。</target>
        </trans-unit>
        <trans-unit id="cb9f3cc234a2699a8be8b939bc81e4cd1e3c8028" translate="yes" xml:space="preserve">
          <source>In the Fossil full-text search system, documents that participate in the full-text search (wiki pages, tickets, check-ins, documentation files, etc) are tracked by a table called &quot;ftsdocs&quot; (&lt;u&gt;f&lt;/u&gt;ull &lt;u&gt;t&lt;/u&gt;ext &lt;u&gt;s&lt;/u&gt;earch &lt;u&gt;doc&lt;/u&gt;ument&lt;u&gt;s&lt;/u&gt;). As new documents are added to the repository, they are not indexed right away. Indexing is deferred until there is a search request. The ftsdocs table contains an &quot;idxed&quot; field which is true if the document has been indexed and false if not.</source>
          <target state="translated">在化石全文检索系统，参与的全文检索的文献（wiki页面，门票，检查插件，文档文件等）是由一个名为&amp;ldquo;ftsdocs&amp;rdquo;（表跟踪&lt;u&gt;˚F&lt;/u&gt; ULL &lt;u&gt;牛逼&lt;/u&gt;分机&lt;u&gt;小号&lt;/u&gt;目录操作搜索&lt;u&gt;文档&lt;/u&gt; ument &lt;u&gt;小号&lt;/u&gt;）。将新文档添加到资源库后，不会立即对其进行索引。索引将推迟到有搜索请求为止。ftsdocs表包含一个&amp;ldquo; idxed&amp;rdquo;字段，如果文档已被索引，则为true，否则为false。</target>
        </trans-unit>
        <trans-unit id="54570b346f4d608f2bbac12e4181cf27370c513d" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">在输入到&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;及其变体的SQL语句文本中，文字可以用与以下模板之一匹配的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;代替：</target>
        </trans-unit>
        <trans-unit id="2d198fd96a87b68a84840a27e15d7192fd58115f" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">在输入到&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;及其变体的SQL语句文本中，文字可以用与以下模板之一匹配的&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;代替：</target>
        </trans-unit>
        <trans-unit id="0bfef1786d8548ec0f82e3f4f67466b9d9c84839" translate="yes" xml:space="preserve">
          <source>In the TCL test harness, the crash simulation is done in a separate process. The main testing process spawns a child process which runs some SQLite operation and randomly crashes somewhere in the middle of a write operation. A special &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; randomly reorders and corrupts the unsynchronized write operations to simulate the effect of buffered filesystems. After the child dies, the original test process opens and reads the test database and verifies that the changes attempted by the child either completed successfully or else were completely rolled back. The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is used to make sure no database corruption occurs.</source>
          <target state="translated">在TCL测试工具中，崩溃模拟是在单独的过程中完成的。主要的测试过程会产生一个子进程，该子进程运行一些SQLite操作，并在写操作的中间随机崩溃。特殊的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;随机重新排序并破坏了不同步的写操作，以模拟缓冲文件系统的效果。子进程死亡后，原始测试过程将打开并读取测试数据库，并验证子进程尝试的更改是否成功完成或已完全回滚。该&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;INTEGRITY_CHECK &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;用来确保没有数据库损坏发生。</target>
        </trans-unit>
        <trans-unit id="2e83d8a255a88980125401cd881c484a48bd6dc6" translate="yes" xml:space="preserve">
          <source>In the TPC-H Q8 query, the setup costs are all negligible, all dependencies are between individual nodes, and there is no ORDER BY, GROUP BY, or DISTINCT clause. So for TPC-H Q8, the graph above is a reasonable representation of what needs to be computed. The general case involves a lot of extra complication, which for clarity is neglected in the remainder of this article.</source>
          <target state="translated">在TPC-H Q8查询中,设置成本都可以忽略不计,所有的依赖关系都在各个节点之间,而且没有ORDER BY、GROUP BY或者DISTINCT子句。所以对于TPC-H Q8来说,上面的图是需要计算的合理表示。一般情况下,涉及到很多额外的复杂情况,为了清楚起见,本文其余部分忽略了这一点。</target>
        </trans-unit>
        <trans-unit id="9f3539e13c22fa6c6ec2b58a1ccd7e90a2d77370" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句中。</target>
        </trans-unit>
        <trans-unit id="2ff78c844bf874e8944245ab0f90e378a482a538" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a partial index.</source>
          <target state="translated">在部分索引的WHERE子句中。</target>
        </trans-unit>
        <trans-unit id="b6311a2e6a2d0640df13bf33c58d5ba4044c66ce" translate="yes" xml:space="preserve">
          <source>In the Windows OS driver, reacquire a SHARED lock if an attempt to acquire an EXCLUSIVE lock fails. Ticket #2354</source>
          <target state="translated">在 Windows OS 驱动程序中,如果获取 EXCLUSIVE 锁的尝试失败,则重新获取 SHARED 锁。Ticket #2354</target>
        </trans-unit>
        <trans-unit id="c812acc1f415592dcfc5eeb302d23caa6a39526f" translate="yes" xml:space="preserve">
          <source>In the above paragraph, the term &quot;equal&quot; means equal when values are compared using the rules &lt;a href=&quot;datatype3#comparisons&quot;&gt;specified here&lt;/a&gt;. The following clarifications apply:</source>
          <target state="translated">在上一段中，术语&amp;ldquo;等于&amp;rdquo;表示使用&lt;a href=&quot;datatype3#comparisons&quot;&gt;此处指定&lt;/a&gt;的规则比较值时等于&amp;ldquo;相等&amp;rdquo; 。以下澄清适用：</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">在上述。</target>
        </trans-unit>
        <trans-unit id="441e596237bc1ae031cea29bc5e12b44c88ed81c" translate="yes" xml:space="preserve">
          <source>In the above, &amp;lt;content&amp;gt; is replaced by the name of the content table. By default, &amp;lt;content_rowid&amp;gt; is replaced by the literal text &quot;rowid&quot;. Or, if the &quot;content_rowid&quot; option is set within the CREATE VIRTUAL TABLE statement, by the value of that option. &amp;lt;cols&amp;gt; is replaced by a comma-separated list of the FTS5 table column names. For example:</source>
          <target state="translated">在上面，&amp;lt;content&amp;gt;被内容表的名称替换。默认情况下，&amp;lt;content_rowid&amp;gt;被文字文本&amp;ldquo; rowid&amp;rdquo;替换。或者，如果在CREATE VIRTUAL TABLE语句中设置了&amp;ldquo; content_rowid&amp;rdquo;选项，则通过该选项的值进行设置。&amp;lt;cols&amp;gt;替换为FTS5表列名称的逗号分隔列表。例如：</target>
        </trans-unit>
        <trans-unit id="a2464dd3bf1c506de33685f476dfeec6d3c9f83a" translate="yes" xml:space="preserve">
          <source>In the above, the user creates the database schema (a single table - &quot;x1&quot;), and then uses the &quot;.expert&quot; command to analyze a query, in this case &quot;SELECT * FROM x1 WHERE a=? AND b&amp;gt;?&quot;. The shell tool recommends that the user create a new index (index &quot;x1_idx_000123a7&quot;) and outputs the plan that the query would use in &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; format. The user then creates an index with an equivalent schema and runs the analysis on the same query again. This time the shell tool does not recommend any new indexes, and outputs the plan that SQLite will use for the query given the existing indexes.</source>
          <target state="translated">在上面，用户创建数据库模式（单个表-&amp;ldquo; x1&amp;rdquo;），然后使用&amp;ldquo; .expert&amp;rdquo;命令分析查询，在这种情况下为&amp;ldquo; SELECT * FROM x1 WHERE a =？AND b&amp;gt;？ &amp;rdquo;。 Shell工具建议用户创建一个新索引（索引&amp;ldquo; x1_idx_000123a7&amp;rdquo;）并以&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;格式输出该查询将使用的计划。然后，用户使用等效的架构创建索引，并再次对同一查询运行分析。这次，shell工具不建议任何新索引，并在给定现有索引的情况下输出SQLite将用于查询的计划。</target>
        </trans-unit>
        <trans-unit id="c0edb5d51a3281366e0040cd06804f7b08ee3eaa" translate="yes" xml:space="preserve">
          <source>In the argments to &quot;rtree&quot; in the CREATE VIRTUAL TABLE statement, the names of the columns are taken from the first token of each argument. All subsequent tokens within each argument are silently ignored. This means, for example, that if you try to give a column a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; or add a constraint such as UNIQUE or NOT NULL or DEFAULT to a column, those extra tokens are accepted as valid, but they do not change the behavior of the rtree. In an RTREE virtual table, the first column always has a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of INTEGER and all other data columns have a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of NUMERIC.</source>
          <target state="translated">在CREATE VIRTUAL TABLE语句中&amp;ldquo; rtree&amp;rdquo;的参数中，列的名称取自每个参数的第一个标记。每个自变量中的所有后续标记都将被静默忽略。例如，这意味着，如果您尝试为列赋予&lt;a href=&quot;datatype3#affinity&quot;&gt;类型亲和性&lt;/a&gt;或向列添加约束（例如UNIQUE或NOT NULL或DEFAULT），则这些额外的标记将被视为有效，但它们不会更改标记的行为。 rtree。在RTREE虚拟表中，第一列的&lt;a href=&quot;datatype3#affinity&quot;&gt;类型关联&lt;/a&gt;始终为INTEGER，而所有其他数据列的&lt;a href=&quot;datatype3#affinity&quot;&gt;类型关联&lt;/a&gt;始终为NUMERIC。</target>
        </trans-unit>
        <trans-unit id="94df2ec8cdab4e4a1c3463eb8499a5bac9b92ebf" translate="yes" xml:space="preserve">
          <source>In the call above, pBuf is a pointer to a large, contiguous chunk of memory space that SQLite will use to satisfy all of its memory allocation needs. pBuf might point to a static array or it might be memory obtained from some other application-specific mechanism. szBuf is an integer that is the number of bytes of memory space pointed to by pBuf. mnReq is another integer that is the minimum size of an allocation. Any call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc(N)&lt;/a&gt; where N is less than mnReq will be rounded up to mnReq. mnReq must be a power of two. We shall see later that the mnReq parameter is important in reducing the value of &lt;b&gt;n&lt;/b&gt; and hence the minimum memory size requirement in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;.</source>
          <target state="translated">在上面的调用中，pBuf是指向大量连续内存空间的指针，SQLite将使用该内存空间来满足其所有内存分配需求。 pBuf可能指向静态数组，也可能是从其他一些特定于应用程序的机制获得的内存。 szBuf是一个整数，它是pBuf指向的内存空间的字节数。 mnReq是另一个整数，它是分配的最小大小。N小于mnReq的对&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（N）的&lt;/a&gt;任何调用将四舍五入为mnReq。 mnReq必须为2的幂。稍后我们将看到mnReq参数对于减小&lt;b&gt;n&lt;/b&gt;的值非常重要，因此对于&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson证明中&lt;/a&gt;的最小内存大小要求也很重要。</target>
        </trans-unit>
        <trans-unit id="90165ee71034491a4c0d9359bc73082f9488de28" translate="yes" xml:space="preserve">
          <source>In the call above, pMem is a pointer to an &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object that defines the interface to the application-specific memory allocator. The &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object is really just a structure containing pointers to functions to implement the various memory allocation primitives.</source>
          <target state="translated">在上面的调用中，pMem是指向&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;对象的指针，该对象定义了特定于应用程序的内存分配器的接口。所述&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;对象实际上只是含函数指针来实现各种存储器分配的原语的结构。</target>
        </trans-unit>
        <trans-unit id="c159dc37c192a0696adfe0ed4e91dc6c74c10ae1" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="translated">在调用sqlite3_vtab_config（D，C，...）中，D参数是在其中创建虚拟表的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;，该数据库连接作为调用sqlite3_vtab_config（）的&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法的第一个参数传递。C参数是&lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;虚拟表配置选项之一&lt;/a&gt;。C后面的参数的存在和含义取决于所使用的&lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;虚拟表配置选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b10e05d68bb770ad4b44c8424ff81a8fc9e69978" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="translated">在调用sqlite3_vtab_config（D，C，...）中，D参数是在其中创建虚拟表的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;，该数据库连接作为调用sqlite3_vtab_config（）的&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法的第一个参数传递。C参数是&lt;a href=&quot;c_vtab_constraint_support&quot;&gt;虚拟表配置选项之一&lt;/a&gt;。C后面的参数的存在和含义取决于所使用的&lt;a href=&quot;c_vtab_constraint_support&quot;&gt;虚拟表配置选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="890332a4e5fd5b1fbcf7ece72dd3f24eeb42de4e" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, whenever the word &quot;column&quot; is used in the foregoing text, one can substitute &quot;indexed expression&quot; (meaning a copy of the expression that appears in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement) and everything will work the same.</source>
          <target state="translated">对于&lt;a href=&quot;expridx&quot;&gt;表达式&lt;/a&gt;的索引，每当在前面的文本中使用单词&amp;ldquo; column&amp;rdquo;时，就可以替换&amp;ldquo; indexed expression&amp;rdquo;（表示出现在&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句中的表达式的副本），并且所有内容将相同。</target>
        </trans-unit>
        <trans-unit id="d6023ff2ef6625bf825c5177040f5f9d0c7e6eaa" translate="yes" xml:space="preserve">
          <source>In the case of sqlite3changeset_start_strm(), the xInput callback may be invoked by the sessions module at any point during the lifetime of the iterator. If such an xInput callback returns an error, the iterator enters an error state, whereby all subsequent calls to iterator functions immediately fail with the same error code as returned by xInput.</source>
          <target state="translated">在sqlite3changeset_start_strm()的情况下,xInput回调可以被session模块在迭代器生命周期内的任何时候调用。如果这样的xInput回调返回错误,迭代器就会进入错误状态,所有后续对迭代器函数的调用都会立即以xInput返回的相同错误代码失败。</target>
        </trans-unit>
        <trans-unit id="2c842ccec3d83bffac0868a71bae98e55882c42d" translate="yes" xml:space="preserve">
          <source>In the cases above, the values returned by the function affects the information stored in the database file. The values of functions in CHECK constraints determines which entries are valid for a table, and functions in the WHERE clause of a partial index or in an index on an expression compute values stored in the index b-tree. If any of these functions later returns a different value, then the database might no longer be well-formed. Hence, to avoid database corruption, only deterministic functions can be used in the contexts above.</source>
          <target state="translated">在上述情况下,函数返回的值会影响数据库文件中存储的信息。CHECK约束中的函数值决定了哪些条目对表是有效的,部分索引的WHERE子句或表达式上的索引中的函数计算存储在索引b树中的值。如果这些函数中的任何一个后来返回了一个不同的值,那么数据库可能不再是良好的形式。因此,为了避免数据库损坏,在上述情况下只能使用确定性函数。</target>
        </trans-unit>
        <trans-unit id="212f1ca207fd318cb7601421ea08bad1d38b37aa" translate="yes" xml:space="preserve">
          <source>In the command-line shell, use popen() instead of fopen() if the first character of the argument to the &quot;.output&quot; command is &quot;|&quot;.</source>
          <target state="translated">在命令行shell中,如果&quot;.output &quot;命令参数的第一个字符是&quot;|&quot;,则使用popen()代替fopen()。</target>
        </trans-unit>
        <trans-unit id="bd2d277ff0771ee506fb5065fe7a06ad8e377ea0" translate="yes" xml:space="preserve">
          <source>In the current implementation of SQLite, the SQL parser only works with UTF-8 text. So if you supply UTF-16 text it will be converted. This is just an implementation issue and there is nothing to prevent future versions of SQLite from parsing UTF-16 encoded SQL natively.</source>
          <target state="translated">在当前SQLite的实现中,SQL解析器只适用于UTF-8文本。因此,如果你提供UTF-16文本,它将被转换。这只是一个实现上的问题,并不能阻止未来版本的SQLite解析UTF-16编码的SQL。</target>
        </trans-unit>
        <trans-unit id="2904f602a19479b220a87ade171425cb57484f61" translate="yes" xml:space="preserve">
          <source>In the current implementation, a table is analyzed if and only if all of the following are true:</source>
          <target state="translated">在目前的实施中,如果且仅当以下所有条件为真时,才会对表进行分析。</target>
        </trans-unit>
        <trans-unit id="f2454c76bf66b1405ea30b83fd1ca60a2a98f0ef" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">在当前实现中，由于&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt;子句而删除冲突的行时，不会调用更新挂钩。使用&lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;删除行时，也不会调用更新挂钩。本段中定义的异常可能会在将来的SQLite版本中更改。</target>
        </trans-unit>
        <trans-unit id="fb481751cd63e35f2d57a7f24a37356fd4bf25b0" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">在当前实现中，由于&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt;子句而删除冲突的行时，不会调用更新挂钩。使用&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;删除行时，也不会调用更新挂钩。本段中定义的异常可能会在将来的SQLite版本中更改。</target>
        </trans-unit>
        <trans-unit id="6c3c5dcd56d182703694f79901fe613441a9864b" translate="yes" xml:space="preserve">
          <source>In the current row, the number of times the phrase appears in the column.</source>
          <target state="translated">在当前行中,该短语在列中出现的次数。</target>
        </trans-unit>
        <trans-unit id="cee9466acdd5b62aa76761a9bf112fbd7910b30a" translate="yes" xml:space="preserve">
          <source>In the definitions of generated columns.</source>
          <target state="translated">在生成列的定义中。</target>
        </trans-unit>
        <trans-unit id="846ab6c42eae3f5d5a28f0437cb021d184a6da90" translate="yes" xml:space="preserve">
          <source>In the diagram above, initial-select means one or more non-recursive SELECT statements and recursive-select means one or more recursive SELECT statements. The most common case is for there to be exactly one initial-select and exactly one recursive-select but more than one of each is allowed.</source>
          <target state="translated">在上图中,initial-select是指一个或多个非递归SELECT语句,recursive-select是指一个或多个递归SELECT语句。最常见的情况是,初始选择和递归选择刚好各一个,但每种都允许有一个以上。</target>
        </trans-unit>
        <trans-unit id="d3116d32ea608324199d5e0469ef8b030b799865" translate="yes" xml:space="preserve">
          <source>In the diagram at the right, we show that the information that was held in user space is cleared when the lock is released. This used to be literally true for older versions of SQLite. But more recent versions of SQLite keep the user space information in memory in case it might be needed again at the start of the next transaction. It is cheaper to reuse information that is already in local memory than to transfer the information back from the operating system disk cache or to read it off of the disk drive again. Prior to reusing the information in user space, we must first reacquire the shared lock and then we have to check to make sure that no other process modified the database file while we were not holding a lock. There is a counter in the first page of the database that is incremented every time the database file is modified. We can find out if another process has modified the database by checking that counter. If the database was modified, then the user space cache must be cleared and reread. But it is commonly the case that no changes have been made and the user space cache can be reused for a significant performance savings.</source>
          <target state="translated">在右图中,我们显示了当锁被释放时,保存在用户空间中的信息会被清除。对于旧版本的SQLite来说,这曾经是字面上的事实。但更多的最新版本的SQLite将用户空间信息保留在内存中,以防在下一个事务开始时可能再次需要它。重用已经在本地内存中的信息比从操作系统磁盘缓存中转回信息或再次从磁盘驱动器中读取信息要便宜。在重用用户空间中的信息之前,我们必须首先重新获取共享锁,然后我们必须检查是否在我们没有持有锁的时候没有其他进程修改数据库文件。在数据库的第一页有一个计数器,每次数据库文件被修改时,这个计数器都会递增。我们可以通过检查该计数器来了解是否有其他进程修改了数据库。如果数据库被修改了,那么必须清除用户空间缓存,重新读取。但通常情况下,没有修改过,用户空间缓存可以重新使用,大大节省了性能。</target>
        </trans-unit>
        <trans-unit id="bc4afe67e993812e607ae27c7ab087c30151c22e" translate="yes" xml:space="preserve">
          <source>In the diagram, each of the 8 tables in the FROM clause of the query is identified by a large circle with the label of the FROM-clause term: N2, S, L, P, O, C, N1 and R. The arcs in the graph represent the estimated cost of computing each term assuming that the origin of the arc is in an outer loop. For example, the cost of running the S loop as an inner loop to L is 2.30 whereas the cost of running the S loop as an outer loop to L is 9.17.</source>
          <target state="translated">在图中,查询的FROM子句中的8张表中的每一张表都用一个大圆圈标识,并标明FROM-clause项的标签。图中的弧线表示假设弧线的原点在一个外循环中,计算每个术语的估计成本。例如,将S循环作为内循环运行到L的成本是2.30,而将S循环作为外循环运行到L的成本是9.17。</target>
        </trans-unit>
        <trans-unit id="395caf8810d6babac050840aec487ecca9bbc4bd" translate="yes" xml:space="preserve">
          <source>In the event of an operating system or power failure, the various combinations of file-system software and storage hardware available provide varying levels of guarantee as to the integrity of the data written to the file system just before or during the failure. The exact combination of IO operations that SQLite is required to perform in order to safely modify a database file depend on the exact characteristics of the target platform.</source>
          <target state="translated">在操作系统或电源故障的情况下,可用的文件系统软件和存储硬件的各种组合对故障前或故障期间写入文件系统的数据的完整性提供了不同程度的保证。为了安全地修改数据库文件,SQLite需要执行的IO操作的确切组合取决于目标平台的确切特性。</target>
        </trans-unit>
        <trans-unit id="fbf76308006177e994e0ad525f9e6c338bce580b" translate="yes" xml:space="preserve">
          <source>In the example above, all the rows for each partition are grouped together in the final output. This is because the PARTITION BY clause is a prefix of the ORDER BY clause on the overall query. But that does not have to be the case. A partition can be composed of rows scattered about haphazardly within the result set. For example:</source>
          <target state="translated">在上面的例子中,每个分区的所有记录都会在最后的输出中被归为一组。这是因为partition by子句是整体查询上的order by子句的前缀。但不一定要这样。分区可以由结果集中随意散落的行组成。比如说</target>
        </trans-unit>
        <trans-unit id="5cf1e8a43e9d63b712df3d7090fc5c9414ccb7c0" translate="yes" xml:space="preserve">
          <source>In the example above, each triple identifies the location of a token instance by rowid, column number (columns are numbered sequentially starting at 0 from left to right) and position within the column value (the first token in a column value is 0, the second is 1, and so on). Using this index, FTS5 is able to provide timely answers to queries such as &quot;the set of all documents that contain the token 'A'&quot;, or &quot;the set of all documents that contain the sequence 'Y Z'&quot;. The list of instances associated with a single token is called an &quot;instance-list&quot;.</source>
          <target state="translated">在上面的例子中,每个三元组通过rowid、列号(列号从左到右依次从0开始)和列值中的位置(列值中的第一个令牌为0,第二个为1,以此类推)来标识令牌实例的位置。利用该索引,FTS5能够及时回答诸如 &quot;包含令牌'A'的所有文档的集合&quot;,或 &quot;包含序列'Y Z'的所有文档的集合 &quot;等查询。与单个标记相关联的实例列表称为 &quot;实例列表&quot;。</target>
        </trans-unit>
        <trans-unit id="6670429b3f62749505c4b98851abdba99076dc7b" translate="yes" xml:space="preserve">
          <source>In the example above, if most purchase orders do not have a &quot;parent&quot; purchase order, then most parent_po values will be NULL. That means only a small subset of the rows in the purchaseorder table will be indexed. Hence the index will take up much less space. And changes to the original purchaseorder table will run faster since the po_parent index only needs to be updated for those exceptional rows where parent_po is not NULL. But the index is still useful for querying. In particular, if one wants to know all &quot;children&quot; of a particular purchase order &quot;?1&quot;, the query would be:</source>
          <target state="translated">在上面的例子中,如果大多数采购订单没有 &quot;父 &quot;采购订单,那么大多数parent_po值将是NULL。这意味着在采购订单表中只有一小部分的行会被索引。因此索引占用的空间将大大减少。而且对原始的purchaseorder表的更改会运行得更快,因为po_parent索引只需要更新那些parent_po不是NULL的特殊行。但是索引对于查询还是很有用的。特别是,如果想知道某个采购订单&quot;?1 &quot;的所有 &quot;子代&quot;,查询的结果是</target>
        </trans-unit>
        <trans-unit id="093d39a0dc19bc985afaed609f6ca65b1771f970" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.header on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.header off&quot; instead. (The &quot;.header off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">在上面的例子中,&quot;.header on &quot;行导致列标签被打印为输出的第一行。这意味着生成的CSV文件的第一行将包含列标签。如果不需要列标签,可以设置&quot;.header off &quot;来代替。(&quot;.header off &quot;的设置是默认的,如果之前没有打开页眉,可以省略。)</target>
        </trans-unit>
        <trans-unit id="19c364b4c4bd5bb78a54b1baeb3476ed5a370176" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.headers on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.headers off&quot; instead. (The &quot;.headers off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">在上面的例子中,&quot;.headers on &quot;行导致列标签被打印为输出的第一行。这意味着生成的CSV文件的第一行将包含列标签。如果不需要列标签,可以设置&quot;.headers off &quot;来代替。(&quot;.headers off &quot;的设置是默认的,如果之前没有打开页眉,可以省略。)</target>
        </trans-unit>
        <trans-unit id="10cd93c52fe5f9cca786dee67c9404fab91f9de8" translate="yes" xml:space="preserve">
          <source>In the example above, the window frame consists of all rows between the previous row (&quot;1 PRECEDING&quot;) and the following row (&quot;1 FOLLOWING&quot;), inclusive, where rows are sorted according to the ORDER BY clause in the window-defn (in this case &quot;ORDER BY a&quot;). For example, the frame for the row with (a=3) consists of rows (2, 'B', 'two'), (3, 'C', 'three') and (4, 'D', 'one'). The result of group_concat(b, '.') for that row is therefore 'B.C.D'.</source>
          <target state="translated">在上面的例子中,窗口框架由前一行(&quot;1 PRECEDING&quot;)和后一行(&quot;1 FOLLOWING&quot;)之间的所有行组成,包括在内,其中的行根据window-defn中的ORDER BY子句进行排序(本例中为 &quot;ORDER BY a&quot;)。例如,(a=3)行的框架由(2,'B','2'),(3,'C','3')和(4,'D','1')行组成。因此,该行的group_concat(b,'.')的结果是'B.C.D'。</target>
        </trans-unit>
        <trans-unit id="b3d6a23d97e4594c0776e73b100f4f0f95f7c245" translate="yes" xml:space="preserve">
          <source>In the example queries above, every row of the table being queried must be loaded off of the disk and examined, even if only a small percentage of the rows end up in the result. This can take a long time on a big table. To speed things up, SQLite can use an index.</source>
          <target state="translated">在上面的查询示例中,被查询表的每一条记录都必须从磁盘上加载并进行检查,即使只有一小部分记录最终出现在结果中。这在一个大表上可能会花费很长的时间。为了加快速度,SQLite可以使用索引。</target>
        </trans-unit>
        <trans-unit id="097fb65fd13aa3cb8c9440796ac79504d1b2d367" translate="yes" xml:space="preserve">
          <source>In the example, instead of a single sort of 7 elements, there are 5 sorts of one-element each and 1 sort of 2 elements for the case of fruit=='Orange'.</source>
          <target state="translated">在这个例子中,水果=='橙子'的情况下,不是单一的7个元素的排序,而是有5种各为一个元素的排序和1种2个元素的排序。</target>
        </trans-unit>
        <trans-unit id="28b65ff31e772aaf95fd7eecfcefa7c33d5a2c49" translate="yes" xml:space="preserve">
          <source>In the example, the values in the &quot;term&quot; column are all lower case, even though they were inserted into table &quot;ft&quot; in mixed case. This is because an fts4aux table contains the terms as extracted from the document text by the &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. In this case, since table &quot;ft&quot; uses the &lt;a href=&quot;fts3#tokenizer&quot;&gt;simple tokenizer&lt;/a&gt;, this means all terms have been folded to lower case. Also, there is (for example) no row with column &quot;term&quot; set to &quot;apple&quot; and column &quot;col&quot; set to 1. Since there are no instances of the term &quot;apple&quot; in column 1, no row is present in the fts4aux table.</source>
          <target state="translated">在该示例中，&amp;ldquo; term&amp;rdquo;列中的值均为小写字母，即使它们以混合大小写形式插入表&amp;ldquo; ft&amp;rdquo;中也是如此。这是因为fts4aux表包含由分&lt;a href=&quot;fts3#tokenizer&quot;&gt;词器&lt;/a&gt;从文档文本中提取的术语。在这种情况下，由于表&amp;ldquo; ft&amp;rdquo;使用&lt;a href=&quot;fts3#tokenizer&quot;&gt;简单的分词器&lt;/a&gt;，因此这意味着所有术语均已折叠为小写。另外，（例如）不存在将&amp;ldquo; term&amp;rdquo;列设置为&amp;ldquo; apple&amp;rdquo;且将&amp;ldquo; col&amp;rdquo;列设置为1的行。由于在第1列中没有术语&amp;ldquo; apple&amp;rdquo;的实例，因此fts4aux表。</target>
        </trans-unit>
        <trans-unit id="4d08492de7be0204d6bca6b75942d78b6a5e659c" translate="yes" xml:space="preserve">
          <source>In the examples above,</source>
          <target state="translated">在上面的例子中。</target>
        </trans-unit>
        <trans-unit id="de880219c17c8178404452e7a6a65a0e25a5ab03" translate="yes" xml:space="preserve">
          <source>In the examples above, the APPCOST table would be interrogated to find the edit distance coefficients. It is the presence of the &quot;edit_cost_table=&quot; parameter to the spellfix1 module name that causes editdist3() to be used in place of the built-in edit distance function. If APPCOST is an empty string, then the built-in Wagner edit-distance function is used.</source>
          <target state="translated">在上面的例子中,APPCOST表将被查询以找到编辑距离系数。正是由于spellfix1模块名中存在 &quot;edit_cost_table=&quot;参数,才导致editdist3()被用来代替内置的编辑距离函数。如果APPCOST是一个空字符串,那么就会使用内置的瓦格纳编辑距离函数。</target>
        </trans-unit>
        <trans-unit id="2400a1ee49a9dce2718b34cdfc5c379cec93c638" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;gencol&quot;&gt;生成列&lt;/a&gt;的表达式中。</target>
        </trans-unit>
        <trans-unit id="e3adc83f3d79277fad8353d570dcfc825d479731" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;.</source>
          <target state="translated">在表达&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1dc67cb87d0120f285414b41e4beb1e776521f83" translate="yes" xml:space="preserve">
          <source>In the expression part of an index on an expression.</source>
          <target state="translated">在表达式上的索引部分。</target>
        </trans-unit>
        <trans-unit id="7ff8ef765e12ede160f30458a862b4edd37cec09" translate="yes" xml:space="preserve">
          <source>In the extreme case where the columns being indexed cover all columns of the PRIMARY KEY, the index will consist of only the columns being indexed. The ex25acde example above demonstrates this. Each entry in the ex25acde index consists of only the columns a, c, d, and e, in that order.</source>
          <target state="translated">在极端的情况下,如果被索引的列覆盖了PRIMARY KEY的所有列,索引将只由被索引的列组成。上面的ex25acde例子就证明了这一点。ex25acde索引中的每个条目只由a、c、d和e列组成,顺序如下。</target>
        </trans-unit>
        <trans-unit id="f9d2f7bcd7e33c3c61f03684e92a0123ee2c50c1" translate="yes" xml:space="preserve">
          <source>In the first case, when the table does not previously exist, the table is automatically created and the content of the first row of the input CSV file is used to determine the name of all the columns in the table. In other words, if the table does not previously exist, the first row of the CSV file is interpreted to be column names and the actual data starts on the second row of the CSV file.</source>
          <target state="translated">在第一种情况下,当表之前不存在时,表会自动创建,并使用输入的CSV文件第一行的内容来确定表中所有列的名称。换句话说,如果表之前不存在,CSV文件的第一行被解释为列名,实际数据从CSV文件的第二行开始。</target>
        </trans-unit>
        <trans-unit id="8cfb2ab353eeb9931ea61c166eef50db11918f37" translate="yes" xml:space="preserve">
          <source>In the following example, the window frame for each row consists of all rows from the current row to the end of the set, where rows are sorted according to &quot;ORDER BY a&quot;.</source>
          <target state="translated">在下面的例子中,每行的窗口框架由从当前行到集合末尾的所有行组成,其中行按照 &quot;ORDER BY a &quot;进行排序。</target>
        </trans-unit>
        <trans-unit id="26a8683102e2afa132677bc118b19b0b251deeec" translate="yes" xml:space="preserve">
          <source>In the following logically equivalent formulation of the same query, the substitution of &quot;CROSS JOIN&quot; for the &quot;,&quot; means that the order of tables must be N1, E, N2.</source>
          <target state="translated">在下面相同查询的逻辑等价的表述中,用 &quot;CROSS JOIN &quot;代替&quot;,&quot;意味着表的顺序必须是N1,E,N2。</target>
        </trans-unit>
        <trans-unit id="9f7285bf84f2f7b9a693a0b5399377f6b0fc1389" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause any way it sees fit:</source>
          <target state="translated">在下面的查询中,优化器可以自由地以任何它认为合适的方式对FROM子句的表进行重新排序。</target>
        </trans-unit>
        <trans-unit id="ad3b432372161232b364559d85e3c83dbfa80ec8" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause anyway it sees fit:</source>
          <target state="translated">在下面的查询中,优化器可以自由地对FROM子句的表进行任何它认为合适的排序。</target>
        </trans-unit>
        <trans-unit id="213dce290e5c56de530174ae284660516d8c6333" translate="yes" xml:space="preserve">
          <source>In the future, this option may also disable other floating point functionality, for example the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double()&lt;/a&gt; API functions.</source>
          <target state="translated">将来，此选项可能还会禁用其他浮点功能，例如&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double（）&lt;/a&gt;，&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double（）&lt;/a&gt;，&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double（）&lt;/a&gt;和&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double（）&lt;/a&gt; API函数。</target>
        </trans-unit>
        <trans-unit id="dfaedc6be2b7553cc537d3ce90c362a4be2c9a84" translate="yes" xml:space="preserve">
          <source>In the latter query, the query plan must be &lt;a href=&quot;#option2&quot;&gt;option 2&lt;/a&gt;. Note that you must use the keyword &quot;CROSS&quot; in order to disable the table reordering optimization; INNER JOIN, NATURAL JOIN, JOIN, and other similar combinations work just like a comma join in that the optimizer is free to reorder tables as it sees fit. (Table reordering is also disabled on an outer join, but that is because outer joins are not associative or commutative. Reordering tables in OUTER JOIN changes the result.)</source>
          <target state="translated">在后一个查询中，查询计划必须是&lt;a href=&quot;#option2&quot;&gt;选项2&lt;/a&gt;。请注意，必须使用关键字&amp;ldquo; CROSS&amp;rdquo;才能禁用表重新排序优化。INNER JOIN，NATURAL JOIN，JOIN和其他类似的组合就像逗号联接一样工作，因为优化器可以根据需要自由对表进行重新排序。（在外部联接上也禁用表重新排序，但这是因为外部联接不具有关联性或可交换性。在OUTER JOIN中对表进行重新排序会更改结果。）</target>
        </trans-unit>
        <trans-unit id="db1ceb5581cb83e63561f68248a7b5044a5f4d90" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">在旧版界面中，返回值将为&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。使用&amp;ldquo; v2&amp;rdquo;界面，也可能会返回任何其他&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4f1e2e6a1b6e2882af269cc303fc56c8348c472" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">在旧版界面中，返回值将为&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;，&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;，&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;或&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。使用&amp;ldquo; v2&amp;rdquo;界面，也可能会返回任何其他&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e24ef81342a9cacce2edb83f3edc5fc97054dd2" translate="yes" xml:space="preserve">
          <source>In the previous query the fruit='Peach' constraint narrowed the result down to a single row. But the same technique works even if multiple rows are obtained. Suppose we looked up the price of Oranges instead of Peaches:</source>
          <target state="translated">在前面的查询中,fruit='Peach'约束条件将结果缩小到了一条记录。但是,即使获得多条记录,同样的技术也是有效的。假设我们查询的是橙子的价格,而不是桃子。</target>
        </trans-unit>
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">在前面的章节中,我们已经看到了如何从作为ZIP存档实现的键/值存储转移到一个只有三张表的简单SQLite数据库,可以为应用程序文件格式增加重要的功能。我们可以继续用新的表来增强模式,为了性能而添加索引,为了编程方便而添加触发器和视图,即使面对编程错误,也可以用约束来强制执行内容的一致性。进一步的增强想法包括:</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">在前文中,WHERE子句中的 &quot;type NOT IN ('object','array')&quot;项抑制了容器,只允许通过叶元素。这种方式也可以达到同样的效果。</target>
        </trans-unit>
        <trans-unit id="cbeb7859d795228eb3a3ec910c174670d8e945ef" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indexes the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and using that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">在上面的查询中，如果t1和t2都大约有N行，那么在没有任何索引的情况下，查询将需要O（N * N）时间。另一方面，在表t2上创建索引需要O（NlogN）时间，使用该索引评估查询需要额外的O（NlogN）时间。在没有&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;信息的情况下，SQLite猜测N为一百万，因此它认为构造自动索引将是更便宜的方法。</target>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">在上面的查询中，如果t1和t2都大约有N行，则没有任何索引，查询将需要O（N * N）时间。另一方面，在表t2上创建索引需要O（NlogN）时间，然后使用该索引评估查询需要额外的O（NlogN）时间。在没有&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;信息的情况下，SQLite猜测N为一百万，因此它认为构造自动索引将是更便宜的方法。</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">在上面的查询中,我们大概会将第12区的精确边界的二进制BLOB描述绑定到&quot;:边界 &quot;参数上。</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">在上面的查询中,&quot;PARTITION BY c &quot;子句将结果集分成了三个分区。第一个分区有三条c=='1'的记录。第二个分区有两行c=='三',第三个分区有两行c=='二'。</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">在上面的查询中，&amp;ldquo; a&amp;rdquo;列是GROUP BY子句的一部分，因此输出的每一行都包含&amp;ldquo; a&amp;rdquo;的不同值之一。&amp;ldquo; c&amp;rdquo;列包含在&lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum（）&lt;/a&gt;聚合函数中，因此输出列是&amp;ldquo; a&amp;rdquo;具有相同值的行中所有&amp;ldquo; c&amp;rdquo;值的总和。但是，裸列&amp;ldquo; b&amp;rdquo;的结果是什么？答案是，&amp;ldquo; b&amp;rdquo;结果将是构成聚合的输入行之一中&amp;ldquo; b&amp;rdquo;的值。问题是您通常不知道哪个输入行用于计算&amp;ldquo; b&amp;rdquo;，因此在许多情况下，&amp;ldquo; b&amp;rdquo;的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">在上面的查询中,子查询 &quot;SELECT b FROM ex2 &quot;被评估,其结果被存储在一个临时表(实际上是一个临时索引)中,允许人们使用简单的二进制搜索来确定是否存在一个值ex2.b。一旦这个表被构造出来,就会运行外部查询,并对每一条潜在的结果行进行检查,看ex1.a是否包含在临时表中。只有当检查结果为真时,才会输出该行。</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">在上面的查询中,first_name和last_name列的值将对应于满足max(salary)条件的行。</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">在修改后的查询中,由一个联合程序实现的子查询计算 &quot;a &quot;的五个最新值。这五个值从共同程序传递到外部查询中,其中&quot; expensive_function()&quot;只在应用程序关心的特定行上被调用。</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">在第二个例子中,DO UPDATE子句中的表达式是 &quot;excluded.phonenumber &quot;的形式。前缀 &quot;excluded.&quot;导致 &quot;phonenumber &quot;指的是在没有冲突的情况下本应插入的phonenumber的值。因此,upsert的效果是插入一个Alice的phonenumber,如果不存在的话,或者用新的phonenumber覆盖Alice之前的任何phonenumber。</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">在左边的序列中,第二次插入将失败。在这种情况下,字符串'0'和'0.0'被视为数字,因为它们被插入到一个数字列中,但0==0.0违反了唯一性约束。然而,右手序列中的第二个插入是有效的。在这种情况下,常量0和0.0被视为字符串,这意味着它们是不同的。</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">在外壳程序中，当用户按下Control-C时调用&lt;b&gt;sqlite_interrupt（）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">在spellfix1算法中,cFrom是用户输入的文本,cTo是数据库中存在的正确拼写文本。editdist3算法的目标是确定用户输入的文本与字典文本的接近程度。</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">在sqlite shell中,现在打印初始启动时的版本号。</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">在sqlite shell中,将 &quot;Database opened READ ONLY &quot;信息打印到stderr而不是stdout。</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">在上面的语句中,由MATCH操作符生成的FTS3游标指针被送入carray()表值函数中,而不是其预定的接收方snippet()。carray()函数将指针视为指向整数数组的指针,并逐一返回每个整数,从而泄露了FTS3游标对象的内容。由于FTS3游标对象中包含了指向其他对象的指针,所以上面的语句将是一个指针泄漏。</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">在上面的模板中,NNN代表一个整数文字,VVV代表一个字母数字标识符。这些参数的值(也称为 &quot;主机参数名 &quot;或 &quot;SQL参数&quot;)可以使用这里定义的sqlite3_bind_*()例程来设置。</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">在基础&lt;a href=&quot;fileformat2&quot;&gt;文件格式中&lt;/a&gt;，每个rowid存储为一个&lt;a href=&quot;fileformat2#varint&quot;&gt;可变长度的整数&lt;/a&gt;。这意味着小的非负rowid值比大或负rowid值占用更少的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">在这种情况下，aConstraint []。op值与&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction（）&lt;/a&gt;为FUNCTION 返回的值相同。</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">在这种情况下,可以通过在t2(c)上创建一个索引来避免使用临时b树,如下所示。</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">在这种情况下,SQLite仍然会进行一次二进制搜索,找到索引的第一个条目,其中fruit='Orange'。然后它从索引中提取rowid,并使用该rowid通过二进制搜索查找原表条目,输出原表的价格。但是数据库引擎并没有退出,而是前进到索引的下一行,对下一个 fruit='Orange'条目重复这个过程。推进到索引(或表)的下一行比进行二进制搜索的成本要低得多,因为下一行通常与当前行位于同一个数据库页面上。事实上,与二进制搜索相比,前进到下一行的成本非常便宜,所以我们通常会忽略它。所以我们对这个查询的总成本的估计是3次二进制搜索。如果输出的行数为K,表中的行数为N,那么一般情况下,做这个查询的成本与(K+1)*logN成正比。</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">在这张图中,一个SQL语句(&quot;SELECT v FROM kv WHERE k=?1&quot;)被准备了一次。然后对于每个blob,将blob键值绑定到?1参数上,并对语句进行评估,提取blob内容。</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">在这个例子中,docs.name为 &quot;report-15 &quot;的条目的docs.body字段的内容将被发送到编辑器。编辑器返回后,结果将被写回 docs.body 字段。</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">在这个例子中,demo_data.boundary字段是为了持有对象的精确边界的某种二进制表示。R*Tree索引只持有对象的轴对齐的矩形边界。R*Tree边界只是真实对象边界的近似值。所以通常情况下,R*Tree索引被用来将搜索范围缩小到一个候选对象列表,然后对每个候选对象进行更详细和昂贵的计算,以发现候选对象是否真正符合搜索标准。</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">在这个例子中,rowids不是连续的,而是有序的。SQLite通常会创建从1开始的rowids,每增加一条记录就增加一条。但是如果删除了行,序列中就会出现空白。而且如果需要的话,应用程序可以控制分配的rowid,这样就不一定会在底部插入行。但是无论发生什么,rowid总是唯一的,并且严格按照升序排列。</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">在这个例子中,t2表被用于一个子查询,以翻译t1.b列的值。如果每个表都包含N条记录,SQLite预计子查询将运行N次,因此它会认为先在t2上构造一个自动的瞬时索引,然后使用该索引来满足子查询的N个实例,这样会更快。</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">在最后这个例子中,phonebook2条目只有在新插入的值的validDate比表中已有的条目更新时才会更新。如果表已经包含了一个具有相同名称和当前validDate的条目,那么WHERE子句就会导致DO UPDATE成为无操作。</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">在后一个表中,只有一个B-Tree,它使用 &quot;word &quot;列作为键,&quot;cnt &quot;列作为数据。(技术性:低级实现实际上将 &quot;word &quot;和 &quot;cnt &quot;都存储在B-Tree的 &quot;key &quot;区域。但除非你正在看数据库文件的低级字节编码,否则这个事实并不重要)。)因为只有一个B-Tree,&quot;word &quot;列的文本在数据库中只存储一次。此外,查询特定 &quot;单词 &quot;的 &quot;cnt &quot;值只需要对主B树进行一次二进制搜索,因为 &quot;cnt &quot;值可以直接从第一次搜索找到的记录中检索,而不需要对rowid进行第二次二进制搜索。</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">在这个查询中,&quot;x轴 &quot;和 &quot;y轴 &quot;CTE定义了Mandelbrot Set将被近似的点的网格。m(iter,cx,cy,x,y)&quot;CTE中的每一行都意味着在 &quot;iter &quot;迭代之后,从cx,cy开始的Mandelbrot迭代已经到达了x,y点。本例中的迭代次数被限制为28次(这严重限制了计算的分辨率,但对于低分辨率的ASCII艺术输出来说已经足够了)。m2(iter,cx,cy)&quot;CTE保存了从点cx,cy开始时达到的最大迭代次数。最后,&quot;a(t)&quot;CTE中的每一行都保存着一个字符串,这是输出ASCII-art的单行。最后的SELECT语句只是查询 &quot;a &quot;CTE,逐行检索所有的ASCII-art行。</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">在这个模式中,每张幻灯片没有决定其在演示文稿中的顺序的页码,而是有一个唯一的整数标识符,它与幻灯片的顺序出现的位置无关。幻灯片在演示文稿中的顺序由幻灯片标识符(slideIds)列表决定,该列表以文本字符串的形式存储在VERSION表的MANIFEST列中。由于VERSION表中允许有多个条目,这就意味着同一文档中可以存储多个演示文稿。</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">在这个系统中,歌曲表中的每个条目都需要映射到专辑表中的一个条目,艺术家和专辑的组合相同。</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">这样一来,新的指针传递接口似乎解决了SQLite中从一个扩展向另一个扩展传递指针值的所有安全问题。</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">在具有第四个参数的例程中，其值是参数中的字节数。需要明确的是：该值是&lt;u&gt;字节数&lt;/u&gt;在值中，而不是字符数中。如果sqlite3_bind_text（）或sqlite3_bind_text16（）的第四个参数为负，则字符串的长度为直到第一个零终止符的字节数。如果sqlite3_bind_blob（）的第四个参数为负，则行为未定义。如果为sqlite3_bind_text（）或sqlite3_bind_text16（）或sqlite3_bind_text64（）提供了非负第四个参数，则该参数必须是字节偏移量，假定字符串以NUL终止，则NUL终止符将出现在该字节偏移处。如果任何NUL字符出现在字节偏移量小于第四个参数的值的位置，则结果字符串值将包含嵌入的NUL。涉及带有嵌入式NUL的字符串的表达式的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="f5c0b6c1ce652bbe2a9ce301182f0e17dcf5f222" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occurs at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">在具有第四个参数的例程中，其值是参数中的字节数。需要明确的是：该值是&lt;u&gt;字节数&lt;/u&gt;在值中，而不是字符数中。如果sqlite3_bind_text（）或sqlite3_bind_text16（）的第四个参数为负，则字符串的长度为直到第一个零终止符的字节数。如果sqlite3_bind_blob（）的第四个参数为负，则该行为未定义。如果为sqlite3_bind_text（）或sqlite3_bind_text16（）或sqlite3_bind_text64（）提供了非负第四个参数，则该参数必须是字节偏移量，假定字符串以NUL终止，则NUL终止符将出现在该字节偏移处。如果任何NUL字符出现在字节偏移量小于第四个参数的值的位置，则结果字符串值将包含嵌入的NUL。涉及带有嵌入式NUL的字符串的表达式的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">在truncate journal模式下,事务的提交方式是将日志文件截断为零长度,而不是像DELETE模式那样删除日志文件(DELETE模式)或将头清零(PERSIST模式)。TRUNCATE模式与PERSIST模式有相同的优点,即包含日志文件和数据库的目录不需要更新。因此,截断一个文件通常比删除它更快。TRUNCATE还有一个好处,就是它后面不需要系统调用(如:fsync())来同步更改到磁盘上。如果这样做,可能会更安全。但是在许多现代文件系统中,truncate是一个原子和同步的操作,因此我们认为truncate在面对电源故障时通常是安全的。如果你不确定TRUNCATE是否会在你的文件系统上是同步和原子的,而且你的数据库在截断操作过程中发生断电或操作系统崩溃时,对你很重要,那么你可以考虑使用不同的日记模式。</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">在3.5.9版本中,上面的查询将返回一个名为 &quot;t1.a &quot;的单列。在3.6.0版本中,列名只是 &quot;a&quot;。</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">在非常旧的SQLite版本（版本3.7.11-2012-03-20之前）中，如果有任何待处理的查询，则ROLLBACK将失败，并显示错误代码&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。在较新版本的SQLite中，ROLLBACK将继续执行，并且挂起的语句通常会中止，从而导致它们返回&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;或&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt;错误。在SQLite版本3.8.8（2015-01-16）及更高版本中，只要ROLLBACK不修改数据库架构，待处理的读取将在ROLLBACK之后继续运行。</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">换句话说,我们有一个名为 &quot;examp &quot;的数据库表,表中有两列数据,分别名为 &quot;一 &quot;和 &quot;二&quot;。现在假设我们要在这个表中插入一条记录。像这样。</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">内存数据库</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">内存数据库和共享缓存。</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">如果使用&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;打开内存数据库，则它们可以使用&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;。如果使用未经修饰的&amp;ldquo;：memory：&amp;rdquo;名称指定内存数据库，则该数据库始终具有专用缓存，并且仅对最初打开该数据库的数据库连接可见。但是，可以通过两个或多个数据库连接打开相同的内存数据库，如下所示：</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">在每个标识符名称的某处加入一个数字。</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">在库中包含一个静态字符串,响应RCS &quot;ident &quot;命令,其中包含库的版本号。</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">不兼容的变化首先被覆盖,因为它们对维护者和程序员来说是最重要的。</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">CREATE TABLE AS和简单SELECT之间的结果集列名称不一致。机票&lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">将A.Rottmann的makefile补丁合并到LIBTOOL中。</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">错误的assert（）语句已删除。入住&lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">报告了不正确的列数据类型。门票&lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87e0a937278327bb727372d43f146a781488670b" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">报告了不正确的列数据类型。门票&lt;a href=&quot;https://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">与ORDER BY DESC联接的查询结果不正确。票证&lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">使用跳过提前优化时，查询结果不正确。门票&lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">在小于&lt;a href=&quot;rowvalue&quot;&gt;value&lt;/a&gt;的小于值运算符上的结果不正确。门票&lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="b26b9e9148cbb52c34e5ac01e22c1673ec213167" translate="yes" xml:space="preserve">
          <source>Increase or decrease the seekHit value for cursor P1, if necessary, so that it is no less than P2 and no greater than P3.</source>
          <target state="translated">必要时增加或减少光标P1的seekHit值,使其不小于P2,不大于P3。</target>
        </trans-unit>
        <trans-unit id="bfb28e75251bc4d83a52b5697560b9c1115b80bf" translate="yes" xml:space="preserve">
          <source>Increase the &lt;a href=&quot;limits#max_variable_number&quot;&gt;default upper bound&lt;/a&gt; on the number of &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; from 999 to 32766.</source>
          <target state="translated">将&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;数量的&lt;a href=&quot;limits#max_variable_number&quot;&gt;默认上限&lt;/a&gt;从999增加到32766。</target>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">将默认&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;分配大小从100字节增加到128字节。</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">将默认&lt;a href=&quot;malloc#lookaside&quot;&gt;后备&lt;/a&gt;大小从512,125增加到1200,100，因为这可以提供更好的性能，同时每个连接仅增加56KB的额外内存。内存敏感的应用程序可以在编译时，启动时或运行时恢复旧的默认设置。</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">将看前缓存行的默认大小从100增加到128字节。</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">将&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt;的默认值增加到50，并确保在所有更改架构的地方都可以使用它，以强制执行语句重试。</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">将&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;扩展名的最大&amp;ldquo;范围&amp;rdquo;值从6增加到30。</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">将数据库页面的最大尺寸从32KiB增加到64KiB。</target>
        </trans-unit>
        <trans-unit id="c023946d393ce520944a7e8848356e945bf33b16" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of database files to 281 TB.</source>
          <target state="translated">将数据库文件的最大大小提高到281TB。</target>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">将&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;的最大值从30增加到62（尽管默认值保持为10）。</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">将&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;的最大值从62增加到125。</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">在发出&lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt;错误之前，请将&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;的超时从1秒增加到10秒。</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">提高了对恶意破坏数据库运行的恶意SQL的鲁棒性。</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">将&lt;a href=&quot;c3ref/vfs&quot;&gt;VFS对象&lt;/a&gt;的版本号增加到3，并添加了用于进行完全覆盖测试的新方法xSetSysCall，xGetSysCall和xNextSysCall。</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">通过P2递增一个 &quot;约束计数器&quot;(P2可以是负值或正值)。如果P1为非零,则数据库约束计数器递增(延迟外键约束)。否则,如果P1为零,则递增语句计数器(即时外键约束)。</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version = X&lt;/a&gt;递增架构版本号，其中X比上面步骤2中找到的旧架构版本号大1。</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">递增P1的值，以便&lt;a href=&quot;opcode#Once&quot;&gt;一旦&lt;/a&gt;操作码在第一次运行时就跳转。</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">增量和持续更新</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">索引B树内部单元(头0x02)。</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">索引B树叶单元(头0x0a)。</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">索引B-树叶或内部细胞。</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">内部索引 (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">索引叶 (0x0a)</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">一个给定名称的参数的索引</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">表达式上的索引</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">使用&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;命令删除索引。</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">索引可以使用&lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt;和&lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">子键列不需要索引，但是它们几乎总是有益的。返回&lt;a href=&quot;#fk_basics&quot;&gt;第1节中&lt;/a&gt;的示例，每次应用程序从列表中删除一行时，</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">名称形式为&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;的索引用于在普通表上实现&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束。</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">通过使用&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;标志第三个参数，使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;创建的单个数据库连接可以选择参与或不参与共享缓存模式。使用这些标志中的任何一个都将覆盖&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;建立的全局共享缓存模式设置。最多只能使用一个标志。如果在&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的第三个参数中同时使用了SQLITE_OPEN_SHAREDCACHE和SQLITE_OPEN_PRIVATECACHE标志，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">shm头的各个字段,除了从WAL头复制的salt值之外,都是以主机的本机字节顺序的无符号整数。盐值是WAL头的精确拷贝,并以WAL文件使用的任何字节顺序排列。整数的大小可以是8、16、32或64位。下面是shm头的各个字段的详细分解。</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">各个子项可能是单个比较表达式，例如* a = 5 *或* x&amp;gt; y *，或者它们可以是LIKE或BETWEEN表达式，或者子项可以是AND连接子项的括号列表。对每个子项进行分析，就好像它本身就是整个WHERE子句一样，以便查看该子项是否可自行索引。如果OR子句的&lt;u&gt;每个&lt;/u&gt;子项都可以单独索引，则可以对OR子句进行编码，以便使用单独的索引来评估OR子句的每个项。考虑SQLite如何为每个OR子句术语使用单独的索引的一种方法是，假设WHERE子句的重写方式如下：</target>
        </trans-unit>
        <trans-unit id="b50964dcca8f7e2d2ab55601a57f00ff964447be" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like &lt;b&gt;a=5&lt;/b&gt; or &lt;b&gt;x&amp;gt;y&lt;/b&gt; or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indexes for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">各个子项可能是单个比较表达式，例如&lt;b&gt;a = 5&lt;/b&gt;或&lt;b&gt;x&amp;gt; y&lt;/b&gt;，也可能是LIKE或BETWEEN表达式，或者子项可以是AND连接子项的括号列表。对每个子项进行分析，就好像它本身就是整个WHERE子句一样，以便查看该子项是否可自行索引。如果OR子句的&lt;u&gt;每个&lt;/u&gt;子项都可以单独索引，则可以对OR子句进行编码，以便使用单独的索引来评估OR子句的每个项。考虑SQLite如何为每个OR子句术语使用单独的索引的一种方法是，假设WHERE子句的重写方式如下：</target>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">单个虚拟表实现可能会施加其他约束。例如，某些虚拟实现可能提供只读表。或者某些虚拟表实现可能允许&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE，&lt;/a&gt;但不允许&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;。或者某些虚拟表实现可能会限制可以进行的UPDATE的种类。</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">在WHERE子句中使用OR运算符的UPDATE上的无限循环。问题在3.17.0中引入，并在大约一年后在邮件列表中报告。机票&lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">ORDER BY子句的信息存储在aOrderBy[]中。aOrderBy的每个术语都记录了ORDER BY子句的一列。</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">首次公开发布Alpha代码</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">最初发布的2.0版本。放弃了将库改名为 &quot;SQLus &quot;的想法,而保留了 &quot;SQLite &quot;的名称,并凸起了主要版本号。</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">数据库的初始大小,以页为单位</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">初始化 SQLite 库</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">初始化索引X为N-200(其中N为数据库页面的大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">初始化回调的&lt;b&gt;azColumnName []&lt;/b&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">将校验和初始化为偏移量为12的日记头中的校验和非ce值。</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">内连接可以自由地重新排序。但是,左外连接既不是换算的,也不是关联的,因此不会被重新排序。如果优化器认为外连接的左边和右边的内连接是有利的,那么可以重新排序,但是外连接总是按照它们出现的顺序进行评估。</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">将这一行插入递归表中。</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">将寄存器P2持有的整数值插入到寄存器P1持有的RowSet对象中。</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">在数据库中插入记录</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">LIMIT子句可以代替单独的OFFSET子句,指定两个用逗号分隔的标量表达式。在这种情况下,第一个表达式被用作OFFSET表达式,第二个表达式被用作LIMIT表达式。这是与直觉相反的,因为当使用OFFSET子句时,两个表达式中的第二个表达式是OFFSET,第一个表达式是LIMIT。这种偏移和限制的颠倒是有意为之的--它最大限度地提高了与其他SQL数据库系统的兼容性。然而,为了避免混淆,强烈建议程序员使用使用 &quot;OFFSET &quot;关键字的LIMIT子句形式,并避免使用带有逗号分隔偏移量的LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">这条语句没有删除 &quot;二 &quot;列小于50的记录,而只是把 &quot;一 &quot;列放在括号里 VDBE实现这条语句的程序如下。</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">默认情况下，SQLite不会提供对Unicode大小写的完全支持，而是提供了链接外部Unicode比较和转换例程的功能。应用程序可以重载内置的&lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt;整理序列（使用&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;）和内置的&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）&lt;/a&gt;，&lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#lower&quot;&gt;Lower（）&lt;/a&gt;函数（使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;）。 SQLite源代码包括执行这些重载的&amp;ldquo; ICU&amp;rdquo;扩展。或者，开发人员可以根据项目中已经包含的自己的Unicode感知比较例程编写自己的重载。</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">FTS5不使用磁盘上的单一数据结构来存储全文索引,而是使用一系列b树。每次提交一个新的事务时,一个包含提交的事务内容的新b树就会被写入数据库文件。当查询全文索引时,必须对每个b树进行单独查询,并将结果合并后再返回给用户。</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">不使用没有尾部参数的bm25(),而是可以根据每个查询配置映射到rank列的特定辅助函数,或者为FTS表设置不同的持久化默认值。</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">有些用户可能希望使用数据库触发器来保持全文索引与存储在内容表中的一组文档的最新状态,而不是分别写入全文索引和内容表。例如,使用前面例子中的表。</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">指令1在本例中尤为重要。通常情况下,Column指令会从SQLite文件条目数据中的大记录中提取列的值。指令1在瞬时表上设置了一个标志,这样Column反而会把SQLite文件条目的键当作数据来处理,从键中提取列信息。</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">指令0到4和INSERT示例一样。它们启动了主数据库和临时数据库的事务,验证了主数据库的数据库模式,并在表 &quot;examp &quot;上打开了一个读游标。注意,打开游标是为了读,而不是写。在程序的这个阶段,我们只是要扫描表,而不是改变表。稍后我们将在指令15中重新打开同一张表进行写入。</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">指令11到18实现了对所有索引记录的循环,其中的键是由指令8获取的。所有带有这个键的索引记录在索引表中都是连续的,所以我们走过它们,从索引中获取相应的表键。然后用这个表键将光标移动到表中的那一行。剩下的循环与非索引SELECT查询的循环相同。</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">指令18至23在要索引的表的每一行上实现循环。对于每个表行，我们首先在指令19中使用Recno提取该行的整数键，然后在指令20中使用Column获取&amp;ldquo; two&amp;rdquo;列的值&lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;。MakeIdxKey&lt;/a&gt;指令在21处将数据转换为&amp;ldquo; two&amp;rdquo;列中的数据（ （位于堆栈顶部）进入有效的索引键。对于单列索引，这基本上是无操作的。但是，如果对MakeIdxKey的P1操作数大于一个，则会从堆栈中弹出多个条目并将其转换为单个索引键。该&lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;实际创建索引条目的是22处的指令。IdxPut从堆栈中弹出两个元素。堆栈的顶部用作从索引表中获取条目的键。然后，将在堆栈上排第二的整数添加到该索引的整数集中，并将新记录写回到数据库文件中。请注意，如果有两个或两个以上表条目的两列具有相同的值，则同一索引条目可以存储多个整数。</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">指令19到25构造了一个新的数据库记录,将用于替换现有记录。这和我们在insert的描述中看到的代码是一样的,不再赘述。指令25执行后,堆栈是这样的。</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">指令2和3在要查询的数据库表上打开一个读游标。这与INSERT示例中的OpenWrite指令的工作原理相同,只是这次打开的游标是读而不是写。指令4和INSERT示例中一样,验证数据库模式。</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Android的编译说明&lt;a href=&quot;#compile-android&quot;&gt;如下所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">原本会导致溢出的整数算术运算,现在改用浮点运算。</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">存储为段b树节点一部分的整数值使用FTS varint格式进行编码。这种编码是类似的，但&lt;b&gt;不完全相同&lt;/b&gt;，于&lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite的varint格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60896296e2cc4f360fd103b1acf3b75080d48243" translate="yes" xml:space="preserve">
          <source>Integrity of the freelist</source>
          <target state="translated">自由职业者的诚信</target>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">该内存插槽的预期用途</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">表b树的内页没有有效载荷,所以永远不会有任何有效载荷溢出。</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">内部与外部BLOBs</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">SQLite中的内部BLOB与外部BLOB的比较</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">SQLite使用的内部模式对象可能包括以下内容。</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">内部表格</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">在内部,Geopoly以二进制格式存储多边形--SQL BLOB。下面给出了二进制格式的细节。所有的 Geopoly 界面都能接受 GeoJSON 格式或二进制格式的多边形。</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">TRIM()函数的国际化。Ticket #2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">将偏移量X的字节解释为8位无符号整数,并将该整数的值加到校验和中。</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">将寄存器P1的内容解释为一个整数。将P1值的一补存入寄存器P2中。如果P1的值是NULL,那么在P2中存储一个NULL。</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">将光标P1指向的数据解释为使用&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;指令构建的结构。（有关数据格式的其他信息，请参见&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;操作码。）从该记录中提取第P2列。如果记录中的值少于（P2 + 1），则提取NULL。</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">将寄存器P1中的值解释为一个布尔值,将该布尔值(0或1)存储在寄存器P2中。将该布尔值(0或1)存储在寄存器P2中。或者如果寄存器P1中的值是NULL,那么P3就存储在寄存器P2中。如果P4为1,则将答案反转。</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">将寄存器P1中的值解释为布尔值。将布尔值的补码存储在寄存器P2中,如果寄存器P1中的值为NULL,则在P2中存储一个NULL。如果寄存器P1中的值是NULL,那么在P2中存储一个NULL。</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">中断一个长期运行的查询</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">引入扩展错误代码,增加各种I/O错误的错误代码。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">内省SQLite数据库文件（&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;）的磁盘内容</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">直觉上,我们人类理解算法-1是最好的。每个签到可能有很少的子代(一个子代是最常见的情况),而且每个子代都可以用对数时间来测试$trunk标签。事实上,算法-1是实践中较快的选择。但是NGQP没有直观的感受。NGQP必须使用硬数学,而算法-2在数学上略胜一筹。这是因为,在没有其他信息的情况下,NGQP必须假设PLINK_I1和TAGXREF_I1这两个索引质量相同,并且具有同等的选择性。算法-2使用了TAGXREF_I1索引的一个字段和PLINK_I1索引的两个字段,而算法-1只使用了每个索引的第一个字段。由于算法-2使用了更多的索引材料,所以NGQP判断它是更好的算法是正确的。分数很接近,算法-2只是勉强领先算法-1。但算法-2在这里确实是正确的选择。</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">颠倒一个变化集</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">在应用变化集之前将其反转。这相当于在应用变化集之前,使用sqlite3changeset_invert()来反转它。在补丁集中指定这个标志是错误的。</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">在迭代变化集的同时,将变化集反转。这相当于在应用变化集之前,使用sqlite3changeset_invert()对它进行反转。在补丁集中指定这个标志是错误的。</target>
        </trans-unit>
        <trans-unit id="7bcd843ccbf3ca2b0a46090c9286f7cf70d294d4" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened.</source>
          <target state="translated">打开每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接后&lt;/a&gt;，立即调用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;，0,0）。</target>
        </trans-unit>
        <trans-unit id="ebc598ee05cff833de713e00e614680a147ad7e5" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened. This prevents application-defined functions from being used in places where an attacker might be able to surreptiously invoke them by modifying a database schema:</source>
          <target state="translated">打开每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接后&lt;/a&gt;，立即调用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;，0,0）。这样可以防止在攻击者可能会通过修改数据库架构秘密调用应用程序的地方使用应用程序定义的函数：</target>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">在与提供的语句句柄关联的数据库连接句柄上调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;进行注册，以进行解锁通知回调。如果对unlock_notify（）的调用返回SQLITE_LOCKED，则将此值返回给调用方。</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">调用一个用户函数(P4是指向定义函数的FuncDef对象的指针),P5参数取自寄存器P2和后续函数。函数的结果存储在寄存器P3中。寄存器P3不能是函数的输入之一。</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">调用一个用户函数(P4是一个指向sqlite3_context对象的指针,该对象包含一个指向要运行的函数的指针),P5参数取自寄存器P2和继任者。函数的结果存储在寄存器P3中。寄存器P3不能是函数的输入之一。</target>
        </trans-unit>
        <trans-unit id="bf8b8c1d4d822ee5f5035e452152155ef6c1caa7" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">调用一个用户函数(P4是一个指向sqlite3_context对象的指针,该对象包含一个指向要运行的函数的指针),参数取自寄存器P2和继承者。参数的数量在P4指向的sqlite3_context对象中。函数的结果存储在寄存器P3中。寄存器P3不能是函数的输入之一。</target>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">调用'merge'命令一次,参数设置为 -N,然后</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">在参数设置为N的情况下,调用'merge'命令0次或多次。</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">调用当前结果行的回调函数。</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">在 sqlite3rbu 对象指针 X 上调用 sqlite3rbu_step(X)函数一次或多次,每次调用 sqlite3rbu_step()都会执行一次 b-tree 操作,因此可能需要调用数千次才能应用完整的更新。当更新被完全应用时,sqlite3rbu_step()接口将返回SQLITE_DONE。</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">调用xValue()函数并将结果存储在寄存器P3中。</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">在一个NULL指针上调用sqlite3_finalize()是一个无害的no-op。</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">使用参数调用此编译指示等效于使用与&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;参数&lt;/a&gt;对应的第三个参数调用&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt; C接口：</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">不带参数调用此编译指示等效于调用&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; C接口。</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">SQLite的线程安全吗?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">替换为:</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">隔离与并发</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">数据库连接之间的隔离</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">SQLite中的隔离</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">每当查询计划者使用自动索引时，在&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;上发出&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt;警告。</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">如果使用&lt;a href=&quot;quirks#dblquote&quot;&gt;双引号的字符串文字，&lt;/a&gt;则在&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;上发出SQLITE_WARNING消息。</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">当sqlite_master表损坏时，发出错误而不是断言故障或空指针取消引用，以使sqlite_sequence表根页实际上是btree-index页。入住&lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">如果数据库zFrom不存在或不包含所需的兼容表,这是一个错误。</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">它不能用于将数据复制到内存数据库或从内存数据库中复制。</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">它可以处理掉表或索引时可能发生的SQLITE_LOCKED的特殊情况。</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">它可以管理线程优先级。</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">它存在,而且</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">建立用于基于目标数据库名称确定RBU真空状态数据库名称的约定是一个好主意。下面的示例代码使用&amp;ldquo; &amp;lt;target&amp;gt; -vacuum&amp;rdquo;，其中&amp;lt;target&amp;gt;是要清理的数据库的名称。</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">这是可以接受的调用&lt;b&gt;sqlite_finalize&lt;/b&gt;在虚拟机上之前&lt;b&gt;sqlite_step&lt;/b&gt;返回SQLITE_DONE。这样做会中断正在进行的操作。部分完成的变化将被回滚，并且数据库将被恢复到其原始状态（除非替代恢复算法是使用正在执行的SQL的ON CONFLICT子句选择。）的效果是一样的，如果的回调函数&lt;b&gt;sqlite_exec&lt;/b&gt;民政事务返回非零。</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">在从未传递过&lt;b&gt;sqlite_step&lt;/b&gt;的虚拟机上调用&lt;b&gt;一次sqlite_finalize&lt;/b&gt;也是可以接受的。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">也可以为FTS5创建自定义标记器。&lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;此处描述了&lt;/a&gt;用于执行此操作的API 。</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">也可以自定义 unicode61 将其视为分隔符的代码点集。可以使用 &quot;separators=&quot;选项来指定一个或多个额外的字符作为分隔符,而 &quot;tokenchars=&quot;选项可以指定一个或多个额外的字符作为标记的一部分,而不是作为分隔符。例如</target>
        </trans-unit>
        <trans-unit id="c5f2716f625be713954d4be305f323e2da4e7532" translate="yes" xml:space="preserve">
          <source>It is also possible to express this kind of simultaneous read and write on an R-Tree within a single query, for example if an UPDATE statement tries to change the value of one row of the R-Tree based on a complicated query from another row of the same R-Tree, perhaps something like this:</source>
          <target state="translated">也可以在一个查询中表达这种对R-Tree的同时读写,例如,如果一个UPDATE语句试图根据一个复杂的查询从同一R-Tree的另一行中改变R-Tree中某一行的值,也许可以这样表达。</target>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">向用于创建FTS5表的CREATE VIRTUAL TABLE语句添加类型，约束或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;声明是错误的。创建FTS5表后，可以像其他任何表一样使用&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句填充FTS5 表。像其他任何没有PRIMARY KEY声明的表一样，FTS5表具有名为rowid的隐式INTEGER PRIMARY KEY字段。</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">试图将sz或rawdata字段设置为NULL以外的任何值都是错误的。</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">将columnsize选项设置为0或1以外的任何值都是错误的。</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">第一次调用xToken()时,指定FTS5_TOKEN_COLOCATED标志是错误的。连续多次调用xToken(FTS5_TOKEN_COLOCATED),可以为单一标记指定多个同义词。同义词的数量没有限制。</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">假设游标只用于追加,所以如果游标有效,那么游标一定已经指向btree的末端,所以不会对游标进行任何修改。</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">假设按顺序向文件中写入一系列顺序的数据块比按任意顺序写入相同的数据块要快。</target>
        </trans-unit>
        <trans-unit id="b7995ee897a4d7d38d5bc734c7b7a1490089b50f" translate="yes" xml:space="preserve">
          <source>It is common for an application to invoke sqlite3_create_function() multiple times for the same SQL function. For example, if an SQL function can take either 2 or 3 arguments, then sqlite3_create_function() would be invoked once for the 2-argument version and a second time for the 3-argument version. The underlying implementation (the callbacks) can be different for both variants.</source>
          <target state="translated">一个应用程序通常会对同一个SQL函数多次调用sqlite3_create_function()。例如,如果一个SQL函数可以接受2个或3个参数,那么sqlite3_create_function()将为2个参数版本调用一次,为3个参数版本调用第二次。两个变体的底层实现(回调)可以不同。</target>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">它是通过调用sqlite3changegroup_new()来创建的。</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">更新 ZIP 存档中的单个条目很困难。更新 ZIP 存檔中的個別項目尤其困難,因為如果電腦斷電和/或在更新過程中發生故障,則不會破壞整個文件。要做到这一点并非不可能,但由于难度太大,实际上没有人这样做。相反,每当用户选择 &quot;文件/保存 &quot;时,整个ZIP存档就会被重写。因此,&quot;文件/保存 &quot;需要的时间比它应该的要长,特别是在旧硬件上。较新的机器速度更快,但在50兆字节的文件中改变一个字符会导致人们烧掉SSD上有限的50兆字节的写入寿命,这还是很麻烦的。</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">P1和P3是同一个寄存器是非法的。有时,如果P3与P2是同一个寄存器,那么实现能够避免memcpy()。</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">重要的是,所有对同一数据库文件的连接都使用相同的锁协议。如果一个应用程序使用POSIX咨询锁,而另一个应用程序使用点文件锁,那么这两个应用程序将看不到对方的锁,无法协调数据库访问,可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="4db5c3705011df2246b430e36dddd9221cec5416" translate="yes" xml:space="preserve">
          <source>It is important that the file-handle lock is upgraded directly from</source>
          <target state="translated">重要的是,文件手柄锁是直接从</target>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">需要注意的是,改变SQLite的版本可能会导致查询计划的改变。相同版本的SQLite总是会选择相同的查询计划,但如果你重新链接你的应用程序来使用不同版本的SQLite,那么查询计划可能会改变。在极少数情况下,SQLite版本变化可能会导致性能倒退。这是一个原因,你应该考虑将你的应用程序静态地链接到SQLite,而不是使用全系统的SQLite共享库,因为后者可能会在你不知情或无法控制的情况下发生变化。</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">重要的是要意识到，&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;都不会执行使用核心例程无法完成的任何操作。实际上，这些包装器仅根据核心例程来实现。</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">为了防止在写扇区时断电后数据库损坏,在回滚日志中存储扇区的所有页面是很重要的。假设第1、2、3、4页都存储在扇区1中,第2页被修改。为了将修改内容写入第2页,底层硬件还必须重写第1、3、4页的内容,因为硬件必须写入完整的扇区。如果这个写操作因断电而中断,第1、3或4页中的一个或多个页可能会留下不正确的数据。因此,为了避免数据库的持久损坏,所有这些页面的原始内容必须包含在回滚日志中。</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">理解这两种不同的 &quot;无服务器 &quot;定义很重要。当一个数据库声称自己是 &quot;无服务器 &quot;时,一定要辨别他们的意思是 &quot;经典无服务器 &quot;还是 &quot;新无服务器&quot;。</target>
        </trans-unit>
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">重要的是要验证gcov测试运行和第二个实际测试运行是否都给出了相同的输出。任何输出的差异都表明在SQLite代码中使用了未定义或不确定的行为(因此是一个bug),或者是编译器中的一个bug。请注意,在过去的十年中,SQLite在GCC、Clang和MSVC中都遇到了bug。编译器的bug虽然很少,但确实会发生,这就是为什么在已交付的配置中测试代码是如此重要。</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">我们不可能测试SQLite的每一个可能的编译时选项组合。但下面这组编译时选项是一个总是经过全面测试的配置。</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">当然，使用实际电源故障进行崩溃测试是不切实际的，因此崩溃测试是在仿真中完成的。插入了备用的&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;，该虚拟文件系统允许测试工具在崩溃后模拟数据库文件的状态。</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">如果命名的表在数据库中不存在,这并不是一个错误,如果命名的表没有PRIMARY KEY,也不是一个错误。如果命名的表没有PRIMARY KEY,也不是错误。但是,在这两种情况下都不会记录任何变化。</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">创建与现有&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;同名的表不是错误。</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">多次评估&lt;em&gt;完全相同的&lt;/em&gt; SQL语句通常没有用。通常，人们想评估类似的陈述。例如，您可能想使用不同的值多次评估INSERT语句。或者，您可能想使用WHERE子句中的不同键多次评估同一查询。为了适应这种情况，SQLite允许SQL语句包含在评估之前&amp;ldquo;绑定&amp;rdquo;到值的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。以后可以更改这些值，并且可以使用新值再次评估相同的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">在Git中找到签到的后代并非不可能。这只是困难。例如，有一个&lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow页面，&lt;/a&gt;显示用于在unix中查找签入后代的命令序列：</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">索引的每一列都不必出现在WHERE子句项中才能使用该索引。但是使用的索引列中不能有空白。因此，对于上面的示例索引，如果没有约束列c的WHERE子句，则约束列a和b的术语可以与索引一起使用，而不约束d到z的术语。同样，如果索引列位于仅受不等式约束的列的右侧，则通常将不使用（出于索引目的）。 （有关例外情况，请参见下面的&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="2de5ebb77ad1ee7c30b198dc81894f078e037a10" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. However, there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constrains column c, then terms that constrain columns a and b can be used with the index but not terms that constrain columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">索引的每一列都不必出现在WHERE子句项中才能使用该索引。但是，使用的索引列中不能有间隙。因此，对于上面的示例索引，如果没有约束列c的WHERE子句术语，那么约束列a和b的术语可以与索引一起使用，但不能约束列d到z的术语。同样，如果索引列位于仅受不等式约束的列的右侧，则通常将不使用（出于索引目的）。（有关例外情况，请参见下面的&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">从会话集中提取变更集或补丁集后，无需删除会话对象。可以将其保留在数据库句柄上，并将像以前一样继续监视已配置表上的更改。但是，如果&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;再次&lt;/a&gt;在会话对象上调用sqlite3session_changeset（）或&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;，则更改集或补丁集将包含自创建会话以来在连接上进行的&lt;em&gt;所有&lt;/em&gt;更改。换句话说，通过调用sqlite3session_changeset（）或sqlite3session_patchset（）不会重置会话对象或将其清零。</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">对于第一次事务后的事务,没有必要在数据库头中增加更改计数器。这样做往往可以节省对回滚日志和主数据库文件的第一页的写入。</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">检索数据不需要用sqlite3_column_type()指定的格式,如果要求不同的格式,数据会自动转换。如果要求使用不同的格式,数据会自动转换。</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">单个FTS查询不可能返回具有不同languageid值的行。未添加使用其他运算符（例如lid！= 5或lid &amp;lt;= 5）的WHERE子句的结果。</target>
        </trans-unit>
        <trans-unit id="0859fe8615c2125c6e219976b0af5affb3b3243b" translate="yes" xml:space="preserve">
          <source>It is not possible to &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; a STORED column. One can add a VIRTUAL column, however.</source>
          <target state="translated">不能在STORED列中&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;更改TABLE ADD COLUMN&lt;/a&gt;列。但是，可以添加一个VIRTUAL列。</target>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">不可能对存储在无内容的FTS4表中的记录进行UPDATE或DELETE。试图这样做是一个错误。</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">进入WAL模式后，无论是在空数据库上，还是使用&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;或使用&lt;a href=&quot;backup&quot;&gt;备份API&lt;/a&gt;从备份中还原，都无法更改&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;。您必须处于回滚日志模式才能更改页面大小。</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">在&lt;a href=&quot;lang_transaction&quot;&gt;多语句事务&lt;/a&gt;的中间（当SQLite不在&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;自动提交模式时&lt;/a&gt;），不能启用或禁用外键约束。尝试这样做不会返回错误；它根本没有效果。</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">不可能使用 &quot;ALTER TABLE ...ADD COLUMN &quot;语法来添加一个包含REFERENCES子句的列,除非新列的默认值是NULL。试图这样做会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">一次在多个线程中读取或修改此变量是不安全的。如果在单独的线程中同时使用&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接，&lt;/a&gt;则不安全地读取或修改此变量。打算在进程初始化过程中以及在调用任何SQLite接口例程之前，一次设置此变量，此后此变量保持不变。</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">一次在多个线程中读取或修改此变量是不安全的。如果在单独的线程中同时使用&lt;a href=&quot;sqlite3&quot;&gt;数据库连接，&lt;/a&gt;则不安全地读取或修改此变量。打算在进程初始化过程中以及在调用任何SQLite接口例程之前，一次设置此变量，此后此变量保持不变。</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">可以为同一个单词建立多个条目,只要每个条目有不同的soundslike值。注意,如果没有指定soundslike值,soundslike默认为单词本身。</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">如果要静态链接两个或多个扩展,使用基于扩展文件名的入口点名称,而不是通用的 &quot;sqlite3_extension_init &quot;入口点名称尤为重要。如果你使用通用的名称,就会出现同一个符号的多个定义,链接就会失败。</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">允许注册同一函数的多个实现,名称相同,但参数数量不同,或首选文本编码不同。SQLite将使用最接近SQL函数使用方式的实现。一个具有非负的nArg参数的函数实现比一个具有负的nArg的函数实现更匹配。一个首选文本编码与数据库编码相匹配的函数,比编码不同的函数更匹配。编码差异在UTF16le和UTF16be之间的函数比编码差异在UTF8和UTF16之间的函数匹配度更高。</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">库编译时C预处理程序符号&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;可能会覆盖此编译指示设置。下表总结了&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;预处理程序宏和temp_store编译指示的交互：</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">证明者将来的增强可能使它能够认识到某些内置函数的NULL输入始终会导致NULL答案。但是并非所有内置函数都具有该属性（例如，&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;），并且当然，证明者将永远无法推理&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">证明者将来的增强可能使它能够认识到某些内置函数的NULL输入始终会导致NULL答案。但是并非所有内置函数都具有该属性（例如，&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;），并且当然，证明者将永远无法推理&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67a29506bbefedd972fbd5d580cbf8d20601e4a4" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. However, not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">证明者将来的增强可能使它能够认识到某些内置函数的NULL输入始终会导致NULL答案。但是，并非所有内置函数都具有该属性（例如，&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;），并且当然，证明者将永远无法推理&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">可以建立一种特殊的&lt;a href=&quot;amalgamation&quot;&gt;合并方法&lt;/a&gt;，该方法可以与一组预定的SQLITE_OMIT _...选项一起使用。有关说明，请参见&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">可以在一个数据库句柄上创建多个会话对象。</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">当然,也可以扩展自定义或文件堆格式,但做起来往往要困难得多。如果添加了索引,那么所有修改相应表的应用程序代码都必须定位和修改,以保持这些索引的更新。如果增加了列,那么必须找到并修改所有访问相应表的应用代码,以考虑到新的列。</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">只要函数的两种形式的参数数量不同，就有可能具有与简单函数同名的聚合函数。例如，带有单个参数的&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max（）&lt;/a&gt;函数是一个聚合，带有两个或多个参数的&lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max（）&lt;/a&gt;函数是一个简单函数。集合函数通常也可以用作窗口函数。</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">为了SELECT DISTINCT和UNION的目的，可以使SQLite将NULL区别对待。为此，应在 &lt;code&gt;sqliteInt.h&lt;/code&gt; 源文件中更改NULL_ALWAYS_DISTINCT #define的值，然后重新编译。</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">通过在执行命令之前和之后检查&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; API 返回的值，可以判断'merge'命令是否找到了要合并的b树。如果两个值之间的差为2或更大，则执行工作。如果差异小于2，则&amp;ldquo;合并&amp;rdquo;命令为无操作。在这种情况下，至少在下一次更新FTS表之前，没有理由再次执行相同的&amp;ldquo;合并&amp;rdquo;命令。</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">可以向 &quot;t2 &quot;表写入,从而改变索引的内容。但是这样做会使 &quot;t1bc &quot;索引与其父表 &quot;t1 &quot;不同步。一个不同步的索引会导致不正确的查询结果。</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">建议应用程序通过明确地发出ROLLBACK命令来响应上述错误。如果事务已经被错误响应自动回滚,那么ROLLBACK命令就会以错误失败,但不会因此造成伤害。</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">从不同于当前正在运行数据库操作的线程的线程中调用此例程是安全的。但是，在sqlite3_interrupt（）返回之前已关闭或可能已关闭的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;中调用此例程并不安全。</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">从不同于当前正在运行数据库操作的线程的线程中调用此例程是安全的。但是，在sqlite3_interrupt（）返回之前已关闭或可能已关闭的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;中调用此例程并不安全。</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="translated">在xConflict回调中执行SQL语句是安全的,包括那些写到回调相关的表的语句。这可以用来进一步定制应用程序的冲突解决策略。</target>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">在xConflict回调中执行SQL语句是安全的,包括那些写到回调相关的表的语句。这可以用来进一步定制应用程序的冲突解决策略。</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">有时,SQLite扩展可以方便地在子组件之间或扩展与应用程序之间进行非SQL值的通信。以下是一些例子。</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">用户仍有责任确保外部内容FTS5表的内容与内容表保持一致。一种方法是用触发器来实现。例如:</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="translated">Guttman R-Tree算法的本质是，任何写入都可能从根本上重组树，并在此过程中更改节点的扫描顺序。因此，通常无法在查询R-Tree的过程中修改R-Tree。尝试执行此操作将失败，并显示&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &amp;ldquo;数据库表已锁定&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">调用该函数成功后,调用者有责任最终在*ppOut指针上调用sqlite3_free()来释放缓冲区分配。</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">调用者有责任通过将迭代器传递给&lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）&lt;/a&gt;来最终销毁该迭代器。包含变更集（pChangeset）的缓冲区必须保持有效，直到销毁迭代器为止。</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">调用者有责任通过将迭代器传递给&lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）&lt;/a&gt;来最终销毁该迭代器。包含变更集（pChangeset）的缓冲区必须保持有效，直到销毁迭代器为止。</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">的确,应用程序有时会从不受信任的来源导入完整的二进制SQLite数据库文件,这种导入可能会带来一个可能的攻击载体。然而,SQLite中的那些代码路径是有限的,并且经过了极好的测试。而且对于想要读取不受信任数据库的应用程序来说,预验证例程可以帮助在使用前检测可能的攻击。</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">如果试图在数据库中创建一个新的表,而这个表已经包含了一个同名的表、索引或视图,这通常是一个错误。但是,如果在CREATE TABLE语句中指定了 &quot;IF NOT EXISTS &quot;子句,而同名的表或视图已经存在,那么CREATE TABLE命令就没有任何效果(也不会返回错误信息)。如果因为存在索引而无法创建表,即使指定了 &quot;IF NOT EXISTS &quot;子句,仍然会返回错误信息。</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">不能在包含&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;的数据库上使用它。</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">可能是合并中出现了冲突。当同一行代码在圈(1)和圈(4)与圈(2)和圈(3)之间被以不同的方式修改时,就会发生冲突。合并命令将宣布任何冲突,并在输出中包含冲突行的两个版本。你需要调出包含冲突的文件并手动解决冲突。</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">一定不能通过在左侧有一个数值(而不是字符串或blob)来使LIKE或GLOB操作符为真。这意味着,无论是。</target>
        </trans-unit>
        <trans-unit id="48d86628c63409da486bd0d69fb891667a6d8475" translate="yes" xml:space="preserve">
          <source>It never hurts to run the VACUUM, even if you don't need it. If the database is in WAL mode, you should shutdown and reopen all database connections before continuing.</source>
          <target state="translated">即使你不需要它,运行VACUUM也不会有任何伤害。如果数据库处于WAL模式,在继续之前应该关闭并重新打开所有数据库连接。</target>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">有必要转移到3.0版本来实现这些功能,因为每个功能都需要对数据库文件格式进行不兼容的修改。其他不兼容的变化,如清理API,也是同时引入的,因为理论上最好一次就把不兼容的变化全部解决掉。</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">它适用于unicode(UTF8)文本。</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">它的主日志存在,或者主日志名称是一个空字符串,以及</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">其大小大于512字节,并且</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="translated">其超级期刊存在或超级期刊名称为空字符串,且</target>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.M.Robson。&quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;。</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON支持</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">加盟顺序</target>
        </trans-unit>
        <trans-unit id="5b92551545cdfc2e412cb3b6272639906036d3da" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indexes, though occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">联接重新排序是自动的，通常效果很好，程序员不必考虑它，特别是如果使用&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;来收集有关可用索引的统计信息，尽管有时需要程序员一些提示。例如，考虑以下架构：</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">联接重新排序是自动的，通常效果很好，程序员不必考虑它，特别是如果使用&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;来收集有关可用索引的统计信息时。但是有时需要程序员的一些提示。例如，考虑以下架构：</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">日志文件格式</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">日志头格式</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">日志记录格式</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">计算机协会杂志</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">记录数据库页面</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">编写一页日记</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">阴历日数</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">如果寄存器P1中的值为False,则跳转到P2。如果它的数值为零,则认为是false,如果P3为非零,则跳转到P2。如果P1中的数值为NULL,那么只有当P3为非零时才进行跳转。</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">如果寄存器P1中的值为NULL,则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">如果寄存器P1中的值不是NULL,则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">如果寄存器P1中的值为真,则跳转到P2。如果该值是数值且非零,则认为是真。如果P1中的值为NULL,那么只有当P3为非零时才进行跳转。</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">取决于在最新的&lt;a href=&quot;opcode#Compare&quot;&gt;比较&lt;/a&gt;指令中P1向量分别小于等于还是大于P2向量，跳转到地址P1，P2或P3的指令。</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">跳转到寄存器P1中的地址之后的下一条指令。跳转后,寄存器P1变为未定义。</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">就像有用于管理ZIP存档的&amp;ldquo; zip&amp;rdquo;程序和用于管理Tarball的&amp;ldquo; tar&amp;rdquo;程序一样，也存在用于管理SQL存档的&lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&amp;ldquo; sqlar&amp;rdquo;程序&lt;/a&gt;。&amp;ldquo; sqlar&amp;rdquo;程序能够创建新的SQLite存档，列出现有存档的内容，从存档中添加或删除文件和/或从存档中提取文件。一个单独的&amp;ldquo; sqlarfs&amp;rdquo;程序能够将SQLite存档作为&lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse文件系统&lt;/a&gt;挂载。</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">要时刻警惕自己的生活行为。</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">每天把死亡放在眼前。</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">在转换为 NUMERIC 时,保持整数的全精度(如果可能的话)。票据 #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">关键点:</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">本篇文章的主要收获。</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">原始数据库文件内容的键/值存储。键是页码,值是二进制页面内容。</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">关键字参数可以选择用引号引起来。（例如： &lt;code&gt;'yes' [FALSE]&lt;/code&gt; 。）某些编译指示将字符串文字作为参数。当pragma使用关键字参数时，通常也将使用数值等效项。例如，&amp;ldquo; 0&amp;rdquo;和&amp;ldquo;否&amp;rdquo;与&amp;ldquo; 1&amp;rdquo;和&amp;ldquo;是&amp;rdquo;含义相同。查询设置的值时，许多编译指示会返回数字而不是关键字。</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">要知道,上帝到处都能看到你。</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">左键加入</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">LEFT JOIN消除经常出现的情况是在视图里面使用LEFT JOIN,然后视图在使用时,LEFT JOIN的右侧表的列都没有引用。</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">LEFT JOIN强度降低优化</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">实现了LEFT OUTER JOIN,但没有实现RIGHT OUTER JOIN或FULL OUTER JOIN。</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">喜欢优化</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">LIKE优化现在适用于带有 COLLATE NOCASE 的列。</target>
        </trans-unit>
        <trans-unit id="7bf74f2615b51b60a0f37ad079a71016710bd256" translate="yes" xml:space="preserve">
          <source>LIKE(</source>
          <target state="translated">LIKE(</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0现在不显示行。使用LIMIT-1可以看到所有的行。</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0现在适用于子查询</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">大型WAL文件</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">最后一次插入Rowid</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">后来,SQLite 3.6.16版本发布,如图中圆圈(4)所示。在这一点上,私有分支维护者做了一个合并,把从(1)到(4)的所有变化都应用到(3)中。结果是版本(5),也就是SQLite 3.6.16加上编辑。</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">前面的空格被去掉了。</target>
        </trans-unit>
        <trans-unit id="e52b8a48a53a875ca174a915ae5c47d6e94c2665" translate="yes" xml:space="preserve">
          <source>Leading zeros are handled properly, in the sense that they do not mess of the maginitude comparison of embedded strings of digits. &quot;x00123y&quot; is equal to &quot;x123y&quot;.</source>
          <target state="translated">前导零的处理是正确的,在某种意义上说,它们不会扰乱内嵌数字串的磁力比较。&quot;x00123y &quot;等于 &quot;x123y&quot;。</target>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">叶子有效载荷分数。必须是32。</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">左操作数</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">找到左操作数</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">左对齐输出中的值。默认情况下是右对齐。如果宽度为零,或者小于被替换的值的长度,那么就没有填充,&quot;-&quot;标志是不行的。</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">旧版本(比3.22.0旧)的session模块不能捕获对sqlite_stat1表的修改。旧版本的sqlite3changeset_apply()函数会默默地忽略任何对sqlite_stat1表的修改,这些修改是变化集或补丁集的一部分。</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">Lemon没有自己的源码库。相反,Lemon由SQLite源代码树中的几个文件组成。</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">Lemon生成LALR（1）解析器。它的操作类似于更熟悉的工具&lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;，但是Lemon增加了重要的改进，包括：</target>
        </trans-unit>
        <trans-unit id="e082b356dc26d0aea289ce00e7ec084aced6cb66" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. Its operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">Lemon生成LALR（1）解析器。它的操作类似于更熟悉的工具&lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;，但是Lemon增加了重要的改进，包括：</target>
        </trans-unit>
        <trans-unit id="efedecd644b64990e1efae314b3426de6b60b11e" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; token. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">Lemon有一个 &quot;后备 &quot;标记的概念。SQL语言中包含大量的关键字,这些关键字有可能与标识符名称发生碰撞。Lemon有能力指定一些关键字有能够 &quot;回落 &quot;到一个标识符。如果关键字出现在输入令牌流中,否则会出现语法错误的上下文,那么在语法错误产生之前,令牌会自动转化为其回退。这个特性使得解析器对用作标识符的保留词非常宽容,这也是SQL语言中经常出现的问题。</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">Lemon有一个 &quot;后备 &quot;标记的概念。SQL语言中包含大量的关键字,这些关键字有可能与标识符名称发生碰撞。Lemon有能力指定一些关键字有能够 &quot;回落 &quot;到一个标识符。如果关键字出现在输入令牌流中,否则会出现语法错误的上下文,那么在语法错误产生之前,该令牌会自动转化为其回退。这个特性使得解析器对用作标识符的保留词非常宽容,这也是SQL语言中经常出现的问题。</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">Lemon有一个非终端析构器的概念,它可以用来在语法错误或其他中止的解析后回收内存或其他资源。</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">Lemon还用于为&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;扩展中的查询模式表达式生成解析。在这种情况下，输入语法文件是&lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81b122bf1a51d71a58a32df85cf2293735051ebd" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate the parser for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">Lemon还用于在&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;扩展中为查询模式表达式生成解析器。在这种情况下，输入语法文件是&lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">Lemon在SQLite中的两个地方使用。</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemon支持对语法文件规则进行有条件的编译,这样就可以根据编译时的选项生成不同的解析器。</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Lemon是由D.Richard Hipp(也是SQLite的创建者)在1987年到1992年期间在杜克大学读研究生时原创的。Lemon最初的创建日期已经丢失,但可能是1990年左右的某个时间。Lemon生成了一个LALR(1)解析器。曾有配套的LL(1)解析器生成工具名为 &quot;Lime&quot;,但Lime的源代码已经丢失。</target>
        </trans-unit>
        <trans-unit id="c14807b5c54c06b6f5e4f638f48d2b24a5f7168b" translate="yes" xml:space="preserve">
          <source>Lemon was originally written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was a companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Lemon最初是由D.Richard Hipp(也是SQLite的创建者)在1987年到1992年期间在杜克大学读研究生时编写的。Lemon最初的创建日期已经丢失,但可能是1990年左右的某个时间。Lemon生成了一个LALR(1)解析器。曾经有一个配套的LL(1)解析器生成工具,名为 &quot;Lime&quot;,但Lime的源代码已经丢失。</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">长度规格</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">更少的管理意味着程序员将更多的时间用在软件上(在这里是SQLite),而不是在版本控制系统上大费周章。</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">少用内存</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">设K为M+((P-M)%(U-4))。</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">让X为((U-12)*64/255)-23。如果有效载荷大小P小于或等于X,那么整个有效载荷都存储在b树页上。让M为((U-12)*32/255)-23,让K为M+((P-M)%(U-4))。若P大于X,则索引b树页上存储的字节数为K,若K小于或等于X,否则为M。索引页上存储的字节数永远不会小于M。</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">让X为U-35。如果有效载荷大小P小于或等于X,那么整个有效载荷都存储在b树叶页上。让M为((U-12)*32/255)-23,让K为M+((P-M)%(U-4))。若P大于X,则表b树叶页上存储的字节数为K,若K小于或等于X,否则为M。叶页上存储的字节数永远不会小于M。</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">令X为部分索引的WHERE子句中的表达式，令W为使用索引表的查询的WHERE子句。然后，如果W&amp;rArr;X，则允许查询使用部分索引，其中&amp;rArr;运算符（通常发音为&amp;ldquo; implies&amp;rdquo;）等于&amp;ldquo; X or not W&amp;rdquo;的逻辑运算符。因此，确定部分索引在特定查询中是否可用减少了证明一阶逻辑的定理。</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">让X是最大的连续整数集{h,h+1,h+2,...,h+N},这样对于X中的每一个j,aPgno[j%8192]!=0.如果aPgno[h%8192]==0,X集将是空的。 X集很容易计算,从值h%8192开始,将h%8192加到X中,然后递增h,直到遇到第一个aPgno[h%8192]条目为零。</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">让数据库的页面大小(日记头偏移量24处的整数值)为N,那么页面记录的格式如下。</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">让数据类型 &quot;u8&quot;、&quot;u16 &quot;和 &quot;u32 &quot;分别表示长度为8、16和32位的无符号整数。那么,shm文件的第一个32768字节的单元组织如下。</target>
        </trans-unit>
        <trans-unit id="35d97b78e6396cb7e0d5fdc8a5a3051973e7dd0f" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. Because there are only 2 alice and bob nodes each, the inner loop only has to run four times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">设alice节点的数量为M,bob节点的数量为N,考虑两种情况。在第一种情况下,M和N都是2,但每个节点上有数千条边。在这种情况下,首选方案1。在方案1下,内循环检查一对节点之间是否存在边缘,如果发现就输出结果。因为alice和bob节点各只有2个,所以内循环只需要运行4次,查询速度非常快。方案2在这里需要的时间会更长。方案2的外循环只执行两次,但是因为每个alice节点有大量的边离开,所以中间的循环要迭代很多千次。速度会慢很多。所以在第一种情况下,我们更倾向于使用方案1。</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">设alice节点的数量为M,bob节点的数量为N,考虑两种情况。在第一种情况下,M和N都是2,但每个节点上有数千条边。在这种情况下,首选方案1。在方案1下,内循环检查一对节点之间是否存在边缘,如果发现就输出结果。但是由于alice和bob节点各只有2个,所以内循环只需要运行4次,查询速度非常快。方案2在这里需要的时间会更长。方案2的外循环只执行两次,但是因为每个alice节点有大量的边离开,所以中间的循环要迭代好几千次。速度会慢很多。所以在第一种情况下,我们更倾向于使用方案1。</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">让日记头中偏移量8处的页数值为M,如果M大于零,那么在M页记录后,日记文件可能会被零填充到扇区大小的下一个倍数,然后插入另一个日记头。同一日记本中的所有日记本头必须包含相同的数据库页面大小和扇区大小。</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">让我们假设你使用的是合并源码。将基线添加到你的项目中,如下所示。</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">假设OpenDocument没有使用ZIP存档来存储文件,而是使用了一个非常简单的SQLite数据库,其单表模式如下。</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">让我们使用下面的记法(与罗布森的记法相似但不相同)。</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">让我们成为现实。很少有人会严重质疑Git提供次佳的用户体验。许多底层实现都显示在用户界面中。界面是如此糟糕，以至于甚至有一个模仿网站都会生成&lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;伪造的git手册页&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">让我们再仔细看看这里发生了什么。第一个SELECT是由指令5到10的循环实现的。指令5通过重绕其光标来初始化循环。指令6从 &quot;examp &quot;中提取 &quot;two &quot;列的值,指令7将其转换为行。指令8将一个空字符串推到堆栈中。最后,指令9将该行写入临时表。但是请记住,PutStrKey操作码使用栈顶作为记录数据,栈上的下一个作为键。对于INSERT语句来说,MakeRecord操作码生成的行是记录数据,记录键是NewRecno操作码创建的整数。但是这里的角色是相反的,MakeRecord创建的行是记录键,记录数据只是一个空字符串。</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">用C语言编写的库没有巨大的运行时依赖性。在其最低配置中,SQLite只需要标准C库中的以下例程。</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">用C++或Java编写的库一般只能被用同一种语言编写的应用程序使用。要让一个用Haskell或Java编写的应用程序调用一个用C++编写的库是很困难的。另一方面,用C语言编写的库可以从任何编程语言中调用。</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">库大小优化。</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">像--file一样，将文件FILE用作存档，但是使用&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt;打开文件，以便在FILE已经存在的情况下将存档附加到FILE的末尾。</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">与无内容表一样,外部内容表不支持REPLACE冲突处理。任何指定REPLACE冲突处理的操作都会使用ABORT处理。</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">像其他虚拟表类型一样，使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句创建新的FTS表。在USING关键字之后的模块名称为&amp;ldquo; fts3&amp;rdquo;或&amp;ldquo; fts4&amp;rdquo;。虚拟表模块自变量可以保留为空，在这种情况下，将创建带有单个用户定义列名为&amp;ldquo; content&amp;rdquo;的FTS表。可选地，可以向模块自变量传递以逗号分隔的列名称的列表。</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">和sqlite3rbu_step()一样,如果真空操作已经完成,sqlite3rbu_close()返回SQLITE_DONE。如果真空操作没有完成,但没有发生错误,则返回SQLITE_OK。或者,如果发生了错误,则返回一个SQLite错误代码。如果在之前调用sqlite3rbu_step()的过程中发生了错误,sqlite3rbu_close()将返回相同的错误代码。</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">与&quot;.dump &quot;命令一样,&quot;.recover &quot;试图将数据库文件的全部内容转换为文本。不同的是,&quot;.recover &quot;不是使用正常的SQL数据库接口读取数据,而是试图根据直接从尽可能多的数据库页面中提取的数据来重新组合数据库。如果数据库已经损坏,&quot;.recover &quot;通常能够从数据库所有未损坏的部分恢复数据,而&quot;.dump &quot;则在遇到第一个损坏迹象时停止。</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">极限设置</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">限制&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;生成的输出量。</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">限制JSON对象和数组的递归深度，以避免递归下降解析器中过多的堆栈使用。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64（）&lt;/a&gt;接口限制SQLite将分配的最大内存量。这有助于防止拒绝服务攻击。要找出应用程序实际需要多少堆空间，请对典型输入运行该堆空间，然后使用&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;接口测量最大瞬时内存使用量。将硬堆限制设置为观察到的最大瞬时内存使用量加上一些余量。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">限制和注意事项</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">OpenDocument演示格式的局限性</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">SQLite中的限制</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">以 &quot;#&quot;开头的行和不在SQL语句中间的行被解释为注释。</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">将SQLite与一个测试程序进行链接,该程序运行约30,000条代表典型工作负载的SQL语句。</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">2006-06-27,Linus Torvalds在Git邮件列表中用不同的词来表达同样的意思。</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">常量清单:</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">功能清单:</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">对象列表:</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">PRAGMAs清单</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">SQLite常量列表</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">SQLite函数列表</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">SQLite对象列表</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">虚拟表列表</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">在处理过程中列出每个文件。</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">列出归档的内容,如果没有指定参数,则列出所有文件。如果没有指定参数,则列出所有文件。否则,只有那些指定为参数的文件才会被列出。目前,--verbose选项不会改变此命令的行为。将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">列出存档中的文件。</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">IN右侧的列表值被视为必须具体化的子查询。换句话说,前一条语句的行为就像。</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">下面列出了一些情况下,可能有意义的添加额外的soundlike条目。具体的条目将取决于应用程序和目标语言。</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">心甘情愿地聆听圣洁的读书声。</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">字面值(常量)</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="translated">字符串不包含字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">字面价值</target>
        </trans-unit>
        <trans-unit id="402377f4fa54f586c7bcf70486179fb514f52098" translate="yes" xml:space="preserve">
          <source>Literal values: numeric or string constants.</source>
          <target state="translated">字面值:数字或字符串常量。</target>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">LoC建议的存储格式</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">加载延长线</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">将表之间的差异加载到一个会话中。</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">在计算差异之前，将共享库或DLL文件LIBRARY加载到SQLite中。这可用于添加架构所需的应用程序定义的&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">可加载的扩展通克</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">可加载的扩展是C代码。要在大多数类似unix的操作系统上编译它们,通常的命令是这样的。</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">本地删除</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">本地插入</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">本地更新</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">当地时间修改器</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">锁名</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">锁定偏移</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="translated">锁定光标P1所指向的btree,使其他光标无法写入btree。</target>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">锁定和并发</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">锁定和并发控制由&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;寻呼机模块&lt;/a&gt;处理。传呼机模块负责使SQLite成为&amp;ldquo; ACID&amp;rdquo;（原子，一致，隔离和持久）。分页器模块确保所有更改都立即发生，或者所有更改都发生，或者所有更改都没有发生，两个或多个进程不会尝试以不兼容的方式同时访问数据库，并且一旦写入更改，它们坚持到明确删除为止。分页器还提供磁盘文件某些内容的内存缓存。</target>
        </trans-unit>
        <trans-unit id="ed7186a4521b0a419cc417d0bc8ed17722029057" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">锁定和并发控制由&lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;寻呼机模块&lt;/a&gt;处理。传呼机模块负责使SQLite成为&amp;ldquo; ACID&amp;rdquo;（原子，一致，隔离和持久）。分页器模块确保所有更改都立即发生，或者所有更改都发生，或者所有更改都没有发生，两个或多个进程不会尝试以不兼容的方式同时访问数据库，并且一旦写入更改，它们就可以坚持到明确删除为止。分页器还提供了磁盘文件某些内容的内存缓存。</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">多头期权</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">长期支持</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">长式和短式可以混合选择。例如,以下是等价的:</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">更长的答案：如果您将表的某列声明为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，则每当您在表的该列中插入NULL时，该NULL都会自动转换为一个整数，该整数比该列的最大值大1表中的所有其他行；如果表为空，则为1。或者，如果正在使用最大的现有整数键9223372036854775807，则随机选择一个未使用的键值。例如，假设您有一个像这样的表：</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">新&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接的&lt;/a&gt;后备缓冲区分配。</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">旁观者内存分配器</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">大量的BUG修复。</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">很多小bug的修复。</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">爱惜贞操。</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">爱吃斋。</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">爱你的敌人。</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">爱你的小辈们。</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">数据库文件的低级控制</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">低级系统错误代码</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">最低优先级(最松散的分组)。</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1e549c8c539e5dd3fb33fffd4ca9bec2df1c3d6b" translate="yes" xml:space="preserve">
          <source>M &amp;amp;times 2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</source>
          <target state="translated">M＆times 2 &lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">M总是((U-12)*32/255)-23。</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">MASK位0x02被设置。</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="b4455dc80d567e0a3665a73367ed14020b1b8091" translate="yes" xml:space="preserve">
          <source>MATCH(</source>
          <target state="translated">MATCH(</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Mac类似于unix,但它们并不遵循通常的共享库惯例。要在Mac上编译一个共享库,请使用类似这样的命令。</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">在API函数&lt;b&gt;const中&lt;/b&gt;选择参数。这应该是完全向后兼容的。</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">使&lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop模糊器&lt;/a&gt;成为SQLite &lt;a href=&quot;testing&quot;&gt;测试策略&lt;/a&gt;的标准部分。</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">使CACHE_SIZE pragma持久化。</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">神奇的数字。0x377f0682 或 0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">维持100％的MC / DC既费力又费时。对于典型的应用程序而言，维持全覆盖测试所需的精力水平可能并不划算。但是，我们认为完全覆盖的测试对于像SQLite这样&lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;广泛部署的&lt;/a&gt;基础结构库是有道理的，尤其是对于数据库库，由于其本质，它可以&amp;ldquo;记住&amp;rdquo;过去的错误。</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">维护SQLite的私有分支</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">使&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt;响应&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">在WinCE中把AreFileApisANSI()作为一个无操作的宏,因为WinCE不支持这个函数。</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">使命令行shell的CSV(逗号分隔值)输出更符合公认的做法。</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">让LIMIT在复合SELECT语句上工作。</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">将寄存器P1...P1+P3复制到寄存器P2...P2+P3中。</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">排序时要区分数字值和文本值。文本值根据memcmp()进行排序。数字值按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">将寄存器P1浅层复制到寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">尽力分配一个新的页面。只有在不可能分配新页面的情况下才返回NULL。</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">在太阳落山之前,与你的对手和平相处。</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">即使使用降序索引实现DISTINCT运算符，也请确保ORDER BY将行按升序排列。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">确保在外壳中的&lt;b&gt;.dump&lt;/b&gt;命令的输出中在对应的TABLE之后创建VIEW 。</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">确保所有单独的数据库文件都有一个EXCLUSIVE锁和一个有效的日志。</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">确保所有的回滚日志数据已经实际写入磁盘表面(而不仅仅是保存在操作系统或磁盘控制器的缓存中),这样如果发生电源故障,数据在电源恢复后仍然存在。</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">确保INSERT的VALUES子句中的函数表达式是正确的。</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">确保数据库文件名遵循8+3的文件名格式,并且没有空名或扩展名。换句话说,数据库文件名的基本名称必须包含1到8个字符,扩展名必须包含1到3个字符。不允许使用空白的扩展名。</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">确保当一个连接阻塞在一个RESERVES锁上时,它能够在锁被释放后继续。(Ticket #3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">确保单个语句中来自多个触发器的&lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata（）&lt;/a&gt;值不会相互干扰。票证&lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">如果缓冲区大小小于1，请确保&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;接口不会使缓冲区零终止。票号＃2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">确保MIN()和MAX()优化在子查询中工作。</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">确保ORDER BY LIMIT优化（从签入&lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;）与INTEGER PRIMARY KEY上的IN运算符一起使用。修复票务&lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96C1454C&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">确保TCL语言接口在64位机器上与64位整数正确工作。</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">如果malloc()失败,请确保内存后端响应理智。</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">确保查询优化器检查复合SELECT语句的所有术语的依赖性。Ticket #2640.</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">确保你在每条SQL命令的结尾处输入一个分号!sqlite3程序会在你的SQL命令完成时寻找分号。sqlite3程序会寻找分号来知道你的SQL命令何时完成。如果你省略了分号,sqlite3会给你一个继续提示,并等待你输入更多的文本添加到当前的SQL命令中。这个功能允许你输入跨越多行的SQL命令。例如</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">让这个脚本可以执行,并把它放在你的$PATH上。然后编译 kvtest 程序如下。</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">再把 &quot;AS &quot;这个关键词变成可选的。</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">使用&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;选项进行编译时，使&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;成为标准构建的一部分。</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">使GLOB和LIKE运算符成为可以被程序员覆盖的函数。例如,可以将LIKE运算符改为区分大小写。</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">使LIMIT子句对子查询有效。(虽然ORDER BY仍然不能工作。)</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">让库的线程安全。(代码是存在的,似乎可以工作,但没有强调。)</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">使 os.h 头文件在检测何时为 Windows 编译和何时为 Unix 编译时更加强大。</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">在Windows &lt;a href=&quot;vfs&quot;&gt;VFS中&lt;/a&gt;使用OVERLAPPED 可以避免某些系统调用，从而提高性能。</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">在适当的地方，使用&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;中的一遍UPDATE和DELETE查询计划。</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Makefile更新</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Makefile更新和杂项错误修复。</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">A.Rottmann的Makefile更新。</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">进行其他类型的表模式更改</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="translated">SQLite转换为UTF-16字节顺序标记的畸形UTF-8被嵌入到插入FTS3表中的SQL字符串文字值的开头。</target>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">畸形数据库测试</target>
        </trans-unit>
        <trans-unit id="aa578a91aad5dc4dab2da9a4bac602790d836ae2" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement (an ALTER TABLE that tries to rename a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; into one of its own &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;) causes an infinite loop and denial of service. &lt;a href=&quot;https://sqlite.org/src/info/eca0ba2cf4c0fdf7&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句（试图将&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;重命名为其自身的&lt;a href=&quot;vtab#xshadowname&quot;&gt;影子表&lt;/a&gt;之一的ALTER TABLE ）会导致无限循环和拒绝服务。&lt;a href=&quot;https://sqlite.org/src/info/eca0ba2cf4c0fdf7&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3505da2486b779eca8455a74c0a2213782342dc" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/1bc783da63d58b05&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句导致NULL指针取消引用和拒绝服务&lt;a href=&quot;https://www.sqlite.org/src/info/1bc783da63d58b05&quot;&gt;（详细信息）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b3de4ef5153133c67b1a8788b48babe0af12634" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/862974312edf00e9&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意的SQL语句会导致NULL指针取消引用和拒绝服务。&lt;a href=&quot;https://www.sqlite.org/src/info/862974312edf00e9&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f05b51d00c5136f9765e2a5529ff25dd76521560" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/a80f84b511231204&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句会导致NULL指针取消引用，并导致&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表&lt;/a&gt;扩展和拒绝服务。仅当部署了可选的&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表&lt;/a&gt;扩展名时才可能这样做，而在默认版本中则不是这种情况。&lt;a href=&quot;https://www.sqlite.org/src/info/a80f84b511231204&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3223f276a85bbea2e40f22c66ab04105f353da0b" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/cc0fb00a128fd077&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句导致&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表&lt;/a&gt;扩展和拒绝服务中的NULL指针取消引用。仅当部署了可选的&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表&lt;/a&gt;扩展名时才可能这样做，而在默认版本中则不是这种情况。&lt;a href=&quot;https://www.sqlite.org/src/info/cc0fb00a128fd077&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be787da663e373d3f7997d1441cd2ca035e3495f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read access to a NULL pointer and denial of service. &lt;a href=&quot;https://www.sqlite.org/src/info/7a5279a25c57adf1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句导致对NULL指针的读取访问和拒绝服务。&lt;a href=&quot;https://www.sqlite.org/src/info/7a5279a25c57adf1&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b7808ef1d93533f98b34a6af3e305d6a4a79902" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read of a NULL pointer in the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, resulting in denial of service. &lt;a href=&quot;https://sqlite.org/src/info/a4dd148928ea65bd&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句导致&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;扩展的&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt; SQL函数中读取NULL指针，从而导致拒绝服务。&lt;a href=&quot;https://sqlite.org/src/info/a4dd148928ea65bd&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb5500a4c4534dd4662f8932a169f8e6f4053c24" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/4374860b29383380&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句使用未初始化的指针和拒绝服务&lt;a href=&quot;https://www.sqlite.org/src/info/4374860b29383380&quot;&gt;（详细信息）&lt;/a&gt;导致读取</target>
        </trans-unit>
        <trans-unit id="08a51de55d02f39c503f43bf8dbb67b4a981750f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/af4556bb5c285c08&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句使用未初始化的指针和拒绝服务进行读取。&lt;a href=&quot;https://www.sqlite.org/src/info/af4556bb5c285c08&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f420ed40458097230e18bc609dc3d6070a139e7" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free memory error. &lt;a href=&quot;https://sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句会导致只读的使用后使用内存错误。&lt;a href=&quot;https://sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c7315e30c332568a87d33624f52296d256dba71" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free, possibly resulting in a incorrect output from the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension. There is no known way to exfiltrate data or crash the application using this bug. &lt;a href=&quot;https://sqlite.org/src/info/0d69f76f0865f962&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句导致只读的使用后释放，可能导致&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;扩展的&lt;a href=&quot;fts3#snippet&quot;&gt;snippet（）&lt;/a&gt; SQL函数的输出不正确。没有已知的方法可以使用此错误来泄漏数据或使应用程序崩溃。&lt;a href=&quot;https://sqlite.org/src/info/0d69f76f0865f962&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="605174f0d56c0319ea8c88e54fd141ec899039f3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a uninitialized pointer reference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/e2bddcd4c55ba3cb&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句导致未初始化的指针引用和拒绝服务。&lt;a href=&quot;https://www.sqlite.org/src/info/e2bddcd4c55ba3cb&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a3d15a3efb587f7e5d31ca19ff99f19bff90311" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an read past the end of a heap buffer. &lt;a href=&quot;https://sqlite.org/src/info/8f157e8010b22af0&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意的SQL语句导致读取超出了堆缓冲区的末尾。&lt;a href=&quot;https://sqlite.org/src/info/8f157e8010b22af0&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3460af9ab9b12af9da67324f2da63f63e80a6848" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/cba2a2a44cdf138a&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句导致未初始化的指针读取和服务拒绝。&lt;a href=&quot;https://www.sqlite.org/src/info/cba2a2a44cdf138a&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b341edff7ed671940a8d972691c324a8c7d62137" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/timeline?r=better-error-handling-1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">恶意SQL语句导致未初始化的指针读取和服务拒绝。&lt;a href=&quot;https://www.sqlite.org/src/timeline?r=better-error-handling-1&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be80211b17a199f937f0a9b644dfd18f1e2cecb3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes read-only use-after-free of memory allocation if SQLite is compile with -DSQLITE_DEBUG. Does not affect release builds. &lt;a href=&quot;https://www.sqlite.org/src/info/4722bdab08cb1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">如果SQLite是使用-DSQLITE_DEBUG编译的，则恶意的SQL语句将导致内存分配的只读使用后释放。不影响发布版本。&lt;a href=&quot;https://www.sqlite.org/src/info/4722bdab08cb1&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="90aacfe82b6d869ef75232c639a3bc16d905426f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement involving the printf() SQL function results in an integer overflow which can overwrite the stack with over 2 billion bytes of 0x30 or 0x20 (ASCII '0' or ' '). Even though this is a stack overwrite, there is no known way to redirect control or otherwise escalate the level of harm. This is a denial-of-service attack only. &lt;a href=&quot;https://www.sqlite.org/src/info/23439ea582241138&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">涉及printf（）SQL函数的恶意SQL语句导致整数溢出，该溢出可能会用超过20亿个字节的0x30或0x20（ASCII'0'或''）覆盖堆栈。即使这是堆栈覆盖，也没有已知的方法来重定向控制或以其他方式升级危害级别。这仅是一种拒绝服务攻击。&lt;a href=&quot;https://www.sqlite.org/src/info/23439ea582241138&quot;&gt;（细节）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">从命令行管理SQLite档案</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">支持Manifest Typing和BLOB。</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">支持Manifest typing和BLOB。</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">使用CROSS JOIN手动控制查询计划。</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">使用SQLITE_STAT表手动控制查询计划。</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">许多SQLITE_OMIT_宏插入,在编译时省略功能,减少库的占用。</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">许多SQLite函数都会从这里显示的集合中返回一个整数结果代码,以表示成功或失败。</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">在SQLite中,很多小的查询都是高效的</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">许多应用程序在关闭时通过调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;破坏其&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。或者，例如，使用SQLite作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式的应用程序&lt;/a&gt;可能会响应于File / Open菜单操作而打开&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;，然后响应于File / Close菜单而销毁相应的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">许多应用程序使用SQLite作为来自企业RDBMS的相关内容的缓存。这减少了延迟,因为现在大多数查询都是针对本地缓存进行的,避免了网络往返。它还降低了网络和中央数据库服务器的负载。在许多情况下,这意味着客户端应用程序可以在网络中断期间继续运行。</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">许多代码简化和模糊的错误修复，以支持提供&lt;a href=&quot;testing#coverage&quot;&gt;100％的分支测试覆盖率&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">许多文件更新</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">在&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;子目录的SQLite源代码树中可以看到许多完整且可用的可扩展扩展的示例。该目录中的每个文件都是一个单独的扩展名。文档由文件的标题注释提供。这是&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;子目录中一些扩展的简要说明：</target>
        </trans-unit>
        <trans-unit id="8839fb36ad323ef0ec4cee25a22e0e9113f3684b" translate="yes" xml:space="preserve">
          <source>Many historical versions of the SQLite documentation used a different process for generating the syntax diagrams. The historical process was based on Tcl/Tk and is described at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;. The newer Pikchr-based syntax diagrams first landed on trunk on 2020-09-26.</source>
          <target state="translated">SQLite文档的许多历史版本使用不同的过程来生成语法图。历史过程基于Tcl / Tk，并在&lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708中进行了&lt;/a&gt;描述。较新的基于Pikchr的语法图于2020-09-26首次登陆树干。</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">对配置脚本进行了许多改进和清理。</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">壳的许多改进和提高。</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">测试套件的许多改进。测试覆盖率现在超过98%。</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">与以前的版本相比，许多微优化导致相同数量的CPU周期的工作量增加了20.3％。自&lt;a href=&quot;#version_3_8_0&quot;&gt;3.8.0版&lt;/a&gt;以来，累积性能提高了61％。（在具有gcc 4.8.1和-Os的Ubuntu 13.10 x64 上的&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt;工作负载上使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;进行测量。您的性能可能会有所不同。）</target>
        </trans-unit>
        <trans-unit id="e6450a66ff66bca179b7e4def9ab1ada6c17e749" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;https://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">与以前的版本相比，许多微优化导致相同数量的CPU周期的工作量增加了20.3％。自&lt;a href=&quot;#version_3_8_0&quot;&gt;3.8.0版&lt;/a&gt;以来，累积性能提高了61％。（在具有gcc 4.8.1和-Os的Ubuntu 13.10 x64上的&lt;a href=&quot;https://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt;工作负载上使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;进行测量。您的性能可能会有所不同。）</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">很多微优化,使得库的速度比之前的版本更快。</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">许多小的错误修复</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">修复了许多烦人的BUG。</target>
        </trans-unit>
        <trans-unit id="a8c23cdfb8fba87694bb2dbb013754a5354d8db3" translate="yes" xml:space="preserve">
          <source>Many of the parameters passed to the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces are common across the entire family.</source>
          <target state="translated">传递给&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;接口系列的许多参数在整个系列中都是通用的。</target>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C语言接口&lt;/a&gt;中的许多例程都返回数字结果代码，它们指示成功或失败，并且在失败的情况下，提供了一些导致失败的原因的想法。本文档致力于解释每个数字结果代码的含义。</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">许多操作,特别是I/O密集型操作,由于内容确实需要在内核空间和用户空间之间复制,因此可以更快。</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">许多程序使用&lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen（）&lt;/a&gt;，&lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread（）&lt;/a&gt;和&lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite（）&lt;/a&gt;来创建和管理本地格式的数据文件。SQLite可以很好地替代这些</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">许多读者推荐了各种Git的第三方GUI,它们或许能更好地显示历史开发活动。也许其中一些确实比原生Git和/或GitHub更好用,尽管它们都会因为Git不能在同步中保存历史分支名而受到影响。即使这些其他工具更好,但必须通过第三方工具才能获得所需信息的事实也不能说明核心系统的好坏。</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">许多小的性能优化。</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">很多很多的bug修复和兼容性增强。</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">许多,许多小的错误修复和文档更新。</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">主日志指针</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">主日志</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">主期刊</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">如果query1和query2都匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">如果query1或query2匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">如果query1匹配而query2不匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">Matchinfo b旗</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">Matchinfo x flag</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">Matchinfo和旗帜</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">视图和子查询的具体化</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">数学运算符（+，-，*，/，％，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，＆和|）将两个操作数都视为数字。 STRING或BLOB操作数会自动转换为REAL或INTEGER值。如果STRING或BLOB看起来像实数（如果它具有小数点或指数），或者该值超出了可以表示为64位有符号整数的范围，则它将转换为REAL。否则，操作数将转换为INTEGER。数学操作数的隐式类型转换与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST到NUMERIC&lt;/a&gt;略有不同，因为字符串和看起来像实数但没有小数部分的BLOB值保持为REAL而不是像&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST到NUMERIC&lt;/a&gt;那样转换为INTEGER。即使是有损且不可逆的，也要执行从STRING或BLOB到REAL或INTEGER的转换。一些数学运算符（％，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;和＆|）期望使用INTEGER操作数。对于那些运算符，将REAL操作数转换为INTEGER的方式与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER的&lt;/a&gt;方式相同。 &amp;lt;&amp;lt;，&amp;gt;&amp;gt;，＆和|运算符始终返回INTEGER（或NULL）结果，但是％运算符根据其操作数的类型返回INTEGER或REAL（或NULL）。数学运算符上的NULL操作数将产生NULL结果。数学运算符上的操作数将不会以任何形式出现且不是NULL，将转换为0或0.0。除以零的结果为NULL。</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">最大内嵌有效载荷分数。必须是64。</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">最大行数</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">最大xShmLock指数</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">最大开放参数</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">愿你行善不作恶</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">愿你为自己找到宽恕,也为他人找到宽恕。</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">愿你能自由分享,永远不取多于付出。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">使用这些命令测量从数据库和从单个文件读取 blobs 的性能。</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">通过添加--update选项来衡量写入性能。这将导致 blobs 被另一个大小完全相同的随机 blob 覆写。</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">在Ubuntu 16.04的x64上使用gcc 5.4.0和-Os的cachegrind进行测量。</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">以上测量是使用&lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;2017&lt;/a&gt;年10月8日的SQLite版本5594a121bf132a98进行的。</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">测量和降低SQLite中的CPU使用率</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">内存分配例程</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">内存分配子系统</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">内存分配器统计</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">記憶體插槽</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">结合使用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，...）开始时间选项和&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;编译时间选项，可以禁用内存记帐。</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">结合使用&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，...）开始时间选项和&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;编译时间选项，可以禁用内存记帐。</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">除非使用&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0 编译SQLite，否则默认情况下将启用内存分配统计信息，在这种情况下，默认情况下将禁用内存分配统计信息。</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">除非使用&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0 编译SQLite，否则默认情况下将启用内存分配统计信息，在这种情况下，默认情况下将禁用内存分配统计信息。</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">内存分配，无大小写的字符串比较例程，可移植的文本数字转换例程以及其他实用程序位于&lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c中&lt;/a&gt;。解析器使用的符号表由&lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c中的&lt;/a&gt;哈希表维护。该&lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt;源文件包含Unicode转换子程序。 SQLite的有它自己的私有实现的&lt;a href=&quot;printf&quot;&gt;（）的printf&lt;/a&gt;（标有一些扩展）&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;并在其自己的伪随机数生成器（PRNG）&lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">内存统计</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">从malloc（）获得用于保存&lt;b&gt;sqlite_get_table&lt;/b&gt;返回的信息的内存。但是调用函数不应尝试直接释放此信息。相反，当不再需要该表时，请将完整的表传递给&lt;b&gt;sqlite_free_table&lt;/b&gt;。可以安全地使用NULL指针调用&lt;b&gt;sqlite_free_table&lt;/b&gt;，如果结果集为空，则将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">内存映射I/O</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4和memsys6是2007年左右推出的实验性内存分配器,后来在2008年左右从源树中删除,因为它们显然没有增加新的价值。</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">将开发变更合并到主干中。未来使用BTree文件结构的工作将使用一个单独的CVS源代码树。这个CVS树将继续只支持GDBM版本的SQLite。</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatch可以添加，修改或删除JSON对象的元素，因此对于JSON对象，json_patch（）例程是&lt;a href=&quot;json1#jset&quot;&gt;json_set（）&lt;/a&gt;和&lt;a href=&quot;json1#jrm&quot;&gt;json_remove（）&lt;/a&gt;的通用替代。但是，MergePatch将JSON数组对象视为原子对象。MergePatch不能追加到数组，也不能修改数组的单个元素。它只能作为单个单元插入，替换或删除整个阵列。因此，当处理包含数组的JSON时，json_patch（）并不有用，尤其是具有很多子结构的数组。</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">合并的&lt;a href=&quot;sessionintro&quot;&gt;会议&lt;/a&gt;延长到躯干。</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">元数据通过写入作为该函数第5个和后续参数传递的内存位置来返回。这些参数中的任何一个都可以是NULL,在这种情况下,相应的元数据元素将被省略。</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">方法(2)提供了(1)和(3)之间的中间点。使用这种方法,像 &quot;1s*&quot;这样的查询将匹配包含字面标记 &quot;1st &quot;但不包含 &quot;first &quot;的文档(假设标记器不能提供前缀的同义词)。然而,像 &quot;1st &quot;这样的非前缀查询将与 &quot;1st &quot;和 &quot;first &quot;匹配。这种方法不需要额外的磁盘空间,因为没有额外的条目被添加到FTS索引中。另一方面,运行MATCH查询可能需要更多的CPU周期,因为每个同义词都需要单独查询FTS索引。</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;，&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;，&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;，&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;，&lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;，&lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">数以百万计的测试案例</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">最小内嵌有效载荷分数。必须是32。</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">最小行数</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">对网站进行小幅修改。</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">小幅修改语法以支持更多的编译器。</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">对其他代码进行小幅调整,使其运行速度更快一些。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">其他&lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt;减少约2.1％的CPU使用率。</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">杂项代码大小优化和错误修复。</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">杂项文件的改进。</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">各种微优化使普通工作负载的CPU使用率降低了7％以上。此版本中的大多数优化都在前端（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;）上进行。</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">与以前的版本相比，在相同的CPU周期数下，其他各种微优化导致的工作量增加了22.3％。SQLite现在的运行速度是&lt;a href=&quot;#version_3_8_0&quot;&gt;3.8.0版的&lt;/a&gt;两倍，是&lt;a href=&quot;#version_3_3_9&quot;&gt;3.3.9版的&lt;/a&gt;三倍。（在具有gcc 4.8.2和-Os的Ubuntu 14.04 x64 上的&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt;工作负载上使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;进行测量。您的性能可能会有所不同。）</target>
        </trans-unit>
        <trans-unit id="c1d9b076bc6c8344ea5542edf83c259a762c2a37" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;https://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">与以前的版本相比，在相同的CPU周期数下，其他各种微优化导致的工作量增加了22.3％。SQLite现在的运行速度是&lt;a href=&quot;#version_3_8_0&quot;&gt;3.8.0版的&lt;/a&gt;两倍，是&lt;a href=&quot;#version_3_3_9&quot;&gt;3.3.9版的&lt;/a&gt;三倍。（在具有gcc 4.8.2和-Os的Ubuntu 14.04 x64上的&lt;a href=&quot;https://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt;工作负载上使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;进行测量。您的性能可能会有所不同。）</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">杂项小错误修复</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">其他优化可将&lt;a href=&quot;cpu&quot;&gt;使用的CPU周期&lt;/a&gt;减少2％。</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">杂项性能改进</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">&quot;债&quot;、&quot;孓&quot;、&quot;阮&quot;、&quot;万奴 &quot;等杂问题词。</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="translated">格式错误的记录</target>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">缺少回调</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="translated">丢失或多余的指数条目</target>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="translated">缺页</target>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">当磁盘访问是顺序访问时，现代文件系统运行得更快。因此，如果数据库文件的内容在连续页面上，SQLite将运行得更快。要找出数据库中哪些页面是连续的（从而获得度量值，这对于确定何时使用&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;可能有用），请运行如下查询：</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">修改&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;接口以支持更广泛的嵌入式系统。有关更多信息，请参见&lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt;。***可能不兼容的更改***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">对&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器的&lt;/a&gt;修改，使解析器表小4倍。</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">修改了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH，&lt;/a&gt;以在缓冲区大小计算中删除&amp;ldquo; +4&amp;rdquo;幻数。</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell程序，以便在显式请求的情况下为内置SQLITE_MASTER表打印模式。</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell程序以使用新的接口例程。</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell，以使用新的sqlite_get_table（）API来打印多列的表列表，类似于&amp;ldquo; ls&amp;rdquo;打印文件名的方式。</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell，以在&amp;ldquo; .schema&amp;rdquo;命令的输出中的每个CREATE语句的末尾打印分号。</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">修改了B-Tree和Pager模块,使不包含真实数据的磁盘页(空闲页)不写日记,当它们发生变化时,不从内存写回磁盘。这并不影响数据库的完整性,因为这些页面不包含真实数据,但它确实使大型INSERT操作快了约2.5倍,大型DELETE快了约5倍。</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">修改了日志文件格式,使其更能抵御操作系统崩溃或断电后可能出现的损坏。</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">修改TCL接口以使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">修改测试脚本,以确定依赖于系统负载和处理器速度的测试,并警告用户,这些(罕见的)测试之一的失败并不一定意味着库发生了故障。不修改代码。</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">修改数据库页面的内容。</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">修改、添加或截断数据库页面。</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">更激进的&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">当一边或另一边总是假的时候,更积极地优化AND运算符。</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">比较复杂的查询可能采用查询扁平化,也可能不采用查询扁平化来避免临时表。查询能否被扁平化取决于子查询或外层查询是否包含聚合函数、ORDER BY或GROUP BY子句、LIMIT子句等因素。什么情况下查询可以扁平化,什么情况下不能扁平化,这些规则非常复杂,不在本文的讨论范围之内。</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">更有效地对布尔值进行编码,从而使数据库文件更小。</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">更有效地处理&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;，尤其是在应用程序定义数百或数千个自定义函数的情况下。</target>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">更有效地处理&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;，尤其是在应用程序定义数百或数千个自定义函数的情况下。</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">在 Windows 下更高效地实现 sqliteFileExists()。(作者:Joel Luscy)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">更强大的内存外错误处理。</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">更多建议...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">在一个查询中可能会出现一个以上的NEAR操作符。在这种情况下,由NEAR操作符分隔的每一对术语或短语必须出现在文档中指定的相邻范围内。使用与上述示例块中相同的表格和数据。</target>
        </trans-unit>
        <trans-unit id="759136a5c089af122dabc1e0771753f48776ccec" translate="yes" xml:space="preserve">
          <source>Most CVEs written about SQLite assume that the attacker is able to run arbitrary SQL scripts in SQLite. In most applications, this means that there must first be an SQL Injection vulnerability that allows the attacker to inject the malicious SQL.</source>
          <target state="translated">大多数关于SQLite编写的CVE都假设攻击者能够在SQLite中运行任意SQL脚本。在大多数应用程序中,这意味着首先必须存在一个SQL注入漏洞,允许攻击者注入恶意SQL。</target>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">大多数R*Tree查询都使用深度优先搜索。这是通过将rScore设置为iLevel来实现的。深度优先搜索通常是首选,因为它可以使优先级队列中的元素数量最小化,从而减少内存需求并加快处理速度。然而,一些应用程序可能更喜欢广度优先搜索,这可以通过将rScore设置为mxLevel-iLevel来实现。通过为rScore创建更复杂的公式,应用程序可以对搜索子树和返回R*Tree叶子条目的顺序进行详细控制。例如,在一个有数百万个 R*Tree 条目的应用程序中,rScore 可能会被安排为首先返回最大或最重要的条目,使应用程序能够快速显示最重要的信息,并在它们可用时填写较小和不太重要的细节。</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">大多数SQL数据库引擎(据我们所知,除了SQLite之外的所有SQL数据库引擎)都使用静态的、刚性的类型。通过静态类型化,一个值的数据类型由它的容器--存储该值的特定列决定。</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">大多数SQL数据库引擎都是基于客户端/服务器的。在那些无服务器的数据库引擎中,SQLite是笔者所知的唯一一个允许多个应用程序同时访问同一个数据库的引擎。</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">大多数SQL数据库引擎都是基于客户端/服务器的。在那些无服务器的数据库引擎中,SQLite是笔者所知的唯一一个允许多个应用程序同时访问同一个数据库的引擎。</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">大多数SQL数据库引擎是作为一个独立的服务器进程来实现的。想要访问数据库的程序使用某种进程间通信(通常是TCP/IP)与服务器通信,向服务器发送请求并接收返回的结果。SQLite不是这样工作的。在SQLite中,想要访问数据库的进程直接从磁盘上的数据库文件进行读写。没有中间的服务器进程。</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">大多数SQL数据库引擎将已经解析好的模式存储在各种系统表中。在这些数据库引擎上,ALTER TABLE只需要对相应的系统表进行修改即可。</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">大多数SQL数据库引擎都使用静态类型。一个数据类型与表中的每一列相关联,并且只允许在该列中存储该特定数据类型的值。SQLite通过使用manifest typing放宽了这种限制。在manifest typing中,数据类型是值本身的一个属性,而不是存储值的列的属性。因此,SQLite允许用户将任何数据类型的值存储到任何列中,而不管该列的声明类型是什么。(这个规则也有一些例外。一个INTEGER PRIMARY KEY列只能存储整数。而且SQLite试图在可以的情况下,将值胁迫到该列的声明数据类型中。)</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">大多数应用格式都符合这三类中的一类。</target>
        </trans-unit>
        <trans-unit id="d19cf0ebd0035eff768792dfdb24fc34ef35cd23" translate="yes" xml:space="preserve">
          <source>Most applications can use SQLite without having to worry about bugs in obscure SQL inputs. If the application controls the SQL, and the application is not deliberately trying to break SQLite, then everything should just work. It is not necessary to have the latest patched version of SQLite. Any older version should work just fine.</source>
          <target state="translated">大多数应用程序都可以使用SQLite,而不必担心晦涩的SQL输入会出现bug。如果应用程序控制了SQL,并且应用程序没有刻意去破坏SQLite,那么一切都应该只是工作。不一定要有最新的SQLite补丁版本。任何旧版本都应该可以正常工作。</target>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">大多数应用程序将只使用上一节中描述的会话模块功能。然而,以下附加功能可用于使用和操作更改集和补丁集 blobs。</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">大多数应用程序都可以在默认配置下使用SQLite，并且无需特殊的编译时配置。大多数开发人员应该能够完全忽略该文档，而无需进行任何特殊知识并且无需采取任何特殊措施即可简单地从&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;构建SQLite 。</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">大多数构建还使用系统内存分配例程。</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">大多数内置窗口函数都会忽略frame-spec,例外情况是first_value()、last_value()和nth_value()。将 FILTER 子句指定为内置窗口函数调用的一部分是语法错误。</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">大多数内存统计都是全局的,因此对统计的跟踪必须用mutex序列化。统计功能在默认情况下是打开的,但存在一个选项可以禁用它们。通过禁用内存统计,SQLite避免了在每次内存分配和deallocation时进入和离开一个mutex。在Mutex操作成本很高的系统中,这种节约是很明显的。要禁用内存统计,在启动时使用以下接口。</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">大多数对象引用只能解析为特定类型的对象（例如，作为DROP TABLE语句一部分的引用只能解析为表对象，而不是索引，触发器或视图）。但是，在某些情况下（例如&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;），对象引用可以解析为一种以上类型的对象。在数据库模式中搜索命名对象时，总是会忽略在引用上下文中无法使用的类型的对象。</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">SQLite源代码树中的大多数代码纯粹用于&lt;a href=&quot;testing&quot;&gt;测试和验证&lt;/a&gt;。可靠性对SQLite很重要。测试基础结构的任务之一是确保SQLite不会滥用动态分配的内存，SQLite不会泄漏内存，并且SQLite能够正确响应动态内存分配失败。</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">大多数情况下,sqlite3只是读取输入行,并将其传递给SQLite库执行。但是以点(&quot;.&quot;)开头的输入行会被sqlite3程序本身拦截和解释。这些 &quot;点命令 &quot;通常用来改变查询的输出格式,或者执行某些预包装的查询语句。最初的点命令只有几个,但经过多年的发展,积累了许多新的功能,所以今天已经有60多个。</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">大多数时候,SQLite中的查询规划器做得很好。然而,查询规划器需要索引来工作。这些索引通常必须由程序员添加。罕见的情况下,查询规划器AI会做出一个次优的算法选择。在这些情况下,程序员可能要提供额外的提示,以帮助查询规划器做得更好。</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">大多数其他SQL数据库引擎为大多数表的每一行分配了固定的磁盘空间。它们在处理BLOB和CLOB时玩了一些特殊的技巧,这些BLOB和CLOB的长度可能大不相同。但是对于大多数表来说,如果你声明一个列是VARCHAR(100),那么无论你在该列中实际存储了多少信息,数据库引擎都会分配100字节的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">大多数其他SQL数据库引擎都比这个大得多。IBM吹嘘其最近发布的CloudScape数据库引擎 &quot;只有 &quot;2MiB的jar文件--即使经过压缩,也比SQLite大了一个数量级!而Firebird则吹嘘其客户端库只有350KiB。Firebird吹嘘其客户端库只有350KiB。这和SQLite一样大,甚至不包含数据库引擎。Oracle的Berkeley DB库是450KiB,它省略了对SQL的支持,只给程序员提供简单的键/值对。</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">大多数其他SQL数据库引擎在从一个平台转移到另一个平台时,以及在升级到一个较新版本的软件时,经常要求你转储和恢复数据库。</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">大多数程序员使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;功能将SQLite编译到其应用程序中。该&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;是C代码，但它不是&amp;ldquo;源代码&amp;rdquo;。该&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;被从源代码由脚本生成。</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">SQLite中的大多数表由零个或多个行组成，带有唯一的整数键（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;），后跟内容。（&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表除外）。逻辑上，按行号递增的顺序存储行。例如，本文使用一个名为&amp;ldquo; FruitsForSale&amp;rdquo;的表，该表将各种水果与它们的种植州和市场单价相关。模式是这样的：</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">在典型的SQLite数据库模式中,大多数表都是rowid表。</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">大多数 swarmvtab 的用户只会使用上面描述的功能。本节介绍了为更深奥的用例设计的功能。这些特性都涉及到在SQL语句后面指定额外的可选参数,作为CREATE VIRTUAL TABLE命令的一部分。一个可选的参数是用它的名字来指定的,后面是一个&quot;=&quot;字符,然后是一个可以选择引用的值。名字、&quot;=&quot;字符和值之间可以用空格隔开。例如,在参数名称后面加上&quot;=&quot;字符,然后再加上引号。</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">将一个BLOB手柄移动到新的行。</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">将寄存器P1...P1+P3-1中的P3值移到寄存器P2...P2+P3-1中。寄存器P1...P1+P3-1保持一个NULL。寄存器范围P1...P1+P3-1和P2...P2+P3-1重叠是错误的。P3小于1时错误。</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">将光标P1移动到空行。当光标在空行上时发生的任何&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;操作都将始终写入NULL。</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">将网站和文档文件从源目录树移到&lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;单独的CM系统中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5bd873ad5c9f2c5c76a311ec509bc5304045928" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;https://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">将网站和文档文件从源目录树移到&lt;a href=&quot;https://www.sqlite.org/docsrc/&quot;&gt;单独的CM系统中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">将CVS仓库移至www.sqlite.org。</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">从SQLite 3.4.2移动到3.5.0</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">从SQLite 3.5.9迁移到3.6.0</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">将日志文件从一个数据库移动到另一个数据库。</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">尽管某些例程分散在其他文件中，但它们可以访问具有文件范围的数据结构，但是许多&lt;a href=&quot;c3ref/intro&quot;&gt;C语言接口&lt;/a&gt;都可以在源文件&lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;，&lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;和&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c中&lt;/a&gt;找到。该&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;例程中实现&lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;。该&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;程序中发现的&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;。所述&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;接口处于&lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;。在&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口&lt;/a&gt;是通过实施&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">多文件交易</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">多字符的插入、删除和替换可以在成本表中列举出来。</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">多列索引</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">多列索引只有在查询的WHERE子句中的约束条件通过AND连接时才起作用。因此,当搜索的项目既是橙子又生长在加州时,Idx3和Idx4是很有帮助的,但是如果我们想要所有的项目都是橙子,那么这两个索引就没有那么有用了。</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">多种编程语言</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">可以同时注册多个VFS。每个VFS都有一个唯一的名称。同一进程中的单独&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;可以同时使用不同的VFS。因此，如果单个数据库连接使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令打开了多个数据库文件，则每个连接的数据库可能正在使用不同的VFS。</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">使用多个b树结构代替单个b树,以降低在FTS表中插入记录的成本。当一条新记录插入到已经包含大量数据的FTS表中时,新记录中的许多术语很可能已经存在于大量的现有记录中。如果使用单一的b-tree,那么就必须从数据库中加载大型的doclist结构,修改为包含新的docid和术语偏移列表,然后再写回数据库。使用多个b-tree表可以通过创建一个新的b-tree来避免这种情况,这个新的b-tree可以在以后与现有的b-tree(或b-树)合并。b-tree结构的合并可以作为后台任务来执行,或者一旦积累了一定数量的独立b-tree结构,就可以进行合并。当然,这种方案会使查询的成本增加(因为FTS代码可能需要在多个b树中查找单个术语并合并结果),但人们发现,在实践中这种开销往往可以忽略不计。</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">3.15.0版引入了对&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;逻辑的多个错误修复。</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">多位评论者表示希望指针类型使用动态字符串,并希望SQLite拥有类型字符串的所有权,并在使用完毕后自动释放类型字符串。该设计被拒绝,原因如下。</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">来自一个进程内的多个连接,如果使用这种异步IO的实现,可以并发访问一个数据库文件。从用户的角度来看,如果所有的连接都来自于一个进程内,那么 &quot;普通 &quot;SQLite和使用异步后端的SQLite所提供的并发性没有任何区别。</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">多个连接可能同时持有一个读锁。如果许多线程都在获取重叠的读锁,那么可能会出现至少一个线程始终持有读锁的情况。那么等待写锁的表将永远等待。这种情况被称为 &quot;写手饥饿&quot;。</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上的多个数据库</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">多个进程可以附加到同一个应用文件上,并且可以互相读写,互不干扰。</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">多个进程可以同时打开同一个数据库。多个进程可以同时进行SELECT。但在任何时刻只能有一个进程对数据库进行修改,但是。</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">多个小排序集体使用的CPU周期比单个大排序少。</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">将寄存器P1中的值乘以寄存器P2中的值,并将结果存储在寄存器P3中。如果任一输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">将null乘以0,得到null</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">突变测试脚本</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">突变测试可能会很慢,因为在快速工作站上,每次测试可能需要5分钟,而且每个分支指令有两次测试,有超过2万条分支指令。为了加快操作速度,我们做出了努力。例如,TH3的编译方式是一旦发现第一个错误就立即退出,由于许多突变很容易被检测到,所以许多循环只发生在几秒钟内。尽管如此,mutation-test.tcl脚本包含命令行选项,可以限制测试的代码行的范围,这样突变测试只需要对最近改变的代码块进行。</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">互换手柄</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Mutex方法对象</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">互换类型</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">Mutex验证例程</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">互斥虽然便宜,但也不是免费的,所以完全禁用互斥后,性能会更好。由此产生的库足迹也会更小一些。在编译时禁用mutexes是一种推荐的优化,适用于有意义的应用。</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">互斥使用&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">互斥使用&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">我的WHERE子句表达式 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; 不起作用。这将导致返回表的每一行，而不仅仅是返回column1值为&amp;ldquo; column1&amp;rdquo;的行。</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">我的查询没有返回我期望的列名。这是一个错误吗?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="translated">MySQL支持UPDATE FROM思想,但它不使用FROM子句。而是在UPDATE和SET关键字之间给出完整的连接规范。相当于MySQL语句是这样的。</target>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL 3.23.41版本不支持UNION。</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12甚至</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13且为奇数</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1(费用:5.52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2(费用:5.52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1(费用:11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
