<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">在前面的章节中,我们已经看到了如何从作为ZIP存档实现的键/值存储转移到一个只有三张表的简单SQLite数据库,可以为应用程序文件格式增加重要的功能。我们可以继续用新的表来增强模式,为了性能而添加索引,为了编程方便而添加触发器和视图,即使面对编程错误,也可以用约束来强制执行内容的一致性。进一步的增强想法包括:</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">在前文中,WHERE子句中的 &quot;type NOT IN ('object','array')&quot;项抑制了容器,只允许通过叶元素。这种方式也可以达到同样的效果。</target>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">在上面的查询中，如果t1和t2都大约有N行，则没有任何索引，查询将需要O（N * N）时间。另一方面，在表t2上创建索引需要O（NlogN）时间，然后使用该索引评估查询需要额外的O（NlogN）时间。在没有&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;信息的情况下，SQLite猜测N为一百万，因此它认为构造自动索引将是更便宜的方法。</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">在上面的查询中,我们大概会将第12区的精确边界的二进制BLOB描述绑定到&quot;:边界 &quot;参数上。</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">在上面的查询中,&quot;PARTITION BY c &quot;子句将结果集分成了三个分区。第一个分区有三条c=='1'的记录。第二个分区有两行c=='三',第三个分区有两行c=='二'。</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">在上面的查询中，&amp;ldquo; a&amp;rdquo;列是GROUP BY子句的一部分，因此输出的每一行都包含&amp;ldquo; a&amp;rdquo;的不同值之一。&amp;ldquo; c&amp;rdquo;列包含在&lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum（）&lt;/a&gt;聚合函数中，因此输出列是&amp;ldquo; a&amp;rdquo;具有相同值的行中所有&amp;ldquo; c&amp;rdquo;值的总和。但是，裸列&amp;ldquo; b&amp;rdquo;的结果是什么？答案是，&amp;ldquo; b&amp;rdquo;结果将是构成聚合的输入行之一中&amp;ldquo; b&amp;rdquo;的值。问题是您通常不知道哪个输入行用于计算&amp;ldquo; b&amp;rdquo;，因此在许多情况下，&amp;ldquo; b&amp;rdquo;的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">在上面的查询中,子查询 &quot;SELECT b FROM ex2 &quot;被评估,其结果被存储在一个临时表(实际上是一个临时索引)中,允许人们使用简单的二进制搜索来确定是否存在一个值ex2.b。一旦这个表被构造出来,就会运行外部查询,并对每一条潜在的结果行进行检查,看ex1.a是否包含在临时表中。只有当检查结果为真时,才会输出该行。</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">在上面的查询中,first_name和last_name列的值将对应于满足max(salary)条件的行。</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">在修改后的查询中,由一个联合程序实现的子查询计算 &quot;a &quot;的五个最新值。这五个值从共同程序传递到外部查询中,其中&quot; expensive_function()&quot;只在应用程序关心的特定行上被调用。</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">在第二个例子中,DO UPDATE子句中的表达式是 &quot;excluded.phonenumber &quot;的形式。前缀 &quot;excluded.&quot;导致 &quot;phonenumber &quot;指的是在没有冲突的情况下本应插入的phonenumber的值。因此,upsert的效果是插入一个Alice的phonenumber,如果不存在的话,或者用新的phonenumber覆盖Alice之前的任何phonenumber。</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">在左边的序列中,第二次插入将失败。在这种情况下,字符串'0'和'0.0'被视为数字,因为它们被插入到一个数字列中,但0==0.0违反了唯一性约束。然而,右手序列中的第二个插入是有效的。在这种情况下,常量0和0.0被视为字符串,这意味着它们是不同的。</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">在外壳程序中，当用户按下Control-C时调用&lt;b&gt;sqlite_interrupt（）&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">在spellfix1算法中,cFrom是用户输入的文本,cTo是数据库中存在的正确拼写文本。editdist3算法的目标是确定用户输入的文本与字典文本的接近程度。</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">在sqlite shell中,现在打印初始启动时的版本号。</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">在sqlite shell中,将 &quot;Database opened READ ONLY &quot;信息打印到stderr而不是stdout。</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">在上面的语句中,由MATCH操作符生成的FTS3游标指针被送入carray()表值函数中,而不是其预定的接收方snippet()。carray()函数将指针视为指向整数数组的指针,并逐一返回每个整数,从而泄露了FTS3游标对象的内容。由于FTS3游标对象中包含了指向其他对象的指针,所以上面的语句将是一个指针泄漏。</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">在上面的模板中,NNN代表一个整数文字,VVV代表一个字母数字标识符。这些参数的值(也称为 &quot;主机参数名 &quot;或 &quot;SQL参数&quot;)可以使用这里定义的sqlite3_bind_*()例程来设置。</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">在基础&lt;a href=&quot;fileformat2&quot;&gt;文件格式中&lt;/a&gt;，每个rowid存储为一个&lt;a href=&quot;fileformat2#varint&quot;&gt;可变长度的整数&lt;/a&gt;。这意味着小的非负rowid值比大或负rowid值占用更少的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">在这种情况下，aConstraint []。op值与&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction（）&lt;/a&gt;为FUNCTION 返回的值相同。</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">在这种情况下,可以通过在t2(c)上创建一个索引来避免使用临时b树,如下所示。</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">在这种情况下,SQLite仍然会进行一次二进制搜索,找到索引的第一个条目,其中fruit='Orange'。然后它从索引中提取rowid,并使用该rowid通过二进制搜索查找原表条目,输出原表的价格。但是数据库引擎并没有退出,而是前进到索引的下一行,对下一个 fruit='Orange'条目重复这个过程。推进到索引(或表)的下一行比进行二进制搜索的成本要低得多,因为下一行通常与当前行位于同一个数据库页面上。事实上,与二进制搜索相比,前进到下一行的成本非常便宜,所以我们通常会忽略它。所以我们对这个查询的总成本的估计是3次二进制搜索。如果输出的行数为K,表中的行数为N,那么一般情况下,做这个查询的成本与(K+1)*logN成正比。</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">在这张图中,一个SQL语句(&quot;SELECT v FROM kv WHERE k=?1&quot;)被准备了一次。然后对于每个blob,将blob键值绑定到?1参数上,并对语句进行评估,提取blob内容。</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">在这个例子中,docs.name为 &quot;report-15 &quot;的条目的docs.body字段的内容将被发送到编辑器。编辑器返回后,结果将被写回 docs.body 字段。</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">在这个例子中,demo_data.boundary字段是为了持有对象的精确边界的某种二进制表示。R*Tree索引只持有对象的轴对齐的矩形边界。R*Tree边界只是真实对象边界的近似值。所以通常情况下,R*Tree索引被用来将搜索范围缩小到一个候选对象列表,然后对每个候选对象进行更详细和昂贵的计算,以发现候选对象是否真正符合搜索标准。</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">在这个例子中,rowids不是连续的,而是有序的。SQLite通常会创建从1开始的rowids,每增加一条记录就增加一条。但是如果删除了行,序列中就会出现空白。而且如果需要的话,应用程序可以控制分配的rowid,这样就不一定会在底部插入行。但是无论发生什么,rowid总是唯一的,并且严格按照升序排列。</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">在这个例子中,t2表被用于一个子查询,以翻译t1.b列的值。如果每个表都包含N条记录,SQLite预计子查询将运行N次,因此它会认为先在t2上构造一个自动的瞬时索引,然后使用该索引来满足子查询的N个实例,这样会更快。</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">在最后这个例子中,phonebook2条目只有在新插入的值的validDate比表中已有的条目更新时才会更新。如果表已经包含了一个具有相同名称和当前validDate的条目,那么WHERE子句就会导致DO UPDATE成为无操作。</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">在后一个表中,只有一个B-Tree,它使用 &quot;word &quot;列作为键,&quot;cnt &quot;列作为数据。(技术性:低级实现实际上将 &quot;word &quot;和 &quot;cnt &quot;都存储在B-Tree的 &quot;key &quot;区域。但除非你正在看数据库文件的低级字节编码,否则这个事实并不重要)。)因为只有一个B-Tree,&quot;word &quot;列的文本在数据库中只存储一次。此外,查询特定 &quot;单词 &quot;的 &quot;cnt &quot;值只需要对主B树进行一次二进制搜索,因为 &quot;cnt &quot;值可以直接从第一次搜索找到的记录中检索,而不需要对rowid进行第二次二进制搜索。</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">在这个查询中,&quot;x轴 &quot;和 &quot;y轴 &quot;CTE定义了Mandelbrot Set将被近似的点的网格。m(iter,cx,cy,x,y)&quot;CTE中的每一行都意味着在 &quot;iter &quot;迭代之后,从cx,cy开始的Mandelbrot迭代已经到达了x,y点。本例中的迭代次数被限制为28次(这严重限制了计算的分辨率,但对于低分辨率的ASCII艺术输出来说已经足够了)。m2(iter,cx,cy)&quot;CTE保存了从点cx,cy开始时达到的最大迭代次数。最后,&quot;a(t)&quot;CTE中的每一行都保存着一个字符串,这是输出ASCII-art的单行。最后的SELECT语句只是查询 &quot;a &quot;CTE,逐行检索所有的ASCII-art行。</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">在这个模式中,每张幻灯片没有决定其在演示文稿中的顺序的页码,而是有一个唯一的整数标识符,它与幻灯片的顺序出现的位置无关。幻灯片在演示文稿中的顺序由幻灯片标识符(slideIds)列表决定,该列表以文本字符串的形式存储在VERSION表的MANIFEST列中。由于VERSION表中允许有多个条目,这就意味着同一文档中可以存储多个演示文稿。</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">在这个系统中,歌曲表中的每个条目都需要映射到专辑表中的一个条目,艺术家和专辑的组合相同。</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">这样一来,新的指针传递接口似乎解决了SQLite中从一个扩展向另一个扩展传递指针值的所有安全问题。</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">在具有第四个参数的例程中，其值是参数中的字节数。需要明确的是：该值是&lt;u&gt;字节数&lt;/u&gt;在值中，而不是字符数中。如果sqlite3_bind_text（）或sqlite3_bind_text16（）的第四个参数为负，则字符串的长度为直到第一个零终止符的字节数。如果sqlite3_bind_blob（）的第四个参数为负，则行为未定义。如果为sqlite3_bind_text（）或sqlite3_bind_text16（）或sqlite3_bind_text64（）提供了非负第四个参数，则该参数必须是字节偏移量，假定字符串以NUL终止，则NUL终止符将出现在该字节偏移处。如果任何NUL字符出现在字节偏移量小于第四个参数的值的位置，则结果字符串值将包含嵌入的NUL。涉及带有嵌入式NUL的字符串的表达式的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="f5c0b6c1ce652bbe2a9ce301182f0e17dcf5f222" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occurs at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">在truncate journal模式下,事务的提交方式是将日志文件截断为零长度,而不是像DELETE模式那样删除日志文件(DELETE模式)或将头清零(PERSIST模式)。TRUNCATE模式与PERSIST模式有相同的优点,即包含日志文件和数据库的目录不需要更新。因此,截断一个文件通常比删除它更快。TRUNCATE还有一个好处,就是它后面不需要系统调用(如:fsync())来同步更改到磁盘上。如果这样做,可能会更安全。但是在许多现代文件系统中,truncate是一个原子和同步的操作,因此我们认为truncate在面对电源故障时通常是安全的。如果你不确定TRUNCATE是否会在你的文件系统上是同步和原子的,而且你的数据库在截断操作过程中发生断电或操作系统崩溃时,对你很重要,那么你可以考虑使用不同的日记模式。</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">在3.5.9版本中,上面的查询将返回一个名为 &quot;t1.a &quot;的单列。在3.6.0版本中,列名只是 &quot;a&quot;。</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">在非常旧的SQLite版本（版本3.7.11-2012-03-20之前）中，如果有任何待处理的查询，则ROLLBACK将失败，并显示错误代码&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。在较新版本的SQLite中，ROLLBACK将继续执行，并且挂起的语句通常会中止，从而导致它们返回&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;或&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt;错误。在SQLite版本3.8.8（2015-01-16）及更高版本中，只要ROLLBACK不修改数据库架构，待处理的读取将在ROLLBACK之后继续运行。</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">换句话说,我们有一个名为 &quot;examp &quot;的数据库表,表中有两列数据,分别名为 &quot;一 &quot;和 &quot;二&quot;。现在假设我们要在这个表中插入一条记录。像这样。</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">内存数据库</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">内存数据库和共享缓存。</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">如果使用&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;打开内存数据库，则它们可以使用&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;。如果使用未经修饰的&amp;ldquo;：memory：&amp;rdquo;名称指定内存数据库，则该数据库始终具有专用缓存，并且仅对最初打开该数据库的数据库连接可见。但是，可以通过两个或多个数据库连接打开相同的内存数据库，如下所示：</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">在每个标识符名称的某处加入一个数字。</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">在库中包含一个静态字符串,响应RCS &quot;ident &quot;命令,其中包含库的版本号。</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">不兼容的变化首先被覆盖,因为它们对维护者和程序员来说是最重要的。</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">CREATE TABLE AS和简单SELECT之间的结果集列名称不一致。机票&lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">将A.Rottmann的makefile补丁合并到LIBTOOL中。</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">错误的assert（）语句已删除。入住&lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">报告了不正确的列数据类型。门票&lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">与ORDER BY DESC联接的查询结果不正确。票证&lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">使用跳过提前优化时，查询结果不正确。门票&lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">在小于&lt;a href=&quot;rowvalue&quot;&gt;value&lt;/a&gt;的小于值运算符上的结果不正确。门票&lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="bfb28e75251bc4d83a52b5697560b9c1115b80bf" translate="yes" xml:space="preserve">
          <source>Increase the &lt;a href=&quot;limits#max_variable_number&quot;&gt;default upper bound&lt;/a&gt; on the number of &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; from 999 to 32766.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">将默认&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;分配大小从100字节增加到128字节。</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">将默认&lt;a href=&quot;malloc#lookaside&quot;&gt;后备&lt;/a&gt;大小从512,125增加到1200,100，因为这可以提供更好的性能，同时每个连接仅增加56KB的额外内存。内存敏感的应用程序可以在编译时，启动时或运行时恢复旧的默认设置。</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">将看前缓存行的默认大小从100增加到128字节。</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">将&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt;的默认值增加到50，并确保在所有更改架构的地方都可以使用它，以强制执行语句重试。</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">将&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;扩展名的最大&amp;ldquo;范围&amp;rdquo;值从6增加到30。</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">将数据库页面的最大尺寸从32KiB增加到64KiB。</target>
        </trans-unit>
        <trans-unit id="c023946d393ce520944a7e8848356e945bf33b16" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of database files to 281 TB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">将&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;的最大值从30增加到62（尽管默认值保持为10）。</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">将&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;的最大值从62增加到125。</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">在发出&lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt;错误之前，请将&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;的超时从1秒增加到10秒。</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">提高了对恶意破坏数据库运行的恶意SQL的鲁棒性。</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">将&lt;a href=&quot;c3ref/vfs&quot;&gt;VFS对象&lt;/a&gt;的版本号增加到3，并添加了用于进行完全覆盖测试的新方法xSetSysCall，xGetSysCall和xNextSysCall。</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">通过P2递增一个 &quot;约束计数器&quot;(P2可以是负值或正值)。如果P1为非零,则数据库约束计数器递增(延迟外键约束)。否则,如果P1为零,则递增语句计数器(即时外键约束)。</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version = X&lt;/a&gt;递增架构版本号，其中X比上面步骤2中找到的旧架构版本号大1。</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">递增P1的值，以便&lt;a href=&quot;opcode#Once&quot;&gt;一旦&lt;/a&gt;操作码在第一次运行时就跳转。</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">增量和持续更新</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">索引B树内部单元(头0x02)。</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">索引B树叶单元(头0x0a)。</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">索引B-树叶或内部细胞。</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">内部索引 (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">索引叶 (0x0a)</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">一个给定名称的参数的索引</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">表达式上的索引</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">使用&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;命令删除索引。</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">索引可以使用&lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt;和&lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">子键列不需要索引，但是它们几乎总是有益的。返回&lt;a href=&quot;#fk_basics&quot;&gt;第1节中&lt;/a&gt;的示例，每次应用程序从列表中删除一行时，</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">名称形式为&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;的索引用于在普通表上实现&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束。</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">通过使用&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;标志第三个参数，使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;创建的单个数据库连接可以选择参与或不参与共享缓存模式。使用这些标志中的任何一个都将覆盖&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;建立的全局共享缓存模式设置。最多只能使用一个标志。如果在&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的第三个参数中同时使用了SQLITE_OPEN_SHAREDCACHE和SQLITE_OPEN_PRIVATECACHE标志，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">shm头的各个字段,除了从WAL头复制的salt值之外,都是以主机的本机字节顺序的无符号整数。盐值是WAL头的精确拷贝,并以WAL文件使用的任何字节顺序排列。整数的大小可以是8、16、32或64位。下面是shm头的各个字段的详细分解。</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">各个子项可能是单个比较表达式，例如* a = 5 *或* x&amp;gt; y *，或者它们可以是LIKE或BETWEEN表达式，或者子项可以是AND连接子项的括号列表。对每个子项进行分析，就好像它本身就是整个WHERE子句一样，以便查看该子项是否可自行索引。如果OR子句的&lt;u&gt;每个&lt;/u&gt;子项都可以单独索引，则可以对OR子句进行编码，以便使用单独的索引来评估OR子句的每个项。考虑SQLite如何为每个OR子句术语使用单独的索引的一种方法是，假设WHERE子句的重写方式如下：</target>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">单个虚拟表实现可能会施加其他约束。例如，某些虚拟实现可能提供只读表。或者某些虚拟表实现可能允许&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE，&lt;/a&gt;但不允许&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;。或者某些虚拟表实现可能会限制可以进行的UPDATE的种类。</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">在WHERE子句中使用OR运算符的UPDATE上的无限循环。问题在3.17.0中引入，并在大约一年后在邮件列表中报告。机票&lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">ORDER BY子句的信息存储在aOrderBy[]中。aOrderBy的每个术语都记录了ORDER BY子句的一列。</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">首次公开发布Alpha代码</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">最初发布的2.0版本。放弃了将库改名为 &quot;SQLus &quot;的想法,而保留了 &quot;SQLite &quot;的名称,并凸起了主要版本号。</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">数据库的初始大小,以页为单位</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">初始化 SQLite 库</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">初始化索引X为N-200(其中N为数据库页面的大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">初始化回调的&lt;b&gt;azColumnName []&lt;/b&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">将校验和初始化为偏移量为12的日记头中的校验和非ce值。</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">内连接可以自由地重新排序。但是,左外连接既不是换算的,也不是关联的,因此不会被重新排序。如果优化器认为外连接的左边和右边的内连接是有利的,那么可以重新排序,但是外连接总是按照它们出现的顺序进行评估。</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">将这一行插入递归表中。</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">将寄存器P2持有的整数值插入到寄存器P1持有的RowSet对象中。</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">在数据库中插入记录</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">LIMIT子句可以代替单独的OFFSET子句,指定两个用逗号分隔的标量表达式。在这种情况下,第一个表达式被用作OFFSET表达式,第二个表达式被用作LIMIT表达式。这是与直觉相反的,因为当使用OFFSET子句时,两个表达式中的第二个表达式是OFFSET,第一个表达式是LIMIT。这种偏移和限制的颠倒是有意为之的--它最大限度地提高了与其他SQL数据库系统的兼容性。然而,为了避免混淆,强烈建议程序员使用使用 &quot;OFFSET &quot;关键字的LIMIT子句形式,并避免使用带有逗号分隔偏移量的LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">这条语句没有删除 &quot;二 &quot;列小于50的记录,而只是把 &quot;一 &quot;列放在括号里 VDBE实现这条语句的程序如下。</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">默认情况下，SQLite不会提供对Unicode大小写的完全支持，而是提供了链接外部Unicode比较和转换例程的功能。应用程序可以重载内置的&lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt;整理序列（使用&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;）和内置的&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）&lt;/a&gt;，&lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#lower&quot;&gt;Lower（）&lt;/a&gt;函数（使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;）。 SQLite源代码包括执行这些重载的&amp;ldquo; ICU&amp;rdquo;扩展。或者，开发人员可以根据项目中已经包含的自己的Unicode感知比较例程编写自己的重载。</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">FTS5不使用磁盘上的单一数据结构来存储全文索引,而是使用一系列b树。每次提交一个新的事务时,一个包含提交的事务内容的新b树就会被写入数据库文件。当查询全文索引时,必须对每个b树进行单独查询,并将结果合并后再返回给用户。</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">不使用没有尾部参数的bm25(),而是可以根据每个查询配置映射到rank列的特定辅助函数,或者为FTS表设置不同的持久化默认值。</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">有些用户可能希望使用数据库触发器来保持全文索引与存储在内容表中的一组文档的最新状态,而不是分别写入全文索引和内容表。例如,使用前面例子中的表。</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">指令1在本例中尤为重要。通常情况下,Column指令会从SQLite文件条目数据中的大记录中提取列的值。指令1在瞬时表上设置了一个标志,这样Column反而会把SQLite文件条目的键当作数据来处理,从键中提取列信息。</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">指令0到4和INSERT示例一样。它们启动了主数据库和临时数据库的事务,验证了主数据库的数据库模式,并在表 &quot;examp &quot;上打开了一个读游标。注意,打开游标是为了读,而不是写。在程序的这个阶段,我们只是要扫描表,而不是改变表。稍后我们将在指令15中重新打开同一张表进行写入。</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">指令11到18实现了对所有索引记录的循环,其中的键是由指令8获取的。所有带有这个键的索引记录在索引表中都是连续的,所以我们走过它们,从索引中获取相应的表键。然后用这个表键将光标移动到表中的那一行。剩下的循环与非索引SELECT查询的循环相同。</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">指令18至23在要索引的表的每一行上实现循环。对于每个表行，我们首先在指令19中使用Recno提取该行的整数键，然后在指令20中使用Column获取&amp;ldquo; two&amp;rdquo;列的值&lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;。MakeIdxKey&lt;/a&gt;指令在21处将数据转换为&amp;ldquo; two&amp;rdquo;列中的数据（ （位于堆栈顶部）进入有效的索引键。对于单列索引，这基本上是无操作的。但是，如果对MakeIdxKey的P1操作数大于一个，则会从堆栈中弹出多个条目并将其转换为单个索引键。该&lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;实际创建索引条目的是22处的指令。IdxPut从堆栈中弹出两个元素。堆栈的顶部用作从索引表中获取条目的键。然后，将在堆栈上排第二的整数添加到该索引的整数集中，并将新记录写回到数据库文件中。请注意，如果有两个或两个以上表条目的两列具有相同的值，则同一索引条目可以存储多个整数。</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">指令19到25构造了一个新的数据库记录,将用于替换现有记录。这和我们在insert的描述中看到的代码是一样的,不再赘述。指令25执行后,堆栈是这样的。</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">指令2和3在要查询的数据库表上打开一个读游标。这与INSERT示例中的OpenWrite指令的工作原理相同,只是这次打开的游标是读而不是写。指令4和INSERT示例中一样,验证数据库模式。</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Android的编译说明&lt;a href=&quot;#compile-android&quot;&gt;如下所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">原本会导致溢出的整数算术运算,现在改用浮点运算。</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">存储为段b树节点一部分的整数值使用FTS varint格式进行编码。这种编码是类似的，但&lt;b&gt;不完全相同&lt;/b&gt;，于&lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite的varint格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60896296e2cc4f360fd103b1acf3b75080d48243" translate="yes" xml:space="preserve">
          <source>Integrity of the freelist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">该内存插槽的预期用途</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">表b树的内页没有有效载荷,所以永远不会有任何有效载荷溢出。</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">内部与外部BLOBs</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">SQLite中的内部BLOB与外部BLOB的比较</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">SQLite使用的内部模式对象可能包括以下内容。</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">内部表格</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">在内部,Geopoly以二进制格式存储多边形--SQL BLOB。下面给出了二进制格式的细节。所有的 Geopoly 界面都能接受 GeoJSON 格式或二进制格式的多边形。</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">TRIM()函数的国际化。Ticket #2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">将偏移量X的字节解释为8位无符号整数,并将该整数的值加到校验和中。</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">将寄存器P1的内容解释为一个整数。将P1值的一补存入寄存器P2中。如果P1的值是NULL,那么在P2中存储一个NULL。</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">将光标P1指向的数据解释为使用&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;指令构建的结构。（有关数据格式的其他信息，请参见&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;操作码。）从该记录中提取第P2列。如果记录中的值少于（P2 + 1），则提取NULL。</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">将寄存器P1中的值解释为一个布尔值,将该布尔值(0或1)存储在寄存器P2中。将该布尔值(0或1)存储在寄存器P2中。或者如果寄存器P1中的值是NULL,那么P3就存储在寄存器P2中。如果P4为1,则将答案反转。</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">将寄存器P1中的值解释为布尔值。将布尔值的补码存储在寄存器P2中,如果寄存器P1中的值为NULL,则在P2中存储一个NULL。如果寄存器P1中的值是NULL,那么在P2中存储一个NULL。</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">中断一个长期运行的查询</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">引入扩展错误代码,增加各种I/O错误的错误代码。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">内省SQLite数据库文件（&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;）的磁盘内容</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">直觉上,我们人类理解算法-1是最好的。每个签到可能有很少的子代(一个子代是最常见的情况),而且每个子代都可以用对数时间来测试$trunk标签。事实上,算法-1是实践中较快的选择。但是NGQP没有直观的感受。NGQP必须使用硬数学,而算法-2在数学上略胜一筹。这是因为,在没有其他信息的情况下,NGQP必须假设PLINK_I1和TAGXREF_I1这两个索引质量相同,并且具有同等的选择性。算法-2使用了TAGXREF_I1索引的一个字段和PLINK_I1索引的两个字段,而算法-1只使用了每个索引的第一个字段。由于算法-2使用了更多的索引材料,所以NGQP判断它是更好的算法是正确的。分数很接近,算法-2只是勉强领先算法-1。但算法-2在这里确实是正确的选择。</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">颠倒一个变化集</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">在应用变化集之前将其反转。这相当于在应用变化集之前,使用sqlite3changeset_invert()来反转它。在补丁集中指定这个标志是错误的。</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">在迭代变化集的同时,将变化集反转。这相当于在应用变化集之前,使用sqlite3changeset_invert()对它进行反转。在补丁集中指定这个标志是错误的。</target>
        </trans-unit>
        <trans-unit id="7bcd843ccbf3ca2b0a46090c9286f7cf70d294d4" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc598ee05cff833de713e00e614680a147ad7e5" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened. This prevents application-defined functions from being used in places where an attacker might be able to surreptiously invoke them by modifying a database schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">在与提供的语句句柄关联的数据库连接句柄上调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;进行注册，以进行解锁通知回调。如果对unlock_notify（）的调用返回SQLITE_LOCKED，则将此值返回给调用方。</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">调用一个用户函数(P4是指向定义函数的FuncDef对象的指针),P5参数取自寄存器P2和后续函数。函数的结果存储在寄存器P3中。寄存器P3不能是函数的输入之一。</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">调用一个用户函数(P4是一个指向sqlite3_context对象的指针,该对象包含一个指向要运行的函数的指针),P5参数取自寄存器P2和继任者。函数的结果存储在寄存器P3中。寄存器P3不能是函数的输入之一。</target>
        </trans-unit>
        <trans-unit id="bf8b8c1d4d822ee5f5035e452152155ef6c1caa7" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">调用'merge'命令一次,参数设置为 -N,然后</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">在参数设置为N的情况下,调用'merge'命令0次或多次。</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">调用当前结果行的回调函数。</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">在 sqlite3rbu 对象指针 X 上调用 sqlite3rbu_step(X)函数一次或多次,每次调用 sqlite3rbu_step()都会执行一次 b-tree 操作,因此可能需要调用数千次才能应用完整的更新。当更新被完全应用时,sqlite3rbu_step()接口将返回SQLITE_DONE。</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">调用xValue()函数并将结果存储在寄存器P3中。</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">在一个NULL指针上调用sqlite3_finalize()是一个无害的no-op。</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">使用参数调用此编译指示等效于使用与&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;参数&lt;/a&gt;对应的第三个参数调用&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt; C接口：</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">不带参数调用此编译指示等效于调用&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; C接口。</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">SQLite的线程安全吗?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">替换为:</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">隔离与并发</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">数据库连接之间的隔离</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">SQLite中的隔离</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">每当查询计划者使用自动索引时，在&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;上发出&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt;警告。</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">如果使用&lt;a href=&quot;quirks#dblquote&quot;&gt;双引号的字符串文字，&lt;/a&gt;则在&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;上发出SQLITE_WARNING消息。</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">当sqlite_master表损坏时，发出错误而不是断言故障或空指针取消引用，以使sqlite_sequence表根页实际上是btree-index页。入住&lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">如果数据库zFrom不存在或不包含所需的兼容表,这是一个错误。</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">它不能用于将数据复制到内存数据库或从内存数据库中复制。</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">它可以处理掉表或索引时可能发生的SQLITE_LOCKED的特殊情况。</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">它可以管理线程优先级。</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">它存在,而且</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">建立用于基于目标数据库名称确定RBU真空状态数据库名称的约定是一个好主意。下面的示例代码使用&amp;ldquo; &amp;lt;target&amp;gt; -vacuum&amp;rdquo;，其中&amp;lt;target&amp;gt;是要清理的数据库的名称。</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">这是可以接受的调用&lt;b&gt;sqlite_finalize&lt;/b&gt;在虚拟机上之前&lt;b&gt;sqlite_step&lt;/b&gt;返回SQLITE_DONE。这样做会中断正在进行的操作。部分完成的变化将被回滚，并且数据库将被恢复到其原始状态（除非替代恢复算法是使用正在执行的SQL的ON CONFLICT子句选择。）的效果是一样的，如果的回调函数&lt;b&gt;sqlite_exec&lt;/b&gt;民政事务返回非零。</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">在从未传递过&lt;b&gt;sqlite_step&lt;/b&gt;的虚拟机上调用&lt;b&gt;一次sqlite_finalize&lt;/b&gt;也是可以接受的。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">也可以为FTS5创建自定义标记器。&lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;此处描述了&lt;/a&gt;用于执行此操作的API 。</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">也可以自定义 unicode61 将其视为分隔符的代码点集。可以使用 &quot;separators=&quot;选项来指定一个或多个额外的字符作为分隔符,而 &quot;tokenchars=&quot;选项可以指定一个或多个额外的字符作为标记的一部分,而不是作为分隔符。例如</target>
        </trans-unit>
        <trans-unit id="c5f2716f625be713954d4be305f323e2da4e7532" translate="yes" xml:space="preserve">
          <source>It is also possible to express this kind of simultaneous read and write on an R-Tree within a single query, for example if an UPDATE statement tries to change the value of one row of the R-Tree based on a complicated query from another row of the same R-Tree, perhaps something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">向用于创建FTS5表的CREATE VIRTUAL TABLE语句添加类型，约束或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;声明是错误的。创建FTS5表后，可以像其他任何表一样使用&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句填充FTS5 表。像其他任何没有PRIMARY KEY声明的表一样，FTS5表具有名为rowid的隐式INTEGER PRIMARY KEY字段。</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">试图将sz或rawdata字段设置为NULL以外的任何值都是错误的。</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">将columnsize选项设置为0或1以外的任何值都是错误的。</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">第一次调用xToken()时,指定FTS5_TOKEN_COLOCATED标志是错误的。连续多次调用xToken(FTS5_TOKEN_COLOCATED),可以为单一标记指定多个同义词。同义词的数量没有限制。</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">假设游标只用于追加,所以如果游标有效,那么游标一定已经指向btree的末端,所以不会对游标进行任何修改。</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">假设按顺序向文件中写入一系列顺序的数据块比按任意顺序写入相同的数据块要快。</target>
        </trans-unit>
        <trans-unit id="b7995ee897a4d7d38d5bc734c7b7a1490089b50f" translate="yes" xml:space="preserve">
          <source>It is common for an application to invoke sqlite3_create_function() multiple times for the same SQL function. For example, if an SQL function can take either 2 or 3 arguments, then sqlite3_create_function() would be invoked once for the 2-argument version and a second time for the 3-argument version. The underlying implementation (the callbacks) can be different for both variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">它是通过调用sqlite3changegroup_new()来创建的。</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">更新 ZIP 存档中的单个条目很困难。更新 ZIP 存檔中的個別項目尤其困難,因為如果電腦斷電和/或在更新過程中發生故障,則不會破壞整個文件。要做到这一点并非不可能,但由于难度太大,实际上没有人这样做。相反,每当用户选择 &quot;文件/保存 &quot;时,整个ZIP存档就会被重写。因此,&quot;文件/保存 &quot;需要的时间比它应该的要长,特别是在旧硬件上。较新的机器速度更快,但在50兆字节的文件中改变一个字符会导致人们烧掉SSD上有限的50兆字节的写入寿命,这还是很麻烦的。</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">P1和P3是同一个寄存器是非法的。有时,如果P3与P2是同一个寄存器,那么实现能够避免memcpy()。</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">重要的是,所有对同一数据库文件的连接都使用相同的锁协议。如果一个应用程序使用POSIX咨询锁,而另一个应用程序使用点文件锁,那么这两个应用程序将看不到对方的锁,无法协调数据库访问,可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">需要注意的是,改变SQLite的版本可能会导致查询计划的改变。相同版本的SQLite总是会选择相同的查询计划,但如果你重新链接你的应用程序来使用不同版本的SQLite,那么查询计划可能会改变。在极少数情况下,SQLite版本变化可能会导致性能倒退。这是一个原因,你应该考虑将你的应用程序静态地链接到SQLite,而不是使用全系统的SQLite共享库,因为后者可能会在你不知情或无法控制的情况下发生变化。</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">重要的是要意识到，&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;都不会执行使用核心例程无法完成的任何操作。实际上，这些包装器仅根据核心例程来实现。</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">为了防止在写扇区时断电后数据库损坏,在回滚日志中存储扇区的所有页面是很重要的。假设第1、2、3、4页都存储在扇区1中,第2页被修改。为了将修改内容写入第2页,底层硬件还必须重写第1、3、4页的内容,因为硬件必须写入完整的扇区。如果这个写操作因断电而中断,第1、3或4页中的一个或多个页可能会留下不正确的数据。因此,为了避免数据库的持久损坏,所有这些页面的原始内容必须包含在回滚日志中。</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">理解这两种不同的 &quot;无服务器 &quot;定义很重要。当一个数据库声称自己是 &quot;无服务器 &quot;时,一定要辨别他们的意思是 &quot;经典无服务器 &quot;还是 &quot;新无服务器&quot;。</target>
        </trans-unit>
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">重要的是要验证gcov测试运行和第二个实际测试运行是否都给出了相同的输出。任何输出的差异都表明在SQLite代码中使用了未定义或不确定的行为(因此是一个bug),或者是编译器中的一个bug。请注意,在过去的十年中,SQLite在GCC、Clang和MSVC中都遇到了bug。编译器的bug虽然很少,但确实会发生,这就是为什么在已交付的配置中测试代码是如此重要。</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">我们不可能测试SQLite的每一个可能的编译时选项组合。但下面这组编译时选项是一个总是经过全面测试的配置。</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">当然，使用实际电源故障进行崩溃测试是不切实际的，因此崩溃测试是在仿真中完成的。插入了备用的&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;，该虚拟文件系统允许测试工具在崩溃后模拟数据库文件的状态。</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">如果命名的表在数据库中不存在,这并不是一个错误,如果命名的表没有PRIMARY KEY,也不是一个错误。如果命名的表没有PRIMARY KEY,也不是错误。但是,在这两种情况下都不会记录任何变化。</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">创建与现有&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;同名的表不是错误。</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">多次评估&lt;em&gt;完全相同的&lt;/em&gt; SQL语句通常没有用。通常，人们想评估类似的陈述。例如，您可能想使用不同的值多次评估INSERT语句。或者，您可能想使用WHERE子句中的不同键多次评估同一查询。为了适应这种情况，SQLite允许SQL语句包含在评估之前&amp;ldquo;绑定&amp;rdquo;到值的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。以后可以更改这些值，并且可以使用新值再次评估相同的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">在Git中找到签到的后代并非不可能。这只是困难。例如，有一个&lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow页面，&lt;/a&gt;显示用于在unix中查找签入后代的命令序列：</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">索引的每一列都不必出现在WHERE子句项中才能使用该索引。但是使用的索引列中不能有空白。因此，对于上面的示例索引，如果没有约束列c的WHERE子句，则约束列a和b的术语可以与索引一起使用，而不约束d到z的术语。同样，如果索引列位于仅受不等式约束的列的右侧，则通常将不使用（出于索引目的）。 （有关例外情况，请参见下面的&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">从会话集中提取变更集或补丁集后，无需删除会话对象。可以将其保留在数据库句柄上，并将像以前一样继续监视已配置表上的更改。但是，如果&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;再次&lt;/a&gt;在会话对象上调用sqlite3session_changeset（）或&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;，则更改集或补丁集将包含自创建会话以来在连接上进行的&lt;em&gt;所有&lt;/em&gt;更改。换句话说，通过调用sqlite3session_changeset（）或sqlite3session_patchset（）不会重置会话对象或将其清零。</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">对于第一次事务后的事务,没有必要在数据库头中增加更改计数器。这样做往往可以节省对回滚日志和主数据库文件的第一页的写入。</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">检索数据不需要用sqlite3_column_type()指定的格式,如果要求不同的格式,数据会自动转换。如果要求使用不同的格式,数据会自动转换。</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">单个FTS查询不可能返回具有不同languageid值的行。未添加使用其他运算符（例如lid！= 5或lid &amp;lt;= 5）的WHERE子句的结果。</target>
        </trans-unit>
        <trans-unit id="0859fe8615c2125c6e219976b0af5affb3b3243b" translate="yes" xml:space="preserve">
          <source>It is not possible to &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; a STORED column. One can add a VIRTUAL column, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">不可能对存储在无内容的FTS4表中的记录进行UPDATE或DELETE。试图这样做是一个错误。</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">进入WAL模式后，无论是在空数据库上，还是使用&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;或使用&lt;a href=&quot;backup&quot;&gt;备份API&lt;/a&gt;从备份中还原，都无法更改&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;。您必须处于回滚日志模式才能更改页面大小。</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">在&lt;a href=&quot;lang_transaction&quot;&gt;多语句事务&lt;/a&gt;的中间（当SQLite不在&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;自动提交模式时&lt;/a&gt;），不能启用或禁用外键约束。尝试这样做不会返回错误；它根本没有效果。</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">不可能使用 &quot;ALTER TABLE ...ADD COLUMN &quot;语法来添加一个包含REFERENCES子句的列,除非新列的默认值是NULL。试图这样做会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">一次在多个线程中读取或修改此变量是不安全的。如果在单独的线程中同时使用&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接，&lt;/a&gt;则不安全地读取或修改此变量。打算在进程初始化过程中以及在调用任何SQLite接口例程之前，一次设置此变量，此后此变量保持不变。</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">一次在多个线程中读取或修改此变量是不安全的。如果在单独的线程中同时使用&lt;a href=&quot;sqlite3&quot;&gt;数据库连接，&lt;/a&gt;则不安全地读取或修改此变量。打算在进程初始化过程中以及在调用任何SQLite接口例程之前，一次设置此变量，此后此变量保持不变。</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">可以为同一个单词建立多个条目,只要每个条目有不同的soundslike值。注意,如果没有指定soundslike值,soundslike默认为单词本身。</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">如果要静态链接两个或多个扩展,使用基于扩展文件名的入口点名称,而不是通用的 &quot;sqlite3_extension_init &quot;入口点名称尤为重要。如果你使用通用的名称,就会出现同一个符号的多个定义,链接就会失败。</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">允许注册同一函数的多个实现,名称相同,但参数数量不同,或首选文本编码不同。SQLite将使用最接近SQL函数使用方式的实现。一个具有非负的nArg参数的函数实现比一个具有负的nArg的函数实现更匹配。一个首选文本编码与数据库编码相匹配的函数,比编码不同的函数更匹配。编码差异在UTF16le和UTF16be之间的函数比编码差异在UTF8和UTF16之间的函数匹配度更高。</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">库编译时C预处理程序符号&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;可能会覆盖此编译指示设置。下表总结了&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;预处理程序宏和temp_store编译指示的交互：</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">证明者将来的增强可能使它能够认识到某些内置函数的NULL输入始终会导致NULL答案。但是并非所有内置函数都具有该属性（例如，&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;），并且当然，证明者将永远无法推理&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">可以建立一种特殊的&lt;a href=&quot;amalgamation&quot;&gt;合并方法&lt;/a&gt;，该方法可以与一组预定的SQLITE_OMIT _...选项一起使用。有关说明，请参见&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">可以在一个数据库句柄上创建多个会话对象。</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">当然,也可以扩展自定义或文件堆格式,但做起来往往要困难得多。如果添加了索引,那么所有修改相应表的应用程序代码都必须定位和修改,以保持这些索引的更新。如果增加了列,那么必须找到并修改所有访问相应表的应用代码,以考虑到新的列。</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">只要函数的两种形式的参数数量不同，就有可能具有与简单函数同名的聚合函数。例如，带有单个参数的&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max（）&lt;/a&gt;函数是一个聚合，带有两个或多个参数的&lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max（）&lt;/a&gt;函数是一个简单函数。集合函数通常也可以用作窗口函数。</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">为了SELECT DISTINCT和UNION的目的，可以使SQLite将NULL区别对待。为此，应在 &lt;code&gt;sqliteInt.h&lt;/code&gt; 源文件中更改NULL_ALWAYS_DISTINCT #define的值，然后重新编译。</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">通过在执行命令之前和之后检查&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; API 返回的值，可以判断'merge'命令是否找到了要合并的b树。如果两个值之间的差为2或更大，则执行工作。如果差异小于2，则&amp;ldquo;合并&amp;rdquo;命令为无操作。在这种情况下，至少在下一次更新FTS表之前，没有理由再次执行相同的&amp;ldquo;合并&amp;rdquo;命令。</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">可以向 &quot;t2 &quot;表写入,从而改变索引的内容。但是这样做会使 &quot;t1bc &quot;索引与其父表 &quot;t1 &quot;不同步。一个不同步的索引会导致不正确的查询结果。</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">建议应用程序通过明确地发出ROLLBACK命令来响应上述错误。如果事务已经被错误响应自动回滚,那么ROLLBACK命令就会以错误失败,但不会因此造成伤害。</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">从不同于当前正在运行数据库操作的线程的线程中调用此例程是安全的。但是，在sqlite3_interrupt（）返回之前已关闭或可能已关闭的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;中调用此例程并不安全。</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">从不同于当前正在运行数据库操作的线程的线程中调用此例程是安全的。但是，在sqlite3_interrupt（）返回之前已关闭或可能已关闭的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;中调用此例程并不安全。</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">在xConflict回调中执行SQL语句是安全的,包括那些写到回调相关的表的语句。这可以用来进一步定制应用程序的冲突解决策略。</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">有时,SQLite扩展可以方便地在子组件之间或扩展与应用程序之间进行非SQL值的通信。以下是一些例子。</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">用户仍有责任确保外部内容FTS5表的内容与内容表保持一致。一种方法是用触发器来实现。例如:</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">调用该函数成功后,调用者有责任最终在*ppOut指针上调用sqlite3_free()来释放缓冲区分配。</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">调用者有责任通过将迭代器传递给&lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）&lt;/a&gt;来最终销毁该迭代器。包含变更集（pChangeset）的缓冲区必须保持有效，直到销毁迭代器为止。</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">调用者有责任通过将迭代器传递给&lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）&lt;/a&gt;来最终销毁该迭代器。包含变更集（pChangeset）的缓冲区必须保持有效，直到销毁迭代器为止。</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">的确,应用程序有时会从不受信任的来源导入完整的二进制SQLite数据库文件,这种导入可能会带来一个可能的攻击载体。然而,SQLite中的那些代码路径是有限的,并且经过了极好的测试。而且对于想要读取不受信任数据库的应用程序来说,预验证例程可以帮助在使用前检测可能的攻击。</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">如果试图在数据库中创建一个新的表,而这个表已经包含了一个同名的表、索引或视图,这通常是一个错误。但是,如果在CREATE TABLE语句中指定了 &quot;IF NOT EXISTS &quot;子句,而同名的表或视图已经存在,那么CREATE TABLE命令就没有任何效果(也不会返回错误信息)。如果因为存在索引而无法创建表,即使指定了 &quot;IF NOT EXISTS &quot;子句,仍然会返回错误信息。</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">不能在包含&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;的数据库上使用它。</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">可能是合并中出现了冲突。当同一行代码在圈(1)和圈(4)与圈(2)和圈(3)之间被以不同的方式修改时,就会发生冲突。合并命令将宣布任何冲突,并在输出中包含冲突行的两个版本。你需要调出包含冲突的文件并手动解决冲突。</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">一定不能通过在左侧有一个数值(而不是字符串或blob)来使LIKE或GLOB操作符为真。这意味着,无论是。</target>
        </trans-unit>
        <trans-unit id="48d86628c63409da486bd0d69fb891667a6d8475" translate="yes" xml:space="preserve">
          <source>It never hurts to run the VACUUM, even if you don't need it. If the database is in WAL mode, you should shutdown and reopen all database connections before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">有必要转移到3.0版本来实现这些功能,因为每个功能都需要对数据库文件格式进行不兼容的修改。其他不兼容的变化,如清理API,也是同时引入的,因为理论上最好一次就把不兼容的变化全部解决掉。</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">它适用于unicode(UTF8)文本。</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">它的主日志存在,或者主日志名称是一个空字符串,以及</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">其大小大于512字节,并且</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.M.Robson。&quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;。</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON支持</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">加盟顺序</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">联接重新排序是自动的，通常效果很好，程序员不必考虑它，特别是如果使用&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;来收集有关可用索引的统计信息时。但是有时需要程序员的一些提示。例如，考虑以下架构：</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">日志文件格式</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">日志头格式</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">日志记录格式</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">计算机协会杂志</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">记录数据库页面</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">编写一页日记</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">阴历日数</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">如果寄存器P1中的值为False,则跳转到P2。如果它的数值为零,则认为是false,如果P3为非零,则跳转到P2。如果P1中的数值为NULL,那么只有当P3为非零时才进行跳转。</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">如果寄存器P1中的值为NULL,则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">如果寄存器P1中的值不是NULL,则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">如果寄存器P1中的值为真,则跳转到P2。如果该值是数值且非零,则认为是真。如果P1中的值为NULL,那么只有当P3为非零时才进行跳转。</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">取决于在最新的&lt;a href=&quot;opcode#Compare&quot;&gt;比较&lt;/a&gt;指令中P1向量分别小于等于还是大于P2向量，跳转到地址P1，P2或P3的指令。</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">跳转到寄存器P1中的地址之后的下一条指令。跳转后,寄存器P1变为未定义。</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">就像有用于管理ZIP存档的&amp;ldquo; zip&amp;rdquo;程序和用于管理Tarball的&amp;ldquo; tar&amp;rdquo;程序一样，也存在用于管理SQL存档的&lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&amp;ldquo; sqlar&amp;rdquo;程序&lt;/a&gt;。&amp;ldquo; sqlar&amp;rdquo;程序能够创建新的SQLite存档，列出现有存档的内容，从存档中添加或删除文件和/或从存档中提取文件。一个单独的&amp;ldquo; sqlarfs&amp;rdquo;程序能够将SQLite存档作为&lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse文件系统&lt;/a&gt;挂载。</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">要时刻警惕自己的生活行为。</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">每天把死亡放在眼前。</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">在转换为 NUMERIC 时,保持整数的全精度(如果可能的话)。票据 #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">关键点:</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">本篇文章的主要收获。</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">原始数据库文件内容的键/值存储。键是页码,值是二进制页面内容。</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">关键字参数可以选择用引号引起来。（例如： &lt;code&gt;'yes' [FALSE]&lt;/code&gt; 。）某些编译指示将字符串文字作为参数。当pragma使用关键字参数时，通常也将使用数值等效项。例如，&amp;ldquo; 0&amp;rdquo;和&amp;ldquo;否&amp;rdquo;与&amp;ldquo; 1&amp;rdquo;和&amp;ldquo;是&amp;rdquo;含义相同。查询设置的值时，许多编译指示会返回数字而不是关键字。</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">要知道,上帝到处都能看到你。</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">左键加入</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">LEFT JOIN消除经常出现的情况是在视图里面使用LEFT JOIN,然后视图在使用时,LEFT JOIN的右侧表的列都没有引用。</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">LEFT JOIN强度降低优化</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">实现了LEFT OUTER JOIN,但没有实现RIGHT OUTER JOIN或FULL OUTER JOIN。</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">喜欢优化</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">LIKE优化现在适用于带有 COLLATE NOCASE 的列。</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0现在不显示行。使用LIMIT-1可以看到所有的行。</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0现在适用于子查询</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">大型WAL文件</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">最后一次插入Rowid</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">后来,SQLite 3.6.16版本发布,如图中圆圈(4)所示。在这一点上,私有分支维护者做了一个合并,把从(1)到(4)的所有变化都应用到(3)中。结果是版本(5),也就是SQLite 3.6.16加上编辑。</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">前面的空格被去掉了。</target>
        </trans-unit>
        <trans-unit id="e52b8a48a53a875ca174a915ae5c47d6e94c2665" translate="yes" xml:space="preserve">
          <source>Leading zeros are handled properly, in the sense that they do not mess of the maginitude comparison of embedded strings of digits. &quot;x00123y&quot; is equal to &quot;x123y&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">叶子有效载荷分数。必须是32。</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">左操作数</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">找到左操作数</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">左对齐输出中的值。默认情况下是右对齐。如果宽度为零,或者小于被替换的值的长度,那么就没有填充,&quot;-&quot;标志是不行的。</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">旧版本(比3.22.0旧)的session模块不能捕获对sqlite_stat1表的修改。旧版本的sqlite3changeset_apply()函数会默默地忽略任何对sqlite_stat1表的修改,这些修改是变化集或补丁集的一部分。</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">Lemon没有自己的源码库。相反,Lemon由SQLite源代码树中的几个文件组成。</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">Lemon生成LALR（1）解析器。它的操作类似于更熟悉的工具&lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;，但是Lemon增加了重要的改进，包括：</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">Lemon有一个 &quot;后备 &quot;标记的概念。SQL语言中包含大量的关键字,这些关键字有可能与标识符名称发生碰撞。Lemon有能力指定一些关键字有能够 &quot;回落 &quot;到一个标识符。如果关键字出现在输入令牌流中,否则会出现语法错误的上下文,那么在语法错误产生之前,该令牌会自动转化为其回退。这个特性使得解析器对用作标识符的保留词非常宽容,这也是SQL语言中经常出现的问题。</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">Lemon有一个非终端析构器的概念,它可以用来在语法错误或其他中止的解析后回收内存或其他资源。</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">Lemon还用于为&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;扩展中的查询模式表达式生成解析。在这种情况下，输入语法文件是&lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">Lemon在SQLite中的两个地方使用。</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemon支持对语法文件规则进行有条件的编译,这样就可以根据编译时的选项生成不同的解析器。</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Lemon是由D.Richard Hipp(也是SQLite的创建者)在1987年到1992年期间在杜克大学读研究生时原创的。Lemon最初的创建日期已经丢失,但可能是1990年左右的某个时间。Lemon生成了一个LALR(1)解析器。曾有配套的LL(1)解析器生成工具名为 &quot;Lime&quot;,但Lime的源代码已经丢失。</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">长度规格</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">更少的管理意味着程序员将更多的时间用在软件上(在这里是SQLite),而不是在版本控制系统上大费周章。</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">少用内存</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">设K为M+((P-M)%(U-4))。</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">让X为((U-12)*64/255)-23。如果有效载荷大小P小于或等于X,那么整个有效载荷都存储在b树页上。让M为((U-12)*32/255)-23,让K为M+((P-M)%(U-4))。若P大于X,则索引b树页上存储的字节数为K,若K小于或等于X,否则为M。索引页上存储的字节数永远不会小于M。</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">让X为U-35。如果有效载荷大小P小于或等于X,那么整个有效载荷都存储在b树叶页上。让M为((U-12)*32/255)-23,让K为M+((P-M)%(U-4))。若P大于X,则表b树叶页上存储的字节数为K,若K小于或等于X,否则为M。叶页上存储的字节数永远不会小于M。</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">令X为部分索引的WHERE子句中的表达式，令W为使用索引表的查询的WHERE子句。然后，如果W&amp;rArr;X，则允许查询使用部分索引，其中&amp;rArr;运算符（通常发音为&amp;ldquo; implies&amp;rdquo;）等于&amp;ldquo; X or not W&amp;rdquo;的逻辑运算符。因此，确定部分索引在特定查询中是否可用减少了证明一阶逻辑的定理。</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">让X是最大的连续整数集{h,h+1,h+2,...,h+N},这样对于X中的每一个j,aPgno[j%8192]!=0.如果aPgno[h%8192]==0,X集将是空的。 X集很容易计算,从值h%8192开始,将h%8192加到X中,然后递增h,直到遇到第一个aPgno[h%8192]条目为零。</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">让数据库的页面大小(日记头偏移量24处的整数值)为N,那么页面记录的格式如下。</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">让数据类型 &quot;u8&quot;、&quot;u16 &quot;和 &quot;u32 &quot;分别表示长度为8、16和32位的无符号整数。那么,shm文件的第一个32768字节的单元组织如下。</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">设alice节点的数量为M,bob节点的数量为N,考虑两种情况。在第一种情况下,M和N都是2,但每个节点上有数千条边。在这种情况下,首选方案1。在方案1下,内循环检查一对节点之间是否存在边缘,如果发现就输出结果。但是由于alice和bob节点各只有2个,所以内循环只需要运行4次,查询速度非常快。方案2在这里需要的时间会更长。方案2的外循环只执行两次,但是因为每个alice节点有大量的边离开,所以中间的循环要迭代好几千次。速度会慢很多。所以在第一种情况下,我们更倾向于使用方案1。</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">让日记头中偏移量8处的页数值为M,如果M大于零,那么在M页记录后,日记文件可能会被零填充到扇区大小的下一个倍数,然后插入另一个日记头。同一日记本中的所有日记本头必须包含相同的数据库页面大小和扇区大小。</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">让我们假设你使用的是合并源码。将基线添加到你的项目中,如下所示。</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">假设OpenDocument没有使用ZIP存档来存储文件,而是使用了一个非常简单的SQLite数据库,其单表模式如下。</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">让我们使用下面的记法(与罗布森的记法相似但不相同)。</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">让我们成为现实。很少有人会严重质疑Git提供次佳的用户体验。许多底层实现都显示在用户界面中。界面是如此糟糕，以至于甚至有一个模仿网站都会生成&lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;伪造的git手册页&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">让我们再仔细看看这里发生了什么。第一个SELECT是由指令5到10的循环实现的。指令5通过重绕其光标来初始化循环。指令6从 &quot;examp &quot;中提取 &quot;two &quot;列的值,指令7将其转换为行。指令8将一个空字符串推到堆栈中。最后,指令9将该行写入临时表。但是请记住,PutStrKey操作码使用栈顶作为记录数据,栈上的下一个作为键。对于INSERT语句来说,MakeRecord操作码生成的行是记录数据,记录键是NewRecno操作码创建的整数。但是这里的角色是相反的,MakeRecord创建的行是记录键,记录数据只是一个空字符串。</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">用C语言编写的库没有巨大的运行时依赖性。在其最低配置中,SQLite只需要标准C库中的以下例程。</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">用C++或Java编写的库一般只能被用同一种语言编写的应用程序使用。要让一个用Haskell或Java编写的应用程序调用一个用C++编写的库是很困难的。另一方面,用C语言编写的库可以从任何编程语言中调用。</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">库大小优化。</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">像--file一样，将文件FILE用作存档，但是使用&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt;打开文件，以便在FILE已经存在的情况下将存档附加到FILE的末尾。</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">与无内容表一样,外部内容表不支持REPLACE冲突处理。任何指定REPLACE冲突处理的操作都会使用ABORT处理。</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">像其他虚拟表类型一样，使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句创建新的FTS表。在USING关键字之后的模块名称为&amp;ldquo; fts3&amp;rdquo;或&amp;ldquo; fts4&amp;rdquo;。虚拟表模块自变量可以保留为空，在这种情况下，将创建带有单个用户定义列名为&amp;ldquo; content&amp;rdquo;的FTS表。可选地，可以向模块自变量传递以逗号分隔的列名称的列表。</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">和sqlite3rbu_step()一样,如果真空操作已经完成,sqlite3rbu_close()返回SQLITE_DONE。如果真空操作没有完成,但没有发生错误,则返回SQLITE_OK。或者,如果发生了错误,则返回一个SQLite错误代码。如果在之前调用sqlite3rbu_step()的过程中发生了错误,sqlite3rbu_close()将返回相同的错误代码。</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">与&quot;.dump &quot;命令一样,&quot;.recover &quot;试图将数据库文件的全部内容转换为文本。不同的是,&quot;.recover &quot;不是使用正常的SQL数据库接口读取数据,而是试图根据直接从尽可能多的数据库页面中提取的数据来重新组合数据库。如果数据库已经损坏,&quot;.recover &quot;通常能够从数据库所有未损坏的部分恢复数据,而&quot;.dump &quot;则在遇到第一个损坏迹象时停止。</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">极限设置</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">限制&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;生成的输出量。</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">限制JSON对象和数组的递归深度，以避免递归下降解析器中过多的堆栈使用。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">限制和注意事项</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">OpenDocument演示格式的局限性</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">SQLite中的限制</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">以 &quot;#&quot;开头的行和不在SQL语句中间的行被解释为注释。</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">将SQLite与一个测试程序进行链接,该程序运行约30,000条代表典型工作负载的SQL语句。</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">2006-06-27,Linus Torvalds在Git邮件列表中用不同的词来表达同样的意思。</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">常量清单:</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">功能清单:</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">对象列表:</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">PRAGMAs清单</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">SQLite常量列表</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">SQLite函数列表</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">SQLite对象列表</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">虚拟表列表</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">在处理过程中列出每个文件。</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">列出归档的内容,如果没有指定参数,则列出所有文件。如果没有指定参数,则列出所有文件。否则,只有那些指定为参数的文件才会被列出。目前,--verbose选项不会改变此命令的行为。将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">列出存档中的文件。</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">IN右侧的列表值被视为必须具体化的子查询。换句话说,前一条语句的行为就像。</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">下面列出了一些情况下,可能有意义的添加额外的soundlike条目。具体的条目将取决于应用程序和目标语言。</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">心甘情愿地聆听圣洁的读书声。</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">字面值(常量)</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">字面价值</target>
        </trans-unit>
        <trans-unit id="402377f4fa54f586c7bcf70486179fb514f52098" translate="yes" xml:space="preserve">
          <source>Literal values: numeric or string constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">LoC建议的存储格式</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">加载延长线</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">将表之间的差异加载到一个会话中。</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">在计算差异之前，将共享库或DLL文件LIBRARY加载到SQLite中。这可用于添加架构所需的应用程序定义的&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">可加载的扩展通克</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">可加载的扩展是C代码。要在大多数类似unix的操作系统上编译它们,通常的命令是这样的。</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">本地删除</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">本地插入</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">本地更新</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">当地时间修改器</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">锁名</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">锁定偏移</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">锁定和并发</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">锁定和并发控制由&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;寻呼机模块&lt;/a&gt;处理。传呼机模块负责使SQLite成为&amp;ldquo; ACID&amp;rdquo;（原子，一致，隔离和持久）。分页器模块确保所有更改都立即发生，或者所有更改都发生，或者所有更改都没有发生，两个或多个进程不会尝试以不兼容的方式同时访问数据库，并且一旦写入更改，它们坚持到明确删除为止。分页器还提供磁盘文件某些内容的内存缓存。</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">多头期权</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">长期支持</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">长式和短式可以混合选择。例如,以下是等价的:</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">更长的答案：如果您将表的某列声明为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，则每当您在表的该列中插入NULL时，该NULL都会自动转换为一个整数，该整数比该列的最大值大1表中的所有其他行；如果表为空，则为1。或者，如果正在使用最大的现有整数键9223372036854775807，则随机选择一个未使用的键值。例如，假设您有一个像这样的表：</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">新&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接的&lt;/a&gt;后备缓冲区分配。</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">旁观者内存分配器</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">大量的BUG修复。</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">很多小bug的修复。</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">爱惜贞操。</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">爱吃斋。</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">爱你的敌人。</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">爱你的小辈们。</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">数据库文件的低级控制</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">低级系统错误代码</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">最低优先级(最松散的分组)。</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1e549c8c539e5dd3fb33fffd4ca9bec2df1c3d6b" translate="yes" xml:space="preserve">
          <source>M &amp;amp;times 2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">M总是((U-12)*32/255)-23。</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">MASK位0x02被设置。</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Mac类似于unix,但它们并不遵循通常的共享库惯例。要在Mac上编译一个共享库,请使用类似这样的命令。</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">在API函数&lt;b&gt;const中&lt;/b&gt;选择参数。这应该是完全向后兼容的。</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">使&lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop模糊器&lt;/a&gt;成为SQLite &lt;a href=&quot;testing&quot;&gt;测试策略&lt;/a&gt;的标准部分。</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">使CACHE_SIZE pragma持久化。</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">神奇的数字。0x377f0682 或 0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">维持100％的MC / DC既费力又费时。对于典型的应用程序而言，维持全覆盖测试所需的精力水平可能并不划算。但是，我们认为完全覆盖的测试对于像SQLite这样&lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;广泛部署的&lt;/a&gt;基础结构库是有道理的，尤其是对于数据库库，由于其本质，它可以&amp;ldquo;记住&amp;rdquo;过去的错误。</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">维护SQLite的私有分支</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">使&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt;响应&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">在WinCE中把AreFileApisANSI()作为一个无操作的宏,因为WinCE不支持这个函数。</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">使命令行shell的CSV(逗号分隔值)输出更符合公认的做法。</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">让LIMIT在复合SELECT语句上工作。</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">将寄存器P1...P1+P3复制到寄存器P2...P2+P3中。</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">排序时要区分数字值和文本值。文本值根据memcmp()进行排序。数字值按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">将寄存器P1浅层复制到寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">尽力分配一个新的页面。只有在不可能分配新页面的情况下才返回NULL。</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">在太阳落山之前,与你的对手和平相处。</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">即使使用降序索引实现DISTINCT运算符，也请确保ORDER BY将行按升序排列。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">确保在外壳中的&lt;b&gt;.dump&lt;/b&gt;命令的输出中在对应的TABLE之后创建VIEW 。</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">确保所有单独的数据库文件都有一个EXCLUSIVE锁和一个有效的日志。</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">确保所有的回滚日志数据已经实际写入磁盘表面(而不仅仅是保存在操作系统或磁盘控制器的缓存中),这样如果发生电源故障,数据在电源恢复后仍然存在。</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">确保INSERT的VALUES子句中的函数表达式是正确的。</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">确保数据库文件名遵循8+3的文件名格式,并且没有空名或扩展名。换句话说,数据库文件名的基本名称必须包含1到8个字符,扩展名必须包含1到3个字符。不允许使用空白的扩展名。</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">确保当一个连接阻塞在一个RESERVES锁上时,它能够在锁被释放后继续。(Ticket #3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">确保单个语句中来自多个触发器的&lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata（）&lt;/a&gt;值不会相互干扰。票证&lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">如果缓冲区大小小于1，请确保&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;接口不会使缓冲区零终止。票号＃2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">确保MIN()和MAX()优化在子查询中工作。</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">确保ORDER BY LIMIT优化（从签入&lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;）与INTEGER PRIMARY KEY上的IN运算符一起使用。修复票务&lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96C1454C&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">确保TCL语言接口在64位机器上与64位整数正确工作。</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">如果malloc()失败,请确保内存后端响应理智。</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">确保查询优化器检查复合SELECT语句的所有术语的依赖性。Ticket #2640.</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">确保你在每条SQL命令的结尾处输入一个分号!sqlite3程序会在你的SQL命令完成时寻找分号。sqlite3程序会寻找分号来知道你的SQL命令何时完成。如果你省略了分号,sqlite3会给你一个继续提示,并等待你输入更多的文本添加到当前的SQL命令中。这个功能允许你输入跨越多行的SQL命令。例如</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">让这个脚本可以执行,并把它放在你的$PATH上。然后编译 kvtest 程序如下。</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">再把 &quot;AS &quot;这个关键词变成可选的。</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">使用&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;选项进行编译时，使&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;成为标准构建的一部分。</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">使GLOB和LIKE运算符成为可以被程序员覆盖的函数。例如,可以将LIKE运算符改为区分大小写。</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">使LIMIT子句对子查询有效。(虽然ORDER BY仍然不能工作。)</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">让库的线程安全。(代码是存在的,似乎可以工作,但没有强调。)</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">使 os.h 头文件在检测何时为 Windows 编译和何时为 Unix 编译时更加强大。</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">在Windows &lt;a href=&quot;vfs&quot;&gt;VFS中&lt;/a&gt;使用OVERLAPPED 可以避免某些系统调用，从而提高性能。</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">在适当的地方，使用&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;中的一遍UPDATE和DELETE查询计划。</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Makefile更新</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Makefile更新和杂项错误修复。</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">A.Rottmann的Makefile更新。</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">进行其他类型的表模式更改</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">畸形数据库测试</target>
        </trans-unit>
        <trans-unit id="aa578a91aad5dc4dab2da9a4bac602790d836ae2" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement (an ALTER TABLE that tries to rename a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; into one of its own &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;) causes an infinite loop and denial of service. &lt;a href=&quot;https://sqlite.org/src/info/eca0ba2cf4c0fdf7&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3505da2486b779eca8455a74c0a2213782342dc" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/1bc783da63d58b05&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3de4ef5153133c67b1a8788b48babe0af12634" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/862974312edf00e9&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05b51d00c5136f9765e2a5529ff25dd76521560" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/a80f84b511231204&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3223f276a85bbea2e40f22c66ab04105f353da0b" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/cc0fb00a128fd077&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be787da663e373d3f7997d1441cd2ca035e3495f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read access to a NULL pointer and denial of service. &lt;a href=&quot;https://www.sqlite.org/src/info/7a5279a25c57adf1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7808ef1d93533f98b34a6af3e305d6a4a79902" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read of a NULL pointer in the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, resulting in denial of service. &lt;a href=&quot;https://sqlite.org/src/info/a4dd148928ea65bd&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5500a4c4534dd4662f8932a169f8e6f4053c24" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/4374860b29383380&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a51de55d02f39c503f43bf8dbb67b4a981750f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/af4556bb5c285c08&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f420ed40458097230e18bc609dc3d6070a139e7" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free memory error. &lt;a href=&quot;https://sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7315e30c332568a87d33624f52296d256dba71" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free, possibly resulting in a incorrect output from the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension. There is no known way to exfiltrate data or crash the application using this bug. &lt;a href=&quot;https://sqlite.org/src/info/0d69f76f0865f962&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605174f0d56c0319ea8c88e54fd141ec899039f3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a uninitialized pointer reference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/e2bddcd4c55ba3cb&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3d15a3efb587f7e5d31ca19ff99f19bff90311" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an read past the end of a heap buffer. &lt;a href=&quot;https://sqlite.org/src/info/8f157e8010b22af0&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3460af9ab9b12af9da67324f2da63f63e80a6848" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/cba2a2a44cdf138a&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b341edff7ed671940a8d972691c324a8c7d62137" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/timeline?r=better-error-handling-1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be80211b17a199f937f0a9b644dfd18f1e2cecb3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes read-only use-after-free of memory allocation if SQLite is compile with -DSQLITE_DEBUG. Does not affect release builds. &lt;a href=&quot;https://www.sqlite.org/src/info/4722bdab08cb1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aacfe82b6d869ef75232c639a3bc16d905426f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement involving the printf() SQL function results in an integer overflow which can overwrite the stack with over 2 billion bytes of 0x30 or 0x20 (ASCII '0' or ' '). Even though this is a stack overwrite, there is no known way to redirect control or otherwise escalate the level of harm. This is a denial-of-service attack only. &lt;a href=&quot;https://www.sqlite.org/src/info/23439ea582241138&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">从命令行管理SQLite档案</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">支持Manifest Typing和BLOB。</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">支持Manifest typing和BLOB。</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">使用CROSS JOIN手动控制查询计划。</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">使用SQLITE_STAT表手动控制查询计划。</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">许多SQLITE_OMIT_宏插入,在编译时省略功能,减少库的占用。</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">许多SQLite函数都会从这里显示的集合中返回一个整数结果代码,以表示成功或失败。</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">在SQLite中,很多小的查询都是高效的</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">许多应用程序在关闭时通过调用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;破坏其&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。或者，例如，使用SQLite作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式的应用程序&lt;/a&gt;可能会响应于File / Open菜单操作而打开&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;，然后响应于File / Close菜单而销毁相应的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">许多应用程序使用SQLite作为来自企业RDBMS的相关内容的缓存。这减少了延迟,因为现在大多数查询都是针对本地缓存进行的,避免了网络往返。它还降低了网络和中央数据库服务器的负载。在许多情况下,这意味着客户端应用程序可以在网络中断期间继续运行。</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">许多代码简化和模糊的错误修复，以支持提供&lt;a href=&quot;testing#coverage&quot;&gt;100％的分支测试覆盖率&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">许多文件更新</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">在&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;子目录的SQLite源代码树中可以看到许多完整且可用的可扩展扩展的示例。该目录中的每个文件都是一个单独的扩展名。文档由文件的标题注释提供。这是&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;子目录中一些扩展的简要说明：</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">对配置脚本进行了许多改进和清理。</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">壳的许多改进和提高。</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">测试套件的许多改进。测试覆盖率现在超过98%。</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">与以前的版本相比，许多微优化导致相同数量的CPU周期的工作量增加了20.3％。自&lt;a href=&quot;#version_3_8_0&quot;&gt;3.8.0版&lt;/a&gt;以来，累积性能提高了61％。（在具有gcc 4.8.1和-Os的Ubuntu 13.10 x64 上的&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt;工作负载上使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;进行测量。您的性能可能会有所不同。）</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">很多微优化,使得库的速度比之前的版本更快。</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">许多小的错误修复</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">修复了许多烦人的BUG。</target>
        </trans-unit>
        <trans-unit id="a8c23cdfb8fba87694bb2dbb013754a5354d8db3" translate="yes" xml:space="preserve">
          <source>Many of the parameters passed to the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces are common across the entire family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C语言接口&lt;/a&gt;中的许多例程都返回数字结果代码，它们指示成功或失败，并且在失败的情况下，提供了一些导致失败的原因的想法。本文档致力于解释每个数字结果代码的含义。</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">许多操作,特别是I/O密集型操作,由于内容确实需要在内核空间和用户空间之间复制,因此可以更快。</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">许多程序使用&lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen（）&lt;/a&gt;，&lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread（）&lt;/a&gt;和&lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite（）&lt;/a&gt;来创建和管理本地格式的数据文件。SQLite可以很好地替代这些</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">许多读者推荐了各种Git的第三方GUI,它们或许能更好地显示历史开发活动。也许其中一些确实比原生Git和/或GitHub更好用,尽管它们都会因为Git不能在同步中保存历史分支名而受到影响。即使这些其他工具更好,但必须通过第三方工具才能获得所需信息的事实也不能说明核心系统的好坏。</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">许多小的性能优化。</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">很多很多的bug修复和兼容性增强。</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">许多,许多小的错误修复和文档更新。</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">主日志指针</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">主日志</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">主期刊</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">如果query1和query2都匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">如果query1或query2匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">如果query1匹配而query2不匹配,则匹配。</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">Matchinfo b旗</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">Matchinfo x flag</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">Matchinfo和旗帜</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">视图和子查询的具体化</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">数学运算符（+，-，*，/，％，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，＆和|）将两个操作数都视为数字。 STRING或BLOB操作数会自动转换为REAL或INTEGER值。如果STRING或BLOB看起来像实数（如果它具有小数点或指数），或者该值超出了可以表示为64位有符号整数的范围，则它将转换为REAL。否则，操作数将转换为INTEGER。数学操作数的隐式类型转换与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST到NUMERIC&lt;/a&gt;略有不同，因为字符串和看起来像实数但没有小数部分的BLOB值保持为REAL而不是像&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST到NUMERIC&lt;/a&gt;那样转换为INTEGER。即使是有损且不可逆的，也要执行从STRING或BLOB到REAL或INTEGER的转换。一些数学运算符（％，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;和＆|）期望使用INTEGER操作数。对于那些运算符，将REAL操作数转换为INTEGER的方式与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER的&lt;/a&gt;方式相同。 &amp;lt;&amp;lt;，&amp;gt;&amp;gt;，＆和|运算符始终返回INTEGER（或NULL）结果，但是％运算符根据其操作数的类型返回INTEGER或REAL（或NULL）。数学运算符上的NULL操作数将产生NULL结果。数学运算符上的操作数将不会以任何形式出现且不是NULL，将转换为0或0.0。除以零的结果为NULL。</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">最大内嵌有效载荷分数。必须是64。</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">最大行数</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">最大xShmLock指数</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">最大开放参数</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">愿你行善不作恶</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">愿你为自己找到宽恕,也为他人找到宽恕。</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">愿你能自由分享,永远不取多于付出。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">使用这些命令测量从数据库和从单个文件读取 blobs 的性能。</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">通过添加--update选项来衡量写入性能。这将导致 blobs 被另一个大小完全相同的随机 blob 覆写。</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">在Ubuntu 16.04的x64上使用gcc 5.4.0和-Os的cachegrind进行测量。</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">以上测量是使用&lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;2017&lt;/a&gt;年10月8日的SQLite版本5594a121bf132a98进行的。</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">测量和降低SQLite中的CPU使用率</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">内存分配例程</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">内存分配子系统</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">内存分配器统计</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">記憶體插槽</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">结合使用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，...）开始时间选项和&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;编译时间选项，可以禁用内存记帐。</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">结合使用&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，...）开始时间选项和&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;编译时间选项，可以禁用内存记帐。</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">除非使用&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0 编译SQLite，否则默认情况下将启用内存分配统计信息，在这种情况下，默认情况下将禁用内存分配统计信息。</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">除非使用&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0 编译SQLite，否则默认情况下将启用内存分配统计信息，在这种情况下，默认情况下将禁用内存分配统计信息。</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">内存分配，无大小写的字符串比较例程，可移植的文本数字转换例程以及其他实用程序位于&lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c中&lt;/a&gt;。解析器使用的符号表由&lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c中的&lt;/a&gt;哈希表维护。该&lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt;源文件包含Unicode转换子程序。 SQLite的有它自己的私有实现的&lt;a href=&quot;printf&quot;&gt;（）的printf&lt;/a&gt;（标有一些扩展）&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;并在其自己的伪随机数生成器（PRNG）&lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">内存统计</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">从malloc（）获得用于保存&lt;b&gt;sqlite_get_table&lt;/b&gt;返回的信息的内存。但是调用函数不应尝试直接释放此信息。相反，当不再需要该表时，请将完整的表传递给&lt;b&gt;sqlite_free_table&lt;/b&gt;。可以安全地使用NULL指针调用&lt;b&gt;sqlite_free_table&lt;/b&gt;，如果结果集为空，则将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">内存映射I/O</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4和memsys6是2007年左右推出的实验性内存分配器,后来在2008年左右从源树中删除,因为它们显然没有增加新的价值。</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">将开发变更合并到主干中。未来使用BTree文件结构的工作将使用一个单独的CVS源代码树。这个CVS树将继续只支持GDBM版本的SQLite。</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatch可以添加，修改或删除JSON对象的元素，因此对于JSON对象，json_patch（）例程是&lt;a href=&quot;json1#jset&quot;&gt;json_set（）&lt;/a&gt;和&lt;a href=&quot;json1#jrm&quot;&gt;json_remove（）&lt;/a&gt;的通用替代。但是，MergePatch将JSON数组对象视为原子对象。MergePatch不能追加到数组，也不能修改数组的单个元素。它只能作为单个单元插入，替换或删除整个阵列。因此，当处理包含数组的JSON时，json_patch（）并不有用，尤其是具有很多子结构的数组。</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">合并的&lt;a href=&quot;sessionintro&quot;&gt;会议&lt;/a&gt;延长到躯干。</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">元数据通过写入作为该函数第5个和后续参数传递的内存位置来返回。这些参数中的任何一个都可以是NULL,在这种情况下,相应的元数据元素将被省略。</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">方法(2)提供了(1)和(3)之间的中间点。使用这种方法,像 &quot;1s*&quot;这样的查询将匹配包含字面标记 &quot;1st &quot;但不包含 &quot;first &quot;的文档(假设标记器不能提供前缀的同义词)。然而,像 &quot;1st &quot;这样的非前缀查询将与 &quot;1st &quot;和 &quot;first &quot;匹配。这种方法不需要额外的磁盘空间,因为没有额外的条目被添加到FTS索引中。另一方面,运行MATCH查询可能需要更多的CPU周期,因为每个同义词都需要单独查询FTS索引。</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;，&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;，&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;，&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;，&lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">方法：&lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;，&lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">数以百万计的测试案例</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">最小内嵌有效载荷分数。必须是32。</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">最小行数</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">对网站进行小幅修改。</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">小幅修改语法以支持更多的编译器。</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">对其他代码进行小幅调整,使其运行速度更快一些。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">其他&lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt;减少约2.1％的CPU使用率。</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">杂项代码大小优化和错误修复。</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">杂项文件的改进。</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">各种微优化使普通工作负载的CPU使用率降低了7％以上。此版本中的大多数优化都在前端（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;）上进行。</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">与以前的版本相比，在相同的CPU周期数下，其他各种微优化导致的工作量增加了22.3％。SQLite现在的运行速度是&lt;a href=&quot;#version_3_8_0&quot;&gt;3.8.0版的&lt;/a&gt;两倍，是&lt;a href=&quot;#version_3_3_9&quot;&gt;3.3.9版的&lt;/a&gt;三倍。（在具有gcc 4.8.2和-Os的Ubuntu 14.04 x64 上的&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt;工作负载上使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;进行测量。您的性能可能会有所不同。）</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">杂项小错误修复</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">其他优化可将&lt;a href=&quot;cpu&quot;&gt;使用的CPU周期&lt;/a&gt;减少2％。</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">杂项性能改进</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">&quot;债&quot;、&quot;孓&quot;、&quot;阮&quot;、&quot;万奴 &quot;等杂问题词。</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">缺少回调</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">当磁盘访问是顺序访问时，现代文件系统运行得更快。因此，如果数据库文件的内容在连续页面上，SQLite将运行得更快。要找出数据库中哪些页面是连续的（从而获得度量值，这对于确定何时使用&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;可能有用），请运行如下查询：</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">修改&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;接口以支持更广泛的嵌入式系统。有关更多信息，请参见&lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt;。***可能不兼容的更改***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">对&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器的&lt;/a&gt;修改，使解析器表小4倍。</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">修改了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH，&lt;/a&gt;以在缓冲区大小计算中删除&amp;ldquo; +4&amp;rdquo;幻数。</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell程序，以便在显式请求的情况下为内置SQLITE_MASTER表打印模式。</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell程序以使用新的接口例程。</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell，以使用新的sqlite_get_table（）API来打印多列的表列表，类似于&amp;ldquo; ls&amp;rdquo;打印文件名的方式。</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">修改了&lt;b&gt;sqlite&lt;/b&gt; shell，以在&amp;ldquo; .schema&amp;rdquo;命令的输出中的每个CREATE语句的末尾打印分号。</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">修改了B-Tree和Pager模块,使不包含真实数据的磁盘页(空闲页)不写日记,当它们发生变化时,不从内存写回磁盘。这并不影响数据库的完整性,因为这些页面不包含真实数据,但它确实使大型INSERT操作快了约2.5倍,大型DELETE快了约5倍。</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">修改了日志文件格式,使其更能抵御操作系统崩溃或断电后可能出现的损坏。</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">修改TCL接口以使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">修改测试脚本,以确定依赖于系统负载和处理器速度的测试,并警告用户,这些(罕见的)测试之一的失败并不一定意味着库发生了故障。不修改代码。</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">修改数据库页面的内容。</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">修改、添加或截断数据库页面。</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">更激进的&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">当一边或另一边总是假的时候,更积极地优化AND运算符。</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">比较复杂的查询可能采用查询扁平化,也可能不采用查询扁平化来避免临时表。查询能否被扁平化取决于子查询或外层查询是否包含聚合函数、ORDER BY或GROUP BY子句、LIMIT子句等因素。什么情况下查询可以扁平化,什么情况下不能扁平化,这些规则非常复杂,不在本文的讨论范围之内。</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">更有效地对布尔值进行编码,从而使数据库文件更小。</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">更有效地处理&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;，尤其是在应用程序定义数百或数千个自定义函数的情况下。</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">在 Windows 下更高效地实现 sqliteFileExists()。(作者:Joel Luscy)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">更强大的内存外错误处理。</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">更多建议...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">在一个查询中可能会出现一个以上的NEAR操作符。在这种情况下,由NEAR操作符分隔的每一对术语或短语必须出现在文档中指定的相邻范围内。使用与上述示例块中相同的表格和数据。</target>
        </trans-unit>
        <trans-unit id="759136a5c089af122dabc1e0771753f48776ccec" translate="yes" xml:space="preserve">
          <source>Most CVEs written about SQLite assume that the attacker is able to run arbitrary SQL scripts in SQLite. In most applications, this means that there must first be an SQL Injection vulnerability that allows the attacker to inject the malicious SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">大多数R*Tree查询都使用深度优先搜索。这是通过将rScore设置为iLevel来实现的。深度优先搜索通常是首选,因为它可以使优先级队列中的元素数量最小化,从而减少内存需求并加快处理速度。然而,一些应用程序可能更喜欢广度优先搜索,这可以通过将rScore设置为mxLevel-iLevel来实现。通过为rScore创建更复杂的公式,应用程序可以对搜索子树和返回R*Tree叶子条目的顺序进行详细控制。例如,在一个有数百万个 R*Tree 条目的应用程序中,rScore 可能会被安排为首先返回最大或最重要的条目,使应用程序能够快速显示最重要的信息,并在它们可用时填写较小和不太重要的细节。</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">大多数SQL数据库引擎(据我们所知,除了SQLite之外的所有SQL数据库引擎)都使用静态的、刚性的类型。通过静态类型化,一个值的数据类型由它的容器--存储该值的特定列决定。</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">大多数SQL数据库引擎都是基于客户端/服务器的。在那些无服务器的数据库引擎中,SQLite是笔者所知的唯一一个允许多个应用程序同时访问同一个数据库的引擎。</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">大多数SQL数据库引擎都是基于客户端/服务器的。在那些无服务器的数据库引擎中,SQLite是笔者所知的唯一一个允许多个应用程序同时访问同一个数据库的引擎。</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">大多数SQL数据库引擎是作为一个独立的服务器进程来实现的。想要访问数据库的程序使用某种进程间通信(通常是TCP/IP)与服务器通信,向服务器发送请求并接收返回的结果。SQLite不是这样工作的。在SQLite中,想要访问数据库的进程直接从磁盘上的数据库文件进行读写。没有中间的服务器进程。</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">大多数SQL数据库引擎将已经解析好的模式存储在各种系统表中。在这些数据库引擎上,ALTER TABLE只需要对相应的系统表进行修改即可。</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">大多数SQL数据库引擎都使用静态类型。一个数据类型与表中的每一列相关联,并且只允许在该列中存储该特定数据类型的值。SQLite通过使用manifest typing放宽了这种限制。在manifest typing中,数据类型是值本身的一个属性,而不是存储值的列的属性。因此,SQLite允许用户将任何数据类型的值存储到任何列中,而不管该列的声明类型是什么。(这个规则也有一些例外。一个INTEGER PRIMARY KEY列只能存储整数。而且SQLite试图在可以的情况下,将值胁迫到该列的声明数据类型中。)</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">大多数应用格式都符合这三类中的一类。</target>
        </trans-unit>
        <trans-unit id="d19cf0ebd0035eff768792dfdb24fc34ef35cd23" translate="yes" xml:space="preserve">
          <source>Most applications can use SQLite without having to worry about bugs in obscure SQL inputs. If the application controls the SQL, and the application is not deliberately trying to break SQLite, then everything should just work. It is not necessary to have the latest patched version of SQLite. Any older version should work just fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">大多数应用程序将只使用上一节中描述的会话模块功能。然而,以下附加功能可用于使用和操作更改集和补丁集 blobs。</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">大多数应用程序都可以在默认配置下使用SQLite，并且无需特殊的编译时配置。大多数开发人员应该能够完全忽略该文档，而无需进行任何特殊知识并且无需采取任何特殊措施即可简单地从&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;构建SQLite 。</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">大多数构建还使用系统内存分配例程。</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">大多数内置窗口函数都会忽略frame-spec,例外情况是first_value()、last_value()和nth_value()。将 FILTER 子句指定为内置窗口函数调用的一部分是语法错误。</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">大多数内存统计都是全局的,因此对统计的跟踪必须用mutex序列化。统计功能在默认情况下是打开的,但存在一个选项可以禁用它们。通过禁用内存统计,SQLite避免了在每次内存分配和deallocation时进入和离开一个mutex。在Mutex操作成本很高的系统中,这种节约是很明显的。要禁用内存统计,在启动时使用以下接口。</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">大多数对象引用只能解析为特定类型的对象（例如，作为DROP TABLE语句一部分的引用只能解析为表对象，而不是索引，触发器或视图）。但是，在某些情况下（例如&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;），对象引用可以解析为一种以上类型的对象。在数据库模式中搜索命名对象时，总是会忽略在引用上下文中无法使用的类型的对象。</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">SQLite源代码树中的大多数代码纯粹用于&lt;a href=&quot;testing&quot;&gt;测试和验证&lt;/a&gt;。可靠性对SQLite很重要。测试基础结构的任务之一是确保SQLite不会滥用动态分配的内存，SQLite不会泄漏内存，并且SQLite能够正确响应动态内存分配失败。</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">大多数情况下,sqlite3只是读取输入行,并将其传递给SQLite库执行。但是以点(&quot;.&quot;)开头的输入行会被sqlite3程序本身拦截和解释。这些 &quot;点命令 &quot;通常用来改变查询的输出格式,或者执行某些预包装的查询语句。最初的点命令只有几个,但经过多年的发展,积累了许多新的功能,所以今天已经有60多个。</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">大多数时候,SQLite中的查询规划器做得很好。然而,查询规划器需要索引来工作。这些索引通常必须由程序员添加。罕见的情况下,查询规划器AI会做出一个次优的算法选择。在这些情况下,程序员可能要提供额外的提示,以帮助查询规划器做得更好。</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">大多数其他SQL数据库引擎为大多数表的每一行分配了固定的磁盘空间。它们在处理BLOB和CLOB时玩了一些特殊的技巧,这些BLOB和CLOB的长度可能大不相同。但是对于大多数表来说,如果你声明一个列是VARCHAR(100),那么无论你在该列中实际存储了多少信息,数据库引擎都会分配100字节的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">大多数其他SQL数据库引擎都比这个大得多。IBM吹嘘其最近发布的CloudScape数据库引擎 &quot;只有 &quot;2MiB的jar文件--即使经过压缩,也比SQLite大了一个数量级!而Firebird则吹嘘其客户端库只有350KiB。Firebird吹嘘其客户端库只有350KiB。这和SQLite一样大,甚至不包含数据库引擎。Oracle的Berkeley DB库是450KiB,它省略了对SQL的支持,只给程序员提供简单的键/值对。</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">大多数其他SQL数据库引擎在从一个平台转移到另一个平台时,以及在升级到一个较新版本的软件时,经常要求你转储和恢复数据库。</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">大多数程序员使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;功能将SQLite编译到其应用程序中。该&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;是C代码，但它不是&amp;ldquo;源代码&amp;rdquo;。该&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;被从源代码由脚本生成。</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">SQLite中的大多数表由零个或多个行组成，带有唯一的整数键（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;），后跟内容。（&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表除外）。逻辑上，按行号递增的顺序存储行。例如，本文使用一个名为&amp;ldquo; FruitsForSale&amp;rdquo;的表，该表将各种水果与它们的种植州和市场单价相关。模式是这样的：</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">在典型的SQLite数据库模式中,大多数表都是rowid表。</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">大多数 swarmvtab 的用户只会使用上面描述的功能。本节介绍了为更深奥的用例设计的功能。这些特性都涉及到在SQL语句后面指定额外的可选参数,作为CREATE VIRTUAL TABLE命令的一部分。一个可选的参数是用它的名字来指定的,后面是一个&quot;=&quot;字符,然后是一个可以选择引用的值。名字、&quot;=&quot;字符和值之间可以用空格隔开。例如,在参数名称后面加上&quot;=&quot;字符,然后再加上引号。</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">将一个BLOB手柄移动到新的行。</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">将寄存器P1...P1+P3-1中的P3值移到寄存器P2...P2+P3-1中。寄存器P1...P1+P3-1保持一个NULL。寄存器范围P1...P1+P3-1和P2...P2+P3-1重叠是错误的。P3小于1时错误。</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">将光标P1移动到空行。当光标在空行上时发生的任何&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;操作都将始终写入NULL。</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">将网站和文档文件从源目录树移到&lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;单独的CM系统中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">将CVS仓库移至www.sqlite.org。</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">从SQLite 3.4.2移动到3.5.0</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">从SQLite 3.5.9迁移到3.6.0</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">将日志文件从一个数据库移动到另一个数据库。</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">尽管某些例程分散在其他文件中，但它们可以访问具有文件范围的数据结构，但是许多&lt;a href=&quot;c3ref/intro&quot;&gt;C语言接口&lt;/a&gt;都可以在源文件&lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;，&lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;和&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c中&lt;/a&gt;找到。该&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;例程中实现&lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;。该&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;程序中发现的&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;。所述&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;接口处于&lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;。在&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口&lt;/a&gt;是通过实施&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">多文件交易</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">多字符的插入、删除和替换可以在成本表中列举出来。</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">多列索引</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">多列索引只有在查询的WHERE子句中的约束条件通过AND连接时才起作用。因此,当搜索的项目既是橙子又生长在加州时,Idx3和Idx4是很有帮助的,但是如果我们想要所有的项目都是橙子,那么这两个索引就没有那么有用了。</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">多种编程语言</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">可以同时注册多个VFS。每个VFS都有一个唯一的名称。同一进程中的单独&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;可以同时使用不同的VFS。因此，如果单个数据库连接使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令打开了多个数据库文件，则每个连接的数据库可能正在使用不同的VFS。</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">使用多个b树结构代替单个b树,以降低在FTS表中插入记录的成本。当一条新记录插入到已经包含大量数据的FTS表中时,新记录中的许多术语很可能已经存在于大量的现有记录中。如果使用单一的b-tree,那么就必须从数据库中加载大型的doclist结构,修改为包含新的docid和术语偏移列表,然后再写回数据库。使用多个b-tree表可以通过创建一个新的b-tree来避免这种情况,这个新的b-tree可以在以后与现有的b-tree(或b-树)合并。b-tree结构的合并可以作为后台任务来执行,或者一旦积累了一定数量的独立b-tree结构,就可以进行合并。当然,这种方案会使查询的成本增加(因为FTS代码可能需要在多个b树中查找单个术语并合并结果),但人们发现,在实践中这种开销往往可以忽略不计。</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">3.15.0版引入了对&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;逻辑的多个错误修复。</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">多位评论者表示希望指针类型使用动态字符串,并希望SQLite拥有类型字符串的所有权,并在使用完毕后自动释放类型字符串。该设计被拒绝,原因如下。</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">来自一个进程内的多个连接,如果使用这种异步IO的实现,可以并发访问一个数据库文件。从用户的角度来看,如果所有的连接都来自于一个进程内,那么 &quot;普通 &quot;SQLite和使用异步后端的SQLite所提供的并发性没有任何区别。</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">多个连接可能同时持有一个读锁。如果许多线程都在获取重叠的读锁,那么可能会出现至少一个线程始终持有读锁的情况。那么等待写锁的表将永远等待。这种情况被称为 &quot;写手饥饿&quot;。</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上的多个数据库</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">多个进程可以附加到同一个应用文件上,并且可以互相读写,互不干扰。</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">多个进程可以同时打开同一个数据库。多个进程可以同时进行SELECT。但在任何时刻只能有一个进程对数据库进行修改,但是。</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">多个小排序集体使用的CPU周期比单个大排序少。</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">将寄存器P1中的值乘以寄存器P2中的值,并将结果存储在寄存器P3中。如果任一输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">将null乘以0,得到null</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">突变测试脚本</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">突变测试可能会很慢,因为在快速工作站上,每次测试可能需要5分钟,而且每个分支指令有两次测试,有超过2万条分支指令。为了加快操作速度,我们做出了努力。例如,TH3的编译方式是一旦发现第一个错误就立即退出,由于许多突变很容易被检测到,所以许多循环只发生在几秒钟内。尽管如此,mutation-test.tcl脚本包含命令行选项,可以限制测试的代码行的范围,这样突变测试只需要对最近改变的代码块进行。</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">互换手柄</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Mutex方法对象</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">互换类型</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">Mutex验证例程</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">互斥虽然便宜,但也不是免费的,所以完全禁用互斥后,性能会更好。由此产生的库足迹也会更小一些。在编译时禁用mutexes是一种推荐的优化,适用于有意义的应用。</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">互斥使用&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">互斥使用&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">我的WHERE子句表达式 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; 不起作用。这将导致返回表的每一行，而不仅仅是返回column1值为&amp;ldquo; column1&amp;rdquo;的行。</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">我的查询没有返回我期望的列名。这是一个错误吗?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL 3.23.41版本不支持UNION。</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12甚至</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13且为奇数</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1(费用:5.52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2(费用:5.52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1(费用:11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">本土人物(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB:这个扩展已经过时了,建议用[WAL模式]代替。推荐使用[WAL模式]作为替代。</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">近距离查询</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">近距离查询不可用。</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">新的和旧的引用都是有效的</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">新的参考资料有效</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN天</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN小时</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN分钟</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN月</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN年</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNN.NNNN秒</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">NOT EXISIS操作者</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">不在运营商</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">非空约束</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL限制被尊重。</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="545dacd66301f165f41f75a11471135695f4dede" translate="yes" xml:space="preserve">
          <source>NUL Characters In Strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLite中的NULL处理</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">SQLite中的NULL处理与其他数据库引擎的比较</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL值(序列类型0)先排序。</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL值现在会以NULL指针而不是空字符串的形式报告给回调。</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">NULLS LAST</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLs优先排序</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">主机参数名称</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">保存数据库文件的文件夹名称</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">保存临时文件的文件夹名称</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">默认整理序列的名称</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">也可以使用WINDOW子句将命名的window-defn子句添加到SELECT语句中,然后在window函数调用中通过名称来引用。例如,下面的SELECT语句包含两个命名的window-defs子句,&quot;win1 &quot;和 &quot;win2&quot;。</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">命名变更</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">几乎所有的系统都能调用用C语言编写的库,其他实现语言则不然。</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">&quot;.width &quot;命令中的负数会导致右对齐。</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;，&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;和&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO的&lt;/a&gt;嵌套事务</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">千万不要对上帝的仁慈绝望。</target>
        </trans-unit>
        <trans-unit id="56cdefb3df5828b1fdbe0c79de688ed68de09460" translate="yes" xml:space="preserve">
          <source>Never tag an application-defined SQL function with &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; unless you really need to and you have checked the implementation closely and are certain that it can do no harm even if it falls under the control of an attacker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">但是，建议应用程序开发人员监视内存分配子系统的状态，并在内存使用率接近或超过Robson限制时发出警报。这样，该应用程序将在发生故障之前为操作员提供大量警告。SQLite 的&lt;a href=&quot;malloc#memstatus&quot;&gt;内存统计信息&lt;/a&gt;接口为应用程序提供了完成此任务的监视部分所需的所有机制。</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">尽管如此,错误还是发生了。如果你正在编写一个向SQLite发送不受信任的SQL输入或数据库文件的应用程序,你可以采取一些额外的措施来帮助减少攻击面,并防止由未检测到的bug引起的零日漏洞。</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">尽管如此,在计算内存分配大小时的整数溢出是SQLite希望处理的问题。为了防止出现问题,所有的SQLite内部内存分配都是使用瘦包装函数来进行的,这些瘦包装函数取一个64位有符号的整数大小参数。SQLite源码经过审计,确保所有大小计算也使用64位有符号的整数进行。SQLite会拒绝一次性分配超过约2GB的内存。(在通常的使用中,SQLite很少会一次分配超过8KB左右的内存,所以2GB的分配限制并不是一个负担)。所以64位大小参数为检测溢出提供了很大的空间。同样的审计也验证了所有大小计算都是以64位有符号整数的方式进行的,也验证了64位整数在计算过程中不可能溢出。</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">尽管如此,没有任何软件是100%完美的。在SQLite中曾出现过一些历史性的错误(现在已经修复),可能会导致数据库损坏。而且可能还有一些未被发现的错误。由于SQLite的广泛测试和广泛使用,导致数据库损坏的bug往往是非常隐蔽的。一个应用程序遇到SQLite bug的可能性很小。为了说明这一点,下面对2009-04-01至2013-04-15这四年期间在SQLite中发现的所有数据库损坏bug进行了说明。这个说明应该能让读者直观地了解到SQLite中哪些类型的bug会设法通过测试程序溜走,并将其发布到版本中。</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">添加了新的&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt;编译时选项</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">新变化</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">新文件格式</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">为内置的日期/时间函数添加新的HH:MM:SS修饰符。</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">新的VFSes用sqlite3_vfs_register()注册。如果makeDflt标志被设置,每个新的VFS都会成为默认的VFS。同一个VFS可以被注册多次而不会受到伤害。要使一个现有的VFS成为默认的VFS,需要在makeDflt标志被设置的情况下再次注册它。如果注册了两个同名的不同VFS,行为是未定义的。如果注册的VFS的名称是NULL或空字符串,那么行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">新应用程序应始终调用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;而不是&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;。保留较旧的&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;是为了向后兼容。但是&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;提供了一个更好的接口。</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的返回码，以确保调用能够正常进行。所述&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;../rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的返回码，以确保调用能够正常进行。所述&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;../rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">默认情况下，SQLite创建的新数据库文件使用格式4。该&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format编译指示&lt;/a&gt;可以用来引起的SQLite通过设置使用格式1来创建新的数据库文件的格式的版本号可以以默认被制成1代替4- &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;在编译时间= 1。</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">在未来的SQLite版本中可能会添加新的错误代码。</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">新的分机。</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">新的文件格式,对于典型的使用来说,体积缩小了25%到35%。</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">在未来的SQLite版本中可能会添加新的标志。</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">新接口&lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;返回已调用应用程序定义的SQL函数的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">新接口&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;允许在每个连接的基础上和在运行时设置大小和长度限制。</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">新接口:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c附加模块中增加了新的接口。</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">新的内部模式对象名称,总是以 &quot;sqlite_&quot;开头,可能会在未来的版本中加入SQLite文件格式。</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">新的内存分配器不必是SQLite源树的一部分，也不必包含在sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;。各个应用程序可以在启动时向SQLite提供其自己的内存分配器。</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">用于配置辅助内存使用的&lt;a href=&quot;cli&quot;&gt;命令行外壳的&lt;/a&gt;新选项：--pagecache，--lookaside和--scratch。</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">新的查询优化。</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">在未来的版本中可能会增加新的运行时间限制类别。</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">新的状态参数可能会不时增加。</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">新测试添加到测试套件中。</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">在未来对SQLite的增强中,新的文本标记可能会被添加到统计列的结尾。出于兼容性考虑,统计列末尾未识别的标记将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">在未来的版本中可能会添加新的跟踪常数。</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的动词。现有的动词可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;如果一个中断或不支持的动词被调用接口将返回非零错误代码。</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的动词。现有的动词可能会中断。应用程序应检查来自&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;如果一个中断或不支持的动词被调用接口将返回非零错误代码。</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">新的压缩包可以使用 zipfile()aggregate 函数完全在内存中构建。聚合函数所访问的每一行都会给zip存档添加一个条目。返回的值是一个包含整个存档图像的blob。</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">但是，较新的磁盘驱动器已开始使用4096字节的扇区。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;版本3.7.10&lt;/a&gt;（2012-01-16）开始，SQLite开发团队进行了实验，对xSectorSize进行了更改，以将4096字节报告为爆炸半径。这样的结果是增加了许多数据库的写开销。对于&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt;为1024（一个非常常见的选择）的数据库，现在更改到数据库中的单个页面需要SQLite将其他三个相邻页面备份到回滚日志中，而以前只需要备份一个在改变。在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;，必须将每个事务填充到WAL文件中的下一个4096字节边界，而不是下一个512字节边界，从而导致每个事务写入数千个额外的字节。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">接下来,使用这样的命令将所有的 blobs 复制到目录中的各个文件中。</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">接下来,将生成的kvtest-android可执行文件移动到Android设备上。</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">接下来,假设你想查询的不是任何橙子的价格,而是特别想查询加州种植的橙子的价格。适当的查询方式如下。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">否(注1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">同一数据库连接上的操作之间没有隔离。</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">不需要编写和调试应用文件I/O代码。</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">无变化</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">没有提供当前或冲突的行信息。唯一可以在提供的sqlite3_changeset_iter句柄上调用的函数是sqlite3changeset_fk_conflicts()。</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">如果发出了未知的pragma,不会产生错误信息。未知pragma会被直接忽略。这意味着如果一个pragma语句中出现了错别字,库不会通知用户这个事实。</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">无锁定方式。如果以上都不能支持,则采用这种锁定方式。不使用数据库锁定机制。使用该系统时,单个数据库被多个客户端访问是不安全的。</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">数据库上没有锁。数据库既不能读也不能写。任何内部缓存的数据都被认为是可疑的,在使用前要对数据库文件进行核查。其他进程可以在自己的锁定状态允许的情况下,读取或写入数据库。这是默认状态。</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">不再使用。</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">不再使用。</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">没有人被要求遵守The Rule,了解The Rule,甚至认为The Rule是个好主意。SQLite的创始人认为,任何遵守The Rule的人都会过得更快乐、更有成就感,但个人可以根据自己的意愿对这一建议提出异议或置之不理。</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">没有其他进程可以更改数据库,所以永远不需要在事务开始时检查更改计数器和清除用户空间缓存。</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">在应用 RBU 更新时,目标数据库上不得发生其他写操作。为了防止这种情况,目标数据库上有一个读锁。</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">除在事务内外，不会发生读取或写入。如果一个数据库尚未生效，那么任何访问数据库的命令（基本上是任何SQL命令，除了几个&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句除外）都将自动启动一个事务。最后一条SQL语句完成时，将提交自动启动的事务。</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">在union-vtab中,任何表都不能包含不在由</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">当你从SQLite数据库中删除信息时,未使用的磁盘空间会被添加到一个内部的 &quot;自由列表 &quot;中,并在下次插入数据时重新使用。磁盘空间不会丢失。但也不会返还给操作系统。</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">非ASCII码范围的字符(即大于127的unicode码点),或</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">非Vista的Windows平台只支持一套DST规则。Vista 只支持两套。因此,在这些平台上,历史上的DST计算将是不正确的。例如,在美国,2007 年的 DST 规则发生了变化。非Vista的Windows平台将2007年新的DST规则应用于之前的所有年份。Vista平台在正确计算1986年的结果方面做得更好,因为当时的规则也发生了变化。</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">非确定性函数可能会在每次调用时给出不同的答案,即使参数总是相同。以下是非确定性函数的例子。</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">非流式等价物</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">接受变化集(或补丁集)作为输入的非流函数要求整个变化集被存储在内存中的一个缓冲区中。类似的,那些返回变化集或补丁集的函数通过返回一个指针到一个用sqlite3_malloc()分配的大缓冲区。通常这很方便。然而,如果一个在低内存环境中运行的应用程序需要处理非常大的变化集,那么所需的大的连续内存分配就会变得很麻烦。</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">在SQLite存在的前10年,没有一种安全的编程语言存在。SQLite可以用Go或Rust重新编码,但这样做可能会引入更多的bug,而不是修复的bug,而且似乎也可能导致代码更慢。</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">除了在调用xBegin()和xCommit()或xRollbackTo()之间,xSavepoint()、xRelease()或xRollbackTo()方法都不会被调用。</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">普通函数只指定xFunc,并将xStep和xFinal设置为NULL。Aggregate函数只指定xStep和xFinal,并将xFunc设置为NULL。没有单独的 sqlite3_create_aggregate()API。</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">通常，FTS5在数据库内维护一个特殊的备用表，该表将每个列值的大小存储在插入到单独表中的主FTS5表中的令牌中。该支持表由&lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API函数&lt;/a&gt;使用，而xColumnSize API函数又由内置&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25排名函数使用&lt;/a&gt;（并且可能对其他排名函数也很有用）。</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">通常情况下，NULL SQL结果存储使用在阵列中&lt;a href=&quot;#nullvalue&quot;&gt;NullValue属性&lt;/a&gt;设置。但是，如果使用&lt;b&gt;-withoutnulls&lt;/b&gt;选项，则NULL SQL值将导致未设置相应的数组元素。</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">通常情况下,SQLite假设在更新扇区任何部分时发生断电,那么恢复后整个设备扇区的内容都是可疑的。在对文件内的扇区的任何部分进行写入后,假设修改后的扇区内容被保存在系统内的某个易失性缓冲区(主内存、磁盘缓存等)。SQLite不会假设更新后的数据已经到达了持久性存储介质,直到它成功地实现了</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">通常情况下,令牌或令牌前缀查询会与MATCH操作符左侧指定的FTS表列进行匹配。或者,如果指定了与FTS表本身同名的特殊列,则与所有列匹配。这可以通过在基本术语查询前指定列名后跟一个&quot;:&quot;字符来覆盖。在&quot;:&quot;和要查询的术语之间可以有空格,但在列名和&quot;:&quot;字符之间不能有空格。例如:&quot;:&quot;字样。</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">通常情况下,SQL索引会引用表的列,但也可以在涉及表列的表达式上形成索引。但是索引也可以在涉及表列的表达式上形成。</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">一般情况下,化石在私有分支和公共分支之间切换时,会修改你结账中的所有文件。但此时,两个分支中的文件是相同的,所以不需要修改。</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">通常，全文查询不区分大小写。但是，这取决于要查询的FTS表使用的特定&lt;a href=&quot;fts3#tokenizer&quot;&gt;标记&lt;/a&gt;器。有关详细信息，请参阅关于分&lt;a href=&quot;fts3#tokenizer&quot;&gt;词器&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">通常情况下,FTS模块会对表中所有列的所有术语进行倒置索引。这个选项用来指定不应该在索引中添加条目的列名。可以使用多个 &quot;notindexed &quot;选项来指定从索引中省略多个列。例如:&quot;notindexed &quot;选项用于指定多个列的名称,这些列不应被添加到索引中。</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">通常，必须在实际创建数据库文件之前配置数据库的&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;以及数据库是否支持&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;。但是，当不在&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;模式下时，可以使用&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;和/或&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt;编译指示来更改现有数据库的&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;和/或&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;属性，然后立即对数据库进行VACUUM。在&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;模式下，只能使用VACUUM更改&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;支持属性。</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">通常情况下,当SQLite向数据库文件写入时,它会等到写入操作完成后才将控制权返回给调用应用程序。由于向文件系统写操作与CPU绑定的操作相比,通常非常慢,这可能是一个性能瓶颈。异步I/O后端是一个扩展,它使SQLite使用一个单独的线程在后台运行来执行所有的写请求。虽然这并没有减少整体的系统资源(CPU、磁盘带宽等),但它允许SQLite即使在向数据库写入时也能快速将控制权返回给调用者。</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">通常情况下,当一行插入到FTS5表中时,以及各种全文索引条目和其他数据,该行的副本被存储在FTS5模块管理的私有表中。当用户或辅助功能实现从FTS5表中请求列值时,它们将从这个私有表中读取。&quot;内容 &quot;选项可以用来创建一个只存储FTS全文索引项的FTS5表。由于列值本身通常比相关的全文索引条目大得多,因此可以节省大量的数据库空间。</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">并非所有的应用都符合这些条件。幸运的是,即使没有这些条件,NGQP通常仍然会找到好的查询计划。然而,确实会出现(很少)性能倒退的情况。</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">并非所有的测试用例都可以这样处理。有些测试用例通过计算查询过程中发生的磁盘访问次数、排序操作、全扫描步骤或其他处理步骤来检查验证优化是否真的减少了计算量。当优化被禁用时,这些测试用例会出现失败。但大多数测试用例只是检查是否得到了正确的答案,所有这些用例都可以在有优化和没有优化的情况下成功运行,以表明优化不会导致故障。</target>
        </trans-unit>
        <trans-unit id="d047995ecc6203bb86f7cef3de1f0a2b4fa5dba8" translate="yes" xml:space="preserve">
          <source>Not ever decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a &quot;price&quot; value of 47.49, that number will be represented in binary64 as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">在上面的示例中未显示的是，还有一些&lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;选项&lt;/a&gt;可以作为CREATE VIRTUAL TABLE语句的一部分提供给FTS5，以配置新表的各个方面。这些可用于修改FTS5表从文档和查询中提取术语的方式，在磁盘上创建额外的索引以加快前缀查询的速度，或用于创建FTS5表作为对其他位置存储的内容的索引。</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Nota bene:</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">还要注意，在添加&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束时&lt;/a&gt;，不会针对表的现有行测试CHECK约束。这可能导致表中包含违反CHECK约束的数据。将来的SQLite版本可能会更改以验证添加时的CHECK约束。</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">请注意,&quot;单调递增 &quot;并不意味着ROWID总是正好增加1。1是通常的增量。但是,如果由于(例如)唯一性约束导致插入失败,那么失败的插入尝试的ROWID可能不会在后续的插入中被重复使用,导致ROWID序列出现空白。AUTOINCREMENT保证自动选择的ROWID会不断增加,但不保证它们是有顺序的。</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">请注意，&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;可能会间接影响数据库的副作用。例如，如果应用程序定义了调用&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的函数&amp;ldquo; eval（）&amp;rdquo; ，则以下SQL语句将通过副作用更改数据库文件：</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">请注意，默认情况下，&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;被认为是不确定的，除非在注册函数时使用&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志，否则不得在CREATE INDEX语句中使用该函数。</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">请注意，&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;可能会间接影响数据库的副作用。例如，如果应用程序定义了调用&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的函数&amp;ldquo; eval（）&amp;rdquo; ，则以下SQL语句将通过副作用更改数据库文件：</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">请注意，Idx3包含与原始&lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;相同的所有信息。因此，如果我们拥有Idx3，我们将不再真正需要Idx1。只需忽略Idx3的&amp;ldquo;状态&amp;rdquo;列，就可以使用Idx3满足&amp;ldquo;桃子的价格&amp;rdquo;查询：</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">请注意,MinGW只生成32位DLL。有一个单独的MinGW64项目可以用来生成64位DLL。大概命令行语法是类似的。还需要注意的是,MSVC的最新版本生成的DLL不能在WinXP和早期版本的Windows上工作。所以为了使你生成的DLL具有最大的兼容性,建议使用MinGW。一个好的经验法则是使用MinGW生成32位DLL,使用MSVC生成64位DLL。</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，SQLITE_IGNORE也用作从&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;接口返回的&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;冲突解决模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，SQLITE_IGNORE也用作从&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;接口返回的&lt;a href=&quot;c_fail&quot;&gt;冲突解决模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63e763dca84d9237a89baecc3d0c141975e41415" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the number of reserve-bytes to be increased but not decreased. So if a database file already has a reserve-bytes value greater than 8, there is no way to activate checksumming on that database, other than to dump and restore the database file. Note also that other extensions might also make use of the reserve-bytes. Checksumming will be incompatible with those other extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">请注意,SQLite允许IN或NOT IN操作符右侧的标量值的括号列表是一个空列表,但大多数其他SQL数据库数据库引擎和SQL92标准要求该列表至少包含一个元素。</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">请注意,SQLite会自动在扩展名中添加适当的扩展名后缀(在windows下为&quot;.dll&quot;,在Mac上为&quot;.dylib&quot;,在大多数其他unixes上为&quot;.so&quot;)。一般来说,指定扩展名的完整路径名是个好主意。</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">请注意，SQLite附带了几个&lt;a href=&quot;../malloc#altalloc&quot;&gt;内置的内存分配器&lt;/a&gt;，它们完全适合绝大多数应用程序，并且该对象仅对极少数具有特殊内存分配要求的应用程序有用。在测试SQLite期间，也使用此对象，以指定模拟内存不足条件的备用内存分配器，以验证SQLite是否可以从此类条件正常恢复。</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">请注意，SQLite附带了几个&lt;a href=&quot;malloc#altalloc&quot;&gt;内置的内存分配器&lt;/a&gt;，它们完全适合绝大多数应用程序，并且该对象仅对极少数具有特殊内存分配要求的应用程序有用。在测试SQLite期间，也使用此对象，以指定模拟内存不足条件的备用内存分配器，以验证SQLite是否可以从此类条件正常恢复。</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">请注意,SQLite不强制执行without ROWID虚拟表的PRIMARY KEY。执行是底层虚拟表实现的责任。但是SQLite确实假设PRIMARY KEY约束是有效的,即所确定的列确实是UNIQUE而非NULL,并且它使用该假设来优化对虚拟表的查询。</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">请注意，无论操作系统和硬件如何告知SQLite，SQLite都必须相信同步请求的状态。 SQLite无法检测到两者都在说谎，并且写操作可能是乱序发生的。但是，与默认回滚日志模式相比，&lt;a href=&quot;wal&quot;&gt;WAL模式下的&lt;/a&gt; SQLite 更能容忍无序写入。在WAL模式下，失败的同步操作可能导致数据库损坏的唯一时间是在&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作期间。 COMMIT期间的同步失败可能会导致持久性损失，但不会导致数据库文件损坏。因此，防止由于同步操作失败而导致数据库损坏的一道防线是在WAL模式下使用SQLite并尽可能不频繁地检查点。</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">请注意,SQLite使用b树,b树是一种排序的数据结构,所以当SELECT语句的WHERE子句包含平等或不平等的测试时,可以使用索引。像下面这样的查询,如果有索引,就可以使用索引。</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">请注意,声明的 &quot;FLOATING POINT &quot;类型会给出INTEGER亲和力,而不是REAL亲和力,因为 &quot;POINT &quot;的末尾有 &quot;INT&quot;。而声明的 &quot;STRING &quot;类型的亲和力是NUMERIC,而不是TEXT。</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">请注意，翻转多边形的转换可能导致顶点顺序颠倒。换句话说，该变换可能导致顶点以顺时针方向而不是逆时针方向循环。可以通过在转换后通过&lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw（）&lt;/a&gt;函数发送结果来纠正此问题。</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">请注意,一个内部事务可能会提交(使用RELEASE命令),但随后会被外部事务中的ROLLBACK命令撤销。断电、程序崩溃或操作系统崩溃都会导致最外层的事务回滚,从而撤销在该外层事务中发生的所有更改,甚至包括那些被RELEASE命令 &quot;提交 &quot;的更改。在最外层事务提交之前,磁盘上的内容并没有实际提交。</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">请注意,来自多个远程更改集的冲突解决是在每个字段的基础上合并的,而不是每个行。这意味着,在多个远程UPDATE操作的情况下,单个本地变更的一些字段可能会被重新基于REPLACE,而其他字段会被重新基于OMIT。</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">请注意,UTF-16be和UTF-16le之间的转换总是在原地进行的,不会使先前的指针无效,当然先前指针指向的缓冲区的内容会被修改。其他类型的转换在可能的情况下会在原地进行,但有时不可能,在这种情况下,先前的指针会失效。</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">请注意,从 zip 存档中删除记录并不能收回存档中使用的空间--它只是从存档的 &quot;中央目录结构 &quot;中删除了一个条目,使得该条目无法访问。绕过这种低效率的一种方法是根据已编辑的归档内容创建一个新的 zip 归档。例如,在编辑了通过虚拟表 temp.zzz 访问的归档后。</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，不同的操作系统为其共享库使用不同的文件名后缀。Windows使用&amp;ldquo; .dll&amp;rdquo;，Mac使用&amp;ldquo; .dylib&amp;rdquo;，除Mac之外的大多数Unix使用&amp;ldquo; .so&amp;rdquo;。如果要使代码可移植，则可以从共享库文件名中省略后缀，并且适当的后缀将由&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口自动添加。</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">请注意,shm文件中每个32768字节的单元都有自己的aHash和aPgno数组。单个单元的aHash数组只对查找同一单元的aPgno条目有帮助。整体的FindFrame(P,M)函数需要从最新的单元开始进行哈希查找,并向后查找最老的单元,直到找到答案。</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">请注意,启用FTS3也会使FTS4可用。没有单独的SQLITE_ENABLE_FTS4编译时选项。一个SQLite的构建要么同时支持FTS3和FTS4,要么两者都不支持。</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">请注意,除了上面详述的一些角码差异外,WITHOUT ROWID表和rowid表的工作原理是一样的。给予相同的SQL语句,它们都会产生相同的答案。因此,在开发周期的后期,在应用程序上运行实验,测试使用without rowid表是否会有帮助,是一件很简单的事情。一个好的策略是,在产品开发接近尾声之前,干脆不担心WITHOUT ROWID的问题,然后回过头来运行测试,看看在具有非整数PRIMARY KEY的表上添加WITHOUT ROWID是帮助还是伤害性能,只有在那些有帮助的情况下才保留WITHOUT ROWID。</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">请注意,geopoly使用传统的右手卡提斯坐标系,原点在左下方,而SVG使用左手坐标系,原点在左上方。geopoly_svg()例程没有尝试转换坐标系,所以显示的图像是以镜像和旋转的方式显示的。如果不希望出现这种情况,可以使用geopoly_xform()例程在将多边形传入geopoly_svg()之前,将输出从卡提斯坐标转换为SVG坐标。</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">请注意，如果使用&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标记了不确定性函数，并且该函数最终在&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句或&lt;a href=&quot;expridx&quot;&gt;表达式索引中使用&lt;/a&gt;，则当该函数开始返回不同的答案时，关联的索引可能会损坏。如果SQL函数几乎是确定性的（也就是说，如果它很少改变，例如&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）&lt;/a&gt;），并且在已损坏的索引中使用它，则可以通过运行&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;来修复损坏。</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">请注意,如果使用了动态mutex参数之一(SQLITE_MUTEX_FAST或SQLITE_MUTEX_RECURSIVE),那么sqlite3_mutex_alloc()在每次调用时都会返回一个不同的mutex。对于静态的mutex类型,在每次调用时都会返回相同类型号的mutex。</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">请注意,如果你没有在WHERE子句中包含 &quot;langid=N&quot;,那么搜索将针对语言0(在上面的例子中是英语)。没有办法同时搜索所有语言。</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">请注意,在大多数情况下,SQLite只会为查询的FROM子句中的每个表使用一个索引。这里介绍的第二个OR-clause优化是这个规则的例外。对于OR-clause,可能会为OR-clause中的每个子项使用不同的索引。</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">请注意,为了使特殊的&quot;:memory:&quot;名称适用,并创建一个纯内存数据库,文件名中必须没有额外的文本。因此,可以在文件中通过预先添加一个路径名来创建基于磁盘的数据库,比如这样。&quot;./:内存:&quot;.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">请注意,在上图中,我们将私人编辑显示为一次提交。这只是为了清晰地展示。没有什么能阻止你做几十个或几百个单独的小改动,并分别提交。事实上,做许多小改动是首选的工作方式。在一次提交中完成所有修改的唯一原因是,这样可以使图更容易绘制。</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">请注意，在此设计中，令牌生成器调用解析器。熟悉YACC和BISON的人可能习惯于以相反的方式进行操作-让解析器调用令牌生成器。但是，让分词器调用解析器会更好，因为可以将其设置为线程安全的，并且运行速度更快。</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">请注意，中缀函数（&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;，&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;，&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;和&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;）反转其参数的顺序。因此，&amp;ldquo; like（A，B）&amp;rdquo;等效于&amp;ldquo; B like A&amp;rdquo;。对于形式为&amp;ldquo;像A一样的B&amp;rdquo;，将B项视为函数的第一个参数。但是对于&amp;ldquo; like（A，B）&amp;rdquo;，A项被认为是第一个参数。</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">请注意,在运行&quot;.import &quot;命令之前,必须将 &quot;mode &quot;设置为 &quot;csv&quot;。这对于防止命令行shell试图将输入文件文本解释为其他格式是必要的。</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">请注意,为了使索引搜索效率高,并不一定要对 R*Tree 索引中的所有坐标进行约束。例如,人们可能希望查询所有与第35条平行线重叠的对象。</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">请注意,不需要引用$bigstring的值。这是自动发生的。如果$bigstring是一个大的字符串或二进制对象,这种技术不仅更容易写,而且更有效率,因为它避免了复制$bigstring的内容。</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">请注意,两个或多个线程使用SQLite库访问同一个SQLite数据库文件是完全安全的。SQLite的unix驱动程序知道POSIX咨询锁定的怪癖,并能绕过它们。只有当一个线程试图绕过SQLite库,直接读取数据库文件时,才会出现这个问题。</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">请注意，数据库文件名具有某种扩展名非常重要。如果没有扩展名，则SQLite会通过附加到文件的基本名称来创建辅助文件名。因此，一个名为&amp;ldquo; &lt;code&gt;db01&lt;/code&gt; &amp;rdquo; 的数据库将具有一个名为&amp;ldquo; &lt;code&gt;db01-journal&lt;/code&gt; &amp;rdquo; 的&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;文件。并且由于该文件名没有扩展名，不能缩短到3个字符，因此将按原样使用，并且会违反8 + 3命名规则。</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">请注意，在&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）之前，SQLite在调用xCreate方法之前未检查其是否为NULL。因此，如果在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;版本3.8.11.1&lt;/a&gt;（2015-07-29）或更早版本中注册了仅具名的虚拟表，并且对该虚拟表模块尝试了&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;命令，则会发生跳转到NULL指针的情况，从而导致崩溃</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">请注意，使用gcov运行SQLite并不是对SQLite的测试，而是对测试套件的测试。gcov运行不会测试SQLite，因为-fprofile-args和-ftest-coverage选项使编译器生成不同的代码。gcov运行仅验证测试套件是否提供100％的分支测试覆盖率。gcov运行是测试的测试-元测试。</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;常量也用作&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;回调的潜在返回值，并且&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;也是&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">请注意，&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;和&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口不计算INSTEAD OF触发器触发，但是&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes编译指示&lt;/a&gt;确实计算INSTEAD OF触发器触发。</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;常量也用作&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;回调的潜在返回值，并且&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;也是&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">请注意,DO UPDATE子句只作用于在INSERT过程中发生约束错误的那一条记录。没有必要包含一个WHERE子句,将操作限制在这一条记录上。在DO UPDATE结尾的WHERE子句的唯一用途是根据原始值和/或新的值,选择性地将DO UPDATE改为no-op。例如</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">请注意,SQLITE_TEXT常量在SQLite版本2中也使用过,意义完全不同。同时针对SQLite版本2和SQLite版本3进行链接的软件应该使用SQLITE3_TEXT,而不是SQLITE_TEXT。</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">请注意,SQLite解析器不会总是生成使用索引的代码,即使可以这样做。以下查询目前不会使用索引。</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">请注意,复合查询的UNION ALL操作符本身并不使用瞬时索引(当然,UNION ALL的左右子查询可能会使用瞬时索引,这取决于它们是如何组成的)。</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">请注意，仅在&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体期间调用授权者回调。在&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;中的语句评估期间不会执行授权，除非如前一段所述，否则sqlite3_step（）会在架构更改后调用sqlite3_prepare_v2（）来重新声明语句。</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">请注意，仅在&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体期间调用授权者回调。在&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;中的语句评估期间不会执行授权，除非如前一段所述，否则sqlite3_step（）会在架构更改后调用sqlite3_prepare_v2（）来重新声明语句。</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">请注意，SQLite使用的字符编码机制无法在运行时更改。这仅是编译时选项。该&lt;b&gt;sqlite_encoding&lt;/b&gt;字符串只是告诉你该库是如何被编译。</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">请注意,如果同步设置为FULL,则不需要回滚日志中的校验和。只有当同步设置为NORMAL时,我们才需要用到校验和。尽管如此,校验和值不会有任何影响,因此无论同步设置如何,校验和值都会被包含在回滚日志中。</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">请注意，命令行Shell程序已经为您启用了扩展加载（通过在安装过程中调用&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;接口作为其安装的一部分），因此上述命令可以正常运行，而无需任何特殊的开关，安装或其他复杂操作。</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">需要注意的是,析产函数D是针对指针值P的,而不是针对类型字符串T的,类型字符串T应该是一个寿命无限的静态字符串。</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">请注意，整数键比插入之前表中的最大键大一。新键在表中当前的所有键上都是唯一的，但是它可能与以前从表中删除的键重叠。要创建在表的生命周期内唯一的键，请将&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;关键字添加到&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;声明中。这样，所选密钥将比该表中曾经存在的最大密钥多一。如果该表中先前已存在最大的可能密钥，则&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;将失败，并显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误代码。</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">请注意，&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;的journal_mode为MEMORY或OFF，并且不能更改为其他值。将&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;的journal_mode更改为除MEMORY或OFF以外的任何设置的尝试都将被忽略。还请注意，事务处于活动状态时，不能更改journal_mode。</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">请注意，上面的例程列表是概念性的，而不是实际的。其中许多例程有多个版本。例如，上面的列表显示了一个名为&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）的&lt;/a&gt;例程，而实际上有三个单独的例程以略有不同的方式完成同一件事：&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;。该列表提到了&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;，而实际上不存在这样的例程。列表中显示的&amp;ldquo; sqlite3_column（）&amp;rdquo;是整个例程系列的占位符，这些例程会在各种数据类型中额外增加列数据。</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">请注意,即使在使用OOM覆盖时,内存泄漏检测逻辑也会继续工作。这就验证了SQLite即使在遇到内存分配错误时也不会泄漏内存。还请注意,OOM覆盖可以与任何底层内存分配器一起工作,包括检查内存分配错误的工具化内存分配器。通过这种方式可以验证OOM错误不会诱发其他类型的内存使用错误。</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">请注意，SQLite可以理解的关键字数量可能取决于编译时选项。例如，如果使用&lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;选项编译SQLite，则&amp;ldquo; VACUUM&amp;rdquo;不是关键字。此外，新的关键字可能会添加到SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">请注意，SQLite可以理解的关键字数量可能取决于编译时选项。例如，如果使用&lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;选项编译SQLite，则&amp;ldquo; VACUUM&amp;rdquo;不是关键字。此外，新的关键字可能会添加到SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">请注意,确定列亲和力的规则顺序很重要。一个声明类型为 &quot;CHARINT &quot;的列将同时符合规则1和规则2,但第一条规则优先,因此列的亲和性将是INTEGER。</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">请注意,主结果代码总是扩展结果代码的一部分。给定一个完整的32位扩展结果代码,应用程序总是可以通过提取扩展结果代码中最不重要的8位来找到相应的主要结果代码。</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">请注意,这个SELECT查询的程序没有包含INSERT例子中使用的Transaction和Commit指令。因为SELECT是一个不改变数据库的读操作,所以它不需要事务。</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">请注意，readfile（X）和writefile（X，Y）函数是扩展函数，并且未内置在核心SQLite库中。这些例程在&lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite源代码存储库&lt;/a&gt;中的&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt;源文件中可用作&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">请注意，根据数据库&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;编码&lt;/a&gt;是UTF-8，UTF-16be还是UTF-16le ，将任何非BLOB值转换为BLOB的结果以及将任何BLOB值转换为非BLOB的结果可能会有所不同。。</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">请注意，sqlite3changeset_apply_v2（）API仍处于&lt;b&gt;试验阶段&lt;/b&gt;，因此可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">请注意，sqlite3changeset_start_v2（）API仍处于&lt;b&gt;试验阶段&lt;/b&gt;，因此可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">请注意，一元* + *运算符还会从表达式中删除&lt;a href=&quot;datatype3#affinity&quot;&gt;类型相似性&lt;/a&gt;，在某些情况下，这可能导致表达式含义发生细微变化。在上面的示例中，如果列* x *具有&lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT关联性，&lt;/a&gt;则比较&amp;ldquo; x = 5&amp;rdquo;将作为文本完成。但是* + *运算符会删除相似性。因此，比较&amp;ldquo; + x = 5&amp;rdquo;会将* x *列中的文本与数值5进行比较，并且始终为false。</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">请注意,在语法图中,有些路径在实践中是不允许的。以下是一些例子:</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">注意,等号和不等号运算符有两种变化。等号可以是</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">请注意,这只是一个思想实验。我们并不是建议改变OpenDocument。本文也不是对当前OpenDocument设计的批评。本文的目的是提出改进未来文件格式设计的方法。</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">请注意,只有在试图获取锁的过程中导致I/O错误时才会出现这个问题。如果锁只是没有被授予(因为其他线程或进程已经持有一个冲突的锁),那么永远不会发生损坏。我们不知道有任何操作系统会在尝试获取共享内存上的文件锁时出现I/O错误而失败。因此,这是一个理论问题,而不是一个真正的问题。不用说,这个问题从未在野外观察到过。这个问题是在模拟I/O错误的测试线束中对SQLite进行压力测试时发现的。</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">请注意，此例程在匹配时返回零，在字符串不匹配时返回非零，与&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">请注意，此例程在匹配时返回零，在字符串不匹配时返回非零，与&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;和&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">请注意,当关联的表被删除时,触发器会自动被删除。</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">请注意，当使用SQLITE_THREADSAFE = 0编译SQLite时，构建过程中将省略使SQLite线程安全的代码。发生这种情况时，不可能在启动时或运行时更改&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">请注意，如果LIKE或GLOB运算符的右侧是&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数，&lt;/a&gt;并且使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;准备了该语句，则在每次运行的第一个&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中，该语句将自动重新分析和重新编译。自上次运行以来，与右侧参数的绑定已更改。这种重新解析和重新编译本质上是与架构更改后发生的相同操作。重新编译是必需的，以便查询计划者可以检查绑定到LIKE或GLOB运算符右侧的新值，并确定是否采用上述优化方法。</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">请注意,当类型转换发生时,之前调用sqlite3_column_blob()、sqlite3_column_text()和/或sqlite3_column_text16()返回的指针可能会失效。在以下情况下,可能会发生类型转换和指针无效的情况。</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">请注意，在&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为NORMAL的情况下，检查点是唯一发出I / O屏障或同步操作的操作（unix上的fsync（）或Windows上的FlushFileBuffers（））。因此，如果应用程序在单独的线程或进程中运行检查点，则执行数据库查询和更新的主线程或进程将永远不会阻塞同步操作。这有助于防止在繁忙的磁盘驱动器上运行的应用程序中出现&amp;ldquo;闩锁&amp;rdquo;。此配置的缺点是事务不再持久，并且可能在电源故障或硬重置后回滚。</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">需要注意的是,使用analyze时,成本估算与实际情况比较吻合,NN和N3都选择了算法-1。</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">请注意，xBestIndex将始终在&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;之前调用，因为xBestIndex的idxNum和idxStr输出是xFilter的必需输入。但是，不能保证成功执行xBestIndex之后将调用xFilter。</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">请注意虚拟表名称(&quot;stat&quot;)前的 &quot;temp.&quot;限定词。这个限定词会导致虚拟表是临时的--只在当前数据库连接期间存在。这是推荐的方法。</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">请特别注意最后一项。sqlite3_set_auxdata(C,N,P,X)中的析构器X可能会在 sqlite3_set_auxdata()接口返回之前立即被调用。因此,sqlite3_set_auxdata()应该在函数实现接近尾声的时候调用,并且在调用了sqlite3_set_auxdata()之后,函数实现不应该对P进行任何使用。</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">注意在这些触发器中使用&lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote（）SQL函数&lt;/a&gt;。quote（）函数将其参数转换为适合包含在SQL语句中的形式。数值不变。在字符串前后添加单引号，并且转义任何内部单引号。BLOB值使用SQL标准十六进制BLOB表示法呈现。使用quote（）函数可确保用于撤消和重做的SQL语句始终对SQL注入安全。</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">请注意&amp;ldquo; estimatedRows&amp;rdquo;，&amp;ldquo; idxFlags&amp;rdquo;和colUsed字段上的警告。这些字段分别与SQLite版本3.8.2、3.9.0和3.10.0一起添加。读取或写入这些字段的任何扩展都必须首先检查所使用的SQLite库的版本是否大于或等于适当的版本-也许将&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值与常量3008002、3009000和/或3010000进行比较。尝试访问由较旧版本的SQLite创建的sqlite3_index_info结构中的这些字段的结果未定义。</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注意：标有&amp;ldquo;功能&lt;small&gt;&lt;i&gt;（EXP）&lt;/i&gt;&lt;/small&gt; &amp;rdquo;的&lt;a href=&quot;capi3ref&quot;&gt;实验性&lt;/a&gt;和功能，其名称是&lt;s&gt;通过撞击&lt;/s&gt;被&lt;a href=&quot;capi3ref&quot;&gt;弃用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注意：标有&amp;ldquo;功能&lt;small&gt;&lt;i&gt;（EXP）&lt;/i&gt;&lt;/small&gt; &amp;rdquo;的&lt;a href=&quot;experimental&quot;&gt;实验性&lt;/a&gt;和功能，其名称是&lt;s&gt;通过撞击&lt;/s&gt;被&lt;a href=&quot;experimental&quot;&gt;弃用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">注意：添加了本文的第2.0节和第3.0节，以响应对&lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt;和&lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit的&lt;/a&gt;评论。</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注意：此方法在MacOS X 10.7和iOS版本5.0上被禁用，并且将始终返回SQLITE_MISUSE。在这些系统上，应通过&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;通过数据库的每个连接启用共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注意：此方法在MacOS X 10.7和iOS版本5.0上被禁用，并且将始终返回SQLITE_MISUSE。在这些系统上，应通过&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;通过数据库的每个连接启用共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;optoverview&quot;&gt;查询优化器的说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">注意LIKE操作符是如何实现的。在SQLite中,它是一个用户定义的函数,所以在P3中指定了它的函数定义地址。操作数P1是它要从堆栈中获取的函数参数数。在本例中,LIKE()函数需要2个参数。参数从堆栈中以相反的顺序(从右到左)取下,所以要匹配的模式是堆栈最上面的元素,下一个元素是要比较的数据。返回值被推到堆栈上。</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">注意上面的查询是如何工作的。R*Tree索引在外循环中运行,以查找包含在经度-81...-79.6和纬度35.0...36.2的边界框内的条目。对于找到的每个对象标识符,SQLite都会在demo_data表中查找相应的条目。然后,它将demo_data表中的边界字段作为con contained_in()函数的参数,如果该函数返回true,则将demo_data表中的objname字段作为下一行查询结果返回。</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">注意,所有其他的日期和时间函数都可以用strftime()来表示。</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">请注意,使用SQLite表将内容划分为更小的部分,这为实现提供了灵活性。应用程序可以选择在启动时将所有内容读入内存。或者它可以只将几个页面读取到内存中,并将其余的内容保存在磁盘上。或者它可以每次只将单页内容读入内存。而且不同版本的应用程序可以做出不同的选择,而不需要对文件格式进行任何修改。当所有的内容都在ZIP档案中的一个大的XML文件中时,这样的选项是不可用的。</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">注意,&quot;dummy &quot;记录的 &quot;host &quot;值是NULL,所以结果[]数组在该槽中包含一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">请注意,现在函数的参数是指向 sqlite3_value 结构的指针,而不是像 SQLite 2.X 版本那样指向字符串的指针,以下例程用于从这些 &quot;值 &quot;中提取有用的信息。</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">注意,共享锁是在操作系统的磁盘缓存上,而不是在磁盘本身。文件锁其实只是操作系统内核内的标志,通常。(具体细节取决于具体的操作系统层接口。)因此,如果操作系统崩溃或断电,锁会立即消失。通常情况下,如果创建锁的进程退出,锁也会消失。</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">请注意，fts3tokenize虚拟表的结果集中的令牌已根据令牌生成器的规则进行了转换。由于此示例使用了&amp;ldquo; porter&amp;rdquo;标记器，因此&amp;ldquo; This&amp;rdquo;标记被转换为&amp;ldquo; thi&amp;rdquo;。如果需要令牌的原始文本，则可以使用&lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr（）&lt;/a&gt;函数的&amp;ldquo; start&amp;rdquo;和&amp;ldquo; end&amp;rdquo;列来检索令牌。例如：</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">注意ListRead和Next指令之间的相似性。这两个操作都是按照这个规则工作的。</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">还要注意的是,在平均读性能和平均写性能之间有一个权衡。为了最大限度地提高读性能,我们希望尽可能地保持WAL小,因此要频繁地运行检查点,可能和每次COMMIT一样频繁。为了最大限度地提高写性能,我们希望将每个检查点的成本摊到尽可能多的写中,这意味着我们希望不频繁地运行检查点,并在每个检查点之前让WAL尽可能地增长。因此,根据应用程序的相对读写性能要求,决定运行检查点的频率可能因应用程序而异。默认的策略是一旦WAL达到1000页就运行一个检查点,这个策略在工作站上的测试应用中似乎很好,但其他策略在不同的平台上或对于不同的工作负载可能会更好。</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">现在又可以在MSVC++6上编译了</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">现在可以在Solaris和OpenBSD以及其他缺乏fdatasync()函数的Unix变体上编译。</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">现在考虑一个查询,以找到组织中身高180cm以上的每个人的名字。</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">现在考虑M和N都是3500的情况。爱丽丝节点很多。但假设这些节点中的每一个节点都只由一条或两条边连接。在这种情况下,方案2是首选。如果采用方案2,外循环仍然要运行3500次,但是中循环每一次外循环只运行一到两次,而内循环每一次中循环只运行一次,如果有的话。所以内循环的总迭代次数在7000次左右。而方案一,它的外循环和中循环各要运行3500次,因此中循环的迭代次数为1200万次。因此在第二种情况下,方案2比方案1快了近2000倍。</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">现在是时候对SQLite进行私有的，自定义的修改了，这是本练习的重点。使用&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo;命令切换到私有分支（如果您还没有的话），然后在文本编辑器中调出源文件并进行任何您想进行的更改。完成更改后，请使用以下命令提交这些更改：</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">现在我们来看看如何使用这个索引。考虑下面的查询。</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">现在假设如果用户只有一个电话号码,则user.phone字段包含纯文本,如果用户有多个电话号码,则包含一个JSON数组。提出同样的问题。&quot;哪些用户有704区号的电话号码?&quot; 但现在json_each()函数只能调用那些有两个或多个电话号码的用户,因为json_each()需要格式良好的JSON作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">现在，公共分支机构和私有分支机构不同，您可以运行&amp;ldquo; &lt;code&gt;fossil update trunk&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo;命令，并看到在分支之间来回切换时，化石确实确实改变了结帐中的文件。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-indicator是一个可选的字符串,表示列值为空。默认值是一个空字符串。请注意,列分隔符和null-indicator是可选的位置参数;如果指定了null-indicator,则必须指定列分隔符参数,并在null-indicator参数之前使用。</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">结果集中的列数</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQL参数数量</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">已被以前的检查站回填到数据库中的WAL帧的数量。</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">试图回填但可能没有成功回填的WAL框架的数量。</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">有效载荷的字节数</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">结果集中的列数</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WAL文件中的有效和已提交的帧数。</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">数字和文本类型对DISTINCT关键字也有影响。</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">数字值(序列类型1至9)在NULLs之后按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">数字值按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">大量的错误修复和文档更新。</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">大量的代码优化,特别是为了使代码占用更小而设计的优化。</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">大量的小错误修复</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">众多其他性能的提升</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice和其他机构使用的开放文档演示格式。</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice和其他机构使用的开放文档格式。</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">对于没有FROM子句的查询，将忽略OFFSET子句。门票&lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET给出了正确答案。但是,OFFSET需要的时间与偏移值成正比。&quot;LIMIT x OFFSET y &quot;真正发生的情况是,SQLite将查询计算为 &quot;LIMIT x+y&quot;,并丢弃第一个y值,而不将其返回给应用程序。所以随着窗口向长列表的底部滚动,y值越来越大,连续的偏移计算需要的时间越来越多。</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">旧的参考资料有效</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">关于冲突条款</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM测试是通过模拟OOM错误来完成的。 SQLite允许应用程序使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;替代替代的malloc（）实现，...）界面。 TCL和TH3测试工具都能够插入修改后的malloc（）版本，该版本可以操纵一定数量的分配后失败。可以将这些检测到的malloc设置为仅失败一次，然后再次开始工作，或者在第一次失败后继续失败。 OOM测试是循环完成的。在循环的第一次迭代中，检测到的malloc被装配为在第一次分配时失败。然后执行一些SQLite操作并进行检查以确保SQLite正确处理了OOM错误。然后，已检测的malloc上的故障时间计数器增加一，并重复测试。循环一直进行到整个操作完成为止，而不会遇到模拟的OOM故障。这样的测试运行两次，一次将设置的malloc设置为仅失败一次，而再次将设置的malloc设置为在首次失败后连续失败。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">排序方式</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BY和GROUP BY现在使用有界内存。</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">如果查询具有相同的GROUP BY，则忽略ORDER BY。门票&lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY适用于子选择</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">操作系统接口</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">操作系统接口文件虚拟方法对象</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">操作系统接口对象</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">操作系统界面打开文件手柄</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
