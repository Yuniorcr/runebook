<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">所述sqlite3_last_insert_rowid（d）接口通常返回&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最近成功的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;成一个rowid表或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;上的数据库连接D.插入到&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表不被记录。如果在数据库连接D上没有成功向rowid表&lt;a href=&quot;lang_insert&quot;&gt;插入INSERT&lt;/a&gt;，则sqlite3_last_insert_rowid（D）返回零。</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）接口尝试加载文件zFile中包含的&lt;a href=&quot;../loadext&quot;&gt;SQLite扩展&lt;/a&gt;库。如果无法直接加载文件，则尝试使用添加的各种特定于操作系统的扩展名进行加载。因此，例如，如果无法加载&amp;ldquo; samplelib&amp;rdquo;，则也可以尝试使用&amp;ldquo; samplelib.so&amp;rdquo;或&amp;ldquo; samplelib.dylib&amp;rdquo;或&amp;ldquo; samplelib.dll&amp;rdquo;之类的名称。</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）接口尝试加载文件zFile中包含的&lt;a href=&quot;loadext&quot;&gt;SQLite扩展&lt;/a&gt;库。如果无法直接加载文件，则尝试使用添加的各种特定于操作系统的扩展名进行加载。因此，例如，如果无法加载&amp;ldquo; samplelib&amp;rdquo;，则也可以尝试使用&amp;ldquo; samplelib.so&amp;rdquo;或&amp;ldquo; samplelib.dylib&amp;rdquo;或&amp;ldquo; samplelib.dll&amp;rdquo;之类的名称。</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">sqlite3_log()接口是为虚拟表、整理函数和SQL函数等扩展而设计的。虽然没有什么可以阻止应用程序调用sqlite3_log(),但这样做被认为是不好的形式。</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">sqlite3_malloc()例程返回一个指向至少N个字节长度的内存块的指针,其中N是参数。如果sqlite3_malloc()无法获得足够的空闲内存,它将返回一个NULL指针。如果sqlite3_malloc()的参数N为0或负值,那么sqlite3_malloc()返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">sqlite3_malloc64(N)例程的工作原理和sqlite3_malloc(N)一样,只是N是一个无符号的64位整数而不是有符号的32位整数。</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）和sqlite3_vmprintf（）例程将其结果写入从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中。这两个例程返回的字符串应由&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放。如果&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;无法分配足够的内存来容纳结果字符串，则这两个例程都将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）和sqlite3_vmprintf（）例程将其结果写入从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中。这两个例程返回的字符串应由&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放。如果&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;无法分配足够的内存来容纳结果字符串，则这两个例程都将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">sqlite3_mutex_alloc()例程分配一个新的mutex并返回一个指向它的指针。如果不能分配所需的mutex,sqlite3_mutex_alloc()例程返回NULL。sqlite3_mutex_alloc()的参数必须是这些整数常数之一。</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）和sqlite3_mutex_try（）例程尝试输入互斥量。如果互斥锁中已有另一个线程，则sqlite3_mutex_enter（）将阻塞，而sqlite3_mutex_try（）将返回SQLITE_BUSY。成功输入后，sqlite3_mutex_try（）接口将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。使用SQLITE_MUTEX_RECURSIVE创建的互斥锁可以由同一线程多次输入。在这种情况下，互斥锁必须退出相同的次数才能进入另一个线程。如果同一线程多次尝试输入除SQLITE_MUTEX_RECURSIVE以外的任何互斥锁，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）和sqlite3_mutex_try（）例程尝试输入互斥量。如果互斥锁中已有另一个线程，则sqlite3_mutex_enter（）将阻塞，而sqlite3_mutex_try（）将返回SQLITE_BUSY。成功输入后，sqlite3_mutex_try（）接口将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。使用SQLITE_MUTEX_RECURSIVE创建的互斥锁可以由同一线程多次输入。在这种情况下，互斥锁必须退出相同的次数才能进入另一个线程。如果同一线程多次尝试输入除SQLITE_MUTEX_RECURSIVE以外的任何互斥锁，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">sqlite3_mutex_free()例程会重新定位之前分配的动态互斥。试图重新定位一个静态的mutex会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">sqlite3_mutex_held()和 sqlite3_mutex_notheld()例程是为了在 assert()语句中使用。SQLite核心除了在assert()语句中使用这些例程外,从未使用过这些例程,建议应用程序遵循核心的引导。SQLite核心只有在编译时使用SQLITE_DEBUG标志时才会提供这些例程的实现。只有在定义了SQLITE_DEBUG和没有定义NDEBUG的情况下,外部mutex实现才需要提供这些例程。</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">sqlite3_mutex_leave()例程会退出一个之前由同一线程进入的mutex。如果mutex当前没有被调用线程进入,或者当前没有被分配,那么这个行为就没有定义。</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">sqlite3_open()例程返回一个整数错误代码,而不是像版本2接口那样返回一个指向sqlite3结构的指针。sqlite3_open()和sqlite3_open16()的区别在于,sqlite3_open16()采用UTF-16(按主机本地字节顺序)作为数据库文件的名称。如果需要创建一个新的数据库文件,那么sqlite3_open16()将内部的文本表示方式设置为UTF-16,而sqlite3_open()将文本表示方式设置为UTF-8。</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）接口的工作方式类似于sqlite3_open（），不同之处在于它接受两个附加参数来对新数据库连接进行附加控制。 sqlite3_open_v2（）的flags参数可以采用以下三个值之一，可以选择与&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;和/或&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志组合：</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）接口的工作方式类似于sqlite3_open（），不同之处在于它接受两个附加参数来对新数据库连接进行附加控制。 sqlite3_open_v2（）的flags参数可以采用以下三个值之一，可以选择与&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;和/或&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志组合：</target>
        </trans-unit>
        <trans-unit id="5a0142d09a66478c971c322bbffc0dda8bf83c4b" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() must include, at a minimum, one of the following three flag combinations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）例程对SQLite库进行操作系统特定的初始化。sqlite3_os_end（）例程撤消sqlite3_os_init（）的影响。这些例程执行的典型任务包括静态资源的分配或释放，全局变量的初始化，设置默认的&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;模块或使用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;设置默认配置。</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）例程对SQLite库进行操作系统特定的初始化。sqlite3_os_end（）例程撤消sqlite3_os_init（）的影响。这些例程执行的典型任务包括静态资源的分配或释放，全局变量的初始化，设置默认的&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;模块或使用&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;设置默认配置。</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">sqlite3_pcache类型是不透明的。它是由可插拔模块实现的。SQLite核心对它的大小和内部结构一无所知,除了持有和传递指向对象的指针外,从不处理sqlite3_pcache对象。</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">不建议使用sqlite3_pcache_methods结构以及&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt;配置参数。它们由新的&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;结构以及&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt;配置参数代替。</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">sqlite3_pcache_page对象代表页面缓存中的一个页面。页面缓存将分配这个对象的实例。页面缓存的各种方法使用指向这个对象实例的指针作为参数或作为它们的返回值。</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">sqlite3_prepare接口将一条SQL语句编译成字节码供以后执行。这个接口现在是访问数据库的首选方式。</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">对于所有新程序，建议使用sqlite3_prepare_v2（），sqlite3_prepare_v3（），sqlite3_prepare16_v2（）和sqlite3_prepare16_v3（）接口。保留了较旧的接口（sqlite3_prepare（）和sqlite3_prepare16（））是为了向后兼容，但不鼓励使用它们。在&amp;ldquo; vX&amp;rdquo;接口中，返回的准备好的语句（&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象）包含原始SQL文本的副本。这导致&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口以三种方式表现不同：</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">对于所有新程序，建议使用sqlite3_prepare_v2（），sqlite3_prepare_v3（），sqlite3_prepare16_v2（）和sqlite3_prepare16_v3（）接口。保留了较旧的接口（sqlite3_prepare（）和sqlite3_prepare16（））是为了向后兼容，但不鼓励使用它们。在&amp;ldquo; vX&amp;rdquo;接口中，返回的准备好的语句（&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象）包含原始SQL文本的副本。这导致&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口以三种方式表现不同：</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D，N，X，P）接口使长时间运行对数据库连接D的&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table（）的&lt;/a&gt;调用会定期调用回调函数X。此接口的示例用法是在大型查询期间保持GUI更新。</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D，N，X，P）接口使长时间运行对数据库连接D的&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;，&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table（）的&lt;/a&gt;调用会定期调用回调函数X。此接口的示例用法是在大型查询期间保持GUI更新。</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">sqlite3_realloc(X,N)接口试图调整先前的内存分配X的大小,使其至少为N个字节。如果sqlite3_realloc(X,N)的X参数是一个NULL指针,那么它的行为和调用sqlite3_malloc(N)是一样的。如果sqlite3_realloc(X,N)的N参数是0或负数,那么它的行为与调用sqlite3_free(X)完全相同。sqlite3_realloc(X,N)返回一个指针,指向一个至少有N个字节大小的内存分配,如果可用内存不足,则返回NULL。如果M是前一个分配的大小,那么前一个分配的min(N,M)字节会被复制到sqlite3_realloc(X,N)返回的缓冲区的开头,并且释放前一个分配。如果sqlite3_realloc(X,N)返回NULL,且N为正值,那么之前的分配就不会被释放。</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">sqlite3_realloc64(X,N)接口的工作原理与 sqlite3_realloc(X,N)相同,只是 N 是一个 64 位的无符号整数,而不是一个 32 位的有符号整数。</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">通过调用sqlite3rebaser_delete()删除sqlite3_rebaser对象。</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）接口尝试通过释放数据库库所持有的不必要的内存分配来释放N字节的堆内存。用于缓存数据库页面以提高性能的内存是非必需内存的一个示例。 sqlite3_release_memory（）返回实际释放的字节数，它可能大于或小于请求的数量。如果未使用&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译SQLite，则sqlite3_release_memory（）例程是无操作的，返回零。</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）接口尝试通过释放数据库库所持有的不必要的内存分配来释放N字节的堆内存。用于缓存数据库页面以提高性能的内存是非必需内存的一个示例。 sqlite3_release_memory（）返回实际释放的字节数，它可能大于或小于请求的数量。如果未使用&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译SQLite，则sqlite3_release_memory（）例程是无操作的，返回零。</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">调用sqlite3_reset（）函数可将&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象重置回其初始状态，以备重新执行。使用&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;绑定了值的任何SQL语句变量都将保留其值。使用&lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;重置绑定。</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">调用sqlite3_reset（）函数可将&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象重置回其初始状态，以备重新执行。使用&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;绑定了值的任何SQL语句变量都将保留其值。使用&lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;重置绑定。</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">sqlite3_result_blob()接口将一个应用程序定义的函数的结果设置为BLOB,其内容由第二个参数指向,并且是N个字节长,其中N是第三个参数。</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">sqlite3_result_double()接口将应用程序定义函数的结果设置为由其第2个参数指定的浮点值。</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error()和sqlite3_result_error16()函数会使实现的SQL函数抛出异常。SQLite使用sqlite3_result_error()或sqlite3_result_error16()的第2个参数指向的字符串作为错误信息的文本。SQLite将来自sqlite3_result_error()的错误信息字符串解释为UTF-8。SQLite将来自sqlite3_result_error16()的字符串按照本机字节顺序解释为UTF-16。如果 sqlite3_result_error()或 sqlite3_result_error16()的第三个参数为负值,那么 SQLite 将从第一个零字符开始的所有文本作为错误信息。如果sqlite3_result_error()或sqlite3_result_error16()的第三个参数是非负值,那么SQLite将从第2个参数中取出的那么多字节(不是字符)作为错误信息。sqlite3_result_error()和 sqlite3_result_error16()例程在返回之前,会对错误信息的文本做一个私有的拷贝。因此,调用函数可以在返回后对文本进行重新分配或修改,而不会造成伤害。sqlite3_result_error_code()函数改变了SQLite因函数出错而返回的错误代码。默认情况下,错误代码是SQLITE_ERROR。随后调用sqlite3_result_error()或sqlite3_result_error16()会将错误代码重置为SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="29f28f42596987edc9ab24a265ebb7acbdeb19a7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a0bd3f253d68fda2502decfe5e0f0d13527f91" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">sqlite3_result_error_nomem()接口使SQLite抛出一个错误,表明内存分配失败。</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">sqlite3_result_error_toobig()接口使SQLite抛出一个错误,表示一个字符串或BLOB太长,无法表示。</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">sqlite3_result_int()接口将应用程序定义的函数的返回值设置为第2个参数中给出的32位有符号的整数值。sqlite3_result_int64()接口将应用程序定义的函数的返回值设置为第2个参数中给出的64位有符号的整数值。</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">sqlite3_result_null()接口将应用定义函数的返回值设置为NULL。</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C，P，T，D）接口将结果设置为SQL NULL值，就像&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null（C）一样&lt;/a&gt;，不同之处在于它还将主机语言指针P或类型T与该NULL值相关联，从而使指针可以使用&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数中&lt;/a&gt;检索。如果D参数不为NULL，则它是指向P参数的析构函数的指针。当SQLite用P结尾时，SQLite调用D作为唯一的参数。D参数应该是静态字符串，最好是字符串文字。 sqlite3_result_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="2141ed898fc1d1e35a1c686aae779faa61d104a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abeb9a4e536ac73c7793be889cbe18ade4a8329e" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C，P，T，D）接口将结果设置为SQL NULL值，就像&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null（C）一样&lt;/a&gt;，不同之处在于它还将主机语言指针P或类型T与该NULL值相关联，从而使指针可以使用&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数中&lt;/a&gt;检索。如果D参数不为NULL，则它是指向P参数的析构函数的指针。当SQLite用P结尾时，SQLite调用D作为唯一的参数。D参数应该是静态字符串，最好是字符串文字。 sqlite3_result_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C，T）函数使带有&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C 的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的结果子类型成为值T。在当前版本的SQLite中，仅保留了子类型T的低8位。高阶位被丢弃。在将来的SQLite版本中，SQLite保留的子类型字节数可能会增加。</target>
        </trans-unit>
        <trans-unit id="14b620485a8968d2bc78129bd173a352a06dd552" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b466179681aeddfbf231a03d679d2648006d92dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C，T）函数使带有&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C 的&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的结果子类型成为值T。在当前版本的SQLite中，仅保留了子类型T的低8位。高阶位被丢弃。在将来的SQLite版本中，SQLite保留的子类型字节数可能会增加。</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（），sqlite3_result_text16（），sqlite3_result_text16le（）和sqlite3_result_text16be（）接口将应用程序定义函数的返回值设置为文本字符串，该文本字符串表示为UTF-8，UTF-16本机字节顺序，UTF-分别为16个小字节序或UTF-16大字节序。 sqlite3_result_text64（）接口将应用程序定义的函数的返回值设置为由第五个（也是最后一个）参数指定的编码的文本字符串，该参数必须是&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE之一&lt;/a&gt;。 SQLite从sqlite3_result_text *接口的第二个参数获取应用程序的文本结果。如果sqlite3_result_text *接口的第3个参数为负，则SQLite从第2个参数到第一个零字符获取结果文本。如果sqlite3_result_text *接口的第3个参数为非负数，则将第2个参数所指向的文本字节（不是字符）作为应用程序定义的函数结果。如果第三个参数为非负数，则它必须是字符串中NUL终止处出现的字符串中字节偏移量。如果字符串中出现的任何NUL字符的字节偏移小于第3个参数的值，那么结果字符串将包含嵌入式NUL，并且对带有嵌入式NUL的字符串进行运算的表达式的结果是不确定的。如果sqlite3_result_text *接口或sqlite3_result_blob的第4个参数是非NULL指针，则SQLite在使用完该结果后将调用该函数作为文本或BLOB结果的析构函数。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_STATIC，则SQLite假定文本或BLOB结果位于恒定空间中，并且不复制参数的内容，也不会在其内容上调用析构函数完成使用该结果。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_TRANSIENT，则SQLite会将结果的副本复制到从中获取的空间中&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;返回之前。</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（），sqlite3_result_text16（），sqlite3_result_text16le（）和sqlite3_result_text16be（）接口将应用程序定义函数的返回值设置为文本字符串，该文本字符串表示为UTF-8，UTF-16本机字节顺序，UTF-分别为16个小字节序或UTF-16大字节序。 sqlite3_result_text64（）接口将应用程序定义的函数的返回值设置为由第五个（也是最后一个）参数指定的编码的文本字符串，该参数必须是&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE之一&lt;/a&gt;。 SQLite从sqlite3_result_text *接口的第二个参数获取应用程序的文本结果。如果sqlite3_result_text *接口的第3个参数为负，则SQLite从第2个参数到第一个零字符获取结果文本。如果sqlite3_result_text *接口的第3个参数为非负数，则将第2个参数所指向的文本字节（不是字符）作为应用程序定义的函数结果。如果第三个参数为非负数，则它必须是字符串中NUL终止处出现的字符串中字节偏移量。如果字符串中出现的任何NUL字符的字节偏移小于第3个参数的值，那么结果字符串将包含嵌入式NUL，并且对带有嵌入式NUL的字符串进行运算的表达式的结果是不确定的。如果sqlite3_result_text *接口或sqlite3_result_blob的第4个参数是非NULL指针，则SQLite在使用完该结果后将调用该函数作为文本或BLOB结果的析构函数。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_STATIC，则SQLite假定文本或BLOB结果位于恒定空间中，并且不复制参数的内容，也不会在其内容上调用析构函数完成使用该结果。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_TRANSIENT，则SQLite会将结果的副本复制到从中获取的空间中&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;返回之前。</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）接口将应用程序定义的函数的结果设置为第二个参数指定的&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象的副本。所述sqlite3_result_value（）接口使得副本&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;使得&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;使用参数中指定可以改变或sqlite3_result_value（）无伤害返回之后被释放。甲&lt;a href=&quot;#sqlite3_value&quot;&gt;保护sqlite3_value&lt;/a&gt;对象总是可以用在一个&lt;a href=&quot;#sqlite3_value&quot;&gt;无保护sqlite3_value&lt;/a&gt;需要对象，因此任一种&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象可以与该接口时使用。</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）接口将应用程序定义的函数的结果设置为第二个参数指定的&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象的副本。所述sqlite3_result_value（）接口使得副本&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;使得&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;使用参数中指定可以改变或sqlite3_result_value（）无伤害返回之后被释放。甲&lt;a href=&quot;value&quot;&gt;保护sqlite3_value&lt;/a&gt;对象总是可以用在一个&lt;a href=&quot;value&quot;&gt;无保护sqlite3_value&lt;/a&gt;需要对象，因此任一种&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象可以与该接口时使用。</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">sqlite3_result_zeroblob(C,N)和 sqlite3_result_zeroblob64(C,N)接口将应用定义函数的结果设置为一个包含所有零字节和N个字节大小的BLOB。</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">xGeom回调的第一个参数所指向的sqlite3_rtree_geometry结构的结构如下所示。在同一个查询中,同一个MATCH操作符的每个回调都会使用完全相同的sqlite3_rtree_geometry结构。sqlite3_rtree_geometry结构的内容是由SQLite初始化的,但随后不会被修改。如果需要,回调可以自由地对结构中的pUser和xDelUser元素进行修改。</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">sqlite3_rtree_query_callback（）在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;3.8.5&lt;/a&gt;（2014-06-04）版本中可用，并且是首选接口。sqlite3_rtree_geometry_callback（）是一个较旧且较不灵活的接口，支持向后兼容。</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D，S，P，F）接口返回指向内存的指针，该内存是&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上S数据库的序列化。如果P不是NULL指针，则将以字节为单位的数据库大小写入* P.</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D，S，P，F）接口返回指向内存的指针，该内存是&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上S数据库的序列化。如果P不是NULL指针，则将以字节为单位的数据库大小写入* P.</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">sqlite3_set_auxdata(C,N,P,X)接口将P保存为应用定义函数的第N个参数的元数据。如果元数据仍然有效,后续对 sqlite3_get_auxdata(C,N)的调用将返回最近一次调用 sqlite3_set_auxdata(C,N,P,X)中的 P,如果元数据被丢弃,则返回 NULL。在每次调用sqlite3_set_auxdata(C,N,P,X)后,其中X不是NULL,SQLite将在元数据被丢弃时,准确地调用参数为P的析构函数X一次。SQLite可以在任何时候自由丢弃元数据,包括。</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">sqlite3_set_last_insert_rowid(D,R)方法允许应用程序将调用sqlite3_last_insert_rowid(D)返回的值设置为R,而无需在数据库中插入一条记录。</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">sqlite3_sleep()函数会使当前线程暂停执行至少一个在其参数中指定的毫秒数。</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">sqlite3_snapshot对象记录了数据库文件历史版本的状态信息,这样以后打开一个新的读事务,就可以看到该数据库的历史版本,而不是最新的版本。</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">sqlite3_snapshot_cmp(P1,P2)接口用于比较两个有效快照句柄的年龄。</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">sqlite3_snprintf()例程类似于标准C库中的 &quot;snprintf()&quot;。结果被写入第二个参数提供的缓冲区中,缓冲区的大小由第一个参数给出。请注意,前两个参数的顺序与snprintf()相反。这是一个历史性的意外,在不破坏向后兼容性的情况下无法修复。还要注意的是,sqlite3_snprintf()返回的是一个指向缓冲区的指针,而不是实际写入缓冲区的字符数。我们承认写入的字符数是一个更有用的返回值,但是我们现在无法在不破坏兼容性的情况下改变 sqlite3_snprintf()的实现。</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）接口设置和/或查询SQLite可能分配的堆内存量的软限制。 SQLite努力通过在堆内存使用率接近极限时减少页面缓存中保存的页面数，将堆内存使用率保持在软堆限制以下。软堆限制是&amp;ldquo;软&amp;rdquo;的，因为即使SQLite努力保持低于该限制，它也会超过该限制而不是生成&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;错误。换句话说，软堆限制仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）接口设置和/或查询SQLite可能分配的堆内存量的软限制。 SQLite努力通过在堆内存使用率接近极限时减少页面缓存中保存的页面数，将堆内存使用率保持在软堆限制以下。软堆限制是&amp;ldquo;软&amp;rdquo;的，因为即使SQLite努力保持低于该限制，它也会超过该限制而不是生成&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;错误。换句话说，软堆限制仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">如果P是由&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;创建的，则sqlite3_sql（P）接口返回指向用于创建预&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt; P 的UTF-8 SQL文本副本的指针。 sqlite3_expanded_sql（P）接口返回指向UTF-8字符串的指针，该字符串包含已准备好的语句P的SQL文本，且&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数已&lt;/a&gt;扩展。 sqlite3_normalized_sql（P）接口返回一个指向包含已准备好的语句P的规范化SQL文本的UTF-8字符串的指针。用于规范化SQL语句的语义是未指定的，并且可能会发生更改。至少，文字值将替换为合适的占位符。</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">如果P是由&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;创建的，则sqlite3_sql（P）接口返回指向用于创建预&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt; P 的UTF-8 SQL文本副本的指针。 sqlite3_expanded_sql（P）接口返回指向UTF-8字符串的指针，该字符串包含已准备好的语句P的SQL文本，且&lt;a href=&quot;../lang_expr#varparam&quot;&gt;绑定参数已&lt;/a&gt;扩展。 sqlite3_normalized_sql（P）接口返回一个指向包含已准备好的语句P的规范化SQL文本的UTF-8字符串的指针。用于规范化SQL语句的语义是未指定的，并且可能会发生更改。至少，文字值将替换为合适的占位符。</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）和sqlite3_status64（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）和sqlite3_status64（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">如果因为锁而无法提交更改,sqlite3_step()接口返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">sqlite3_step()例程如果返回的是结果集的单行,则返回SQLITE_ROW,如果执行完毕,无论是正常执行还是错误执行,则返回SQLITE_DONE。如果无法打开数据库文件,它也可能返回SQLITE_BUSY。如果返回值是SQLITE_ROW,那么可以使用下面的例程来提取结果集中该行的信息。</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S已使用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;至少执行了一次，但既未执行完毕（从&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;），又未使用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（&lt;/a&gt;）重置，则sqlite3_stmt_busy（S）接口返回true（非零）。S）。如果S是NULL指针，则sqlite3_stmt_busy（S）接口返回false。如果S不是NULL指针，也不是指向有效的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的指针，则该行为是不确定的，并且可能是不希望的。</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">如果&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S已使用&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;至少执行了一次，但既未执行完毕（从&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;），又未使用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（&lt;/a&gt;）重置，则sqlite3_stmt_busy（S）接口返回true（非零）。S）。如果S是NULL指针，则sqlite3_stmt_busy（S）接口返回false。如果S不是NULL指针，也不是指向有效的&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的指针，则该行为是不确定的，并且可能是不希望的。</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">如果准备好的语句S是EXPLAIN语句,则sqlite3_stmt_isexplain(S)接口返回1;如果语句S是EXPLAIN查询计划,则返回2。如果S是普通语句或NULL指针,sqlite3_stmt_isexplain(S)接口返回0。</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">当且仅当&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; X没有直接更改数据库文件的内容时，sqlite3_stmt_readonly（X）接口才返回true（非零）。</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">当且仅当&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; X没有直接更改数据库文件的内容时，sqlite3_stmt_readonly（X）接口才返回true（非零）。</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str对象是使用&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;创建的。</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str对象是使用&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;创建的。</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str对象被销毁，并使用&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;接口返回它创建的字符串。</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str对象被销毁，并使用&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;接口返回它创建的字符串。</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X，D，T，C，....）例程返回有关&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; X 上数据库 D中表T列C的信息。sqlite3_table_column_metadata（）接口返回SQLITE_OK并在如果指定的列存在，则使用适当的值最后五个自变量。 sqlite3_table_column_metadata（）接口返回SQLITE_ERROR，如果指定的列不存在。如果sqlite3_table_column_metadata（）的column-name参数是NULL指针，则此例程仅检查表是否存在，如果表存在则返回SQLITE_OK，否则返回SQLITE_ERROR。如果对sqlite3_table_column_metadata（X，D，T，C，...）的调用中的表名参数T为NULL，则结果为未定义行为。</target>
        </trans-unit>
        <trans-unit id="1a9220a600a9fb3a4c23d26f17dc0f839445989b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X，D，T，C，....）例程返回有关&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; X 上数据库 D中表T列C的信息。sqlite3_table_column_metadata（）接口返回SQLITE_OK并在如果指定的列存在，则使用适当的值最后五个自变量。 sqlite3_table_column_metadata（）接口返回SQLITE_ERROR，如果指定的列不存在。如果sqlite3_table_column_metadata（）的column-name参数是NULL指针，则此例程仅检查表是否存在，如果表存在则返回SQLITE_OK，否则返回SQLITE_ERROR。如果对sqlite3_table_column_metadata（X，D，T，C，...）的调用中的表名参数T为NULL，则结果为未定义行为。</target>
        </trans-unit>
        <trans-unit id="1c11863e106d03a5d69e9f5e41b5782d50d0ba8d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">sqlite3_test_control()接口用于读出SQLite的内部状态,并向SQLite注入故障,以达到测试的目的。第一个参数是一个操作代码,决定了后续所有参数的数量、意义和操作。</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">当且仅当由于将&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE的&lt;/a&gt;编译时选项设置为0 而省略了静音代码的情况下编译SQLite时，sqlite3_threadsafe（）函数才返回零。</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">当且仅当由于将&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE的&lt;/a&gt;编译时选项设置为0 而省略了静音代码的情况下编译SQLite时，sqlite3_threadsafe（）函数才返回零。</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">sqlite3_trace()回调发生在每条语句执行之前,而不是在语句编译时。</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）接口用于替换不推荐使用的旧接口&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）接口用于替换不推荐使用的旧接口&lt;a href=&quot;profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;和&lt;a href=&quot;profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D，M，X，P）接口使用属性掩码M和上下文指针P 针对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 注册跟踪回调函数X。如果X回调为NULL或M掩码为零，则禁用跟踪。M参数应为零或多个&lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt;常数的按位&amp;ldquo;或&amp;rdquo;组合。</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D，M，X，P）接口使用属性掩码M和上下文指针P 针对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 注册跟踪回调函数X。如果X回调为NULL或M掩码为零，则禁用跟踪。M参数应为零或多个&lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt;常数的按位&amp;ldquo;或&amp;rdquo;组合。</target>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）接口使用第一个参数标识的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册一个回调函数，只要在&lt;a href=&quot;rowidtable&quot;&gt;rowid表中&lt;/a&gt;更新，插入或删除行时就将调用该函数。先前调用此函数为同一数据库连接设置的任何回调都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）接口使用第一个参数标识的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册一个回调函数，只要在&lt;a href=&quot;../rowidtable&quot;&gt;rowid表中&lt;/a&gt;更新，插入或删除行时就将调用该函数。先前调用此函数为同一数据库连接设置的任何回调都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D，C，P）函数从同一&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的上一次调用返回P参数，对于D上的第一次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D，C，P）函数从同一&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的上一次调用返回P参数，对于D上的第一次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="9e5c2049439d88f4f1e900d8863f9c93f3ca0ab3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean(F,P,B)例程假设P是一个布尔参数,并根据P的值返回true(1)或false(0)。 sqlite3_uri_boolean(F,P,B)例程在任何情况下,如果查询参数P的值是 &quot;yes&quot;、&quot;true &quot;或 &quot;on &quot;之一,或者如果该值以非零数开头,则返回true(1)。sqlite3_uri_boolean(F,P,B)例程在任何情况下,如果查询参数P的值是 &quot;no&quot;、&quot;false &quot;或 &quot;off &quot;中的一个,或者如果值以数字0开头,则返回false(0)。如果P不是F上的查询参数,或者P的值不符合上述任何一种情况,那么sqlite3_uri_boolean(F,P,B)返回(B!=0)。</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">sqlite3_uri_int64(F,P,D)例程将P的值转换为一个64位有符号的整数,并返回该整数,如果P不存在,则返回D。如果P的值不是整数,则返回0。</target>
        </trans-unit>
        <trans-unit id="00f6b921b58342af7827ee6740ce3bd7da1204bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_key(F,N) returns a pointer to the name (not the value) of the N-th query parameter for filename F, or a NULL pointer if N is less than zero or greater than the number of query parameters minus 1. The N value is zero-based so N should be 0 to obtain the name of the first query parameter, 1 for the second parameter, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）接口返回指针的副本，该指针是最初注册应用程序定义函数的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的pUserData参数（第5个参数）。</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）接口返回指针的副本，该指针是最初注册应用程序定义函数的&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的pUserData参数（第5个参数）。</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">作为参数传递到&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的实现中的sqlite3_value对象受到保护。由&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的sqlite3_value对象不受保护。未受保护的sqlite3_value对象只能用作&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）的参数&lt;/a&gt;。该&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;系列的接口需要保护sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="878c26369032034cf1577de94a30701d2b72bfbf" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8545cde1bbfc4f37da956f6919362a532aef6b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">作为参数传递到&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的实现中的sqlite3_value对象受到保护。由&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的sqlite3_value对象不受保护。未受保护的sqlite3_value对象只能用作&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;，&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）的参数&lt;/a&gt;。该&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;系列的接口需要保护sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）接口创建&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象D 的副本，并返回指向该副本的指针。即使输入不是，返回的&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;是&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。如果V为NULL或内存分配失败，则sqlite3_value_dup（V）接口返回NULL。</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）接口创建&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象D 的副本，并返回指向该副本的指针。即使输入不是，返回的&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;是&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。如果V为NULL或内存分配失败，则sqlite3_value_dup（V）接口返回NULL。</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）接口释放先前从&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;获得的&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象。如果V是NULL指针，则sqlite3_value_free（V）是无害的无操作。</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）接口释放先前从&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;获得的&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象。如果V是NULL指针，则sqlite3_value_free（V）是无害的无操作。</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">如果值X源自&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;接口之一，则sqlite3_value_frombind（X）接口返回非零值。如果X来自SQL文字值，表列和表达式，则sqlite3_value_frombind（X）返回零。</target>
        </trans-unit>
        <trans-unit id="80d4668ad9e2d92c3db76ff20be74213c969d9ff" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">如果值X源自&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;接口之一，则sqlite3_value_frombind（X）接口返回非零值。如果X来自SQL文字值，表列和表达式，则sqlite3_value_frombind（X）返回零。</target>
        </trans-unit>
        <trans-unit id="d098066d168e6b39abb688284c2a26c07f3bcf76" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）接口尝试将数字亲和力应用于该值。这意味着试图将值转换为整数或浮点数。如果可以进行这种转换而不会丢失信息（换句话说，如果该值是看起来像数字的字符串），那么将执行转换。否则，将不会发生转换。返回转换后的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）接口尝试将数字亲和力应用于该值。这意味着试图将值转换为整数或浮点数。如果可以进行这种转换而不会丢失信息（换句话说，如果该值是看起来像数字的字符串），那么将执行转换。否则，将不会发生转换。返回转换后的&lt;a href=&quot;c_blob&quot;&gt;数据类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）函数返回&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数自&lt;/a&gt;变量V的子类型。子类型信息可用于将有限量的上下文从一个SQL函数传递给另一个SQL函数。使用&lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;例程为SQL函数的返回值设置子类型。</target>
        </trans-unit>
        <trans-unit id="ac784313e8a1c8814ecb1722aed4c17998bb6a84" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9482d5c89729cab0c852ef903cf3adcd7fd134d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）函数返回&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数自&lt;/a&gt;变量V的子类型。子类型信息可用于将有限量的上下文从一个SQL函数传递给另一个SQL函数。使用&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;例程为SQL函数的返回值设置子类型。</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">sqlite3_value_text16()接口以主机的本机字节顺序提取UTF-16字符串。sqlite3_value_text16be()和 sqlite3_value_text16le()接口分别将UTF-16字符串提取为big-endian和little-endian。</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）接口返回&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象V 的初始数据类型的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型代码&lt;/a&gt;。返回值是&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。其他接口可能会更改sqlite3_value对象的数据类型。例如，如果数据类型最初是SQLITE_INTEGER，并且调用sqlite3_value_text（V）提取该整数的文本值，则随后对sqlite3_value_type（V）的调用可能返回SQLITE_TEXT。不确定是否发生持久内部数据类型转换，并且可能会从一个SQLite版本更改为另一个版本。</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）接口返回&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象V 的初始数据类型的&lt;a href=&quot;c_blob&quot;&gt;数据类型代码&lt;/a&gt;。返回值是&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。其他接口可能会更改sqlite3_value对象的数据类型。例如，如果数据类型最初是SQLITE_INTEGER，并且调用sqlite3_value_text（V）提取该整数的文本值，则随后对sqlite3_value_type（V）的调用可能返回SQLITE_TEXT。不确定是否发生持久内部数据类型转换，并且可能会从一个SQLite版本更改为另一个版本。</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []字符串常量包含&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;宏的文本。 sqlite3_libversion（）函数返回一个指向sqlite3_version []字符串常量的指针。提供sqlite3_libversion（）函数供DLL使用，因为DLL用户通常无法直接访问DLL中的字符串常量。 sqlite3_libversion_number（）函数返回一个等于&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;的整数。 sqlite3_sourceid（）函数返回一个指向字符串常量的指针，该字符串常量的值与&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同。除非SQLite是使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;的编辑副本构建的，否则哈希的最后四个字符可能与&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []字符串常量包含&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;宏的文本。 sqlite3_libversion（）函数返回一个指向sqlite3_version []字符串常量的指针。提供sqlite3_libversion（）函数供DLL使用，因为DLL用户通常无法直接访问DLL中的字符串常量。 sqlite3_libversion_number（）函数返回一个等于&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;的整数。 sqlite3_sourceid（）函数返回一个指向字符串常量的指针，该字符串常量的值与&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同。除非SQLite是使用&lt;a href=&quot;../amalgamation&quot;&gt;合并&lt;/a&gt;的编辑副本构建的，否则哈希的最后四个字符可能与&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">sqlite3_vfs_find()接口返回一个给定名称的VFS指针。名称是区分大小写的,名称是零结尾的UTF-8字符串。名称是以零结尾的UTF-8字符串,如果没有匹配,返回一个NULL指针。如果没有匹配,将返回一个NULL指针。如果zVfsName为NULL,则返回默认的VFS。</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">sqlite3_vsnprintf()例程是 sqlite3_snprintf()的一个varargs版本。</target>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D，X）等同于&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D，X，&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;，0,0）。</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D，X）等同于&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D，X，&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;，0,0）。</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D，X，M，L，C）接口在模式M下对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D的数据库X运行检查点操作。状态信息被写回到L和C所指向的整数。M参数必须为有效&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;检查点模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D，X，M，L，C）接口在模式M下对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D的数据库X运行检查点操作。状态信息被写回到L和C所指向的整数。M参数必须为有效&lt;a href=&quot;c_checkpoint_full&quot;&gt;检查点模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">当更新sqlite_stat1表时,sqlite3changeset_apply()函数会自动将零长度的blob转换回NULL值。但是,如果应用程序直接在一个变化集迭代器上调用sqlite3changeset_new()、sqlite3changeset_old()或sqlite3changeset_conflict(包括传递给冲突处理回调的变化集迭代器),那么就会返回X''值。如果需要的话,应用程序必须自己将X''翻译成NULL。</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">sqlite3rbu_open(T,A,S)函数返回一个指向 &quot;sqlite3rbu &quot;对象的指针,然后传入后续的接口。</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">sqlite3session_config()接口不是线程安全的。如果在任何其他线程处于任何其他session方法中时调用它,那么结果是未定义的。此外,如果在任何会话相关对象被创建后调用它,结果也是未定义的。</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">sqlite3session_config()接口用于对session模块进行全局配置修改,以便根据应用的具体需求进行调整。</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">sqlite_compileoption_get（）SQL函数是对&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++函数的包装。此例程返回用于构建SQLite的第N个编译时选项；如果N超出范围，则返回NULL。另请参见&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">sqlite_compileoption_used（）SQL函数是对&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt; C / C ++函数的包装。当sqlite_compileoption_used（X）的参数X是作为编译时选项名称的字符串时，此例程将返回true（1）或false（0），具体取决于在构建过程中是否使用了该选项。</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_master表针对数据库架构中的每个表，索引，视图和触发器（统称为&amp;ldquo;对象&amp;rdquo;）包含一行，但sqlite_master表本身没有条目。sqlite_master表除了应用程序和程序员定义的对象外，还包含&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部模式对象的&lt;/a&gt;条目。</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_master.name列将保存对象的名称。&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;表上的UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束导致SQLite创建&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部索引&lt;/a&gt;，其名称格式为&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;，其中TABLE替换为包含约束的表的名称，N为以1开头并随每个约束加1的整数。在表定义中可见。在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中，PRIMARY KEY没有sqlite_master条目，但是PRIMARY KEY却保留了&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称，就好像sqlite_master条目确实存在一样。这将影响随后的UNIQUE约束的编号。 &amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称永远不会分配给&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，在rowid表或WITHOUT ROWID表中。</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_master.rootpage列存储了表和索引的根b树页的页码。对于定义视图、触发器和虚拟表的行,rootpage列是0或NULL。</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_master.sql列存储描述对象的SQL文本。该SQL文本是&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;，&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;，&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;，&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;或&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句，如果针对数据库文件进行评估（如果它是&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的主数据库），则会重新创建该对象。文本通常是用于创建对象的原始语句的副本，但是应用了规范化，因此文本符合以下规则：</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_master.tbl_name列保存了对象所关联的表或视图的名称,对于一个表或视图,tbl_name列是名称列的副本。对于表或视图来说,tbl_name列是name列的副本。对于一个索引,tbl_name是被索引的表的名称。对于触发器,tbl_name列存储的是导致触发器被触发的表或视图的名称。</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_master.type列将是以下文本字符串之一：&amp;ldquo; table&amp;rdquo;，&amp;ldquo; index&amp;rdquo;，&amp;ldquo; view&amp;rdquo;或&amp;ldquo; trigger&amp;rdquo;（根据定义的对象类型）。'table'字符串用于普通&lt;a href=&quot;vtab&quot;&gt;表&lt;/a&gt;和虚拟表。</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">只有使用&lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;编译时选项构建SQLite时，sqlite_offset（X）SQL函数才可用。</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">sqlite_offset(X)函数返回数据库文件中读取值的记录开头的字节偏移量。如果X不是普通表中的列,那么sqlite_offset(X)返回NULL。sqlite_offset(X)返回的值可能引用原始表或索引,这取决于查询。如果值X通常会从索引中提取,那么sqlite_offset(X)返回对应索引记录的偏移量。如果值X将从原始表中提取,那么sqlite_offset(X)返回到表记录的偏移量。</target>
        </trans-unit>
        <trans-unit id="7edde881cc83be6805465c505116db44a7c10317" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_schema table itself. The sqlite_schema table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02071e2d759314e2fb363a98ec697450c31c3a5" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54e4469dd50abde5034fd8f801a4d0306037ed0" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6bcf89a71c75b0fa182495e5015131f7df248c" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d911ebef016f1f15b28a4875cf26c113309d9fa3" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a28099cf1bad8380c62abb7ce56059bbeb63ba" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequence表是用于帮助实现&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;的内部表。每当创建具有AUTOINCREMENT整数主键的任何普通表时，都会自动创建sqlite_sequence表。创建后，sqlite_sequence表将永远存在于sqlite_master表中。它不能被丢弃。sqlite_sequence表的架构为：</target>
        </trans-unit>
        <trans-unit id="45d57d826d6c576b74670b2e5b7c281dbdfadbab" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_schema table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">sqlite_source_id（）函数返回一个字符串，该字符串标识用于构建SQLite库的源代码的特定版本。sqlite_source_id（）返回的字符串是签入源代码的日期和时间，后跟该签入的SHA1哈希。该函数是&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt; C接口的SQL包装器。</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">sqlite_stat1是由&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令创建的内部表，用于保存有关表和索引的补充信息，查询计划程序可以使用这些信息来帮助其查找执行查询的更好方法。应用程序可以更新，删除，插入或删除sqlite_stat1表，但不能创建或更改sqlite_stat1表。sqlite_stat1表的架构如下：</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">一个索引的sqlite_stat2.sampleno在0到9(含)之间的sqlite_stat2条目是在索引中最左边的键值沿索引均匀间隔的点上取的样本。让C为索引中的行数。那么,采样的行数由以下公式给出</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2只在SQLite被编译为SQLITE_ENABLE_STAT2,并且SQLite版本号在3.6.18(2009-09-11)和3.7.8(2011-09-19)之间的情况下才会被创建和使用。sqlite_stat2表既不能被3.6.18之前的SQLite版本读取,也不能被3.7.8之后的SQLite版本写入。sqlite_stat2表包含了关于索引内键分布的附加信息。sqlite_stat2表的模式如下。</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">sqlite_stat2表中每行的sqlite_stat2.idx列和sqlite_stat2.tbl列标识了该行所描述的索引。在sqlite_stat2表中,每个索引通常有10行。</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">只有在使用&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;或&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译SQLite 且SQLite版本号为3.7.9（2011-11-01）或更高版本时，才使用sqlite_stat3。在3.7.9之前的任何版本的SQLite都无法读写sqlite_stat3表。如果使用了&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，并且SQLite版本号是3.8.1（2013-10-17）或更高版本，则sqlite_stat3可能被读取但未被写入。 sqlite_stat3表包含有关索引内键的分布的其他信息，查询计划人员可以使用该信息来设计更好，更快的查询算法。 sqlite_stat3表的架构如下：</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">sqlite_stat4是sqlite_stat3表的泛化,sqlite_stat3表提供了索引最左边的列的信息,而sqlite_stat4表提供了索引所有列的信息。sqlite_stat3表提供了一个索引最左边的列的信息,而sqlite_stat4表提供了索引所有列的信息。</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">sqlite_stat4仅在使用&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译SQLite 且SQLite版本号为3.8.1（2013-10-17）或更高版本时创建并使用。在3.8.1之前的任何版本的SQLite都无法读写sqlite_stat4表。 sqlite_stat4表包含有关索引中的键分布或&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的主键中的键分布的其他信息。查询计划者有时可以使用sqlite_stat4表中的其他信息来设计更好，更快的查询算法。 sqlite_stat4表的架构如下：</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">sqlite_stat4.idx列保存该行描述的索引的名称，或者对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，如果为sqlite_stat4条目，则保留该表本身的名称。</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">sqlite_stat4.nDLt列中存放了N个整数列表,其中K-th整数是指索引中前K列不同的条目数,且最左K列的总和小于样本的最左K列。</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nEq列持有N个整数列表,其中K-th整数是索引中最左K列与样本最左K列完全匹配的条目数的近似值。</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nLt列中存放了N个整数列表,其中K-th整数是指索引中K最左列总和小于样本最左列的条目数。</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">sqlite_stat4.sample列包含&lt;a href=&quot;fileformat2#record_format&quot;&gt;记录格式&lt;/a&gt;的BLOB，该BLOB 对索引列进行编码，然后对rowid表的rowid或对WITHOUT ROWID表的主键的列进行编码。 WITHOUT ROWID表本身的sqlite_stat4.sample BLOB仅包含主键的列。假设由sqlite_stat4.sample Blob编码的列数为N。对于普通rowid表上的索引，N将比索引的列数多一。对于WITHOUT ROWID表上的索引，N将是被索引的列数加上主键中的列数。对于WITHOUT ROWID表，N将为主键中的列数。</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">sqlite_stat4.tbl列拥有该行所描述的索引的表名。</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">sqlite_version（）函数返回正在运行的SQLite库的版本字符串。此函数是&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion（）&lt;/a&gt; C接口的SQL包装器。</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">SQLite数据库文件格式的稳定性以及该文件格式是跨平台的事实共同使SQLite数据库文件成为&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;的绝佳选择。美国国会图书馆通过将SQLite列为长期保存数字内容的&lt;a href=&quot;locrsf&quot;&gt;推荐存储格式&lt;/a&gt;来认可这一点。</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">标准的SQLite源代码树包含用于UNIX和Windows的内置VFS。可以使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;接口在启动时或运行时添加备用VFS 。</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">第一次打开数据库连接时,计算机的状态由右图概念性地显示出来。图中最右边的区域(标为 &quot;Disk&quot;)表示存储在大容量存储设备上的信息。每个矩形是一个扇区。蓝色代表这些扇区包含原始数据。中间的区域是操作系统的磁盘缓存。在我们的例子中,缓存是冷的,这通过将磁盘缓存的矩形留空来表示。图中左侧区域显示的是使用SQLite的进程的内存内容。数据库连接刚刚打开,还没有读取任何信息,所以用户空间是空的。</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">上面的语句创建了一个名为 &quot;newtab &quot;的新地缘表。每个地缘表都包含一个内置的整数 &quot;rowid &quot;列和一个&quot;_shape &quot;列,其中包含了与表中该行相关联的多边形。上面的例子还定义了三个名为 &quot;a&quot;、&quot;b &quot;和 &quot;c &quot;的辅助数据列,可以存储应用程序需要与每个多边形相关联的任何附加信息。如果不需要存储辅助信息,可以省略辅助列列表。</target>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">上面的陈述在某些语法上可能看起来不正确。有关说明，请参阅描述&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;简单fts查询&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">语句日志被赋予一个随机的名称,不一定与主数据库在同一目录下,并在事务结束时自动删除。语句日志的大小与导致创建语句日志的UPDATE或INSERT语句所实现的变化大小成正比。</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">status方法基本上是&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt; C语言接口的包装。</target>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">该策略是使用&lt;b&gt;sqlite_compile&lt;/b&gt;编译单个SQL语句，然后多次调用&lt;b&gt;sqlite_step（&lt;/b&gt;对于输出的每一行一次），最后在SQL完成执行后调用&lt;b&gt;sqlite_finalize&lt;/b&gt;进行清理。</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">长度为P1(字节)的字符串值P4存储在寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="9a7f87028156aaa8a8bf754d55b553e046a12fec" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb38b0feb448edc668a127b1d9c6a6f2f876060a" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）和sqlite3_normalized_sql（P）返回的字符串由SQLite管理，并在准备好的语句完成后自动释放。另一方面，sqlite3_expanded_sql（P）返回的字符串是从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的，并且必须由应用程序通过将其传递给&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）和sqlite3_normalized_sql（P）返回的字符串由SQLite管理，并在准备好的语句完成后自动释放。另一方面，sqlite3_expanded_sql（P）返回的字符串是从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的，并且必须由应用程序通过将其传递给&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">子查询和外层查询都不使用LIMIT。</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">子查询和外查询不都有ORDER BY子句。</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">子查询不使用LIMIT或外查询不使用聚合。</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">子查询没有使用LIMIT,或者外查询不是连接。</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">子查询不使用OFFSET。</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">子查询中有一个FROM子句。</target>
        </trans-unit>
        <trans-unit id="36f95cae80ab7a78b4e298e8fc4b136f62be389f" translate="yes" xml:space="preserve">
          <source>The subquery in the FROM clause computes the amount by which the inventory should be reduced for each itemId. That subquery is joined against the inventory table and the quantity of each affected inventory row is reduced by the appropriate amount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">子查询不是DISTINCT。</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">子查询可能不是递归CTE。</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">替换字符(unicode码点26)。</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">上面SQL视图中的substr()函数返回rbu_control参数的文本,但去掉了第一个字符(对应于列 &quot;i &quot;的那个字符,FTS表不需要)。</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">函数substr(X,Y,Z)返回一个从Y-th字符开始的输入字符串X的子串,长度为Z字符。如果省略Z,那么substr(X,Y)将返回从Y-th开始的字符串X的所有字符。X的最左边的字符是1号。如果Y是负数,那么子串的第一个字符是从右边而不是左边开始数的。如果Z是负数,那么返回Y-th字符前面的abs(Z)字符。如果X是一个字符串,那么字符索引指的是实际的UTF-8字符。如果X是一个BLOB,那么索引指的是字节。</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">所有 &quot;四个 &quot;值的总和。用于计算 &quot;avg(four)&quot;。</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">sum()和total()集合函数返回组中所有非NULL值的总和。如果没有非NULL的输入行,那么sum()返回NULL,但是total()返回0.0。对于没有行的总和来说,NULL通常不是一个有用的结果,但是SQL标准要求这样做,而且大多数其他的SQL数据库引擎都是这样实现sum()的,所以为了兼容,SQLite也是这样做的。提供非标准的total()函数是为了方便地解决SQL语言中的这个设计问题。</target>
        </trans-unit>
        <trans-unit id="c8cc59294c9d81aba99fd5de24fb6dc6b41b0132" translate="yes" xml:space="preserve">
          <source>The super-journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee67fa1e83c36dfa202c1d70aacf19927252737" translate="yes" xml:space="preserve">
          <source>The super-journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The super-journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The super-journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the super-journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">仅在WITHOUT ROWID表中抑制索引条目的键后缀中的冗余列。在普通的rowid表中，即使&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列是被索引的列之一，索引条目也总是以rowid结尾。</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">swarmvtab 实现可以在任何时候打开或关闭数据库。默认情况下,它试图将同时打开的数据库文件的最大数量限制为九个。这并不是一个硬性的限制-可以构建一个会导致 swarmvtab 超过这个限制的方案。</target>
        </trans-unit>
        <trans-unit id="9f9e99aa51f888cdf6630598d938ef39ae15f9a3" translate="yes" xml:space="preserve">
          <source>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt;. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.</source>
          <target state="translated">SQLite为帮助确保完整性而执行的同步操作可以在运行时使用&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;同步编译指示&lt;/a&gt;禁用。通过将PRAGMA同步设置为OFF，将忽略所有同步操作。这使得SQLite看起来运行得更快，但是它也允许操作系统自由地对写操作进行重新排序，如果在所有内容到达持久存储之前发生电源故障或硬重置，则可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="8ed0f1cf6ef82d0d97320ed63cceee25b526aa88" translate="yes" xml:space="preserve">
          <source>The synchronous version of SQLite is the slowest of the group in this test, but the asynchronous version is the fastest. The difference is the extra time needed to execute fsync().</source>
          <target state="translated">在这个测试中,SQLite的同步版本是这组测试中最慢的,但异步版本是最快的。区别在于执行fsync()需要额外的时间。</target>
        </trans-unit>
        <trans-unit id="88535ccaca4588c188d3dec59b74e5b6c648c437" translate="yes" xml:space="preserve">
          <source>The syntax for a window function is like this:</source>
          <target state="translated">窗口函数的语法是这样的。</target>
        </trans-unit>
        <trans-unit id="e97f2e6030323368e9626fb51e9e8ff6dc7c7f0a" translate="yes" xml:space="preserve">
          <source>The syntax for integer and floating point literals (collectively &quot;numeric literals&quot;) is shown by the following diagram:</source>
          <target state="translated">整数字和浮点字(统称为 &quot;数字字&quot;)的语法如下图所示。</target>
        </trans-unit>
        <trans-unit id="c1140f24a0825da092ba683013464dc50c75b952" translate="yes" xml:space="preserve">
          <source>The syntax for row values and the circumstances in which row values can be used are illustrated in examples below.</source>
          <target state="translated">行值的语法和可以使用行值的情况在下面的例子中进行了说明。</target>
        </trans-unit>
        <trans-unit id="0601104dedcf396efbb0c30203a6d31fd40a4a67" translate="yes" xml:space="preserve">
          <source>The syntax for the ON CONFLICT clause is as shown above for the CREATE TABLE command. For the INSERT and UPDATE commands, the keywords &quot;ON CONFLICT&quot; are replaced by &quot;OR&quot; so that the syntax reads more naturally. For example, instead of &quot;INSERT ON CONFLICT IGNORE&quot; we have &quot;INSERT OR IGNORE&quot;. The keywords change but the meaning of the clause is the same either way.</source>
          <target state="translated">ON CONFLICT子句的语法与上面CREATE TABLE命令的语法相同。对于INSERT和UPDATE命令,关键字 &quot;ON CONFLICT &quot;被 &quot;OR &quot;代替,这样语法读起来更自然。例如,我们用 &quot;INSERT OR IGNORE &quot;代替 &quot;INSERT ON CONFLICT IGNORE&quot;。关键字变了,但无论哪种方式,子句的意思都是一样的。</target>
        </trans-unit>
        <trans-unit id="f067d61a53dcb338fdf63bf3df528ef6a0487e73" translate="yes" xml:space="preserve">
          <source>The syntax looks like this:</source>
          <target state="translated">语法是这样的。</target>
        </trans-unit>
        <trans-unit id="a61a22c417283e11aa14f2ba9ecd8cd0c90ce62d" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;, &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;, &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and many other commands all permit the user to specify a database object either by its name alone, or by a combination of its name and the name of its database. If no database is specified as part of the object reference, then SQLite searches the main, temp and all attached databases for an object with a matching name. The temp database is searched first, followed by the main database, followed all attached databases in the order that they were attached. The reference resolves to the first match found. For example:</source>
          <target state="translated">&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;，&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;，&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;，&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;，&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;，&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;和许多其他命令的语法都允许用户仅通过名称或通过名称和名称的组合指定数据库对象它的数据库。如果未将任何数据库指定为对象引用的一部分，则SQLite将在主数据库，临时数据库和所有附加数据库中搜索具有匹配名称的对象。首先搜索临时数据库，然后搜索主数据库，再搜索所有连接的数据库，顺序为连接的顺序。参考解析为找到的第一个匹配项。例如：</target>
        </trans-unit>
        <trans-unit id="070a4a12a4cd8479f973f088343e30dee884b914" translate="yes" xml:space="preserve">
          <source>The syntax that occurs in between the &quot;ON CONFLICT&quot; and &quot;DO&quot; keywords is called the &quot;conflict target&quot;. The conflict target specifies a specific uniqueness constraint that will trigger the upsert. The conflict target is required for DO UPDATE upserts, but is optional for DO NOTHING. When the conflict target is omitted, the upsert behavior is triggered by a violation of any uniqueness constraint on the table of the INSERT.</source>
          <target state="translated">发生在 &quot;ON CONFLICT &quot;和 &quot;DO &quot;关键字之间的语法称为 &quot;冲突目标&quot;。冲突目标指定了将触发upsert的特定唯一性约束。对于DO UPDATE upsert来说,冲突目标是必须的,但对于DO NOTHING来说,冲突目标是可选的。当冲突目标被省略时,upsert行为会被INSERT表上的任何唯一性约束的违反所触发。</target>
        </trans-unit>
        <trans-unit id="6578fb33b7ba1ef0fa58c80688a069c9340aa258" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size in bytes of the structure that defines an open file: the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. This object will be described more fully below. The point here is that each VFS implementation can define its own &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object containing whatever information the VFS implementation needs to store about an open file. SQLite needs to know how big this object is, however, in order to preallocate enough space to hold it.</source>
          <target state="translated">szOsFile字段是定义打开文件的结构的大小（以字节为单位）：&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象。下面将更全面地描述该目的。这里的要点是，每个VFS实现都可以定义自己的&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象，其中包含VFS实现需要存储的有关打开文件的任何信息。SQLite需要知道该对象的大小，以便预先分配足够的空间来容纳它。</target>
        </trans-unit>
        <trans-unit id="4160b3968588675d955230ce2bf92a9066be0932" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFile字段是此VFS使用的子类&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;结构的大小。mxPathname是此VFS中路径名的最大长度。</target>
        </trans-unit>
        <trans-unit id="0c08ad2486a604361da59adedd8095e01f05af8a" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFile字段是此VFS使用的子类&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;结构的大小。mxPathname是此VFS中路径名的最大长度。</target>
        </trans-unit>
        <trans-unit id="34b2e05f8be89f8919f89034a92c2255013098b0" translate="yes" xml:space="preserve">
          <source>The t2 table is completely unused in the query above, and so the query planner is able to implement the query as if it were written:</source>
          <target state="translated">在上面的查询中,t2表完全没有使用,所以查询规划器能够像写查询一样实现查询。</target>
        </trans-unit>
        <trans-unit id="4238f21507c2ee050a84b88e1b8452b278b7cbd3" translate="yes" xml:space="preserve">
          <source>The table &quot;t1&quot; has four columns &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; that have no particular datatype assigned. You can store anything you want in any of those columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69666453d6f0a7ffe136a772a15ed97e78f29762" translate="yes" xml:space="preserve">
          <source>The table being clear is in the main database file if P2==0. If P2==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">如果P2==0,则被清除的表在主数据库文件中,如果P2==1,则被清除的表在辅助数据库文件中,该文件用于存储使用CREATE TEMPORARY TABLE创建的表。</target>
        </trans-unit>
        <trans-unit id="b84cc68d91e3409f1edcdf58fc339f372294c1e2" translate="yes" xml:space="preserve">
          <source>The table being destroyed is in the main database file if P3==0. If P3==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">如果P3==0,则被销毁的表在主数据库文件中,如果P3==1,则要清除的表在辅助数据库文件中,该文件用于存储使用CREATE TEMPORARY TABLE创建的表。</target>
        </trans-unit>
        <trans-unit id="41f345ab868d88acd8992e4784839c2d5c1e8639" translate="yes" xml:space="preserve">
          <source>The table below lists a few of the virtual tables implementations available for SQLite. Developers can deploy these virtual tables in their own applications, or use the implementations shown below as templates for writing their own virtual tables.</source>
          <target state="translated">下表列出了一些可用于SQLite的虚拟表实现。开发人员可以在自己的应用程序中部署这些虚拟表,或者使用下面显示的实现作为模板来编写自己的虚拟表。</target>
        </trans-unit>
        <trans-unit id="0d5035ee89279b64afd0eeb8d11272d1a3924472" translate="yes" xml:space="preserve">
          <source>The table conceptually has a number of rows and columns. But these numbers are not part of the result table itself. These numbers are obtained separately. Let N be the number of rows and M be the number of columns.</source>
          <target state="translated">该表在概念上有若干行和列。但这些数字不是结果表本身的一部分。这些数字是单独获得的。设N为行数,M为列数。</target>
        </trans-unit>
        <trans-unit id="dcf57858fad384bb52da74fd124071a651012ac9" translate="yes" xml:space="preserve">
          <source>The table has at least as many columns as recorded in the changeset, and</source>
          <target state="translated">该表的列数至少与变化集中记录的列数相同,并且</target>
        </trans-unit>
        <trans-unit id="c59c86844961ecda887187879536aa8941add7f6" translate="yes" xml:space="preserve">
          <source>The table has primary key columns in the same position as recorded in the changeset.</source>
          <target state="translated">该表的主键列与变更集中记录的位置相同。</target>
        </trans-unit>
        <trans-unit id="80f1ee5eb53df523cde7e4859fa53a41bb0e9f57" translate="yes" xml:space="preserve">
          <source>The table has the same name as the name recorded in the changeset, and</source>
          <target state="translated">该表的名称与变更集中记录的名称相同,并且。</target>
        </trans-unit>
        <trans-unit id="7d27b581c3631a8cd2d37de114b2996daa06d034" translate="yes" xml:space="preserve">
          <source>The table named in the table_info pragma can also be a view.</source>
          <target state="translated">table_info pragma中命名的表也可以是一个视图。</target>
        </trans-unit>
        <trans-unit id="79bd6ebb5ebe8eca1811d6164c483996ae2dbb59" translate="yes" xml:space="preserve">
          <source>The table named on the left-hand side of the AS keyword must appear exactly once in the FROM clause of the right-most SELECT statement of the compound select, and nowhere else.</source>
          <target state="translated">AS关键字左侧命名的表必须在复合选择的最右侧的SELECT语句的FROM子句中准确出现一次,其他地方都不能出现。</target>
        </trans-unit>
        <trans-unit id="747fb24ebf8caf800f314099b86fad330ec2bb21" translate="yes" xml:space="preserve">
          <source>The table that is being changed</source>
          <target state="translated">正在更改的表</target>
        </trans-unit>
        <trans-unit id="e089550b926c62bbc2dcb5b20ca60a982f76e723" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of a DELETE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">作为触发器主体中DELETE语句的一部分,指定的表名必须是无限制的。换句话说,在</target>
        </trans-unit>
        <trans-unit id="f34e54cb0abeaba37df0e01490317583d5a035fb" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of an UPDATE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">在触发器主体中作为UPDATE语句的一部分指定的表名必须是无限制的。换句话说,在触发体中指定的</target>
        </trans-unit>
        <trans-unit id="234e68825ade4fb4c6a3d0e2fe2ac2487e1f2eea" translate="yes" xml:space="preserve">
          <source>The table-valued function returns one row for each record (file, directory or symbolic link) in the zip archive. Each row has the following columns:</source>
          <target state="translated">表值函数为zip压缩包中的每条记录(文件、目录或符号链接)返回一行。每一行有以下几列。</target>
        </trans-unit>
        <trans-unit id="d7dc1f7c6b1a5d93554b66158b8eab41e9fa0f02" translate="yes" xml:space="preserve">
          <source>The table-valued function syntax may also be used to specify an alternative ranking function. In this case the text describing the ranking function should be specified as the second table-valued function argument. The following three queries are equivalent:</source>
          <target state="translated">表值函数语法也可以用来指定一个替代的排序函数,在这种情况下,应该指定描述排序函数的文本作为第二个表值函数参数。在这种情况下,描述排序函数的文本应该被指定为第二个表值函数参数。以下三个查询是等价的。</target>
        </trans-unit>
        <trans-unit id="194c5b8001842ee44aaaa2c4539d9e178d7c37bd" translate="yes" xml:space="preserve">
          <source>The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.</source>
          <target state="translated">在SQLite 3.16.0版本(2017-01-02)中增加了PRAGMA的表值函数功能。之前版本的SQLite不能使用该功能。</target>
        </trans-unit>
        <trans-unit id="273bdbb137f334009fcac2c6deba9c8d09edc07d" translate="yes" xml:space="preserve">
          <source>The tableZ table has a single column named &quot;INTEGER&quot;. That column has no datatype specified, but it is the PRIMARY KEY. The column is &lt;em&gt;not&lt;/em&gt; the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for the table because it has no datatype. The &quot;INTEGER&quot; token is used as an identifier for the column name, not as a datatype keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1296ca23d366e0c8b6ad53b34a86a007a9e6fcba" translate="yes" xml:space="preserve">
          <source>The tables necessary to do full and proper unicode case folding are larger than the whole SQLite library.</source>
          <target state="translated">做完整和正确的unicode大小写折叠所需的表比整个SQLite库还要大。</target>
        </trans-unit>
        <trans-unit id="1fa68f636ed5379e184e8d386d825c36877f4a63" translate="yes" xml:space="preserve">
          <source>The tables that participate in a union-vtab can be in the same database file, or they can be in separate databases files that are &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to the same database connection.</source>
          <target state="translated">参与union-vtab的表可以位于同一数据库文件中，也可以位于已&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;到同一数据库连接的单独数据库文件中。</target>
        </trans-unit>
        <trans-unit id="30590c6f42ddca035bfcfa04a6fd54a5c5428cad" translate="yes" xml:space="preserve">
          <source>The target database may already contain a row with the same PRIMARY KEY values as specified by the INSERT change.</source>
          <target state="translated">目标数据库可能已经包含了一条与INSERT更改所指定的PRIMARY KEY值相同的记录。</target>
        </trans-unit>
        <trans-unit id="ddffb3a24b55dea30b114ff8f89840fe90c8c752" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the current values of the fields that will be modified by the change may not match the original values stored within the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">目标数据库可能包含一条具有指定PRIMARY KEY值的记录,但将被修改的字段的当前值可能与存储在更改集中的原始值不匹配。这种类型的冲突在使用补丁集时不会被检测到。</target>
        </trans-unit>
        <trans-unit id="9637f3da3aa12d5bcfe7a6adc7e68c320df396f3" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the other fields may contain values that do not match those stored as part of the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">目标数据库可能包含一条具有指定的PRIMARY KEY值的行,但其他字段可能包含的值与作为变化集的一部分存储的值不匹配。当使用补丁集时,这种类型的冲突不会被检测到。</target>
        </trans-unit>
        <trans-unit id="11c37f0367cfc6691a61d3fba7a936ab62a7d348" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to delete.</source>
          <target state="translated">目标数据库中可能没有包含指定PRIMARY KEY值的记录要删除。</target>
        </trans-unit>
        <trans-unit id="e2b06a833985a4c35aa0208799ae843a7b65a575" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to modify.</source>
          <target state="translated">目标数据库中可能没有包含指定PRIMARY KEY值的记录要修改。</target>
        </trans-unit>
        <trans-unit id="6f87cac991eff302d9976172f7bdf73e926bb9c2" translate="yes" xml:space="preserve">
          <source>The target database may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">目标数据库可能未处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e79db16e64c18b69803344025e269d729d3745a5" translate="yes" xml:space="preserve">
          <source>The target table is not included in the FROM clause, unless the intent is to do a self-join against the target table. In the event of a self-join, the table in the FROM clause must be aliased to a different name than the target table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711e958f26b3fdef5ca444454f4ee0f963fc86d6" translate="yes" xml:space="preserve">
          <source>The task of the &quot;query planner&quot; is to figure out the best algorithm or &quot;query plan&quot; to accomplish an SQL statement. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), the query planner component has been rewritten so that it runs faster and generates better plans. The rewrite is called the &quot;next generation query planner&quot; or &quot;NGQP&quot;.</source>
          <target state="translated">&amp;ldquo;查询计划器&amp;rdquo;的任务是找出完成SQL语句的最佳算法或&amp;ldquo;查询计划&amp;rdquo;。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;版本3.8.0&lt;/a&gt;（2013-08-26）开始，查询计划程序组件已被重写，以使其运行速度更快并生成更好的计划。重写称为&amp;ldquo;下一代查询计划程序&amp;rdquo;或&amp;ldquo; NGQP&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="42a7ae31a25e761d6c699099d742c17f30af41a6" translate="yes" xml:space="preserve">
          <source>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</source>
          <target state="translated">team_id字段不能是唯一的,因为通常在同一个团队中有多个人。我们不能让team_id和is_team_leader的组合成为唯一,因为每个团队中通常有多个非领导者。强制每个团队只有一个领导者的解决方案是在team_id上创建一个唯一的索引,但仅限于那些is_team_leader为真的条目。</target>
        </trans-unit>
        <trans-unit id="0785e2dbbfabdba0d3916b209d305b3e5683f44f" translate="yes" xml:space="preserve">
          <source>The technique of having xFindFunction() return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; was initially used in the implementation of the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;. The xFindFunction() method of that module returns SQLITE_INDEX_CONSTRAINT_FUNCTION for the &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap()&lt;/a&gt; SQL function and it returns SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within()&lt;/a&gt; SQL function. This permits search optimizations for queries such as:</source>
          <target state="translated">最初在&lt;a href=&quot;geopoly&quot;&gt;Geopoly模块&lt;/a&gt;的实现中使用了具有xFindFunction（）返回值&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;的技术。该模块返回SQLITE_INDEX_CONSTRAINT_FUNCTION为的xFindFunction（）方法&lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap（）&lt;/a&gt; SQL函数，并将其返回SQLITE_INDEX_CONSTRAINT_FUNCTION + 1为&lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within（）&lt;/a&gt; SQL函数。这允许对查询进行搜索优化，例如：</target>
        </trans-unit>
        <trans-unit id="2710792de033b547bac6e441ea1f9b9d8e9fc431" translate="yes" xml:space="preserve">
          <source>The temp.sqlite_parameters table only provides values for parameters in the command-line shell. The temp.sqlite_parameter table has no effect on queries that are run directly using the SQLite C-language API. Individual applications are expected to implement their own parameter binding. You can search for &quot;sqlite_parameters&quot; in the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;command-line shell source code&lt;/a&gt; to see how the command-line shell does parameter binding, and use that as a hint for how to implement it yourself.</source>
          <target state="translated">temp.sqlite_parameters表仅提供命令行外壳程序中参数的值。temp.sqlite_parameter表对直接使用SQLite C语言API运行的查询无效。各个应用程序应实现自己的参数绑定。您可以在&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;命令行外壳程序源代码中&lt;/a&gt;搜索&amp;ldquo; sqlite_parameters&amp;rdquo;，以查看命令行外壳程序如何进行参数绑定，并将其用作如何自己实现的提示。</target>
        </trans-unit>
        <trans-unit id="e0243e43a9e092811e1870e88e873ed47024b50d" translate="yes" xml:space="preserve">
          <source>The temporary file created by the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command exists only for the duration of the command itself. The size of the temporary file will be no larger than the original database.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令创建的临时文件仅在命令本身存在期间存在。临时文件的大小将不大于原始数据库。</target>
        </trans-unit>
        <trans-unit id="2f2df5fab6b729ca7d2c3e78798e53760ca0b74f" translate="yes" xml:space="preserve">
          <source>The temporary files associated with the TEMP database and its rollback journal are only created if the application makes use of the &quot;CREATE TEMP TABLE&quot; statement.</source>
          <target state="translated">只有当应用程序使用 &quot;CREATE TEMP TABLE &quot;语句时,才会创建与TEMP数据库及其回滚日志相关的临时文件。</target>
        </trans-unit>
        <trans-unit id="f07c39bdad21f0453b3d046fa930925221ebb2c1" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, master journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, master, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">与事务控制关联的临时文件（即回滚日志，主日志，预写日志（WAL）文件和共享内存文件）始终写入磁盘。但是其他类型的临时文件可能只存储在内存中，而不会写入磁盘。除回滚，主日志和语句日志以外的临时文件是否写入磁盘或仅存储在内存中取决于&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数，&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;和临时文件的大小。</target>
        </trans-unit>
        <trans-unit id="408ca6d25d3ec064e51ba766d2fa74811ccbfcc3" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, super-journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, super, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ee5d948678f086d276ab61d7dad5de2797f6e5" translate="yes" xml:space="preserve">
          <source>The term number of the matching term within the full-text query expression. Terms within a query expression are numbered starting from 0 in the order that they occur.</source>
          <target state="translated">全文查询表达式中匹配术语的术语号。查询表达式中的术语按其出现的顺序从0开始编号。</target>
        </trans-unit>
        <trans-unit id="2146ad4958dfdca7b01896ef7e97e3c556f6bfc0" translate="yes" xml:space="preserve">
          <source>The term, as stored in the FTS5 index.</source>
          <target state="translated">术语,存储在快三平台5指数中。</target>
        </trans-unit>
        <trans-unit id="efaf8ed4fd273fae5234c31a87ca20e1f921ce05" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">术语&amp;ldquo;受保护&amp;rdquo;和&amp;ldquo;不受保护&amp;rdquo;是指是否持有互斥体。对于受保护的sqlite3_value对象，将保留内部互斥锁，但对于不受保护的sqlite3_value对象，将不保留互斥锁。如果将SQLite编译为单线程（&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;且&lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回0），或者如果SQLite在简化互斥模式&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;或&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;之一中运行，则受保护和不受保护的sqlite3_value对象之间没有区别，它们可以可以互换使用。但是，为了获得最大的代码可移植性，即使没有严格要求，建议应用程序仍应区分受保护的sqlite3_value对象和不受保护的sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="9b59119835d0c98638847083b9be8651dcfed7b3" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">术语&amp;ldquo;受保护&amp;rdquo;和&amp;ldquo;不受保护&amp;rdquo;是指是否持有互斥体。对于受保护的sqlite3_value对象，将保留内部互斥锁，但对于不受保护的sqlite3_value对象，将不保留互斥锁。如果将SQLite编译为单线程（&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;且&lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回0），或者如果SQLite在简化互斥模式&lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;或&lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;之一中运行，则受保护和不受保护的sqlite3_value对象之间没有区别，它们可以可以互换使用。但是，为了获得最大的代码可移植性，即使没有严格要求，建议应用程序仍应区分受保护的sqlite3_value对象和不受保护的sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="d0d8bb329a3e29ad5aa4a494be22dcdfc57447c5" translate="yes" xml:space="preserve">
          <source>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term &quot;b=6&quot; does not match &quot;b=3+3&quot; or &quot;b-6=0&quot; or &quot;b BETWEEN 6 AND 6&quot;. &quot;b=6&quot; will match to &quot;6=b&quot; as long as &quot;b=6&quot; is on the index and &quot;6=b&quot; is in the query. If a term of the form &quot;6=b&quot; appears in the index, it will never match anything.</source>
          <target state="translated">W和X中的术语必须完全匹配。SQLite不做代数来尝试让它们看起来一样。术语 &quot;b=6 &quot;不匹配 &quot;b=3+3 &quot;或 &quot;b-6=0 &quot;或 &quot;b BETWEEN 6 AND 6&quot;。&quot;b=6 &quot;将与 &quot;6=b &quot;匹配,只要 &quot;b=6 &quot;在索引中,&quot;6=b &quot;在查询中。如果在索引中出现 &quot;6=b &quot;形式的术语,它将永远不会匹配任何东西。</target>
        </trans-unit>
        <trans-unit id="1a91aabb1ee8a98e3573519dc568a9cdcf09f371" translate="yes" xml:space="preserve">
          <source>The test infrastructure verifies that SQLite does not misuse dynamically allocated memory by using a specially instrumented memory allocator. The instrumented memory allocator is enabled at compile-time using the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; option. The instrumented memory allocator is much slower than the default memory allocator and so its use is not recommended in production. But when enabled during testing, the instrumented memory allocator performs the following checks:</source>
          <target state="translated">测试基础结构通过使用专门检测的内存分配器来验证SQLite不会滥用动态分配的内存。在编译时使用&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;选项启用检测的内存分配器。检测的内存分配器比默认的内存分配器慢得多，因此不建议在生产中使用它。但是，在测试过程中启用该功能后，检测的内存分配器将执行以下检查：</target>
        </trans-unit>
        <trans-unit id="23d89111adcbe2ab0ff1f685425a6f5892695526" translate="yes" xml:space="preserve">
          <source>The test suite is designed to be run three times, once for each of the ALWAYS() and NEVER() definitions shown above. All three test runs should yield exactly the same result. There is a run-time test using the &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;, ...) interface that can be used to verify that the macros are correctly set to the first form (the pass-through form) for deployment.</source>
          <target state="translated">该测试套件设计为可以运行3次，对于上面显示的每个ALWAYS（）和NEVER（）定义一次。所有三个测试运行应产生完全相同的结果。使用&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;，...）接口进行了运行时测试，可用于验证宏是否正确设置为用于部署的第一种形式（传递形式）。</target>
        </trans-unit>
        <trans-unit id="77fbf4494f9eeac6c3dd3e8030fecebddc25654d" translate="yes" xml:space="preserve">
          <source>The test suites for SQLite also explore the result of stacking multiple failures. For example, tests are run to ensure correct behavior when an I/O error or OOM fault occurs while trying to recover from a prior crash.</source>
          <target state="translated">SQLite的测试套件还探索了堆叠多个故障的结果。例如,当发生I/O错误或OOM故障时,在试图从先前的崩溃中恢复时,会运行测试以确保正确的行为。</target>
        </trans-unit>
        <trans-unit id="a7eb514323fac72f4df40162cf2fb7ca6826d6f1" translate="yes" xml:space="preserve">
          <source>The test1.dir directory will contain 100,000 files with names like &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot; and so forth but the test1.tree directory will contain the same files in subdirectories like &quot;00/00/00&quot;, &quot;00/00/01&quot;, and so on. The test1.dir and test1.test directories take up approximately the same amount of space, though test1.test is very slightly larger due to the extra directory entries.</source>
          <target state="translated">test1.dir目录将包含100,000个文件,名称为 &quot;0000&quot;、&quot;000001&quot;、&quot;000002 &quot;等,但test1.tree目录将在 &quot;00/00/00&quot;、&quot;00/00/01 &quot;等子目录中包含相同的文件。test1.dir和test1.test目录占用的空间大致相同,不过test1.test由于多了一个目录项,所以占的空间非常小。</target>
        </trans-unit>
        <trans-unit id="833841004a13aff638c7a47f3f35a8f25f41ac0a" translate="yes" xml:space="preserve">
          <source>The test_async.c drive now does full file locking and works correctly when used simultaneously by multiple processes on the same database.</source>
          <target state="translated">test_async.c驱动器现在可以进行完全的文件锁定,并且在同一数据库上的多个进程同时使用时可以正常工作。</target>
        </trans-unit>
        <trans-unit id="eb420a5e9808216cc66d2c072d0472129ab690a9" translate="yes" xml:space="preserve">
          <source>The testcase() macro is often used to verify that boundary cases of an inequality comparison are checked. For example, at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;. These kind of checks help to prevent off-by-one errors.</source>
          <target state="translated">testcase（）宏通常用于验证是否检查了不等式比较的边界情况。例如，在&lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;。这些检查有助于防止一次遗漏的错误。</target>
        </trans-unit>
        <trans-unit id="bfd50a8b5d17dc1d197a2f0aeffde22600cc3d5e" translate="yes" xml:space="preserve">
          <source>The testcase(X) macro is normally a no-op, but for a coverage test build it does generate a small amount of extra code that includes at least one branch, in order to verify that test cases exist for which X is both true and false.</source>
          <target state="translated">testcase(X)宏通常是没有操作的,但对于覆盖测试构建来说,它确实会产生少量额外的代码,其中包括至少一个分支,以验证是否存在测试用例,其中 X 既是真也是假。</target>
        </trans-unit>
        <trans-unit id="198025ed4b90dd540b423fcfb30efac73a9076a6" translate="yes" xml:space="preserve">
          <source>The testing process for SQLite is described in the &lt;a href=&quot;testing&quot;&gt;testing&lt;/a&gt; document. Testing objectives include:</source>
          <target state="translated">&lt;a href=&quot;testing&quot;&gt;测试&lt;/a&gt;文档中描述了SQLite的测试过程。测试目标包括：</target>
        </trans-unit>
        <trans-unit id="7f341b9da6892f9f513eb1e23029aaad7d1945bb" translate="yes" xml:space="preserve">
          <source>The testing process is controlled by the &lt;a href=&quot;testing#cklist&quot;&gt;release testing checklists&lt;/a&gt;. The checklists succinctly summary all steps necessary to fully validate SQLite, and they record when and by whom each validation step was performed.</source>
          <target state="translated">测试过程由&lt;a href=&quot;testing#cklist&quot;&gt;发布测试清单控制&lt;/a&gt;。清单简要总结了全面验证SQLite所需的所有步骤，并记录了执行每个验证步骤的时间和对象。</target>
        </trans-unit>
        <trans-unit id="b10a0b7612e25fb69c97ba29101b2f64b4a7581b" translate="yes" xml:space="preserve">
          <source>The text format is pure SQL so you can also use the .dump command to export an SQLite database into other popular SQL database engines. Like this:</source>
          <target state="translated">文本格式是纯SQL,所以你也可以使用.dump命令将SQLite数据库导出到其他流行的SQL数据库引擎中。像这样。</target>
        </trans-unit>
        <trans-unit id="002ca6dfea0de9e1d73a68077f123004fa9755de" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_master.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_master.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_master.sql列中的文本是创建对象的原始CREATE语句文本的副本，但如上所述和通过后续&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;语句进行了修改的规范除外。对于由&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束自动创建的&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部索引&lt;/a&gt;，sqlite_master.sql为NULL 。</target>
        </trans-unit>
        <trans-unit id="df540746bab5e3cce21edce12d96e726e4a223e9" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_schema.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_schema.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3362b59e42a116b494bb787cf561f00b28111a39" translate="yes" xml:space="preserve">
          <source>The text of query parameters is appended to the filename argument of the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Any %HH escape sequences in the query parameters are resolved prior to being appended to the xOpen filename. A single zero-byte separates the xOpen filename argument from the key of the first query parameters, each key and value, and each subsequent key from the prior value. The list of query parameters appended to the xOpen filename is terminated by a single zero-length key. Note that the value of a query parameter can be an empty string.</source>
          <target state="translated">查询参数的文本附加到&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xOpen方法的filename参数中。查询参数中的任何％HH转义序列都必须先解析，然后才能附加到xOpen文件名。单个零字节将xOpen文件名参数与第一个查询参数的键，每个键和值以及每个后续键与先前值分开。附加到xOpen文件名的查询参数列表由单个零长度键终止。请注意，查询参数的值可以是空字符串。</target>
        </trans-unit>
        <trans-unit id="f010a4aeda05a6fff949d6b23c4d99edd507a5b9" translate="yes" xml:space="preserve">
          <source>The text of the word that matches the pattern. Both word and pattern can contain unicode characters and can be mixed case.</source>
          <target state="translated">匹配模式的单词的文本。词和模式都可以包含unicode字符,也可以混合大小写。</target>
        </trans-unit>
        <trans-unit id="34ac3915c6fa697bff1880701cc84fcf41ef0614" translate="yes" xml:space="preserve">
          <source>The text to add to the start or end of the selected text to indicate that the returned text does not occur at the start or end of its column, respectively.</source>
          <target state="translated">要在所选文本的开头或结尾处添加的文字,以分别表示返回的文本不出现在其列的开头或结尾处。</target>
        </trans-unit>
        <trans-unit id="5d227441e585adc9dccb7fd5119a447b09eeb780" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match within the returned text.</source>
          <target state="translated">在返回的文本中,每个短语匹配后插入的文本。</target>
        </trans-unit>
        <trans-unit id="c372789c27ae2ac063bb79f99aab7639b81bdf47" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match.</source>
          <target state="translated">在每个短语匹配后插入的文字。</target>
        </trans-unit>
        <trans-unit id="98deed99ebb119a4eabb19891d9d80c8f6d99766" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match within the returned text.</source>
          <target state="translated">在返回的文本中,每个短语匹配之前插入的文本。</target>
        </trans-unit>
        <trans-unit id="011020fd80da1d64051ffd57ff7d4f9db6949595" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match.</source>
          <target state="translated">在每个短语匹配前插入的文字。</target>
        </trans-unit>
        <trans-unit id="41db7390257d3e1c83cfe7262fbe75efa4098374" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 140 terabytes will be reached first. A 140 terabytes database can hold no more than approximately 1e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">表中的理论最大行数为2 &lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt;（18446744073709551616或大约1.8e + 19）。由于将首先达到140 TB的最大数据库大小，因此无法达到此限制。一个140 TB的数据库最多可以容纳大约1e + 13行，然后仅在没有索引且每行包含的数据很少的情况下才可以。</target>
        </trans-unit>
        <trans-unit id="9c469d0a6dd7814f8f536d83dd0c0d4f9236b847" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 281 terabytes will be reached first. A 281 terabytes database can hold no more than approximately 2e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e681320a770693ff8880c2fe787c3d46c58d6fe" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">这些例程可能会尝试转换结果的数据类型。例如，如果内部表示形式为FLOAT并请求文本结果，则内部使用&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;自动执行转换。下表详细介绍了应用的转换：</target>
        </trans-unit>
        <trans-unit id="d45ababe332de0d6a9b7d204a8229a091726f141" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">这些例程可能会尝试转换结果的数据类型。例如，如果内部表示形式为FLOAT并请求文本结果，则内部使用&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;自动执行转换。下表详细介绍了应用的转换：</target>
        </trans-unit>
        <trans-unit id="f29b8fd84fbcfd59fccde21c2067cc383b5612cf" translate="yes" xml:space="preserve">
          <source>The third and fourth parameters to this function are the table and column name of the desired column, respectively.</source>
          <target state="translated">该函数的第三个和第四个参数分别是所需列的表和列名。</target>
        </trans-unit>
        <trans-unit id="5dad7ccfb7adf02e60a4718cd1bfaf6cc7ad8094" translate="yes" xml:space="preserve">
          <source>The third argument (eTextRep) must be one of the constants:</source>
          <target state="translated">第三个参数(eTextRep)必须是常量之一。</target>
        </trans-unit>
        <trans-unit id="a12fbbce4ea7f98c6f3257e48e8cfdd9d6a7f402" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null().</source>
          <target state="translated">第三个参数是要绑定到参数的值。如果sqlite3_bind_text()或sqlite3_bind_text16()或sqlite3_bind_blob()的第三个参数是一个NULL指针,那么第四个参数将被忽略,最终结果与sqlite3_bind_null()相同。</target>
        </trans-unit>
        <trans-unit id="cfd2994dc5175da09229d952b2be33f11c05e0da" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null(). If the third parameter to sqlite3_bind_text() is not NULL, then it should be a pointer to well-formed UTF8 text. If the third parameter to sqlite3_bind_text16() is not NULL, then it should be a pointer to well-formed UTF16 text. If the third parameter to sqlite3_bind_text64() is not NULL, then it should be a pointer to a well-formed unicode string that is either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8896799f29c2adcd495a7004a3dfd8ef2c595b55" translate="yes" xml:space="preserve">
          <source>The third argument to the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;,...) interface (the &quot;pData&quot; argument in the example above) is a pointer to arbitrary data. SQLite passes this pointer through to the first argument of the error logger callback. The pointer can be used to pass application-specific setup or state information, if desired. Or it can simply be a NULL pointer which is ignored by the callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;，...）接口的第三个参数（上面示例中的&amp;ldquo; pData&amp;rdquo;参数）是指向任意数据的指针。 SQLite将此指针传递到错误记录器回调的第一个参数。如果需要，该指针可用于传递特定于应用程序的设置或状态信息。或者它可以只是一个NULL指针，回调会忽略它。</target>
        </trans-unit>
        <trans-unit id="8e80d3a19f53ad5c94b48f6b4deace1bd8cd6a01" translate="yes" xml:space="preserve">
          <source>The third chart shows that reading blob content out of SQLite can be twice as fast as reading from individual files on disk for Mac and Android, and an amazing ten times faster for Windows.</source>
          <target state="translated">第三张图显示,对于Mac和Android来说,从SQLite中读取blob内容的速度是从磁盘上的单个文件中读取的速度的两倍,对于Windows来说则是惊人的十倍。</target>
        </trans-unit>
        <trans-unit id="ce81cfaf801aa960a0d4e258e6f72c47aaf642db" translate="yes" xml:space="preserve">
          <source>The third column is the minimum value for any rowid in the table.</source>
          <target state="translated">第三列是表中任何rowid的最小值。</target>
        </trans-unit>
        <trans-unit id="66b245a2c0333e9c6e002eaadabc21caae3f20aa" translate="yes" xml:space="preserve">
          <source>The third form of an INSERT statement is with DEFAULT VALUES. The INSERT ... DEFAULT VALUES statement inserts a single new row into the named table. Each column of the new row is populated with its &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt;, or with a NULL if no default value is specified as part of the column definition in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is not supported after DEFAULT VALUES.</source>
          <target state="translated">INSERT语句的第三种形式是带有DEFAULT VALUES。 INSERT ... DEFAULT VALUES语句将单个新行插入到命名表中。新行的每一列均填充有其&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认值&lt;/a&gt;，如果&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中的列定义未指定默认值，则填充NULL 。该&lt;a href=&quot;syntax/upsert-clause&quot;&gt;UPSERT子句&lt;/a&gt; DEFAULT值之后不被支持。</target>
        </trans-unit>
        <trans-unit id="80211bcbcab262c368d4da63de6e8f61d55d7f66" translate="yes" xml:space="preserve">
          <source>The third line of the example shows the virtual table being used, to read all content of the CSV file. This is perhaps the simplest possible use of the virtual table. The CSV virtual table can be used anywhere an ordinary virtual table can be used. One can use the CSV virtual table inside subqueries, or &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT clauses as required.</source>
          <target state="translated">该示例的第三行显示了正在使用的虚拟表，用于读取CSV文件的所有内容。这可能是对虚拟表的最简单的使用。可以在可以使用普通虚拟表的任何地方使用CSV虚拟表。可以在子查询或&lt;a href=&quot;lang_with&quot;&gt;公共表表达式中&lt;/a&gt;使用CSV虚拟表，也可以根据需要添加WHERE，GROUP BY，HAVING，ORDER BY和LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="37d0f732f75ffbc9298be10c6e109dfc37fa5d4b" translate="yes" xml:space="preserve">
          <source>The third number Z is incremented for releases consisting of only small changes that implement performance enhancements and/or bug fixes.</source>
          <target state="translated">第三个数字Z是递增的,因为发布的版本只包含小的变化,实现了性能增强和/或错误修复。</target>
        </trans-unit>
        <trans-unit id="d43fa02ec7a69fa0b5cb4656ab69a4413a6918c8" translate="yes" xml:space="preserve">
          <source>The third optimization, zeroing the journal file header rather than deleting the rollback journal file, does not depend on holding an exclusive lock at all times. This optimization can be set independently of exclusive lock mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; as described in &lt;a href=&quot;#section_7_6&quot;&gt;section 7.6&lt;/a&gt; below.</source>
          <target state="translated">第三种优化是将日志文件头清零而不是删除回滚日志文件，这并不取决于始终保持互斥锁。可以使用&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode杂注&lt;/a&gt;独立于独占锁定模式进行设置，如以下&lt;a href=&quot;#section_7_6&quot;&gt;7.6节&lt;/a&gt;所述。</target>
        </trans-unit>
        <trans-unit id="226219f131eebb1bb82e3a9e80c20160ef9e49d4" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">第三个参数（nArg）是SQL函数或聚合采用的参数数量。如果此参数为-1，则SQL函数或聚合可以接受介于0和&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;）设置的限制之间的任意数量的参数。如果第三个参数小于-1或大于127，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="11f56952c8e04a9269627afb8274637d6b360ea2" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">第三个参数（nArg）是SQL函数或聚合采用的参数数量。如果此参数为-1，则SQL函数或聚合可以接受介于0和&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;）设置的限制之间的任意数量的参数。如果第三个参数小于-1或大于127，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="7effa7c199d796ec9c7957d5b06f69295ac44ef2" translate="yes" xml:space="preserve">
          <source>The third step starts with the four shortest two-node paths and finds the four shortest three-node paths:</source>
          <target state="translated">第三步从四个最短的两节点路径开始,找到四个最短的三节点路径。</target>
        </trans-unit>
        <trans-unit id="97390ca779620e87876318d53cdbb5c0eb4c1782" translate="yes" xml:space="preserve">
          <source>The threading mode can be selected at compile-time (when the SQLite library is being compiled from source code) or at start-time (when the application that intends to use SQLite is initializing) or at run-time (when a new SQLite database connection is being created). Generally speaking, run-time overrides start-time and start-time overrides compile-time. Except, single-thread mode cannot be overridden once selected.</source>
          <target state="translated">线程模式可以在编译时(当SQLite库正在从源代码编译时)或启动时(当打算使用SQLite的应用程序正在初始化时)或运行时(当正在创建一个新的SQLite数据库连接时)选择。一般来说,运行时优先于启动时,启动时优先于编译时。只不过,单线程模式一旦选择,就不能被覆盖。</target>
        </trans-unit>
        <trans-unit id="7a0e198fd0423256115863d78eac9cac1343e176" translate="yes" xml:space="preserve">
          <source>The threading mode for an individual database connection is determined by flags given as the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag causes the database connection to be in the multi-thread mode and the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag causes the connection to be in serialized mode. If neither flag is specified or if &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; are used instead of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, then the default mode determined by the compile-time and start-time settings is used.</source>
          <target state="translated">单个数据库连接的线程模式由作为&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的第三个参数给出的标志确定。所述&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;标志导致数据库连接是在多线程模式和&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;标志使是在串行化模式的连接。如果未指定任何标志，或者使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;代替&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;，则使用由编译时和启动时设置确定的默认模式。</target>
        </trans-unit>
        <trans-unit id="a70f1f8b6fb5520108a2b27f649a3322d3c256dc" translate="yes" xml:space="preserve">
          <source>The three auxiliary functions are only useful within a SELECT statement that uses the FTS table's full-text index. If used within a SELECT that uses the &quot;query by rowid&quot; or &quot;linear scan&quot; strategies, then the snippet and offsets both return an empty string, and the matchinfo function returns a blob value zero bytes in size.</source>
          <target state="translated">这三个辅助函数只在使用FTS表的全文索引的SELECT语句中有用。如果在使用 &quot;按rowid查询 &quot;或 &quot;线性扫描 &quot;策略的SELECT内使用,那么snippet和offsets都返回一个空字符串,matchinfo函数返回一个大小为0字节的blob值。</target>
        </trans-unit>
        <trans-unit id="6eb0a1f7b89a823f8bdbde0d13568a18262e614a" translate="yes" xml:space="preserve">
          <source>The three basic query types described above may be used to query the full-text index for the set of documents that match the specified criteria. Using the FTS query expression language it is possible to perform various set operations on the results of basic queries. There are currently three supported operations:</source>
          <target state="translated">上述三种基本查询类型可以用来查询全文索引中符合指定标准的文档集。利用FTS查询表达式语言,可以对基本查询的结果进行各种集合操作。目前支持的操作有三种。</target>
        </trans-unit>
        <trans-unit id="7097964beca5dc252968954049e7c0946f78e4a9" translate="yes" xml:space="preserve">
          <source>The three leftmost columns of a zipfile virtual table, &quot;name&quot;, &quot;mode&quot; and &quot;mtime&quot;, may each be set to any value that may be inserted into the same column (see above). If either &quot;mode&quot; or &quot;mtime&quot; is set to NULL, the final value is determined as described for an INSERT of a NULL value - the current time for &quot;mtime&quot; and either 33188 or 16877 for &quot;mode&quot;, depending on whether or not the values specified for the next four columns of the zipfile table indicate that the entry is a directory or a file.</source>
          <target state="translated">zipfile虚拟表最左边的三列,&quot;name&quot;、&quot;mode &quot;和 &quot;mtime&quot;,可以分别设置为任何可以插入到同一列的值(见上文)。如果 &quot;mode &quot;或 &quot;mtime &quot;被设置为NULL,那么最终的值将被确定为一个NULL值的INSERT--&quot;mtime &quot;为当前时间,&quot;mode &quot;为33188或16877,这取决于为zipfile表的后面四列指定的值是否表明该条目是一个目录或文件。</target>
        </trans-unit>
        <trans-unit id="3411dedba6408ea6c13a17f75aea9b87b7d91fad" translate="yes" xml:space="preserve">
          <source>The time string can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="translated">时间字符串后面可以跟着零个或多个修改器,以改变日期和/或时间。每个修饰符都是应用于其左边的时间值的转换。修饰符从左到右应用,顺序很重要。可用的修饰符如下。</target>
        </trans-unit>
        <trans-unit id="30024a74e5aefa6cc166b0948a8f34eea1be4641" translate="yes" xml:space="preserve">
          <source>The time taken to execute each virtual machine operation can vary based on many factors. A typical value for a 1 GHz PC is between half and three million per second but may be much higher or lower, depending on the query. As such it is difficult to schedule background operations based on virtual machine operations. Instead, it is recommended that a callback be scheduled relatively frequently (say every 1000 instructions) and external timer routines used to determine whether or not background jobs need to be run.</source>
          <target state="translated">执行每个虚拟机操作所需的时间会根据许多因素而变化。1 GHz PC的典型值是每秒50万到300万之间,但根据查询情况,可能会高得多或低得多。因此,很难根据虚拟机操作来安排后台操作。相反,建议相对频繁地调度回调(例如每1000条指令),并使用外部定时器例程来确定是否需要运行后台作业。</target>
        </trans-unit>
        <trans-unit id="d31d23c9c6ce92ba1161f4e9fe89ef4c4bc1cceb" translate="yes" xml:space="preserve">
          <source>The times reported on all tests represent wall-clock time in seconds. Two separate time values are reported for SQLite. The first value is for SQLite in its default configuration with full disk synchronization turned on. With synchronization turned on, SQLite executes an &lt;b&gt;fsync()&lt;/b&gt; system call (or the equivalent) at key points to make certain that critical data has actually been written to the disk drive surface. Synchronization is necessary to guarantee the integrity of the database if the operating system crashes or the computer powers down unexpectedly in the middle of a database update. The second time reported for SQLite is when synchronization is turned off. With synchronization off, SQLite is sometimes much faster, but there is a risk that an operating system crash or an unexpected power failure could damage the database. Generally speaking, the synchronous SQLite times are for comparison against PostgreSQL (which is also synchronous) and the asynchronous SQLite times are for comparison against the asynchronous MySQL engine.</source>
          <target state="translated">所有测试报告的时间代表以秒为单位的挂钟时间。对于SQLite，报告了两个单独的时间值。第一个值是在默认配置下启用了全磁盘同步的SQLite。启用同步后，SQLite执行&lt;b&gt;fsync（）&lt;/b&gt;在关键点进行系统调用（或等效的调用），以确保已将关键数据实际写入磁盘驱动器表面。如果操作系统崩溃或在数据库更新过程中计算机意外断电，则必须进行同步以确保数据库的完整性。对于SQLite的第二次报告是关闭同步。关闭同步后，SQLite有时会快得多，但是存在操作系统崩溃或意外电源故障可能损坏数据库的风险。一般而言，同步SQLite时间用于与PostgreSQL（也是同步的）进行比较，异步SQLite时间用于与异步MySQL引擎进行比较。</target>
        </trans-unit>
        <trans-unit id="0fc05e4c39e5e71215073020483f372e45a3d893" translate="yes" xml:space="preserve">
          <source>The total amount of free space on a b-tree page consists of the size of the unallocated region plus the total size of all freeblocks plus the number of fragmented free bytes. SQLite may from time to time reorganize a b-tree page so that there are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated space region, and all cells are packed tightly at the end of the page. This is called &quot;defragmenting&quot; the b-tree page.</source>
          <target state="translated">b-tree页面上的自由空间总量由未分配区域的大小加上所有自由块的总大小加上碎片自由字节的数量组成。SQLite可能会不时地重组b-tree页面,以便没有自由块或碎片字节,所有未使用的字节都包含在未分配的空间区域中,并且所有单元格都被紧紧地包装在页面的最后。这就是所谓的b树页的 &quot;碎片化&quot;。</target>
        </trans-unit>
        <trans-unit id="460e85c11483674a3089f1a062d5d6ad1f387294" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term in the entire FTS5 table.</source>
          <target state="translated">该术语在整个FTS5表中的总实例数。</target>
        </trans-unit>
        <trans-unit id="8456fd817ff013feb889e3e84d49e1da8d0b8117" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term that appear in column $col of the FTS5 table (considering all rows).</source>
          <target state="translated">在FTS5表中$col列中出现的术语实例总数(考虑到所有行)。</target>
        </trans-unit>
        <trans-unit id="8b23a01c6d0371374c2abef2c4b0a82ba4134902" translate="yes" xml:space="preserve">
          <source>The total number of pages in the btree for the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6d24f273b69a04a7a37a510d51811f2500b867" translate="yes" xml:space="preserve">
          <source>The total number of rows in the FTS table for which the column contains at least one instance of the phrase.</source>
          <target state="translated">FTS表中该列至少包含一个短语实例的总行数。</target>
        </trans-unit>
        <trans-unit id="36827e0806ceb5dc326cee16a98d2a59022e566e" translate="yes" xml:space="preserve">
          <source>The total number of times the phrase appears in the column in all rows in the FTS table.</source>
          <target state="translated">该短语在FTS表中所有行的列中出现的总次数。</target>
        </trans-unit>
        <trans-unit id="cf5b068f292efb4fb2def2e783aac8fbf8f0464d" translate="yes" xml:space="preserve">
          <source>The total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">自打开当前数据库连接以来，total_changes（）函数返回由INSERT，UPDATE或DELETE语句引起的行更改数。该函数是&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; C / C ++接口的包装。</target>
        </trans-unit>
        <trans-unit id="e56b60d01d475c54e2abcd03a315a64862d2471f" translate="yes" xml:space="preserve">
          <source>The traditional rollback journal works by writing a copy of the original unchanged database content into a separate rollback journal file and then writing changes directly into the database file. In the event of a crash or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, the original content contained in the rollback journal is played back into the database file to revert the database file to its original state. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when the rollback journal is deleted.</source>
          <target state="translated">传统的回滚日志的工作方式是将原始未更改的数据库内容的副本写入单独的回滚日志文件，然后将更改直接写入数据库文件。在发生崩溃或&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK的情况下&lt;/a&gt;，回滚日志中包含的原始内容将被回放到数据库文件中，以将数据库文件还原为原始状态。该&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;当回滚日志被删除时。</target>
        </trans-unit>
        <trans-unit id="fa45945065730186850cef64d952ee165c9cc090" translate="yes" xml:space="preserve">
          <source>The traditional way of communicating this information was to transform a C-language pointer into a BLOB or a 64-bit integer, then move that BLOB or integer through SQLite using the usual interfaces like &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt; or the integer equivalents.</source>
          <target state="translated">传达此信息的传统方式是将C语言指针转换为BLOB或64位整数，然后使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob（）&lt;/a&gt;，&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob（）&lt;/a&gt;，&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob（）&lt;/a&gt;或常规接口通过SQLite通过SQLite移动该BLOB或整数整数等效项。</target>
        </trans-unit>
        <trans-unit id="c2d0f49e1ec0a4672583f25736f97bcbd3e6ba07" translate="yes" xml:space="preserve">
          <source>The transaction command can be used to group together several SQLite commands in a safe way. You can always start transactions manually using BEGIN, of course. But if an error occurs so that the COMMIT or ROLLBACK are never run, then the database will remain locked indefinitely. Also, BEGIN does not nest, so you have to make sure no other transactions are active before starting a new one. The &quot;transaction&quot; method takes care of all of these details automatically.</source>
          <target state="translated">事务命令可以用来将几个SQLite命令安全地分组。当然,你也可以随时使用BEGIN手动启动事务,但如果发生错误,使COMMIT或ROLLBACK从未运行过,那么数据库将无限期地被锁定。但是如果发生错误,以至于COMMIT或ROLLBACK从未运行,那么数据库将无限期地被锁定。另外,BEGIN不会嵌套,所以在启动一个新的事务之前,你必须确保没有其他事务在活动。&quot;事务 &quot;方法会自动处理所有这些细节。</target>
        </trans-unit>
        <trans-unit id="66431b524eb3e3d97e40f460537f3aa544382bf9" translate="yes" xml:space="preserve">
          <source>The transaction has already committed at this point so timing is not critical in the deletion of the rollback journals. The current implementation deletes a single rollback journal then unlocks the corresponding database file before proceeding to the next rollback journal. But in the future we might change this so that all rollback journals are deleted before any database files are unlocked. As long as the rollback journal is deleted before its corresponding database file is unlocked it does not matter in what order the rollback journals are deleted or the database files are unlocked.</source>
          <target state="translated">此时事务已经提交,所以在删除回滚日记的过程中,时间不是关键。目前的实现是先删除一个回滚日记,然后解锁相应的数据库文件,再进行下一个回滚日记。但在未来,我们可能会改变这种做法,在任何数据库文件解锁之前删除所有回滚日志。只要回滚日志在对应的数据库文件解锁之前被删除,那么回滚日志的删除顺序和数据库文件的解锁顺序就无关紧要。</target>
        </trans-unit>
        <trans-unit id="439b3c25010ac483338852bbf167e17f82acaecb" translate="yes" xml:space="preserve">
          <source>The transformation converts each vertex of the polygon according to the following formula:</source>
          <target state="translated">该变换根据以下公式转换多边形的每个顶点。</target>
        </trans-unit>
        <trans-unit id="970a22ffd83744a201d5b074bf5b2eed9b68c352" translate="yes" xml:space="preserve">
          <source>The transient table in which the result is built is created by instruction 0. Three loops then follow. The loop at instructions 5 through 10 implements the first SELECT statement. The second SELECT statement is implemented by the loop at instructions 14 through 19. Finally, a loop at instructions 22 through 25 reads the transient table and invokes the callback once for each row in the result.</source>
          <target state="translated">指令0创建了用于建立结果的瞬时表,接着是三个循环。指令5到10的循环实现了第一个SELECT语句。第二条SELECT语句由指令14到19处的循环实现。最后,指令22到25处的循环读取瞬时表,并对结果中的每一行调用一次回调。</target>
        </trans-unit>
        <trans-unit id="952fc2249e617c46359543a66e348109d3087d3d" translate="yes" xml:space="preserve">
          <source>The transient table in which the results of the inner SELECT are stored is created by the &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; instruction at 0. This opcode is used for tables that exist for the duration of a single SQL statement only. The transient cursor is always opened read/write even if the main database is read-only. The transient table is deleted automatically when the cursor is closed. The P2 value of 1 means the cursor points to a BTree index, which has no data but can have an arbitrary key.</source>
          <target state="translated">内部SELECT的结果存储在其中的临时表是由&lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt;指令（位于0 ）创建的。此操作码用于仅在单个SQL语句期间存在的表。即使主数据库是只读的，瞬态游标也始终以读写方式打开。关闭游标时，临时表将自动删除。 P2值为1表示光标指向BTree索引，该索引没有数据，但可以具有任意键。</target>
        </trans-unit>
        <trans-unit id="592350be0cb11625e2bd092767c6171c56d03c65" translate="yes" xml:space="preserve">
          <source>The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source code file in the SQLite core had to be modified, some extensively. And the change introduced some minor incompatibilities in the C interface. But we feel that the benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting. The new VFS layer is now well-defined and stable and should simplify future customizations. The VFS layer, and the separable memory allocator and mutex subsystems allow a standard SQLite source code amalgamation to be used in an embedded project without change, greatly simplifying configuration management. And the resulting system is much more tolerant of highly threaded designs.</source>
          <target state="translated">从SQLite 3.4.2版本过渡到3.5.0是一个重大的变化。SQLite核心中的每一个源代码文件都必须修改,有的还很广泛。而且这个变化在C接口中引入了一些小的不兼容性。但我们觉得从3.4.2过渡到3.5.0的好处远远超过了移植的痛苦。新的VFS层现在定义得很好,也很稳定,应该可以简化未来的定制。VFS层以及可分离的内存分配器和mutex子系统允许在嵌入式项目中使用标准的SQLite源代码合并,而不需要改变,大大简化了配置管理。而且由此产生的系统对高线程设计的容忍度更高。</target>
        </trans-unit>
        <trans-unit id="b0ecdf62ac64721b60f0c811bc6ae15d2a3d1b27" translate="yes" xml:space="preserve">
          <source>The trick here is the -DTCLSH=1 option. The TCL interface module for SQLite includes a &lt;b&gt;main()&lt;/b&gt; procedure that initializes a TCL interpreter and enters a command-line loop when it is compiled with -DTCLSH=1. The command above works on both Linux and Mac OS X, though one may need to adjust the library options depending on the platform and which version of TCL one is linking against.</source>
          <target state="translated">这里的技巧是-DTCLSH = 1选项。用于SQLite的TCL接口模块包括&lt;b&gt;main（）&lt;/b&gt;过程，该过程将初始化TCL解释器，并在使用-DTCLSH = 1进行编译时进入命令行循环。上面的命令在Linux和Mac OS X上均可使用，尽管可能需要根据平台和所链接的TCL版本来调整库选项。</target>
        </trans-unit>
        <trans-unit id="fc5d00c95debe18bbcee9e720337d19dcab11f5a" translate="yes" xml:space="preserve">
          <source>The trigger created by the previous statement is named &quot;AFTER&quot; and it is a &quot;BEFORE&quot; trigger. The &quot;AFTER&quot; token is used as an identifier instead of as a keyword, as that is the only way to parse the statement. Another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9b7cf0a7967eed621bbbad3863190e29c44d61" translate="yes" xml:space="preserve">
          <source>The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.</source>
          <target state="translated">trim(X,Y)函数返回一个从X的两端删除Y中出现的所有字符所形成的字符串,如果省略Y参数,trim(X)将从X的两端删除空格。</target>
        </trans-unit>
        <trans-unit id="02041028dd7a37adeacbb35b1200b0b1a6b27a53" translate="yes" xml:space="preserve">
          <source>The true primary key for a rowid table (the value that is used as the key to look up rows in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine) is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">rowid表的真正主键（用作在基础&lt;a href=&quot;fileformat2#btree&quot;&gt;B树&lt;/a&gt;存储引擎中查找行的键的值）是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f9dae6c570b0f408d716bb105a5e25850cccf9f" translate="yes" xml:space="preserve">
          <source>The truncate optimization can also be disabled at runtime using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface. If an authorizer callback returns &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; for an &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; action code, then the DELETE operation will proceed but the truncate optimization will be bypassed and rows will be deleted one by one.</source>
          <target state="translated">还可以在运行时使用&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;接口禁用截断优化。如果授权者回调返回&lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_DELETE&lt;/a&gt;操作代码的&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，则DELETE操作将继续进行，但截断优化将被绕过，行将被一一删除。</target>
        </trans-unit>
        <trans-unit id="7489f83785acf46d79dbedce76141d020e3a30b4" translate="yes" xml:space="preserve">
          <source>The truncate optimization can be permanently disabled for all queries by recompiling SQLite with the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time switch.</source>
          <target state="translated">通过使用&lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt;编译时开关重新编译SQLite，可以永久禁用所有查询的截断优化。</target>
        </trans-unit>
        <trans-unit id="30f49567fa43c7d2e5e26ee8efe4338c93c45898" translate="yes" xml:space="preserve">
          <source>The trusted_schema setting is a per-connection boolean that determines whether or not SQL functions and virtual tables that have not been security audited are allowed to be run by views, triggers, or in expressions of the schema such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, and/or &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;. This setting can also be controlled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,...) C-language interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e242c8734781e20213900394ec30db10b58ee560" translate="yes" xml:space="preserve">
          <source>The two &quot;0&quot; parameters do server a purpose in some contexts, but for using these routine to print a parse tree as ASCII-art on the terminal, they should both be &quot;0&quot;.</source>
          <target state="translated">这两个 &quot;0 &quot;参数在某些情况下有一定的作用,但对于使用这些例程在终端上打印ASCII-art的解析树,它们都应该是 &quot;0&quot;。</target>
        </trans-unit>
        <trans-unit id="46623d6b4b79b06cc3078e791041446a91edf407" translate="yes" xml:space="preserve">
          <source>The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are omitted from the database file and neither auto_vacuum nor incremental_vacuum are supported. If the integer at offset 52 is non-zero then it is the page number of the largest root page in the database file, the database file will contain ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In this latter case, the integer at offset 64 is true for incremental_vacuum and false for auto_vacuum. If the integer at offset 52 is zero then the integer at offset 64 must also be zero.</source>
          <target state="translated">偏移量为52和64的两个4字节的大端整数用于管理&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;增量&lt;/a&gt;_vacuum模式。如果偏移量52处的整数为零，则将从数据库文件中省略指针映射（ptrmap）页，并且不支持auto_vacuum和增量_vacuum。如果偏移量52处的整数不为零，则它是数据库文件中最大根页的页码，数据库文件将包含ptrmap页，并且模式必须为auto_vacuum或增量_vacuum。在后一种情况下，偏移量64处的整数对于incremental_vacuum为true，对于auto_vacuum为false。如果偏移52处的整数为零，那么偏移64处的整数也必须为零。</target>
        </trans-unit>
        <trans-unit id="5d5cec8b4b21ae2b9d4802acdeb66477068dae88" translate="yes" xml:space="preserve">
          <source>The two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; are:</source>
          <target state="translated">这两个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;是：</target>
        </trans-unit>
        <trans-unit id="60d1d8fda3bbd4cfca022cc996f0d5a823d5b6ed" translate="yes" xml:space="preserve">
          <source>The two exceptions are:</source>
          <target state="translated">两个例外是:</target>
        </trans-unit>
        <trans-unit id="e1f0bf58781420b540ac606f0e7579a8a2be4378" translate="yes" xml:space="preserve">
          <source>The two fragments of SQL below are similar, but not entirely equivalent, as the latter will fail if the definition of window &quot;win&quot; contains a frame specification.</source>
          <target state="translated">下面的两个SQL片段相似,但并不完全等同,因为如果窗口 &quot;win &quot;的定义中包含框架规范,那么后者就会失败。</target>
        </trans-unit>
        <trans-unit id="f9a92735a6c1a485477340ad1399f41bdfef6983" translate="yes" xml:space="preserve">
          <source>The two remaining tables, %_segments and %_segdir, are used to store the full-text index. Conceptually, this index is a lookup table that maps each term (word) to the set of docid values corresponding to records in the %_content table that contain one or more occurrences of the term. To retrieve all documents that contain a specified term, the FTS module queries this index to determine the set of docid values for records that contain the term, then retrieves the required documents from the %_content table. Regardless of the schema of the FTS virtual table, the %_segments and %_segdir tables are always created as follows:</source>
          <target state="translated">剩下的两个表,%_segments和%_segdir,用来存储全文索引。从概念上讲,这个索引是一个查找表,它将每个术语(词)映射到与%_content表中包含一个或多个术语出现的记录相对应的docid值集。为了检索包含指定术语的所有文档,FTS模块查询该索引以确定包含该术语的记录的docid值集,然后从%_content表中检索所需文档。无论FTS虚拟表的模式如何,%_segments和%_segdir表总是按如下方式创建。</target>
        </trans-unit>
        <trans-unit id="57eb59a7de5c1f2eacd1a8c2e2793991396d4104" translate="yes" xml:space="preserve">
          <source>The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.</source>
          <target state="translated">从WAL文件头复制的两个盐值。这些值是按WAL文件的字节顺序排列的,可能与机器的原始字节顺序不同。</target>
        </trans-unit>
        <trans-unit id="ccc9e431ebc7fabfa6726082e51ef8838fff247f" translate="yes" xml:space="preserve">
          <source>The two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; accepts a pointer to the tokenizer method object even without the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting if the second argument is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;</source>
          <target state="translated">如果第二个参数是&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数，&lt;/a&gt;则即使没有&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;）设置，&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;的两个参数版本也会接受指向令牌生成器方法对象的指针。</target>
        </trans-unit>
        <trans-unit id="6b8d35e3a824a79bc7ce101b6a6ae7997418f4f7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks.</source>
          <target state="translated">位于偏移量1的两个字节的整数,给出了页面上第一个自由块的开始,如果没有自由块,则为零。</target>
        </trans-unit>
        <trans-unit id="c4473928239ae1bda74a9fb4bb8276860fc5ffb5" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 3 gives the number of cells on the page.</source>
          <target state="translated">偏移量3的两个字节整数给出了页面上的单元数。</target>
        </trans-unit>
        <trans-unit id="a06521372b9101f2c70d6a3c29239fdaf5cbc5a7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536.</source>
          <target state="translated">偏移量5的两个字节的整数表示单元格内容区域的开始。该整数的零值被解释为65536。</target>
        </trans-unit>
        <trans-unit id="85da2eb104aa5ac23b3d2218d186677a6dbc8b7e" translate="yes" xml:space="preserve">
          <source>The two-byte value beginning at offset 16 determines the page size of the database. For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted as a big-endian integer and must be a power of two between 512 and 32768, inclusive. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;version 3.7.1&lt;/a&gt; (2010-08-23), a page size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer, so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This value can be interpreted as a big-endian 1 and thought of as a magic number to represent the 65536 page size. Or one can view the two-byte field as a little endian number and say that it represents the page size divided by 256. These two interpretations of the page-size field are equivalent.</source>
          <target state="translated">从偏移量16开始的两字节值确定数据库的页面大小。对于SQLite版本3.7.0.1（2010-08-04）和更早版本，此值解释为big-endian整数，并且必须是512到32768（含）之间的2的幂。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;版本3.7.1&lt;/a&gt;（2010-08-23）开始，支持65536字节的页面大小。值65536将不适合两个字节的整数，因此要指定65536字节的页面大小，偏移量16处的值为0x00 0x01。此值可以解释为big-endian 1，并且可以视为表示65536页大小的幻数。或者，可以将两个字节的字段视为一个小端数字，并说它表示页面大小除以256。页面大小字段的这两种解释是等效的。</target>
        </trans-unit>
        <trans-unit id="d620a0d4c1327669927184e30780adb142926606" translate="yes" xml:space="preserve">
          <source>The typedef is necessary to work around problems in certain C++ compilers.</source>
          <target state="translated">类型定义是必要的,以解决某些C++编译器的问题。</target>
        </trans-unit>
        <trans-unit id="2acee6be58c92d0d4d1c18a3c705f7ce6eca583d" translate="yes" xml:space="preserve">
          <source>The typeof(X) function returns a string that indicates the &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; of the expression X: &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;, or &quot;blob&quot;.</source>
          <target state="translated">typeof（X）函数返回一个字符串，该字符串指示表达式X 的&lt;a href=&quot;datatype3&quot;&gt;数据类型&lt;/a&gt;：&amp;ldquo; null&amp;rdquo;，&amp;ldquo; integer&amp;rdquo;，&amp;ldquo; real&amp;rdquo;，&amp;ldquo; text&amp;rdquo;或&amp;ldquo; blob&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7de0eb427df1bd72e4d6981f084f01d2fd7b104b" translate="yes" xml:space="preserve">
          <source>The types and default collation sequences attached to each column must be the same for all component tables.</source>
          <target state="translated">对所有的组件表来说,附加在每一列上的类型和默认整理序列必须是相同的。</target>
        </trans-unit>
        <trans-unit id="7a193d6baad5e9eae89c634a076cd20d9e39a2d0" translate="yes" xml:space="preserve">
          <source>The unary operator</source>
          <target state="translated">单利运算符</target>
        </trans-unit>
        <trans-unit id="5de3e6de824f9a3c28afdefed054e3e170c8e0d8" translate="yes" xml:space="preserve">
          <source>The uncompress function should uncompress data previously compressed by the compress function. In other words, for all SQLite values X, it should be true that uncompress(compress(X)) equals X. When data that has been compressed by the compress function is read from the database by FTS4, it is passed to the uncompress function before it is used.</source>
          <target state="translated">uncompress函数应该对之前被压缩函数压缩过的数据进行解压。换句话说,对于所有的SQLite值X,uncompress(compress(X))应该是真的等于X,当FTS4从数据库中读取已经被压缩函数压缩过的数据时,会在使用之前将其传递给uncompress函数。</target>
        </trans-unit>
        <trans-unit id="04cb6e28b7a92f43a8ce66195a1ea7614bfeaae5" translate="yes" xml:space="preserve">
          <source>The underlying implementation can support some subset of these locking levels as long as it meets the other requirements of this paragraph. The locking level is specified as the second argument to both xLock and xUnlock. The xLock method increases the locking level to the specified locking level or higher. The xUnlock method decreases the locking level to no lower than the level specified. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; means that the file is unlocked. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; gives permission to read the file. Multiple database connections can hold &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; at the same time. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; is like &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; in that it is permission to read the file. But only a single connection can hold a reserved lock at any point in time. The &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; is also permission to read the file. Other connections can continue to read the file as well, but no other connection is allowed to escalate a lock from none to shared. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; is permission to write on the file. Only a single connection can hold an exclusive lock and no other connection can hold any lock (other than &quot;none&quot;) while one connection holds an exclusive lock. The xLock returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if it is unable to obtain the lock, or &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt; if something else goes wrong. The xUnlock method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; for problems.</source>
          <target state="translated">只要满足本段的其他要求，基础实现就可以支持这些锁定级别的某些子集。锁定级别被指定为xLock和xUnlock的第二个参数。 xLock方法将锁定级别增加到指定的锁定级别或更高。 xUnlock方法将锁定级别降低到不低于指定的级别。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;表示文件已解锁。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;授予读取文件的权限。多个数据库连接可以同时保存&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;就像&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;因为它是读取文件的权限。但是在任何时间点只有一个连接可以保留保留的锁。该&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;也读取该文件的权限。其他连接也可以继续读取文件，但是不允许其他连接将锁从无锁升级为共享锁。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;是在文件上写入的权限。只有一个连接可以拥有排他锁，而其他任何连接都不能拥有任何锁（&amp;ldquo;无&amp;rdquo;除外），而一个连接则可以拥有排他锁。该XLOCK返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功，&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;如果无法获得锁，或者&lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt;如果遇到其他问题。 xUnlock方法返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功，&lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt;解决问题。</target>
        </trans-unit>
        <trans-unit id="0269000c82eb39065f294879a620aecf2c6e833d" translate="yes" xml:space="preserve">
          <source>The underscore character (unicode codepoint 96).</source>
          <target state="translated">下划线字符(unicode cepoint 96)。</target>
        </trans-unit>
        <trans-unit id="94b1d236b1b1bdea969b9f218085fccfc7fb6de3" translate="yes" xml:space="preserve">
          <source>The undo::activate command creates temporary triggers in the database that record all changes made to the tables named in the arguments.</source>
          <target state="translated">undo::activate命令在数据库中创建临时触发器,记录对参数中命名的表的所有更改。</target>
        </trans-unit>
        <trans-unit id="9d719f9a44e55c933ab5b5fa11156ee426d1545d" translate="yes" xml:space="preserve">
          <source>The undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface has been removed.</source>
          <target state="translated">未&lt;b&gt;公开的sqlite3_os_switch（）&lt;/b&gt;接口已被删除。</target>
        </trans-unit>
        <trans-unit id="93cdbdaae25242141056e83b2feecd9f656881a8" translate="yes" xml:space="preserve">
          <source>The unicode tokenizer classifies all unicode characters as either &quot;separator&quot; or &quot;token&quot; characters. By default all space and punctuation characters, as defined by Unicode 6.1, are considered separators, and all other characters as token characters. More specifically, all unicode characters assigned to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt; general category&lt;/a&gt; beginning with &quot;L&quot; or &quot;N&quot; (letters and numbers, specifically) or to category &quot;Co&quot; (&quot;other, private use&quot;) are considered tokens. All other characters are separators.</source>
          <target state="translated">Unicode标记生成器将所有Unicode字符分类为&amp;ldquo;分隔符&amp;rdquo;或&amp;ldquo;令牌&amp;rdquo;字符。默认情况下，Unicode 6.1定义的所有空格和标点字符都被视为分隔符，所有其他字符都被视为标记字符。更具体地说，所有分配给以&amp;ldquo; L&amp;rdquo;或&amp;ldquo; N&amp;rdquo;开头的&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt;通用类别&lt;/a&gt;（特别是字母和数字）或类别&amp;ldquo; Co&amp;rdquo;（&amp;ldquo;其他用途&amp;rdquo;）的所有unicode字符都被视为令牌。所有其他字符都是分隔符。</target>
        </trans-unit>
        <trans-unit id="8359d1281537e2db390ccb27a011cf0c1e07387b" translate="yes" xml:space="preserve">
          <source>The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.</source>
          <target state="translated">unicode(X)函数返回与字符串X的第一个字符相对应的数字unicode码点,如果unicode(X)的参数不是字符串,则结果未定义。</target>
        </trans-unit>
        <trans-unit id="b06912261f5bb2d984a2ea7d12c5ea40ed3062a1" translate="yes" xml:space="preserve">
          <source>The union-vtab is not built into SQLite. Union-vtab is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. The source code for union-vtab is contained in a single file located at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext/misc/unionvtab.c&lt;/a&gt; in the SQLite source tree.</source>
          <target state="translated">union-vtab未内置在SQLite中。Union-vtab是&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。union-vtab的源代码包含在SQLite源树中&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext / misc / unionvtab.c&lt;/a&gt;的单个文件中。</target>
        </trans-unit>
        <trans-unit id="70f606d5ad9373cd7360030770268b87dc04b4a8" translate="yes" xml:space="preserve">
          <source>The union-vtab is read-only. Support for writing may be added at a later time, but writing is not a part of the initial implementation.</source>
          <target state="translated">union-vtab是只读的。以后可能会增加对写入的支持,但写入不是初始实现的一部分。</target>
        </trans-unit>
        <trans-unit id="217c127b8d7dc9166357c6c852e4edb92e8bd2cc" translate="yes" xml:space="preserve">
          <source>The union-vtab shall optimize access to the underlying real tables when the constraints on the query are among forms shown below. Other kinds of constraints may be optimized in the future, but only these constraints are optimized in the initial implementation.</source>
          <target state="translated">当查询的约束条件属于下图所示形式时,union-vtab应优化对底层实表的访问。以后可能会优化其他种类的约束条件,但在初始实现中只优化这些约束条件。</target>
        </trans-unit>
        <trans-unit id="5ad25f83f6534911bf90077b4a8c2d24284bf894" translate="yes" xml:space="preserve">
          <source>The unique id (INTEGER PRIMARY KEY)</source>
          <target state="translated">唯一的ID(INTEGER PRIMARY KEY)</target>
        </trans-unit>
        <trans-unit id="37c73afc15f55751239631e696091c5fb7a86756" translate="yes" xml:space="preserve">
          <source>The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will never use a file descriptor less than</source>
          <target state="translated">Unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;绝不会使用小于</target>
        </trans-unit>
        <trans-unit id="ae8287e8b161fa1549dd3442fa8607f53d8dfe62" translate="yes" xml:space="preserve">
          <source>The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X, 0.0625).</source>
          <target state="translated">不太可能（X）函数返回参数X不变。不大可能（X）函数是一种无操作，代码生成器会对其进行优化，以使其在运行时（即，在调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间）不占用任何CPU周期。不可能的（X）函数的目的是向查询计划者提供一个提示，即参数X是通常不是真的布尔值。可能性函数（X）等于&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;可能性&lt;/a&gt;（X，0.0625）。</target>
        </trans-unit>
        <trans-unit id="f74bf3865d4b8d380ed09cdf9682ebd8ba365f80" translate="yes" xml:space="preserve">
          <source>The unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.</source>
          <target state="translated">unlock-notify回调是不可重入的。如果应用程序在解锁-通知回调中调用任何 sqlite3_xxx API 函数,可能会导致崩溃或死锁。</target>
        </trans-unit>
        <trans-unit id="9f10c2e623337226e56371f152fe9704c596a75e" translate="yes" xml:space="preserve">
          <source>The unlock_notify method is used access the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface to the SQLite core library for testing purposes. The use of this method by applications is discouraged.</source>
          <target state="translated">unlock_notify方法用于访问&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;接口到SQLite核心库以进行测试。不鼓励应用程序使用此方法。</target>
        </trans-unit>
        <trans-unit id="c0db7fcedecb648c350c1b6f11ba954f23165737" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">更新挂钩实现不得做任何会修改调用更新挂钩的数据库连接的操作。任何修改数据库连接的操作都必须推迟到触发更新钩子的&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用完成之后。请注意，在本段中，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="09532968164962481e11046837aaa8bacbe59ea0" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">更新挂钩实现不得做任何会修改调用更新挂钩的数据库连接的操作。任何修改数据库连接的操作都必须推迟到触发更新钩子的&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用完成之后。请注意，在本段中，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="f188e349260d6d862bd1151de1aa0b41c96135c8" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">修改内部系统表（即sqlite_master和sqlite_sequence）时，不会调用更新挂钩。修改&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表时，不会调用更新挂钩。</target>
        </trans-unit>
        <trans-unit id="d4c3b215f10d00c42f1094ebb70e270136be0ef6" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">修改内部系统表（即sqlite_master和sqlite_sequence）时，不会调用更新挂钩。修改&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表时，不会调用更新挂钩。</target>
        </trans-unit>
        <trans-unit id="f04fa9936d514fac1b991da703764bce23461785" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b14dc5637688b2512ff9a25b9caa046cb0c8fc2" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3d709a5bf6d8d9c48b677160252ac4da74295a" translate="yes" xml:space="preserve">
          <source>The upper bound on the database &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache size&lt;/a&gt; has traditionally defaulted to 2000 pages. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; also changes this default setting to be &quot;-2000&quot; which means 2000*1024 bytes, regardless of page size. So, the upper bound on the amount of memory used for the page cache is unchanged.</source>
          <target state="translated">传统上，数据库&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;高速缓存大小&lt;/a&gt;的上限默认为2000页。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;版本3.12.0&lt;/a&gt;还将默认设置更改为&amp;ldquo; -2000&amp;rdquo;，这意味着2000 * 1024字节，与页面大小无关。因此，用于页面缓存的内存量的上限不变。</target>
        </trans-unit>
        <trans-unit id="55e210be964a43ed3f79f81acfb0252d2ec508a2" translate="yes" xml:space="preserve">
          <source>The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.</source>
          <target state="translated">upper(X)函数返回一个输入字符串X的副本,其中所有小写的ASCII字符都被转换为等价的大写字符。</target>
        </trans-unit>
        <trans-unit id="2ff3bb49a7df2e57465c506adbfbac36859c676c" translate="yes" xml:space="preserve">
          <source>The upsert above inserts the new vocabulary word &quot;jovial&quot; if that word is not already in the dictionary, or if it is already in the dictionary, it increments the counter. The &quot;count+1&quot; expression could also be written as &quot;vocabulary.count&quot;. PostgreSQL requires the second form, but SQLite accepts either.</source>
          <target state="translated">上面的upsert插入了新的词汇 &quot;jovial&quot;,如果该词还没有在字典中,或者如果它已经在字典中,则递增计数器。&quot;count+1 &quot;表达式也可以写成 &quot;vocabulary.count&quot;。PostgreSQL需要第二种形式,但SQLite接受任何一种形式。</target>
        </trans-unit>
        <trans-unit id="f98914d65daf1eee948f9cf4215d1bc155ef41fa" translate="yes" xml:space="preserve">
          <source>The usage of pagecache memory is somewhat harder to control in SQLite version 3.6.1, though mechanisms are planned for subsequent releases that will make controlling pagecache memory much easier. Prior to the introduction of these new mechanisms, the only way to control pagecache memory is using the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">在SQLite 3.6.1版中，页面缓存内存的使用在某种程度上很难控制，尽管计划为后续发行版设计机制，这将使控制页面缓存内存变得更加容易。在引入这些新机制之前，控制pagecache内存的唯一方法是使用&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83c37f6e9e518d22e126d6f49713b321c1f31d9b" translate="yes" xml:space="preserve">
          <source>The use of &quot;:&quot; instead of &quot;$&quot; before the name of a variable can sometimes be useful if the SQL text is enclosed in double-quotes &quot;...&quot; instead of curly-braces {...}. When the SQL is contained within double-quotes &quot;...&quot; then TCL will do the substitution of $-variables, which can lead to SQL injection if extreme care is not used. But TCL will never substitute a :-variable regardless of whether double-quotes &quot;...&quot; or curly-braces {...} are used to enclose the SQL, so the use of :-variables adds an extra measure of defense against SQL injection.</source>
          <target state="translated">如果SQL文本用双引号&quot;...&quot;代替大括号{...},在变量名前使用&quot;:&quot;代替&quot;$&quot;有时会很有用。当SQL文本包含在双引号&quot;...&quot;内时,那么TCL会对$-变量进行替换,如果不格外小心,可能会导致SQL注入。但是TCL无论用双引号&quot;...&quot;还是用大括号{...}来封闭SQL,都不会用:-变量来替代,所以使用:-变量就多了一道防御SQL注入的措施。</target>
        </trans-unit>
        <trans-unit id="53ba0fe6640d81c27b2028a34ac03622ddcd61d3" translate="yes" xml:space="preserve">
          <source>The use of a ZIP archive to encapsulate XML files plus resources is an elegant approach to an application file format. It is clearly superior to a custom binary file format. But using an SQLite database as the container, instead of ZIP, would be more elegant still.</source>
          <target state="translated">使用ZIP归档来封装XML文件加资源是一种优雅的应用文件格式的方法。它显然优于定制的二进制文件格式。但使用SQLite数据库作为容器,而不是ZIP,仍然会更优雅。</target>
        </trans-unit>
        <trans-unit id="62a1d7ca77be3f3b5567800401dc0bf052c2aaae" translate="yes" xml:space="preserve">
          <source>The use of a virtual machine in SQLite has been a great benefit to the library's development. The virtual machine provides a crisp, well-defined junction between the front-end of SQLite (the part that parses SQL statements and generates virtual machine code) and the back-end (the part that executes the virtual machine code and computes a result.) The virtual machine allows the developers to see clearly and in an easily readable form what SQLite is trying to do with each statement it compiles, which is a tremendous help in debugging. Depending on how it is compiled, SQLite also has the capability of tracing the execution of the virtual machine - printing each virtual machine instruction and its result as it executes.</source>
          <target state="translated">在SQLite中使用虚拟机对库的开发有很大的好处。虚拟机在SQLite的前端(解析SQL语句和生成虚拟机代码的部分)和后端(执行虚拟机代码和计算结果的部分)之间提供了一个清晰的、定义明确的交界点。&quot;虚拟机 &quot;使开发人员能够以一种易于阅读的形式清楚地看到SQLite编译的每一条语句要做什么,这对调试有极大的帮助。根据编译方式的不同,SQLite还具有跟踪虚拟机执行情况的功能--打印每条虚拟机指令及其执行结果。</target>
        </trans-unit>
        <trans-unit id="9d27ce1c6f5449fceeec41db3a7baef374e89122" translate="yes" xml:space="preserve">
          <source>The use of each of these methods will be explained in the sequel, though not in the order shown above.</source>
          <target state="translated">每一种方法的使用都将在后文中解释,尽管不是按照上述顺序。</target>
        </trans-unit>
        <trans-unit id="ac3e9e4d3a0d1a6a51dbf276370664c84cd0bc3c" translate="yes" xml:space="preserve">
          <source>The use of persistent journal mode provides a noticeable performance improvement on many systems. Of course, the drawback is that the journal files remain on the disk, using disk space and cluttering directories, long after the transaction commits. The only safe way to delete a persistent journal file is to commit a transaction with journaling mode set to DELETE:</source>
          <target state="translated">在许多系统中,使用持久性日志模式可以明显提高性能。当然,缺点是在事务提交后很长一段时间内,日志文件仍然留在磁盘上,占用磁盘空间,使目录杂乱无章。唯一安全的删除持久性日志文件的方法是提交事务时将日志模式设置为DELETE。</target>
        </trans-unit>
        <trans-unit id="ac2e1cc15280219a058aa01cbdd9d14acc3c174c" translate="yes" xml:space="preserve">
          <source>The use of pointer-passing is an advanced technique that should be used infrequently and cautiously. Pointer-passing should not be used haphazardly or carelessly. Pointer-passing is a sharp tool that can leave deep scars if misused.</source>
          <target state="translated">指针传递的使用是一种高级技术,应不经常使用,谨慎使用。不应随意或粗心地使用指针传递。指针传递是一种锋利的工具,如果使用不当,会留下很深的疤痕。</target>
        </trans-unit>
        <trans-unit id="716439e76a7ceab1c8c91b09a2f76c73c53bf8c1" translate="yes" xml:space="preserve">
          <source>The use of subtypes on pointers prevented pointer forgery using pure SQL. But subtypes do nothing to prevent an attacker from reading the values of pointers. In other words, subtypes on pointer values prevent attacks using SQL statements like this:</source>
          <target state="translated">在指针上使用子类型可以防止使用纯SQL的指针伪造。但是子类型对于防止攻击者读取指针的值没有任何作用。换句话说,指针值上的子类型可以防止使用这样的SQL语句进行攻击。</target>
        </trans-unit>
        <trans-unit id="d8ed607375ddfb8582a61f0a5132f51fb52c53b0" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is recommended for all applications.</source>
          <target state="translated">建议在所有应用程序中使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="789c46abbb3fc4976d476150773395da4c1e0a98" translate="yes" xml:space="preserve">
          <source>The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8. The UTF-16 interfaces are provided as a convenience. The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.</source>
          <target state="translated">使用UTF-8接口是首选,因为SQLite目前使用UTF-8进行所有的解析。UTF-16接口是作为一种方便而提供的,它的工作原理是将输入的文本转换成UTF-8,然后调用相应的UTF-8接口。UTF-16接口的工作原理是将输入文本转换为UTF-8,然后调用相应的UTF-8接口。</target>
        </trans-unit>
        <trans-unit id="7ed5c8c8570cfb3a0d0049b76c3fa5c381dc896c" translate="yes" xml:space="preserve">
          <source>The use of the error logger callback is highly recommended. The debugging information that the error logger provides has proven very useful in tracking down obscure problems that occurs with applications after they get into the field. The error logger callback has also proven useful in catching errors occasional errors that the application misses because of inconsistent checking of API return codes. Developers are encouraged to implement an error logger callback early in the development cycle in order to spot unexpected behavior quickly, and to leave the error logger callback turned on through deployment. If the error logger never finds a problem, then no harm is done. But failure to set up an appropriate error logger might compromise diagnostic capabilities later on.</source>
          <target state="translated">强烈建议使用错误记录器回调。事实证明,错误记录器提供的调试信息对于跟踪应用程序进入现场后发生的不明显问题非常有用。事实证明,错误记录器回调在捕捉错误方面也很有用,因为应用程序会因为不一致的API返回代码检查而错过错误。我们鼓励开发人员在开发周期的早期实现错误记录器回调,以便快速发现意外行为,并在部署过程中保持错误记录器回调的开启状态。如果错误记录器从未发现问题,那么就不会造成伤害。但是如果没有设置一个合适的错误记录器,可能会影响以后的诊断能力。</target>
        </trans-unit>
        <trans-unit id="a848d528e6bb7ea17daf03362baa03e736e192f7" translate="yes" xml:space="preserve">
          <source>The use of the standardized speedtest1.c workload and cachegrind has enabled significant performance improvement. However, it is important to recognize the limitations of this approach:</source>
          <target state="translated">使用标准化的speedtest1.c工作负载和cachegrind使性能得到显著提高。但是,必须认识到这种方法的局限性。</target>
        </trans-unit>
        <trans-unit id="fbf470196dd9e32d7a6c5961b17698cfadfdbb60" translate="yes" xml:space="preserve">
          <source>The use of variable-length records by SQLite has a number of advantages. It results in smaller database files, obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.</source>
          <target state="translated">SQLite使用可变长度记录有很多优点。很明显,它可以使数据库文件更小。它还使数据库运行得更快,因为需要从磁盘上移入和移出的信息更少。而且,可变长度记录的使用使得SQLite有可能采用manifest typing而不是静态 typing。</target>
        </trans-unit>
        <trans-unit id="f495ec4a4bf3743c12d1f50425c742888001cad3" translate="yes" xml:space="preserve">
          <source>The user_version pragma will to get or set the value of the user-version integer at offset 60 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. The user-version is an integer that is available to applications to use however they want. SQLite makes no use of the user-version itself.</source>
          <target state="translated">user_version编译指示将获取或设置&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库标头&lt;/a&gt;中偏移60处的user-version整数的值。用户版本是一个整数，应用程序可以根据需要使用它。SQLite不使用用户版本本身。</target>
        </trans-unit>
        <trans-unit id="81fbf2e7b21c5d201e92f96deae7ccf53bbeeddc" translate="yes" xml:space="preserve">
          <source>The usermerge option is similar to the automerge and crisismerge options. It is the minimum number of b-tree segments that will be merged together by a 'merge' command with a positive parameter. For example:</source>
          <target state="translated">usermerge 选项与 automerge 和 crisismerge 选项类似。它是一个带有正参数的 &quot;merge &quot;命令将合并在一起的b树段的最小数量。例如</target>
        </trans-unit>
        <trans-unit id="7380a4170d0b89318a355604d7dab9b3376f5f00" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; commands work on an R*Tree index just like on regular tables. So to insert some data into our sample R*Tree index, we can do something like this:</source>
          <target state="translated">常规&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;命令在R * Tree索引上工作，就像在常规表上一样。因此，要将一些数据插入示例R * Tree索引中，我们可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="7245ad2ccb3652b74420857f1f81436b120932a2" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">通常的情况是sqlite3_serialize（）将数据库的序列化复制到从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中，并返回指向该内存的指针。调用者负责释放返回的值，以避免内存泄漏。但是，如果F参数包含SQLITE_SERIALIZE_NOCOPY位，则不进行内存分配，并且sqlite3_serialize（）函数将返回一个指针，该指针指向SQLite当前用于该数据库的数据库的连续内存表示形式；如果否，则返回NULL。存在数据库的这种连续内存表示形式。通常只有在先调用&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（D，S，...）&lt;/a&gt;后，数据库的连续内存表示形式才会存在。具有相同的D和S值。即使将SQLITE_SERIALIZE_NOCOPY位置1，但不存在数据库的连续副本，数据库的大小也会写入* P。</target>
        </trans-unit>
        <trans-unit id="69659aa2e08fcc19f80f4fa144bcabaf8c7b3ed8" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">通常的情况是sqlite3_serialize（）将数据库的序列化复制到从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中，并返回指向该内存的指针。调用者负责释放返回的值，以避免内存泄漏。但是，如果F参数包含SQLITE_SERIALIZE_NOCOPY位，则不进行内存分配，并且sqlite3_serialize（）函数将返回一个指针，该指针指向SQLite当前用于该数据库的数据库的连续内存表示形式；如果否，则返回NULL。存在数据库的这种连续内存表示形式。通常只有在先调用&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（D，S，...）&lt;/a&gt;后，数据库的连续内存表示形式才会存在。具有相同的D和S值。即使将SQLITE_SERIALIZE_NOCOPY位置1，但不存在数据库的连续副本，数据库的大小也会写入* P。</target>
        </trans-unit>
        <trans-unit id="2878cf43bc017da229299a9eeb8ee3b6c95340de" translate="yes" xml:space="preserve">
          <source>The usual case is that the entire database file is checked. However, if the argument is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc6512389ff21ec6ba0d889f8647d34fa1771be" translate="yes" xml:space="preserve">
          <source>The usual output is an SQL script that will transform database1.sqlite (the &quot;source&quot; database) into database2.sqlite (the &quot;destination&quot; database). This behavior can be altered using command-line switches:</source>
          <target state="translated">通常的输出是一个SQL脚本,它将把database1.sqlite(&quot;源 &quot;数据库)转换成database2.sqlite(&quot;目标 &quot;数据库)。这种行为可以通过命令行开关来改变。</target>
        </trans-unit>
        <trans-unit id="ebe7d136ea02a608354f8bf5123226386a80e2bf" translate="yes" xml:space="preserve">
          <source>The usual usage pattern for an sqlite3_changegroup object is as follows:</source>
          <target state="translated">sqlite3_changegroup对象的通常使用模式如下。</target>
        </trans-unit>
        <trans-unit id="f006b61943f366c81b0414ad0d7a764b14620096" translate="yes" xml:space="preserve">
          <source>The usual way of storing a date in a database table is as a single field, as either a unix timestamp, a julian day number, or an ISO-8601 dates string. But some application store dates as three separate fields for the year, month, and day.</source>
          <target state="translated">通常在数据库表中存储日期的方法是作为一个单一的字段,如unix时间戳,julian日数,或者ISO-8601日期字符串。但有些应用程序将日期存储为年、月、日三个独立的字段。</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="translated">价值</target>
        </trans-unit>
        <trans-unit id="1493e5c49d89b37715d26870b14178bb98eff899" translate="yes" xml:space="preserve">
          <source>The value extracted is stored in register P3.</source>
          <target state="translated">提取的值存储在寄存器P3中。</target>
        </trans-unit>
        <trans-unit id="b67d4fe7f5972a61b5da20c2ef9a98c84328f043" translate="yes" xml:space="preserve">
          <source>The value of NEW.rowid is undefined in a BEFORE INSERT trigger in which the rowid is not explicitly set to an integer.</source>
          <target state="translated">在BEFORE INSERT触发器中,如果rowid没有被显式地设置为一个整数,那么NEW.rowid的值就没有被定义。</target>
        </trans-unit>
        <trans-unit id="6ccbeb6aa89a69300ffd6eb190f7535f8bc566cf" translate="yes" xml:space="preserve">
          <source>The value of SQLITE_THREADSAFE can be determined at run-time using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;接口确定SQLITE_THREADSAFE的值。</target>
        </trans-unit>
        <trans-unit id="d5ab5daf4c7771df3bc76b4527132dffd8bea934" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column must always be a non-NULL integer. The PRIMARY KEY columns of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table are also required to be non-NULL.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列的值必须始终为非NULL整数。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的PRIMARY KEY列也必须为非NULL。</target>
        </trans-unit>
        <trans-unit id="94d5eebfcf21e24cf605bf00db4a0642798783cd" translate="yes" xml:space="preserve">
          <source>The value of the N parameter to these interfaces should be non-negative. Future enhancements may make use of negative N values to define new kinds of function caching behavior.</source>
          <target state="translated">这些接口的N参数的值应该是非负值。未来的改进可能会利用负N值来定义新的函数缓存行为。</target>
        </trans-unit>
        <trans-unit id="cc7bdc3b5bd50bd43536e1eeee3d4c188a48e335" translate="yes" xml:space="preserve">
          <source>The value of the change counter is copied to the database handle change counter (returned by subsequent calls to sqlite3_changes()). Then the VMs internal change counter resets to 0. This is used by trigger programs.</source>
          <target state="translated">变更计数器的值被复制到数据库句柄变更计数器(由后续调用sqlite3_changes()返回)。然后虚拟机内部的变更计数器重置为0,这被触发程序使用。</target>
        </trans-unit>
        <trans-unit id="4a5b194cd44f85aade16e1c37ccac8a115177304" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果没有发生sqlite3_backup_step（）错误，则无论sqlite3_backup_step（）是否完成，sqlite3_backup_finish返回的值为&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果在同一&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象上进行任何先前的sqlite3_backup_step（）调用期间发生了内存不足的情况或IO错误，则sqlite3_backup_finish（）返回相应的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8b2a631496d509ee2b275504f995fbe8e4ff87c" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果没有发生sqlite3_backup_step（）错误，则无论sqlite3_backup_step（）是否完成，sqlite3_backup_finish返回的值为&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果在同一&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象上进行任何先前的sqlite3_backup_step（）调用期间发生了内存不足的情况或IO错误，则sqlite3_backup_finish（）返回相应的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc51fa501b0d744e2b8200daac75839a3f391d4e" translate="yes" xml:space="preserve">
          <source>The values &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are properties of the application. If an application is constructed in such a way that both &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are known, or at least have known upper bounds, and if the application uses the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator and is provided with &lt;b&gt;N&lt;/b&gt; bytes of available memory space using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; then Robson proves that no memory allocation request will ever fail within the application. To put this another way, the application developer can select a value for &lt;b&gt;N&lt;/b&gt; that will guarantee that no call to any SQLite interface will ever return &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;. The memory pool will never become so fragmented that a new memory allocation request cannot be satisfied. This is an important property for applications where a software fault could cause injury, physical harm, or loss of irreplaceable data.</source>
          <target state="translated">值&lt;b&gt;M&lt;/b&gt;和&lt;b&gt;n&lt;/b&gt;是应用程序的属性。如果以&lt;b&gt;M&lt;/b&gt;和&lt;b&gt;n&lt;/b&gt;都已知或至少具有已知上限的方式构造应用程序，并且如果该应用程序使用&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;内存分配器并使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;提供了&lt;b&gt;N&lt;/b&gt;字节的可用内存空间，则罗布森证明没有内存分配请求将永远不会在应用程序内失败。换句话说，应用程序开发人员可以为&lt;b&gt;N&lt;/b&gt;选择一个值，该值将确保对任何SQLite接口的调用都不会返回&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM。&lt;/a&gt;&lt;b&gt;&lt;/b&gt;。内存池永远不会变得如此零散，以致无法满足新的内存分配请求。对于软件故障可能导致人身伤害，物理伤害或不可替代数据丢失的应用程序，这是重要的属性。</target>
        </trans-unit>
        <trans-unit id="22f534f2da25c6b7c05e8783b8e5bfbbc59c87e8" translate="yes" xml:space="preserve">
          <source>The values for each column in the record immediately follow the header. For serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns are of these types then the body section of the record is empty.</source>
          <target state="translated">记录中每一列的值紧随页眉之后。对于序列类型0、8、9、12和13,值的长度为零字节。如果所有列都是这些类型,那么记录的主体部分是空的。</target>
        </trans-unit>
        <trans-unit id="d128efd1de498da70d20d12d2513201d5001c97a" translate="yes" xml:space="preserve">
          <source>The values for each column of the row are stored in these columns. The &quot;.recover&quot; command creates the lost_and_found table with as many columns as required by the longest orphaned row.</source>
          <target state="translated">行的每一列的值都存储在这些列中。&quot;.recover &quot;命令创建了丢失和发现表,表的列数与最长的孤儿行所需的列数相同。</target>
        </trans-unit>
        <trans-unit id="fd6b2ec514a48d20f0372d7449abd69ec8081347" translate="yes" xml:space="preserve">
          <source>The values placed in the sqlite_stat1 table by an approximate ANALYZE are not exactly the same as what would be computed by an unrestricted analysis. But they are usually close enough. The index statistics in the sqlite_stat1 table are approximations in any case, so the fact that the results of an approximate ANALYZE are slightly different from a traditional full scan ANALYZE has little practical impact. It is possible to construct a pathological case where an approximate ANALYZE is noticeably inferior to a full-scan ANALYZE, but such cases rare in real-world problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61332fb4ed04580474ae395b4c8e0cfc53138b43" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;返回的值在字符串末尾不包含零终止符。为了清楚起见：&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;返回的值是字符串中的字节数，而不是字符数。</target>
        </trans-unit>
        <trans-unit id="56d75a71d4310cb50689d453693c130f5e211175" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;和&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;返回的值在字符串末尾不包含零终止符。为了清楚起见：&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;和&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;返回的值是字符串中的字节数，而不是字符数。</target>
        </trans-unit>
        <trans-unit id="9a34a413d802292386ca8ed35bad50613a2e40f9" translate="yes" xml:space="preserve">
          <source>The values returned by sqlite3_errcode() and/or sqlite3_extended_errcode() might change with each API call. Except, there are some interfaces that are guaranteed to never change the value of the error code. The error-code preserving interfaces are:</source>
          <target state="translated">sqlite3_errcode()和/或 sqlite3_extended_errcode()返回的值可能会随着每次API调用而改变。只不过,有一些接口是保证永远不会改变错误代码的值的。错误代码保存的接口有</target>
        </trans-unit>
        <trans-unit id="af0883b91a2c32edd6bb6e8adf9674294de318ba" translate="yes" xml:space="preserve">
          <source>The variable &lt;b&gt;$x&lt;/b&gt; is set by the above code to</source>
          <target state="translated">上面的代码将变量&lt;b&gt;$ x&lt;/b&gt;设置为</target>
        </trans-unit>
        <trans-unit id="e81b821adc588b80803661eb9435ef7daf5e77e6" translate="yes" xml:space="preserve">
          <source>The variable i in the previous expression varies between 0 and 9. Conceptually, the index space is divided into 10 uniform buckets and the samples are the middle row from each bucket.</source>
          <target state="translated">前面表达式中的变量i在0到9之间变化。从概念上讲,索引空间被分为10个统一的桶,样本是每个桶的中间一行。</target>
        </trans-unit>
        <trans-unit id="e46969b4d5144ef5a3ecc1c7c5e86080c0dd5e34" translate="yes" xml:space="preserve">
          <source>The various &lt;b&gt;sqlite_stat&lt;/b&gt;</source>
          <target state="translated">各种&lt;b&gt;sqlite_stat&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ea0a2ad541e7dfd246d5e09a98161b66d983211" translate="yes" xml:space="preserve">
          <source>The various SQLite Archive Archive commands are implemented using SQL statements. Application developers can easily add SQLite Archive Archive reading and writing support to their own projects by running the appropriate SQL.</source>
          <target state="translated">各种SQLite Archive Archive命令都是使用SQL语句实现的。应用程序开发人员可以通过运行适当的SQL语句,轻松地将SQLite Archive Archive读写支持添加到自己的项目中。</target>
        </trans-unit>
        <trans-unit id="22f8ca9c7ec1168dbb45b57fd3ebfbf3e9d60926" translate="yes" xml:space="preserve">
          <source>The various assert()-like macros behave differently according to how SQLite is built.</source>
          <target state="translated">各种类似 assert()的宏根据 SQLite 的构建方式而表现不同。</target>
        </trans-unit>
        <trans-unit id="8789a3da4f75d5b0392ef189d216e2c9312d1546" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="translated">各种UNIX VFS的区别仅在于它们处理文件锁定的方式不同-它们彼此共享大多数实现，并且都位于同一SQLite源文件&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c中&lt;/a&gt;。请注意，除了&amp;ldquo; unix&amp;rdquo;和&amp;ldquo; unix-excl&amp;rdquo;以外，各种UNIX VFS都使用不兼容的锁定实现。如果两个进程正在使用不同的unix VFS访问同一SQLite数据库，则它们可能看不到彼此的锁，并且最终可能会相互干扰，从而导致数据库损坏。特别是&amp;ldquo; unix-none&amp;rdquo; VFS根本没有锁定，如果同时由两个或多个数据库连接使用，则很容易导致数据库损坏。鼓励程序员仅使用&amp;ldquo; unix&amp;rdquo;或&amp;ldquo; unix-excl&amp;rdquo;除非有令人信服的理由否则。</target>
        </trans-unit>
        <trans-unit id="c5ffe5eea46cbcd5a1594ce73f72bf62a68d39e3" translate="yes" xml:space="preserve">
          <source>The versions of SQLite that come preinstalled on Apple Mac OS X computers contain a version of SQLite that has been extended to use alternative locking strategies that work on all network filesystems that Apple supports. These extensions used by Apple work great as long as all processes are accessing the database file in the same way. Unfortunately, the locking mechanisms do not exclude one another, so if one process is accessing a file using (for example) AFP locking and another process (perhaps on a different machine) is using dot-file locks, the two processes might collide because AFP locks do not exclude dot-file locks or vice versa.</source>
          <target state="translated">预装在苹果Mac OS X电脑上的SQLite版本包含了一个SQLite的版本,该版本已经扩展到使用替代锁定策略,可以在苹果支持的所有网络文件系统上工作。只要所有进程都以同样的方式访问数据库文件,苹果使用的这些扩展就非常好用。不幸的是,这些锁定机制并不相互排斥,因此,如果一个进程使用(例如)AFP锁定访问文件,而另一个进程(可能在不同的机器上)使用点文件锁定,这两个进程可能会发生碰撞,因为AFP锁定并不排斥点文件锁定,反之亦然。</target>
        </trans-unit>
        <trans-unit id="27a68965a58736f6647ab050fea465e20bf8ddef" translate="yes" xml:space="preserve">
          <source>The versions of the SQLite amalgamation that are supplied on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; are normally adequate for most users. However, some projects may want or need to build their own amalgamations. A common reason for building a custom amalgamation is in order to use certain &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; to customize the SQLite library. Recall that the SQLite amalgamation contains a lot of C-code that is generated by auxiliary programs and scripts. Many of the compile-time options effect this generated code and must be supplied to the code generators before the amalgamation is assembled. The set of compile-time options that must be passed into the code generators can vary from one release of SQLite to the next, but at the time of this writing (circa SQLite 3.6.20, 2009-11-04) the set of options that must be known by the code generators includes:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载页面&lt;/a&gt;上提供的SQLite合并版本通常适合大多数用户。但是，某些项目可能想要或需要构建自己的合并。建立自定义合并的常见原因是为了使用某些&lt;a href=&quot;compile&quot;&gt;编译时选项&lt;/a&gt;自定义SQLite库。回想一下，SQLite合并包含许多由辅助程序和脚本生成的C代码。许多编译时选项会影响此生成的代码，因此在组合合并之前必须将其提供给代码生成器。从一个版本的SQLite到下一个版本，必须传递给代码生成器的一组编译时选项可能会有所不同，但是在撰写本文时（大约在SQLite 3.6.20中，2009-11-04），这组选项代码生成器必须知道的内容包括：</target>
        </trans-unit>
        <trans-unit id="d08eefb01c3e7948c8ed07ad520422cff4b9225d" translate="yes" xml:space="preserve">
          <source>The very name &quot;Structured Query Language&quot; tells us that SQL should support nested queries. And, in fact, two different kinds of nesting are supported. Any SELECT statement that returns a single-row, single-column result can be used as a term in an expression of another SELECT statement. And, a SELECT statement that returns a single-column, multi-row result can be used as the right-hand operand of the IN and NOT IN operators. We will begin this section with an example of the first kind of nesting, where a single-row, single-column SELECT is used as a term in an expression of another SELECT. Here is our example:</source>
          <target state="translated">&quot;结构化查询语言 &quot;这个名字就告诉我们,SQL应该支持嵌套查询。而事实上,支持两种不同的嵌套。任何返回单行、单列结果的SELECT语句都可以作为另一条SELECT语句表达式中的术语。而且,一个返回单列、多行结果的SELECT语句可以作为IN和NOT IN操作符的右手操作数。我们将以第一种嵌套的例子开始本节,在这种嵌套中,一个单行、单列的SELECT被用作另一个SELECT表达式中的术语。下面是我们的例子。</target>
        </trans-unit>
        <trans-unit id="20c4a011c8e3b37249d4469eb52a0ff7a1d9c48e" translate="yes" xml:space="preserve">
          <source>The vfs query parameter causes the database connection to be opened using the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; called</source>
          <target state="translated">vfs查询参数导致使用称为&lt;a href=&quot;vfs&quot;&gt;VFS的VFS&lt;/a&gt;打开数据库连接</target>
        </trans-unit>
        <trans-unit id="7fc9c565eeb1c6123557989180ff5a163d06934e" translate="yes" xml:space="preserve">
          <source>The view to drop is identified by the view-name and optional schema-name specified as part of the DROP VIEW statement. This reference is resolved using the standard procedure for &lt;a href=&quot;lang_naming&quot;&gt;object resolution&lt;/a&gt;.</source>
          <target state="translated">要删除的视图由在DROP VIEW语句中指定的视图名称和可选模式名称标识。使用标准的&lt;a href=&quot;lang_naming&quot;&gt;对象解析&lt;/a&gt;程序可以解决此参考。</target>
        </trans-unit>
        <trans-unit id="3b2c6960eedc019bcf13fce258370b16a245ba89" translate="yes" xml:space="preserve">
          <source>The view v1 cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; because it is DISTINCT. It must instead be run as a subquery with the results being stored in a transient table, then the join is performed between t2 and the transient table. The push-down optimization pushes down the &quot;b BETWEEN 10 AND 20&quot; term into the view. This makes the transient table smaller, and helps the subquery to run faster if there is an index on t1.b. The resulting evaluation is like this:</source>
          <target state="translated">由于视图v1 是DISTINCT，因此无法将其展&lt;a href=&quot;optoverview#flattening&quot;&gt;平&lt;/a&gt;。相反，它必须作为子查询运行，并将结果存储在临时表中，然后在t2和临时表之间执行联接。下推式优化将&amp;ldquo; b介于10和20之间&amp;rdquo;的条件下推到视图中。这使临时表变小，并且如果t1.b上有索引，则有助于子查询更快地运行。结果评估如下：</target>
        </trans-unit>
        <trans-unit id="ce6b93653a867ff824a137b275a2d8a4b5929427" translate="yes" xml:space="preserve">
          <source>The virtual machine itself is entirely contained in a single source file &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt; header file defines an interface between the virtual machine and the rest of the SQLite library and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; which defines structures and interfaces that are private the virtual machine itself. Various other &lt;b&gt;vdbe*.c&lt;/b&gt; files are helpers to the virtual machine. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt; file contains utilities used by the virtual machine and interface modules used by the rest of the library to construct VM programs. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; file contains external interfaces to the virtual machine such as the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int()&lt;/a&gt; and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Individual values (strings, integer, floating point numbers, and BLOBs) are stored in an internal object named &quot;Mem&quot; which is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;.</source>
          <target state="translated">虚拟机本身完全包含在单个源文件&lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c中&lt;/a&gt;。所述&lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt;头文件定义了虚拟机和SQLite库的其余部分之间的界面&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt;其定义了私人虚拟机本身的结构和接口。其他各种&lt;b&gt;vdbe * .c&lt;/b&gt;文件都是虚拟机的帮助程序。所述&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt;文件包含由所用的库的其余部分来构造VM程序在虚拟机和接口模块中使用的工具。所述&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt;文件包含外部接口到所述虚拟机，如&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int（）&lt;/a&gt;和&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;。各个值（字符串，整数，浮点数和BLOB）存储在名为&amp;ldquo; Mem&amp;rdquo;的内部对象中，该对象由&lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="00bcd77d6dec3bc1a5f96c0e0f3985aefbea69f9" translate="yes" xml:space="preserve">
          <source>The virtual table contains an xShadowName method.</source>
          <target state="translated">该虚拟表包含一个xShadowName方法。</target>
        </trans-unit>
        <trans-unit id="aba94b8d1e25fe7120c464dc013b1d34868edb66" translate="yes" xml:space="preserve">
          <source>The virtual table mechanism allows an application to publish interfaces that are accessible from SQL statements as if they were tables. SQL statements can do almost anything to a virtual table that they can do to a real table, with the following exceptions:</source>
          <target state="translated">虚拟表机制允许应用程序发布接口,这些接口可以像表一样从SQL语句中访问。SQL语句几乎可以对虚拟表做任何它们可以对真实表做的事情,但有以下例外。</target>
        </trans-unit>
        <trans-unit id="7616eb3efb8cfc2b544466ae9f36f2a81289f276" translate="yes" xml:space="preserve">
          <source>The virtual table will return one row of output for each token in the input string. The &quot;token&quot; column is the text of the token. The &quot;start&quot; and &quot;end&quot; columns are the byte offset to the beginning and end of the token in the original input string. The &quot;position&quot; column is the sequence number of the token in the original input string. There is also an &quot;input&quot; column which is simply a copy of the input string that is specified in the WHERE clause. Note that a constraint of the form &quot;input=?&quot; must appear in the WHERE clause or else the virtual table will have no input to tokenize and will return no rows. The example above generates the following output:</source>
          <target state="translated">虚拟表将为输入字符串中的每个标记返回一行输出。token &quot;列是token的文本,&quot;start &quot;和 &quot;end &quot;列是原始输入字符串中token的开始和结束的字节偏移。开始 &quot;和 &quot;结束 &quot;列是原始输入字符串中标记的开始和结束的字节偏移量,&quot;位置 &quot;列是原始输入字符串中标记的序列号。位置 &quot;列是标记在原始输入字符串中的序列号。还有一个 &quot;input &quot;列,是WHERE子句中指定的输入字符串的副本。请注意,WHERE子句中必须出现 &quot;input=? &quot;这样的约束条件,否则虚拟表将没有输入标记,也不会返回任何记录。上面的例子会产生以下输出。</target>
        </trans-unit>
        <trans-unit id="e7d6d48d0123dd78c2ece991b5f7661cea292174" translate="yes" xml:space="preserve">
          <source>The wal-index file or &quot;shm&quot; file is not actually used as a file. Rather, individual database clients mmap the shm file and use it as shared memory for coordinating access to the database and as a cache for quickly locating frame within the wal file. The name of the shm file is the main database file name with the four characters &quot;-shm&quot; appended. Or, for 8+3 filesystems, the shm file is the main database file with the suffix changed to &quot;.SHM&quot;.</source>
          <target state="translated">wal-index文件或 &quot;shm &quot;文件实际上并不作为一个文件使用。相反,各个数据库客户端对shm文件进行mmap,并将其作为共享内存来协调对数据库的访问,并作为缓存来快速定位wal文件中的框架。shm文件的名称是主数据库文件名,后面附加&quot;-shm &quot;四个字符。或者,对于8+3文件系统,shm文件是主数据库文件,后缀改为&quot;.SHM&quot;。</target>
        </trans-unit>
        <trans-unit id="2705cff44fec902d1ca3ce2af3b554cabc339fb3" translate="yes" xml:space="preserve">
          <source>The wal-index file, usually named &quot;X-shm&quot;.</source>
          <target state="translated">wal-index文件,通常命名为 &quot;X-shm&quot;。</target>
        </trans-unit>
        <trans-unit id="3164ee82328b180dbc8289eddc9db733f9109901" translate="yes" xml:space="preserve">
          <source>The wal-index is transient. After a crash, the wal-index is reconstructed from the original WAL file. The VFS is required to either truncate or zero the header of the wal-index when the last connection to it closes. Because the wal-index is transient, it can use an architecture-specific format; it does not have to be cross-platform. Hence, unlike the database and WAL file formats which store all values as big endian, the wal-index stores multi-byte values in the native byte order of the host computer.</source>
          <target state="translated">wal-index是瞬时的。崩溃后,wal-index会从原来的WAL文件重建。当与wal-index的最后一个连接关闭时,VFS需要将wal-index的头截断或清零。因为wal-index是瞬时的,所以它可以使用特定架构的格式;它不一定要跨平台。因此,与数据库和WAL文件格式不同的是,wal-index以大英汉字存储所有的值,它以主机的本地字节顺序存储多字节的值。</target>
        </trans-unit>
        <trans-unit id="f37728360280f92c82e5f63eda2235cd3fe649d8" translate="yes" xml:space="preserve">
          <source>The wal_checkpoint pragma returns a single row with three integer columns. The first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing, for example because another thread or process was actively using the database. In other words, the first column is 0 if the equivalent call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; would have returned &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or 1 if the equivalent call would have returned &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. The second column is the number of modified pages that have been written to the write-ahead log file. The third column is the number of pages in the write-ahead log file that have been successfully moved back into the database file at the conclusion of the checkpoint. The second and third column are -1 if there is no write-ahead log, for example if this pragma is invoked on a database connection that is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">wal_checkpoint编译指示返回包含三列整数的单行。第一列通常为0，但是如果阻止RESTART或FULL或TRUNCATE检查点完成，则该列为1，例如，因为另一个线程或进程正在积极使用数据库。换句话说，如果对&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;的等效调用将返回&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_OK&lt;/a&gt;，则第一&lt;a href=&quot;rescode#ok&quot;&gt;列为&lt;/a&gt; 0；如果等效调用将返回SQLITE_BUSY，则第一列为 1。。第二列是已写入预写日志文件的已修改页数。第三列是预写日志文件中在检查点结束时已成功移回到数据库文件中的页面数。如果没有预写日志，例如，如果在非&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;的数据库连接上调用此编译指示，则第二列和第三列为-1 。</target>
        </trans-unit>
        <trans-unit id="7abca67d3b2f6649a3ed46e41721882b254d1af5" translate="yes" xml:space="preserve">
          <source>The way SQLite deals with this is to first run the inner SELECT (the one against examp2) and store its result in a private memory cell. SQLite then substitutes the value of this private memory cell for the inner SELECT when it evaluates the outer SELECT. The code looks like this:</source>
          <target state="translated">SQLite处理这个问题的方法是首先运行内部SELECT(针对examp2的那个),并将其结果存储在一个私有内存单元中。然后,SQLite在评估外层SELECT时,将这个私有内存单元的值替换为内部SELECT。代码看起来像这样。</target>
        </trans-unit>
        <trans-unit id="d9f0711eae8ce05c73449f6cd3513a09a5b0c229" translate="yes" xml:space="preserve">
          <source>The way in which the IN and NOT IN operators handle NULL values in their right-hand expressions has been brought into compliance with the SQL standard and with other SQL database engines.</source>
          <target state="translated">IN和NOT IN操作符在其右侧表达式中处理NULL值的方式已经符合SQL标准和其他SQL数据库引擎的要求。</target>
        </trans-unit>
        <trans-unit id="1bcbf2e1391b1aa7e3ebafdb83d7f3bc20c48ce0" translate="yes" xml:space="preserve">
          <source>The whole point of the xShadowName method is to protect the content of shadow tables from being corrupted by hostile SQL. Every virtual table implementation that uses shadow tables should be able to detect and cope with corrupted shadow table content. However, bugs in particular virtual table implementation might allow a deliberately corrupted shadow table to cause a crash or other malfunction. The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary SQL statements from deliberately corrupting shadow tables.</source>
          <target state="translated">xShadowName方法的全部意义在于保护影子表的内容不被敌对的SQL破坏。每个使用影子表的虚拟表实现都应该能够检测和应对损坏的影子表内容。但是,特定虚拟表实现中的bug可能会让故意损坏的影子表导致崩溃或其他故障。xShadowName机制旨在通过防止普通SQL语句故意破坏影子表来避免零日漏洞。</target>
        </trans-unit>
        <trans-unit id="7ba3625dd3002c676817bb5d0641f1c309f9b35c" translate="yes" xml:space="preserve">
          <source>The width field specifies the minimum width of the substituted value in the output. If the string or number that is written into the output is shorter than the width, then the value is padded. Padding is on the left (the value is right-justified) by default. If the &quot;-&quot; flag is used, then the padding is on the right and the value is left-justified.</source>
          <target state="translated">宽度字段指定了输出中替代值的最小宽度。如果写入输出的字符串或数字短于宽度,那么该值将被填充。默认情况下,填充是在左边(值是右对齐的)。如果使用&quot;-&quot;标志,那么填充是在右边,值是左对齐的。</target>
        </trans-unit>
        <trans-unit id="a12aad5ee5dbe2d3fff555e1c8b3c9090a69eb38" translate="yes" xml:space="preserve">
          <source>The width is measured in bytes by default. However, if the &quot;!&quot; flag is present then the width is in characters. This only makes a difference for multi-byte utf-8 characters, and those only occur on string substitutions.</source>
          <target state="translated">默认情况下,宽度以字节为单位。但是,如果有&quot;!&quot;标志,则宽度以字符为单位。这只对多字节utf-8字符有区别,而且这些字符只在字符串替换时出现。</target>
        </trans-unit>
        <trans-unit id="bb37fe25186c24e9c2d6b18924cc12e6bf999427" translate="yes" xml:space="preserve">
          <source>The word transliterated into lower-case ASCII. There is a standard table of mappings from non-ASCII characters into ASCII. Examples: &quot;&amp;aelig;&quot; -&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot; -&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot; -&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot; -&amp;gt; &quot;a&quot;, ... The accessory function spellfix1_translit(X) will do the non-ASCII to ASCII mapping. The built-in lower(X) function will convert to lower-case. Thus: k1 = lower(spellfix1_translit(word)). If the word is already all lower-case ASCII, then the k1 column will contain a NULL. This reduces the storage requirements for the %_vocab table and helps spellfix to run a little faster. Therefore, it is advantageous to populate as much of the spellfix table as possible using lower-case ASCII vocabulary.</source>
          <target state="translated">该单词已译为小写ASCII。有一个从非ASCII字符到ASCII的映射的标准表。例如：&amp;ldquo;&amp;aelig;&amp;rdquo;-&amp;gt;&amp;ldquo; ae&amp;rdquo;，&amp;ldquo;&amp;thorn;&amp;rdquo;-&amp;gt;&amp;ldquo; th&amp;rdquo;，&amp;ldquo;&amp;szlig;&amp;rdquo;-&amp;gt;&amp;ldquo; ss&amp;rdquo;，&amp;ldquo;&amp;aacute;&amp;rdquo;-&amp;gt;&amp;ldquo; a&amp;rdquo;，...辅助函数spellfix1_translit（X）将执行非ASCII到ASCII的映射。内置的lower（X）函数将转换为小写字母。因此：k1 = Lower（spellfix1_translit（word））。如果单词已经是全小写的ASCII，则k1列将包含NULL。这减少了％_vocab表的存储要求，并帮助spellfix运行得更快。因此，使用小写ASCII词汇表填充尽可能多的拼写修正表是有利的。</target>
        </trans-unit>
        <trans-unit id="2aea0dad5536afb073da7952899f42822308cf24" translate="yes" xml:space="preserve">
          <source>The working directory</source>
          <target state="translated">工作目录</target>
        </trans-unit>
        <trans-unit id="1191da9cfb737ab513b0974862b6931c34d468a3" translate="yes" xml:space="preserve">
          <source>The write-ahead log file, usually named &quot;X-wal&quot;.</source>
          <target state="translated">写入式日志文件,通常命名为 &quot;X-wal&quot;。</target>
        </trans-unit>
        <trans-unit id="aa76cd0207c05b41731ac87f189a853ae60f3634" translate="yes" xml:space="preserve">
          <source>The write-ahead log or &quot;wal&quot; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database. Details on the format of the wal file are describe in the &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL format&lt;/a&gt; subsection of the main &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The wal file is named by appending the four characters &quot;-wal&quot; to the end of the name of the main database file. Except on 8+3 filesystems, such names are not allowed, and in that case the file suffix is changed to &quot;.WAL&quot;. But as 8+3 filesystems are increasingly rare, that exceptional case can usually be ignored.</source>
          <target state="translated">预写日志或&amp;ldquo; wal&amp;rdquo;文件是前滚日志，记录已提交但尚未应用到主数据库的事务。有关wal文件格式的详细信息，请参见主&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档的&lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL格式&lt;/a&gt;小节。通过在主数据库文件名的末尾附加四个字符&amp;ldquo; -wal&amp;rdquo;来命名wal文件。除8 + 3文件系统外，不允许使用此类名称，在这种情况下，文件后缀将更改为&amp;ldquo; .WAL&amp;rdquo;。但是，随着8 + 3文件系统越来越稀有，通常可以忽略这种例外情况。</target>
        </trans-unit>
        <trans-unit id="9fcf91986e20f3838e989f19567544d31cd8c593" translate="yes" xml:space="preserve">
          <source>The writefile(X,Y) SQL function write the blob Y into the file named X and returns the number of bytes written. Use this function to extract the content of a single table column into a file. For example:</source>
          <target state="translated">writefile(X,Y)SQL函数将blob Y写入名为X的文件中,并返回写入的字节数。使用该函数可以将单个表列的内容提取到文件中。例如</target>
        </trans-unit>
        <trans-unit id="35efa113638256d189c7bffd527a8b95982adee0" translate="yes" xml:space="preserve">
          <source>The writing test above is not completely fair, since SQLite is doing &lt;a href=&quot;transactional&quot;&gt;power-safe transactions&lt;/a&gt; whereas the direct-to-disk writing is not. To put the tests on a more equal footing, add either the --nosync option to the SQLite writes to disable calling fsync() or FlushFileBuffers() to force content to disk, or using the --fsync option for the direct-to-disk tests to force them to invoke fsync() or FlushFileBuffers() when updating disk files.</source>
          <target state="translated">上面的写入测试并不完全公平，因为SQLite正在执行&lt;a href=&quot;transactional&quot;&gt;电源安全事务，&lt;/a&gt;而直接写入磁盘则不是。为了使测试更加平等，请在SQLite写入中添加--nosync选项以禁止调用fsync（）或FlushFileBuffers（）将内容强制插入磁盘，或将--fsync选项用于直接磁盘测试，以强制他们在更新磁盘文件时调用fsync（）或FlushFileBuffers（）。</target>
        </trans-unit>
        <trans-unit id="3500eedb790da60f6c7c2c2fe42347161ad2dc7e" translate="yes" xml:space="preserve">
          <source>The xAccess method is used to check for access permissions on a file. The filename will be UTF-8 encoded. The flags argument will be &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to check for the existence of the file, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to check to see if the file is both readable and writable, or &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to check to see if the file is at least readable. The &quot;file&quot; named by the second parameter might be a directory or folder name.</source>
          <target state="translated">xAccess方法用于检查文件的访问权限。文件名将采用UTF-8编码。flags参数将是&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;来检查文件是否存在，&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;来检查文件是否可读和可写，或&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;来检查文件是否至少可读。第二个参数命名的&amp;ldquo;文件&amp;rdquo;可能是目录名或文件夹名。</target>
        </trans-unit>
        <trans-unit id="7e3dceb3a3d82f8b52bd7f5b2f951ed3b0619691" translate="yes" xml:space="preserve">
          <source>The xAccess() method is invoked again to detect if the journal file is still in the file system. If it is, then it is a hot-journal file and SQLite tries to roll it back (see section</source>
          <target state="translated">再次调用xAccess()方法来检测日志文件是否还在文件系统中。如果在,那么它就是一个热日志文件,SQLite会尝试将其回滚(见第2节</target>
        </trans-unit>
        <trans-unit id="be1521ac61f6da801d0f89ccb40ef26362bd2aea" translate="yes" xml:space="preserve">
          <source>The xAccess() method of the VFS is allowed to return -1 to signal a memory allocation error.</source>
          <target state="translated">VFS的xAccess()方法允许返回-1,以提示内存分配错误。</target>
        </trans-unit>
        <trans-unit id="dbb116d3015d148d9aef4ab4eaf91f8dc7699911" translate="yes" xml:space="preserve">
          <source>The xBestIndex function may have requested the values of certain expressions using the aConstraintUsage[].argvIndex values of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. Those values are passed to xFilter using the argc and argv parameters.</source>
          <target state="translated">xBestIndex函数可能已使用&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构的aConstraintUsage []。argvIndex值请求了某些表达式的值。这些值使用argc和argv参数传递到xFilter。</target>
        </trans-unit>
        <trans-unit id="e673068c08d7f626c7139b66b363abe588afdbfb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method fills the idxNum and idxStr fields with information that communicates an indexing strategy to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. The information in idxNum and idxStr is arbitrary as far as the SQLite core is concerned. The SQLite core just copies the information through to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. Any desired meaning can be assigned to idxNum and idxStr as long as xBestIndex and xFilter agree on what that meaning is.</source>
          <target state="translated">xBestIndex方法使用将索引策略传达给&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法的信息填充idxNum和idxStr字段。就SQLite核心而言，idxNum和idxStr中的信息是任意的。SQLite核心仅将信息复制到&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法。只要xBestIndex和xFilter同意该含义，就可以将任何期望的含义分配给idxNum和idxStr。</target>
        </trans-unit>
        <trans-unit id="7549b2c421b13b6947674708c7a5360fc1373a57" translate="yes" xml:space="preserve">
          <source>The xBestIndex method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xBestIndex方法。</target>
        </trans-unit>
        <trans-unit id="6671b4241ef5e4b25933598f6cbd513b0faa9c69" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag - SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite assumes that the strategy may visit at most one row.</source>
          <target state="translated">xBestIndex 方法可以选择用 SQLITE_INDEX_SCAN_*标志的掩码来填充 idxFlags 字段,目前只有一个这样的标志-SQLITE_INDEX_SCAN_UNIQUE。目前只有一个这样的标志--SQLITE_INDEX_SCAN_UNIQUE。如果xBestIndex方法设置了这个标志,SQLite就会认为该策略最多只能访问一条记录。</target>
        </trans-unit>
        <trans-unit id="60dc1bff84d7b24ecf260c549a70a2e550acd608" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may set aConstraintUsage[].argvIndex entries to values greater than zero. Exactly one entry should be set to 1, another to 2, another to 3, and so forth up to as many or as few as the xBestIndex method wants. The EXPR of the corresponding constraints will then be passed in as the argv[] parameters to xFilter.</source>
          <target state="translated">xBestIndex方法可以将aConstraintUsage[].argvIndex条目设置为大于0的值。确切地说,一个条目应该设置为1,另一个条目设置为2,另一个条目设置为3,以此类推,xBestIndex方法想要多少就有多少。相应约束条件的EXPR将作为argv[]参数传递给xFilter。</target>
        </trans-unit>
        <trans-unit id="b0c67bb7b3ba635b9cd74ad89d5155e843f934eb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method should return SQLITE_OK on success. If any kind of fatal error occurs, an appropriate error code (ex: &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;) should be returned instead.</source>
          <target state="translated">如果成功，xBestIndex方法应返回SQLITE_OK。如果发生任何类型的致命错误，则应返回适当的错误代码（例如：&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6e2147722085d4c968213130f4ef993a32c73b66" translate="yes" xml:space="preserve">
          <source>The xBestIndex method will be invoked once for each of the potential plans above. For plan 1, the aConstraint[].usable flag for for the SQLITE_CONSTRAINT_EQ constraint on the param1 column will be true because the right-hand side value for the &quot;param1 = ?&quot; constraint will be known, since it is determined by the outer realtab loop. But for plan 2, the aConstraint[].usable flag for &quot;param1 = ?&quot; will be false because the right-hand side value is determined by an inner loop and is thus an unknown quantity. Because param1 is a required input to the table-valued functions, the xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2, indicating that a required input is missing. This forces the query planner to select plan 1.</source>
          <target state="translated">xBestIndex方法将为上述每个潜在计划调用一次。对于计划1,对于param1列上的SQLITE_CONSTRAINT_EQ约束的aConstraint[].usable标志将为真,因为 &quot;param1=? &quot;约束的右侧值将是已知的,因为它是由外部realtab循环决定的。但是对于计划2,&quot;param1=?&quot;的aConstraint[].usable标志将为false,因为右侧的值是由内部循环决定的,因此是一个未知量。因为param1是表值函数的必要输入,所以当呈现计划2时,xBestIndex方法应该返回SQLITE_CONSTRAINT,表示缺少一个必要的输入。这就迫使查询规划器选择计划1。</target>
        </trans-unit>
        <trans-unit id="c5e6a28d9d92d2bf9deb3f28a367d165a9d141f6" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">SQLite可以随时调用xCachesize（）方法来设置建议的最大缓存大小（作为第一个参数传递的缓存实例）的最大缓存大小（存储的页面数）。这是使用SQLite&amp;ldquo; &lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &amp;rdquo;命令配置的值。与bPurgeable参数一样，实现不需要使用此值做任何事情；它仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="64860c154593114b929547aef1bfe359a445dd93" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">SQLite可以随时调用xCachesize（）方法来设置建议的最大缓存大小（作为第一个参数传递的缓存实例）的最大缓存大小（存储的页面数）。这是使用SQLite&amp;ldquo; &lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &amp;rdquo;命令配置的值。与bPurgeable参数一样，实现不需要使用此值做任何事情；它仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="76bfcc9d387b84934d7209d1ccf2568a52cae2ff" translate="yes" xml:space="preserve">
          <source>The xCheckReservedLock() method checks to see if another connection or another process is currently holding a reserved, pending, or exclusive lock on the file. It returns true or false.</source>
          <target state="translated">xCheckReservedLock()方法检查另一个连接或另一个进程当前是否在文件上持有保留、待定或独占的锁。它返回true或false。</target>
        </trans-unit>
        <trans-unit id="5108534fb3c98c994a35c533b42cb72d472a86d4" translate="yes" xml:space="preserve">
          <source>The xClose method closes a cursor previously opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The SQLite core will always call xClose once for each cursor opened using xOpen.</source>
          <target state="translated">xClose方法关闭以前由&lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;打开的游标。对于使用xOpen打开的每个游标，SQLite核心将始终调用一次xClose。</target>
        </trans-unit>
        <trans-unit id="a1fcaec496244ffb2502893506be9bff99222ddb" translate="yes" xml:space="preserve">
          <source>The xClose method closes the file. The space for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure is deallocated by the caller. But if the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains pointers to other allocated memory or resources, those allocations should be released by the xClose method.</source>
          <target state="translated">xClose方法关闭文件。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;结构的空间由调用方释放。但是，如果&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;包含指向其他已分配内存或资源的指针，则应通过xClose方法释放这些分配。</target>
        </trans-unit>
        <trans-unit id="2af5d67c2c34fed358127148fe670412a17ae024" translate="yes" xml:space="preserve">
          <source>The xClose method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xClose方法。</target>
        </trans-unit>
        <trans-unit id="57537332c9edcb104197db5e7bb9793f5df28547" translate="yes" xml:space="preserve">
          <source>The xColumn method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xColumn方法。</target>
        </trans-unit>
        <trans-unit id="ef93eeb561a6057de6700b4a7eda4c4170148438" translate="yes" xml:space="preserve">
          <source>The xColumnSize API always returns -1. There is no way to determine the number of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.</source>
          <target state="translated">xColumnSize API总是返回-1。无法确定配置为 columnsize=0 的无内容 FTS5 表内存储的值中的令牌数。</target>
        </trans-unit>
        <trans-unit id="9e2d00478c87bed4be4b97709f42f53211a90ec1" translate="yes" xml:space="preserve">
          <source>The xConnect method is required for every virtual table implementation, though the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and xConnect pointers of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; object may point to the same function if the virtual table does not need to initialize backing store.</source>
          <target state="translated">尽管虚拟表不需要初始化后备存储，但&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;对象的&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和xConnect指针可能指向同一函数，但每个虚拟表实现都需要使用xConnect方法。</target>
        </trans-unit>
        <trans-unit id="3a84b2667247b1e27fdcdd3d4cc56221f573c090" translate="yes" xml:space="preserve">
          <source>The xConnect method is very similar to &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;. It has the same parameters and constructs a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure just like xCreate. And it must also call &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; like xCreate.</source>
          <target state="translated">xConnect方法与&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;非常相似。它具有相同的参数，并像xCreate一样构造一个新的&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;结构。并且它还必须像xCreate一样调用&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ec50befd1d20d9f6756f231c4255cc685afba32" translate="yes" xml:space="preserve">
          <source>The xConnect method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">该xConnect方法必须返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;如果成功创建新的虚拟表，或&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果它不成功。如果未成功，则不得分配&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;结构。如果失败，则可以选择在* pzErr中返回错误消息。必须使用SQLite内存分配函数（例如&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（））&lt;/a&gt;分配用于保存错误消息字符串的空间，因为在将错误报告给应用程序之后，SQLite核心将尝试使用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放空间。</target>
        </trans-unit>
        <trans-unit id="6920f3a6545664c297cabaad1f1d797cb28640a2" translate="yes" xml:space="preserve">
          <source>The xCreate and xConnect methods are only different when the virtual table has some kind of backing store that must be initialized the first time the virtual table is created. The xCreate method creates and initializes the backing store. The xConnect method just connects to an existing backing store. When xCreate and xConnect are the same, the table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;.</source>
          <target state="translated">仅当虚拟表具有某种必须在首次创建虚拟表时初始化的后备存储时，xCreate和xConnect方法才不同。 xCreate方法创建并初始化后备存储。 xConnect方法仅连接到现有的后备存储。当xCreate和xConnect相同时，该表是&lt;a href=&quot;vtab#epovtab&quot;&gt;同义的虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dcf39a347f064ec02d2e007cec689340fd805ffc" translate="yes" xml:space="preserve">
          <source>The xCreate method is called to create a new instance of a virtual table in response to a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If the xCreate method is the same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, then the virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;. If the xCreate method is omitted (if it is a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;.</source>
          <target state="translated">调用xCreate方法以创建虚拟表的新实例，以响应&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句。如果xCreate方法是相同的指针作为&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法，则虚拟表是一个&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;。如果省略xCreate方法（如果它是NULL指针），则虚拟表是&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;仅&lt;/a&gt;具有别名的虚拟表。</target>
        </trans-unit>
        <trans-unit id="7fa820ae673d5a152c6735ecfbe5a6902d1afc09" translate="yes" xml:space="preserve">
          <source>The xCreate method need not initialize the pModule, nRef, and zErrMsg fields of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object. The SQLite core will take care of that chore.</source>
          <target state="translated">xCreate方法不需要初始化&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象的pModule，nRef和zErrMsg字段。SQLite核心将负责这项工作。</target>
        </trans-unit>
        <trans-unit id="06c7e419a8719bf400eb11e6ddbab813f843fcfc" translate="yes" xml:space="preserve">
          <source>The xCreate should return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">该xCreate应该返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;如果成功创建新的虚拟表，或&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果它不成功。如果未成功，则不得分配&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;结构。如果失败，则可以选择在* pzErr中返回错误消息。必须使用SQLite内存分配函数（例如&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（））&lt;/a&gt;分配用于保存错误消息字符串的空间，因为在将错误报告给应用程序之后，SQLite核心将尝试使用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放空间。</target>
        </trans-unit>
        <trans-unit id="f958ace0be88d27965e6fd7b0b417f1f44eb7a29" translate="yes" xml:space="preserve">
          <source>The xCurrentTime method finds the current time and date and writes the result as a double-precision floating point value into pointer provided by the second parameter. The time and date is in coordinated universal time (UTC) and is a fractional Julian day number.</source>
          <target state="translated">xCurrentTime方法找到当前时间和日期,并将结果作为一个双精度浮点值写入第二个参数提供的指针中。时间和日期是以协调的世界时(UTC)为单位,是一个小数的朱利安日数。</target>
        </trans-unit>
        <trans-unit id="6df2a95b2c02a08ca9301c1af593f076dcec3de1" translate="yes" xml:space="preserve">
          <source>The xDelete callback, if one is specified, is also invoked on the auxiliary data pointer after the FTS5 query has finished.</source>
          <target state="translated">如果指定了xDelete回调,在FTS5查询结束后,也会对辅助数据指针进行调用。</target>
        </trans-unit>
        <trans-unit id="684db9583b8006f9c3587ed123a3291e36233a15" translate="yes" xml:space="preserve">
          <source>The xDelete method in the built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now return SQLITE_IOERR_DELETE_NOENT if the file to be deleted does not exist.</source>
          <target state="translated">在内置的xDelete方法&lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;现在回到SQLITE_IOERR_DELETE_NOENT如果要删除的文件不存在。</target>
        </trans-unit>
        <trans-unit id="8acbdfc184b8627360b75ab194ff6c7691155e56" translate="yes" xml:space="preserve">
          <source>The xDelete method is used to delete a file. The name of the file is given in the second parameter. The filename will be in UTF-8. The VFS must convert the filename into whatever character representation the underlying operating system expects. If the syncDir parameter is true, then the xDelete method should not return until the change to the directory contents for the directory containing the deleted file have been synced to disk in order to ensure that the file does not &quot;reappear&quot; if a power failure occurs soon after.</source>
          <target state="translated">xDelete方法用于删除一个文件。文件的名称在第二个参数中给出。文件名将是UTF-8格式。VFS必须将文件名转换成底层操作系统期望的任何字符表示。如果syncDir参数为真,那么xDelete方法不应该返回,直到包含被删除文件的目录内容的变化已经同步到磁盘上,以确保文件不会在断电后不久就 &quot;重新出现&quot;。</target>
        </trans-unit>
        <trans-unit id="11b2a4e02961f3a81754bcacd1c2618edac811a1" translate="yes" xml:space="preserve">
          <source>The xDestroy callback is &lt;u&gt;not&lt;/u&gt; called if the sqlite3_create_collation_v2() function fails. Applications that invoke sqlite3_create_collation_v2() with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them. This is different from every other SQLite interface. The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.</source>
          <target state="translated">如果sqlite3_create_collat​​ion_v2（）函数失败，则&lt;u&gt;不会&lt;/u&gt;调用xDestroy回调。调用带有非NULL xDestroy参数的sqlite3_create_collat​​ion_v2（）的应用程序应检查返回代码并自行处理应用程序数据指针，而不是期望SQLite为它们处理。这不同于其他所有SQLite接口。不一致是不幸的，但是在不破坏向后兼容性的情况下就无法更改。</target>
        </trans-unit>
        <trans-unit id="82fcb2416a6d15ad9c7eed2868bb3c1083659be9" translate="yes" xml:space="preserve">
          <source>The xDestroy method is required for every virtual table implementation, though it is acceptable for the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; and xDestroy methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">尽管对于特定的虚拟表有意义，但&lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt;和xDestroy方法可以使用相同的功能，但每个虚拟表实现都需要使用xDestroy方法。</target>
        </trans-unit>
        <trans-unit id="433eafbb64ee6df6fcf2cd0863165758dd2318f2" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy（）方法用于删除xCreate（）分配的缓存。与指定的缓存关联的所有资源都应释放。调用xDestroy（）方法后，SQLite认为&lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt;句柄无效，并且不会与任何其他sqlite3_pcache_methods2函数一起使用。</target>
        </trans-unit>
        <trans-unit id="8baf35611bcad0c5db55f35fee163e2aa0c149e9" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy（）方法用于删除xCreate（）分配的缓存。与指定的缓存关联的所有资源都应释放。调用xDestroy（）方法后，SQLite认为&lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt;句柄无效，并且不会与任何其他sqlite3_pcache_methods2函数一起使用。</target>
        </trans-unit>
        <trans-unit id="604385447aab898766cb3896d8016d04ab97fc0d" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xDeviceCharacteristics方法返回一个整数，该整数是这些位值的向量，这些值表示保存&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods所&lt;/a&gt;引用文件的大容量存储设备的I / O特性。</target>
        </trans-unit>
        <trans-unit id="b98ec973b9735d7dd446dd0f56fe3b7eb0a27d7c" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xDeviceCharacteristics方法返回一个整数，该整数是这些位值的向量，这些值表示保存&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods所&lt;/a&gt;引用文件的大容量存储设备的I / O特性。</target>
        </trans-unit>
        <trans-unit id="c2e8466b1e208836960d6bb4f90ed3ea7832fd67" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method returns an integer bit vector that defines any special properties that the underlying storage medium might have that SQLite can use to increase performance. The allowed return is the bit-wise OR of the following values:</source>
          <target state="translated">xDeviceCharacteristics方法返回一个整数位向量,它定义了底层存储介质可能具有的、SQLite可以用来提高性能的任何特殊属性。允许的返回值是以下值的位宽OR。</target>
        </trans-unit>
        <trans-unit id="1262b3501d52f25dbe2da92b37772cb17c293d40" translate="yes" xml:space="preserve">
          <source>The xDisconnect method is required for every virtual table implementation, though it is acceptable for the xDisconnect and &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">尽管对于特定的虚拟表有意义，但xDisconnect和&lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt;方法可以使用相同的功能，但每个虚拟表实现都需要使用xDisconnect方法。</target>
        </trans-unit>
        <trans-unit id="80202d349ad4d59a55548ad8afd689feeefba61b" translate="yes" xml:space="preserve">
          <source>The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing shared libraries at run-time. These methods may be omitted (and their pointers set to zero) if the library is compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; or if the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface is never used to enable dynamic extension loading. The xDlOpen method opens a shared library or DLL and returns a pointer to a handle. NULL is returned if the open fails. If the open fails, the xDlError method can be used to obtain a text error message. The message is written into the zErrMsg buffer of the third parameter which is at least nByte bytes in length. The xDlSym returns a pointer to a symbol in the shared library. The name of the symbol is given by the second parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer is returned. The xDlClose routine closes the shared library.</source>
          <target state="translated">xDlOpen，xDlError，xDlSym和xDlClose方法都用于在运行时访问共享库。如果使用&lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt;编译库，或者如果&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（），&lt;/a&gt;则可以忽略这些方法（它们的指针设置为零）。接口从不用于启用动态扩展加载。 xDlOpen方法将打开共享库或DLL，并返回指向句柄的指针。如果打开失败，则返回NULL。如果打开失败，则可以使用xDlError方法获取文本错误消息。该消息将写入第三个参数的zErrMsg缓冲区，该缓冲区的长度至少为nByte个字节。 xDlSym返回一个指向共享库中符号的指针。符号的名称由第二个参数给出。假设采用UTF-8编码。如果找不到该符号，则返回NULL指针。 xDlClose例程关闭共享库。</target>
        </trans-unit>
        <trans-unit id="2a328c23f376e27049c3463e790fd30ea24be07c" translate="yes" xml:space="preserve">
          <source>The xEof method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xEof方法。</target>
        </trans-unit>
        <trans-unit id="2f524de9f6418ba3f20971cbbb6e678439f267fb" translate="yes" xml:space="preserve">
          <source>The xEof method must return false (zero) if the specified cursor currently points to a valid row of data, or true (non-zero) otherwise. This method is called by the SQL engine immediately after each &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; and &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; invocation.</source>
          <target state="translated">如果指定的游标当前指向有效的数据行，则xEof方法必须返回false（零），否则返回true（非零）。每次&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;和&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;调用之后，SQL引擎都会立即调用此方法。</target>
        </trans-unit>
        <trans-unit id="31055a962a7bb13c9dfa534ee5cb14dc7402ab08" translate="yes" xml:space="preserve">
          <source>The xFetch() method locates a page in the cache and returns a pointer to an sqlite3_pcache_page object associated with that page, or a NULL pointer. The pBuf element of the returned sqlite3_pcache_page object will be a pointer to a buffer of szPage bytes used to store the content of a single database page. The pExtra element of sqlite3_pcache_page will be a pointer to the szExtra bytes of extra storage that SQLite has requested for each entry in the page cache.</source>
          <target state="translated">xFetch()方法在缓存中定位一个页面,并返回一个指向与该页面相关联的 sqlite3_pcache_page 对象的指针,或者一个 NULL 指针。返回的 sqlite3_pcache_page 对象的 pBuf 元素将是一个指向 szPage 字节的缓冲区的指针,用于存储单个数据库页面的内容。sqlite3_pcache_page的pExtra元素将是一个指针,指向SQLite为页面缓存中的每个条目请求的额外存储的szExtra字节。</target>
        </trans-unit>
        <trans-unit id="eec30896c07568e6756a1fd11de9a9be38006b51" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the (new and experimental) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer which is intended to be a pointer to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves opcodes less than 100 for its own use. A &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts.</source>
          <target state="translated">xFileControl（）方法是一个通用接口，允许自定义VFS实现使用（新的和实验性的）&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口直接控制打开的文件。第二个&amp;ldquo; op&amp;rdquo;参数是整数操作码。第三个参数是通用指针，旨在用作指向结构的指针，该结构可能包含要在其中写入返回值的参数或空间。 xFileControl（）的潜在用途可能是启用超时锁定功能，更改锁定策略（例如，使用点文件锁定），查询锁定状态或破坏陈旧锁定的功能。 SQLite核心保留少于100的操作码供自己使用。一个&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;操作码的列表&lt;/a&gt;少于100个可用。定义自定义xFileControl方法的应用程序应使用大于100的操作码以避免冲突。</target>
        </trans-unit>
        <trans-unit id="dddf7acfafd6d3f8269f8f981d3bcbe57970b96a" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl（）方法是一个通用接口，允许自定义VFS实现使用&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口直接控制打开的文件。第二个&amp;ldquo; op&amp;rdquo;参数是整数操作码。第三个参数是通用指针，旨在指向一个结构，该结构可能包含在其中写入返回值的参数或空间。xFileControl（）的潜在用途可能是启用超时锁定功能，更改锁定策略（例如，使用点文件锁定），查询锁定状态或破坏陈旧锁定的功能。SQLite核心保留所有少于100个操作码供自己使用。一个&lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;操作码的列表&lt;/a&gt;少于100个可用。定义自定义xFileControl方法的应用程序应使用大于100的操作码以避免冲突。 VFS实现应为无法识别的文件控制操作码返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cff0bc514819c033ff2d05910e11b13ceab5fce" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl（）方法是一个通用接口，允许自定义VFS实现使用&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口直接控制打开的文件。第二个&amp;ldquo; op&amp;rdquo;参数是整数操作码。第三个参数是通用指针，旨在指向一个结构，该结构可能包含在其中写入返回值的参数或空间。xFileControl（）的潜在用途可能是启用超时锁定功能，更改锁定策略（例如，使用点文件锁定），查询锁定状态或破坏陈旧锁定的功能。SQLite核心保留所有少于100个操作码供自己使用。一个&lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;操作码的列表&lt;/a&gt;少于100个可用。定义自定义xFileControl方法的应用程序应使用大于100的操作码以避免冲突。 VFS实现应为无法识别的文件控制操作码返回&lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3203c926180842d31c782d904c037633ddf2f91f" translate="yes" xml:space="preserve">
          <source>The xFileSize() method determines the current size of the file in bytes and writes that value into *pSize. It returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; if something goes wrong.</source>
          <target state="translated">xFileSize（）方法确定文件的当前大小（以字节为单位），并将该值写入* pSize。它返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt;如果出现错误。</target>
        </trans-unit>
        <trans-unit id="96653ab4bb654a8e871b1a8c14aa48716aadb8ae" translate="yes" xml:space="preserve">
          <source>The xFilter method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xFilter方法。</target>
        </trans-unit>
        <trans-unit id="4479f4bd625e3440b28fa60e755d9671817cfbcf" translate="yes" xml:space="preserve">
          <source>The xFullPathname method is used to convert a relative pathname into a full pathname. The resulting full pathname is written into the buffer provided by the third parameter. SQLite will size the output buffer to at least mxPathname bytes. Both the input and output names should be in UTF-8.</source>
          <target state="translated">xFullPathname方法用于将相对路径名转换为完整路径名。产生的完整路径名被写入第三个参数提供的缓冲区。SQLite将把输出缓冲区的大小至少定为mxPathname字节。输入和输出名称都应该是UTF-8格式。</target>
        </trans-unit>
        <trans-unit id="5dbd41bd881211c13a1dbbcb8c736851e1bf5d97" translate="yes" xml:space="preserve">
          <source>The xGeom callback always does a depth-first search of the r-tree.</source>
          <target state="translated">xGeom回调总是对r树进行深度优先搜索。</target>
        </trans-unit>
        <trans-unit id="454e11b15802805175a3b539debe13d361beb72d" translate="yes" xml:space="preserve">
          <source>The xGetTempName method computes the name of a temporary file that SQLite can use. The name should be written into the buffer given by the second parameter. SQLite will size that buffer to hold at least mxPathname bytes. The generated filename should be in UTF-8. To avoid security problems, the generated temporary filename should contain enough randomness to prevent an attacker from guessing the temporary filename in advance.</source>
          <target state="translated">xGetTempName方法计算SQLite可以使用的临时文件的名称。该名称应该被写入第二个参数给出的缓冲区中。SQLite将把该缓冲区的大小确定为至少能容纳mxPathname字节。生成的文件名应该是UTF-8格式的。为了避免安全问题,生成的临时文件名应该包含足够的随机性,以防止攻击者提前猜测临时文件名。</target>
        </trans-unit>
        <trans-unit id="5d25f32f0f944f020730e420a59b761837d6fa20" translate="yes" xml:space="preserve">
          <source>The xGetTempname method has been removed from &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. In its place, the xOpen method is enhanced to open a temporary file of its own invention when the filename parameter is NULL.</source>
          <target state="translated">xGetTempname方法已从&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs中&lt;/a&gt;删除。当文件名参数为NULL时，增强了xOpen方法以打开自己的发明的临时文件。</target>
        </trans-unit>
        <trans-unit id="e9de98bc73bd358a33146535bc6a4c0838edf0ac" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit方法初始化内存分配器。例如，它可能分配任何必需的互斥对象或初始化内部数据结构。 xShutdown方法由&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;调用（间接），并且应取消分配xInit获取的所有资源。 pAppData指针用作xInit和xShutdown的唯一参数。</target>
        </trans-unit>
        <trans-unit id="3fa9fa67f04b6378191cf480be2d31d4ea4b3e4c" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit方法初始化内存分配器。例如，它可能分配任何必需的互斥对象或初始化内部数据结构。 xShutdown方法由&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;调用（间接），并且应取消分配xInit获取的所有资源。 pAppData指针用作xInit和xShutdown的唯一参数。</target>
        </trans-unit>
        <trans-unit id="b5977e9a51901888e399d44616a096c8dd4ad36a" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b210b9a34cdea6b00c84f118c3818052de5137" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928f04710edbd4aadd8a60154ed8a2e307eed0ef" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">每次对&lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize（）的&lt;/a&gt;有效调用都会调用一次xInit（）方法（通常在该过程的生命周期内仅调用一次）。向xInit（）方法传递了sqlite3_pcache_methods2.pArg值的副本。 xInit（）方法的目的是设置自定义页面缓存实现所需的全局数据结构。如果xInit（）方法为NULL，则使用内置的默认页面缓存而不是应用程序定义的页面缓存。</target>
        </trans-unit>
        <trans-unit id="6ba32c8d759124102ccc057ecbe6a0c1c85fb3b5" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">每次对&lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize（）的&lt;/a&gt;有效调用都会调用一次xInit（）方法（通常在该过程的生命周期内仅调用一次）。向xInit（）方法传递了sqlite3_pcache_methods2.pArg值的副本。 xInit（）方法的目的是设置自定义页面缓存实现所需的全局数据结构。如果xInit（）方法为NULL，则使用内置的默认页面缓存而不是应用程序定义的页面缓存。</target>
        </trans-unit>
        <trans-unit id="8a32ff6fcc7d9e120e222fe6ef8bbf8b9661df8a" translate="yes" xml:space="preserve">
          <source>The xLock and xUnlock methods are used to set and clear file locks. SQLite supports five levels of file locks, in order:</source>
          <target state="translated">xLock和xUnlock方法用于设置和清除文件锁。SQLite支持五级文件锁,依次为:1:</target>
        </trans-unit>
        <trans-unit id="8a5c74b276f4ba001214e303873304b1cefc6f0e" translate="yes" xml:space="preserve">
          <source>The xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.</source>
          <target state="translated">xMalloc、xRealloc和xFree方法必须像标准C库中的malloc()、realloc()和free()函数一样工作。SQLite保证xRealloc的第二个参数始终是之前调用xRoundup返回的值。</target>
        </trans-unit>
        <trans-unit id="f3c67d901eafc4b8170f137f64b1ed5325131c31" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_shutdown（）函数在系统关闭过程中调用此结构定义的xMutexEnd方法。预期此方法的实现将释放通过互斥方法实现而获得的所有出色资源，尤其是通过xMutexInit方法获得的资源。对于&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）的&lt;/a&gt;每次调用，xMutexEnd（）接口仅被调用一次。</target>
        </trans-unit>
        <trans-unit id="29460abd69ce976afdb57bd86f856a912e6b2129" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_shutdown（）函数在系统关闭过程中调用此结构定义的xMutexEnd方法。预期此方法的实现将释放通过互斥方法实现而获得的所有出色资源，尤其是通过xMutexInit方法获得的资源。对于&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）的&lt;/a&gt;每次调用，xMutexEnd（）接口仅被调用一次。</target>
        </trans-unit>
        <trans-unit id="cd4f06c8938e3564cfbf224eac3d8cf5b5b06a0d" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">由sqlite3_initialize（）函数调用此结构定义的xMutexInit方法作为系统初始化的一部分。对于每次对&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）的&lt;/a&gt;有效调用，SQLite均只调用一次xMutexInit例程。</target>
        </trans-unit>
        <trans-unit id="dab4cb79a586f29424445d440e5fffbfe8ba4495" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">由sqlite3_initialize（）函数调用此结构定义的xMutexInit方法作为系统初始化的一部分。对于每次对&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）的&lt;/a&gt;有效调用，SQLite均只调用一次xMutexInit例程。</target>
        </trans-unit>
        <trans-unit id="89ac720acef7b2cd1f40cadc5a9b4008a6051773" translate="yes" xml:space="preserve">
          <source>The xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.</source>
          <target state="translated">xMutexInit()方法必须是线程安全的,在同一进程中多次调用xMutexInit()必须是无害的。在同一进程中多次调用xMutexInit()必须是无害的,并且不需要中间调用xMutexEnd()。对xMutexInit()的第二次和后续调用必须是无操作的。</target>
        </trans-unit>
        <trans-unit id="35cc67c51c972e7defc85a2cd19b646cf64aa418" translate="yes" xml:space="preserve">
          <source>The xNext method advances a &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; to the next row of a result set initiated by &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;. If the cursor is already pointing at the last row when this routine is called, then the cursor no longer points to valid data and a subsequent call to the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; method must return true (non-zero). If the cursor is successfully advanced to another row of content, then subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero).</source>
          <target state="translated">xNext方法将&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;虚拟表光标移到&lt;/a&gt;&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;初始化的结果集的下一行。如果在调用此例程时游标已经指向最后一行，则游标不再指向有效数据，并且随后对&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;方法的调用必须返回true（非零）。如果光标成功前进到另一行内容，则随后对&lt;a href=&quot;vtab#xeof&quot;&gt;xEof的&lt;/a&gt;调用必须返回false（零）。</target>
        </trans-unit>
        <trans-unit id="c07bbf2e5005e8108d2f1c166d0b989d5b0ef5de" translate="yes" xml:space="preserve">
          <source>The xNext method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xNext方法。</target>
        </trans-unit>
        <trans-unit id="eee0d952c4251db31a384eceabf2a26d2118eb4d" translate="yes" xml:space="preserve">
          <source>The xOpen method creates a new cursor used for accessing (read and/or writing) a virtual table. A successful invocation of this method will allocate the memory for the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (or a subclass), initialize the new object, and make *ppCursor point to the new object. The successful call then returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">xOpen方法创建用于访问（读取和/或写入）虚拟表的新游标。成功调用此方法将为&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;（或子类）分配内存，初始化新对象，并使* ppCursor指向新对象。成功的调用然后返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00b35252e3240b77ad5fc35ac862013d23c8ea89" translate="yes" xml:space="preserve">
          <source>The xOpen method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xOpen方法。</target>
        </trans-unit>
        <trans-unit id="fe219d8e760e2d5872424a8a4fa6980f7d9bd820" translate="yes" xml:space="preserve">
          <source>The xOpen method need not initialize the pVtab field of the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure. The SQLite core will take care of that chore automatically.</source>
          <target state="translated">xOpen方法不需要初始化&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;结构的pVtab字段。SQLite核心将自动处理该琐事。</target>
        </trans-unit>
        <trans-unit id="5883a2e08ea426f3d0e98ebbcc84b207e43eeb5d" translate="yes" xml:space="preserve">
          <source>The xOutput callback is invoked zero or more times to return data to the application. The first parameter passed to each call is a copy of the pOut pointer supplied by the application. The second parameter, pData, points to a buffer nData bytes in size containing the chunk of output data being returned. If the xOutput callback successfully processes the supplied data, it should return SQLITE_OK to indicate success. Otherwise, it should return some other SQLite error code. In this case processing is immediately abandoned and the streaming API function returns a copy of the xOutput error code to the application.</source>
          <target state="translated">xOutput回调被调用零次或多次,以返回数据给应用程序。传递给每次调用的第一个参数是应用程序提供的pOut指针的副本。第二个参数pData指向一个缓冲区nData字节大小的数据,其中包含要返回的输出数据块。如果xOutput回调成功地处理了所提供的数据,它应该返回SQLITE_OK来表示成功。否则,它应该返回一些其他SQLite错误代码。在这种情况下,处理会被立即放弃,并且流式API函数会将xOutput错误代码的副本返回给应用程序。</target>
        </trans-unit>
        <trans-unit id="4fdec734fe0825d4b45223206e7ef21a40dca7d6" translate="yes" xml:space="preserve">
          <source>The xPagecount() method must return the number of pages currently stored in the cache, both pinned and unpinned.</source>
          <target state="translated">xPagecount()方法必须返回当前存储在缓存中的页数,包括钉入和未钉入的页数。</target>
        </trans-unit>
        <trans-unit id="f7670800549df532ce782308a5027526fc2bbf4f" translate="yes" xml:space="preserve">
          <source>The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether or not the bounding box defined by aCoord[] is completely outside the region, overlaps the region, or is completely inside the region, respectively. In addition, the xQueryFunc must set the rScore field to a non-negative value that indicates the order in which subtrees and entries of the query should be analyzed and returned. Smaller scores are processed first.</source>
          <target state="translated">xQueryFunc必须将sqlite3_rtree_query_info的eWithin字段设置为NOT_WITHIN、PARTLY_WITHIN或FULLY_WITHIN中的一个值,分别取决于aCoord[]定义的边界框是否完全在区域之外、是否与区域重叠或是否完全在区域之内。此外,xQueryFunc必须将rScore字段设置为一个非负值,该值表示应分析和返回查询的子树和条目的顺序。较小的分数会被优先处理。</target>
        </trans-unit>
        <trans-unit id="243e65d787818469363333eb640b0b44f38c6ec4" translate="yes" xml:space="preserve">
          <source>The xRandomness method is used exactly once to initialize the pseudo-random number generator (PRNG) inside of SQLite. Only the xRandomness method on the default VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite. The xRandomness routine requests that nByte bytes of randomness be written into zOut. The routine returns the actual number of bytes of randomness obtained. The quality of the randomness so obtained will determine the quality of the randomness generated by built-in SQLite functions such as random() and randomblob(). SQLite also uses its PRNG to generate temporary file names. On some platforms (ex: Windows) SQLite assumes that temporary file names are unique without actually testing for collisions, so it is important to have good-quality randomness even if the random() and randomblob() functions are never used.</source>
          <target state="translated">xRandomness方法只用于初始化SQLite内部的伪随机数生成器(PRNG)一次。只有默认VFS上的xRandomness方法被使用。其他VFS上的xRandomness方法永远不会被SQLite访问。xRandomness例程请求将nByte字节的随机性写入zOut中。该例程返回获得随机性的实际字节数。这样得到的随机性的质量将决定由内置的SQLite函数如random()和randomblob()生成的随机性的质量。SQLite还使用它的PRNG来生成临时文件名。在某些平台上(例如:Windows),SQLite假定临时文件名是唯一的,而没有实际测试碰撞,因此即使从未使用过random()和randomblob()函数,获得高质量的随机性也很重要。</target>
        </trans-unit>
        <trans-unit id="2203fe5d9da94fc2d593e73757d6951b646a5aac" translate="yes" xml:space="preserve">
          <source>The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.</source>
          <target state="translated">xRandomness()、xSleep()、xCurrentTime()和xCurrentTimeInt64()接口并不是严格意义上的文件系统的一部分,但为了完整性,它们被包含在VFS结构中。xRandomness()函数试图向zOut返回nBytes字节的优质随机性。返回值是获得随机性的实际字节数。xSleep()方法会使调用线程至少在给定的微秒数内睡眠。xCurrentTime()方法以浮点值的形式返回当前日期和时间的朱利安日数。xCurrentTimeInt64()方法以整数形式返回Julian Day Number乘以86400000(一天24小时中的毫秒数)。如果xCurrentTimeInt64()方法可用,SQLite将使用该方法来获取当前的日期和时间(如果iVersion是2或更大,并且函数指针不是NULL),如果xCurrentTimeInt64()不可用,则将返回到xCurrentTime()。</target>
        </trans-unit>
        <trans-unit id="9578c347ea12c88b2a68bb1b8891cc899dd6f688" translate="yes" xml:space="preserve">
          <source>The xRead method reads iAmt bytes from the file beginning at a byte offset to iOfst. The data read is stored in the pointer of the second parameter. xRead returns the &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; if it was not able to read the full number of bytes because it reached end-of-file, or &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; for any other error.</source>
          <target state="translated">xRead方法从文件读取到iOfst的字节偏移量开始的iAmt字节。读取的数据存储在第二个参数的指针中。 xRead返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功，&lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt;如果它是不能够阅读完整的字节数，因为它达到结束的文件，或者&lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt;任何其他错误。</target>
        </trans-unit>
        <trans-unit id="179305437ddf972de11f25d6c031548629b7dbeb" translate="yes" xml:space="preserve">
          <source>The xRekey() method is used to change the key value associated with the page passed as the second argument. If the cache previously contains an entry associated with newKey, it must be discarded. Any prior cache entry associated with newKey is guaranteed not to be pinned.</source>
          <target state="translated">xRekey()方法用于改变与作为第二个参数传递的页面相关联的键值。如果缓存中之前包含了一个与newKey相关联的条目,那么它必须被丢弃。任何之前与newKey相关联的缓存条目保证不会被钉住。</target>
        </trans-unit>
        <trans-unit id="ee97077a16637439ff4f073f89fa74d3ae66efba" translate="yes" xml:space="preserve">
          <source>The xRename method is optional. If omitted, then the virtual table may not be renamed using the ALTER TABLE RENAME command.</source>
          <target state="translated">xRename方法是可选的,如果省略,那么就不能使用ALTER TABLE RENAME命令重命名虚拟表。如果省略,那么就不能使用ALTER TABLE RENAME命令重命名虚拟表。</target>
        </trans-unit>
        <trans-unit id="ac1529fc1db9096e5e7532c56994cf7e11a7e7d4" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundup方法返回给定特定请求大小的内存分配的分配大小。大多数内存分配器将内存分配至少舍入到8的下一个整数倍。某些内存分配器将舍入到更大的整数倍或2的幂。每个通过&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;传入的内存分配请求都首先调用xRoundup。如果xRoundup返回0，则导致相应的内存分配失败。</target>
        </trans-unit>
        <trans-unit id="5558ee9f292501795b089dc2d3175bf349258bae" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundup方法返回给定特定请求大小的内存分配的分配大小。大多数内存分配器将内存分配至少舍入到8的下一个整数倍。某些内存分配器将舍入到更大的整数倍或2的幂。每个通过&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;传入的内存分配请求都首先调用xRoundup。如果xRoundup返回0，则导致相应的内存分配失败。</target>
        </trans-unit>
        <trans-unit id="ac776ca96c027496fe8cb024585d72e01e0bde03" translate="yes" xml:space="preserve">
          <source>The xRowid method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xRowid方法。</target>
        </trans-unit>
        <trans-unit id="f91951a49d3cd2a19053a4c5034726651d8bcc0a" translate="yes" xml:space="preserve">
          <source>The xSectorSize returns the &quot;sector size&quot; of the underlying non-volatile media. A &quot;sector&quot; is defined as the smallest unit of storage that can be written without disturbing adjacent storage. On a disk drive the &quot;sector size&quot; has until recently been 512 bytes, though there is a push to increase this value to 4KiB. SQLite needs to know the sector size so that it can write a full sector at a time, and thus avoid corrupting adjacent storage space if a power loss occurs in the middle of a write.</source>
          <target state="translated">xSectorSize 返回底层非易失性介质的 &quot;扇区大小&quot;。一个 &quot;扇区 &quot;被定义为在不干扰相邻存储的情况下可以写入的最小存储单位。在磁盘驱动器上,&quot;扇区大小 &quot;直到最近都是512字节,尽管有一种趋势是将这个值增加到4KiB。SQLite需要知道扇区大小,这样才能一次写入一个完整的扇区,从而避免在写入过程中发生断电时破坏相邻的存储空间。</target>
        </trans-unit>
        <trans-unit id="7905596593f9a3650933e2dff7d4278590e16d18" translate="yes" xml:space="preserve">
          <source>The xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:</source>
          <target state="translated">xSectorSize()方法返回文件底层设备的扇区大小。该扇区大小是在不干扰文件中其他字节的情况下可以执行的最小写。xDeviceCharacteristics()方法返回一个描述底层设备行为的位向量。</target>
        </trans-unit>
        <trans-unit id="c28ec934424705226c30dba3dc7fb3bbb1c98c66" translate="yes" xml:space="preserve">
          <source>The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.</source>
          <target state="translated">xSetSystemCall()、xGetSystemCall()和xNestSystemCall()接口不被SQLite核心使用。这些可选的接口是由一些VFSes提供的,以方便对VFS代码的测试。通过用其控制下的函数覆盖系统调用,测试程序可以模拟出原本难以或无法诱发的故障和错误条件。可以重写的系统调用集因VFS而异,也因同一VFS的不同版本而异。使用这些接口的应用程序必须为这些接口中的任何或所有接口为 NULL 或为它们的行为从一个版本到下一个版本的变化做好准备。如果VFS的iVersion小于3,应用程序不得尝试访问任何这些方法。</target>
        </trans-unit>
        <trans-unit id="5423cabb179d0301d2f1838406af9e345543b685" translate="yes" xml:space="preserve">
          <source>The xShadowName method exists to allow SQLite to determine whether a certain real table is in fact a shadow table for a virtual table.</source>
          <target state="translated">xShadowName方法的存在是为了让SQLite确定某个实表是否真的是虚拟表的影子表。</target>
        </trans-unit>
        <trans-unit id="947c2bf35d5cbfd4ce5579dacd8c602d7123b2d2" translate="yes" xml:space="preserve">
          <source>The xShadowName method returns true when its input is the part of the table name past the last &quot;_&quot; character.</source>
          <target state="translated">当它的输入是表名最后一个&quot;_&quot;字符之后的部分时,xShadowName方法返回true。</target>
        </trans-unit>
        <trans-unit id="bb9ed2671c0267a52c772896119a40dfbdf41d3e" translate="yes" xml:space="preserve">
          <source>The xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.</source>
          <target state="translated">xShmLock方法可以在解锁和SHARED之间或在解锁和EXCLUSIVE之间转换。它不能在SHARED和EXCLUSIVE之间转换。</target>
        </trans-unit>
        <trans-unit id="3b138a7b2ca75c6da01e38d919aae9bc4beaeeca" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;上的xShmLock方法可以使用0到此上限之间的值作为其&amp;ldquo;偏移&amp;rdquo;参数。SQLite核心绝不会尝试获取或释放超出此范围的锁</target>
        </trans-unit>
        <trans-unit id="99e14d7c5dc9f436dda83c4868de4dcfa29aa8e2" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;上的xShmLock方法可以使用0到此上限之间的值作为其&amp;ldquo;偏移&amp;rdquo;参数。SQLite核心绝不会尝试获取或释放超出此范围的锁</target>
        </trans-unit>
        <trans-unit id="c9d6171767cbe080777a834fc404f8313c3bd7a0" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown（）方法由&lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;调用。如果需要，它可以用来在进程关闭之前清除所有未使用的资源。xShutdown（）方法可以为NULL。</target>
        </trans-unit>
        <trans-unit id="89b517d093efdb5642222dcbac94dd78a355996a" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown（）方法由&lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;调用。如果需要，它可以用来在进程关闭之前清除所有未使用的资源。xShutdown（）方法可以为NULL。</target>
        </trans-unit>
        <trans-unit id="809b6a168241db65edee19e686edd4e9bd3b2bfa" translate="yes" xml:space="preserve">
          <source>The xSleep method is used to suspend the calling thread for at least the number of microseconds given. This method is used to implement the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; APIs. In the case of &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; the xSleep method of the default VFS is always used. If the underlying system does not have a microsecond resolution sleep capability, then the sleep time should be rounded up. xSleep returns this rounded-up value.</source>
          <target state="translated">xSleep方法用于将调用线程挂起至少给定的微秒数。此方法用于实现&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;和&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt; API。对于&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;，始终使用默认VFS的xSleep方法。如果底层系统没有微秒分辨率的睡眠功能，则睡眠时间应四舍五入。xSleep返回此舍入值。</target>
        </trans-unit>
        <trans-unit id="097b3f659c15f2c222834063189d1813c9097500" translate="yes" xml:space="preserve">
          <source>The xSync method is called again, to ensure that the update to the</source>
          <target state="translated">xSync方法再次被调用,以确保更新到了</target>
        </trans-unit>
        <trans-unit id="c43866c10fb70246bff455fcc260272ec7695054" translate="yes" xml:space="preserve">
          <source>The xSync method is used to force previously written data out of operating system cache and into non-volatile memory. The second parameter is usually &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;. If the second parameter is &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; then the xSync method should make sure that data has also been flushed through the disk controllers cache. The &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; parameter is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xSync方法用于将先前写入的数据从操作系统缓存中强制出并进入非易失性内存。第二个参数通常是&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;。如果第二个参数是&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL，&lt;/a&gt;则xSync方法应确保还通过磁盘控制器高速缓存刷新了数据。该&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;参数是相当于在Mac OS X上XSYNC方法返回F_FULLSYNC的ioctl（）的&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt;如果有什么差错。</target>
        </trans-unit>
        <trans-unit id="d363e92ec2dbc091f6f79c8b02f677c3bfbb4dc4" translate="yes" xml:space="preserve">
          <source>The xSync method of the file-handle opened on the journal file is called. This operation ensures that all</source>
          <target state="translated">日志文件上打开的文件柄的xSync方法被调用。该操作确保所有的</target>
        </trans-unit>
        <trans-unit id="2abc7e1d2661195eacab3734a083049181c96938" translate="yes" xml:space="preserve">
          <source>The xTruncate method truncates a file to be nByte bytes in length. If the file is already nByte bytes or less in length then this method is a no-op. The xTruncate method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xTruncate方法将文件截断为nByte字节长。如果文件的长度已经是nByte字节或更小，则此方法为无操作。该xTruncate方法返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt;如果有什么差错。</target>
        </trans-unit>
        <trans-unit id="264cd9fc05e84b4a4186bdf81ed3b9dddd14f364" translate="yes" xml:space="preserve">
          <source>The xUpdate method is optional. If the xUpdate pointer in the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; for a virtual table is a NULL pointer, then the virtual table is read-only.</source>
          <target state="translated">xUpdate方法是可选的。如果&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module中&lt;/a&gt;用于虚拟表的xUpdate指针是NULL指针，则该虚拟表是只读的。</target>
        </trans-unit>
        <trans-unit id="e7991b9300a6d5d1e9dd517f980e91bd729b810d" translate="yes" xml:space="preserve">
          <source>The xUpdate method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if it is successful. If a failure occurs, the xUpdate must return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. On a failure, the pVTab-&amp;gt;zErrMsg element may optionally be replaced with error message text stored in memory allocated from SQLite using functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;.</source>
          <target state="translated">仅当成功时，xUpdate方法必须返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果发生故障，则xUpdate必须返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。如果发生故障，可以使用诸如&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;或&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）之类的&lt;/a&gt;函数将pVTab-&amp;gt; zErrMsg元素替换为从SQLite分配的内存中存储的错误消息文本。</target>
        </trans-unit>
        <trans-unit id="4f4c20f5295bf2671dba3e7fbec564fd71238ee3" translate="yes" xml:space="preserve">
          <source>The xUpdate method will do a DELETE or an INSERT or both. The argv[0] element (which corresponds to memory cell P3) is the rowid of a row to delete. If argv[0] is NULL then no deletion occurs. The argv[1] element is the rowid of the new row. This can be NULL to have the virtual table select the new rowid for itself. The subsequent elements in the array are the values of columns in the new row.</source>
          <target state="translated">xUpdate方法将进行DELETE或INSERT操作,或者同时进行这两种操作。argv[0]元素(对应于内存单元格P3)是要删除的记录的rowid。如果 argv[0]为 NULL,那么就不会进行删除。argv[1]元素是新行的行名。这个元素可以是NULL,让虚拟表为自己选择新的行名。数组中的后续元素是新行中列的值。</target>
        </trans-unit>
        <trans-unit id="dce6593181b88387e0232c4fe3315ea114b78c31" translate="yes" xml:space="preserve">
          <source>The xWrite method writes iAmt bytes of data from the second parameter into the file beginning at an offset of iOfst bytes. If the size of the file is less than iOfst bytes prior to the write, then xWrite should ensure that the file is extended with zeros up to iOfst bytes prior to beginning its write. xWrite continues to extends the file as necessary so that the size of the file is at least iAmt+iOfst bytes at the conclusion of the xWrite call. The xWrite method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If the write cannot complete because the underlying storage medium is full, then &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; is returned. &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; should be returned for any other error.</source>
          <target state="translated">xWrite方法将第二个参数的iAmt字节数据从iOfst字节的偏移量开始写入文件中。如果在写入之前文件的大小小于iOfst字节，则xWrite应该确保在开始写入之前，使用零将文件扩展到iOfst字节。 xWrite继续根据需要扩展文件，以便在xWrite调用结束时文件的大小至少为iAmt + iOfst字节。 xWrite方法成功返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果由于基础存储介质已满而无法完成写入，则返回&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;。对于其他任何错误，应返回&lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d58a45ae0f446bdb86db23efea40a4365e8b2411" translate="yes" xml:space="preserve">
          <source>The zFormat string must not be NULL.</source>
          <target state="translated">zFormat字符串不能为NULL。</target>
        </trans-unit>
        <trans-unit id="4f80fc797d2d3e861743d9ee1212caa09c71f3bc" translate="yes" xml:space="preserve">
          <source>The zName field holds the name of the VFS module. The name must be unique across all VFS modules.</source>
          <target state="translated">zName字段保存VFS模块的名称。该名称在所有VFS模块中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="2e8507d62c194c1ae3ea2e8955ca09d80822bd5b" translate="yes" xml:space="preserve">
          <source>The zName field is the symbolic name of the VFS. This is the name that the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; compares against when it is looking for a VFS.</source>
          <target state="translated">zName字段是VFS的符号名称。这是&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;在查找VFS时要与之比较的名称。</target>
        </trans-unit>
        <trans-unit id="159171a13f5482b6256b050c73e581c3c1ed7fde" translate="yes" xml:space="preserve">
          <source>The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt;. This SQL function is implemented using the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; routine from the C/C++ interface.</source>
          <target state="translated">zeroblob（N）函数返回一个BLOB，该BLOB由N个0x00字节组成。SQLite非常有效地管理这些零点。Zeroblob可用于为BLOB保留空间，该空间随后使用&lt;a href=&quot;c3ref/blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;写入。此SQL函数是使用C / C ++接口中的&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob（）&lt;/a&gt;例程实现的。</target>
        </trans-unit>
        <trans-unit id="211680c2a7f3cd39edd65730ba2dc5798231d4d2" translate="yes" xml:space="preserve">
          <source>The zipfile module provides read/write access to simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archives&lt;/a&gt;. The current implementation has the following restrictions:</source>
          <target state="translated">zipfile模块提供对简单&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP归档文件的&lt;/a&gt;读/写访问。当前的实现有以下限制：</target>
        </trans-unit>
        <trans-unit id="1b7b70776cb9a79f5d42a047fb481e44592ef0cc" translate="yes" xml:space="preserve">
          <source>The zipfile module provides three similar interfaces for accessing, updating and creating zip file archives:</source>
          <target state="translated">zipfile模块为访问、更新和创建压缩文件档案提供了三个类似的界面。</target>
        </trans-unit>
        <trans-unit id="a3bf102cd7b1098b918321543923b0fbcf9afd25" translate="yes" xml:space="preserve">
          <source>The zipfile module provides two similar interfaces for accessing zip archives. A table-valued function, which provides read-only access to existing archives, and a virtual table interface, which provides both read and write access.</source>
          <target state="translated">zipfile模块提供了两个类似的访问zip存档的接口。一个是表值函数,它提供了对现有档案的只读访问,另一个是虚拟表接口,它提供了读和写两种访问方式。</target>
        </trans-unit>
        <trans-unit id="7f26831f509249abeae6c04bd252c7253425a19e" translate="yes" xml:space="preserve">
          <source>The zipfile() aggregate function may be called with 2, 4 or 5 arguments. If it is called with 5 arguments, then the entry added to the archive is equivalent to inserting the same values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot; and &quot;method&quot; columns of a zipfile virtual table.</source>
          <target state="translated">zipfile()聚合函数可以用2、4或5个参数来调用。如果调用5个参数,那么添加到归档中的条目就相当于在zipfile虚拟表中的 &quot;name&quot;、&quot;mode&quot;、&quot;mtime&quot;、&quot;data &quot;和 &quot;method &quot;列中插入相同的值。</target>
        </trans-unit>
        <trans-unit id="fda3c54068d6592ac94595a28e9ae2b5a7631d94" translate="yes" xml:space="preserve">
          <source>Then any query that uses operators =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;, IN, LIKE, or GLOB on column &quot;c&quot; would be usable with the partial index because those comparison operators are only true if &quot;c&quot; is not NULL. So the following query could use the partial index:</source>
          <target state="translated">然后，对列&amp;ldquo; c&amp;rdquo;使用运算符=，&amp;lt;，&amp;gt;，&amp;lt;=，&amp;gt; =，&amp;lt;&amp;gt;，IN，LIKE或GLOB的任何查询都可与部分索引一起使用，因为这些比较运算符仅在&amp;ldquo; c&amp;rdquo;为真时才为true不为NULL。因此，以下查询可以使用部分索引：</target>
        </trans-unit>
        <trans-unit id="d38e46789e87cb85236cff516beec8a98a69642c" translate="yes" xml:space="preserve">
          <source>Then continue to merge the changes in &quot;trunk&quot; with your &quot;private&quot; changes as described in section 3.7.</source>
          <target state="translated">然后继续将 &quot;trunk &quot;中的更改与 &quot;private &quot;中的更改合并,如3.7节所述。</target>
        </trans-unit>
        <trans-unit id="4221ef1a5952683847cd93186bb995482d485923" translate="yes" xml:space="preserve">
          <source>Then creating &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt; in that schema that implement the official information schema tables using table-valued PRAGMA functions.</source>
          <target state="translated">然后在该模式中创建&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;，以使用表值PRAGMA函数实现正式信息模式表。</target>
        </trans-unit>
        <trans-unit id="24143dcd35d1fb5f0ef327aba489cfb57e18e5f5" translate="yes" xml:space="preserve">
          <source>Then download the new version of the SQLite sources and overwrite the files that are in the checkout.</source>
          <target state="translated">然后下载新版的SQLite源码,覆盖结账中的文件。</target>
        </trans-unit>
        <trans-unit id="350d0a66ff74448747b37fd69238737bb7294306" translate="yes" xml:space="preserve">
          <source>Then either of the two queries below may be executed to find the number of documents in the database that contain the word &quot;linux&quot; (351). Using one desktop PC hardware configuration, the query on the FTS3 table returns in approximately 0.03 seconds, versus 22.5 for querying the ordinary table.</source>
          <target state="translated">然后可以执行下面两个查询中的任何一个查询,以查找数据库中含有 &quot;linux &quot;一词的文档数量(351)。使用一台台式电脑的硬件配置,对FTS3表的查询大约在0.03秒内返回,而对普通表的查询则需要22.5秒。</target>
        </trans-unit>
        <trans-unit id="dec93deaca5432fc2b3655d16d3eb7b184d40788" translate="yes" xml:space="preserve">
          <source>Then for each &quot;id&quot; value returned, suppose the application creates an UPDATE statement like the following and binds the &quot;id&quot; value returned against the &quot;?1&quot; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72f2d807bd1572c917e30647dff75353e7ffc89" translate="yes" xml:space="preserve">
          <source>Then let the application maintain a separate pool of larger lookaside memory buffers that it can distribute to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; as they are created. In the common case, the application will only have a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and so the lookaside memory pool can consist of a single large buffer.</source>
          <target state="translated">然后，让应用程序维护一个单独的较大后备内存缓冲区池，在创建它们时可以将其分配给&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。在通常情况下，应用程序将只有一个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;，因此后备内存池可以由单个大缓冲区组成。</target>
        </trans-unit>
        <trans-unit id="13bc76c23a2d1597cb4fa248a96e4ed2a6339b15" translate="yes" xml:space="preserve">
          <source>Then one of the constraints would be on the &quot;a&quot; column with operator &quot;=&quot; and an expression of &quot;5&quot;. Constraints need not have a literal representation of the WHERE clause. The query optimizer might make transformations to the WHERE clause in order to extract as many constraints as it can. So, for example, if the WHERE clause contained something like this:</source>
          <target state="translated">那么其中一个约束条件将是在 &quot;a &quot;列上,操作符为&quot;=&quot;,表达式为 &quot;5&quot;。约束不需要有WHERE子句的字面表示。查询优化器可能会对WHERE子句进行转换,以便提取尽可能多的约束条件。因此,例如,如果WHERE子句包含这样的内容。</target>
        </trans-unit>
        <trans-unit id="a6d85a4cee37097aa0048aa17c7e903390d7845d" translate="yes" xml:space="preserve">
          <source>Then run &quot;sh speed-check.sh trunk&quot;.</source>
          <target state="translated">然后运行 &quot;sh speed-check.sh trunk&quot;。</target>
        </trans-unit>
        <trans-unit id="5af7ca0994a03bba6845a3d09f85ba03527c6bbf" translate="yes" xml:space="preserve">
          <source>Then that term is rewritten as follows:</source>
          <target state="translated">那么,该术语重写如下:</target>
        </trans-unit>
        <trans-unit id="89cb6c0dfe329a7ee49493775fd34d7651a1097e" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. But if an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="translated">然后，LIKE运算符会注意大小写，并且上面的示例将评估为false。请注意，不区分大小写仅适用于latin1字符-基本上是ASCII的低127个字节代码中英文的大小写字母。国际字符集在SQLite中区分大小写，除非提供的应用程序定义的&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）SQL函数&lt;/a&gt;考虑了非ASCII字符。但是，如果提供了应用程序定义的整理序列和/或like（）SQL函数，将永远不会采用此处描述的LIKE优化。</target>
        </trans-unit>
        <trans-unit id="be60a7454a5a8c066c86b3ca9b68995e4f6f1ddf" translate="yes" xml:space="preserve">
          <source>Then the RBU database should contain:</source>
          <target state="translated">那么,区域局的数据库应该包含:</target>
        </trans-unit>
        <trans-unit id="afb35789040d9830a99208d5f4ddcf476245eb59" translate="yes" xml:space="preserve">
          <source>Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is that the initial query has not run to completion. It is remembering its place in the middle of a scan of the R-Tree. So an update to the R-Tree cannot be tolerated as this would disrupt the scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996a8ef99f82edf5bb93411418cadd30d4e95347" translate="yes" xml:space="preserve">
          <source>Then the generated SQL will look like the following:</source>
          <target state="translated">那么生成的SQL就会像下面这样。</target>
        </trans-unit>
        <trans-unit id="0e329a491713b53943766e19e0cd3bc2370d4353" translate="yes" xml:space="preserve">
          <source>Then the index is usable by the query because the &quot;b=6&quot; term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</source>
          <target state="translated">那么这个索引是可以被查询使用的,因为 &quot;b=6 &quot;这个术语同时出现在索引定义和查询中。记住:索引中的术语应该是OR连接的,而查询中的术语应该是AND连接的。</target>
        </trans-unit>
        <trans-unit id="2efe4248a37f7b9e147bfa69326ac21ae4833059" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the *=* or *IN* or *IS* operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="translated">那么,如果索引的初始列(a列、b列等)出现在WHERE子句术语中,就可以使用索引。索引的初始列必须使用*=*或*IN*或*IS*运算符。使用的最右边的列可以采用不等式。对于使用的索引最右边的列,最多可以有两个不等式,这些不等式必须将该列的允许值夹在两个极端之间。</target>
        </trans-unit>
        <trans-unit id="f563dfd5bcb7f2cd99d04f3adadee6fc2e0e90d8" translate="yes" xml:space="preserve">
          <source>Then the index will &lt;u&gt;not&lt;/u&gt; be used because the expression on the CREATE INDEX statement (x+y) is not the same as the expression as it appears in the query (y+x). The two expressions might be mathematically equivalent, but the SQLite query planner insists that they be the same, not merely equivalent. Consider rewriting the query thusly:</source>
          <target state="translated">然后将&lt;u&gt;不&lt;/u&gt;使用索引，因为CREATE INDEX语句（x + y）上的表达式与查询（y + x）中出现的表达式不同。这两个表达式在数学上可能是等效的，但SQLite查询计划程序坚持认为它们是相同的，而不仅仅是等效的。考虑这样重写查询：</target>
        </trans-unit>
        <trans-unit id="faa0b455785c0547f03cc054aee1b96482863f25" translate="yes" xml:space="preserve">
          <source>Then the locking mode applies only to the named database. If no database name qualifier precedes the &quot;locking_mode&quot; keyword then the locking mode is applied to all databases, including any new databases added by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands.</source>
          <target state="translated">然后，锁定模式仅适用于命名数据​​库。如果在&amp;ldquo; locking_mode&amp;rdquo;关键字之前没有数据库名称限定符，则锁定模式将应用于所有数据库，包括由后续&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令添加的任何新数据库。</target>
        </trans-unit>
        <trans-unit id="2ace62cf521cfc04b47d7dad558287516162d423" translate="yes" xml:space="preserve">
          <source>Then the virtual table would be created with two hidden columns, and with datatypes of &quot;VARCHAR(12)&quot; and &quot;INTEGER&quot;.</source>
          <target state="translated">然后用两个隐藏列创建虚拟表,数据类型为 &quot;VARCHAR(12)&quot;和 &quot;INTEGER&quot;。</target>
        </trans-unit>
        <trans-unit id="b398879a2efe1c2e2e8691470971432fd8ac7954" translate="yes" xml:space="preserve">
          <source>Then to read the first page of that database file, one merely runs:</source>
          <target state="translated">然后要读取该数据库文件的第一页,只需运行。</target>
        </trans-unit>
        <trans-unit id="9a0f2cc8cc7905afb88e588449e50b02e607b774" translate="yes" xml:space="preserve">
          <source>Then two &quot;virtual&quot; terms are added as follows:</source>
          <target state="translated">然后再加上两个 &quot;虚 &quot;字,如下。</target>
        </trans-unit>
        <trans-unit id="ca7fe30da623ecbcc16dc68b6763c7b9a4af11d0" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3ddffeb2cfef8ef81678864135303a52c1015f" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It is also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">然后，使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX（）&lt;/a&gt;函数将较大的字符串值绑定到SQL语句。绑定的使用避免了对字符串中的引号字符进行转义的需要，从而降低了SQL注入攻击的风险。由于不需要分析或复制大字符串，因此它的运行速度也更快。</target>
        </trans-unit>
        <trans-unit id="265606c9637ac4024a4237e1919b8d5a2a194605" translate="yes" xml:space="preserve">
          <source>Then, love your neighbor as yourself.</source>
          <target state="translated">那么,要爱你的邻居像爱自己一样。</target>
        </trans-unit>
        <trans-unit id="3cfbc622cd136a62d323c5b8bab5c8bc5876d69e" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;vtablist&quot;&gt;many other virtual table implementations&lt;/a&gt; in the SQLite source tree that can be used as examples. Locate these other virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0cc9442c93b87173641af3ce48fe6ba6a56819" translate="yes" xml:space="preserve">
          <source>There are U or more such b-trees on a single level (see the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for an explanation of b-tree levels), where U is the value assigned to the &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge option&lt;/a&gt; option.</source>
          <target state="translated">在单个级别上有U个或多个这样的b树（请参阅&lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5自动合并选项&lt;/a&gt;的文档以获取 b树级别的说明），其中U是分配给&lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge选项&lt;/a&gt;选项的值。</target>
        </trans-unit>
        <trans-unit id="fd10b08d9cff8fbc86ae03afd572ce0a4529a480" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;&lt;a href=&quot;zeroconf&quot;&gt;zero-configuration&lt;/a&gt;&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">无服务器具有优点和缺点。主要优点是，没有安装，设置，配置，初始化，管理和故障排除的单独服务器进程。这就是SQLite是&amp;ldquo; &lt;a href=&quot;zeroconf&quot;&gt;零配置&lt;/a&gt; &amp;rdquo;数据库引擎的原因之一。使用SQLite的程序在运行之前不需要任何管理支持即可设置数据库引擎。任何能够访问磁盘的程序都可以使用SQLite数据库。</target>
        </trans-unit>
        <trans-unit id="9e47d4a7ae3779b3ce3872907368c2ebe6ca93d1" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;zero-configuration&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">无服务器有优势也有劣势。主要的优点是没有单独的服务器进程来安装、设置、配置、初始化、管理和故障排除。这也是为什么SQLite是一个 &quot;零配置 &quot;的数据库引擎的原因之一。使用SQLite的程序在运行前不需要管理支持来设置数据库引擎。任何能够访问磁盘的程序都能够使用SQLite数据库。</target>
        </trans-unit>
        <trans-unit id="a00099ff32dd16c72c3ea081a513584d8f3c38e0" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using WAL instead of a rollback journal. Advantages include:</source>
          <target state="translated">使用WAL代替回滚日记账有其优势和劣势。优点包括:</target>
        </trans-unit>
        <trans-unit id="3093b427039bbfacae2cf7cc0c20cdff14795a5c" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</source>
          <target state="translated">使用内存映射的I/O有优势也有劣势。优点包括:</target>
        </trans-unit>
        <trans-unit id="79bd071128837bce919057f74da96b8e84ac063f" translate="yes" xml:space="preserve">
          <source>There are certain reasonable restrictions on expressions that appear in CREATE INDEX statements:</source>
          <target state="translated">对出现在CREATE INDEX语句中的表达式有一定的合理限制。</target>
        </trans-unit>
        <trans-unit id="0440cacf20ea4b02e6a0db0e8999f07d0748bd04" translate="yes" xml:space="preserve">
          <source>There are compile-time options that will set upper bounds on the sizes of various structures in SQLite. The compile-time options normally set a hard upper bound that can be changed at run-time on individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface.</source>
          <target state="translated">有一些编译时选项可以设置SQLite中各种结构的大小的上限。编译时选项通常设置一个硬上限，可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;接口在单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上更改该硬上限。</target>
        </trans-unit>
        <trans-unit id="5db06d3cdfac9a23d2859adb4baf70db2e25be47" translate="yes" xml:space="preserve">
          <source>There are currently 170 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">虚拟机当前定义了170个操作码。下表描述了所有当前定义的操作码。该表是通过扫描文件&lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c中&lt;/a&gt;的源代码自动生成的。</target>
        </trans-unit>
        <trans-unit id="3d151e494351273cc5176bb466ee794220518dba" translate="yes" xml:space="preserve">
          <source>There are currently 175 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f94a164918f438c0d1173d53f7a4f94c08b35d7" translate="yes" xml:space="preserve">
          <source>There are currently the following configuration options:</source>
          <target state="translated">目前有以下配置选项:</target>
        </trans-unit>
        <trans-unit id="3c95acf82c00de5d5751bda48036e2a0038274e3" translate="yes" xml:space="preserve">
          <source>There are details to fill in here. Perhaps a screen can be provided that displays a history changes (perhaps with a graph) allowing the user to select which version they want to view or edit. Perhaps some facility can be provided to merge forks that might occur in the version history. And perhaps the application should provide a means to purge old and unwanted versions. The key point is that using an SQLite database to store the content, rather than a ZIP archive, makes all of these features much, much easier to implement, which increases the possibility that they will eventually get implemented.</source>
          <target state="translated">这里有一些细节需要填写。也许可以提供一个屏幕,显示历史变化(也许用图表),允许用户选择他们想要查看或编辑的版本。也许可以提供一些设施来合并可能发生在版本历史中的分叉。也许应用程序应该提供一种方法来清除旧的和不需要的版本。关键的一点是,使用SQLite数据库来存储内容,而不是ZIP存档,使得所有这些功能更容易实现,这增加了它们最终得到实现的可能性。</target>
        </trans-unit>
        <trans-unit id="98cb1601f44f3fee5a33f8d40abfeb82b5e7251a" translate="yes" xml:space="preserve">
          <source>There are five separate read locks, numbers 0 through 4. Read locks may be either SHARED or EXCLUSIVE. Connections obtain a shared lock on one of the read locks bytes while they are within a transaction. Connections also obtain an exclusive lock on read locks, one at a time, for the brief moment while they are updating the values of the corresponding read-marks. Read locks 1 through 4 are held exclusively when running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">有五个单独的读取锁，编号为0到4。读取锁可以是SHARED或EXCLUSIVE。当连接处于事务中时，连接会在其中一个读取锁字节上获得共享锁。当连接在更新相应读取标记的值时，连接也会在短暂的时间内获得一次读锁定的排他锁。运行&lt;a href=&quot;walformat#recovery&quot;&gt;恢复&lt;/a&gt;时，将仅保留读取锁1至4 。</target>
        </trans-unit>
        <trans-unit id="c457ee41ba8d1b7387ba8e7edc9a0ac19be4f375" translate="yes" xml:space="preserve">
          <source>There are five ways to describe starting and ending frame boundaries:</source>
          <target state="translated">有五种方法来描述起止框界。</target>
        </trans-unit>
        <trans-unit id="c2ce0d23c5814413e2c1fb5364c7eef30a6e31f7" translate="yes" xml:space="preserve">
          <source>There are four independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4083c54b42aa73500fa86d4b0409e55690866a09" translate="yes" xml:space="preserve">
          <source>There are many advantages to using SQLite as an application file format, including:</source>
          <target state="translated">使用SQLite作为应用文件格式有很多优势,包括:1:</target>
        </trans-unit>
        <trans-unit id="7e1c62962db715e611550a655ba502415a8c24f6" translate="yes" xml:space="preserve">
          <source>There are many benefits to this approach, including improved performance, reduced cost and complexity, and improved reliability. See technical notes &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; and &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; for more information. This use case is closely related to the &lt;a href=&quot;#wireproto&quot;&gt;data transfer format&lt;/a&gt; and &lt;a href=&quot;#container&quot;&gt;data container&lt;/a&gt; use cases below.</source>
          <target state="translated">这种方法有很多好处，包括改进的性能，降低的成本和复杂性以及改进的可靠性。有关更多信息，请参见技术说明&lt;a href=&quot;aff_short&quot;&gt;&amp;ldquo; aff_short.html&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;appfileformat&quot;&gt;&amp;ldquo; appfileformat.html&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;fasterthanfs&quot;&gt;&amp;ldquo; fasterthanfs.html&amp;rdquo;&lt;/a&gt;。该用例与下面的&lt;a href=&quot;#wireproto&quot;&gt;数据传输格式&lt;/a&gt;和&lt;a href=&quot;#container&quot;&gt;数据容器&lt;/a&gt;用例密切相关。</target>
        </trans-unit>
        <trans-unit id="a6dd1c1ec54122d1cd8a41e77d633d60c4de1054" translate="yes" xml:space="preserve">
          <source>There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.</source>
          <target state="translated">I/O错误有许多不同的扩展结果代码,可以识别失败的具体I/O操作。</target>
        </trans-unit>
        <trans-unit id="f265782324871b5641aee92d51fefe1edfb475af" translate="yes" xml:space="preserve">
          <source>There are many fraudulent USB sticks in circulation that report to have a high capacity (ex: 8GB) but are really only capable of storing a much smaller amount (ex: 1GB). Attempts to write on these devices will often result in unrelated files being overwritten. Any use of a fraudulent flash memory device can easily lead to database corruption, therefore. Internet searches such as &quot;fake capacity usb&quot; will turn up lots of disturbing information about this problem.</source>
          <target state="translated">有许多欺诈性的USB棒在流通中,报告有一个高容量(如:8GB),但实际上只能存储更小的数量(如:1GB)。试图在这些设备上写东西,往往会导致不相关的文件被覆盖。因此,任何使用假冒闪存设备的行为都很容易导致数据库损坏。在互联网上搜索 &quot;假容量U盘 &quot;等,会发现很多关于这个问题的令人不安的信息。</target>
        </trans-unit>
        <trans-unit id="a53dc58a565490cefd808a058bfaad47e191a084" translate="yes" xml:space="preserve">
          <source>There are many more features not listed above. SQLite may be small in size and have &quot;Lite&quot; in its name, but it is not lacking in capability.</source>
          <target state="translated">还有很多功能没有在上面列出。SQLite可能体积很小,名字中也有 &quot;Lite&quot;,但它并不缺乏功能。</target>
        </trans-unit>
        <trans-unit id="60f662540321a06d796e68831dc73409bf49f397" translate="yes" xml:space="preserve">
          <source>There are many other dot-commands available in the command-line shell. See the &quot;.help&quot; command for a complete list for any particular version and build of SQLite.</source>
          <target state="translated">在命令行shell中还有许多其他的点命令。请参阅&quot;.help &quot;命令以获得任何特定版本和SQLite构建的完整列表。</target>
        </trans-unit>
        <trans-unit id="53f739b37a172fddf027f7c8afb4029bf933f8fe" translate="yes" xml:space="preserve">
          <source>There are many other testing options, which can be seen by running the command:</source>
          <target state="translated">还有很多其他的测试选项,可以通过运行命令来查看。</target>
        </trans-unit>
        <trans-unit id="461c7676d827031f4cd64d05f3d67e68ce256daf" translate="yes" xml:space="preserve">
          <source>There are many ways to measure test coverage. The most popular metric is &quot;statement coverage&quot;. When you hear someone say that their program as &quot;XX% test coverage&quot; without further explanation, they usually mean statement coverage. Statement coverage measures what percentage of lines of code are executed at least once by the test suite.</source>
          <target state="translated">衡量测试覆盖率的方法有很多。最流行的衡量标准是 &quot;语句覆盖率&quot;。当你听到有人说他们的程序是 &quot;XX%的测试覆盖率&quot;,而没有进一步的解释,他们通常指的是语句覆盖率。语句覆盖率衡量的是测试套件至少执行一次的代码行的百分比。</target>
        </trans-unit>
        <trans-unit id="15784824361af8c293ec21cb8076051131fb442d" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits in TH3. One could generate a single test program that contained all test modules and all configuration files. However, such a test program might be too large to deploy on embedded platforms. (As of 2018-05-19, a full-up TH3 test is over 850,000 lines and 58MB of C code.) TH3 provides the ability to break the library of test modules up into smaller, more easily digested pieces.</source>
          <target state="translated">在TH3中没有任意的限制。人们可以生成一个包含所有测试模块和所有配置文件的单一测试程序。然而,这样的测试程序可能太大,无法部署在嵌入式平台上。(截至2018-05-19,一个完整的TH3测试是超过85万行和58MB的C代码)。TH3提供了将测试模块库分解成更小的、更容易消化的片段的能力。</target>
        </trans-unit>
        <trans-unit id="67165e227e06a66e9e2a7c9a359bffd814ca48a8" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits on the number of indices that can be attached to a single table. The number of columns in an index is limited to the value set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,...).</source>
          <target state="translated">可以附加到单个表的索引数没有任意限制。索引中的列数限制为&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;，...）设置的值。</target>
        </trans-unit>
        <trans-unit id="75e5745eabbe1f0d9742be6d3047103706a06632" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;../threadsafe&quot;&gt;线程处理模式设置&lt;/a&gt;为多线程。换句话说，它禁用&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和预&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt;对象的静音。该应用程序负责序列化对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;stmt&quot;&gt;准备好的语句的&lt;/a&gt;访问。但是启用了其他互斥锁，以便SQLite在多线程环境中可以安全地使用，只要没有两个线程尝试同时使用同一&lt;a href=&quot;sqlite3&quot;&gt;数据库连接即可&lt;/a&gt;。如果使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;编译时选项编译SQLite ，则无法设置多线程&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;和&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;如果使用SQLITE_CONFIG_MULTITHREAD配置选项调用，将返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="438fea25e22862b67e0b2e195af310125649fa4d" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;../threadsafe&quot;&gt;线程处理模式设置&lt;/a&gt;为序列化。换句话说，此选项启用所有互斥锁，包括&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象上的递归互斥锁。在这种模式下（这是使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1&lt;/a&gt;编译SQLite时的默认设置），SQLite库本身将序列化对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;stmt&quot;&gt;预处理语句的&lt;/a&gt;访问，以便应用程序可以在不同线程中自由使用相同的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;或相同的&lt;a href=&quot;stmt&quot;&gt;预处理语句&lt;/a&gt;与此同时。如果使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;编译SQLite编译时选项，则无法设置序列化&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;，如果使用SQLITE_CONFIG_SERIALIZED配置选项调用，则&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;将返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b86fd3dbc8c8ae83073b70ec3ca59694912ef28" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;../threadsafe&quot;&gt;线程处理模式&lt;/a&gt;设置为&amp;ldquo;单线程&amp;rdquo;。换句话说，它禁用所有静音，并将SQLite置于只能由单个线程使用的模式。如果使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0的&lt;/a&gt;编译时选项编译SQLite ，则无法将&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;从其默认值Single-thread 更改，因此&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;如果使用SQLITE_CONFIG_SINGLETHREAD配置选项调用，将返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6b294707b24261f0f532c64902934c051eedbd1" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;threadsafe&quot;&gt;线程处理模式设置&lt;/a&gt;为多线程。换句话说，它禁用&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和预&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt;对象的静音。该应用程序负责序列化对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句的&lt;/a&gt;访问。但是启用了其他互斥锁，以便SQLite在多线程环境中可以安全地使用，只要没有两个线程尝试同时使用同一&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接即可&lt;/a&gt;。如果使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;编译时选项编译SQLite ，则无法设置多线程&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;和&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;如果使用SQLITE_CONFIG_MULTITHREAD配置选项调用，将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="955a610f066915f2766fca467b944718d1ee6aea" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;threadsafe&quot;&gt;线程处理模式设置&lt;/a&gt;为序列化。换句话说，此选项启用所有互斥锁，包括&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象上的递归互斥锁。在这种模式下（这是使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1&lt;/a&gt;编译SQLite时的默认设置），SQLite库本身将序列化对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stmt&quot;&gt;预处理语句的&lt;/a&gt;访问，以便应用程序可以在不同线程中自由使用相同的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;或相同的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;预处理语句&lt;/a&gt;与此同时。如果使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;编译SQLite编译时选项，则无法设置序列化&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;，如果使用SQLITE_CONFIG_SERIALIZED配置选项调用，则&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bc66a3a72545b16257e521a7b7467b7b7fb116b" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;threadsafe&quot;&gt;线程处理模式&lt;/a&gt;设置为&amp;ldquo;单线程&amp;rdquo;。换句话说，它禁用所有静音，并将SQLite置于只能由单个线程使用的模式。如果使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0的&lt;/a&gt;编译时选项编译SQLite ，则无法将&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;从其默认值Single-thread 更改，因此&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;如果使用SQLITE_CONFIG_SINGLETHREAD配置选项调用，将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33e0331165757b835edb3c42bfc1d34942851312" translate="yes" xml:space="preserve">
          <source>There are numerous test cases that verify that SQLite is able to deal with malformed database files. These tests first build a well-formed database file, then add corruption by changing one or more bytes in the file by some means other than SQLite. Then SQLite is used to read the database. In some cases, the bytes changes are in the middle of data. This causes the content of the database to change while keeping the database well-formed. In other cases, unused bytes of the file are modified, which has no effect on the integrity of the database. The interesting cases are when bytes of the file that define database structure get changed. The malformed database tests verify that SQLite finds the file format errors and reports them using the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; return code without overflowing buffers, dereferencing NULL pointers, or performing other unwholesome actions.</source>
          <target state="translated">有许多测试用例可以验证SQLite是否可以处理格式错误的数据库文件。这些测试首先构建格式正确的数据库文件，然后通过SQLite以外的其他方法通过更改文件中的一个或多个字节来添加损坏。然后使用SQLite读取数据库。在某些情况下，字节更改位于数据中间。这将导致数据库的内容发生变化，同时保持数据库的格式正确。在其他情况下，将修改文件的未使用字节，这不会影响数据库的完整性。有趣的情况是定义数据库结构的文件的字节被更改。格式错误的数据库测试将验证SQLite是否找到文件格式错误并使用&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;报告错误 返回代码而不会溢出缓冲区，取消引用NULL指针或执行其他有害操作。</target>
        </trans-unit>
        <trans-unit id="f9afe2547739122b5f898fca4cf352f033d81b8f" translate="yes" xml:space="preserve">
          <source>There are only two reasonable ways to implement this query. (There are many other possible algorithms, but none of the others are contenders for being the &quot;best&quot; algorithm.)</source>
          <target state="translated">只有两种合理的方法可以实现这个查询。有许多其他可能的算法,但其他算法都不是 &quot;最佳 &quot;算法的竞争者)。</target>
        </trans-unit>
        <trans-unit id="35c4953b7b40ec225a59ad1651360c7dbd0086b0" translate="yes" xml:space="preserve">
          <source>There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not apply.</source>
          <target state="translated">还有其他一些SQL数据库引擎,它们拥有自由的许可证,允许广泛和自由地使用代码。但这些其他引擎仍然受版权法的约束。SQLite则不同,版权法根本不适用。</target>
        </trans-unit>
        <trans-unit id="00840e534b3409464615b9e5469c1789e0356b07" translate="yes" xml:space="preserve">
          <source>There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.</source>
          <target state="translated">在SQLite核心源码库和可用的扩展中还有其他的VFS实现。上面的列表并不意味着详尽无遗,而只是代表了使用VFS接口可以实现的各种功能。</target>
        </trans-unit>
        <trans-unit id="fe657852dc4212647e79b2906ecbf326edcfcb96" translate="yes" xml:space="preserve">
          <source>There are several other ways to add an equivalent foreign key declaration to a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE documentation&lt;/a&gt; for details.</source>
          <target state="translated">还有其他几种将等效的外键声明添加到&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的方法。有关详细信息，请参考&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14687afe7afa4066d985b4f03845594063586e18" translate="yes" xml:space="preserve">
          <source>There are several ways of thinking about the RELEASE command:</source>
          <target state="translated">RELEASE命令有几种思路。</target>
        </trans-unit>
        <trans-unit id="22c57ea3a56c1a621fcb33ba044a6de73ca1f510" translate="yes" xml:space="preserve">
          <source>There are several ways to approach this in FTS5:</source>
          <target state="translated">在FTS5中,有几种方法可以解决这个问题。</target>
        </trans-unit>
        <trans-unit id="de40b756c06e57b21f4c7c518f428b201082172b" translate="yes" xml:space="preserve">
          <source>There are some contexts in SQLite that do not allow the use of non-deterministic functions:</source>
          <target state="translated">在SQLite中,有一些上下文不允许使用非确定性函数。</target>
        </trans-unit>
        <trans-unit id="ffb257ce26a3636acdb1a9134b8ec418a490f506" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:</source>
          <target state="translated">对于VALUES子句的使用有一些限制,这些限制没有在语法图上显示出来。</target>
        </trans-unit>
        <trans-unit id="4fc9c795ba02424df295c5bd8e19a42a3240738c" translate="yes" xml:space="preserve">
          <source>There are three frame types: ROWS, GROUPS, and RANGE. The frame type determines how the starting and ending boundaries of the frame are measured.</source>
          <target state="translated">有三种框架类型。ROWS、GROUPS和RANGE。帧类型决定了如何测量帧的起始和结束边界。</target>
        </trans-unit>
        <trans-unit id="b1e7d89744d05b6a27dde7db2836b2617aa1bbd6" translate="yes" xml:space="preserve">
          <source>There are three independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">有三个独立的测试线束用于测试核心SQLite库。每个测试线束都是单独设计、维护和管理的。</target>
        </trans-unit>
        <trans-unit id="045c3584370eb289c548f60cb3b6ecaf401b3ed3" translate="yes" xml:space="preserve">
          <source>There are three levels to the shared-cache locking model, transaction level locking, table level locking and schema level locking. They are described in the following three sub-sections.</source>
          <target state="translated">共享缓存锁定模型有三个层次,事务级锁定、表级锁定和模式级锁定。下面三个小节将对它们进行描述。</target>
        </trans-unit>
        <trans-unit id="944bcf56eaccf2f8d8f73507f47a4f5f610aa075" translate="yes" xml:space="preserve">
          <source>There are three reasons to set the locking-mode to EXCLUSIVE.</source>
          <target state="translated">有三个原因可以将锁定模式设置为EXCLUSIVE。</target>
        </trans-unit>
        <trans-unit id="e889a4b513747e6b54c292e814d5a011df18d8e5" translate="yes" xml:space="preserve">
          <source>There are three special-case entries in the cost table:</source>
          <target state="translated">费用表中有三个特殊情况条目。</target>
        </trans-unit>
        <trans-unit id="3e8f3752e4f9aab9d7f5e605906342c5eeca4178" translate="yes" xml:space="preserve">
          <source>There are two advantages to using the SQLite printf functions instead of &lt;b&gt;sprintf&lt;/b&gt;. First of all, with the SQLite printf routines, there is never a danger of overflowing a static buffer as there is with &lt;b&gt;sprintf&lt;/b&gt;. The SQLite printf routines automatically allocate (and later frees) as much memory as is necessary to hold the SQL statements generated.</source>
          <target state="translated">使用SQLite printf函数而不是&lt;b&gt;sprintf&lt;/b&gt;有两个优点。首先，使用SQLite printf例程，永远不会像&lt;b&gt;sprintf&lt;/b&gt;那样存在溢出静态缓冲区的危险。SQLite printf例程会自动分配（并在以后释放）所需的内存，以容纳生成的SQL语句。</target>
        </trans-unit>
        <trans-unit id="391950a505dd77c6d9de2b0a8bf9dd26b935ed51" translate="yes" xml:space="preserve">
          <source>There are two aggregate SQL functions:</source>
          <target state="translated">有两个聚合SQL函数。</target>
        </trans-unit>
        <trans-unit id="631b7dfac93f3d53c23db92b1bef743005732dff" translate="yes" xml:space="preserve">
          <source>There are two cases to consider: (1) Table &quot;tab1&quot; does not previously exist and (2) table &quot;tab1&quot; does already exist.</source>
          <target state="translated">有两种情况需要考虑。(1)表 &quot;tab1 &quot;以前不存在,(2)表 &quot;tab1 &quot;已经存在。</target>
        </trans-unit>
        <trans-unit id="b8b8531dc422d3e33d42cc7bdad0abd37870f1fe" translate="yes" xml:space="preserve">
          <source>There are two column (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array names azResult. Then azResult holds this content:</source>
          <target state="translated">有两列(M==2)和三行(N==3)。因此结果表有8个条目。假设结果表存储在一个名为azResult的数组中。那么azResult中就存放了这个内容。</target>
        </trans-unit>
        <trans-unit id="e8adb25d367ffc51207827de29ffc66a0b34c609" translate="yes" xml:space="preserve">
          <source>There are two columns (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array named azResult. Then azResult holds this content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928a963ad2407ff0d2d21e12347ddb23d756bb64" translate="yes" xml:space="preserve">
          <source>There are two differences in this variation. The initial-select is &quot;SELECT 1&quot; instead of &quot;VALUES(1)&quot;. But those are just different syntaxes for saying exactly the same thing. The other change is that the recursion is stopped by a LIMIT rather than a WHERE clause. The use of LIMIT means that when the one-millionth row is added to the &quot;cnt&quot; table (and returned by the main SELECT, thanks to the query optimizer) then the recursion stops immediately regardless of how many rows might be left in the queue. On more complex queries, it can sometimes be difficult to ensure that the WHERE clause will eventually cause the queue to drain and the recursion to terminate. But the LIMIT clause will always stop the recursion. So it is good practice to always include a LIMIT clause as a safety if an upper bound on the size of the recursion is known.</source>
          <target state="translated">这个变化有两个不同之处。初始选择是 &quot;SELECT 1 &quot;而不是 &quot;VALUES(1)&quot;。但是这些只是不同的语法,说的是完全相同的事情。另一个变化是递归由一个LIMIT而不是WHERE子句来停止。使用LIMIT意味着当第100万条记录被添加到 &quot;cnt &quot;表中时(并由主SELECT返回,这要归功于查询优化器),那么递归就会立即停止,不管队列中可能还剩下多少条记录。在更复杂的查询中,有时很难确保WHERE子句最终会导致队列耗尽,递归终止。但是LIMIT子句总是会停止递归。所以,如果知道递归的大小有一个上限,那么作为安全起见,总是包含一个LIMIT子句是一个很好的做法。</target>
        </trans-unit>
        <trans-unit id="bb5962b52c02f4df27314354c0118e64e476f288" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f943413bc9e88ca64edb6cc154e6b7583f6c77" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">这里有两个单独的配置更改，可以一起使用也可以单独使用。该&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;设置禁用能够连续访问互斥&lt;a href=&quot;c3ref/sqlite3&quot;&gt;的数据库连接&lt;/a&gt;对象，并&lt;a href=&quot;c3ref/stmt&quot;&gt;事先准备好的声明&lt;/a&gt;的对象。使用此设置，应用程序可以从多个线程中自由使用SQLite，但必须确保没有两个线程尝试同时访问同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;或与该&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的任何&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。两个线程可以同时使用SQLite，但是它们必须使用单独的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。第二个&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;设置将禁用SQLite中跟踪所有未完成的内存分配请求的总大小的机制。这省去了对每次调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;进行互斥的需求，从而节省了大量互斥操作。但是，禁用内存统计信息机制的结果是&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;，&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;和&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口不再起作用。</target>
        </trans-unit>
        <trans-unit id="03b9684a8e7902c26ab2183576e54dd70242a272" translate="yes" xml:space="preserve">
          <source>There are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.</source>
          <target state="translated">有两种类型的简单SELECT语句--聚合查询和非聚合查询。如果一个简单的SELECT语句包含一个GROUP BY子句或者在结果集中包含一个或多个聚合函数,那么它就是一个聚合查询。否则,如果一个简单的SELECT语句不包含聚合函数或GROUP BY子句,它就是一个非聚合查询。</target>
        </trans-unit>
        <trans-unit id="265655ffc7236582ade45c905963724f97d22dc0" translate="yes" xml:space="preserve">
          <source>There are two ways to use the &quot;content&quot; option:</source>
          <target state="translated">有两种方法可以使用 &quot;内容 &quot;选项。</target>
        </trans-unit>
        <trans-unit id="6c855557ba4350c988043164f7d90199d18c9af0" translate="yes" xml:space="preserve">
          <source>There are typically between 10 to 40 entries in the sqlite_stat4 table for each index for which statistics are available, however these limits are not hard bounds. The meanings of the columns in the sqlite_stat4 table are as follows:</source>
          <target state="translated">在sqlite_stat4表中,每个可以统计的索引通常有10到40个条目,然而这些限制并不是硬性的界限。sqlite_stat4表中各列的含义如下。</target>
        </trans-unit>
        <trans-unit id="7cc2860dd2126e117e20cc785f2f36fc98950f36" translate="yes" xml:space="preserve">
          <source>There are usually multiple entries in the sqlite_stat3 table for each index. The sqlite_stat3.sample column holds the value of the left-most field of an index identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column holds the approximate number of entries in the index whose left-most column exactly matches the sample. The sqlite_stat3.nLt holds the approximate number of entries in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt column holds the approximate number of distinct left-most entries in the index that are less than the sample.</source>
          <target state="translated">在sqlite_stat3表中,每个索引通常有多个条目。sqlite_stat3.sample列保存了由sqlite_stat3.idx和sqlite_stat3.tbl标识的索引最左边字段的值。sqlite_stat3.nEq列保存了索引中最左列与样本完全匹配的条目数。sqlite_stat3.nLt列存放了索引中最左列小于样本的条目数。sqlite_stat3.nDLt列持有索引中最左列小于样本的条目的近似数。</target>
        </trans-unit>
        <trans-unit id="3bc8ca2faf5f82d403479bc810eea0e330c59fbe" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat3 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat3 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">每个索引可以有任意数量的sqlite_stat3条目。的&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令将典型地生成包含在跨越密钥空间，并与大NEQ值分布的样本10和40之间sqlite_stat3表。</target>
        </trans-unit>
        <trans-unit id="76781503806bdc9ca573d5796b00968614643484" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat4 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat4 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">每个索引可以有任意数量的sqlite_stat4条目。的&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令将典型地生成包含在跨越密钥空间，并与大NEQ值分布的样本10和40之间sqlite_stat4表。</target>
        </trans-unit>
        <trans-unit id="4935a4962bbd49a87bfec8ba26bcb0ee96e2bc65" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">每个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;只能定义一个繁忙的处理程序。设置新的繁忙处理程序将清除所有先前设置的处理程序。请注意，调用&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;或评估&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt;会更改繁忙处理程序，从而清除任何先前设置的繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="595614b4fea7d83eeee9eca9b82c7f15a616950a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">每个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;只能定义一个繁忙的处理程序。设置新的繁忙处理程序将清除所有先前设置的处理程序。请注意，调用&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;或评估&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt;会更改繁忙处理程序，从而清除任何先前设置的繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="4557f81c54cd198ad30dafda03e1a7688c37ee6a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">在任何给定时刻，特定&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;只能有一个繁忙的处理程序。如果在调用此例程之前定义了另一个繁忙处理程序（使用&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;），则将清除另一个繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="6c5612f166f3c19adb75f5b9420223d984d062bf" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">在任何给定时刻，特定&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;只能有一个繁忙的处理程序。如果在调用此例程之前定义了另一个繁忙处理程序（使用&lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;），则将清除另一个繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="da947c700e89a2839d81ef99abfdba549201cf04" translate="yes" xml:space="preserve">
          <source>There can only be a single error logging callback per process. The error logging callback is registered at start-time using C-code similar to the following:</source>
          <target state="translated">每个进程只能有一个错误记录回调。错误记录回调在启动时使用类似于下面的C代码注册。</target>
        </trans-unit>
        <trans-unit id="297da7a4ca1508d9a0851c1993606776e3a61cd5" translate="yes" xml:space="preserve">
          <source>There can only be a single trace callback registered on a database connection. Each use of &quot;trace&quot; or &quot;trace_v2&quot; cancels all prior trace callback.</source>
          <target state="translated">在一个数据库连接上只能注册一个跟踪回调。每次使用 &quot;trace &quot;或 &quot;trace_v2 &quot;都会取消之前所有的跟踪回调。</target>
        </trans-unit>
        <trans-unit id="13fe35de43729e33636f83c267efada945c04a07" translate="yes" xml:space="preserve">
          <source>There exists some subtle problem with mmap() on QNX such that making a second mmap() call against a single file descriptor can cause the memory obtained from the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared memory region for transaction coordination in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, and it will call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated to corrupt database file under that scenario. QNX engineers are aware of this problem and are working on a solution; the problem may have already been fixed by the time you read this.</source>
          <target state="translated">QNX上的mmap（）存在一些细微的问题，例如，对单个文件描述符进行第二次mmap（）调用可能会使从第一次mmap（）调用获得的内存归零。 Unix上的SQLite在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;使用mmap（）创建用于事务协调的共享内存区域，对于大型事务它将多次调用mmap（）。在这种情况下，QNX mmap（）已被证明损坏了数据库文件。 QNX工程师已经意识到了这个问题，并且正在研究解决方案。在您阅读本文时，该问题可能已经解决。</target>
        </trans-unit>
        <trans-unit id="d56d459074bf9b196b2551c494a4c7bec9d94df2" translate="yes" xml:space="preserve">
          <source>There has lately been a lot of interest in &quot;safe&quot; programming languages like Rust or Go in which it is impossible, or is at least difficult, to make common programming errors like memory leaks or array overruns. So the question often arises as to why SQLite is not coded in a &quot;safe&quot; language.</source>
          <target state="translated">最近,人们对Rust或Go这样的 &quot;安全 &quot;编程语言很感兴趣,在这些语言中,不可能或至少很难犯常见的编程错误,如内存泄漏或数组超限。所以经常有人问,为什么SQLite不采用 &quot;安全 &quot;的语言进行编码。</target>
        </trans-unit>
        <trans-unit id="52072b3d340cc958b2ff6cebc4a70e99aba7da9e" translate="yes" xml:space="preserve">
          <source>There have been three historical file formats for SQLite. SQLite 1.0 through 1.0.32 used the &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; library as its storage engine. SQLite 2.0.0 through 2.8.17 used a custom b-tree storage engine that supported only text keys and data. All modern versions of SQLite (3.0.0 to present) use a b-tree storage engine that has full support for binary data and Unicode.</source>
          <target state="translated">SQLite有三种历史文件格式。SQLite的1.0到1.0.32中使用的&lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;GDBM&lt;/a&gt;库作为其存储引擎。SQLite 2.0.0至2.8.17使用了自定义的b树存储引擎，该引擎仅支持文本键和数据。所有现代版本的SQLite（目前为3.0.0）都使用b树存储引擎，该引擎完全支持二进制数据和Unicode。</target>
        </trans-unit>
        <trans-unit id="3be8d2f16b71e4444f7f725739b5254eb08f103c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; which will return the integer key for the most recent insert operation.</source>
          <target state="translated">有一个名为&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;的函数，它将为最新的插入操作返回整数键。</target>
        </trans-unit>
        <trans-unit id="2c4047eace270e4351576190943319e0de00174c" translate="yes" xml:space="preserve">
          <source>There is a limit, set using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;, to the number of databases that can be simultaneously attached to a single database connection.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;和&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;设置了一个限制，该限制是可以同时附加到单个数据库连接的数据库数量。</target>
        </trans-unit>
        <trans-unit id="d03b97c401c9a348f14fea8d291ce117238dc810" translate="yes" xml:space="preserve">
          <source>There is a long list of conditions that must all be met in order for query flattening to occur. Some of the constraints are marked as obsolete by italic text. These extra constraints are retained in the documentation to preserve the numbering of the other constraints.</source>
          <target state="translated">有一长串的条件,必须全部满足,才能实现查询扁平化。有些约束条件用斜体字标明为过时的。文件中保留了这些额外的约束条件,以保留其他约束条件的编号。</target>
        </trans-unit>
        <trans-unit id="098b1868e66c13228c4371a548aa26b3bfac10d5" translate="yes" xml:space="preserve">
          <source>There is a new TypeOf() function used to determine if an expression is numeric or text.</source>
          <target state="translated">有一个新的TypeOf()函数用于确定一个表达式是数字还是文本。</target>
        </trans-unit>
        <trans-unit id="e6da2fbcc052924976fcf688d82595c343604804" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_master.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">对于使用AUTOINCREMENT的每个普通表，在sqlite_sequence表中只有一行。该表的名称（显示在sqlite_master.name中）在sqlite_sequence.main字段中，并且曾经插入该表的最大的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;在sqlite_sequence.seq字段中。确保为AUTOINCREMENT表自动生成的新的整数主键大于该表的sqlite_sequence.seq字段。如果AUTOINCREMENT表的sqlite_sequence.seq字段已经是最大整数值（9223372036854775807），则尝试使用自动生成的整数主表向该表添加新行将失败，并显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误。将新条目插入到AUTOINCREMENT表中时，如果需要，可自动更新sqlite_sequence.seq字段。删除表时，将自动删除AUTOINCREMENT表的sqlite_sequence行。如果在更新AUTOINCREMENT表时不存在AUTOINCREMENT表的sqlite_sequence行，那么将创建一个新的sqlite_sequence行。如果将AUTOINCREMENT表的sqlite_sequence.seq值手动设置为整数以外的其他值，并且随后尝试插入或更新AUTOINCREMENT表，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="873101a14a572759e5a45b0dc79cf0cd42bbd9dd" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_schema.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02c79b70988445eed051dee5ef879c5abc0fcef" translate="yes" xml:space="preserve">
          <source>There is a single row of the dbstat table for each page in the database file. Freelist pages, the lock page, and pointer-map pages of the database file do not appear in the dbstat virtual table.</source>
          <target state="translated">数据库文件中的每一页都有一行dbstat表。数据库文件的自由列表页、锁定页和指针映射页不出现在dbstat虚拟表中。</target>
        </trans-unit>
        <trans-unit id="aad819f0714ba351410884e15d9171da8c02d268" translate="yes" xml:space="preserve">
          <source>There is also a &quot;.once -e&quot; command which works similarly, except that it names the temporary file with a &quot;.txt&quot; suffix so that the default text editor for the system will be invoked, instead of the default spreadsheet.</source>
          <target state="translated">还有一个&quot;.once -e &quot;命令,工作原理类似,只是它用&quot;.txt &quot;后缀来命名临时文件,这样就会调用系统默认的文本编辑器,而不是默认的电子表格。</target>
        </trans-unit>
        <trans-unit id="d689365d69d51f44124dabea5ed23d15cbc239dd" translate="yes" xml:space="preserve">
          <source>There is also a function for computing the Wagner edit distance or the Levenshtein distance between a pattern and a word. This function is exposed as spellfix1_editdist(X,Y). The edit distance function returns the &quot;cost&quot; of converting X into Y. Some transformations cost more than others. Changing one vowel into a different vowel, for example is relatively cheap, as is doubling a constant, or omitting the second character of a double-constant. Other transformations or more expensive. The idea is that the edit distance function returns a low cost for words that are similar and a higher cost for words that are further apart. In this implementation, the maximum cost of any single-character edit (delete, insert, or substitute) is 100, with lower costs for some edits (such as transforming vowels).</source>
          <target state="translated">还有一个函数用于计算模式和单词之间的 Wagner 编辑距离或 Levenshtein 距离。这个函数以 spellfix1_editdist(X,Y)的形式出现。编辑距离函数返回将 X 转换为 Y 的 &quot;成本&quot;。有些转换的成本比其他转换的成本高。例如,将一个元音转换为不同的元音是相对便宜的,将一个常量加倍,或者省略双常量的第二个字符也是如此。其他变换或更昂贵。其想法是,编辑距离函数对相似的字返回的成本较低,对相距较远的字返回的成本较高。在本实施例中,任何单字符编辑(删除、插入或替换)的最大成本为100,某些编辑(如变换元音)的成本较低。</target>
        </trans-unit>
        <trans-unit id="8f729e8ad1be217b3b85bb1dbd08e4580826f423" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode for the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; that allows an application to query the powersafe overwrite property for a database file.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;还有一个新的&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt;操作码，它允许应用程序查询数据库文件的powersafe覆盖属性。</target>
        </trans-unit>
        <trans-unit id="d5d98dc46e0aff9a749813616cdf742a9f8913ea" translate="yes" xml:space="preserve">
          <source>There is also an SQL function that can be used to load extensions: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension(X,Y)&lt;/a&gt;. It works just like the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C interface.</source>
          <target state="translated">还有一个SQL函数可用于加载扩展：&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（X，Y）&lt;/a&gt;。它的作用就像&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; C接口一样。</target>
        </trans-unit>
        <trans-unit id="043cd14b86c980f673cef92a152d79c2c6e3cf2c" translate="yes" xml:space="preserve">
          <source>There is always a default VFS. The legacy interfaces &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; always use the default VFS. The new interface for creating database connections, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, allows you to specify which VFS you want to use by name.</source>
          <target state="translated">始终有一个默认的VFS。旧版接口&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;始终使用默认VFS。用于创建数据库连接的新接口&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;允许您按名称指定要使用的VFS。</target>
        </trans-unit>
        <trans-unit id="a75d63f61cb222d77eadc6074711ab25e460df12" translate="yes" xml:space="preserve">
          <source>There is always one VFS which is the default VFS. On unix systems, the &quot;unix&quot; VFS comes up as the default and on windows it is &quot;win32&quot;. If no other actions are taken, new database connections will make use of the default VFS.</source>
          <target state="translated">总有一个VFS是默认的VFS。在unix系统中,&quot;unix &quot;VFS是默认的,在windows系统中是 &quot;win32&quot;。如果没有其他操作,新的数据库连接将使用默认的VFS。</target>
        </trans-unit>
        <trans-unit id="a07e87b2dfc85be098248de6c63083968b9cc2a5" translate="yes" xml:space="preserve">
          <source>There is an additional quasi-persistent &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; file and &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; shared memory file associated with each database, which can make SQLite less appealing for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;.</source>
          <target state="translated">每个数据库都有一个附加的准持久&amp;ldquo; &lt;code&gt;-wal&lt;/code&gt; &amp;rdquo;文件和&amp;ldquo; &lt;code&gt;-shm&lt;/code&gt; &amp;rdquo;共享内存文件，这会使SQLite不太适合用作&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c15ef6d2dec509f5afb1c6ad236607cae0e66e0" translate="yes" xml:space="preserve">
          <source>There is an assortment of sqlite3_bind routines used to assign values to wildcards in a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not reset by sqlite3_reset(). But wildcards can be rebound to new values after an sqlite3_reset().</source>
          <target state="translated">sqlite3_bind例程的种类繁多,用于在准备好的SQL语句中给通配符赋值。未绑定的通配符被解释为NULLs。sqlite3_reset()不能重置绑定。但是通配符可以在sqlite3_reset()之后被重定向为新的值。</target>
        </trans-unit>
        <trans-unit id="1cba197f7f4cf87333685b6d55dd8ea7d285abdf" translate="yes" xml:space="preserve">
          <source>There is an implied &quot;&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot; instruction inserted at the very end of every program. So a jump past the last instruction of the program is the same as executing &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;.</source>
          <target state="translated">在每个程序的末尾都有一条隐含的&amp;ldquo; &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&amp;rdquo;指令。因此，跳过程序的最后一条指令与执行&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="16ef4ec82cf13cdae86f5bf01316c19576909f0f" translate="yes" xml:space="preserve">
          <source>There is an unofficial and unsanctioned Git clone of this repository at &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite上&lt;/a&gt;有此存储库的非官方且未经批准的Git克隆。</target>
        </trans-unit>
        <trans-unit id="bea5c372cd0bf0b6a49c619c32079d5921e4aed3" translate="yes" xml:space="preserve">
          <source>There is another, deprecated, method for invoking the optimize operation using a SELECT statement. New code should use statements similar to the INSERT above to optimize FTS structures.</source>
          <target state="translated">还有另一种方法,已被废弃,就是使用SELECT语句来调用优化操作。新的代码应该使用类似于上述INSERT的语句来优化FTS结构。</target>
        </trans-unit>
        <trans-unit id="b085a1ad6ab5d12c0b0eb9f325abf631b21418bf" translate="yes" xml:space="preserve">
          <source>There is no &quot;CREATE TEMP VIRTUAL TABLE&quot; statement. To create a temporary virtual table, add the &quot;temp&quot; schema before the virtual table name.</source>
          <target state="translated">没有 &quot;CREATE TEMP VIRTUAL TABLE &quot;语句。要创建一个临时的虚拟表,在虚拟表名称前添加 &quot;temp &quot;模式。</target>
        </trans-unit>
        <trans-unit id="f17db4bcecd606fe4d51c30c972432fc774cef49" translate="yes" xml:space="preserve">
          <source>There is no RESERVED lock on the corresponding database file.</source>
          <target state="translated">在相应的数据库文件上没有RESOLED锁。</target>
        </trans-unit>
        <trans-unit id="e99ed00de2d6f07769da563a3ed2aa8bf01a7e2e" translate="yes" xml:space="preserve">
          <source>There is no agreement on what the C datatype for a UTF-16 string should be. Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings. Client software can cast the void* to whatever datatype is appropriate for their system.</source>
          <target state="translated">对于UTF-16字符串的C数据类型应该是什么,目前还没有达成一致。因此,SQLite使用一个通用类型的void*来引用UTF-16字符串。客户端软件可以将void*转为任何适合其系统的数据类型。</target>
        </trans-unit>
        <trans-unit id="c505515229e6ccfbb2128baeaa4350ad9e337f7c" translate="yes" xml:space="preserve">
          <source>There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</source>
          <target state="translated">在这种情况下,没有冲突的记录。调用sqlite3changeset_conflict()API的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="a04b936246a75ee50e5104c87c5e5c3bc05ae139" translate="yes" xml:space="preserve">
          <source>There is no pre-defined release cycle. Releases occur when there is a critical mass of feature enhancements and/or bug fixes. Historically, releases have occurred about 5 or 6 times per year. Users of SQLite pick up new releases from the website on an as-needed basis.</source>
          <target state="translated">没有预先定义的发布周期。当功能增强和/或错误修复达到临界质量时,就会发布。从历史上看,每年大约会发布5到6次。SQLite的用户可以根据需要从网站上获取新版本。</target>
        </trans-unit>
        <trans-unit id="dd71d330015524aacf28e91f9c23458da952387d" translate="yes" xml:space="preserve">
          <source>There is no reserved lock on the main database file.</source>
          <target state="translated">主数据库文件上没有预留锁。</target>
        </trans-unit>
        <trans-unit id="7df732794b7961185fb08c11a413b1539639964a" translate="yes" xml:space="preserve">
          <source>There is no support for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Changes to virtual tables are not captured.</source>
          <target state="translated">不支持&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;。未捕获对虚拟表的更改。</target>
        </trans-unit>
        <trans-unit id="11d7bfeb25e84c6d1e9766a1abf1f94079350c5e" translate="yes" xml:space="preserve">
          <source>There is normally one row per index, with the index identified by the name in the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table to which the index belongs. In each such row, the sqlite_stat.stat column will be a string consisting of a list of integers followed by zero or more arguments. The first integer in this list is the approximate number of rows in the index. (The number of rows in the index is the same as the number of rows in the table, except for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.) The second integer is the approximate number of rows in the index that have the same value in the first column of the index. The third integer is the number number of rows in the index that have the same value for the first two columns. The N-th integer (for N&amp;gt;1) is the estimated average number of rows in the index which have the same value for the first N-1 columns. For a K-column index, there will be K+1 integers in the stat column. If the index is unique, then the last integer will be 1.</source>
          <target state="translated">通常每个索引有一行，该索引由sqlite_stat1.idx列中的名称标识。 sqlite_stat1.tbl列是索引所属的表的名称。在每个此类行中，sqlite_stat.stat列将是一个字符串，其中包含一个整数列表，后跟零个或多个参数。此列表中的第一个整数是索引中的大约行数。 （除&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;外，索引中的行数与表中的行数相同。）第二个整数是索引中第一行中具有相同值的大约行数。第三个整数是索引中前两列具有相同值的行数。第N个整数（对于N&amp;gt; 1）是索引中对前N-1列具有相同值的估计行平均数。对于K列索引，stat列中将有K + 1个整数。如果索引是唯一的，则最后一个整数将为1。</target>
        </trans-unit>
        <trans-unit id="c9c3e6d9120e8e4bfa41b1d6a3111f7343cb6f19" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative malloc()/free() implementations without having to modify any core SQLite code.</source>
          <target state="translated">现在有了一个编译时选项,允许应用程序定义替代的malloc()/free()实现,而无需修改任何核心SQLite代码。</target>
        </trans-unit>
        <trans-unit id="f62ae2b58bd448bf76ec1b9c9d9ded56906eaff1" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative mutex implementations without having to modify any core SQLite code.</source>
          <target state="translated">现在有了一个编译时选项,允许应用程序定义替代的mutex实现,而无需修改任何核心SQLite代码。</target>
        </trans-unit>
        <trans-unit id="b1cb6058c59ace1351641df9e565cb12b51e73fe" translate="yes" xml:space="preserve">
          <source>There is one entry in the %_node table for each R*Tree node. An R*Tree node consists of one or more entries that are proximate to one another. The nodes of an R*Tree for a tree. All nodes other than the root have an entry in the %_parent shadow table that identifies the parent node. Each entry in an R*Tree has a rowid. The %_rowid shadow table maps entry rowids to the node that contains that entry.</source>
          <target state="translated">在%_node表中,每个R*Tree节点都有一个条目。一个R*Tree节点由一个或多个条目组成,这些条目相互之间是近似的。一个R*Tree的节点为一棵树。除根节点外的所有节点在%_parent影子表中都有一个条目,标识父节点。R*Tree中的每个条目都有一个rowid。%_rowid影子表将条目的rowid映射到包含该条目的节点上。</target>
        </trans-unit>
        <trans-unit id="91aa566670abb0466fc190ee57ffd69271a7af7c" translate="yes" xml:space="preserve">
          <source>There is one exception to the previous paragraph: when a row is inserted, updated or deleted, if one or more of its primary key columns contain a NULL value, no record of the change is made.</source>
          <target state="translated">前一段有一个例外:当插入、更新或删除一行时,如果它的一个或多个主键列包含一个NULL值,则不做任何更改记录。</target>
        </trans-unit>
        <trans-unit id="545885bb104866881571615fd910604fef6b0f44" translate="yes" xml:space="preserve">
          <source>There is one important difference between ON UPDATE foreign key actions and SQL triggers. An ON UPDATE action is only taken if the values of the parent key are modified so that the new parent key values are not equal to the old. For example:</source>
          <target state="translated">ON UPDATE外键操作和SQL触发器之间有一个重要的区别。只有当父键的值被修改,使新的父键值不等于旧的父键值时,才会采取ON UPDATE操作。例如</target>
        </trans-unit>
        <trans-unit id="67f4030e1b4840bae9054c024eff72bf5cb42560" translate="yes" xml:space="preserve">
          <source>There is one other subtle difference between &quot;docid&quot; and the normal SQLite aliases for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete values to two or more aliases of the rowid column, SQLite writes the rightmost of such values specified in the INSERT or UPDATE statement to the database. However, assigning a non-NULL value to both the &quot;docid&quot; and one or more of the SQLite rowid aliases when inserting or updating an FTS table is considered an error. See below for an example.</source>
          <target state="translated">在 &quot;docid &quot;和普通SQLite对rowid列的别名之间还有一个微妙的区别。通常情况下,如果一条INSERT或UPDATE语句给rowid列的两个或多个别名分配了离散的值,SQLite会将INSERT或UPDATE语句中指定的这些值中最右边的一个写入数据库。然而,当插入或更新一个FTS表时,给 &quot;docid &quot;和一个或多个SQLite rowid别名分配一个非NULL值被认为是一个错误。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="f856aedc1ad69cfc42357d4bdb200682208f50ab" translate="yes" xml:space="preserve">
          <source>There is only one sorter object, so there are no instructions to open or close it. It is opened automatically when needed, and it is closed when the VDBE program halts.</source>
          <target state="translated">只有一个分拣机对象,所以没有打开或关闭它的指令。需要时自动打开,VDBE程序停止时关闭。</target>
        </trans-unit>
        <trans-unit id="6e50e0d48c576b86d93a31befcc02f54e14b5267" translate="yes" xml:space="preserve">
          <source>There is the extra operation of &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; which, though automatic by default, is still something that application developers need to be mindful of.</source>
          <target state="translated">还有额外的&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作，尽管默认情况下是自动的，但仍然是应用程序开发人员需要注意的一点。</target>
        </trans-unit>
        <trans-unit id="62428f96be095192850e1858e6283c21fe02dd48" translate="yes" xml:space="preserve">
          <source>There is write permission on the directory containing the database so that the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files can be created.</source>
          <target state="translated">在包含数据库的目录上具有写许可权，因此可以创建 &lt;code&gt;-shm&lt;/code&gt; 和 &lt;code&gt;-wal&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="5b6352389dca7ff834f53599bb4e1238c6a257d8" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">被阻止的连接最多可以注册一个解锁通知回调。如果在阻止的连接已经具有注册的解锁通知回调时调用sqlite3_unlock_notify（），则新的回调将替换旧的回调。如果使用空指针作为第二个参数调用sqlite3_unlock_notify（），则将取消所有现有的unlock-notify回调。也可以通过使用&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭被阻止的连接来取消被阻止的连接的解锁通知回调。</target>
        </trans-unit>
        <trans-unit id="474f04800d7576cb1df432f79959d44e97ec88c4" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">被阻止的连接最多可以注册一个解锁通知回调。如果在阻止的连接已经具有注册的解锁通知回调时调用sqlite3_unlock_notify（），则新的回调将替换旧的回调。如果使用空指针作为第二个参数调用sqlite3_unlock_notify（），则将取消所有现有的unlock-notify回调。也可以通过使用&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭被阻止的连接来取消被阻止的连接的解锁通知回调。</target>
        </trans-unit>
        <trans-unit id="51e2e6b0569ca6a8c745966ed3e14378d13e60a9" translate="yes" xml:space="preserve">
          <source>There might be merge conflicts. In other words, it might be that the changes from (2) to (3) are incompatible with the changes from (1) to (4). In that case, the maintainer will have to manually resolve the conflicts. Hopefully conflicts will not come up that often. Conflicts are less likely to occur when the private edits are kept to a minimum.</source>
          <target state="translated">可能存在合并冲突。换句话说,可能是(2)至(3)的改动与(1)至(4)的改动不兼容。在这种情况下,维护者将不得不手动解决这些冲突。希望冲突不会那么频繁地出现。当私人编辑被保持在最低限度时,冲突就不太可能发生。</target>
        </trans-unit>
        <trans-unit id="c1f15675484de7896b9f4cea6917b5f96c0a2c61" translate="yes" xml:space="preserve">
          <source>There might be one or more &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; objects open and in use on the virtual table instance and perhaps even on the row of the virtual table when the xUpdate method is invoked. The implementation of xUpdate must be prepared for attempts to delete or modify rows of the table out from other existing cursors. If the virtual table cannot accommodate such changes, the xUpdate method must return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">调用xUpdate方法时，可能在虚拟表实例上甚至在虚拟表的行上打开并使用了一个或多个&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;对象。xUpdate的实现必须准备好尝试从其他现有游标中删除或修改表的行。如果虚拟表不能容纳此类更改，则xUpdate方法必须返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f17a65d092891c67c0c7c0d6ffba57606e51c65a" translate="yes" xml:space="preserve">
          <source>There must be a read-lock on the database (either a transaction must be started or there must be an open cursor) before executing this instruction.</source>
          <target state="translated">在执行这条指令之前,必须在数据库上有一个读锁(必须启动一个事务或者必须有一个打开的游标)。</target>
        </trans-unit>
        <trans-unit id="838abced0ca5c629a232ce0c8ac382dc2a5201e9" translate="yes" xml:space="preserve">
          <source>There must be no overlap in the bands of rowids for the various tables in a union-vtab.</source>
          <target state="translated">在union-vtab中,各个表的rowids带不能有重叠。</target>
        </trans-unit>
        <trans-unit id="2f109c8b1d1e372963703dc38ccb68fefa2006aa" translate="yes" xml:space="preserve">
          <source>There must be no overlapping rowid ranges in the rows returned by the SQL statement. It is an error if there are.</source>
          <target state="translated">在SQL语句返回的行中,不能有重叠的rowid范围。如果有,则是错误。</target>
        </trans-unit>
        <trans-unit id="af3fe573da439b499f0025edd3eb3c7aa3d7e8cd" translate="yes" xml:space="preserve">
          <source>There must not be a write transaction open on schema S of database connection D.</source>
          <target state="translated">数据库连接D的模式S上一定没有打开一个写事务。</target>
        </trans-unit>
        <trans-unit id="3d41940c4561987aa3b448b06598e8d1c6472839" translate="yes" xml:space="preserve">
          <source>There should be exactly one call to sqlite3_backup_finish() for each successful call to sqlite3_backup_init().</source>
          <target state="translated">每成功调用一次sqlite3_backup_init(),应该正好有一次对sqlite3_backup_finish()的调用。</target>
        </trans-unit>
        <trans-unit id="9cf5a0f0e6851073aea7c635470af127d9d907d8" translate="yes" xml:space="preserve">
          <source>There were reports that SQLite did not perform as well on an indexed table. This test was recently added to disprove those rumors. It is true that SQLite is not as fast at creating new index entries as the other engines (see Test 6 below) but its overall speed is still better.</source>
          <target state="translated">有报道称,SQLite在索引表上的表现不尽如人意。最近增加了这个测试来否定这些传言。的确,SQLite在创建新索引项的速度上不如其他引擎(见下面的测试6),但其整体速度还是比较好的。</target>
        </trans-unit>
        <trans-unit id="7cdb3ca5132a0c3bc86c19fe3abd0889729f8701" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C预处理器符号编译该库时，这些API才可用。</target>
        </trans-unit>
        <trans-unit id="04c8e718505dcab90cfc6233e2bd22375b7164d1" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C预处理器符号编译该库时，这些API才可用。</target>
        </trans-unit>
        <trans-unit id="c0bacb531ef3c143611b93d8575c5722c7b86645" translate="yes" xml:space="preserve">
          <source>These action code values signify what kind of operation is to be authorized. The 3rd and 4th parameters to the authorization callback function will be parameters or NULL depending on which of these codes is used as the second parameter. The 5th parameter to the authorizer callback is the name of the database (&quot;main&quot;, &quot;temp&quot;, etc.) if applicable. The 6th parameter to the authorizer callback is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from top-level SQL code.</source>
          <target state="translated">这些动作代码值表示要授权的操作类型。授权回调函数的第3和第4个参数将是参数或NULL,这取决于这些代码中的哪个被用作第二个参数。授权回调的第5个参数是数据库的名称(&quot;main&quot;、&quot;temp &quot;等),如果适用的话。授权者回调的第6个参数是负责访问尝试的最内层触发器或视图的名称,如果这个访问尝试直接来自顶层SQL代码,则为NULL。</target>
        </trans-unit>
        <trans-unit id="08d99679f060455eb057ba3c4cf117bfe450c567" translate="yes" xml:space="preserve">
          <source>These and other similar syntax restrictions are described in the text.</source>
          <target state="translated">这些和其他类似的语法限制在文中有描述。</target>
        </trans-unit>
        <trans-unit id="373ccf29c36481aabf98cf8d5fcf341e72288794" translate="yes" xml:space="preserve">
          <source>These are just a few of the benefits of using SQLite as an application file format &amp;mdash; the benefits that seem most likely to improve the user experience for applications like OpenOffice. Other applications might benefit from SQLite in different ways. See the &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt; document for additional ideas.</source>
          <target state="translated">这些只是将SQLite用作应用程序文件格式的一些好处-这些好处似乎最有可能改善OpenOffice等应用程序的用户体验。其他应用程序可能会以不同的方式受益于SQLite。有关其他建议，请参见&amp;ldquo; &lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&amp;rdquo;&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="840704459c7bebebba604f0b7c84031cf12ac5c7" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">这些是析构函数的特殊值，这些值作为最终参数传递给诸如&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob（）之&lt;/a&gt;类的例程。如果析构函数参数为SQLITE_STATIC，则表示内容指针是常量，并且永远不会更改。它不需要被销毁。SQLITE_TRANSIENT值表示内容可能会在不久的将来更改，并且SQLite应该在返回之前对其内容进行私有复制。</target>
        </trans-unit>
        <trans-unit id="3097b1326f3eb788f48bb5e49292e793f88d3f73" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">这些是析构函数的特殊值，这些值作为最终参数传递给诸如&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob（）之&lt;/a&gt;类的例程。如果析构函数参数为SQLITE_STATIC，则表示内容指针是常量，并且永远不会更改。它不需要被销毁。SQLITE_TRANSIENT值表示内容可能会在不久的将来更改，并且SQLite应该在返回之前对其内容进行私有复制。</target>
        </trans-unit>
        <trans-unit id="49e507a42bf99a1526a38fb0d00d4e955eae6280" translate="yes" xml:space="preserve">
          <source>These are the eight locks supported:</source>
          <target state="translated">这就是支持的八把锁。</target>
        </trans-unit>
        <trans-unit id="b356241fa91bdf09876f0517086180731227ee47" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ef0cc4c32969ca19f4793dd10614a44d9a509c" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61de6a061e0e9a67e085323db1a55d01abf6a99" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">这些都是对VFS实现有用的实用例程,它们检查数据库文件是否是一个包含特定查询参数的URI,如果是,则获得该查询参数的值。</target>
        </trans-unit>
        <trans-unit id="0ae1c1d92689387597a221cbf4a8586463c0d9b8" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">这些位值旨在在&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口的第3个参数中以及在&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法的第4个参数中使用。</target>
        </trans-unit>
        <trans-unit id="091c1cd775270574b7e8fe92576bddaa3dc774e3" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">这些位值旨在在&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口的第3个参数中以及在&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法的第4个参数中使用。</target>
        </trans-unit>
        <trans-unit id="7379d4e0ce4f6675fd9028087eadfa8eb7ff4976" translate="yes" xml:space="preserve">
          <source>These changes in the default behavior of SQLite are not a compatibility break. All legacy database files continue to be readable and writable by newer versions of SQLite, and all newly created database files continue to be readable and writable by legacy versions of the SQLite library. The only thing that is changing is some default settings. This should result in a performance increase for many applications.</source>
          <target state="translated">SQLite默认行为的这些变化并不是兼容性的破坏。所有遗留的数据库文件都可以继续被新版本的SQLite读取和写入,所有新创建的数据库文件也可以继续被遗留版本的SQLite库读取和写入。唯一改变的是一些默认设置。这应该会使许多应用程序的性能得到提高。</target>
        </trans-unit>
        <trans-unit id="f8b6f19362cf61de4d3d35983b38ffd9c2bbd4d6" translate="yes" xml:space="preserve">
          <source>These constant define integer codes that represent the various text encodings supported by SQLite.</source>
          <target state="translated">这些常量定义了代表SQLite支持的各种文本编码的整数代码。</target>
        </trans-unit>
        <trans-unit id="28ee7781baba8510621fd94348e40d728944ee20" translate="yes" xml:space="preserve">
          <source>These constants are codes for each of those types.</source>
          <target state="translated">这些常量是这些类型的代码。</target>
        </trans-unit>
        <trans-unit id="5d678085fc410906abd9ecdf3f62895a2bdac8f9" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">这些常量由&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;返回，以通知&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现所评估的SQL语句的&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式是什么。</target>
        </trans-unit>
        <trans-unit id="8d5af3a6c05bd2fcca2c0f972b2fd66256957f31" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">这些常量由&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;返回，以通知&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现所评估的SQL语句的&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式是什么。</target>
        </trans-unit>
        <trans-unit id="e0814beadd7fffeacf97b8f77142e48bc418e590" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数&amp;ldquo;动词&amp;rdquo;，可以作为第二个参数传递给&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="ee8e50c4c247f1789de616c3122fcd5d75fef481" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数&amp;ldquo;动词&amp;rdquo;，可以作为第二个参数传递给&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="5685826d85b489c4a4722d59958f312636d778f9" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数配置选项，可以作为第一个参数传递给&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="cb2ae78ea5b1ae2e5bfc176e2229bcc4eaa83a74" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数配置选项，可以作为第一个参数传递给&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="b8b83f50bcee4d621ab3350b27ae006d83053d8d" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数配置选项，可以作为第二个参数传递给&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="bfdbb7c579979335802d5433a0c4351cc2e64138" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数配置选项，可以作为第二个参数传递给&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="adcbc56bb51ca533b4d845770250da49d6cb92e5" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">这些常量是有效的操作代码参数，用作&lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;的第一个参数。</target>
        </trans-unit>
        <trans-unit id="c9e83fda514b191357ca2f8a433c34a6a2561552" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">这些常量是有效的操作代码参数，用作&lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;的第一个参数。</target>
        </trans-unit>
        <trans-unit id="01b7633fac6735c207dc2ef793e2ed3c159bf015" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">这些常量定义了作为&amp;ldquo;检查点模式&amp;rdquo;的所有有效值，这些值作为第三个参数传递到&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;接口。有关每种检查点模式含义的详细信息，请参见&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1096d3bfc46b56a1b04a8f3fad11f5e8e55e3e9f" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">这些常量定义了作为&amp;ldquo;检查点模式&amp;rdquo;的所有有效值，这些值作为第三个参数传递到&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;接口。有关每种检查点模式含义的详细信息，请参见&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f262688fc8aaf9f38b8c78556de1b6829b6de723" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">这些常量定义了各种标志，可以将这些标志传递到&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;接口的&amp;ldquo; prepFlags&amp;rdquo;参数中。</target>
        </trans-unit>
        <trans-unit id="52a7e652cd3193b904625b47cf5fc5b4007943d0" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">这些常量定义了各种标志，可以将这些标志传递到&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;和&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;接口的&amp;ldquo; prepFlags&amp;rdquo;参数中。</target>
        </trans-unit>
        <trans-unit id="f4779c39284f3e8f89de78b1cf22bb4300a2dde2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">这些常量定义了各种性能限制，可以在运行时使用&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;降低这些限制。各种限制含义的摘要如下所示。有关更多信息，请&lt;a href=&quot;limits&quot;&gt;参见SQLite&lt;/a&gt;中的Limits。</target>
        </trans-unit>
        <trans-unit id="dc33a9fdf99d3b7c3164b92212d61358e77ed2b2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;../limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">这些常量定义了各种性能限制，可以在运行时使用&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;降低这些限制。各种限制含义的摘要如下所示。有关更多信息，请&lt;a href=&quot;../limits&quot;&gt;参见SQLite&lt;/a&gt;中的Limits。</target>
        </trans-unit>
        <trans-unit id="2d9ca50401c9fc616026596d32b3930da4b3846d" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">这些常量标识可以使用&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;跟踪逻辑进行监视的事件类别。&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（D，M，X，P）&lt;/a&gt;的M参数是一个或多个以下常量的或运算组合。跟踪回调的第一个参数是以下常量之一。</target>
        </trans-unit>
        <trans-unit id="ed407cdd4869216425bae7d051975b3bcd0fdc3b" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">这些常量标识可以使用&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;跟踪逻辑进行监视的事件类别。&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（D，M，X，P）&lt;/a&gt;的M参数是一个或多个以下常量的或运算组合。跟踪回调的第一个参数是以下常量之一。</target>
        </trans-unit>
        <trans-unit id="14266cc61d0db9a630a6d1107d408c2e2d4959a8" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;#SQLITE_ANY&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">这些常量可以与&lt;a href=&quot;#SQLITE_ANY&quot;&gt;首选文本编码&lt;/a&gt;一起进行&amp;ldquo;或&amp;rdquo;运算，作为&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;的第四个参数。</target>
        </trans-unit>
        <trans-unit id="4e4c2775c736d10a648ec5f64c5240681b8a597f" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;c_any&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">这些常量可以与&lt;a href=&quot;c_any&quot;&gt;首选文本编码&lt;/a&gt;一起进行&amp;ldquo;或&amp;rdquo;运算，作为&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;，&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;或&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;的第四个参数。</target>
        </trans-unit>
        <trans-unit id="d452c2a5987467cef42875b2093f98a07b801c06" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">这些函数（统称为&amp;ldquo;函数创建例程&amp;rdquo;）用于添加SQL函数或聚合或重新定义现有SQL函数或聚合的行为。这三个&amp;ldquo; sqlite3_create_function *&amp;rdquo;例程之间的唯一区别是，第二个参数（正在创建的函数的名称）预期的文本编码以及应用程序数据指针是否存在析构函数回调。函数sqlite3_create_window_function（）类似，但允许用户提供&lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;聚合窗口函数&lt;/a&gt;所需的额外回调函数。</target>
        </trans-unit>
        <trans-unit id="460bddf16e550adbe692fb026aea91fd5c1a8fa1" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">这些函数（统称为&amp;ldquo;函数创建例程&amp;rdquo;）用于添加SQL函数或聚合或重新定义现有SQL函数或聚合的行为。这三个&amp;ldquo; sqlite3_create_function *&amp;rdquo;例程之间的唯一区别是，第二个参数（正在创建的函数的名称）预期的文本编码以及应用程序数据指针是否存在析构函数回调。函数sqlite3_create_window_function（）类似，但允许用户提供&lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;聚合窗口函数&lt;/a&gt;所需的额外回调函数。</target>
        </trans-unit>
        <trans-unit id="f5aa8ee7f5d5dcd17c7a255e21fd6564afc6f3cb" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;../datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">这些函数添加，删除或修改与指定为第一个参数的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的&lt;a href=&quot;../datatype3#collation&quot;&gt;排序规则&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed63a5a7289985766e806cdca8d318ceb652f682" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">这些函数添加，删除或修改与指定为第一个参数的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的&lt;a href=&quot;datatype3#collation&quot;&gt;排序规则&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e828096ae0ef377574b3a48a5e49c755665e8418" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">这些功能已被&lt;a href=&quot;capi3ref&quot;&gt;弃用&lt;/a&gt;。为了保持与旧代码的向后兼容性，将继续支持这些功能。但是，新的应用程序应避免使用这些功能。为了鼓励程序员避免使用这些功能，我们将不解释它们的作用。</target>
        </trans-unit>
        <trans-unit id="a53c5b52778acbd5177be1207d66b6e2855a89a9" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">这些功能已被&lt;a href=&quot;experimental&quot;&gt;弃用&lt;/a&gt;。为了保持与旧代码的向后兼容性，将继续支持这些功能。但是，新的应用程序应避免使用这些功能。为了鼓励程序员避免使用这些功能，我们将不解释它们的作用。</target>
        </trans-unit>
        <trans-unit id="20e0d52fc906194ab3c598ecb16113bb7e27244d" translate="yes" xml:space="preserve">
          <source>These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values. If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved. An example of where this might be useful is in a regular-expression matching function. The compiled version of the regular expression can be stored as metadata associated with the pattern string. Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.</source>
          <target state="translated">这些函数可以被(非聚合)SQL函数用来将元数据与参数值关联起来。如果在查询执行过程中,相同的值被传递给同一个SQL函数的多次调用,在某些情况下,相关的元数据可能会被保留。在正则表达式匹配函数中,这可能是一个有用的例子。正则表达式的编译版本可以被存储为与模式字符串相关联的元数据。只要模式字符串保持不变,编译后的正则表达式就可以在多次调用同一函数时重复使用。</target>
        </trans-unit>
        <trans-unit id="6522a9f48ff48fe82ed5d5982cbd1db9ee5c56d5" translate="yes" xml:space="preserve">
          <source>These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.</source>
          <target state="translated">这些函数只适用于0000-01-01 00:00:00和9999-12-31 23:59:59之间的日期(儒略日数1721059.5至5373484.5)。对于这个范围之外的日期,这些函数的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="c8d304d80363d45f2a701bb02157d9c038cae0f9" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">这些函数的工作方式与&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;参数绑定&lt;/a&gt;系列非常相似，该函数用于将值绑定到准备好的语句中的主机参数。有关其他信息，请参考&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL参数&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="b317ce2527b91fa298699867534154a11da36ac3" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">这些函数的工作方式与&lt;a href=&quot;bind_blob&quot;&gt;参数绑定&lt;/a&gt;系列非常相似，该函数用于将值绑定到准备好的语句中的主机参数。有关其他信息，请参考&lt;a href=&quot;bind_blob&quot;&gt;SQL参数&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="ab78522f9e6af4ebb0a819cdbba908125b1aa9de" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">这些整数常量是&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xFileControl方法和&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口的操作码。</target>
        </trans-unit>
        <trans-unit id="a38e815d9a81f8a36563593031ac86d208aff3ef" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">这些整数常量是&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xFileControl方法和&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口的操作码。</target>
        </trans-unit>
        <trans-unit id="ea60b84c9e9ef3033a276fcbd9184666b77d102f" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">这些整数常量可用作&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xAccess方法的第三个参数。它们确定xAccess方法正在寻找哪种权限。使用SQLITE_ACCESS_EXISTS，xAccess方法仅检查文件是否存在。使用SQLITE_ACCESS_READWRITE，xAccess方法检查命名目录是否可读写（换句话说，是否可以在目录中添加，删除和重命名文件）。SQLITE_ACCESS_READWRITE常量当前仅由&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma使用&lt;/a&gt;，尽管在将来的SQLite版本中可能会改变。使用SQLITE_ACCESS_READ，xAccess方法检查文件是否可读。SQLITE_ACCESS_READ常量当前未使用，尽管将来的SQLite版本中可能会使用它。</target>
        </trans-unit>
        <trans-unit id="311aa59e56c46be41f406ebc987fb4c56872151d" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">这些整数常量可用作&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xAccess方法的第三个参数。它们确定xAccess方法正在寻找哪种权限。使用SQLITE_ACCESS_EXISTS，xAccess方法仅检查文件是否存在。使用SQLITE_ACCESS_READWRITE，xAccess方法检查命名目录是否可读写（换句话说，是否可以在目录中添加，删除和重命名文件）。SQLITE_ACCESS_READWRITE常量当前仅由&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma使用&lt;/a&gt;，尽管在将来的SQLite版本中可能会改变。使用SQLITE_ACCESS_READ，xAccess方法检查文件是否可读。SQLITE_ACCESS_READ常量当前未使用，尽管将来的SQLite版本中可能会使用它。</target>
        </trans-unit>
        <trans-unit id="8e30f4610e846824046fcc55a5610ab368656db0" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">这些整数常量定义&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;的xShmLock方法允许的各种锁定操作。以下是xShmLock方法的标志的唯一合法组合：</target>
        </trans-unit>
        <trans-unit id="63c61207725308cbbebcd362e48d34bfbbce9eff" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">这些整数常量定义&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;的xShmLock方法允许的各种锁定操作。以下是xShmLock方法的标志的唯一合法组合：</target>
        </trans-unit>
        <trans-unit id="46be45c61b7407297842f2bf5d770d15053c4ac4" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">这些整数常量指定&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status（）&lt;/a&gt;可以返回的各种运行时状态参数。</target>
        </trans-unit>
        <trans-unit id="9d8a64fd442238eaa787788726abe76149b5cae0" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">这些整数常量指定&lt;a href=&quot;status&quot;&gt;sqlite3_status（）&lt;/a&gt;可以返回的各种运行时状态参数。</target>
        </trans-unit>
        <trans-unit id="1dd74d0b7bde7f62eaef94d29d31baa355fc24b9" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">这些接口将内容添加到先前从&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;获得的sqlite3_str对象。</target>
        </trans-unit>
        <trans-unit id="f4c68aa7a2ee53b8d7d01e966ec46bd4df66a0b8" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">这些接口将内容添加到先前从&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;获得的sqlite3_str对象。</target>
        </trans-unit>
        <trans-unit id="37d07c864bda5264afb416a4db651631968abf92" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">这些接口仅在Windows上可用。所述&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口用于设置与所述相关联的值&lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;或&lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;变量，以zValue，取决于类型参数的值。 zValue参数应该为NULL，以使之前的值通过&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;释放；在使用之前，非NULL值将被复制到从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存中。该&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;表示成功，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果类型不受支持，或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;如果无法分配内存。所述的值&lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;变量旨在充当用于在Win32的副平台当前的目录中替换，其中该概念不存在，例如WinRT的和UWP。的&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt;和&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt;接口行为完全相同，除了字符串参数的sqlite3_win32_set_directory接口必须是UTF-8或UTF-16，分别。</target>
        </trans-unit>
        <trans-unit id="e3077cf84285d5d0c77e1603a1b1cc3c809c60d7" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">这些接口仅在Windows上可用。所述&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口用于设置与所述相关联的值&lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;或&lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;变量，以zValue，取决于类型参数的值。 zValue参数应该为NULL，以使之前的值通过&lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;释放；在使用之前，非NULL值将被复制到从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存中。该&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;表示成功，&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果类型不受支持，或&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;如果无法分配内存。所述的值&lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;变量旨在充当用于在Win32的副平台当前的目录中替换，其中该概念不存在，例如WinRT的和UWP。的&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt;和&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt;接口行为完全相同，除了字符串参数的sqlite3_win32_set_directory接口必须是UTF-8或UTF-16，分别。</target>
        </trans-unit>
        <trans-unit id="bf73a94780de490a8f9c02eb38be04e9aad9c703" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt;编译时选项编译SQLite时，这些接口才可用。</target>
        </trans-unit>
        <trans-unit id="2573d74316b2beb50fe8b93933b238b687b3e25f" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt;编译时选项编译SQLite时，这些接口才可用。</target>
        </trans-unit>
        <trans-unit id="1dfbcb8f183f59b84e1cdc3c799c0026a4da7b1c" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">这些接口用于检索有关SQLite性能的运行时状态信息，并可以选择重置各种高水位线。第一个参数是要测量的特定参数的整数代码。公认的整数代码的形式为&lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS _...&lt;/a&gt;。参数的当前值返回到* pCurrent。最高记录值在* pHighwater中返回。如果resetFlag为true，则在写入* pHighwater之后将重置最高记录值。某些参数未记录最高值。对于这些参数，不会将任何内容写入* pHighwater中，并且会忽略resetFlag。其他参数仅记录高水位线，而不记录当前值。对于这些后面的参数，没有任何内容写入* pCurrent。</target>
        </trans-unit>
        <trans-unit id="9a006bb7b78680fec3ca85a8c33bf946ae2c290a" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">这些接口用于检索有关SQLite性能的运行时状态信息，并可以选择重置各种高水位线。第一个参数是要测量的特定参数的整数代码。公认的整数代码的形式为&lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS _...&lt;/a&gt;。参数的当前值返回到* pCurrent。最高记录值在* pHighwater中返回。如果resetFlag为true，则在写入* pHighwater之后将重置最高记录值。某些参数未记录最高值。对于这些参数，不会将任何内容写入* pHighwater中，并且会忽略resetFlag。其他参数仅记录高水位线，而不记录当前值。对于这些后面的参数，没有任何内容写入* pCurrent。</target>
        </trans-unit>
        <trans-unit id="7a26bb8a6cfb99470baf86e2f9ba8d8fe1ec3d04" translate="yes" xml:space="preserve">
          <source>These interfaces can be used by an application to monitor how much memory SQLite is using. The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently in use and the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; returns the maximum instantaneous memory usage. Neither routine includes the overhead associated with the memory allocator. These routines are provided for use by the application. SQLite never invokes them itself. So if the application is providing its own memory allocation subsystem, it can omit these interfaces if desired.</source>
          <target state="translated">应用程序可以使用这些接口来监视SQLite使用的内存量。所述&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;例程返回当前正在使用的存储器的字节数和&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;返回最大瞬时内存使用情况。这两个例程都不包括与内存分配器相关的开销。提供了这些例程供应用程序使用。 SQLite永远不会调用它们本身。因此，如果应用程序提供了自己的内存分配子系统，则可以根据需要忽略这些接口。</target>
        </trans-unit>
        <trans-unit id="5e6bfb4cf13a4a1ec7a21d1345619d3a829697d4" translate="yes" xml:space="preserve">
          <source>These interfaces impose limits on the amount of heap memory that will be by all database connections within a single process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d867180f3b3d1ed5572faf6a624799c6449d787" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">这些接口提供的信息与&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;，&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;和&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同，但与库而不是头文件关联。谨慎的程序员可能在其应用程序中包含assert（）语句，以验证这些接口返回的值与标头中的宏相匹配，从而确保使用匹配的库和标头文件来编译应用程序。</target>
        </trans-unit>
        <trans-unit id="7e7f85933d01fbbc2719e5dc64309e8e175f6d5d" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">这些接口提供的信息与&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;，&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;和&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同，但与库而不是头文件关联。谨慎的程序员可能在其应用程序中包含assert（）语句，以验证这些接口返回的值与标头中的宏相匹配，从而确保使用匹配的库和标头文件来编译应用程序。</target>
        </trans-unit>
        <trans-unit id="8f3967be8dcb65457d2a35a639ddbcd4e8748853" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">这些接口返回&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象的当前状态。</target>
        </trans-unit>
        <trans-unit id="9f4d86f27a761f3cf1b6a9d1b51464453bd7acc2" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">这些接口返回&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象的当前状态。</target>
        </trans-unit>
        <trans-unit id="edf2097b32647c30069fed117ef937baf26e2654" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a8d7ae768abbd8bdb6f16b4e0e326ba78812f7" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">这些宏仅在Windows上可用。它们为&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口的type参数定义了允许的值。</target>
        </trans-unit>
        <trans-unit id="a687dbdbbc158f7b1d8247c45af66df0ad45cf41" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">这些宏仅在Windows上可用。它们为&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口的type参数定义了允许的值。</target>
        </trans-unit>
        <trans-unit id="a53b463320023e1da4e50fb5fb587f4bc7e0b044" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285af12f9b73f8c383619a138a0750effc7e59e8" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efdced9c4da4c580aa62b3a5a3c4685a1b1ed67" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">这些宏为&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;接口定义了各种选项，&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现可用于自定义和优化其行为。</target>
        </trans-unit>
        <trans-unit id="648697ac8bc614b007ee6a86dba8449e42be0af2" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">这些宏为&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;接口定义了各种选项，&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现可用于自定义和优化其行为。</target>
        </trans-unit>
        <trans-unit id="e2c086e3788cfb99a6897d54171eed03d73b01e8" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">这些宏定义了&lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。op字段的允许值。每个值代表一个运算符，该运算符是使用&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的查询的wHERE子句中约束条件的一部分。</target>
        </trans-unit>
        <trans-unit id="fa39882fd7522d6ac624eca8d9d3a80dde9e04fa" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">这些宏定义了&lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。op字段的允许值。每个值代表一个运算符，该运算符是使用&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的查询的wHERE子句中约束条件的一部分。</target>
        </trans-unit>
        <trans-unit id="cef481ad6fa7db18e075879f04ed74ee515d6f8c" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">这些方法不返回结果代码。如果发生错误，则将该事实记录在&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象中，并且可以通过后续调用&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;来恢复。</target>
        </trans-unit>
        <trans-unit id="cf9638bb05ccc82e92352f4c91e50e88181ed764" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">这些方法不返回结果代码。如果发生错误，则将该事实记录在&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象中，并且可以通过后续调用&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;来恢复。</target>
        </trans-unit>
        <trans-unit id="c8abab119f90d9828a9a200b591657ce6dda56d7" translate="yes" xml:space="preserve">
          <source>These methods provide the virtual table implementation an opportunity to implement nested transactions. They are always optional and will only be called in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23) and later.</source>
          <target state="translated">这些方法为虚拟表实现提供了实现嵌套事务的机会。它们始终是可选的，并且只能在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;3.7.7&lt;/a&gt;（2011-06-23）及更高版本中调用。</target>
        </trans-unit>
        <trans-unit id="46bde550196023cbdbd528e902d936fa4e39c988" translate="yes" xml:space="preserve">
          <source>These operations are described in detail in section</source>
          <target state="translated">这些操作将在以下章节中详细介绍</target>
        </trans-unit>
        <trans-unit id="8a581a47ac4eaa711b3f420b4ba4930e1f71a44b" translate="yes" xml:space="preserve">
          <source>These options are obsolete and should not be used by new code. They are retained for backwards compatibility but are now no-ops.</source>
          <target state="translated">这些选项已经过时,不应该被新代码使用。保留这些选项是为了向后的兼容性,但现在已经没有了。</target>
        </trans-unit>
        <trans-unit id="559388a0d9af9b6cbe52d397cd3542b5b1c78fdd" translate="yes" xml:space="preserve">
          <source>These pages are intended to be precise and detailed specification. For a tutorial introduction, see instead:</source>
          <target state="translated">这些页面旨在精确和详细的规范。关于教程介绍,请参见。</target>
        </trans-unit>
        <trans-unit id="6abb0e63f8d45e8d38ed1d32dbd7bc6804598807" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">这些参数及其含义如有更改，恕不另行通知。这些值仅用于测试目的。应用程序不应使用任何这些参数或&lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="572f36fd8fcb5b2b9a0c163c10706d2d9c69fa95" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">这些参数及其含义如有更改，恕不另行通知。这些值仅用于测试目的。应用程序不应使用任何这些参数或&lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="f8a0b86303fc051c5fd0870031ccb3460d4da0f7" translate="yes" xml:space="preserve">
          <source>These pragmas are only available in builds using non-standard compile-time options.</source>
          <target state="translated">这些实用程序只在使用非标准编译时选项的构建中可用。</target>
        </trans-unit>
        <trans-unit id="7d1b3b12b0e1a81b824764e591a7c4f5ca02302c" translate="yes" xml:space="preserve">
          <source>These pragmas are used for testing SQLite and are not recommended for use in application programs.</source>
          <target state="translated">这些实用程序用于测试SQLite,不建议在应用程序中使用。</target>
        </trans-unit>
        <trans-unit id="995493d489d94b8be4b015e9bc63ccee86968693" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">这些预处理器宏定义整数代码，这些整数代码命名与&lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;接口关联的计数器值。各个计数器的含义如下：</target>
        </trans-unit>
        <trans-unit id="45f1f746bd34bc0ce563d83def09a125c5bf05c1" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">这些预处理器宏定义整数代码，这些整数代码命名与&lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;接口关联的计数器值。各个计数器的含义如下：</target>
        </trans-unit>
        <trans-unit id="c705c2e0cd7b6320d8503e4412e5e99c6ba613d2" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2638c6822db8d54f4bd5ddffbdd3a5cd063ac265" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">这些例程已弃用。使用&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;接口代替此处描述的例程。</target>
        </trans-unit>
        <trans-unit id="79eec12a37e6ba999a536376578f3d7f9c0f472e" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">这些例程已弃用。使用&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;接口代替此处描述的例程。</target>
        </trans-unit>
        <trans-unit id="88da5c4ccf3f13c2b355a0a8cea0eee5123dacc4" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">这些例程由实现SQL函数和聚合的xFunc或xFinal回调使用。有关其他信息，请参见&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ac11b77df30733555a1b785ff3b36747aa22425" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">这些例程由实现SQL函数和聚合的xFunc或xFinal回调使用。有关其他信息，请参见&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a645fc58a9b80b5d58439099cf576c18383cf676" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">这些例程用于注册新的&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;名称。在使用模块创建新的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;之前以及在使用模块的现有&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;之前，必须注册模块名称。</target>
        </trans-unit>
        <trans-unit id="947d0c2cba6cd0b29a7af62bdccba7526d0c92de" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">这些例程用于注册新的&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;名称。在使用模块创建新的&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;之前以及在使用模块的现有&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;之前，必须注册模块名称。</target>
        </trans-unit>
        <trans-unit id="52698fd9d4ddf179ee30cea3431e78d27c345761" translate="yes" xml:space="preserve">
          <source>These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing. These routines return 1 if the input string appears to be a complete SQL statement. A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement. Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator. Whitespace and comments that follow the final semicolon are ignored.</source>
          <target state="translated">这些例程在命令行输入过程中很有用,可以确定当前输入的文本是否是一条完整的SQL语句,或者在将文本发送到SQLite进行解析之前是否需要额外的输入。如果输入的字符串看起来是一条完整的SQL语句,这些例程就返回1。如果一条语句以分号结束,并且不是一个完整的CREATE TRIGGER语句的前缀,那么这条语句就被认为是完整的。嵌入在字符串字面或引号标识符名称或注释中的分号不是独立的标记(它们是嵌入其中的标记的一部分),因此不作为语句结束符。最后分号后面的空白和注释会被忽略。</target>
        </trans-unit>
        <trans-unit id="1eee207918e3686e6a6a0aff77d6f8f4cd324299" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;../printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;../printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;../printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;../printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">这些例程与标准C库中的&amp;ldquo; printf（）&amp;rdquo;函数家族相似。这些例程了解标准库printf（）的大多数常见格式设置选项以及一些其他非标准格式（&lt;a href=&quot;../printf#percentq&quot;&gt;％q&lt;/a&gt;，&lt;a href=&quot;../printf#percentq&quot;&gt;％Q&lt;/a&gt;，&lt;a href=&quot;../printf#percentw&quot;&gt;％w&lt;/a&gt;和&lt;a href=&quot;../printf#percentz&quot;&gt;％z&lt;/a&gt;）。有关详细信息，请参见&lt;a href=&quot;../printf&quot;&gt;内置的printf（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="5d6ce4df9ede9c6a9b8604117d8eeec42326da1e" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">这些例程与标准C库中的&amp;ldquo; printf（）&amp;rdquo;函数家族相似。这些例程了解标准库printf（）的大多数常见格式设置选项以及一些其他非标准格式（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;，&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;，&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;和&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;）。有关详细信息，请参见&lt;a href=&quot;printf&quot;&gt;内置的printf（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="d695b797410a06f75931294f55b67ec9c439fcc7" translate="yes" xml:space="preserve">
          <source>These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL.</source>
          <target state="translated">这些例程不会解析SQL语句,因此不会检测到语法错误的SQL。</target>
        </trans-unit>
        <trans-unit id="7531da5fcda9441742ab989cffc3d5a7ea0da49d" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">这些例程从&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象提取类型，大小和内容信息。受保护的sqlite3_value对象用于将参数信息传递到&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;和&lt;a href=&quot;vtab&quot;&gt;虚拟表的实现中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="780ed181ddbb53bd0cd75f887c1efe5a712dae77" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79baca34267204233cef0f72fa563f702ea3b9b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">这些例程从&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象提取类型，大小和内容信息。受保护的sqlite3_value对象用于将参数信息传递到&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;和&lt;a href=&quot;../vtab&quot;&gt;虚拟表的实现中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="080e4929a8edf88eab58f3131b66975c555d313b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6356562f1a7ea967d47e4aa35dbd596cfeb17ce" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">必须从与提供&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value *&lt;/a&gt;参数的SQL函数相同的线程中调用这些例程。</target>
        </trans-unit>
        <trans-unit id="ea74f3659cddc5ce0c6b4fa5c6b8b6ea6fcf9692" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">必须从与提供&lt;a href=&quot;value&quot;&gt;sqlite3_value *&lt;/a&gt;参数的SQL函数相同的线程中调用这些例程。</target>
        </trans-unit>
        <trans-unit id="a54537ed3c843a1d7c75c98c519dd12715dd5904" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread in which the SQL function is running.</source>
          <target state="translated">这些例程必须从运行SQL函数的同一线程中调用。</target>
        </trans-unit>
        <trans-unit id="aea4f6b4200dc559c39531008b13c73c4dca39ea" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">这些例程打开由filename参数指定的SQLite数据库文件。 filename参数对于sqlite3_open（）和sqlite3_open_v2（）解释为UTF-8，对于sqlite3_open16（）则以本机字节顺序解释为UTF-16。一个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;手柄通常在* PPDB返回，即使发生错误。唯一的例外是，如果SQLite无法分配内存来容纳&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象，则会将一个NULL写入* ppDb而不是指向&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的指针。如果成功打开（和/或创建）数据库，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。否则，将返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。所述&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;在任何sqlite3_open（）例程失败之后，可以使用该例程获取错误的英语描述。</target>
        </trans-unit>
        <trans-unit id="24814302ce83d408ddc70164757005571a98a1af" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">这些例程打开由filename参数指定的SQLite数据库文件。 filename参数对于sqlite3_open（）和sqlite3_open_v2（）解释为UTF-8，对于sqlite3_open16（）则以本机字节顺序解释为UTF-16。一个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;手柄通常在* PPDB返回，即使发生错误。唯一的例外是，如果SQLite无法分配内存来容纳&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象，则会将一个NULL写入* ppDb而不是指向&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的指针。如果成功打开（和/或创建）数据库，则返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。否则，将返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。所述&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;在任何sqlite3_open（）例程失败之后，可以使用该例程获取错误的英语描述。</target>
        </trans-unit>
        <trans-unit id="4cb0a6ed5fd628702f759fa88fc57a08522ef219" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">这些例程提供了一种确定数据库，表和表列的方法，该数据库，表和表列是&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句中特定结果列的来源。数据库或表或列的名称可以作为UTF-8或UTF-16字符串返回。 _database_例程返回数据库名称，_table_例程返回表名称，origin_例程返回列名称。返回的字符串是有效的，直到使用&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;stmt&quot;&gt;准备好的语句，&lt;/a&gt;或者直到第一次调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;来为特定运行自动重新编写该语句为止，或者直到再次以不同的编码请求相同的信息为止。</target>
        </trans-unit>
        <trans-unit id="6747cec9622a96ae1091ed2adc2461d962bf2710" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">这些例程提供了一种确定数据库，表和表列的方法，该数据库，表和表列是&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句中特定结果列的来源。数据库或表或列的名称可以作为UTF-8或UTF-16字符串返回。 _database_例程返回数据库名称，_table_例程返回表名称，origin_例程返回列名称。返回的字符串是有效的，直到使用&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句，&lt;/a&gt;或者直到第一次调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;来为特定运行自动重新编写该语句为止，或者直到再次以不同的编码请求相同的信息为止。</target>
        </trans-unit>
        <trans-unit id="723ec7b5764e01bb470a171ac81db6f1bccacf01" translate="yes" xml:space="preserve">
          <source>These routines provide access to the set of SQL language keywords recognized by SQLite. Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.</source>
          <target state="translated">这些例程提供了对SQLite识别的SQL语言关键字集的访问。应用程序可以使用这些例程来确定是否需要对特定的标识符进行转义(例如,用双引号括起来),以避免混淆解析器。</target>
        </trans-unit>
        <trans-unit id="c63151a5ae56c785b897a0325e0c6f8aa37ea7fb" translate="yes" xml:space="preserve">
          <source>These routines provide direct access to the version of the Wagner edit-distance function that allows for application-defined weights on edit operations. The first two forms of this function compare pattern P against word W and return the edit distance. In the first function, the langid is assumed to be 0 and in the second, the langid is given by the L parameter. The third form of this function reloads edit distance coefficients from the table named by T.</source>
          <target state="translated">这些例程提供了对 Wagner edit-distance 函数版本的直接访问,该函数允许应用程序定义编辑操作的权重。该函数的前两种形式是将模式 P 与单词 W 进行比较,并返回编辑距离。在第一个函数中,langid被假定为0,而在第二个函数中,langid由L参数给出。该函数的第三种形式是从T命名的表中重新加载编辑距离系数。</target>
        </trans-unit>
        <trans-unit id="6ece6463ac2989d7eff64fecae9f2305cb234cc2" translate="yes" xml:space="preserve">
          <source>These routines register callback functions that can be used for tracing and profiling the execution of SQL statements.</source>
          <target state="translated">这些例程注册了回调函数,可用于跟踪和分析SQL语句的执行情况。</target>
        </trans-unit>
        <trans-unit id="40a118423314c412a0ead5a2681ebf518ed77f67" translate="yes" xml:space="preserve">
          <source>These routines return 0 if the statement is incomplete. If a memory allocation fails, then SQLITE_NOMEM is returned.</source>
          <target state="translated">如果语句不完整,这些例程返回0。如果内存分配失败,则返回SQLITE_NOMEM。</target>
        </trans-unit>
        <trans-unit id="324c17666cfb5119bcfea9a10a94bbaee6b00643" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">这些例程返回有关查询当前结果行的单个列的信息。在每种情况下，第一个参数是指向要评估的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;预&lt;/a&gt;&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt;的指针（从&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其变体之一返回的sqlite3_stmt *），第二个参数是应为其返回信息的列的索引。结果集的最左列索引为0。可以使用&lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;确定结果中的列数。</target>
        </trans-unit>
        <trans-unit id="5435456a1f2380e65f87b371b45464ea838877ae" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">这些例程返回有关查询当前结果行的单个列的信息。在每种情况下，第一个参数是指向要评估的&lt;a href=&quot;stmt&quot;&gt;预&lt;/a&gt;&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt;的指针（从&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其变体之一返回的sqlite3_stmt *），第二个参数是应为其返回信息的列的索引。结果集的最左列索引为0。可以使用&lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;确定结果中的列数。</target>
        </trans-unit>
        <trans-unit id="86c424b8734fe7ddecb01d35115c043c61c06f29" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">这些例程返回分配给&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句结果集中的特定列的名称。sqlite3_column_name（）接口返回一个以零结尾的UTF-8字符串的指针，而sqlite3_column_name16（）返回一个以零结尾的UTF-16字符串的指针。第一个参数是&lt;a href=&quot;stmt&quot;&gt;准备&lt;/a&gt;执行&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句的语句。第二个参数是列号。最左边的列是数字0。</target>
        </trans-unit>
        <trans-unit id="c92c0a5a51a4b6415e4465e481831e591f5adbb3" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">这些例程返回分配给&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句结果集中的特定列的名称。sqlite3_column_name（）接口返回一个以零结尾的UTF-8字符串的指针，而sqlite3_column_name16（）返回一个以零结尾的UTF-16字符串的指针。第一个参数是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备&lt;/a&gt;执行&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句的语句。第二个参数是列号。最左边的列是数字0。</target>
        </trans-unit>
        <trans-unit id="5de2bfd9e6d919b373b4c3d1b80a7310909f2955" translate="yes" xml:space="preserve">
          <source>These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread.</source>
          <target state="translated">这些例程应该在其参数中的mutex分别被调用线程持有或不持有时返回true。</target>
        </trans-unit>
        <trans-unit id="afa365b8dc52497e4284392ecbb9654dff91e29b" translate="yes" xml:space="preserve">
          <source>These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB.</source>
          <target state="translated">如果第一个JSON参数没有格式化,或者任何PATH参数没有格式化,或者任何参数是BLOB,这些例程会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="040db3ed336324c99d540be07030ca6b73dfe1d9" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">这些例程的工作方式与相应的&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;列访问函数&lt;/a&gt;相同，只是这些例程采用单个&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象指针，而不是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt;指针和整数列号。</target>
        </trans-unit>
        <trans-unit id="8f8d6c3e862ca519958d58c8125484847b89c711" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">这些例程的工作方式与相应的&lt;a href=&quot;column_blob&quot;&gt;列访问函数&lt;/a&gt;相同，只是这些例程采用单个&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象指针，而不是&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt;指针和整数列号。</target>
        </trans-unit>
        <trans-unit id="95d389aedaf4f8ce85f9804703017919fd80feca" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">这些例程仅适用于&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。在&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;上使用这些例程的任何尝试都不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="7a8ed928c1fb3dc4a20d3be2fb5cfe01bd35f70b" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">这些例程仅适用于&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。在&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;上使用这些例程的任何尝试都不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="cf9c078687c96682c6a85bb7a67b91a68491a0f8" translate="yes" xml:space="preserve">
          <source>These static mutexes are reserved for use internally by SQLite and should not be used by the application. The static mutexes are all non-recursive.</source>
          <target state="translated">这些静态mutexes是保留给SQLite内部使用的,不应该被应用程序使用。这些静态mutexes都是非递归的。</target>
        </trans-unit>
        <trans-unit id="a11e17b224413c41480316935dad79b1f586c189" translate="yes" xml:space="preserve">
          <source>These techniques are designed to aid in understanding the core SQLite library itself, not applications that merely use SQLite.</source>
          <target state="translated">这些技术旨在帮助理解核心SQLite库本身,而不是仅仅使用SQLite的应用程序。</target>
        </trans-unit>
        <trans-unit id="7f9968558d6525a5e69fdd942a06f1a35ab390ef" translate="yes" xml:space="preserve">
          <source>These tests are on a relatively small (approximately 14 megabyte) database. They do not measure how well the database engines scale to larger problems.</source>
          <target state="translated">这些测试是在一个相对较小(大约14兆字节)的数据库上进行的。它们并不能衡量数据库引擎对更大问题的扩展能力。</target>
        </trans-unit>
        <trans-unit id="f97df2bc02e2ab86d912a22d332def150459caf8" translate="yes" xml:space="preserve">
          <source>These tests did not attempt to measure multi-user performance or optimization of complex queries involving multiple joins and subqueries.</source>
          <target state="translated">这些测试并没有试图测量多用户性能或涉及多个连接和子查询的复杂查询的优化。</target>
        </trans-unit>
        <trans-unit id="dd70aa0fe10c02751ca4c43bd10acab99e561495" translate="yes" xml:space="preserve">
          <source>These three ways of committing a transaction correspond to the DELETE, TRUNCATE, and PERSIST settings, respectively, of the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">这三种提交事务的方式分别对应于journal_mode &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;pragma&lt;/a&gt;的DELETE，TRUNCATE和PERSIST设置。</target>
        </trans-unit>
        <trans-unit id="8f79d49bdd4e3aeeeb4789bde61715a9a01e430c" translate="yes" xml:space="preserve">
          <source>These two rules describe how the query planner for SQLite works as of this writing (2013-08-01). And the rules above will always be honored. However, future versions of SQLite might incorporate a better theorem prover that can find other cases where W&amp;rArr;X is true and thus may find more instances where partial indexes are useful.</source>
          <target state="translated">这两个规则描述了撰写本文时（2013-08-01）的SQLite查询计划程序的工作方式。并且上述规则将始终得到遵守。但是，未来版本的SQLite可能会包含一个更好的定理证明器，它可以找到W&amp;rArr;X为true的其他情况，从而可以找到更多使用部分索引的实例。</target>
        </trans-unit>
        <trans-unit id="c8fd956e215d583a512e53c2c78546d08e30ff46" translate="yes" xml:space="preserve">
          <source>Things That Can Go Wrong</source>
          <target state="translated">可能出错的事情</target>
        </trans-unit>
        <trans-unit id="42067c10086226bb2498180a8a023f3ac259d639" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">如果在运行触发器程序的同时执行sqlite3_changes（）函数，事情将变得更加复杂。如果程序使用&lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes（）SQL函数&lt;/a&gt;，或者某些其他回调函数直接调用sqlite3_changes（），则可能会发生这种情况。本质上：</target>
        </trans-unit>
        <trans-unit id="53a7af1ec1bf96fe1cf7aeeb3a8a96e5b6a416b2" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">如果在运行触发器程序的同时执行sqlite3_changes（）函数，事情将变得更加复杂。如果程序使用&lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes（）SQL函数&lt;/a&gt;，或者某些其他回调函数直接调用sqlite3_changes（），则可能会发生这种情况。本质上：</target>
        </trans-unit>
        <trans-unit id="774483139813d257b6024c3ca6cbcda75578301f" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a separate computer program. The original SQL text is source code. A prepared statement object is the compiled object code. All SQL must be converted into a prepared statement before it can be run.</source>
          <target state="translated">把每条SQL语句看作是一个独立的计算机程序。原始的SQL文本就是源代码。准备好的语句对象就是编译后的对象代码。所有的SQL都必须在运行之前将其转换为准备好的语句。</target>
        </trans-unit>
        <trans-unit id="2f8cd345a6425d660448be637505c8f25ad1aef9" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a small computer program. The purpose of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is to compile that program into object code. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is the object code. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface then runs the object code to get a result.</source>
          <target state="translated">将每个SQL语句视为一个小型计算机程序。&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;的目的是将该程序编译为目标代码。在&lt;a href=&quot;c3ref/stmt&quot;&gt;准备语句&lt;/a&gt;是目标代码。然后，&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口运行目标代码以获取结果。</target>
        </trans-unit>
        <trans-unit id="cfafbb2da361739c04c43a8272cc38856e9c67a7" translate="yes" xml:space="preserve">
          <source>Third Improvement: Versioning</source>
          <target state="translated">第三次改进。版本化</target>
        </trans-unit>
        <trans-unit id="865c9c12492c3442466282bf437772709b257a8a" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirstColumn() set iCol to -1).</source>
          <target state="translated">如果使用以 &quot;detail=none &quot;选项创建的FTS5表,这个API可能会相当慢。如果FTS5表是以 &quot;detail=none&quot;&quot;content=&quot;选项创建的(即如果它是一个无内容的表),那么这个API总是遍历一个空集(所有对xPhraseFirstColumn()的调用都将iCol设置为-1)。</target>
        </trans-unit>
        <trans-unit id="ebf79b4cb55761477acdbbee63fd4654b2112a93" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option.</source>
          <target state="translated">如果使用以 &quot;detail=none &quot;或 &quot;detail=column &quot;选项创建的FTS5表,这个API可能会相当慢。</target>
        </trans-unit>
        <trans-unit id="320a596dec5edeedf6c5c2728a533311ecff7379" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirst() set iCol to -1).</source>
          <target state="translated">如果与以 &quot;detail=none &quot;或 &quot;detail=column &quot;选项创建的FTS5表一起使用,该API可能会相当缓慢。如果FTS5表是以 &quot;detail=none &quot;或 &quot;detail=column &quot;和 &quot;content=&quot;选项创建的(即如果它是一个无内容表),那么这个API总是在一个空集合中迭代(所有对xPhraseFirst()的调用都将iCol设置为-1)。</target>
        </trans-unit>
        <trans-unit id="f65fb946e21f0df296308a1267bfc8d75459c36f" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always returns 0.</source>
          <target state="translated">如果使用以 &quot;detail=none &quot;或 &quot;detail=column &quot;选项创建的FTS5表,该API可能会相当缓慢。如果FTS5表是以 &quot;detail=none &quot;或 &quot;detail=column &quot;和 &quot;content=&quot;选项创建的(即如果它是一个无内容表),那么这个API总是返回0。</target>
        </trans-unit>
        <trans-unit id="43444bfacf757a80f8f09485afde0ead5f0a776e" translate="yes" xml:space="preserve">
          <source>This API function is used to query the FTS table for phrase iPhrase of the current query. Specifically, a query equivalent to:</source>
          <target state="translated">该API函数用于查询当前查询的短语iPhrase的FTS表。具体来说,相当于以下的查询。</target>
        </trans-unit>
        <trans-unit id="d89725045237fc9113c1fa0f974917002e582aec" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">仅当库是使用定义的预处理程序符号&lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt;构建的时，此API才可用。</target>
        </trans-unit>
        <trans-unit id="48dac83568aa304395644b3c39b1c1984d8ea7c3" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">仅当库是使用定义的预处理程序符号&lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt;构建的时，此API才可用。</target>
        </trans-unit>
        <trans-unit id="f548cc5880d8bc2ce8ab0c825c0274336bee682c" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">此API确保存在具有特定名称和参数数量的函数的全局版本。如果在调用此API之前不存在此类函数，则会创建一个新函数。新功能的实现始终会引发异常。因此，新功能本身并不适合任何功能。它的唯一目的是成为一个可以被&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;重载的占位符函数。</target>
        </trans-unit>
        <trans-unit id="8540f6a2004da77a77789ccfaf202735cf5c6ba1" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">此API确保存在具有特定名称和参数数量的函数的全局版本。如果在调用此API之前不存在此类函数，则会创建一个新函数。新功能的实现始终会引发异常。因此，新功能本身并不适合任何功能。它的唯一目的是成为一个可以被&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;重载的占位符函数。</target>
        </trans-unit>
        <trans-unit id="6ab96b1e97da69a025cb8ca96b99b710398cad45" translate="yes" xml:space="preserve">
          <source>This C-preprocess macro determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; configuration setting. It defaults to 1 (on) which means that covering indices are used for full table scans where possible, in order to reduce I/O and improve performance. However, the use of a covering index for a full scan will cause results to appear in a different order from legacy, which could cause some (incorrectly-coded) legacy applications to break. Hence, the covering index scan option can be disabled at compile-time on systems that what to minimize their risk of exposing errors in legacy applications.</source>
          <target state="translated">此C预处理宏确定&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt;配置设置的默认设置。默认为1（开），这意味着覆盖索引将在可能的情况下用于全表扫描，以减少I / O并提高性能。但是，将覆盖索引用于完整扫描将导致结果显示的顺序与旧版的顺序不同，这可能会导致某些（错误编码）的旧版应用程序崩溃。因此，覆盖索引扫描选项可以在编译时在系统上禁用，以最大程度地降低其在遗留应用程序中暴露错误的风险。</target>
        </trans-unit>
        <trans-unit id="9b6673eaea3893e3fceb60fe446b80a1ff19d0e8" translate="yes" xml:space="preserve">
          <source>This DELETE statement will remove every record from the &quot;examp&quot; table where the &quot;two&quot; column is less than 50. The code generated to do this is as follows:</source>
          <target state="translated">这条DELETE语句将删除 &quot;examp &quot;表中 &quot;two &quot;列小于50的每一条记录。为此生成的代码如下:</target>
        </trans-unit>
        <trans-unit id="b0bfab415a485beb9edddb8d5188d00815376867" translate="yes" xml:space="preserve">
          <source>This allows optimizations: (a) when P4==0 there is no need to test the RowSet object for P3, as it is guaranteed not to contain it, (b) when P4==-1 there is no need to insert the value, as it will never be tested for, and (c) when a value that is part of set X is inserted, there is no need to search to see if the same value was previously inserted as part of set X (only if it was previously inserted as part of some other set).</source>
          <target state="translated">这样就可以进行优化。(a)当P4==0时,不需要测试P3的RowSet对象,因为它保证不包含P3;(b)当P4==1时,不需要插入该值,因为它永远不会被测试;(c)当插入一个属于集X的值时,不需要搜索该值以前是否作为集X的一部分被插入(只有当它以前作为其他集的一部分被插入)。</target>
        </trans-unit>
        <trans-unit id="e9de882f0fc5b21571717171f0fcc8e049f8f4b3" translate="yes" xml:space="preserve">
          <source>This allows separate database connections to share the same in-memory database. Of course, all database connections sharing the in-memory database need to be in the same process. The database is automatically deleted and memory is reclaimed when the last connection to the database closes.</source>
          <target state="translated">这样就可以让不同的数据库连接共享同一个内存数据库。当然,所有共享内存数据库的数据库连接都需要在同一个进程中。当最后一个数据库连接关闭时,数据库会被自动删除,内存会被回收。</target>
        </trans-unit>
        <trans-unit id="c92e98ecc01f031d3a1efe7cd735db9a008161b9" translate="yes" xml:space="preserve">
          <source>This article also uses the terms &quot;bytecode program&quot; and &quot;prepared statement&quot; interchangeably, as they are mostly the same thing.</source>
          <target state="translated">本文还交替使用 &quot;字节码程序 &quot;和 &quot;准备好的语句 &quot;这两个术语,因为它们大多是一回事。</target>
        </trans-unit>
        <trans-unit id="a9af0cbe702f19f3f49888228ef0df406a0e5175" translate="yes" xml:space="preserve">
          <source>This article defines what the limits of SQLite are and how they can be customized for specific applications. The default settings for limits are normally quite large and adequate for almost every application. Some applications may want to increase a limit here or there, but we expect such needs to be rare. More commonly, an application might want to recompile SQLite with much lower limits to avoid excess resource utilization in the event of bug in higher-level SQL statement generators or to help thwart attackers who inject malicious SQL statements.</source>
          <target state="translated">本文定义了SQLite的限制是什么,以及如何针对特定的应用进行自定义。通常情况下,限制的默认设置是相当大的,对于几乎所有的应用程序来说都足够了。有些应用程序可能想在这里或那里增加限制,但我们希望这种需求是罕见的。更常见的情况是,一个应用程序可能希望用低得多的限制来重新编译SQLite,以避免在更高级别的SQL语句生成器出现bug的情况下过度使用资源,或者帮助阻止注入恶意SQL语句的攻击者。</target>
        </trans-unit>
        <trans-unit id="316fd7167581f1bf3b1521c621172952b269d34a" translate="yes" xml:space="preserve">
          <source>This article describes how the SQLite developers measure CPU usage, what those measurements actually mean, and the techniques used by SQLite developers on their continuing quest to further reduce the CPU usage of the SQLite library.</source>
          <target state="translated">本文介绍了SQLite开发人员是如何测量CPU使用率的,这些测量结果的实际意义,以及SQLite开发人员在不断追求进一步降低SQLite库的CPU使用率的过程中所使用的技术。</target>
        </trans-unit>
        <trans-unit id="926f25884d306babc2c568ebac87d0360fd509bf" translate="yes" xml:space="preserve">
          <source>This article describes the SQLite OS portability layer or &quot;VFS&quot; - the module at the bottom of the SQLite implementation stack that provides portability across operating systems.</source>
          <target state="translated">本文介绍了SQLite操作系统可移植性层或 &quot;VFS&quot;--SQLite实现栈底部的模块,它提供了跨操作系统的可移植性。</target>
        </trans-unit>
        <trans-unit id="e9493c358448eb3b281eac84dedc92f4531c0a0b" translate="yes" xml:space="preserve">
          <source>This article describes the techniques used by SQLite to create the illusion of atomic commit.</source>
          <target state="translated">本文介绍了SQLite用来制造原子提交假象的技术。</target>
        </trans-unit>
        <trans-unit id="c7354274b5f5ad835c3ba9869336d09f507f1b91" translate="yes" xml:space="preserve">
          <source>This article describes the various temporary files that SQLite creates and uses. It describes when the files are created, when they are deleted, what they are used for, why they are important, and how to avoid them on systems where creating temporary files is expensive.</source>
          <target state="translated">本文介绍了SQLite创建和使用的各种临时文件。它描述了这些文件何时创建,何时删除,它们的用途,为什么它们很重要,以及如何在创建临时文件很昂贵的系统中避免它们。</target>
        </trans-unit>
        <trans-unit id="bf37adfcb2e68d7e2d42601f83e22affd6226d10" translate="yes" xml:space="preserve">
          <source>This article does not contain a step-by-step recipe for compiling SQLite. That would be difficult since each development situation is different. Rather, this article describes and illustrates the principals behind the compilation of SQLite. Typical compilation commands are provided as examples with the expectation that application developers can use these examples as guidance for developing their own custom compilation procedures. In other words, this article provides ideas and insights, not turnkey solutions.</source>
          <target state="translated">本文不包含编译SQLite的步骤秘诀。这将是很困难的,因为每个开发情况都是不同的。相反,本文描述和说明了编译SQLite背后的原理。典型的编译命令是作为例子提供的,希望应用程序开发人员可以使用这些例子作为指导来开发他们自己的自定义编译过程。换句话说,本文提供的是想法和见解,而不是万能的解决方案。</target>
        </trans-unit>
        <trans-unit id="945df33c68655603cf7dd0502f5d42134ad32f1a" translate="yes" xml:space="preserve">
          <source>This article has been revised multiple times in an attempt to improve clarity, address concerns and misgivings, and to fix errors identified on &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; and &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;. The complete edit history can be seen at &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt;. (Usage hint: Click on any two nodes of the graph for a diff.)</source>
          <target state="translated">本文已多次修订，以提高清晰度，解决疑虑和疑虑，并修复在&lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;，&lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt;和&lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;上发现的错误。完整的编辑历史记录可以在&lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in中&lt;/a&gt;查看。（使用提示：单击图的任意两个节点进行比较。）</target>
        </trans-unit>
        <trans-unit id="62a4071d7245439102f2788bb499d61e09713933" translate="yes" xml:space="preserve">
          <source>This article has reviewed all of the major techniques used by SQLite's VDBE to implement SQL statements. What has not been shown is that most of these techniques can be used in combination to generate code for an appropriately complex query statement. For example, we have shown how sorting is accomplished on a simple query and we have shown how to implement a compound query. But we did not give an example of sorting in a compound query. This is because sorting a compound query does not introduce any new concepts: it merely combines two previous ideas (sorting and compounding) in the same VDBE program.</source>
          <target state="translated">本文已经回顾了SQLite的VDBE用来实现SQL语句的所有主要技术。但没有展示的是,这些技术中的大多数可以组合使用,以生成适当复杂的查询语句的代码。例如,我们已经展示了如何在一个简单的查询上完成排序,我们已经展示了如何实现复合查询。但是我们并没有给出复合查询中排序的例子。这是因为对复合查询进行排序并没有引入任何新的概念:它只是在同一个VDBE程序中结合了以前的两个想法(排序和复合)。</target>
        </trans-unit>
        <trans-unit id="a20be3ae1245d83ff9c73306d203b42ad8b16c54" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; a comparison between Fossil and Git. See &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; for one comparison of the two systems. There are others as well.</source>
          <target state="translated">本文&lt;u&gt;不是&lt;/u&gt; Fossil和Git之间的比较。请参阅&lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt;了解两种系统的比较。还有其他。</target>
        </trans-unit>
        <trans-unit id="afdaa5ec4a00df9435f74fca69ef2e683fab815e" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; advocating that you switch your projects away from Git. You can use whatever version control system you want. If you are perfectly happy with Git, then by all means keep using Git. But, if you are wondering if there isn't something better, then maybe try to understand the perspectives presented below. Use the insights thus obtained to find or write a different and better version control system, or to just make improvements to Git itself.</source>
          <target state="translated">本文&lt;u&gt;并不&lt;/u&gt;主张您将项目从Git移开。您可以使用所需的任何版本控制系统。如果您对Git感到非常满意，那么一定要继续使用Git。但是，如果您想知道是否还有更好的选择，那么也许可以尝试理解下面介绍的观点。使用由此获得的见解来查找或编写其他更好的版本控制系统，或仅对Git本身进行改进。</target>
        </trans-unit>
        <trans-unit id="7e8b2b9b07235888ae1de754eef75c5cbe3b972b" translate="yes" xml:space="preserve">
          <source>This article is a brief introduction to how the VDBE works and in particular how the various VDBE instructions (documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;) work together to do useful things with the database. The style is tutorial, beginning with simple tasks and working toward solving more complex problems. Along the way we will visit most submodules in the SQLite library. After completing this tutorial, you should have a pretty good understanding of how SQLite works and will be ready to begin studying the actual source code.</source>
          <target state="translated">本文简要介绍了VDBE的工作方式，尤其是各种VDBE指令（&lt;a href=&quot;opcode&quot;&gt;在此处记录&lt;/a&gt;）如何协同工作以对数据库进行有用的操作。样式是教程，从简单的任务开始，逐步解决更复杂的问题。在此过程中，我们将访问SQLite库中的大多数子模块。完成本教程后，您应该对SQLite的工作原理有很好的了解，并准备开始研究实际的源代码。</target>
        </trans-unit>
        <trans-unit id="2a689ac1a6bfa9fdba228a490c8ca90cb86bfd11" translate="yes" xml:space="preserve">
          <source>This article is about the bottom layer.</source>
          <target state="translated">本条是关于底层的。</target>
        </trans-unit>
        <trans-unit id="8376dd4be0a7eabaff5c0a359df7f198ffdee0ed" translate="yes" xml:space="preserve">
          <source>This article only mentions the most important and most commonly used SQLite interfaces. The SQLite library includes many other APIs implementing useful features that are not described here. A &lt;a href=&quot;c3ref/funclist&quot;&gt;complete list of functions&lt;/a&gt; that form the SQLite application programming interface is found at the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ Interface Specification&lt;/a&gt;. Refer to that document for complete and authoritative information about all SQLite interfaces.</source>
          <target state="translated">本文仅提及最重要和最常用的SQLite接口。 SQLite库包括许多其他API，这些API实现了此处未描述的有用功能。在&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++接口规范中&lt;/a&gt;可以找到构成SQLite应用程序编程接口&lt;a href=&quot;c3ref/funclist&quot;&gt;的功能&lt;/a&gt;的完整列表。有关所有SQLite接口的完整和权威信息，请参阅该文档。</target>
        </trans-unit>
        <trans-unit id="ecb82abd11a7741bac191b285785a86679cd3dd8" translate="yes" xml:space="preserve">
          <source>This article outlines one possible method for keeping a private branch of SQLite in sync with the public SQLite source code. There are many ways of maintaining a private branch, of course. Nobody is compelled to use the method describe here. This article is not trying to impose a particular procedure on maintainers of private branches. The point of this article is to offer an example of one process for maintaining a private branch which can be used as a template for designing processes best suited for the circumstances of each individual project.</source>
          <target state="translated">本文概述了一种可能的方法,让SQLite的私有分支与公共SQLite源代码保持同步。当然,维护私有分支的方法有很多。没有人必须使用这里描述的方法。这篇文章并不是要把一个特定的程序强加给私有分支的维护者。本文的目的是提供一个维护私有分支的过程的例子,它可以作为一个模板来设计最适合每个项目情况的过程。</target>
        </trans-unit>
        <trans-unit id="6e9369c9e16c87662c003b06c9e9f9920fb45e35" translate="yes" xml:space="preserve">
          <source>This article overviews the importance of query planning, describes some of the problems inherent to query planning, and outlines how the NGQP solves those problems.</source>
          <target state="translated">本文概述了查询规划的重要性,描述了查询规划固有的一些问题,并概述了NGQP如何解决这些问题。</target>
        </trans-unit>
        <trans-unit id="edd2ab1205dd1a38d5ce29f020d2d454461aadbe" translate="yes" xml:space="preserve">
          <source>This article presents a technique using the SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface such that calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; block until the required locks are available instead of returning SQLITE_LOCKED immediately. If the sqlite3_blocking_step() or sqlite3_blocking_prepare_v2() functions presented to the left return SQLITE_LOCKED, this indicates that to block would deadlock the system.</source>
          <target state="translated">本文介绍一种使用SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;接口的技术，以便调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;块，直到所需的锁可用为止，而不是立即返回SQLITE_LOCKED。如果显示在左侧的sqlite3_blocking_step（）或sqlite3_blocking_prepare_v2（）函数返回SQLITE_LOCKED，则表明阻塞将使系统死锁。</target>
        </trans-unit>
        <trans-unit id="9498c6cd8712f6376d65af391550cc9e3ffdabcd" translate="yes" xml:space="preserve">
          <source>This block of instruction cleans up the VDBE program. Three of these instructions aren't really required, but are generated by the SQLite parser from its code templates, which are designed to handle more complicated cases.</source>
          <target state="translated">这条指令块清理了VDBE程序。其中有三条指令并不是真正需要的,而是由SQLite解析器从其代码模板中生成的,这些模板是为了处理更复杂的情况而设计的。</target>
        </trans-unit>
        <trans-unit id="4a01a06f54367b20ad3750e286b70148e2c847d5" translate="yes" xml:space="preserve">
          <source>This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of</source>
          <target state="translated">这个内置的窗口函数以与集合窗口函数相同的方式计算每行的窗口框架。它返回</target>
        </trans-unit>
        <trans-unit id="20ec5d83d88c2da3b16c3295bcff75c38125962e" translate="yes" xml:space="preserve">
          <source>This change is an exception to the version number rule described above in that it is neither forwards or backwards compatible. A complete reload of the database is required. This is the only exception.</source>
          <target state="translated">这一变化是上述版本号规则的一个例外,因为它既不向前也不向后兼容。需要完全重新加载数据库。这是唯一的例外。</target>
        </trans-unit>
        <trans-unit id="c6a5f96c5622bed501ea8661519073e0de4f52cd" translate="yes" xml:space="preserve">
          <source>This column also always contains an integer value greater than zero.</source>
          <target state="translated">这一列也总是包含一个大于零的整数值。</target>
        </trans-unit>
        <trans-unit id="fb0358a44a2292d9d05f4777b69d5f05939eb420" translate="yes" xml:space="preserve">
          <source>This column always contains an integer value greater than zero.</source>
          <target state="translated">此列总是包含一个大于零的整数值。</target>
        </trans-unit>
        <trans-unit id="1713bd9e06b77e4bbf5df2753a784a802e3933b6" translate="yes" xml:space="preserve">
          <source>This column determines which &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;languageid&lt;/a&gt; is used to extract vocabulary from the FTS3/4 table.</source>
          <target state="translated">此列确定使用哪种&lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;languageid&lt;/a&gt;从FTS3 / 4表中提取词汇。</target>
        </trans-unit>
        <trans-unit id="285c275d9591ca00ecba379d1be0f439e124856e" translate="yes" xml:space="preserve">
          <source>This column may contain either the text value '*' (i.e. a single character, U+002a) or an integer between 0 and N-1, where N is again the number of user-defined columns in the corresponding FTS table.</source>
          <target state="translated">这一列可以包含文本值'*'(即一个字符,U+002a),也可以是0到N-1之间的整数,其中N又是相应FTS表中用户定义的列数。</target>
        </trans-unit>
        <trans-unit id="65f82075152c89e2aff2366597dc220e2a3e5878" translate="yes" xml:space="preserve">
          <source>This column must be set to NULL. If a non-NULL value is inserted into this column, or if a new non-NULL value is provided using an UPDATE statement, it is an error.</source>
          <target state="translated">此列必须设置为NULL。如果在此列中插入了一个非NULL值,或者使用UPDATE语句提供了一个新的非NULL值,则是一个错误。</target>
        </trans-unit>
        <trans-unit id="e9e3819e4d76ebe92176deabc7d0279eab9fbfc8" translate="yes" xml:space="preserve">
          <source>This column shows the phonetic hash prefix that was used to restrict the search. For any given query, this column should be the same for every row. This information is available for diagnostic purposes and is not normally considered useful in real applications.</source>
          <target state="translated">这一列显示了用于限制搜索的拼音哈希前缀。对于任何给定的查询,这一列对于每一行都应该是相同的。此信息可用于诊断目的,通常不认为在实际应用中有用。</target>
        </trans-unit>
        <trans-unit id="01288c4cfddc172d238625a965b9f1003be61617" translate="yes" xml:space="preserve">
          <source>This command both creates the new repository and populates it with all the latest SQLite code. You can then create a private branch as described in section 3.4.</source>
          <target state="translated">这个命令既创建了新的版本库,又将所有最新的 SQLite 代码填充到版本库中。然后你可以创建一个私有分支,如3.4节所述。</target>
        </trans-unit>
        <trans-unit id="e0ca6b6ac38f5b817649e53a976402c687ab2fa8" translate="yes" xml:space="preserve">
          <source>This command causes SQLite to disconnect from the previous database and reattach to an in-memory database with the content in</source>
          <target state="translated">这条命令会使SQLite断开与前一个数据库的连接,并重新连接到一个内存数据库,内容在</target>
        </trans-unit>
        <trans-unit id="52245829743ea4e1b3e2fa49a0972f85d14c8fbb" translate="yes" xml:space="preserve">
          <source>This command causes the &quot;callback&quot; script to be invoked whenever certain conditions occurs. The conditions are determined by the</source>
          <target state="translated">每当某些条件发生时,这个命令会使 &quot;回调 &quot;脚本被调用。这些条件是由</target>
        </trans-unit>
        <trans-unit id="13f59d1cb3e06c83ff056103acea107f7910080d" translate="yes" xml:space="preserve">
          <source>This command first deletes the entire full-text index, then rebuilds it based on the contents of the table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">此命令首先删除整个全文索引，然后根据表或&lt;a href=&quot;fts5#external_content_tables&quot;&gt;内容表&lt;/a&gt;的内容重建它。它对于&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容表&lt;/a&gt;不可用。</target>
        </trans-unit>
        <trans-unit id="fe5638fc83b6cdbce8fdc02e570b8e2b10a1482f" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It deletes all entries from the full-text index.</source>
          <target state="translated">该命令仅适用于&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部内容&lt;/a&gt;和&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容&lt;/a&gt;表。它将从全文索引中删除所有条目。</target>
        </trans-unit>
        <trans-unit id="7489ecbcacef562551b65244089f9307c364a891" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It is used to delete the index entries associated with a single row from the full-text index. This command and the &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; command are the only ways to remove entries from the full-text index of a contentless table.</source>
          <target state="translated">该命令仅适用于&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部内容&lt;/a&gt;和&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容&lt;/a&gt;表。它用于从全文索引中删除与单行关联的索引条目。该命令和&lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt;命令是从无内容表的全文索引中删除条目的唯一方法。</target>
        </trans-unit>
        <trans-unit id="a1d13a5c03e8731ed6d7cfb96b7277fb1a9eb4b2" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;pgsz&quot; option.</source>
          <target state="translated">该命令用于设置持久化的 &quot;pgz &quot;选项。</target>
        </trans-unit>
        <trans-unit id="b39428042e588fc7d00e73c6e90326dc9e9ea85b" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;rank&quot; option.</source>
          <target state="translated">该命令用于设置持久的 &quot;等级 &quot;选项。</target>
        </trans-unit>
        <trans-unit id="85b16bab1c29894a0c668469c8830c0b869b0913" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;usermerge&quot; option.</source>
          <target state="translated">该命令用于设置持久化的 &quot;usermerge &quot;选项。</target>
        </trans-unit>
        <trans-unit id="3730a7c5668daaf6af3f627c894d5a241eb8942e" translate="yes" xml:space="preserve">
          <source>This command is used to verify that the full-text index is consistent with the contents of the FTS5 table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">此命令用于验证全文索引与FTS5表或&lt;a href=&quot;fts5#external_content_tables&quot;&gt;content表&lt;/a&gt;的内容一致。它对于&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容表&lt;/a&gt;不可用。</target>
        </trans-unit>
        <trans-unit id="1a574335749833522810d0e9deb16c3b1a8c4736" translate="yes" xml:space="preserve">
          <source>This command may also be used with ordinary FTS4 tables, for example if the implementation of the tokenizer changes. It is an error to attempt to rebuild the full-text index maintained by a contentless FTS4 table, since no content will be available to do the rebuilding.</source>
          <target state="translated">该命令也可用于普通的 FTS4 表,例如,如果 tokenizer 的实现发生了变化。试图重建由无内容的 FTS4 表维护的全文索引是错误的,因为没有内容可以重建。</target>
        </trans-unit>
        <trans-unit id="61072f8fd085f0b1c6b3c6456d8203db4cf536aa" translate="yes" xml:space="preserve">
          <source>This command merges all individual b-trees that currently make up the full-text index into a single large b-tree structure. This ensures that the full-text index consumes the minimum space within the database and is in the fastest form to query.</source>
          <target state="translated">该命令将当前构成全文索引的所有单个b树合并为一个大b树结构。这样可以保证全文索引在数据库中占用的空间最小,而且是以最快的形式进行查询。</target>
        </trans-unit>
        <trans-unit id="51ac15b2185be7d66cfb5466a048917c1313d8ae" translate="yes" xml:space="preserve">
          <source>This command merges b-tree structures together until roughly N pages of merged data have been written to the database, where N is the absolute value of the parameter specified as part of the 'merge' command. The size of each page is as configured by the &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz option&lt;/a&gt;.</source>
          <target state="translated">此命令将b树结构合并在一起，直到大约N页合并数据已写入数据库，其中N是作为&amp;ldquo;合并&amp;rdquo;命令的一部分指定的参数的绝对值。每页的大小由&lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz选项&lt;/a&gt;配置。</target>
        </trans-unit>
        <trans-unit id="f6ccb891d0018f34c8b539ed4ad53a6be49ac1c9" translate="yes" xml:space="preserve">
          <source>This command sequence is a lot to memorize and type. (One would want to create a bash alias or short shell script if it were used frequently.) Furthermore, it is not quite the same thing. The command above gives one a list of descendents without showing the branching structure, which is important for understanding what happened. In contrast, Fossil offers displays such as &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt;, which is a tremendous help in analyzing the aftermath of historical changes.</source>
          <target state="translated">这个命令序列要记住和键入很多。（如果经常使用的话，可能要创建一个bash别名或简短的shell脚本。）此外，它也不是完全一样的。上面的命令给出了一个后代列表，但未显示分支结构，这对于理解发生的事情很重要。相反，Fossil提供了诸如&lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15之类的&lt;/a&gt;显示，这在分析历史变化的后果方面提供了巨大的帮助。</target>
        </trans-unit>
        <trans-unit id="309dfaa9b377c5a8af4ac33fa681865f1bffbfb3" translate="yes" xml:space="preserve">
          <source>This command will create a new branch named &quot;private&quot; (you can use a different name if you like) and assign it a background color of light blue (&quot;#add8e8&quot;). You can omit the background color if you want, though having a distinct background does make it easier to tell the branch from the &quot;trunk&quot; (the public branch) on timeline displays. You can change the background color of the private branch or of the public branch (the &quot;trunk&quot;) using the web interface if you like.</source>
          <target state="translated">这条命令将创建一个名为 &quot;private &quot;的新分支(如果你愿意,可以使用不同的名字),并为它指定一个浅蓝色的背景色(&quot;#add8e8&quot;)。如果你想的话,你可以省略背景色,尽管有一个独特的背景的确可以让你更容易在时间轴上区分该分支和 &quot;主干&quot;(公共分支)。如果你愿意,你可以使用 Web 界面改变私有分支或公共分支(&quot;主干&quot;)的背景颜色。</target>
        </trans-unit>
        <trans-unit id="5db5e98e2fd20bba8ab658518e972deb34aab3ef" translate="yes" xml:space="preserve">
          <source>This command-line shell leaves unnamed parameters unbound, meaning that they will have a value of an SQL NULL, but named parameters might be assigned values. If there exists a TEMP table named &quot;sqlite_parameters&quot; with a schema like this:</source>
          <target state="translated">这个命令行shell没有绑定未命名的参数,这意味着它们的值是SQL NULL,但是命名的参数可能会被赋值。如果存在一个名为 &quot;sqlite_parameters &quot;的TEMP表,其模式是这样的。</target>
        </trans-unit>
        <trans-unit id="4c4b4e9517b3e559a4264bd38d883b4075b15dd6" translate="yes" xml:space="preserve">
          <source>This compile-time option affects the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator only and has no impact on the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface.</source>
          <target state="translated">此编译时选项仅影响SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符，对&lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike（）&lt;/a&gt; C语言接口没有影响。</target>
        </trans-unit>
        <trans-unit id="6c67f3211a79226589052fa652c6121f10cd5b9d" translate="yes" xml:space="preserve">
          <source>This compile-time option causes the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator to always return False if either operand is a BLOB. The default behavior of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; is that BLOB operands are cast to TEXT before the comparison is done.</source>
          <target state="translated">如果任一操作数是BLOB，则此编译时选项会使&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符始终返回False。&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;的默认行为是在完成比较之前将BLOB操作数强制转换为TEXT。</target>
        </trans-unit>
        <trans-unit id="b087b90d5f82c6cd11bb4d6150e1edc15e3c7080" translate="yes" xml:space="preserve">
          <source>This compile-time option changes the default setting of the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;. When this option is not used, secure_delete defaults to off. When this option is present, secure_delete defaults to on.</source>
          <target state="translated">此编译时选项更改&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;的默认设置。不使用此选项时，secure_delete默认为关闭。存在此选项时，secure_delete默认为打开。</target>
        </trans-unit>
        <trans-unit id="ec3013abfee74643b8705338ad5e107049f5af6c" translate="yes" xml:space="preserve">
          <source>This compile-time option disables the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; command.</source>
          <target state="translated">此编译时选项禁用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="3400d01afcac3cfb7345138b17405acb7d27f932" translate="yes" xml:space="preserve">
          <source>This compile-time option enables SQLite to take advantage batch atomic write capabilities in the underlying filesystem. As of SQLite version 3.21.0 (2017-10-24) this is only supported on &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt;. However, the interface is implemented generically, using &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; so the capability can be added to other filesystem times in the future. When this option is enabled, SQLite automatically detects that the underlying filesystem supports batch atomic writes, and when it does so it avoids writing the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; for transaction control. This can make transactions over twice as fast, while simultaneously reducing wear on SSD storage devices.</source>
          <target state="translated">该编译时选项使SQLite可以利用基础文件系统中的批处理原子写功能。从SQLite版本3.21.0（2017-10-24）开始，仅在&lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS上&lt;/a&gt;支持此功能。但是，该接口是通过使用带&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;和&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE的&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;来通用实现的，因此将来可以将该功能添加到其他文件系统中。启用此选项后，SQLite会自动检测到基础文件系统支持批处理原子写，并且这样做时，它避免编写&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;用于交易控制。这可以使事务处理速度提高两倍，同时减少SSD存储设备的磨损。</target>
        </trans-unit>
        <trans-unit id="2a47cb88e70b43c326cbb7cc659779aee23f98fe" translate="yes" xml:space="preserve">
          <source>This compile-time option enables the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; logic.</source>
          <target state="translated">此编译时选项启用&lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT虚拟表&lt;/a&gt;逻辑。</target>
        </trans-unit>
        <trans-unit id="ff47a638485535b8abdf68c6579ec40497b2ae91" translate="yes" xml:space="preserve">
          <source>This compile-time option has been renamed to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;.</source>
          <target state="translated">此编译时选项已重命名为&lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0b75f253921594adb213c37bae38c55286027e5" translate="yes" xml:space="preserve">
          <source>This compile-time option is deprecated and untested.</source>
          <target state="translated">这个编译时的选项已经废弃,并且未经测试。</target>
        </trans-unit>
        <trans-unit id="3be0a309752742e7707ae2403c4dadee6c132ddc" translate="yes" xml:space="preserve">
          <source>This compile-time option is no longer used.</source>
          <target state="translated">这个编译时的选项已不再使用。</target>
        </trans-unit>
        <trans-unit id="4333e0a432302d984fdf33eabb1d1ed8fc11d61a" translate="yes" xml:space="preserve">
          <source>This compile-time option makes SQLite run more efficiently when processing queries that use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator, at the expense of breaking backwards compatibility. However, the backwards compatibility break may be only a technicality. There was a long-standing bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; processing logic (see &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt;) that caused it to misbehavior for BLOB operands and nobody observed that bug in nearly 10 years of active use. So for more users, it is probably safe to enable this compile-time option and thereby save a little CPU time on LIKE queries.</source>
          <target state="translated">当处理使用&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符的查询时，此编译时选项使SQLite的运行效率更高，但代价是破坏了向后兼容性。但是，向后兼容性中断可能只是技术问题。&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;处理逻辑中存在一个长期存在的错误（请参阅&lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt;），导致它对BLOB操作数的行为不佳，并且在将近10年的活跃使用中没有人发现该错误。 。因此，对于更多用户而言，启用此编译时选项可能很安全，从而可以在LIKE查询上节省一点CPU时间。</target>
        </trans-unit>
        <trans-unit id="65b9357f2e420dd3508c81b4ae3257d2786b19ca" translate="yes" xml:space="preserve">
          <source>This constraint arises from the fact that numbers do not sort in lexicographical order. For example: 9&amp;lt;10 but '9'&amp;gt;'10'.</source>
          <target state="translated">这种限制是由于数字没有按字典顺序排序而产生的。例如：9 &amp;lt;10但'9'&amp;gt;'10'。</target>
        </trans-unit>
        <trans-unit id="187432feb7a09e6addc8b4c1a243d9ef78920104" translate="yes" xml:space="preserve">
          <source>This design note considers the database to be a collection of objects. Each SQL table is a class. Each row is an instance of that class. There are, of course, other ways to interpret an SQL database schema, and the techniques described here work equally well under alternative interpretations, but an object-oriented view seems be more natural to most contemporary programmers.</source>
          <target state="translated">本设计说明认为数据库是一个对象的集合。每个SQL表是一个类。每一行都是该类的一个实例。当然,还有其他的方法来解释SQL数据库模式,这里描述的技术在其他解释下也同样有效,但对于大多数当代程序员来说,面向对象的观点似乎更自然。</target>
        </trans-unit>
        <trans-unit id="7f5cd63f8a1306fc33b54e6f33d75fb0c8f5824b" translate="yes" xml:space="preserve">
          <source>This document describes SQLite internals. The information provided here is not needed for routine application development using SQLite. This document is intended for people who want to delve more deeply into the internal operation of SQLite.</source>
          <target state="translated">本文档描述了SQLite的内部结构。这里提供的信息对于使用SQLite进行常规的应用开发是不需要的。本文档是为那些想更深入地了解SQLite内部操作的人准备的。</target>
        </trans-unit>
        <trans-unit id="29000c12ac32a9037c669c50606cdb73ab6f60c1" translate="yes" xml:space="preserve">
          <source>This document describes and defines the on-disk database file format used by all releases of SQLite since version 3.0.0 (2004-06-18).</source>
          <target state="translated">本文档描述并定义了自3.0.0版本(2004-06-18)以来所有版本的SQLite所使用的磁盘数据库文件格式。</target>
        </trans-unit>
        <trans-unit id="dc53982e7fc871bc167dd841afd5d1fa7b1536a4" translate="yes" xml:space="preserve">
          <source>This document describes how to obtain the canonical source code for SQLite - the raw source files from which the amalgamation is built. See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page for additional information on what to do with the canonical source code once it is obtained.</source>
          <target state="translated">本文档介绍了如何获取SQLite的规范源代码-构建合并的原始源文件。有关&lt;a href=&quot;howtocompile&quot;&gt;如何&lt;/a&gt;获取规范源代码的更多信息，请参见&amp;ldquo; 如何编译SQLite&amp;rdquo;页面。</target>
        </trans-unit>
        <trans-unit id="8cb17c7b427d4b622c77f47d250d842b7e4339f9" translate="yes" xml:space="preserve">
          <source>This document describes in detail the way that SQLite uses the API provided by the VFS adaptor component to solve the problems and implement the strategies enumerated above. It also specifies the assumptions made about the properties of the system that the VFS adaptor provides access to. For example, specific assumptions about the extent of data corruption that may occur if a power failure occurs while a database file is being updated are presented in section</source>
          <target state="translated">本文档详细描述了SQLite使用VFS适配器组件提供的API来解决问题和实现上面列举的策略的方式。它还指定了对VFS适配器提供访问的系统属性所做的假设。例如,关于在更新数据库文件时发生断电时可能发生的数据损坏程度的具体假设,在第</target>
        </trans-unit>
        <trans-unit id="7da4581d4d5128e1ce5220b57b58fd4271a11dba" translate="yes" xml:space="preserve">
          <source>This document describes incompatibilities that have occurred in SQLite prior to 2004. Since 2004, there have been enhancements to SQLite such that newer database files are unreadable by older versions of the SQLite library. But the most recent versions of the SQLite library should be able to read and write any older SQLite database file without any problems.</source>
          <target state="translated">本文档描述了2004年以前SQLite中发生的不兼容问题。自2004年以来,SQLite的功能得到了增强,旧版本的SQLite库无法读取较新的数据库文件,但最新版本的SQLite库应该可以毫无问题地读取和写入任何旧的SQLite数据库文件。但是,最新版本的SQLite库应该能够毫无问题地读写任何旧版SQLite数据库文件。</target>
        </trans-unit>
        <trans-unit id="522199e4ebe6e710a972b890a7a5a64190cc5d3b" translate="yes" xml:space="preserve">
          <source>This document describes low-level details on how &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is implemented on unix and windows.</source>
          <target state="translated">本文档介绍了有关如何在UNIX和Windows上实现&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;的底层细节。</target>
        </trans-unit>
        <trans-unit id="86876920b62069808dcd8a4f6cfa725666d13fe3" translate="yes" xml:space="preserve">
          <source>This document describes the architecture of the SQLite library. The information here is useful to those who want to understand or modify the inner workings of SQLite.</source>
          <target state="translated">本文档描述了SQLite库的架构。这里的信息对那些想了解或修改SQLite内部工作原理的人很有用。</target>
        </trans-unit>
        <trans-unit id="4d320774e9898d3525e4d8d7e2967bd5937be4b0" translate="yes" xml:space="preserve">
          <source>This document describes the support for SQL foreign key constraints introduced in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14).</source>
          <target state="translated">本文档介绍了SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;3.6.19&lt;/a&gt;（2009-10-14）版本中引入的对SQL外键约束的支持。</target>
        </trans-unit>
        <trans-unit id="2bc5a2a4190725779b47fa8957802675b43bcdcd" translate="yes" xml:space="preserve">
          <source>This document does not contain a full description of the syntax used to create foreign key constraints in SQLite. This may be found as part of the documentation for the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">本文档未完整介绍用于在SQLite中创建外键约束的语法。这可以在&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的文档中找到。</target>
        </trans-unit>
        <trans-unit id="1a95f5bdc9ff03cc2aba9a9f1c4e965180076c32" translate="yes" xml:space="preserve">
          <source>This document does not specify the details of the interface that must be implemented by the VFS adaptor component, that is left to</source>
          <target state="translated">本文档没有指定VFS适配器组件必须实现的接口的细节,那是留给VFS适配器组件的。</target>
        </trans-unit>
        <trans-unit id="4458da44ee2dc70541cbb9f7f722e55f2e9b165b" translate="yes" xml:space="preserve">
          <source>This document focuses on the NGQP. For a more general overview of the SQLite query planner that encompasses the entire history of SQLite, see the &quot;&lt;a href=&quot;optoverview&quot;&gt;The SQLite Query Optimizer Overview&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;queryplanner&quot;&gt;How Indexes Work&lt;/a&gt;&quot; documents.</source>
          <target state="translated">本文档重点介绍NGQP。有关包含SQLite整个历史记录的SQLite查询计划程序的更一般的概述，请参见&amp;ldquo; &lt;a href=&quot;optoverview&quot;&gt;SQLite查询优化器概述&lt;/a&gt; &amp;rdquo;和&amp;ldquo; &lt;a href=&quot;queryplanner&quot;&gt;索引的工作方式&lt;/a&gt; &amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="da2a96113e96df4cba87ef0ebb6ecd70e207ec5c" translate="yes" xml:space="preserve">
          <source>This document gives an overview of the Tcl programming interface for SQLite.</source>
          <target state="translated">本文档概述了SQLite的Tcl编程接口。</target>
        </trans-unit>
        <trans-unit id="a5a4e1d46e6e2a3f39086d506303b41bc25dcc9a" translate="yes" xml:space="preserve">
          <source>This document is a quick introduction to the changes for SQLite 3.0 for users who are already familiar with SQLite version 2.8.</source>
          <target state="translated">本文档是为已经熟悉SQLite 2.8版本的用户快速介绍SQLite 3.0的变化。</target>
        </trans-unit>
        <trans-unit id="c1c02e760418d224f0c07cba5a70ec82e928ba41" translate="yes" xml:space="preserve">
          <source>This document is an introduction to the session extension. The details of the interface are in the separate &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Session Extension C-language Interface&lt;/a&gt; document.</source>
          <target state="translated">本文档是会话扩展的简介。接口的详细信息在单独的&lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;会话扩展C语言接口&lt;/a&gt;文档中。</target>
        </trans-unit>
        <trans-unit id="3ff7ff01849be2d401b1d6230764460ab55eb57e" translate="yes" xml:space="preserve">
          <source>This document is concerned with the persistent state of the database file, and since the wal-index is a transient structure, no further information about the format of the wal-index will be provided here. Additional details on the format of the wal-index are contained in the separate &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; document.</source>
          <target state="translated">该文档与数据库文件的持久状态有关，并且由于wal-index是一个临时结构，因此此处将不提供有关wal-index格式的更多信息。关于wal-index格式的其他详细信息包含在单独的&lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index文件格式&lt;/a&gt;文档中。</target>
        </trans-unit>
        <trans-unit id="ce4f9d4c36f7d70e8b9276d0825d097968bc414d" translate="yes" xml:space="preserve">
          <source>This document is created by a script which scans comments in the source code file sqlite3session.h.</source>
          <target state="translated">这个文档是由一个脚本创建的,它可以扫描源代码文件sqlite3session.h中的注释。</target>
        </trans-unit>
        <trans-unit id="d12748856fa96aaf8fec02bb978ea061f37e25d7" translate="yes" xml:space="preserve">
          <source>This document is still sometimes used as a &quot;Code of Conduct&quot; on supplier registration forms. But it is not a Code of Conduct in the same sense that many communities mean a Code of Conduct. Rather, this document describes the ethical principles upon which SQLite is based. Another way to look at this document is as a succinct description of the SQLite Founder's idea of what it means to be &quot;virtuous&quot;.</source>
          <target state="translated">本文件有时仍被用作供应商登记表上的 &quot;行为守则&quot;。但它并不是像许多社区所说的行为准则那样的行为准则。相反,这份文档描述了SQLite所基于的道德原则。另一种看法是,这份文件是对SQLite创始人关于 &quot;美德 &quot;含义的简明描述。</target>
        </trans-unit>
        <trans-unit id="6ead8dcfb3bc7787acee358a9c3c6b55198ad643" translate="yes" xml:space="preserve">
          <source>This document proposes to use &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;fossil&lt;/a&gt;, but any other distributed software configuration management system such as &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt; or &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt; (a.k.a. &quot;hg&quot;), or &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; could serve just as well. The concept will be the same, though the specifics of the procedure will vary.</source>
          <target state="translated">该文档建议使用&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;化石&lt;/a&gt;，但是其他任何分布式软件配置管理系统（例如&lt;a href=&quot;http://www.monotone.ca/&quot;&gt;单调&lt;/a&gt;或&lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;Mercurial&lt;/a&gt;（aka&amp;ldquo; hg&amp;rdquo;）或&lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git）&lt;/a&gt;也可以使用。尽管该过程的细节会有所不同，但概念是相同的。</target>
        </trans-unit>
        <trans-unit id="98d1415d454d0b20f9e20df74b68698917685b9f" translate="yes" xml:space="preserve">
          <source>This document provides an overview of dynamic memory allocation within SQLite. The target audience is software engineers who are tuning their use of SQLite for peak performance in demanding environments. Nothing in this document is required knowledge for using SQLite. The default settings and configuration for SQLite will work well in most applications. However, the information contained in this document may be useful to engineers who are tuning SQLite to comply with special requirements or to run under unusual circumstances.</source>
          <target state="translated">本文档概述了SQLite中的动态内存分配。目标读者是那些正在调整他们对SQLite的使用以在苛刻的环境中获得最佳性能的软件工程师。本文档中的任何内容都不是使用SQLite的必备知识。SQLite的默认设置和配置在大多数应用程序中都能很好地工作。然而,本文档中包含的信息可能对那些正在调整SQLite以符合特殊要求或在不寻常的环境下运行的工程师有用。</target>
        </trans-unit>
        <trans-unit id="c06afae30b0b7293df04fe27c7c538132693e4c6" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the query planner and optimizer for SQLite works.</source>
          <target state="translated">本文档概述了SQLite的查询规划器和优化器的工作原理。</target>
        </trans-unit>
        <trans-unit id="54a3569b4cf066b2b50e3e942ef2c48ddc1b1732" translate="yes" xml:space="preserve">
          <source>This document provides background information about how the SQLite query planner and query engine work. Programmers can use this information to help create better indexes, and provide hints to help the query planner when needed.</source>
          <target state="translated">本文档提供了关于SQLite查询规划器和查询引擎如何工作的背景信息。程序员可以使用这些信息来帮助创建更好的索引,并在需要时提供提示来帮助查询规划器。</target>
        </trans-unit>
        <trans-unit id="db48c0715525eb5ade6fdd8bc0b1d41936f8012f" translate="yes" xml:space="preserve">
          <source>This document strives to highlight the principal differences between SQLite and other SQL implementations, as an aid to developers that are porting to or from SQLite or who are trying to build a system that works across multiple database engines.</source>
          <target state="translated">本文档力图强调SQLite和其他SQL实现之间的主要区别,以帮助那些正在向SQLite移植或从SQLite移植的开发人员,或者那些试图构建一个能够跨多个数据库引擎工作的系统的开发人员。</target>
        </trans-unit>
        <trans-unit id="499e5ba33e0583ef7d40d010da72b3c26c5f57b3" translate="yes" xml:space="preserve">
          <source>This document was originally called a &quot;Code of Conduct&quot; and was created (in a slightly different format) for the purpose of filling in a box on &quot;supplier registration&quot; forms submitted to the SQLite developers by various minor clients. However, we subsequently learned that &quot;Code of Conduct&quot; has a specific technical meaning within many software development communities, a meaning which was at odds with the intent of this document. Hence, this document is now renamed and replaced by a &lt;a href=&quot;codeofconduct&quot;&gt;Code of Conduct&lt;/a&gt; that does comply with the specific technical requirements was inserted in the place of the old name.</source>
          <target state="translated">该文档最初被称为&amp;ldquo;行为准则&amp;rdquo;，其创建方式（格式略有不同）是为了填写由各个未成年人提交给SQLite开发人员的&amp;ldquo;供应商注册&amp;rdquo;表格上的方框。但是，我们随后了解到，&amp;ldquo;行为准则&amp;rdquo;在许多软件开发社区中具有特定的技术含义，该含义与本文档的意图背道而驰。因此，该文件现在已被重命名并由符合特定技术要求&lt;a href=&quot;codeofconduct&quot;&gt;的行为准则&lt;/a&gt;代替，并以旧名称代替。</target>
        </trans-unit>
        <trans-unit id="9f4b3397370025bf1fdba593094ae6486be0fecb" translate="yes" xml:space="preserve">
          <source>This document was originally created in early 2004 when SQLite version 2 was still in widespread use and was written to introduce the new concepts of SQLite version 3 to readers who were already familiar with SQLite version 2. But these days, most readers of this document have probably never seen SQLite version 2 and are only familiar with SQLite version 3. Nevertheless, this document continues to serve as an authoritative reference to how database file locking works in SQLite version 3.</source>
          <target state="translated">本文档最初创建于2004年初,当时SQLite版本2还在广泛使用,编写本文档的目的是向已经熟悉SQLite版本2的读者介绍SQLite版本3的新概念。但如今,本文档的大多数读者可能从未见过SQLite版本2,只熟悉SQLite版本3。尽管如此,本文档仍然是SQLite版本3中数据库文件锁定工作原理的权威参考。</target>
        </trans-unit>
        <trans-unit id="efa34a5056d6c01d0548b0f2be11ce7b6109059b" translate="yes" xml:space="preserve">
          <source>This experimental &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; provides information about a single &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; in a database file, such as the depth, and estimated number of pages and number of entries, and so forth.</source>
          <target state="translated">这个实验性的&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;提供有关数据库文件中单个&lt;a href=&quot;fileformat2#btree&quot;&gt;B树&lt;/a&gt;的信息，例如深度，估计的页面数和条目数，等等。</target>
        </trans-unit>
        <trans-unit id="0902999854d1422342b1343c7db1457520c25f82" translate="yes" xml:space="preserve">
          <source>This facility is provided for WinRT which does not have an OS mechanism for reading or changing the current working directory. The use of this pragma in any other context is discouraged and may be disallowed in future releases.</source>
          <target state="translated">这个功能是为WinRT提供的,因为WinRT没有一个操作系统机制来读取或改变当前的工作目录。不鼓励在任何其他情况下使用这个pragma,在未来的版本中可能会被禁止。</target>
        </trans-unit>
        <trans-unit id="a16ab751fe0e625eef00360bec04f5c6e2724bea" translate="yes" xml:space="preserve">
          <source>This feature could be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;information schema&lt;/a&gt; by first creating a separate schema using</source>
          <target state="translated">通过首先使用以下方法创建单独的架构，可以使用此功能来实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;信息架构&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bbc13030cdb5706fbe971e91e53cd50c5af469f0" translate="yes" xml:space="preserve">
          <source>This feature is experimental and is subject to change. Further documentation will become available if and when the table-valued functions for PRAGMAs feature becomes officially supported.</source>
          <target state="translated">这个功能是试验性的,可能会有变化。如果PRAGMAs的表值函数得到正式支持,将有进一步的文档。</target>
        </trans-unit>
        <trans-unit id="18abc550835bcdb0029b1a86390eaca991d2351b" translate="yes" xml:space="preserve">
          <source>This field contains a checksum value, calculated based on the contents of the journaled database page data (the previous field) and the values stored in the</source>
          <target state="translated">这个字段包含了一个校验值,它是根据日志数据库页面数据的内容(前一个字段)和存储在数据库中的值计算出来的。</target>
        </trans-unit>
        <trans-unit id="e3760b531cd8fa332f7ee70ed518883a43ad81f8" translate="yes" xml:space="preserve">
          <source>This field contains the original data for the page, exactly as it appeared in the database file before the</source>
          <target state="translated">这个字段包含了页面的原始数据,与数据库文件中出现的数据一模一样。</target>
        </trans-unit>
        <trans-unit id="3ae121150e2dd424e68324ff08f7e0c6c1d0a2a0" translate="yes" xml:space="preserve">
          <source>This field holds a phonetic code derived from coalesce(k1,word). Letters that have similar sounds are mapped into the same symbol. For example, all vowels and vowel clusters become the single symbol &quot;A&quot;. And the letters &quot;p&quot;, &quot;b&quot;, &quot;f&quot;, and &quot;v&quot; all become &quot;B&quot;. All nasal sounds are represented as &quot;N&quot;. And so forth. The mapping is based on ideas found in Soundex, Metaphone, and other long-standing phonetic matching systems. This key can be generated by the function spellfix1_phonehash(X). Hence: k2 = spellfix1_phonehash(coalesce(k1,word))</source>
          <target state="translated">这个字段保存着从coalesce(k1,word)导出的音码。具有相似音的字母被映射到同一个符号中。例如,所有元音和元音群都会变成单一的符号 &quot;A&quot;。而字母 &quot;p&quot;、&quot;b&quot;、&quot;f&quot;、&quot;v &quot;都成为 &quot;B&quot;。所有的鼻音都表示为 &quot;N&quot;。以此类推。这个映射是基于Soundex、Metaphone和其他长期存在的语音匹配系统中的想法。这个键可以通过函数spellfix1_phonehash(X)生成。因此:k2=spellfix1_phonehash(coalesce(k1,word))</target>
        </trans-unit>
        <trans-unit id="7981d385aa4b9ca4b4f9844539885d4afde0da8a" translate="yes" xml:space="preserve">
          <source>This field may contain either an integer or a text field consisting of two integers separated by a space character (unicode codepoint 0x20).</source>
          <target state="translated">该字段可以包含一个整数,也可以包含一个由两个整数组成的文本字段,由一个空格字符隔开(unicode cepepoint 0x20)。</target>
        </trans-unit>
        <trans-unit id="de591efb54fdb80ffddf1b7c9525e6ab9978c95c" translate="yes" xml:space="preserve">
          <source>This field must be set one of integer values 0 and 8, or else to NULL.</source>
          <target state="translated">该字段必须设置为整数值0和8之一,否则为NULL。</target>
        </trans-unit>
        <trans-unit id="7e75b74f43def5b21dd19f54d176219e2332fba0" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;database page count&lt;/b&gt;, is set to the number of pages that the</source>
          <target state="translated">此字段（&lt;b&gt;数据库页数&lt;/b&gt;）设置为</target>
        </trans-unit>
        <trans-unit id="4ce138fa916045f081e00c343e7762b51298df38" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;locking page number&lt;/b&gt;, is always set to the page number of the database</source>
          <target state="translated">此字段（&lt;b&gt;锁定页号&lt;/b&gt;）始终设置为数据库的页号</target>
        </trans-unit>
        <trans-unit id="825eef8a444b33cb8e93566d91167c3eabd02df8" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;record count&lt;/b&gt;, is set to the number of</source>
          <target state="translated">该字段（&lt;b&gt;记录计数&lt;/b&gt;）设置为</target>
        </trans-unit>
        <trans-unit id="f631e740c08280177f2a7f6f8390e6ab3758fda5" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;sector size&lt;/b&gt;, is set to the</source>
          <target state="translated">此字段（&lt;b&gt;扇区大小&lt;/b&gt;）设置为</target>
        </trans-unit>
        <trans-unit id="caf63c1c58b9f87489297844a819efb8d6633a40" translate="yes" xml:space="preserve">
          <source>This flag causes comma-separators to be added to the output of %d and %i substitutions, between every 3 digits from the left. This can help humans to more easily discern the magnitude of large integer values. For example, the value 2147483647 would be rendered as &quot;2147483647&quot; using &quot;%d&quot; but would appear as &quot;2,147,483,647&quot; with &quot;%,d&quot;. This flag is a non-standard extension.</source>
          <target state="translated">这个标志会使%d和%i替换的输出结果中加入逗号分隔符,从左边开始每3个数字之间。这可以帮助人类更容易辨别大的整数值的大小。例如,值2147483647使用&quot;%d &quot;会被渲染为 &quot;2147483647&quot;,但使用&quot;%,d &quot;会显示为 &quot;2,147,483,647&quot;。这个标志是一个非标准的扩展。</target>
        </trans-unit>
        <trans-unit id="a5b80382a268dfe85ecc58efaaccd407cc41e4b2" translate="yes" xml:space="preserve">
          <source>This function adds a set of changes to the session object that could be used to update the table in database zFrom (call this the &quot;from-table&quot;) so that its content is the same as the table attached to the session object (call this the &quot;to-table&quot;). Specifically:</source>
          <target state="translated">该函数向会话对象添加一组变化,可以用来更新数据库zFrom中的表(称之为 &quot;from-table&quot;),使其内容与附加在会话对象上的表(称之为 &quot;to-table&quot;)相同。具体来说,就是</target>
        </trans-unit>
        <trans-unit id="3b5d7e99038e4d5b072061176057f97dc299323e" translate="yes" xml:space="preserve">
          <source>This function and xPhraseNextColumn() are similar to the xPhraseFirst() and xPhraseNext() APIs described above. The difference is that instead of iterating through all instances of a phrase in the current row, these APIs are used to iterate through the set of columns in the current row that contain one or more instances of a specified phrase. For example:</source>
          <target state="translated">这个函数和xPhraseNextColumn()类似于上面描述的xPhraseFirst()和xPhraseNext()API。不同的是,这些API不是遍历当前行中短语的所有实例,而是遍历当前行中包含一个或多个指定短语实例的列的集合。比如说,在当前行中包含一个或多个指定短语实例的列中,这些API用来迭代。</target>
        </trans-unit>
        <trans-unit id="80988b461d2df6302b49f4dceec8b27b005d6908" translate="yes" xml:space="preserve">
          <source>This function attempts to retrieve the text of column iCol of the current document. If successful, (*pz) is set to point to a buffer containing the text in utf-8 encoding, (*pn) is set to the size in bytes (not characters) of the buffer and SQLITE_OK is returned. Otherwise, if an error occurs, an SQLite error code is returned and the final values of (*pz) and (*pn) are undefined.</source>
          <target state="translated">该函数试图检索当前文档中iCol列的文本。如果成功,(*pz)被设置为指向一个包含utf-8编码文本的缓冲区,(*pn)被设置为缓冲区的字节数(不是字符数),并返回SQLITE_OK。否则,如果发生错误,将返回SQLite错误代码,并且(*pz)和(*pn)的最终值未定义。</target>
        </trans-unit>
        <trans-unit id="28a6bb3de337284487682e360c8a725a543916e4" translate="yes" xml:space="preserve">
          <source>This function attempts to scan the WAL file associated with database zDb of database handle db and make all valid snapshots available to sqlite3_snapshot_open(). It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.</source>
          <target state="translated">这个函数试图扫描与数据库句柄db的数据库zDb相关联的WAL文件,并使所有有效的快照都能被sqlite3_snapshot_open()使用。如果数据库上已经打开了一个读事务,或者数据库不是WAL模式的数据库,那么这个函数就会出错。</target>
        </trans-unit>
        <trans-unit id="27eaa9cd67b4a77bfd0fe868cf2e24b92591db2f" translate="yes" xml:space="preserve">
          <source>This function causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema.</source>
          <target state="translated">该函数使所有的数据库模式从磁盘上读取并进行解析,如果还没有这样做的话,如果在加载模式时遇到任何错误,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="7d871089984a2a55cb6c89bf16fcd0bc4a023753" translate="yes" xml:space="preserve">
          <source>This function causes any pending database operation to abort and return at its earliest opportunity. This routine is typically called in response to a user action such as pressing &quot;Cancel&quot; or Ctrl-C where the user wants a long query operation to halt immediately.</source>
          <target state="translated">这个函数使任何待定的数据库操作中止,并在其最早的机会返回。这个例程通常在用户操作时被调用,如按 &quot;Cancel &quot;或Ctrl-C,用户希望一个长查询操作立即停止。</target>
        </trans-unit>
        <trans-unit id="84f0a277d8eb36da2c14763cce01f3221d3f3be5" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">此函数关闭打开的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;。BLOB句柄无条件关闭。即使此例程返回错误代码，句柄仍将关闭。</target>
        </trans-unit>
        <trans-unit id="c52c6ec750ee5ca8bf8f3568aa703ede60385a7a" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">此函数关闭打开的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;。BLOB句柄无条件关闭。即使此例程返回错误代码，句柄仍将关闭。</target>
        </trans-unit>
        <trans-unit id="dcb5cb2e9c08e0b9f3037428dbe4920c74c2b405" translate="yes" xml:space="preserve">
          <source>This function combines the two input changesets using an sqlite3_changegroup object. Calling it produces similar results as the following code fragment:</source>
          <target state="translated">这个函数使用一个sqlite3_changegroup对象将两个输入的变化集结合起来。调用它产生的结果类似于下面的代码片段。</target>
        </trans-unit>
        <trans-unit id="4624a9200d853f2e32a44b7a98a35021843efd43" translate="yes" xml:space="preserve">
          <source>This function does not change the order in which changes appear within the changeset. It merely reverses the sense of each individual change.</source>
          <target state="translated">这个功能并不改变变更集中变更出现的顺序。它只是颠倒了每个单独变化的意义。</target>
        </trans-unit>
        <trans-unit id="d7cbc42833b432d19d25054e50c1379caf39e23d" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">此函数不会设置由&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;函数返回的数据库句柄错误代码或消息。</target>
        </trans-unit>
        <trans-unit id="2c015e6f1fde0378f350b940649e6bb977266a40" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">此函数不会设置由&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;函数返回的数据库句柄错误代码或消息。</target>
        </trans-unit>
        <trans-unit id="6303b7057e9914dac072c1b4a0b74b270e4dc698" translate="yes" xml:space="preserve">
          <source>This function fails with SQLITE_ERROR if any of the following are true:</source>
          <target state="translated">如果以下任何一项为真,该函数将以SQLITE_ERROR失败。</target>
        </trans-unit>
        <trans-unit id="870ceb33e21de66e2ccc8a5ce1caa06026ee0a3c" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">SQL语句可通过&lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）SQL函数&lt;/a&gt;访问此函数。</target>
        </trans-unit>
        <trans-unit id="3ed24a06a5fab16f67d5f77a45744a9d31cdf2e0" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">SQL语句可通过&lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）SQL函数&lt;/a&gt;访问此函数。</target>
        </trans-unit>
        <trans-unit id="ba56f71e7eaf44d8bff350353ce98793aa844743" translate="yes" xml:space="preserve">
          <source>This function is expected to tokenize the nText byte string indicated by argument pText. pText may or may not be nul-terminated. The first argument passed to this function is a pointer to an Fts5Tokenizer object returned by an earlier call to xCreate().</source>
          <target state="translated">这个函数将对参数 pText 所表示的 nText 字节进行标记化处理。传递给本函数的第一个参数是指向一个Fts5Tokenizer对象的指针,该对象由之前调用xCreate()返回。</target>
        </trans-unit>
        <trans-unit id="c0f6fbfd19fbfc44b1560cfd2b05948b7fed7c50" translate="yes" xml:space="preserve">
          <source>This function is invoked to delete a tokenizer handle previously allocated using xCreate(). Fts5 guarantees that this function will be invoked exactly once for each successful call to xCreate().</source>
          <target state="translated">该函数用于删除之前使用 xCreate()分配的 tokenizer 句柄。Fts5 保证每次成功调用 xCreate()时,这个函数都会被调用一次。</target>
        </trans-unit>
        <trans-unit id="fcde84651450f2b10b0843fe43cf87cdc47c8be9" translate="yes" xml:space="preserve">
          <source>This function is used to &quot;invert&quot; a changeset object. Applying an inverted changeset to a database reverses the effects of applying the uninverted changeset. Specifically:</source>
          <target state="translated">这个函数用来 &quot;反转 &quot;一个变化集对象。将一个倒置的变化集应用到数据库中会反转应用未倒置的变化集的效果。具体来说</target>
        </trans-unit>
        <trans-unit id="29ae82377275c7b1f1384fc8e2d212e8da0789d4" translate="yes" xml:space="preserve">
          <source>This function is used to allocate and initialize a tokenizer instance. A tokenizer instance is required to actually tokenize text.</source>
          <target state="translated">该函数用于分配和初始化一个标记符实例。需要一个tokenizer实例来实际标记文本。</target>
        </trans-unit>
        <trans-unit id="24b74a85f4b47c195bc0b6fe21af9724e0d1ed94" translate="yes" xml:space="preserve">
          <source>This function is used to concatenate two changesets, A and B, into a single changeset. The result is a changeset equivalent to applying changeset A followed by changeset B.</source>
          <target state="translated">这个函数用于将两个变化集,A和B,连接成一个变化集。结果是一个变化集,相当于应用变化集A和变化集B。</target>
        </trans-unit>
        <trans-unit id="69eb445f771165e9cf3bdc2eef0ebd4932045f16" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">此函数用于完成分配有&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;的迭代器。</target>
        </trans-unit>
        <trans-unit id="b35815e34122016382887fcb96a49b58070b37da" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">此函数用于完成分配有&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;的迭代器。</target>
        </trans-unit>
        <trans-unit id="2cfec4fd8864b11036478634ce0c848102b439e0" translate="yes" xml:space="preserve">
          <source>This function is used to find which columns comprise the PRIMARY KEY of the table modified by the change that iterator pIter currently points to. If successful, *pabPK is set to point to an array of nCol entries, where nCol is the number of columns in the table. Elements of *pabPK are set to 0x01 if the corresponding column is part of the tables primary key, or 0x00 if it is not.</source>
          <target state="translated">该函数用于查找由迭代器pIter当前指向的变化所修改的表的PRIMARY KEY由哪些列组成。如果成功,*pabPK将被设置为指向一个nCol条目的数组,其中nCol是表中的列数。如果对应的列是表的主键的一部分,则*pabPK的元素被设置为0x01,如果不是,则为0x00。</target>
        </trans-unit>
        <trans-unit id="e114c8bad40f12de287f68c473424a8e6e66648d" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">此函数用于移动现有的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;，使其指向同一数据库表的另一行。新行由作为第二个参数传递的rowid值标识。仅该行可以更改。打开Blob句柄的数据库，表和列保持不变。将现有的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;移动到新行比关闭现有的句柄并打开新的句柄要快。</target>
        </trans-unit>
        <trans-unit id="308c798f0a295eb0c4645e5b7f42fbabbc544780" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">此函数用于移动现有的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;，使其指向同一数据库表的另一行。新行由作为第二个参数传递的rowid值标识。仅该行可以更改。打开Blob句柄的数据库，表和列保持不变。将现有的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;移动到新行比关闭现有的句柄并打开新的句柄要快。</target>
        </trans-unit>
        <trans-unit id="4b885ede0001de9f5c638f038a437a23ced24dd6" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">此函数用于将数据从打开的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;读取到调用方提供的缓冲区中。从偏移量iOffset开始，将N个字节的数据从打开的BLOB复制到缓冲区Z中。</target>
        </trans-unit>
        <trans-unit id="21272222209bb70a086675dada0f2b2f97f0f8e4" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">此函数用于将数据从打开的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;读取到调用方提供的缓冲区中。从偏移量iOffset开始，将N个字节的数据从打开的BLOB复制到缓冲区Z中。</target>
        </trans-unit>
        <trans-unit id="9f3667d662139e493e6cf3b56b1b782512c8bc44" translate="yes" xml:space="preserve">
          <source>This function is used to retrieve the total number of rows in the table. In other words, the same value that would be returned by:</source>
          <target state="translated">这个函数用于检索表中的总行数。换句话说,与以下函数返回的值相同。</target>
        </trans-unit>
        <trans-unit id="b651a758789810b674e3ae5146e089dc27672b54" translate="yes" xml:space="preserve">
          <source>This function is used to set, clear or query the session object indirect flag. If the second argument passed to this function is zero, then the indirect flag is cleared. If it is greater than zero, the indirect flag is set. Passing a value less than zero does not modify the current value of the indirect flag, and may be used to query the current state of the indirect flag for the specified session object.</source>
          <target state="translated">该函数用于设置、清除或查询会话对象的间接标志,如果传递给该函数的第二个参数为零,则清除间接标志。如果传递给此函数的第二个参数为0,则清除间接标志。如果大于零,则设置间接标志。传递的值小于零,则不会修改间接标志的当前值,可用于查询指定会话对象间接标志的当前状态。</target>
        </trans-unit>
        <trans-unit id="57a1761e9d0e1762347b4943de9494b5f2f5f8cc" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">此函数用于将数据从调用者提供的缓冲区写入打开的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄中&lt;/a&gt;。从偏移量iOffset开始，将N个字节的数据从缓冲区Z复制到打开的BLOB中。</target>
        </trans-unit>
        <trans-unit id="959745cc981e8eae46a52bb0e5894da3fa5cff9f" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">此函数用于将数据从调用者提供的缓冲区写入打开的&lt;a href=&quot;blob&quot;&gt;BLOB句柄中&lt;/a&gt;。从偏移量iOffset开始，将N个字节的数据从缓冲区Z复制到打开的BLOB中。</target>
        </trans-unit>
        <trans-unit id="1483892d5daffd0f4eda8275dee22e2f701b626d" translate="yes" xml:space="preserve">
          <source>This function is used, along with type Fts5PhraseIter and the xPhraseNext method, to iterate through all instances of a single query phrase within the current row. This is the same information as is accessible via the xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient to use, this API may be faster under some circumstances. To iterate through instances of phrase iPhrase, use the following code:</source>
          <target state="translated">这个函数与Fts5PhraseIter类型和xPhraseNext方法一起,用来遍历当前行中单个查询短语的所有实例。这与通过xInstCount/xInst APIs访问的信息相同。虽然xInstCount/xInst APIs使用起来更方便,但在某些情况下,这个API可能更快。要遍历短语iPhrase的实例,请使用以下代码。</target>
        </trans-unit>
        <trans-unit id="2e540303404a447a74d8a0d678f9bad1c3c4058d" translate="yes" xml:space="preserve">
          <source>This function maps every page number into an integer between 0 and 8191 inclusive. The aHash field of each 32768-byte shm file unit maps P values into indexes of the aPgno field of the same unit as follows:</source>
          <target state="translated">这个函数将每个页码映射成0到8191之间的整数。每个32768字节的shm文件单元的aHash字段将P值映射到同一单元的aPgno字段的索引中,如下所示。</target>
        </trans-unit>
        <trans-unit id="b474b368c95d2db3e02f8d968fb517ea9f808a38" translate="yes" xml:space="preserve">
          <source>This function may also return SQLITE_NOMEM. If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.</source>
          <target state="translated">这个函数也可能返回SQLITE_NOMEM。如果在数据库句柄处于自动提交模式的情况下调用该函数,但由于其他原因而失败,那么是否在模式S上打开读事务是未定义的。</target>
        </trans-unit>
        <trans-unit id="d107c7c4ed710ea3330eefcfd44db3b75a5ff363" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法可以调用此函数，以配置虚拟表接口的各个方面。</target>
        </trans-unit>
        <trans-unit id="436450a55b61a947a304f65e4e9be131ade57dc9" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法可以调用此函数，以配置虚拟表接口的各个方面。</target>
        </trans-unit>
        <trans-unit id="892823d34401462a7936657244cacf73ba9d16a7" translate="yes" xml:space="preserve">
          <source>This function may be quite inefficient if used with an FTS5 table created with the &quot;columnsize=0&quot; option.</source>
          <target state="translated">如果使用以 &quot;columnsize=0 &quot;选项创建的FTS5表,这个函数的效率可能很低。</target>
        </trans-unit>
        <trans-unit id="e3c728fb74daea7a42a0d0a89203b1fbf38464ae" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">此函数只能在对&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法的调用中调用。</target>
        </trans-unit>
        <trans-unit id="651e6e671ae629015a6ac3d4f4c461902dc827bb" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">只能在对INSERT或UPDATE操作的&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法的调用中调用此函数。根据触发&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法调用的SQL语句的&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式，返回的值是&lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;，&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，&lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;，&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;或&lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE&lt;/a&gt;之一。</target>
        </trans-unit>
        <trans-unit id="a16a26f00d528f2a67fb084167cd62426f17fa64" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">此函数只能在对&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法的调用中调用。</target>
        </trans-unit>
        <trans-unit id="a48f675a9216b80779894ce906eb64bd5d832356" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">只能在对INSERT或UPDATE操作的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法的调用中调用此函数。根据触发&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法调用的SQL语句的&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式，返回的值是&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;，&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;或&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE&lt;/a&gt;之一。</target>
        </trans-unit>
        <trans-unit id="9f4b868b197498e92e7be98a22186e8a9d0ec008" translate="yes" xml:space="preserve">
          <source>This function may only be called with an iterator passed to an SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case it sets the output variable to the total number of known foreign key violations in the destination database and returns SQLITE_OK.</source>
          <target state="translated">这个函数只能与传递给SQLITE_CHANGESET_FOREIGN_KEY冲突处理回调的迭代器一起调用。在这种情况下,它将输出变量设置为目标数据库中已知外键违规的总数,并返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="6aefcc013460f98a7eaca0c2faea39955530e82b" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">此函数只能与由&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;函数创建的迭代器一起使用。如果在通过&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;传递给冲突处理程序回调的迭代器上调用它，则返回SQLITE_MISUSE，并且该调用无效。</target>
        </trans-unit>
        <trans-unit id="6b40997bef104535dd0852dc311c81d541b71952" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">此函数只能与由&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;函数创建的迭代器一起使用。如果在通过&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;传递给冲突处理程序回调的迭代器上调用它，则返回SQLITE_MISUSE，并且该调用无效。</target>
        </trans-unit>
        <trans-unit id="81dcfaa530f9bc3b0cf4ff6ac3dd711bd8249deb" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a7a3750664d2ff5967d620601e32e54729a198" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3cebc479567b581aaea382b042cd658c5a6fd2" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">该函数只能修改BLOB的内容；使用此API不可能增加BLOB的大小。如果偏移量iOffset从BLOB的末尾开始小于N个字节，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;写入任何数据。可以使用&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定BLOB的大小（以及N + iOffset的最大值）。如果N或iOffset小于零，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;写入任何数据。</target>
        </trans-unit>
        <trans-unit id="cc4415e783325c61d6eb500d3a2195a9814914cb" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">该函数只能修改BLOB的内容；使用此API不可能增加BLOB的大小。如果偏移量iOffset从BLOB的末尾开始小于N个字节，则返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;写入任何数据。可以使用&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定BLOB的大小（以及N + iOffset的最大值）。如果N或iOffset小于零，则返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;写入任何数据。</target>
        </trans-unit>
        <trans-unit id="e611001e69d55801c25d56986ec39153bc754108" translate="yes" xml:space="preserve">
          <source>This function returns SQLITE_OK if successful, or an SQLite error code otherwise.</source>
          <target state="translated">如果成功,该函数返回SQLITE_OK,否则返回SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="1c2517d3cf09b0cdb52fd7581d781f148fee8f8f" translate="yes" xml:space="preserve">
          <source>This function returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter. Executing any other type of SQL statement does not modify the value returned by this function.</source>
          <target state="translated">这个函数返回在唯一参数指定的数据库连接上最近完成的INSERT、UPDATE或DELETE语句所修改、插入或删除的行数。执行任何其他类型的SQL语句都不会修改这个函数返回的值。</target>
        </trans-unit>
        <trans-unit id="6b76b4997f936492171845d7baebab3de049f79f" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">此函数返回自打开数据库连接以来已完成的所有&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;语句插入，修改或删除的行总数，包括作为触发器程序一部分执行的行。执行任何其他类型的SQL语句都不会影响sqlite3_total_changes（）返回的值。</target>
        </trans-unit>
        <trans-unit id="adf4834644160b8bd2e8b37a1e591e556b1afb6a" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">此函数返回自打开数据库连接以来已完成的所有&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句插入，修改或删除的行总数，包括作为触发器程序一部分执行的行。执行任何其他类型的SQL语句都不会影响sqlite3_total_changes（）返回的值。</target>
        </trans-unit>
        <trans-unit id="8213d08301f09db1801edcdcc6b6898d5bedde17" translate="yes" xml:space="preserve">
          <source>This function sets the database handle error code and message.</source>
          <target state="translated">该函数设置数据库句柄的错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="dc027be02604df0d93fb0c7fd87bd8fb650c8db3" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">仅应在使用&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;函数创建的迭代器上调用此函数。如果应用程序调用该函数通过传递给冲突处理程序迭代&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（） &lt;/a&gt;，&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;立即返回，呼叫没有任何影响。</target>
        </trans-unit>
        <trans-unit id="2df7e3d1377d5e8297acef52974006d62b57703e" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">仅应在使用&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;函数创建的迭代器上调用此函数。如果应用程序调用该函数通过传递给冲突处理程序迭代&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（） &lt;/a&gt;，&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;立即返回，呼叫没有任何影响。</target>
        </trans-unit>
        <trans-unit id="6644624c994928cadd1595cf7f165d3a9a2ca4f0" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">该函数仅应与&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;通过&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;或&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;传递给冲突处理程序回调的迭代器对象一起使用。如果在任何其他迭代器上调用此函数，则返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="548141af0246ca4eef33b575f89c5796207c5a05" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">该函数仅应与&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;通过&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;或&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;传递给冲突处理程序回调的迭代器对象一起使用。如果在任何其他迭代器上调用此函数，则返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="aabca26792420e3dedde38828f3aa35b5f3a0612" translate="yes" xml:space="preserve">
          <source>This generates a file named &lt;b&gt;ex1.dump.gz&lt;/b&gt; that contains everything you need to reconstruct the database at a later time, or on another machine. To reconstruct the database, just type:</source>
          <target state="translated">这将生成一个名为&lt;b&gt;ex1.dump.gz&lt;/b&gt;的文件，其中包含稍后或在另一台计算机上重建数据库所需的所有内容。要重建数据库，只需键入：</target>
        </trans-unit>
        <trans-unit id="311cc4fab23f9723b1a4efe300a30ad45967a776" translate="yes" xml:space="preserve">
          <source>This graph is acyclic. And we assume that the mtime of every child checkin is no less than the mtime of all its parents. But unlike the earlier examples, this graph might have multiple paths of differing lengths between any two checkins.</source>
          <target state="translated">这个图是无周期的。我们假设每个子签到的m时间不小于所有父签到的m时间。但与前面的例子不同的是,这个图可能在任何两个签入之间有多条长度不同的路径。</target>
        </trans-unit>
        <trans-unit id="fa0e2bf6a1863b49e18b3cb7db1999e03d428ead" translate="yes" xml:space="preserve">
          <source>This historical version numbering system used a two-, three-, or four-number version: W.X, W.X.Y, or W.X.Y.Z. W was the file format: 1 or 2 or 3. X was the major version. Y was the minor version. Z was used only for patch releases to fix bugs.</source>
          <target state="translated">这种历史上的版本编号系统采用的是二号、三号或四号版本。W.X,W.X.Y,或W.X.Y.Z.W是文件格式:1或2或3.X是主要版本。Y是次要版本。Z只用于修复错误的补丁版本。</target>
        </trans-unit>
        <trans-unit id="9f4676d0afd51e8fa37c9aa0283801b026a1b72b" translate="yes" xml:space="preserve">
          <source>This instruction causes the VM to halt.</source>
          <target state="translated">该指令会导致虚拟机停止。</target>
        </trans-unit>
        <trans-unit id="fdc444b74a87e964e8bcc2b42a370bbc5df69c15" translate="yes" xml:space="preserve">
          <source>This instruction makes a deep copy of the value. A duplicate is made of any string or blob constant. See also &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;.</source>
          <target state="translated">该指令对值进行了深层复制。任何字符串或blob常量均构成重复项。另请参阅&lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dad5db056b0ca8e5a487c8ab6c8e6dc7e0f2672" translate="yes" xml:space="preserve">
          <source>This instruction makes a shallow copy of the value. If the value is a string or blob, then the copy is only a pointer to the original and hence if the original changes so will the copy. Worse, if the original is deallocated, the copy becomes invalid. Thus the program must guarantee that the original will not change during the lifetime of the copy. Use &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; to make a complete copy.</source>
          <target state="translated">该指令对值进行了浅表复制。如果值是字符串或Blob，则副本只是指向原始对象的指针，因此，如果原始对象发生更改，则副本也将更改。更糟糕的是，如果原件被重新分配，副本将无效。因此，程序必须保证原件在复印期间不会更改。使用&amp;ldquo; &lt;a href=&quot;opcode#Copy&quot;&gt;复印&amp;rdquo;&lt;/a&gt;进行完整复印。</target>
        </trans-unit>
        <trans-unit id="4df251f100bd98635ac20986854a4f9d3558bf05" translate="yes" xml:space="preserve">
          <source>This instruction only works for indices. The equivalent instruction for tables is &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;.</source>
          <target state="translated">该指令仅适用于索引。表的等效指令是&lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="724c5d92359b2812711bd98fdbbd0ee48ff16933" translate="yes" xml:space="preserve">
          <source>This instruction only works on tables. The equivalent instruction for indices is &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;.</source>
          <target state="translated">该指令仅适用于表。索引的等效指令是&lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc342418f5a1b7e3edc039b6124a9b746a56c8e5" translate="yes" xml:space="preserve">
          <source>This instruction throws an error if the memory cell is not initially an integer.</source>
          <target state="translated">如果内存单元最初不是一个整数,则该指令会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="b8399072455bb3b6ee2757655f5f7b2af59230c1" translate="yes" xml:space="preserve">
          <source>This instruction works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it opens the cursor in read/write mode.</source>
          <target state="translated">该指令的工作方式与&lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;相似，只是它以读/写模式打开游标。</target>
        </trans-unit>
        <trans-unit id="849ae2eb4b736949542c4487e7de5222b770b0b6" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">该接口允许在逐个连接的基础上限制各种构造的大小。第一个参数是要设置或查询其限制的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。第二个参数是&lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;限制类别&lt;/a&gt;之一，它定义了要限制大小的构造类。第三个参数是该构造的新限制。</target>
        </trans-unit>
        <trans-unit id="6687035e8ed6fa147345334bd3634ec9e7ff5918" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;c_limit_attached&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">该接口允许在逐个连接的基础上限制各种构造的大小。第一个参数是要设置或查询其限制的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。第二个参数是&lt;a href=&quot;c_limit_attached&quot;&gt;限制类别&lt;/a&gt;之一，它定义了要限制大小的构造类。第三个参数是该构造的新限制。</target>
        </trans-unit>
        <trans-unit id="9256e21c25ccdf9db985fbb93738819f3d6d967d" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">应用程序可以使用此接口，以确保使用所需的&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;宏设置编译了与其链接的SQLite版本。</target>
        </trans-unit>
        <trans-unit id="32dc361b08c9c60505d75103bdc36b57584e9fcf" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">应用程序可以使用此接口，以确保使用所需的&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;宏设置编译了与其链接的SQLite版本。</target>
        </trans-unit>
        <trans-unit id="25ebb19095f954c7ae8a2ed499bdbfed83aadaa6" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">该接口可以与&lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt（）&lt;/a&gt;结合使用，以查找与数据库连接关联的所有准备语句，这些语句需要重置。例如，可以在诊断例程中使用它来搜索使事务处于打开状态的准备好的语句。</target>
        </trans-unit>
        <trans-unit id="d607ef96133a79a067aeb3d80e9e814bdda87569" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">该接口可以与&lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt（）&lt;/a&gt;结合使用，以查找与数据库连接关联的所有准备语句，这些语句需要重置。例如，可以在诊断例程中使用它来搜索使事务处于打开状态的准备好的语句。</target>
        </trans-unit>
        <trans-unit id="d798abdc7bea34806f312f897736975cfc379c7c" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">此接口导致为创建的每个新&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;调用xEntryPoint（）函数。这里的想法是xEntryPoint（）是静态链接的&lt;a href=&quot;loadext&quot;&gt;SQLite扩展&lt;/a&gt;的入口点，该扩展将自动加载到所有新的数据库连接中。</target>
        </trans-unit>
        <trans-unit id="a18b59c5465abea2190a535937651aa6f4f67fb4" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">此接口导致为创建的每个新&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;调用xEntryPoint（）函数。这里的想法是xEntryPoint（）是静态链接的&lt;a href=&quot;../loadext&quot;&gt;SQLite扩展&lt;/a&gt;的入口点，该扩展将自动加载到所有新的数据库连接中。</target>
        </trans-unit>
        <trans-unit id="9786ef1ecb8c77d789971c3f849525761d5d38c2" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">此接口禁用以前使用&lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;注册的所有自动扩展。</target>
        </trans-unit>
        <trans-unit id="2b9c0cbd974b30f6431515e1186211476ca08e78" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">此接口禁用以前使用&lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;注册的所有自动扩展。</target>
        </trans-unit>
        <trans-unit id="8736a85b1a1bcc4c800c4ff7d229eb677c9e2f70" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">此接口启用或禁用C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;和SQL函数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;。使用&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;，..）仅启用或禁用C-API。</target>
        </trans-unit>
        <trans-unit id="ab1cdc93fe51f37fdae78544827ec5e365f941a3" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">此接口启用或禁用C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;和SQL函数&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;。使用&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;，..）仅启用或禁用C-API。</target>
        </trans-unit>
        <trans-unit id="737d038457ffc2dd705bbf7d3e67fd74eca8f49b" translate="yes" xml:space="preserve">
          <source>This interface is not for use by applications. It exists solely for verifying the correct operation of the SQLite library. Depending on how the SQLite library is compiled, this interface might not exist.</source>
          <target state="translated">这个接口不供应用程序使用。它的存在只是为了验证SQLite库的正确操作。根据SQLite库的编译方式,这个接口可能不存在。</target>
        </trans-unit>
        <trans-unit id="dec74db456b76b7c855d3cb1358c040acad3ef05" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt;选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="5c93fb0edc37eb4be652a31e1dc573b6923060cf" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="17b0e4d3f046d7d363af1d959e76e0c4d41dedec" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt;选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="f287e88e4474f60d3222ad14486a836ab2470ef3" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
