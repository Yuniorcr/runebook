<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="99bed95a8c8918c9ad675486624a0ec50cca0b55" translate="yes" xml:space="preserve">
          <source>The maximum amount of general-purpose memory needed by the application is determined by such factors as how many simultaneous open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects the application uses, and on the complexity of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. For any given application, these factors are normally fixed and can be determined experimentally using &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;. A typical application might only use about 40KB of general-purpose memory. This gives a value of &lt;b&gt;N&lt;/b&gt; of around 100KB.</source>
          <target state="translated">应用程序所需的最大通用内存量由以下因素确定，这些因素包括应用程序使用多少个同时打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;对象，以及&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;的复杂性。对于任何给定的应用程序，这些因素通常是固定的，可以使用&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;通过实验确定。一个典型的应用程序可能只使用大约40KB的通用内存。&lt;b&gt;N&lt;/b&gt;的值约为100KB。</target>
        </trans-unit>
        <trans-unit id="a9b767b87a835989935611d9f91af0a49ef22427" translate="yes" xml:space="preserve">
          <source>The maximum and minimum embedded payload fractions and the leaf payload fraction values must be 64, 32, and 32. These values were originally intended to be tunable parameters that could be used to modify the storage format of the b-tree algorithm. However, that functionality is not supported and there are no current plans to add support in the future. Hence, these three bytes are fixed at the values specified.</source>
          <target state="translated">最大和最小的嵌入有效载荷分数和叶有效载荷分数值必须是64、32和32。这些值最初的目的是作为可调整的参数,可用于修改b树算法的存储格式。但是,该功能不被支持,目前也没有计划在未来增加支持。因此,这三个字节被固定在指定的值上。</target>
        </trans-unit>
        <trans-unit id="3b75dd01c336dd48a91229fb4fe465cfca0656d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of an expression tree can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) interface if the SQLITE_MAX_EXPR_DEPTH is initially positive. In other words, the maximum expression depth can be lowered at run-time if there is already a compile-time limit on the expression depth. If SQLITE_MAX_EXPR_DEPTH is set to 0 at compile time (if the depth of expressions is unlimited) then the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) is a no-op.</source>
          <target state="translated">如果SQLITE_MAX_EXPR_DEPTH最初为正，则可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;，size）接口降低表达式树的最大深度。换句话说，如果表达式深度已经存在编译时限制，则可以在运行时降低最大表达式深度。如果在编译时将SQLITE_MAX_EXPR_DEPTH设置为0（如果表达式的深度不受限制），则&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH的&lt;/a&gt;大小）是无操作的。</target>
        </trans-unit>
        <trans-unit id="7601f568790af4a666771d9637268d8679fb90bb" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursion for triggers.</source>
          <target state="translated">触发器的最大递归深度。</target>
        </trans-unit>
        <trans-unit id="f7ca88d6870cff0eca30922b0b5339bd065f10ca" translate="yes" xml:space="preserve">
          <source>The maximum depth of the parse tree on any expression.</source>
          <target state="translated">任何表达式上解析树的最大深度。</target>
        </trans-unit>
        <trans-unit id="2e6bbb757edd69dcf67031bc6d4f260f516ed8d0" translate="yes" xml:space="preserve">
          <source>The maximum host parameter number can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;，size）接口降低最大主机参数数量。</target>
        </trans-unit>
        <trans-unit id="b3e774d908522cebf9bd7f7f3469b3fb31276410" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQL语句中任何&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的最大索引号。</target>
        </trans-unit>
        <trans-unit id="32a6d72e37d636464c2192cbf409c3425887feb6" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQL语句中任何&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的最大索引号。</target>
        </trans-unit>
        <trans-unit id="ab2a11cb65d0770d55a8b43b094028bd3c341a46" translate="yes" xml:space="preserve">
          <source>The maximum length of a LIKE or GLOB pattern can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;，size）接口在运行时降低LIKE或GLOB模式的最大长度。</target>
        </trans-unit>
        <trans-unit id="295e913f367222db2770c86b223d1cb94f3eaca7" translate="yes" xml:space="preserve">
          <source>The maximum length of a SQL function name is 255 bytes of UTF8. Any attempt to create a function with a longer name will result in an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; error.</source>
          <target state="translated">SQL函数名称的最大长度为255个字节的UTF8。任何尝试使用更长名称创建函数的尝试都会导致&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="d765036961e5dc86e0ba5117af47c297fab27c55" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;，size）接口降低SQL语句的最大长度。</target>
        </trans-unit>
        <trans-unit id="d303fbf5ebde80b928a0a149ac1d360f8b2d9beb" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement, in bytes.</source>
          <target state="translated">一个SQL语句的最大长度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c8feb93491c3d188a9985624d09a15796f2e0e57" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的pattern参数的最大长度。</target>
        </trans-unit>
        <trans-unit id="1ee02be23a19dec285dd5109a44c64362161f0e7" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的pattern参数的最大长度。</target>
        </trans-unit>
        <trans-unit id="b23da6f4323ba72ffe46e74c0191923768cdb864" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;../lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_attach&quot;&gt;附加数据库&lt;/a&gt;的最大数量。</target>
        </trans-unit>
        <trans-unit id="b544569d59df80608bd6a41e19a745bdff4577b6" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;附加数据库&lt;/a&gt;的最大数量。</target>
        </trans-unit>
        <trans-unit id="471b9bc71d47534b60a1c278c46d4cee7c9664ba" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments in a function can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;，size）接口降低函数中参数的最大数量。</target>
        </trans-unit>
        <trans-unit id="00eff3b06f801e572f28af21289c2619b46c2f08" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments on a function.</source>
          <target state="translated">一个函数的最大参数数。</target>
        </trans-unit>
        <trans-unit id="b6c416e24701b8851e7053c0bb7cd7dd6b331315" translate="yes" xml:space="preserve">
          <source>The maximum number of attached databases can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;，size）接口降低附加数据库的最大数量。</target>
        </trans-unit>
        <trans-unit id="0b6c3c6cf8605d1353c6caeac57deb9da3ed0c6e" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">一个&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;可以启动的辅助工作线程的最大数量。</target>
        </trans-unit>
        <trans-unit id="66f8c3a081d879e272abf19945402c6cac2a7ecc" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">一个&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;可以启动的辅助工作线程的最大数量。</target>
        </trans-unit>
        <trans-unit id="bbb454e2483711c9ac94945a0c80d3f47e450874" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in a string or BLOB in SQLite is defined by the preprocessor macro SQLITE_MAX_LENGTH. The default value of this macro is 1 billion (1 thousand million or 1,000,000,000). You can raise or lower this value at compile-time using a command-line option like this:</source>
          <target state="translated">在SQLite中,字符串或BLOB的最大字节数由预处理器宏SQLITE_MAX_LENGTH定义。这个宏的默认值是10亿(10亿或1,000,000,000)。你可以在编译时使用命令行选项提高或降低这个值,比如这样。</target>
        </trans-unit>
        <trans-unit id="da1ee68dd77283238b55af162c380f02592134ee" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in the text of an SQL statement is limited to SQLITE_MAX_SQL_LENGTH which defaults to 1000000. You can redefine this limit to be as large as the smaller of SQLITE_MAX_LENGTH and 1073741824.</source>
          <target state="translated">SQL语句文本中的最大字节数限制为SQLITE_MAX_SQL_LENGTH,默认为1000000。你可以重新定义这个限制,使其大到SQLITE_MAX_LENGTH和1073741824中的较小值。</target>
        </trans-unit>
        <trans-unit id="6345ddabb514350f3e36f681af647ea84308cf28" translate="yes" xml:space="preserve">
          <source>The maximum number of columns can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;，size）接口降低最大列数。</target>
        </trans-unit>
        <trans-unit id="1c620a336050426a95c894972afda47b3aee66a2" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">表定义或&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;结果集中的最大列数，或索引或ORDER BY或GROUP BY子句中的最大列数。</target>
        </trans-unit>
        <trans-unit id="355eec7f9bb7446523a2374f005ae8119aa229d8" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">表定义或&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;结果集中的最大列数，或索引或ORDER BY或GROUP BY子句中的最大列数。</target>
        </trans-unit>
        <trans-unit id="8374b8e68f54521ffc214c5ed7e8c2d7fd95f1b7" translate="yes" xml:space="preserve">
          <source>The maximum number of compound SELECT terms can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;，size）接口降低复合SELECT术语的最大数量。</target>
        </trans-unit>
        <trans-unit id="63cbc7c9607d5bbb2a5e8441eb06e668604fc05c" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">虚拟机程序中用于实现SQL语句的最大指令数。如果&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效方法试图在单个准备好的语句中为多个操作码分配空间，则将返回SQLITE_NOMEM错误。</target>
        </trans-unit>
        <trans-unit id="3914cdf98f328c74ff19ff41972588f848a7b49e" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">虚拟机程序中用于实现SQL语句的最大指令数。如果&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效方法试图在单个准备好的语句中为多个操作码分配空间，则将返回SQLITE_NOMEM错误。</target>
        </trans-unit>
        <trans-unit id="7c57be7916f18cb9fd931235954ed49b10f67a38" translate="yes" xml:space="preserve">
          <source>The maximum number of terms in a compound SELECT statement.</source>
          <target state="translated">复合SELECT语句中的最大项数。</target>
        </trans-unit>
        <trans-unit id="6409e263b558e4fc8032ff274ccb7661be29c559" translate="yes" xml:space="preserve">
          <source>The maximum number of tokens in the returned text. This must be greater than zero and equal to or less than 64.</source>
          <target state="translated">返回文本中的最大标记数。必须大于零,等于或小于64。</target>
        </trans-unit>
        <trans-unit id="970d6e67d87a8bc5f32df0c8fe5b2ab66eff4335" translate="yes" xml:space="preserve">
          <source>The maximum parameter number is set at compile-time by the &lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt; macro. An individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; D can reduce its maximum parameter number below the compile-time maximum using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,...) interface.</source>
          <target state="translated">最大参数数是在编译时由&lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt;宏设置的。单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt; D可以使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;，...）接口将其最大参数数减少到编译时最大值以下。</target>
        </trans-unit>
        <trans-unit id="eeb9b32b1bfb4a0ced4bb9bc2aaa054c3abdfc92" translate="yes" xml:space="preserve">
          <source>The maximum size of any string or BLOB or table row, in bytes.</source>
          <target state="translated">任何字符串或BLOB或表格行的最大尺寸,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c7f288d6ab417ac4a35975a5356fac79645319c2" translate="yes" xml:space="preserve">
          <source>The maximum string or BLOB length can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;，size）接口降低最大字符串或BLOB长度。</target>
        </trans-unit>
        <trans-unit id="770a09ba0039805fb6c3142551082e18eaaafe07" translate="yes" xml:space="preserve">
          <source>The meaning of P5 depends on whether or not the SQLITE_ENABLE_NULL_TRIM compile-time option is enabled:</source>
          <target state="translated">P5的含义取决于是否启用了SQLITE_ENABLE_NULL_TRIM编译时选项。</target>
        </trans-unit>
        <trans-unit id="5cc8ccfaed1025b2039c6bdfd6b0a5399eacb5ca" translate="yes" xml:space="preserve">
          <source>The meanings for all $nResCode result code values are shown below, in numeric order.</source>
          <target state="translated">所有$nResCode结果代码值的含义如下所示,按数字顺序排列。</target>
        </trans-unit>
        <trans-unit id="2c0dcd2e74747cfdf6b8873df9cf97a473ffe1cd" translate="yes" xml:space="preserve">
          <source>The meanings for all 102 result code values are shown below, in numeric order.</source>
          <target state="translated">所有102个结果代码值的含义如下,按数字顺序排列。</target>
        </trans-unit>
        <trans-unit id="4cad3638dbf4cc08ff40caa02c71d9ae2dc2cc12" translate="yes" xml:space="preserve">
          <source>The meanings for all 92 result code values are shown below, in numeric order.</source>
          <target state="translated">所有92个结果代码值的含义如下,按数字顺序排列。</target>
        </trans-unit>
        <trans-unit id="07eeff254885d567e91c4b2aaaeee641fbf91699" translate="yes" xml:space="preserve">
          <source>The meanings of the fields of the schema table are as follows:</source>
          <target state="translated">模式表中各字段的含义如下。</target>
        </trans-unit>
        <trans-unit id="acfaa39aa41d2de54931d409a9de16ab158bc08a" translate="yes" xml:space="preserve">
          <source>The meanings of these various return values are as follows:</source>
          <target state="translated">这些不同的返回值的含义如下:</target>
        </trans-unit>
        <trans-unit id="3594f845ca8155469ebf0d3a1db0993f4bb9cbd1" translate="yes" xml:space="preserve">
          <source>The measurements in this article were made during the week of 2017-06-05 using a version of SQLite in between 3.19.2 and 3.20.0. You may expect future versions of SQLite to perform even better.</source>
          <target state="translated">本文中的测量是在2017-06-05这一周使用3.19.2和3.20.0之间的SQLite版本进行的。您可能会期待未来版本的SQLite表现更好。</target>
        </trans-unit>
        <trans-unit id="5036b12169e90ae6667838e4b73b7f71ccf84ec9" translate="yes" xml:space="preserve">
          <source>The memory allocation limits can also be adjusted using &lt;a href=&quot;../pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;.</source>
          <target state="translated">内存分配限制也可以使用&lt;a href=&quot;../pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt;和&lt;a href=&quot;../pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;进行调整。</target>
        </trans-unit>
        <trans-unit id="f2809fd545c907ef31fca4768c017467b4928225" translate="yes" xml:space="preserve">
          <source>The memory allocation limits can also be adjusted using &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;.</source>
          <target state="translated">内存分配限制也可以使用&lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;进行调整。</target>
        </trans-unit>
        <trans-unit id="e788358e2ac74022367111d33deb5ddc9a976282" translate="yes" xml:space="preserve">
          <source>The memory corruption problem becomes more acute when using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;. When all or part of the database file is mapped into the application's address space, then a stray pointer that overwrites any part of that mapped space will immediately corrupt the database file, without requiring the application to do a subsequent write() system call.</source>
          <target state="translated">使用&lt;a href=&quot;mmap&quot;&gt;内存映射的I / O&lt;/a&gt;时，内存损坏问题变得更加严重。当数据库文件的全部或部分映射到应用程序的地址空间时，覆盖该映射空间的任何部分的杂散指针将立即破坏数据库文件，而无需应用程序执行后续的write（）系统调用。</target>
        </trans-unit>
        <trans-unit id="1f25753cb6dacb02b829c0a340f5d35891b7f9cb" translate="yes" xml:space="preserve">
          <source>The memory footprint of the application can be dramatically reduced by only loading content that is relevant to the current display and keeping the bulk of the content on disk. The fast query capability of SQLite make this a viable alternative to keeping all content in memory at all times. And when applications use less memory, it makes the entire computer more responsive, further enhancing the user experience.</source>
          <target state="translated">通过只加载与当前显示相关的内容,而将大部分内容保留在磁盘上,可以极大地减少应用程序的内存占用。SQLite的快速查询能力使其成为一个可行的替代方案,而不是将所有内容始终保留在内存中。而当应用程序使用较少的内存时,就会使整个计算机的响应速度更快,进一步提升用户体验。</target>
        </trans-unit>
        <trans-unit id="9d3e4b06e9105ca7c88a4e1edabcb69936b1841b" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">当且仅当&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;的参数为true时，内存高水位标记才会重置为&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;的当前值。&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;返回的值是重置之前的高水位线。</target>
        </trans-unit>
        <trans-unit id="cd5593ab95a8d1e1ac6cc8d242678782f1a535e8" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">当且仅当&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;的参数为true时，内存高水位标记才会重置为&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;的当前值。&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;返回的值是重置之前的高水位线。</target>
        </trans-unit>
        <trans-unit id="a98788d1208d8031c1910803fa2f1051d600b111" translate="yes" xml:space="preserve">
          <source>The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.</source>
          <target state="translated">为声明类型和整理序列返回的字符指针所指向的内存是有效的,直到下一次调用任何SQLite API函数。</target>
        </trans-unit>
        <trans-unit id="523aa17230ae599153575b20eede454c13803757" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（），sqlite3_realloc（），sqlite3_malloc64（）和sqlite3_realloc64（）返回的内存始终至少对齐8个字节边界，如果使用&lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;编译时选项，则始终对齐4个字节边界。</target>
        </trans-unit>
        <trans-unit id="0b4a85ec728749e1396a0209dbea3173ce995dba" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（），sqlite3_realloc（），sqlite3_malloc64（）和sqlite3_realloc64（）返回的内存始终至少对齐8个字节边界，如果使用&lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;编译时选项，则始终对齐4个字节边界。</target>
        </trans-unit>
        <trans-unit id="d4065cde811c203e3d250a3f54d5601da517866b" translate="yes" xml:space="preserve">
          <source>The memsys5 allocator is designed for use on embedded systems, though there is nothing to prevent its use on workstations. The szBuf is typically between a few hundred kilobytes up to a few dozen megabytes, depending on system requirements and memory budget.</source>
          <target state="translated">memsys5分配器是为在嵌入式系统上使用而设计的,不过并不妨碍在工作站上使用它。szBuf通常在几百千字节到几十兆字节之间,这取决于系统需求和内存预算。</target>
        </trans-unit>
        <trans-unit id="15e755d3b15a2797fc8e730750dc9e96957bcf11" translate="yes" xml:space="preserve">
          <source>The min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">min()集合函数返回该组中所有值的最小非NULL值,最小值是在列的ORDER BY中出现的第一个非NULL值。最小值是列的ORDER BY中出现的第一个非NULL值。聚合函数min()只在组中没有非NULL值的情况下返回NULL。</target>
        </trans-unit>
        <trans-unit id="114a5a7dbd98c187abf7e68d111172546895bf6d" translate="yes" xml:space="preserve">
          <source>The min/max-value pair columns are stored as 32-bit floating point values for &quot;rtree&quot; virtual tables or as 32-bit signed integers in &quot;rtree_i32&quot; virtual tables. Unlike regular SQLite tables which can store data in a variety of datatypes and formats, the R*Tree rigidly enforce these storage types. If any other type of value is inserted into such a column, the r-tree module silently converts it to the required type before writing the new record to the database.</source>
          <target state="translated">对于 &quot;rtree &quot;虚拟表来说,最小值/最大值对列存储为32位浮点值,或者在 &quot;rtree_i32 &quot;虚拟表中存储为32位有符号整数。与常规的SQLite表可以以各种数据类型和格式存储数据不同,R*Tree严格执行这些存储类型。如果在这样的列中插入任何其他类型的值,r-tree模块会在将新记录写入数据库之前,默默地将其转换为所需类型。</target>
        </trans-unit>
        <trans-unit id="697dd64d2ba004e05302a199cbf94ae930397047" translate="yes" xml:space="preserve">
          <source>The minimum &quot;three+four&quot; value</source>
          <target state="translated">最低 &quot;三+四 &quot;值</target>
        </trans-unit>
        <trans-unit id="4344744cb5e4e7fe1c07e4d9e9f4f1a35db07ca5" translate="yes" xml:space="preserve">
          <source>The minimum size of an SQLite database is one page for each table and each index. With a larger page size, the size of an empty database for a given schema will grow by a factor of four, therefore. However, once the database begins to fill with content the size of the older 1024-byte page databases and the newer 4096-byte page databases will quickly converge. Due to relaxed bin-packing constraints, the 4096-byte page size might actually result in a smaller file, once substantial content is added.</source>
          <target state="translated">SQLite数据库的最小尺寸是每个表和每个索引的一个页面。随着页面大小的增大,一个给定模式的空数据库的大小将增长4倍,因此。然而,一旦数据库开始充满内容,旧的1024字节页数据库和新的4096字节页数据库的大小将迅速趋同。由于放宽了bin-packing限制,一旦添加了大量内容,4096字节的页面大小实际上可能会导致文件变小。</target>
        </trans-unit>
        <trans-unit id="e5d2ce57cb5bfbf79b3c98a499658be04c3e7756" translate="yes" xml:space="preserve">
          <source>The minor version number Y was historically incremented for new features and/or new interfaces that did not significantly change the structure of the code. The addition of &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; are all examples of &quot;minor&quot; changes. Again, the distinction between &quot;major&quot; and &quot;minor&quot; is subjective.</source>
          <target state="translated">对于新功能和/或新接口，次要版本号Y在历史上一直递增，而新功能和/或新接口并未显着改变代码的结构。的加入&lt;a href=&quot;lang_with&quot;&gt;公共表表达式&lt;/a&gt;，&lt;a href=&quot;partialindex&quot;&gt;部分指标&lt;/a&gt;和&lt;a href=&quot;expridx&quot;&gt;指标上的表达&lt;/a&gt;是&amp;ldquo;小&amp;rdquo;的变化的例子。同样，&amp;ldquo;主要&amp;rdquo;和&amp;ldquo;次要&amp;rdquo;之间的区别是主观的。</target>
        </trans-unit>
        <trans-unit id="daac53b800202886e5a1bc16ab5a5eb44a3f8d4d" translate="yes" xml:space="preserve">
          <source>The mirror is an incremental export of the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;canonical Fossil repository&lt;/a&gt; for SQLite. A cron-job updates the GitHub repository once an hour. This is a one-way, read-only code mirror. No pull requests or changes are accepted via GitHub. The GitHub repository merely copies the content from the Fossil repository. All changes are input via Fossil.</source>
          <target state="translated">镜像是SQLite &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;规范化Fossil存储库&lt;/a&gt;的增量导出。一个cron-job每小时更新一次GitHub存储库。这是一个单向只读代码镜像。 GitHub不接受任何请求或更改。 GitHub存储库仅复制Fossil存储库中的内容。所有更改均通过Fossil输入。</target>
        </trans-unit>
        <trans-unit id="8699fa6e48270c38aaec7f72b7768d7c856e3da2" translate="yes" xml:space="preserve">
          <source>The mmap_size is set separately for each database file using the &quot;&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;&quot; statement. The usual default mmap_size is zero, meaning that memory mapped I/O is disabled by default. However, the default mmap_size can be increased either at compile-time using the &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; macro or at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,...) interface.</source>
          <target state="translated">使用&amp;ldquo; &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; &amp;rdquo;语句为每个数据库文件分别设置mmap_size。通常的默认mmap_size为零，这意味着默认情况下禁用内存映射的I / O。但是，可以在编译时使用&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;宏或在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;，...）接口来增加默认的mmap_size 。</target>
        </trans-unit>
        <trans-unit id="bc3aa8081ad975eaa64522ee2647fdff6a383213" translate="yes" xml:space="preserve">
          <source>The mode query parameter determines if the new database is opened read-only, read-write, read-write and created if it does not exist, or that the database is a pure in-memory database that never interacts with disk, respectively.</source>
          <target state="translated">模式查询参数分别决定新数据库是只读、读写、读写,如果不存在则创建,或者数据库是纯内存数据库,从不与磁盘交互。</target>
        </trans-unit>
        <trans-unit id="f2526ac46e681fb29c61b97dfb71933e5d3d8f00" translate="yes" xml:space="preserve">
          <source>The modifications made to each row affected by an UPDATE statement are determined by the list of assignments following the SET keyword. Each assignment specifies a column-name to the left of the equals sign and a scalar expression to the right. For each affected row, the named columns are set to the values found by evaluating the corresponding scalar expressions. If a single column-name appears more than once in the list of assignment expressions, all but the rightmost occurrence is ignored. Columns that do not appear in the list of assignments are left unmodified. The scalar expressions may refer to columns of the row being updated. In this case all scalar expressions are evaluated before any assignments are made.</source>
          <target state="translated">受UPDATE语句影响的每条记录的修改由SET关键字后面的赋值列表决定。每个赋值都在等号左边指定一个列名,右边指定一个标量表达式。对于每一条受影响的记录,被命名的列会被设置为通过评估相应的标量表达式所找到的值。如果一个列名在赋值表达式列表中出现了一次以上,那么除了最右边出现的列名外,其他列名都会被忽略。没有出现在赋值列表中的列名将不被修改。标量表达式可能指的是被更新行的列。在这种情况下,所有标量表达式在进行任何赋值之前都会被评估。</target>
        </trans-unit>
        <trans-unit id="c57c56215c73a95bddb16c7f419303a4f511dbe2" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">模块名称在第一个参数指定的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;上注册。模块的名称由第二个参数给出。第三个参数是&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;实现的指针。第四个参数是一个任意的客户端数据指针，当创建或重新初始化新的虚拟表时，该指针将传递到虚拟表模块的&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法中。</target>
        </trans-unit>
        <trans-unit id="f7d008fdf7032ca8558d613dfe5b4ba03ec8869a" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">模块名称在第一个参数指定的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;上注册。模块的名称由第二个参数给出。第三个参数是&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;实现的指针。第四个参数是一个任意的客户端数据指针，当创建或重新初始化新的虚拟表时，该指针将传递到虚拟表模块的&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法中。</target>
        </trans-unit>
        <trans-unit id="c29884604bb765a8ff66e73918a8eec45479c155" translate="yes" xml:space="preserve">
          <source>The module name must be changed from &quot;fts3&quot; or &quot;fts4&quot; to &quot;fts5&quot;.</source>
          <target state="translated">模块名称必须从 &quot;fts3 &quot;或 &quot;fts4 &quot;改为 &quot;fts5&quot;。</target>
        </trans-unit>
        <trans-unit id="ea30bfabecd455dc9fb80bfe26599d0bf2066398" translate="yes" xml:space="preserve">
          <source>The module structure contains methods that are invoked by SQLite to perform various actions on the virtual table such as creating new instances of a virtual table or destroying old ones, reading and writing data, searching for and deleting, updating, or inserting rows. The module structure is explained in more detail below.</source>
          <target state="translated">该模块结构包含了SQLite调用的方法,用于对虚拟表执行各种操作,如创建虚拟表的新实例或销毁旧实例、读写数据、搜索和删除、更新或插入行。下面将对该模块结构进行详细说明。</target>
        </trans-unit>
        <trans-unit id="e7e8ce1834b0e39b1a04f1ee58c27c3761f545ea" translate="yes" xml:space="preserve">
          <source>The module structure defines all of the methods for each virtual table object. The module structure also contains the iVersion field which defines the particular edition of the module table structure. Currently, iVersion is always 3 or less, but in future releases of SQLite the module structure definition might be extended with additional methods and in that case the maximum iVersion value will be increased.</source>
          <target state="translated">模块结构定义了每个虚拟表对象的所有方法。模块结构还包含iVersion字段,它定义了模块表结构的特定版本。目前,iVersion总是3或更少,但在未来的SQLite版本中,模块结构定义可能会扩展更多的方法,在这种情况下,最大的iVersion值会增加。</target>
        </trans-unit>
        <trans-unit id="f82636212897757718a1a7712ed9f6ebe7472ac1" translate="yes" xml:space="preserve">
          <source>The module-name is the name of an object that implements the virtual table. The module-name must be registered with the SQLite database connection using &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; prior to issuing the CREATE VIRTUAL TABLE statement. The module takes zero or more comma-separated arguments. The arguments can be just about any text as long as it has balanced parentheses. The argument syntax is sufficiently general that the arguments can be made to appear as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in a traditional &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. SQLite passes the module arguments directly to the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the module implementation without any interpretation. It is the responsibility of the module implementation to parse and interpret its own arguments.</source>
          <target state="translated">module-name是实现虚拟表的对象的名称。在发出CREATE VIRTUAL TABLE语句之前，必须使用&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;或&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;向SQLite数据库连接注册模块名称。该模块接受零个或多个逗号分隔的参数。只要括号中有括号，参数就可以是任何文本。参数语法足够通用，可以使参数在传统的&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中显示为&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定义&lt;/a&gt;。 SQLite将模块参数直接传递给&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;模块实现的方法，无需任何解释。模块实现负责解析和解释其自身的参数。</target>
        </trans-unit>
        <trans-unit id="44619ca32ea56419710789f2ec6fc9766c59ac70" translate="yes" xml:space="preserve">
          <source>The most common reason an attempt to obtain a</source>
          <target state="translated">最常见的原因是,试图获得</target>
        </trans-unit>
        <trans-unit id="b4677e9c54155902987749f94de50b511a297fed" translate="yes" xml:space="preserve">
          <source>The most common way to force an SQLite database to exist purely in memory is to open the database using the special filename &quot;&lt;b&gt;:memory:&lt;/b&gt;&quot;. In other words, instead of passing the name of a real disk file into one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; functions, pass in the string &quot;:memory:&quot;. For example:</source>
          <target state="translated">强制SQLite数据库完全存在于内存中的最常见方法是使用特殊文件名&amp;ldquo; &lt;b&gt;：memory：&lt;/b&gt; &amp;rdquo; 打开数据库。换句话说，不是将实际磁盘文件的名称传递给&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;函数之一，而是传递字符串&amp;ldquo;：memory：&amp;rdquo;。例如：</target>
        </trans-unit>
        <trans-unit id="03a7919d9a36d839fb3e6c8676819056867ece77" translate="yes" xml:space="preserve">
          <source>The most efficient way to apply changes to a B-Tree (the data structure that SQLite uses to store each table and index on disk) is to make the changes in key order. But if an SQL table has one or more indexes, the key order for each index may be different from the main table and the other auxiliary indexes. As a result, when executing a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements it is not generally possible to order the operations so that all b-trees are updated in key order. The RBU update process works around this by applying all changes to the main table in one pass, then applying changes to each index in separate passes, ensuring each B-Tree is updated optimally. For a large database file (one that does not fit in the OS disk cache) this procedure can result in two orders of magnitude faster updates.</source>
          <target state="translated">将更改应用于B树（SQLite用于在磁盘上存储每个表和索引的数据结构）的最有效方法是按键顺序进行更改。但是，如果SQL表具有一个或多个索引，则每个索引的键顺序可能与主表和其他辅助索引不同。结果，当执行一系列&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE时&lt;/a&gt;语句通常无法对操作进行排序，以使所有b树都按键顺序进行更新。 RBU更新过程通过一次将所有更改应用于主表，然后在单独的通道中将更改应用于每个索引，从而确保对每个B-Tree进行最佳更新来解决此问题。对于大型数据库文件（一个不适合OS磁盘缓存的文件），此过程可以使更新速度提高两个数量级。</target>
        </trans-unit>
        <trans-unit id="0aab584bc04ad9506143fb4e57b11f24aeb68952" translate="yes" xml:space="preserve">
          <source>The most useful</source>
          <target state="translated">最有用的</target>
        </trans-unit>
        <trans-unit id="672a287b758e4f6545eeda0d335349088507b997" translate="yes" xml:space="preserve">
          <source>The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;full-text query expression&amp;gt;&quot; as part of the WHERE clause of a SELECT statement that reads data from an FTS table. &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;Simple FTS queries&lt;/a&gt; that return all documents that contain a given term are described above. In that discussion the right-hand operand of the MATCH operator was assumed to be a string consisting of a single term. This section describes the more complex query types supported by FTS tables, and how they may be utilized by specifying a more complex query expression as the right-hand operand of a MATCH operator.</source>
          <target state="translated">关于FTS表，最有用的是可以使用内置的全文本索引执行的查询。通过指定形式为&amp;ldquo; &amp;lt;column&amp;gt; MATCH &amp;lt;全文查询表达式&amp;gt;&amp;rdquo;的子句来执行全文查询，这是从FTS表中读取数据的SELECT语句的WHERE子句的一部分。上面描述了返回所有包含给定术语的所有文档的&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;简单FTS查询&lt;/a&gt;。在该讨论中，MATCH运算符的右侧操作数被假定为由单个项组成的字符串。本节描述FTS表支持的更复杂的查询类型，以及如何通过将更复杂的查询表达式指定为MATCH运算符的右侧操作数来利用它们。</target>
        </trans-unit>
        <trans-unit id="b952b720a1c68c621b96fa1e29a1ec3a3e91db58" translate="yes" xml:space="preserve">
          <source>The multi-argument max() function returns the argument with the maximum value, or return NULL if any argument is NULL. The multi-argument max() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to max() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;max()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">多参数max（）函数返回具有最大值的参数，如果任何参数为NULL，则返回NULL。多参数max（）函数从左到右搜索其参数，以找到定义整理函数并将该整理函数用于所有字符串比较的参数。如果max（）的参数均未定义整理函数，则使用BINARY整理函数。请注意，当&lt;b&gt;max（）&lt;/b&gt;具有2个或更多参数时，它是一个简单函数，但如果仅给出单个参数，则它作为一个&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;聚合函数&lt;/a&gt;运行。</target>
        </trans-unit>
        <trans-unit id="4978bfa5c1668418de3cae9f58ae0236b3a923fa" translate="yes" xml:space="preserve">
          <source>The multi-argument min() function returns the argument with the minimum value. The multi-argument min() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to min() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;min()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">多参数min（）函数返回带有最小值的参数。多参数min（）函数从左到右搜索其参数，以定义一个定义整理函数的参数，并将该整理函数用于所有字符串比较。如果min（）的参数均未定义整理函数，则使用BINARY整理函数。请注意，当&lt;b&gt;min（）&lt;/b&gt;具有2个或更多参数时，它是一个简单的函数；但是，如果仅给定单个参数，则它将作为&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;聚合函数&lt;/a&gt;运行。</target>
        </trans-unit>
        <trans-unit id="78c0cf060a6f9ee3d1106d60ebe5e6c21511776f" translate="yes" xml:space="preserve">
          <source>The multiply operator now correctly detects 64-bit integer overflow and promotes to floating point in all corner-cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;.</source>
          <target state="translated">现在，乘法运算符可以正确检测到64位整数溢出，并在所有转折情况下都提升为浮点数。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee9132cb0f48417f8650cad9e27fe43d03b0618b" translate="yes" xml:space="preserve">
          <source>The mutation-test.tcl script takes care of all of the details for running a mutation test:</source>
          <target state="translated">mutation-test.tcl脚本处理了运行突变测试的所有细节。</target>
        </trans-unit>
        <trans-unit id="2945579c517aa1d3b8ba9d11b0bc3f91de1e9921" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite中的互斥模块将&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;定义为互斥对象的抽象类型。SQLite核心从不查看&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;的内部表示。它仅处理指向&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="d0e09c593f6493d406d9e4e9dcac2eadda30e574" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite中的互斥模块将&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;定义为互斥对象的抽象类型。SQLite核心从不查看&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;的内部表示。它仅处理指向&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="2683feab4dd898006f40d9a775532ccca7b7b569" translate="yes" xml:space="preserve">
          <source>The mxFrame value is always greater than or equal to both &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and nBackfillAttempted.</source>
          <target state="translated">mxFrame值始终大于或等于&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;和nBackfillAttempted。</target>
        </trans-unit>
        <trans-unit id="ab3c5c72a969cacdc78a3e4dd0229038bdf0e320" translate="yes" xml:space="preserve">
          <source>The mxPathname field is the maximum length of a file pathname that this VFS can use. SQLite sometimes has to preallocate buffers of this size, so it should be as small as reasonably possible. Some filesystems permit huge pathnames, but in practice pathnames rarely extend beyond 100 bytes or so. You do not have to put the longest pathname that the underlying filesystem can handle here. You only have to put the longest pathname that you want SQLite to be able to handle. A few hundred is a good value in most cases.</source>
          <target state="translated">mxPathname字段是这个VFS可以使用的文件路径名的最大长度。SQLite有时不得不预分配这个大小的缓冲区,所以它应该尽可能的小。有些文件系统允许使用巨大的路径名,但实际上路径名很少超过100字节左右。你不需要把底层文件系统能处理的最长路径名放在这里。你只需要输入你希望SQLite能够处理的最长路径名。在大多数情况下,几百个是一个不错的值。</target>
        </trans-unit>
        <trans-unit id="cb1334872e71aa02626433d46e5f9130af9a0bfd" translate="yes" xml:space="preserve">
          <source>The nArg parameter specifies the number of arguments to the function. A value of 0 indicates that any number of arguments is allowed. The eTextRep parameter specifies what representation text values are expected to be in for arguments to this function. The value of this parameter should be one of the parameters defined above. SQLite version 3 allows multiple implementations of the same function using different text representations. The database engine chooses the function that minimization the number of text conversions required.</source>
          <target state="translated">nArg参数指定函数的参数数。值为0表示允许任何数量的参数。eTextRep参数指定本函数参数的文本值应该用什么表示。这个参数的值应该是上面定义的参数之一。SQLite第3版允许同一个函数使用不同的文本表示方式进行多种实现。数据库引擎会选择能使所需的文本转换次数最小化的函数。</target>
        </trans-unit>
        <trans-unit id="15067be8341cb3e5ea308646b0092b9f585804c8" translate="yes" xml:space="preserve">
          <source>The nBackfill can only be increased while holding the WAL_CKPT_LOCK. However, nBackfill is changed to zero during a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt;, and this happens while holding the WAL_WRITE_LOCK.</source>
          <target state="translated">仅在保持WAL_CKPT_LOCK的同时增加nBackfill。但是，在&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL重置&lt;/a&gt;过程中，nBackfill会更改为零，并且在保持WAL_WRITE_LOCK时会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="99673f4f335d79523c7b7494142bf07ba1cd84e2" translate="yes" xml:space="preserve">
          <source>The nBackfill number is never greater than &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;. When nBackfill equals &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;, that means that the WAL content has been completely written back into the database and it is ok to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if there are no locks held on any of WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">nBackfill编号永远不会大于&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;。当nBackfill等于&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame时&lt;/a&gt;，这意味着WAL内容已被完全写回到数据库中，并且如果N&amp;gt; 0的WAL_READ_LOCK（N）中没有任何锁，则可以&lt;a href=&quot;fileformat2#walreset&quot;&gt;重置WAL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58aea584e25c7551e85c617c6b8537adc3f19238" translate="yes" xml:space="preserve">
          <source>The name &quot;memsys5&quot; used for the zero-malloc memory allocator implies that there are several additional memory allocators available, and indeed there are. The default memory allocator is &quot;memsys1&quot;. The debugging memory allocator is &quot;memsys2&quot;. Those have already been covered.</source>
          <target state="translated">零内存分配器使用的名称 &quot;memsys5 &quot;意味着还有几个额外的内存分配器可用,事实上也有。默认的内存分配器是 &quot;memsys1&quot;。调试内存分配器是 &quot;memsys2&quot;。这些已经介绍过了。</target>
        </trans-unit>
        <trans-unit id="e00b973d0e23f6d37321209e23fc2917cf32700a" translate="yes" xml:space="preserve">
          <source>The name &quot;sqlite_schema&quot; does not appear anywhere in the file format. That name is just a convention used by the database implementation. Due to historical and operational considerations, the &quot;sqlite_schema&quot; table can also sometimes be called by one of the following aliases:</source>
          <target state="translated">文件格式中没有 &quot;sqlite_schema &quot;这个名字。这个名字只是数据库实现中使用的一个惯例。出于历史和操作上的考虑,&quot;sqlite_schema &quot;表有时也可以用下列别名之一来称呼。</target>
        </trans-unit>
        <trans-unit id="5db0afbba9901c1e9e8534384d38571355c85857" translate="yes" xml:space="preserve">
          <source>The name for the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; used to compare values in the index-column.</source>
          <target state="translated">&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;的名称，用于比较索引列中的值。</target>
        </trans-unit>
        <trans-unit id="d0a42cf139ce30315511c41a36a93d913d4ae81d" translate="yes" xml:space="preserve">
          <source>The name of a result column is the value of the &quot;AS&quot; clause for that column, if there is an AS clause. If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.</source>
          <target state="translated">如果有AS子句,那么结果列的名称就是该列的 &quot;AS &quot;子句的值。如果没有AS子句,那么该列的名称是未指定的,可能会随着SQLite的不同版本而改变。</target>
        </trans-unit>
        <trans-unit id="a57f858acf3d2e5077979e3afa2c8309985a2b90" translate="yes" xml:space="preserve">
          <source>The name of an SQLite database is the name of a file that will contain the database. If the file does not exist, SQLite attempts to create and initialize it. If the file is read-only (due to permission bits or because it is located on read-only media like a CD-ROM) then SQLite opens the database for reading only. The entire SQL database is stored in a single file on the disk. But additional temporary files may be created during the execution of an SQL command in order to store the database rollback journal or temporary and intermediate results of a query.</source>
          <target state="translated">SQLite数据库的名称是一个将包含数据库的文件的名称。如果文件不存在,SQLite会尝试创建并初始化它。如果文件是只读的(由于权限位或因为它位于CD-ROM等只读介质上),那么SQLite就会打开数据库进行只读。整个SQL数据库存储在磁盘上的一个文件中。但是在执行SQL命令的过程中可能会创建额外的临时文件,以便存储数据库回滚日志或查询的临时和中间结果。</target>
        </trans-unit>
        <trans-unit id="2e5f7637f527bcb85ea83184153ee4c57e5bbfca" translate="yes" xml:space="preserve">
          <source>The name of each column in the table.</source>
          <target state="translated">表中每一列的名称。</target>
        </trans-unit>
        <trans-unit id="e1e64668404efe0d041f261ba3d958b47753bba4" translate="yes" xml:space="preserve">
          <source>The name of the FTS5 table column that contains the term.</source>
          <target state="translated">包含术语的FTS5表列名称。</target>
        </trans-unit>
        <trans-unit id="fb2519166ef6466d94c575e04a046d25ae02cbef" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">排序规则的名称是sqlite3_create_collat​​ion（）和sqlite3_create_collat​​ion_v2（）的UTF-8字符串，以及sqlite3_create_collat​​ion16（）的本地字节顺序的UTF-16字符串。根据&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;比较相等的排序规则名称被视为相同的名称。</target>
        </trans-unit>
        <trans-unit id="7df8bfa2bb01af5c880a238a6167d3b3a1623f37" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">排序规则的名称是sqlite3_create_collat​​ion（）和sqlite3_create_collat​​ion_v2（）的UTF-8字符串，以及sqlite3_create_collat​​ion16（）的本地字节顺序的UTF-16字符串。根据&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;比较相等的排序规则名称被视为相同的名称。</target>
        </trans-unit>
        <trans-unit id="60f9c38a5b1707739850b72dfb67adc25dbc2069" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed, or NULL if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">被索引列的名称；如果index-column是被索引表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;expridx&quot;&gt;expression，&lt;/a&gt;则为NULL 。</target>
        </trans-unit>
        <trans-unit id="a2c4a68aabf0cd9d6847a72cb797a421605fdb66" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed. This columns is NULL if the column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">被索引的列的名称。如果列是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;expridx&quot;&gt;表达式，&lt;/a&gt;则此列为 NULL 。</target>
        </trans-unit>
        <trans-unit id="2755fad1da17fab976d4effee601e3a0ced598c2" translate="yes" xml:space="preserve">
          <source>The name of the column that contains the term instance.</source>
          <target state="translated">包含术语实例的列名。</target>
        </trans-unit>
        <trans-unit id="d4c672f643ac02f7fa3683763e45ddf698d1be4b" translate="yes" xml:space="preserve">
          <source>The name of the database is usually just the name of a disk file in which the database is stored. If the name of the database is the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; then a new database is created in memory. If the name of the database is an empty string, then the database is created in an empty file that is automatically deleted when the database connection closes. &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; can be used if the &quot;&lt;b&gt;-uri yes&lt;/b&gt;&quot; option is supplied on the &lt;b&gt;sqlite3&lt;/b&gt; command.</source>
          <target state="translated">数据库的名称通常只是存储数据库的磁盘文件的名称。如果数据库名称是特殊名称&amp;ldquo; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &amp;rdquo;，则会在内存中创建一个新数据库。如果数据库名称是一个空字符串，那么将在一个空文件中创建数据库，该文件将在数据库连接关闭时自动删除。如果&lt;b&gt;sqlite3&lt;/b&gt;命令提供了&amp;ldquo; &lt;b&gt;-uri yes&lt;/b&gt; &amp;rdquo;选项，则可以使用&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="638ad72e8f8e6b978d1b5c7a5434bac446aa668c" translate="yes" xml:space="preserve">
          <source>The name of the database on which the transaction was committed</source>
          <target state="translated">进行交易的数据库名称;</target>
        </trans-unit>
        <trans-unit id="b53c39aeaa16a31f4a835cb5ee0c4ef2cb1c4ca7" translate="yes" xml:space="preserve">
          <source>The name of the database table,</source>
          <target state="translated">数据库表的名称。</target>
        </trans-unit>
        <trans-unit id="1389d8d4ecdcdbedac7a4549e6a07ae7ad0ad26c" translate="yes" xml:space="preserve">
          <source>The name of the database which is being changed</source>
          <target state="translated">正在更改的数据库名称</target>
        </trans-unit>
        <trans-unit id="fc047e5a2c9d6a845176aac031ed03d6a1b50ee2" translate="yes" xml:space="preserve">
          <source>The name of the desired tokenizer should be substituted in place of 'porter' in the example, of course. If the tokenizer requires one or more arguments, they should be separated by commas in the fts3tokenize declaration (even though they are separated by spaces in declarations of regular fts4 tables). The following creates fts4 and fts3tokenize tables that use the same tokenizer:</source>
          <target state="translated">当然,在本例中,需要用 tokenizer 的名称代替 'porter'。如果 tokenizer 需要一个或多个参数,那么在 fts3tokenize 声明中应该用逗号来分隔(尽管在常规的 fts4 表的声明中是用空格分隔的)。下面创建了使用相同 tokenizer 的 fts4 和 fts3tokenize 表。</target>
        </trans-unit>
        <trans-unit id="9a63a9136665984fc122cf635a36ad0166ead67d" translate="yes" xml:space="preserve">
          <source>The name of the index.</source>
          <target state="translated">索引的名称。</target>
        </trans-unit>
        <trans-unit id="c2412b63f15e8dfde7222fa76ad9e5504c06aea1" translate="yes" xml:space="preserve">
          <source>The name of the new table.</source>
          <target state="translated">新表的名称。</target>
        </trans-unit>
        <trans-unit id="a12d264e140fa64a7adf3172f5ec27d60bbcedb0" translate="yes" xml:space="preserve">
          <source>The name of the result column is a combination of the source table and source column name: TABLE.COLUMN</source>
          <target state="translated">结果列的名称是源表和源列名称的组合:TABLE.COLUMN。</target>
        </trans-unit>
        <trans-unit id="85777de7d38bf8fc5dfa8258c31af44f8a1c7698" translate="yes" xml:space="preserve">
          <source>The name of the table contains one or more &quot;_&quot; characters.</source>
          <target state="translated">表名包含一个或多个&quot;_&quot;字符。</target>
        </trans-unit>
        <trans-unit id="d14fb34ff4c810e0436eba6520cbeda0158f9e95" translate="yes" xml:space="preserve">
          <source>The name of the table data is read from.</source>
          <target state="translated">从表中读取数据的名称。</target>
        </trans-unit>
        <trans-unit id="a43b536a14c1d7b3d8b50ac0e9b44a83e9c467f9" translate="yes" xml:space="preserve">
          <source>The name of the table in which the xColumnSize values are stored (unless columnsize=0 is specified) is &quot;&amp;lt;name&amp;gt;_docsize&quot;, where &amp;lt;name&amp;gt; is the name of the FTS5 table itself. The &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt; tool may be used on an existing database in order to determine how much space might be saved by recreating an FTS5 table using columnsize=0.</source>
          <target state="translated">存储xColumnSize值的表的名称（除非指定了columnize = 0）是&amp;ldquo; &amp;lt;名称&amp;gt; _docsize&amp;rdquo;，其中，&amp;lt;名称&amp;gt;是FTS5表本身的名称。该&lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt;工具可以在现有的数据库，以确定有多少空间可以通过重新使用columnsize = 0的FTS5表保存使用。</target>
        </trans-unit>
        <trans-unit id="ba455f33d978f1db1e5e1561024b5ab7e0845678" translate="yes" xml:space="preserve">
          <source>The name of the table or index that is implemented by the btree of the current row</source>
          <target state="translated">当前行的btree实现的表或索引的名称。</target>
        </trans-unit>
        <trans-unit id="b9dba3fb9b44494b1bade858ebafe1459aa85475" translate="yes" xml:space="preserve">
          <source>The name of the table to be modified in an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement must be an unqualified table name. In other words, one must use just &quot;</source>
          <target state="translated">要在&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;或&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句中修改的表的名称必须是非限定的表名称。换句话说，您只能使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6e32ef9d959d1305ba25656ee3bbcec3b526eef2" translate="yes" xml:space="preserve">
          <source>The name that occurs after the AS keyword is the name of the database used internally by SQLite. The schema-names 'main' and 'temp' refer to the main database and the database used for temporary tables. The main and temp databases cannot be attached or detached.</source>
          <target state="translated">AS关键字后出现的名称是SQLite内部使用的数据库名称。模式名'main'和'temp'指的是主数据库和用于临时表的数据库。主数据库和临时数据库不能被附加或分离。</target>
        </trans-unit>
        <trans-unit id="c7f1793be68e4540903171531d569a4a7be0fbfa" translate="yes" xml:space="preserve">
          <source>The names and numeric values for existing result codes are fixed and unchanging. However, new result codes, and especially new extended result codes, might appear in future releases of SQLite.</source>
          <target state="translated">现有结果代码的名称和数值是固定不变的。但是,新的结果代码,特别是新的扩展结果代码,可能会出现在SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="6c186656572f2bf1670bbd5a3b99aeadd51bedda" translate="yes" xml:space="preserve">
          <source>The names of the columns are contained in first</source>
          <target state="translated">栏目名称包含在第一</target>
        </trans-unit>
        <trans-unit id="6e42a281800acf1a1a711bf3baf9388c4ecfa00b" translate="yes" xml:space="preserve">
          <source>The names returned are the original un-aliased names of the database, table, and column.</source>
          <target state="translated">返回的名称是数据库、表、列的原始无偏旁名称。</target>
        </trans-unit>
        <trans-unit id="9d972c129d1db380a40044755e84ee7d9ba4bda3" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows an application to customize the behavior of SQLite at run-time. Customizations possible using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; include the following:</source>
          <target state="translated">新的&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口允许应用程序在运行时自定义SQLite的行为。使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;可能进行的自定义包括以下内容：</target>
        </trans-unit>
        <trans-unit id="3df658c177f1eac56b80fa5f85864ebd817426dc" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface allows an application to query the performance status of SQLite at runtime.</source>
          <target state="translated">新的&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;接口允许应用程序在运行时查询SQLite的性能状态。</target>
        </trans-unit>
        <trans-unit id="a8d3b04d8482aa6bd5d923ab36f6fdfe7a6ac1b9" translate="yes" xml:space="preserve">
          <source>The new API for SQLite 3.0 contains routines that accept text as both UTF-8 and UTF-16 in the native byte order of the host machine. Each database file manages text as either UTF-8, UTF-16BE (big-endian), or UTF-16LE (little-endian). Internally and in the disk file, the same text representation is used everywhere. If the text representation specified by the database file (in the file header) does not match the text representation required by the interface routines, then text is converted on-the-fly. Constantly converting text from one representation to another can be computationally expensive, so it is suggested that programmers choose a single representation and stick with it throughout their application.</source>
          <target state="translated">SQLite 3.0的新API包含了一些例程,这些例程可以接受文本为UTF-8和UTF-16,并以主机的本地字节顺序排列。每个数据库文件都以UTF-8、UTF-16BE(大字节)或UTF-16LE(小字节)的形式管理文本。在内部和磁盘文件中,到处都使用相同的文本表示法。如果数据库文件(在文件头)指定的文本表示法与接口例程所需的文本表示法不匹配,那么文本将被即时转换。不断地将文本从一种表示方式转换到另一种表示方式可能会造成计算成本,因此建议程序员选择一种单一的表示方式,并在整个应用程序中坚持使用它。</target>
        </trans-unit>
        <trans-unit id="f5fd61ae1c4f097aa92960dd4fc53f087c2a1de0" translate="yes" xml:space="preserve">
          <source>The new OP_SeekScan opcode is used to improve performance of multi-column index look-ups when later columns are constrained by an IN operator.</source>
          <target state="translated">新的OP_SeekScan操作码用于提高多列索引查找的性能,当后面的列受到IN操作符的约束时。</target>
        </trans-unit>
        <trans-unit id="30af4368149bbc60ce20946b58b7cfd9adb8ff97" translate="yes" xml:space="preserve">
          <source>The new OS interface for SQLite is built around an object named &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. The &quot;vfs&quot; stands for &quot;Virtual File System&quot;. The sqlite3_vfs object is basically a structure containing pointers to functions that implement the primitive disk I/O operations that SQLite needs to perform in order to read and write databases. In this article, we will often refer to an sqlite3_vfs objects as a &quot;VFS&quot;.</source>
          <target state="translated">SQLite的新OS接口基于名为&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的对象构建。&amp;ldquo; vfs&amp;rdquo;代表&amp;ldquo;虚拟文件系统&amp;rdquo;。sqlite3_vfs对象基本上是一个结构，其中包含指向函数的指针，这些函数实现SQLite为了读取和写入数据库而需要执行的原始磁盘I / O操作。在本文中，我们经常将sqlite3_vfs对象称为&amp;ldquo; VFS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6c9ac7112282c02c3ac370e4792bfc347f1711f1" translate="yes" xml:space="preserve">
          <source>The new change is ignored. This case does not occur if the new changeset was recorded immediately after the changesets already added to the changegroup.</source>
          <target state="translated">新的变更被忽略。如果新的变更集是在已经添加到变更组的变更集之后立即记录的,这种情况不会发生。</target>
        </trans-unit>
        <trans-unit id="7b39e9d3e42d3852cda66bb7e7297a2f31d0e706" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">新的数据库连接将使用&amp;ldquo;多线程&amp;rdquo;&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;。这意味着只要每个线程使用不同的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;，就可以允许单独的线程同时使用SQLite 。</target>
        </trans-unit>
        <trans-unit id="67ff5fb06e02cb095d4456f9e428328e41689b42" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">新的数据库连接将使用&amp;ldquo;多线程&amp;rdquo;&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;。这意味着只要每个线程使用不同的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;，就可以允许单独的线程同时使用SQLite 。</target>
        </trans-unit>
        <trans-unit id="2ed188f9846a7395326bff47f2223ddc25ac3eab" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="translated">新的数据库连接将使用&amp;ldquo;序列化&amp;rdquo;&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;。这意味着多个线程可以安全地尝试同时使用同一数据库连接。（Mutexes会阻止任何实际的并发，但是在这种模式下进行尝试没有任何危害。）</target>
        </trans-unit>
        <trans-unit id="f2075b8f3b4c50de265f00054b0d87b23e094598" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="translated">新的数据库连接将使用&amp;ldquo;序列化&amp;rdquo;&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;。这意味着多个线程可以安全地尝试同时使用同一数据库连接。（Mutexes会阻止任何实际的并发，但是在这种模式下进行尝试没有任何危害。）</target>
        </trans-unit>
        <trans-unit id="81ae31ac06c9efe8e8edfec9e13527250faad45f" translate="yes" xml:space="preserve">
          <source>The new database file format uses B+trees for tables. In a B+tree, all data is stored in the leaves of the tree instead of in both the leaves and the intermediate branch nodes. The use of B+trees for tables allows for better scalability and the storage of larger data fields without the use of overflow pages. Traditional B-trees are still used for indices.</source>
          <target state="translated">新的数据库文件格式使用B+树作为表。在B+树中,所有的数据都存储在树的叶子中,而不是同时存储在叶子和中间的分支节点中。表使用B+树可以实现更好的扩展性,并且可以存储更大的数据字段,而不需要使用溢出页。传统的B树仍然用于索引。</target>
        </trans-unit>
        <trans-unit id="31e91eb6ebd1ae009dff2061b0ed5da69f5f04a8" translate="yes" xml:space="preserve">
          <source>The new file format also supports variable pages sizes between 512 and 65536 bytes. The size of a page is stored in the file header so the same library can read databases with different pages sizes, in theory, though this feature has not yet been implemented in practice.</source>
          <target state="translated">新的文件格式还支持512到65536字节之间的可变页面大小。页面的大小存储在文件头中,因此理论上同一库可以读取不同页面大小的数据库,尽管这一功能尚未在实践中实现。</target>
        </trans-unit>
        <trans-unit id="b7b98e36d84deeda55906998dc0425a8e896c821" translate="yes" xml:space="preserve">
          <source>The new file format omits unused fields from its disk images. For example, indices use only the key part of a B-tree record and not the data. So for indices, the field that records the length of the data is omitted. Integer values such as the length of key and data are stored using a variable-length encoding so that only one or two bytes are required to store the most common cases but up to 64-bits of information can be encoded if needed. Integer and floating point data is stored on the disk in binary rather than being converted into ASCII as in SQLite version 2.8. These changes taken together result in database files that are typically 25% to 35% smaller than the equivalent files in SQLite version 2.8.</source>
          <target state="translated">新的文件格式从其磁盘图像中省略了未使用的字段。例如,索引只使用B树记录的关键部分,而不使用数据。所以对于索引,记录数据长度的字段被省略。整数值如键的长度和数据的长度使用可变长度的编码来存储,所以在最常见的情况下只需要存储一个或两个字节,但如果需要的话,可以对最多64位的信息进行编码。整数和浮点数据以二进制方式存储在磁盘上,而不是像SQLite 2.8版本那样转换成ASCII。这些变化加在一起的结果是,数据库文件通常比SQLite 2.8版本中的同等文件小25%到35%。</target>
        </trans-unit>
        <trans-unit id="5a8ddfc73fc040315222214bdfe8a3558fe0da52" translate="yes" xml:space="preserve">
          <source>The new interface uses three separate functions to replace the single &lt;b&gt;sqlite_exec&lt;/b&gt; function.</source>
          <target state="translated">新接口使用三个单独的函数来替换单个&lt;b&gt;sqlite_exec&lt;/b&gt;函数。</target>
        </trans-unit>
        <trans-unit id="601cb56433c850ed70120e223ec644602fc957a5" translate="yes" xml:space="preserve">
          <source>The new object is configured with the rebase buffer obtained from sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure(). If the local changeset is to be rebased against multiple remote changesets, then sqlite3rebaser_configure() should be called multiple times, in the same order that the multiple sqlite3changeset_apply_v2() calls were made.</source>
          <target state="translated">通过调用sqlite3rebaser_configure(),用从sqlite3changeset_apply_v2()获得的重基缓冲区配置新对象。如果本地变化集要针对多个远程变化集进行重基,那么sqlite3rebaser_configure()应该被多次调用,调用顺序与多次调用sqlite3changeset_apply_v2()的顺序相同。</target>
        </trans-unit>
        <trans-unit id="a80319826820a0baa113ed82a7da25195888339a" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新行必须满足与&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;相同的条件- 新行必须存在，并且被提名列中必须存储有blob或text值。如果表中不存在新行，或者其中不包含Blob或文本值，或者发生其他错误，则返回SQLite错误代码，并且Blob句柄被视为中止。在中断的Blob句柄上对&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）的&lt;/a&gt;所有后续调用都立即返回SQLITE_ABORT。在&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;异常&lt;/a&gt;终止的Blob句柄上调用sqlite3_blob_bytes（）始终返回零。</target>
        </trans-unit>
        <trans-unit id="1fc9db87ef5146974ffc63aaf19ef4d76ed16ccc" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新行必须满足与&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;相同的条件- 新行必须存在，并且被提名列中必须存储有blob或text值。如果表中不存在新行，或者其中不包含Blob或文本值，或者发生其他错误，则返回SQLite错误代码，并且Blob句柄被视为中止。在中断的Blob句柄上对&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;或&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）的&lt;/a&gt;所有后续调用都立即返回SQLITE_ABORT。在&lt;a href=&quot;blob_bytes&quot;&gt;异常&lt;/a&gt;终止的Blob句柄上调用sqlite3_blob_bytes（）始终返回零。</target>
        </trans-unit>
        <trans-unit id="477dc8c1b42a8f1f1f9e215976276669879cbe40" translate="yes" xml:space="preserve">
          <source>The new values for each modified field of the row, and</source>
          <target state="translated">行中每个修改后的字段的新值,以及</target>
        </trans-unit>
        <trans-unit id="9ca11824ed5a21754d9f34df6fca6bca218bd35f" translate="yes" xml:space="preserve">
          <source>The new window definition must not include a PARTITION BY clause. The PARTITION BY clause, if there is one, must be supplied by the base window specification.</source>
          <target state="translated">新窗口定义不得包含 PARTITION BY 子句。如果有PARTITION BY子句,则必须由基本窗口规范提供。</target>
        </trans-unit>
        <trans-unit id="f3a9a1d6f9268d0f1362c9fb457875a7fb250370" translate="yes" xml:space="preserve">
          <source>The newer &quot;.eqp trace&quot; command does everything that &quot;.eqp full&quot; does and also turns on &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE tracing&lt;/a&gt;.</source>
          <target state="translated">较新的&amp;ldquo; .eqp trace&amp;rdquo;命令执行&amp;ldquo; .eqp full&amp;rdquo;所做的所有操作，并且还打开了&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE跟踪&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd8ed5a57b50230eec8d4ec2e3e5c1e149c55cc8" translate="yes" xml:space="preserve">
          <source>The newer xQueryFunc callback receives more information from the r-tree query engine on each call, and it sends more information back to the query engine before it returns. To help keep the interface manageable, the xQueryFunc callback sends and receives information from the query engine as fields in the sqlite3_rtree_query_info structure:</source>
          <target state="translated">较新的xQueryFunc回调在每次调用时都会从r-tree查询引擎接收更多的信息,并且在返回之前会将更多的信息发回给查询引擎。为了帮助保持接口的可管理性,xQueryFunc回调以sqlite3_rtree_query_info结构中的字段形式发送和接收来自查询引擎的信息。</target>
        </trans-unit>
        <trans-unit id="03223a32a94905afaa2e599c575bdc7c618a776e" translate="yes" xml:space="preserve">
          <source>The next &quot;.mode&quot; command will reset the &quot;.separator&quot; back to its default. So you will need repeat the &quot;.separator&quot; command whenever you change modes if you want to continue using a non-standard separator.</source>
          <target state="translated">下一个&quot;.mode &quot;命令会将&quot;.separator &quot;重置为默认值。因此,如果你想继续使用非标准的分隔符,你需要在每次改变模式时重复使用&quot;.separator &quot;命令。</target>
        </trans-unit>
        <trans-unit id="9bff369a4e5022b3604d755cd856a8cb8591c715" translate="yes" xml:space="preserve">
          <source>The next block contains an example rank function that uses matchinfo data implemented in C. Instead of a single weight, it allows a weight to be externally assigned to each column of each document. It may be registered with SQLite like any other user function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;.</source>
          <target state="translated">下一个块包含一个示例等级函数，该函数使用在C中实现的matchinfo数据。它允许将权重从外部分配给每个文档的每一列，而不是单个权重。可以像其他任何使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function的&lt;/a&gt;用户函数一样，将其注册到SQLite 。</target>
        </trans-unit>
        <trans-unit id="5e308fd7498285ea1f61e243e9d3f001701f643f" translate="yes" xml:space="preserve">
          <source>The next block of SQL enhances the query with solutions to two other problems that may arise in developing search applications using FTS:</source>
          <target state="translated">接下来的SQL块通过解决使用FTS开发搜索应用程序时可能出现的另外两个问题来增强查询。</target>
        </trans-unit>
        <trans-unit id="acd253e5152192f86ab636fd16bb5196034aa10b" translate="yes" xml:space="preserve">
          <source>The next chart compares SQLite database updates in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; against raw direct-to-disk overwrites of separate files on disk. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is NORMAL. All database writes are in a single transaction. The timer for the database writes is stopped after the transaction commits, but before a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run. Note that the SQLite writes, unlike the direct-to-disk writes, are &lt;a href=&quot;transactional&quot;&gt;transactional&lt;/a&gt; and &lt;a href=&quot;transactional&quot;&gt;power-safe&lt;/a&gt;, though because the synchronous setting is NORMAL instead of FULL, the transactions are not durable.</source>
          <target state="translated">下一张图表将&lt;a href=&quot;wal&quot;&gt;WAL模式下的&lt;/a&gt; SQLite数据库更新与磁盘上单独文件的原始直接磁盘覆盖进行了比较。该&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为正常。所有数据库写入都在单个事务中。在事务提交之后但在运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;之前，数据库写计时器将停止。请注意，与直接磁盘写入不同，SQLite写入具有&lt;a href=&quot;transactional&quot;&gt;事务性&lt;/a&gt;和&lt;a href=&quot;transactional&quot;&gt;电源安全性&lt;/a&gt;，但是由于同步设置为NORMAL而不是FULL，因此事务不持久。</target>
        </trans-unit>
        <trans-unit id="0aae132ea98563594c1fa5eb1b5277ade35e9e0f" translate="yes" xml:space="preserve">
          <source>The next chart shows the performance of SQLite versus direct-to-disk when transactions are disabled (&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt;) and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to OFF. These settings put SQLite on an equal footing with direct-to-disk writes, which is to say they make the data prone to corruption due to system crashes and power failures.</source>
          <target state="translated">下一张图表显示了禁用事务（&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;）并将&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA sync&lt;/a&gt;设置为OFF 时，SQLite与直接磁盘的性能。这些设置使SQLite在磁盘直接写入方面处于平等的地位，也就是说，由于系统崩溃和电源故障，它们使数据易于损坏。</target>
        </trans-unit>
        <trans-unit id="a36fc6db6d371099515d1fcc0740a7c0b2437b14" translate="yes" xml:space="preserve">
          <source>The next example demonstrates lag(), lead(), first_value(), last_value() and nth_value(). The frame-spec is ignored by both lag() and lead(), but respected by first_value(), last_value() and nth_value().</source>
          <target state="translated">下一个例子演示了lag()、lead()、first_value()、last_value()和nth_value()。lag()和lead()都会忽略frame-spec,但first_value()、last_value()和nth_value()会尊重它。</target>
        </trans-unit>
        <trans-unit id="edb143346c38b864be88a8c33e46d2997195abb0" translate="yes" xml:space="preserve">
          <source>The next example uses two common table expressions in a single WITH clause. The following table records a family tree:</source>
          <target state="translated">下一个例子在一个WITH子句中使用了两个常见的表表达式。下面的表记录了一个家庭树。</target>
        </trans-unit>
        <trans-unit id="1e6dfc599524aaa9c044c52fd99b0a8ed104813e" translate="yes" xml:space="preserve">
          <source>The next interface routine to SQLite is a convenience function used to test whether or not a string forms a complete SQL statement. If the &lt;b&gt;sqlite_complete&lt;/b&gt; function returns true when its input is a string, then the argument forms a complete SQL statement. There are no guarantees that the syntax of that statement is correct, but we at least know the statement is complete. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then more text is required to complete the SQL statement.</source>
          <target state="translated">SQLite的下一个接口例程是一个便捷函数，用于测试字符串是否形成完整的SQL语句。如果&lt;b&gt;sqlite_complete&lt;/b&gt;函数的输入为字符串时返回true，则该参数形成完整的SQL语句。不能保证该语句的语法正确，但是我们至少知道该语句是完整的。如果&lt;b&gt;sqlite_complete&lt;/b&gt;返回false，则需要更多文本来完成SQL语句。</target>
        </trans-unit>
        <trans-unit id="c0fe3b1ebf5cdcafa2a519a22d91d50cf98645d3" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;master journal&quot; file. The name of the master journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">多文件提交的下一步是创建&amp;ldquo;主日志&amp;rdquo;文件。主日志文件的名称与原始数据库文件名（使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;接口打开的数据库，不是&lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt;辅助数据库之一）打开的文本&lt;b&gt;名称相同&lt;/b&gt;，且文本为&amp;ldquo; &lt;b&gt;-mj&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cd61740e94e70cec25ceb66f34763d5696dff28" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;super-journal&quot; file. The name of the super-journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">多文件提交的下一步是创建&amp;ldquo;超级新闻&amp;rdquo;文件。超级新闻文件的名称与原始数据库文件名（使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;接口打开的数据库，而不是已&lt;a href=&quot;lang_attach&quot;&gt;附加的&lt;/a&gt;辅助数据库之一）具有相同的名称，其文本为&amp;ldquo; &lt;b&gt;-mj&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3da089b39e9e2681938268cb3d32b250cde300bb" translate="yes" xml:space="preserve">
          <source>The next step is to delete the master journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">下一步是删除主日记文件。这就是提交多文件事务的地方。在删除回滚日志的单文件提交方案中，此步骤对应于&lt;a href=&quot;#section_3_11&quot;&gt;步骤3.11&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eca8d6f0301fd62dd1a522a60a7179d3923b8b3" translate="yes" xml:space="preserve">
          <source>The next step is to delete the super-journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">下一步是删除超级新闻文件。这就是提交多文件事务的地方。此步骤对应于单文件提交方案中的&lt;a href=&quot;#section_3_11&quot;&gt;步骤3.11，&lt;/a&gt;在该方案中回滚日志已删除。</target>
        </trans-unit>
        <trans-unit id="0f8a36a95656f30638f07c12cb9da14410f8f263" translate="yes" xml:space="preserve">
          <source>The next step is to flush the content of the rollback journal file to nonvolatile storage. As we will see later, this is a critical step in insuring that the database can survive an unexpected power loss. This step also takes a lot of time, since writing to nonvolatile storage is normally a slow operation.</source>
          <target state="translated">下一步是将回滚日志文件的内容刷新到非易失性存储中。正如我们稍后将看到的那样,这是保证数据库能够在意外断电的情况下生存的关键一步。这一步也需要大量的时间,因为向非易失性存储中写入内容通常是一个缓慢的操作。</target>
        </trans-unit>
        <trans-unit id="2d76b37ca4cb1c2c8f635e9aaada12e5312b553c" translate="yes" xml:space="preserve">
          <source>The next step is to move the changes in the public branch over into the private branch. In other words, we want to create circle (5) in the diagram above. Begin by changing to the private branch using &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot;. Then type this command:</source>
          <target state="translated">下一步是将公共分支中的更改移到私有分支中。换句话说，我们要在上图中创建圆（5）。首先使用&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo; 更改为私有分支。然后键入以下命令：</target>
        </trans-unit>
        <trans-unit id="7e4259fddae0dc878cdf5dde573b08c0dee99991" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the master journal file in the header of every rollback journal. Space to hold the master journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">下一步是将主日志文件的完整路径名记录在每个回滚日志的页眉中。在创建回滚日记本时,每个回滚日记本的开头都预留了存放主日记本文件名的空间。</target>
        </trans-unit>
        <trans-unit id="75cf4af1420a93693d3db893fcca12c3f40102cd" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the super-journal file in the header of every rollback journal. Space to hold the super-journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">下一步是在每个回滚日志的页眉中记录超级日志文件的完整路径名。在创建回滚日记本时,在每个回滚日记本的开头都预留了存放超级日记本文件名的空间。</target>
        </trans-unit>
        <trans-unit id="10799d0f2a52185a80b7f98059fdd7fef8ba0412" translate="yes" xml:space="preserve">
          <source>The next three bytes in the header record the number of vertexes in the polygon as a big-endian integer. Thus there is an upper bound of about 16 million vertexes per polygon.</source>
          <target state="translated">头部的三个字节记录了多边形中的顶点数量,是一个大安字节的整数,因此每个多边形的顶点数量上限是1600万。因此,每个多边形的顶点数上限为1600万。</target>
        </trans-unit>
        <trans-unit id="a4532dd188d90322b7de7cb35c04fd5fcf2e6593" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction for P1 will refer to the first entry in the database table or index. If the table or index is empty, jump immediately to P2. If the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">P1 的&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;或&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;或&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;指令的下一次使用将引用数据库表或索引中的第一个条目。如果表或索引为空，请立即跳至P2。如果表或索引不为空，请执行以下指令。</target>
        </trans-unit>
        <trans-unit id="db275badbcaa5bbb5c1ecd5830883705763b811b" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction for P1 will refer to the last entry in the database table or index. If the table or index is empty and P2&amp;gt;0, then jump immediately to P2. If P2 is 0 or if the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">P1 的&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;或&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;或&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;指令的下一次使用将引用数据库表或索引中的最后一个条目。如果表或索引为空并且P2&amp;gt; 0，则立即跳转到P2。如果P2为0，或者表或索引不为空，请执行以下指令。</target>
        </trans-unit>
        <trans-unit id="971bdad47f863dca0857c6853816fdb36613779f" translate="yes" xml:space="preserve">
          <source>The no-op memory allocator is not useful by itself. It exists only as a placeholder so that SQLite has a memory allocator to link against on systems that may not have malloc(), free(), or realloc() in their standard library. An application that is compiled with &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; will need to use &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; together with &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; to specify a new alternative memory allocator before beginning to use SQLite.</source>
          <target state="translated">无操作内存分配器本身没有用。它仅作为占位符存在，因此SQLite可以在其标准库中可能没有malloc（），free（）或realloc（）的系统上链接一个内存分配器。在开始使用SQLite之前，使用&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt;编译的应用程序将需要与&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;或&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;一起使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;来指定新的备用内存分配器。</target>
        </trans-unit>
        <trans-unit id="fa03e3271f78c25f5482177efc3b575ee4cb93ab" translate="yes" xml:space="preserve">
          <source>The nolock query parameter is a boolean that disables all calls to the xLock, xUnlock, and xCheckReservedLock methods of the VFS when true. The nolock query parameter might be used, for example, when trying to access a file on a filesystem that does not support file locking. Caution: If two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; try to interact with the same SQLite database and one or more of those connections has enabled &quot;nolock&quot;, then database corruption can result. The &quot;nolock&quot; query parameter should only be used if the application can guarantee that writes to the database are serialized.</source>
          <target state="translated">nolock查询参数是一个布尔值，当为true时，它将禁用对VFS的xLock，xUnlock和xCheckReservedLock方法的所有调用。例如，当尝试访问不支持文件锁定的文件系统上的文件时，可以使用nolock查询参数。警告：如果两个或多个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;尝试与同一个SQLite数据库进行交互，并且其中一个或多个连接启用了&amp;ldquo; nolock&amp;rdquo;，则可能导致数据库损坏。仅当应用程序可以保证对数据库的写操作已序列化时，才应使用&amp;ldquo; nolock&amp;rdquo;查询参数。</target>
        </trans-unit>
        <trans-unit id="b327cb7b48d6db3fd953f98055ad0798aba25bf9" translate="yes" xml:space="preserve">
          <source>The normal ROWID selection algorithm described above will generate monotonically increasing unique ROWIDs as long as you never use the maximum ROWID value and you never delete the entry in the table with the largest ROWID. If you ever delete rows or if you ever create a row with the maximum possible ROWID, then ROWIDs from previously deleted rows might be reused when creating new rows and newly created ROWIDs might not be in strictly ascending order.</source>
          <target state="translated">只要你从不使用最大的ROWID值,也从不删除表中具有最大ROWID的条目,上面描述的正常ROWID选择算法就会产生单调增加的唯一ROWID。如果你曾经删除过行,或者你曾经用最大可能的ROWID创建过行,那么在创建新行时,以前删除的行的ROWID可能会被重新使用,而且新创建的ROWID可能不会严格按照升序排列。</target>
        </trans-unit>
        <trans-unit id="dd6fdcceb1d1ed51baa294f01d457a9007d5dbff" translate="yes" xml:space="preserve">
          <source>The notindexed= option is not available. Adding &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; to the column definition is equivalent.</source>
          <target state="translated">notindexed =选项不可用。将&lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt;添加到列定义是等效的。</target>
        </trans-unit>
        <trans-unit id="e15aca005b3d3fc4e0be53d1a5e363f5a459da35" translate="yes" xml:space="preserve">
          <source>The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used.</source>
          <target state="translated">如果参数不同,nullif(X,Y)函数返回第一个参数,如果参数相同,则返回NULL。nullif(X,Y)函数从左到右搜索它的参数,寻找一个定义了整理函数的参数,并使用这个整理函数进行所有的字符串比较。如果nullif()的两个参数都没有定义整理函数,则使用BINARY。</target>
        </trans-unit>
        <trans-unit id="0d33dbf967cc9fffb2bcf5f7dd0e676a56e0fe27" translate="yes" xml:space="preserve">
          <source>The number of arguments to a function is sometimes stored in a signed character. So there is a hard upper bound on SQLITE_MAX_FUNCTION_ARG of 127.</source>
          <target state="translated">一个函数的参数数有时会用一个符号字符来存储。所以SQLITE_MAX_FUNCTION_ARG有一个硬性的上限,为127。</target>
        </trans-unit>
        <trans-unit id="22855456991124f9a63a13f70b4de30a07b1a44f" translate="yes" xml:space="preserve">
          <source>The number of characters in cFrom and cTo do not need to be the same. The rule above says that &quot;ss&quot; on user input will match &quot;&amp;szlig;&quot; with a penalty of 8.</source>
          <target state="translated">cFrom和cTo中的字符数不必相同。上面的规则说，用户输入上的&amp;ldquo; ss&amp;rdquo;将与&amp;ldquo;&amp;szlig;&amp;rdquo;匹配，惩罚为8。</target>
        </trans-unit>
        <trans-unit id="1dc8b6de1e412ad3d4600fff75a5432b18cfae89" translate="yes" xml:space="preserve">
          <source>The number of columns in a table</source>
          <target state="translated">表格中的列数</target>
        </trans-unit>
        <trans-unit id="c449227bed7d73e21c9772a435303abb6080e61e" translate="yes" xml:space="preserve">
          <source>The number of columns in a table is limited by the &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; compile-time parameter. A single row of a table cannot store more than &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; bytes of data. Both of these limits can be lowered at runtime using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">表中的列数受&lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt;编译时参数的限制。表的一行不能存储超过&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;个字节的数据。使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt; C / C ++接口可以在运行时降低这两个限制。</target>
        </trans-unit>
        <trans-unit id="8a6392262a1b2aadeab5c7954067326f2acb3a1d" translate="yes" xml:space="preserve">
          <source>The number of columns in a view</source>
          <target state="translated">视图中的列数</target>
        </trans-unit>
        <trans-unit id="7da1c90b5d954b64a1a4a566749d8c554741462e" translate="yes" xml:space="preserve">
          <source>The number of columns in an index</source>
          <target state="translated">索引中的列数</target>
        </trans-unit>
        <trans-unit id="155a4bbdc3161555e0a5db3b049b1a9960793a80" translate="yes" xml:space="preserve">
          <source>The number of columns in each row returned by the SELECT statement (if any) and the specific values returned have no effect on the results of the EXISTS operator. In particular, rows containing NULL values are not handled any differently from rows without NULL values.</source>
          <target state="translated">SELECT语句返回的每行中的列数(如果有的话)和返回的具体值对EXISTS操作符的结果没有影响。特别是,包含NULL值的行与不包含NULL值的行的处理方式没有任何区别。</target>
        </trans-unit>
        <trans-unit id="b33773d9bb8fcd548b7aa9142e9dd252802d3ebf" translate="yes" xml:space="preserve">
          <source>The number of columns in the result set of a SELECT statement</source>
          <target state="translated">SELECT语句的结果集中的列数。</target>
        </trans-unit>
        <trans-unit id="5962dbc1c4fa716686ee3f9c370159a83fff2488" translate="yes" xml:space="preserve">
          <source>The number of columns in the rows returned by a simple SELECT statement is equal to the number of expressions in the result expression list after substitution of * and alias.* expressions. Each result row is calculated by evaluating the expressions in the result expression list with respect to a single row of input data or, for aggregate queries, with respect to a group of rows.</source>
          <target state="translated">一个简单的SELECT语句返回的行中的列数等于结果表达式列表中替换*和别名.*表达式后的表达式数。每条结果行都是通过评估结果表达式列表中关于单行输入数据的表达式来计算的,或者,对于汇总查询来说,是关于一组行的表达式。</target>
        </trans-unit>
        <trans-unit id="efcaef0127aaba4759abf4c43138ceabba69a62b" translate="yes" xml:space="preserve">
          <source>The number of columns in the table, and</source>
          <target state="translated">表中的列数,以及</target>
        </trans-unit>
        <trans-unit id="ec4b9441464f8df5d1135d79fc696ff2d27c10ef" translate="yes" xml:space="preserve">
          <source>The number of columns the table has, and</source>
          <target state="translated">表的列数,以及</target>
        </trans-unit>
        <trans-unit id="f71fcd9bd24f5e705202e8ea9d15f75d827b7073" translate="yes" xml:space="preserve">
          <source>The number of entries in the write-ahead log (WAL) file for that database</source>
          <target state="translated">该数据库的写前日志(WAL)文件中的条目数。</target>
        </trans-unit>
        <trans-unit id="146718a82c006ef871da6bc05817a225f7435b26" translate="yes" xml:space="preserve">
          <source>The number of fields in this row.</source>
          <target state="translated">本行的字段数。</target>
        </trans-unit>
        <trans-unit id="049187119aa733be135d042e46c0767e81dbbd57" translate="yes" xml:space="preserve">
          <source>The number of freelist pages is stored as a 4-byte big-endian integer in the database header at an offset of 36 from the beginning of the file. The database header also stores the page number of the first freelist trunk page as a 4-byte big-endian integer at an offset of 32 from the beginning of the file.</source>
          <target state="translated">自由列表的页数在数据库头中以4字节的大字节整数形式存储,偏移量为36,从文件的开头开始。数据库头也将第一个自由列表主干页的页数作为一个4字节的大字节整数存储在文件开头的32个偏移量中。</target>
        </trans-unit>
        <trans-unit id="1267821fa107fc1f1ce35c73214837ec37375367" translate="yes" xml:space="preserve">
          <source>The number of keys on an interior b-tree page, K, is almost always at least 2 and is usually much more than 2. The only exception is when page 1 is an interior b-tree page. Page 1 has 100 fewer bytes of storage space available, due to the presence of the database header at the beginning of that page, and so sometimes (rarely) if page 1 is an interior b-tree page, it can end up holding just a a single key. In all other cases, K is 2 or more. The upper bound on K is as many keys as will fit on the page. Large keys on index b-trees are split up into &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; so that no single key uses more than one fourth of the available storage space on the page and hence every internal page is able to store at least 4 keys. The integer keys of table b-trees are never large enough to require overflow, so key overflow only occurs on index b-trees.</source>
          <target state="translated">内部b树页面上的键数K几乎总是至少2，并且通常远远大于2。唯一的例外是，当页面1是内部b树页面时。页面1的可用存储空间减少了100字节，这是因为该页面的开头存在数据库头，因此有时（很少）如果页面1是内部b树页面，则最终只能容纳aa单键。在所有其他情况下，K为2或更大。 K的上限是页面上适合的键数。索引b树上的大键分为&lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;溢出页面&lt;/a&gt;因此，没有一个键会占用页面上可用存储空间的四分之一以上，因此每个内部页面都能够存储至少4个键。表b树的整数键永远不会大到需要溢出的范围，因此键溢出仅发生在索引b树上。</target>
        </trans-unit>
        <trans-unit id="297412af9b640397abb6b05573031f719033bedb" translate="yes" xml:space="preserve">
          <source>The number of matchable phrases in the query.</source>
          <target state="translated">查询中可匹配的短语数量。</target>
        </trans-unit>
        <trans-unit id="96242742547a237955f6f616dd7a1536e46de1dc" translate="yes" xml:space="preserve">
          <source>The number of open read-transactions on the shared-cache drops to zero.</source>
          <target state="translated">共享缓存上开放的读交易数量降为零。</target>
        </trans-unit>
        <trans-unit id="140866849ab31e765e1dcf46dadf93357615ced1" translate="yes" xml:space="preserve">
          <source>The number of registers in a single prepared statement is fixed at compile-time. The content of all registers is cleared when a prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">单个准备好的语句中的寄存器数量在编译时是固定的。当&lt;a href=&quot;c3ref/reset&quot;&gt;重置&lt;/a&gt;或&lt;a href=&quot;c3ref/finalize&quot;&gt;结束&lt;/a&gt;准备好的语句时，将清除所有寄存器的内容。</target>
        </trans-unit>
        <trans-unit id="4967dccc017338cead0491dfe60a2adb347e1af4" translate="yes" xml:space="preserve">
          <source>The number of rows in a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; is no longer limited by &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#values&quot;&gt;VALUES子句中&lt;/a&gt;的行数不再受&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT的&lt;/a&gt;限制。</target>
        </trans-unit>
        <trans-unit id="36747c7623716448e27a5f87c9f1a06587b9fa71" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS4 table. This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">FTS4表中的行数。该值仅在查询FTS4表时可用,而非FTS3表。</target>
        </trans-unit>
        <trans-unit id="e61b9ea13ff6553c9d51a6610c8145f4cf2adbcc" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS5 table for which column $col contains at least one instance of the term.</source>
          <target state="translated">FTS5表中$col列至少包含一个术语实例的行数。</target>
        </trans-unit>
        <trans-unit id="05c84b067bb80eadabe7075383b96e16df1c5aad" translate="yes" xml:space="preserve">
          <source>The number of rows that contain at least one instance of the term.</source>
          <target state="translated">至少包含一个术语实例的行数。</target>
        </trans-unit>
        <trans-unit id="32422ea0ce2f612eaf439b2072fddd2d97242e6b" translate="yes" xml:space="preserve">
          <source>The number of system calls for filesystem operations is reduced, possibly resulting in a small performance increase.</source>
          <target state="translated">减少了系统对文件系统操作的调用次数,可能导致性能小幅提升。</target>
        </trans-unit>
        <trans-unit id="e6551507f016b4d4b5fee98e7304b5666b04c04e" translate="yes" xml:space="preserve">
          <source>The number of terms in a GROUP BY or ORDER BY clause</source>
          <target state="translated">GROUP BY或ORDER BY子句中术语的数量。</target>
        </trans-unit>
        <trans-unit id="1c91b565cbe9942030a8129bf45c560b0a7de90f" translate="yes" xml:space="preserve">
          <source>The number of terms in the SET clause of an UPDATE statement</source>
          <target state="translated">UPDATE语句的SET子句中的术语数。</target>
        </trans-unit>
        <trans-unit id="70c8732a507183c03eb179514303045a0317c738" translate="yes" xml:space="preserve">
          <source>The number of the current row's peer group within its partition - the rank of the current row without gaps. Partitions are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">当前行的对等组在其分区内的编号--当前行的等级,没有空隙。分区按照窗口定义中的ORDER BY子句定义的顺序从1开始编号。如果没有ORDER BY子句,那么所有的行都被认为是对等组,这个函数总是返回1。</target>
        </trans-unit>
        <trans-unit id="19450a48e3be402fdbd06d100d558662cd52a063" translate="yes" xml:space="preserve">
          <source>The number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise.</source>
          <target state="translated">当前分区中行的编号。按照窗口定义中的ORDER BY子句定义的顺序,从1开始给行编号,否则按照任意顺序编号。</target>
        </trans-unit>
        <trans-unit id="4dd0d77e2a923847446dbf60b3f48736890bd6ba" translate="yes" xml:space="preserve">
          <source>The number of user defined columns in the FTS table (i.e. not including the docid or the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;).</source>
          <target state="translated">FTS表中用户定义的列数（即，不包括docid或&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ec04163c2280ea8f1f3a4d1db55ac34599bd6c09" translate="yes" xml:space="preserve">
          <source>The number of values in an INSERT statement</source>
          <target state="translated">INSERT语句中的值的数量</target>
        </trans-unit>
        <trans-unit id="0c5896381d0db64fdbbf15f25aac8c07347171d8" translate="yes" xml:space="preserve">
          <source>The numbered list above notes that the data for the first page of the database file, if it exists and is not already loaded into the</source>
          <target state="translated">上面的编号列表中指出,如果数据库文件的第一页数据存在,而且还没有加载到</target>
        </trans-unit>
        <trans-unit id="57671fab77edd8c578d7c9204ffe057965cc804a" translate="yes" xml:space="preserve">
          <source>The numbers here have become meaningless. This page has been retained only as an historical artifact.</source>
          <target state="translated">这里的数字已经变得毫无意义。本页仅作为历史文物保留。</target>
        </trans-unit>
        <trans-unit id="dde5b38271f3bab6f5848df944b4001a9705e033" translate="yes" xml:space="preserve">
          <source>The numbers on the left are the CPU cycle counts for that line of code, of course.</source>
          <target state="translated">当然,左边的数字是该行代码的CPU周期数。</target>
        </trans-unit>
        <trans-unit id="a08476269382d9cd02770e2cab87ae0ab5a527b0" translate="yes" xml:space="preserve">
          <source>The object is deleted using a call to sqlite3changegroup_delete().</source>
          <target state="translated">使用调用sqlite3changegroup_delete()删除该对象。</target>
        </trans-unit>
        <trans-unit id="5ae7075075a940fc9e83c06d49e89ed478d0bf99" translate="yes" xml:space="preserve">
          <source>The one-byte flag at offset 0 indicating the b-tree page type.</source>
          <target state="translated">偏移量0的一个字节标志,表示b树的页面类型。</target>
        </trans-unit>
        <trans-unit id="8ef8e17609c1f629f28fe60dfd6c0e8997843e40" translate="yes" xml:space="preserve">
          <source>The one-byte integer at offset 7 gives the number of fragmented free bytes within the cell content area.</source>
          <target state="translated">偏移量7处的一字节整数给出了单元内容区域内碎片化的自由字节数。</target>
        </trans-unit>
        <trans-unit id="729502a2e01c1766734981063a90830e318512ca" translate="yes" xml:space="preserve">
          <source>The online backup API is &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;documented here&lt;/a&gt;. The remainder of this page contains two C language examples illustrating common uses of the API and discussions thereof. Reading these examples is no substitute for reading the API documentation!</source>
          <target state="translated">在线备份API &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;在此处记录&lt;/a&gt;。该页面的其余部分包含两个C语言示例，这些示例说明了API的常见用法及其讨论。阅读这些示例不能代替阅读API文档！</target>
        </trans-unit>
        <trans-unit id="0ca3b9f46f696e6082e6b7a829be81ef745b8e77" translate="yes" xml:space="preserve">
          <source>The only SQLite compile-time option used was &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;. The optional &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator is used for performance testing because it gives results that are more repeatable than the library-supplied malloc()/free() on Ubuntu.</source>
          <target state="translated">使用的唯一SQLite编译时选项是&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;。可选的&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;内存分配器用于性能测试，因为它提供的结果比Ubuntu上库提供的malloc（）/ free（）更具可重复性。</target>
        </trans-unit>
        <trans-unit id="89c13a55d3d11964427a1a5b2d10d0b78ec66565" translate="yes" xml:space="preserve">
          <source>The only compression algorithm supported is &lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;.</source>
          <target state="translated">支持的唯一压缩算法是&lt;a href=&quot;https://zlib.net&quot;&gt;&amp;ldquo; deflate&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecb1124fca00e2a69914563c0d3a9baa08011926" translate="yes" xml:space="preserve">
          <source>The only difference between the following two CASE expressions is that the</source>
          <target state="translated">以下两个CASE表达式的唯一区别是</target>
        </trans-unit>
        <trans-unit id="f71f4a9db1fb88c54de0203ce462454fe4edc774" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case, the results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">唯一不同的是,上面列举的公共sqlite3_XXX函数会默默地忽略任何传递一个NULL指针而不是有效的mutex句柄的调用。这个结构所定义的方法的实现不需要处理这种情况,传递NULL指针而不是有效的mutex句柄的结果是未定义的(也就是说,如果传递了一个NULL指针,提供一个segfaults的实现是可以接受的)。</target>
        </trans-unit>
        <trans-unit id="9650a6c44a89db8ce8453af489933161fa10a223" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case. The results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">唯一不同的是,上面列举的公共sqlite3_XXX函数会默默地忽略任何传递一个NULL指针而不是有效的mutex句柄的调用。该结构所定义的方法的实现不需要处理这种情况。传递NULL指针而不是有效的mutex句柄的结果是未定义的(也就是说,如果传递了一个NULL指针,提供一个segfaults的实现是可以接受的)。</target>
        </trans-unit>
        <trans-unit id="927a15e9b9c9c5a21e0cad33a99f89864994a2c1" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. The &lt;a href=&quot;https://sqlite.org/src/dir?ci=trunk&amp;amp;type=tree&quot;&gt;SQLite source tree&lt;/a&gt; contains many virtual table implementations that are suitable for copying, including:</source>
          <target state="translated">唯一真正困难的部分是步骤1。您可能想从现有的虚拟表实现开始，并对其进行修改以适合您的需求。的&lt;a href=&quot;https://sqlite.org/src/dir?ci=trunk&amp;amp;type=tree&quot;&gt;SQLite的源树&lt;/a&gt;中包含许多虚拟表实现适合于复制，包括：</target>
        </trans-unit>
        <trans-unit id="b216563d4489c23da5dd8ef7bbce7ce15447a023" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. There are several virtual table implementations in the SQLite source tree (for testing purposes). You might use one of those as a guide. Locate these test virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">唯一真正困难的部分是第1步。你可能想从一个现有的虚拟表实现开始,并根据你的需要修改它。在SQLite源代码树中有几个虚拟表的实现(用于测试目的)。你可以使用其中的一个作为指导。通过搜索 &quot;sqlite3_create_module &quot;找到这些测试虚拟表实现。</target>
        </trans-unit>
        <trans-unit id="6a54b4d13a6de9bd96883cd76ca40e5bd7dd1a4b" translate="yes" xml:space="preserve">
          <source>The only reasons for providing functions other than strftime() is for convenience and for efficiency.</source>
          <target state="translated">提供strftime()以外的函数的唯一原因是为了方便和提高效率。</target>
        </trans-unit>
        <trans-unit id="c64051b826835db581e8535aa4a8fb802f2e8d26" translate="yes" xml:space="preserve">
          <source>The only schema altering commands directly supported by SQLite are the &quot;&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;rename table&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;rename column&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;add column&lt;/a&gt;&quot; commands shown above. However, applications can make other arbitrary changes to the format of a table using a simple sequence of operations. The steps to make arbitrary changes to the schema design of some table X are as follows:</source>
          <target state="translated">SQLite直接支持的唯一模式更改命令是上面显示的&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;重命名表&lt;/a&gt; &amp;rdquo;，&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;重命名列&lt;/a&gt; &amp;rdquo;和&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;添加列&lt;/a&gt; &amp;rdquo;命令。但是，应用程序可以使用简单的操作序列对表的格式进行其他任意更改。对某些表X的架构设计进行任意更改的步骤如下：</target>
        </trans-unit>
        <trans-unit id="a93c45a553bd489c541613e587314033dbb5442e" translate="yes" xml:space="preserve">
          <source>The only significant design decision that developers need to make is whether to use -Os (optimize for size) or -O6 (optimize for speed). The -O6 setting makes binaries that run about 2% or 3% faster, but which are also 66% larger. The performance here is measured by counting CPU cycles using cachegrind. I-cache misses are not considered in the analysis. If I-cache misses are considered, builds with -O6 might not be any faster than builds with -Os.</source>
          <target state="translated">开发者需要做的唯一重要的设计决策是使用-Os(优化大小)还是-O6(优化速度)。-O6的设置使得二进制文件的运行速度提高了大约2%或3%,但其体积也大了66%。这里的性能是通过使用cachegrind计算CPU周期来衡量的。在分析中不考虑I-cache misses。如果考虑到 I-cache 遗漏,使用 -O6 的构建可能不会比使用 -Os 的构建更快。</target>
        </trans-unit>
        <trans-unit id="67fcf151555c1f1738044349d853d4cc0820a67f" translate="yes" xml:space="preserve">
          <source>The only thing that is really new about the current example is the WHERE clause which is implemented by instructions at addresses 7 through 10. Instructions at address 7 and 8 push onto the stack the value of the &quot;one&quot; column from the table and the literal string &quot;H%&quot;. The &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; instruction at address 9 pops these two values from the stack and pushes the result of the LIKE() function back onto the stack. The &lt;a href=&quot;opcode#IfNot&quot;&gt;IfNot&lt;/a&gt; instruction pops the top stack value and causes an immediate jump forward to the Next instruction if the top value was false (&lt;em&gt;not&lt;/em&gt; not like the literal string &quot;H%&quot;). Taking this jump effectively skips the callback, which is the whole point of the WHERE clause. If the result of the comparison is true, the jump is not taken and control falls through to the Callback instruction below.</source>
          <target state="translated">当前示例中唯一真正新颖的是WHERE子句，该子句由地址7到10的指令实现。地址7和8的指令将表和文字中的&amp;ldquo; one&amp;rdquo;列的值压入堆栈字符串&amp;ldquo; H％&amp;rdquo;。地址9处的&lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;指令从堆栈中弹出这两个值，并将LIKE（）函数的结果推回堆栈中。在&lt;a href=&quot;opcode#IfNot&quot;&gt;如不方便&lt;/a&gt;指令弹出堆栈顶部的值，并导致立即跳跃式前进到下一条指令，如果顶部的值是假的（&lt;em&gt;不&lt;/em&gt;不像文字字符串&amp;ldquo; H％&amp;rdquo;）。有效地执行此跳转将跳过回调，这是WHERE子句的重点。如果比较结果为true，则不执行跳转，控制权落到下面的Callback指令中。</target>
        </trans-unit>
        <trans-unit id="7db0a106b3cc6051a669fd3768b87982a2f1bf0d" translate="yes" xml:space="preserve">
          <source>The only time this would ever be an issue is when you have a program using version 2.8.0 or later that crashes with an incomplete transaction, then you try to examine the database using version 2.7.6 or earlier. The 2.7.6 code will not be able to read the journal file and thus will not be able to rollback the incomplete transaction to restore the database.</source>
          <target state="translated">只有当你有一个使用2.8.0或更高版本的程序因不完整的事务而崩溃,然后你尝试使用2.7.6或更早的版本检查数据库时,才会出现这种情况。2.7.6版本的代码将无法读取日志文件,因此将无法回滚不完整事务来恢复数据库。</target>
        </trans-unit>
        <trans-unit id="3427e2677eb5693de36c8d23ded03f405a1417be" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that the left-most columns of an index have many duplicate is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. But skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="translated">SQLite知道索引的最左列有很多重复项的唯一方法是，是否已经在数据库上运行了&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令。没有ANALYZE的结果，SQLite必须猜测表中数据的&amp;ldquo;形状&amp;rdquo;，默认猜测是索引最左列中的每个值平均有10个重复项。但是，当重复项的数量大约为18或更多时，跳过扫描只会变得有利可图（它只会比全表扫描更快）。因此，从未对尚未分析的数据库使用跳过扫描。</target>
        </trans-unit>
        <trans-unit id="245c56bccd061276354c331751cdfed36f0c96cc" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that there are many duplicates in the left-most columns of an index is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. Skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="translated">SQLite知道索引最左列中有很多重复项的唯一方法是，是否已经在数据库上运行了&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令。没有ANALYZE的结果，SQLite必须猜测表中数据的&amp;ldquo;形状&amp;rdquo;，默认猜测是索引最左边一列中的每个值平均有10个重复项。当重复项的数量大约为18或更多时，跳过扫描只会变得有利可图（它只会比全表扫描更快）。因此，从未对尚未进行分析的数据库使用跳过扫描。</target>
        </trans-unit>
        <trans-unit id="4470bf44a4ab413995e0a4a3db8d3df4a465f540" translate="yes" xml:space="preserve">
          <source>The opening and/or creating of the database file is deferred until the file is actually needed. This allows options and parameters, such as the native text representation and default page size, to be set using PRAGMA statements.</source>
          <target state="translated">数据库文件的打开和/或创建被推迟到实际需要该文件的时候。这允许使用PRAGMA语句设置选项和参数,如本地文本表示和默认页面大小。</target>
        </trans-unit>
        <trans-unit id="0fff8fde33861bc909ec1bcff7cb77c490217d5b" translate="yes" xml:space="preserve">
          <source>The operating system interface layer understands and tracks all five locking states described above. The pager module only tracks four of the five locking states. A PENDING lock is always just a temporary stepping stone on the path to an EXCLUSIVE lock and so the pager module does not track PENDING locks.</source>
          <target state="translated">操作系统接口层了解并跟踪上述所有五种锁定状态。寻呼机模块只跟踪五种锁定状态中的四种。待定锁永远只是通往专属锁的临时垫脚石,所以寻呼机模块不跟踪待定锁。</target>
        </trans-unit>
        <trans-unit id="6f69f5f3efa82abf10e6a8b25aaa02ea47607f29" translate="yes" xml:space="preserve">
          <source>The operating system must have a unified buffer cache in order for the memory-mapped I/O extension to work correctly, especially in situations where two processes are accessing the same database file and one process is using memory-mapped I/O while the other is not. Not all operating systems have a unified buffer cache. In some operating systems that claim to have a unified buffer cache, the implementation is buggy and can lead to corrupt databases.</source>
          <target state="translated">操作系统必须有统一的缓冲区缓存,内存映射的I/O扩展才能正常工作,特别是在两个进程访问同一个数据库文件,一个进程使用内存映射的I/O而另一个进程不使用的情况下。并非所有的操作系统都有统一的缓冲区缓存。在一些宣称有统一缓冲区缓存的操作系统中,其实现是有bug的,可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="2fef3a1777aac58cd8a21d6d8b1475aa38c4964a" translate="yes" xml:space="preserve">
          <source>The operations above can potentially cause vast changes the raw database file, and hence cause very different SHA1 hashes at the file level. But since the content represented in the database file is unchanged by these operations, the hash computed by dbhash is also unchanged.</source>
          <target state="translated">上面的操作有可能会导致原始数据库文件发生巨大的变化,从而在文件级造成截然不同的SHA1哈希。但由于数据库文件中所表示的内容在这些操作中是不变的,所以dbhash计算出的哈希值也是不变的。</target>
        </trans-unit>
        <trans-unit id="fa365bc2db1bf185a92f2d5ef6ff8250e55de644" translate="yes" xml:space="preserve">
          <source>The optimization that uses an index to quickly compute an aggregate min() or max() is extended to work with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">使用索引来快速计算聚合min（）或max（）的优化已扩展为可&lt;a href=&quot;expridx&quot;&gt;用于表达式的索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0ff09fb1c0cc730867c7410dca6d8522dc6581b" translate="yes" xml:space="preserve">
          <source>The optimizer automatically inverts terms of the form &quot;expr OP column&quot; and makes other simplifications to the WHERE clause in an attempt to get as many WHERE clause terms into the form shown above as possible. The aConstraint[] array only reports WHERE clause terms that are relevant to the particular virtual table being queried.</source>
          <target state="translated">优化器会自动反转 &quot;expr OP列 &quot;形式的术语,并对WHERE子句进行其他简化,试图让尽可能多的WHERE子句进入上图所示的形式。aConstraint[]数组只报告与被查询的特定虚拟表相关的WHERE子句。</target>
        </trans-unit>
        <trans-unit id="3a8fb11a2c37159ec0832c94b1217f4e3525fc9f" translate="yes" xml:space="preserve">
          <source>The optimizer has more freedom to reorder tables in the FROM clause even in there are LEFT joins.</source>
          <target state="translated">优化器有更多的自由度来重新排列FROM子句中的表,即使在有LEFT连接的情况下。</target>
        </trans-unit>
        <trans-unit id="ed82314b13b2ea2beac78e23a61e927cbc2a784b" translate="yes" xml:space="preserve">
          <source>The optimizer will now scan tables in the reverse if doing so will satisfy an ORDER BY ... DESC clause.</source>
          <target state="translated">优化器现在会反向扫描表,如果这样做会满足ORDER BY ...DESC子句。</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">该选项</target>
        </trans-unit>
        <trans-unit id="a17a0a84a2d535101cac8aa7214d0ca78303a13a" translate="yes" xml:space="preserve">
          <source>The option causes SQLite to omit its built-in operating system interfaces for Unix, Windows, and OS/2. The resulting library will have no default &lt;a href=&quot;c3ref/vfs&quot;&gt;operating system interface&lt;/a&gt;. Applications must use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to register an appropriate interface before using SQLite. Applications must also supply implementations for the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt; interfaces. The usual practice is for the supplied &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; to invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. SQLite will automatically invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; when it initializes.</source>
          <target state="translated">该选项使SQLite省略其针对Unix，Windows和OS / 2的内置操作系统接口。生成的库将没有默认的&lt;a href=&quot;c3ref/vfs&quot;&gt;操作系统接口&lt;/a&gt;。在使用SQLite之前，应用程序必须使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;注册适当的接口。应用程序还必须提供&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;和&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end（）&lt;/a&gt;接口的实现。通常的做法是让提供的&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;调用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;。 SQLite 初始化时将自动调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">可选的</target>
        </trans-unit>
        <trans-unit id="e154860c714282a196150a8b230c6746d885f55b" translate="yes" xml:space="preserve">
          <source>The optional &quot;</source>
          <target state="translated">可选的&quot;</target>
        </trans-unit>
        <trans-unit id="44528aeaa99ba557a8ba7b80ef11d6c589ba4953" translate="yes" xml:space="preserve">
          <source>The optional &quot;AS alias&quot; phrase provides an alternative name for the table into which content is being inserted. The alias name can be used within WHERE and SET clauses of the &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;. If there is no &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;, then the alias is pointless, but also harmless.</source>
          <target state="translated">可选的&amp;ldquo; AS别名&amp;rdquo;短语为插入内容的表提供了备用名称。别名可以在&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT的&lt;/a&gt; WHERE和SET子句中使用。如果没有&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert子句&lt;/a&gt;，则别名是没有意义的，而且也是无害的。</target>
        </trans-unit>
        <trans-unit id="af3a99778493ef21555e9c9fa86a7e91b06e70d3" translate="yes" xml:space="preserve">
          <source>The optional &quot;OR</source>
          <target state="translated">可选的 &quot;OR</target>
        </trans-unit>
        <trans-unit id="20d5db3386f7bebafe75fa5cbd335d930edd4888" translate="yes" xml:space="preserve">
          <source>The optional EXCLUDE clause may take any of the following four forms:</source>
          <target state="translated">可选的排除条款可以采取以下四种形式中的任何一种:</target>
        </trans-unit>
        <trans-unit id="f5dad0eb12cbe81d01819ac36d3268610ba8edac" translate="yes" xml:space="preserve">
          <source>The optional IF EXISTS clause suppresses the error that would normally result if the table does not exist.</source>
          <target state="translated">可选的IF EXISTS子句抑制了表不存在时通常会产生的错误。</target>
        </trans-unit>
        <trans-unit id="5cb5d652a77ff38b54b62cd30fd9ed282bedd94d" translate="yes" xml:space="preserve">
          <source>The optional MASK argument is a bitmask of optimizations to perform:</source>
          <target state="translated">可选的 MASK 参数是要执行的优化的位掩码。</target>
        </trans-unit>
        <trans-unit id="6a52a350b8227e3f2c9ade5a4eb34242d4d7eced" translate="yes" xml:space="preserve">
          <source>The optional argument is the name of the schema or database to be serialized. The default value is &quot;main&quot;.</source>
          <target state="translated">可选参数是要序列化的模式或数据库的名称。默认值是 &quot;main&quot;。</target>
        </trans-unit>
        <trans-unit id="38da3cf28a52f4f6d620faa6e6cb2361f1cf4901" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two basic forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">出现在CASE关键字和第一个WHEN关键字之间的可选表达式称为 &quot;基础 &quot;表达式。CASE表达式有两种基本形式:有基础表达式的和没有基础表达式的。</target>
        </trans-unit>
        <trans-unit id="4916a24a4905c950af19989b67424175234963da" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two fundamental forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">出现在CASE关键字和第一个WHEN关键字之间的可选表达式称为 &quot;基础 &quot;表达式。CASE表达式有两种基本形式:有基础表达式的和没有基础表达式的。</target>
        </trans-unit>
        <trans-unit id="b46109c9ae9c950c43fe7007d16547e58baf09ab" translate="yes" xml:space="preserve">
          <source>The optional shared cache and memory management features that were introduced in version 3.3.0 can now be used across multiple threads within the same process. Formerly, these extensions only applied to database connections operating within a single thread.</source>
          <target state="translated">在3.3.0版本中引入的可选共享缓存和内存管理功能现在可以在同一进程中的多个线程中使用。以前,这些扩展只适用于在单个线程内运行的数据库连接。</target>
        </trans-unit>
        <trans-unit id="095e758e6c75bd1010500f9c5cbf1c0112ebeaf1" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments.</source>
          <target state="translated">函数参数的评估顺序。</target>
        </trans-unit>
        <trans-unit id="671d3f63e428cbeb09358473179412be4940924b" translate="yes" xml:space="preserve">
          <source>The order of keys in an index b-tree is determined by the sort order of the records that the keys represent. Record comparison progresses column by column. Columns of a record are examined from left to right. The first pair of columns that are not equal determines the relative order of the two records. The sort order of individual columns is as follows:</source>
          <target state="translated">索引b树中键的顺序是由键所代表的记录的排序顺序决定的。记录比较是逐列进行的。记录的列从左到右进行检查。第一对不相等的列决定了两条记录的相对顺序。各列的排序顺序如下。</target>
        </trans-unit>
        <trans-unit id="2b489797ae43740676c30370f9b2ea776aa65877" translate="yes" xml:space="preserve">
          <source>The order of tables in a join is adjusted automatically to make better use of indices</source>
          <target state="translated">自动调整连接中表的顺序,以便更好地利用索引。</target>
        </trans-unit>
        <trans-unit id="140f29de259bdc1e34708f12946df0112e292cdd" translate="yes" xml:space="preserve">
          <source>The order of the buffer pointer and buffer size parameters in the built-in snprintf() implementation is reversed from the order used in standard-library implementations.</source>
          <target state="translated">在内置的snprintf()实现中,缓冲区指针和缓冲区大小参数的顺序与标准库实现中使用的顺序是相反的。</target>
        </trans-unit>
        <trans-unit id="5e9268cc64b3aabab9ece14a89f94084ddd4b3cc" translate="yes" xml:space="preserve">
          <source>The order of the columns in the data_% table does not matter.</source>
          <target state="translated">data_%表中各列的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="b1b615b19c9501777b15d4388be1e80320f4db76" translate="yes" xml:space="preserve">
          <source>The order of the entries indicates the nesting order. In this case, the scan of table t1 using index i2 is the outer loop (since it appears first) and the full-table scan of table t2 is the inner loop (since it appears last). In the following example, the positions of t1 and t2 in the FROM clause of the SELECT are reversed. The query strategy remains the same. The output from EXPLAIN QUERY PLAN shows how the query is actually evaluated, not how it is specified in the SQL statement.</source>
          <target state="translated">条目的顺序表示嵌套顺序。在本例中,使用索引i2对表t1的扫描是外循环(因为它最先出现),对表t2的全表扫描是内循环(因为它最后出现)。在下面的例子中,SELECT的FROM子句中t1和t2的位置是相反的。查询策略保持不变。EXPLAIN QUERY PLAN的输出显示的是查询的实际评估方式,而不是SQL语句中指定的方式。</target>
        </trans-unit>
        <trans-unit id="70ac1e5ab36762649806ee198f0345318ef8e4bd" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumed意味着&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext的&lt;/a&gt;输出将以正确的顺序出现，以满足ORDER BY子句，因此不需要单独的排序步骤。</target>
        </trans-unit>
        <trans-unit id="a4ee366293d58487c3c181ee97d4fddeec053e83" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumed意味着&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;vtab#xnext&quot;&gt;xNext的&lt;/a&gt;输出将以正确的顺序出现，以满足ORDER BY子句，因此不需要单独的排序步骤。</target>
        </trans-unit>
        <trans-unit id="361a689885e1ba1224dc1550da95ae3bd8151f01" translate="yes" xml:space="preserve">
          <source>The original UTF8 text of the vocabulary word</source>
          <target state="translated">词汇的UTF8原文。</target>
        </trans-unit>
        <trans-unit id="8f218b03066661856e3cf8a761cc5ae4bbd68ed0" translate="yes" xml:space="preserve">
          <source>The original document we put here was more of a &lt;a href=&quot;codeofethics&quot;&gt;Code of Ethics of the Project Founder&lt;/a&gt;. While we stand by those principles, they are not in line with the modern technical meaning of a Code of Conduct and have hence been renamed.</source>
          <target state="translated">我们放在这里的原始文档更多地是&lt;a href=&quot;codeofethics&quot;&gt;Project Founder的道德守则&lt;/a&gt;。尽管我们坚持这些原则，但它们不符合《行为准则》的现代技术含义，因此已被重命名。</target>
        </trans-unit>
        <trans-unit id="c32bb1620d101b8c498092185971e74a9cc27eb4" translate="yes" xml:space="preserve">
          <source>The original implementation of SQLite sought to follow &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel's Law&lt;/a&gt; which states in part &quot;Be liberal in what you accept&quot;. This used to be considered good design - that a system would accept dodgy inputs and try to do the best it could without complaining too much. But lately, people have come to realize that it is sometimes better to be strict in what you accept, so as to more easily find errors in the input.</source>
          <target state="translated">SQLite的原始实现试图遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel法则&lt;/a&gt;，该法则部分规定&amp;ldquo;在所接受的内容中保持自由&amp;rdquo;。过去，这被认为是好的设计-系统可以接受狡猾的输入，并尽其所能地做到最好，而不会抱怨太多。但是最近，人们开始意识到有时最好严格接受您所接受的内容，以便更轻松地发现输入中的错误。</target>
        </trans-unit>
        <trans-unit id="faed9cec852456e57ebf990afb4cf1cac2f27e57" translate="yes" xml:space="preserve">
          <source>The original values for each modified field of the row.</source>
          <target state="translated">该行各修改字段的原始值。</target>
        </trans-unit>
        <trans-unit id="2a41f1df0018eecb7b908d40c9986e3b87989e32" translate="yes" xml:space="preserve">
          <source>The original values of any modified fields are omitted from UPDATE records.</source>
          <target state="translated">任何修改后的字段的原始值都会从UPDATE记录中省略。</target>
        </trans-unit>
        <trans-unit id="f1449473437f390f79738378e7abd93ce9be7fe0" translate="yes" xml:space="preserve">
          <source>The other advantage to using SQLite in place of ZIP is that the document can now be updated incrementally, without risk of corrupting the document if a power loss or other crash occurs in the middle of the update. (Remember that writes to &lt;a href=&quot;atomiccommit&quot;&gt;SQLite databases are atomic&lt;/a&gt;.) True, all the content is still kept in a single big XML file (&quot;content.xml&quot;) which must be completely rewritten if so much as a single character changes. But with SQLite, only that one file needs to change. The other 77 files in the repository can remain unaltered. They do not all have to be rewritten, which in turn makes &quot;File/Save&quot; run much faster and saves wear on SSDs.</source>
          <target state="translated">使用SQLite代替ZIP的另一个优点是，现在可以增量更新文档，而如果在更新过程中发生断电或其他崩溃，则不会损坏文档。 （请记住，写入&lt;a href=&quot;atomiccommit&quot;&gt;SQLite数据库是原子的&lt;/a&gt;。）确实，所有内容仍然保存在一个大的XML文件（&amp;ldquo; content.xml&amp;rdquo;）中，如果单个字符发生很大变化，则必须将其完全重写。但是，使用SQLite，只需更改一个文件即可。存储库中的其他77个文件可以保持不变。不必全部重写它们，从而使&amp;ldquo;文件/保存&amp;rdquo;运行得更快，并节省了SSD的磨损。</target>
        </trans-unit>
        <trans-unit id="ff8ed48a831b734ff6e1604276150ac99b9ac0e1" translate="yes" xml:space="preserve">
          <source>The other allowed parameters to sqlite3_mutex_alloc() (anything other than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return a pointer to a static preexisting mutex. Nine static mutexes are used by the current version of SQLite. Future versions of SQLite may add additional static mutexes. Static mutexes are for internal use by SQLite only. Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE.</source>
          <target state="translated">sqlite3_mutex_alloc()的其他允许参数(除了SQLITE_MUTEX_FAST和SQLITE_MUTEX_RECURSIVE以外的任何参数),每个参数都返回一个指向静态预存在的mutex的指针。当前版本的SQLite使用了九个静态互斥。未来版本的SQLite可能会添加更多的静态互斥。静态mutexes只供SQLite内部使用。使用SQLite mutexes的应用程序应该只使用由SQLITE_MUTEX_FAST或SQLITE_MUTEX_RECURSIVE返回的动态mutexes。</target>
        </trans-unit>
        <trans-unit id="e68942fbbde7b9568017891360f3a9246030e2a2" translate="yes" xml:space="preserve">
          <source>The other file, &quot;fts5.h&quot;, is not required to compile the FTS5 extension. It is used by applications that implement &lt;a href=&quot;fts5#extending_fts5&quot;&gt;custom FTS5 tokenizers or auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">不需要另一个文件&amp;ldquo; fts5.h&amp;rdquo;来编译FTS5扩展名。由实现&lt;a href=&quot;fts5#extending_fts5&quot;&gt;自定义FTS5标记程序或辅助功能&lt;/a&gt;的应用程序使用。</target>
        </trans-unit>
        <trans-unit id="f74c4fa3b3502ec3d363778205dc40519edfac8e" translate="yes" xml:space="preserve">
          <source>The other information required to create a changeset or patchset is read from the database file when &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called. Specifically,</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;调用sqlite3session_changeset（）&lt;/a&gt;或&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;时，将从数据库文件中读取创建变更集或补丁集所需的其他信息。特别，</target>
        </trans-unit>
        <trans-unit id="4ceb7a7a69cfd1205ea5e7612f272fc9e42d8423" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 11 through 25. In particular, the WHERE clause containing the IN operator is implemented by instructions at 16, 17, and 20. Instruction 16 pushes the value of the &quot;two&quot; column for the current row onto the stack and instruction 17 checks to see that it is non-NULL. If this is successful, execution jumps to 20, where it tests to see if top of the stack matches any key in the temporary table. The rest of the code is the same as what has been shown before.</source>
          <target state="translated">外层的SELECT是由指令11到25实现的。特别是包含IN操作符的WHERE子句由指令16、17和20实现。指令16将当前行的 &quot;二 &quot;列的值推到堆栈上,指令17检查它是否为非NULL。如果成功,执行跳转到20,在这里测试栈顶是否与临时表中的任何键相匹配。其余的代码与前面所展示的相同。</target>
        </trans-unit>
        <trans-unit id="636166e4ba0668356d630c0a9cb37eba4fcc8c00" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 14 through 25. In particular, the WHERE clause that contains the nested select is implemented by instructions 19 through 21. You can see that the result of the inner select is loaded onto the stack by instruction 20 and used by the conditional jump at 21.</source>
          <target state="translated">外层的select由指令14到25实现。特别是包含嵌套选择的WHERE子句由指令19到21实现。可以看到,内层选择的结果由指令20加载到堆栈中,并由21处的条件跳转使用。</target>
        </trans-unit>
        <trans-unit id="fcdaf6e60b18b913fe64114ea32692d007183ab8" translate="yes" xml:space="preserve">
          <source>The outer loop over table examp is implement by instructions 7 through 23. The inner loop is instructions 13 through 22. Notice that the &quot;two&amp;lt;50&quot; term of the WHERE expression involves only columns from the first table and can be factored out of the inner loop. SQLite does this and implements the &quot;two&amp;lt;50&quot; test in instructions 10 through 12. The &quot;four==two&quot; test is implement by instructions 14 through 16 in the inner loop.</source>
          <target state="translated">表examp的外部循环由指令7至23实现。内部循环由13至22指令实现。请注意，WHERE表达式的&amp;ldquo; two &amp;lt;50&amp;rdquo;术语仅涉及第一张表中的列，并且可以从内循环。SQLite这样做并在指令10到12中实现&amp;ldquo; two &amp;lt;50&amp;rdquo;测试。&amp;ldquo; four == two&amp;rdquo;测试由内部循环中的指令14到16实现。</target>
        </trans-unit>
        <trans-unit id="0e7b99d6dfc2b5d85e34f55e3ea4da579b189034" translate="yes" xml:space="preserve">
          <source>The output begins with a report of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (cross-checked again &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;) for the SQLite under test and the compile-time options used as reported by &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt;. The output concludes with a summary of the test results and a repeat of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;. If any errors are detected, additional lines detail the problem. The error reporting lines always begin with a single space character so that they can be quickly extracted from large output files using:</source>
          <target state="translated">输出以针对测试中的SQLite 的&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;报告（再次交叉检查&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt;）和&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt;报告的编译时选项开始。输出以测试结果的摘要和&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;的重复结尾。如果检测到任何错误，则其他行会详细说明问题。错误报告行始终以单个空格字符开头，以便可以使用以下命令从大型输出文件中快速提取它们：</target>
        </trans-unit>
        <trans-unit id="b2295d00e027ddb605dbb2cc9b7646825272b788" translate="yes" xml:space="preserve">
          <source>The output from EXPLAIN and EXPLAIN QUERY PLAN is intended for interactive analysis and troubleshooting only. The details of the output format are subject to change from one release of SQLite to the next. Applications should not use EXPLAIN or EXPLAIN QUERY PLAN since their exact behavior is variable and only partially documented.</source>
          <target state="translated">EXPLAIN 和 EXPLAIN QUERY PLAN 的输出仅用于交互式分析和故障排除。输出格式的细节会随着SQLite的不同版本而改变。应用程序不应该使用EXPLAIN或EXPLAIN QUERY PLAN,因为它们的确切行为是可变的,而且只有部分记录。</target>
        </trans-unit>
        <trans-unit id="235163a8fba9aa1445cd051f01c741ea66911c96" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; script shows the number of CPU cycles spent on each line of code. The report is approximately 80,000 lines long. The following is a brief snippet taken from the middle of the report to show what it looks like:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt;脚本的输出显示每行代码花费的CPU周期数。该报告大约有80,000行。以下是摘自报告中间的简短摘要，以显示其外观：</target>
        </trans-unit>
        <trans-unit id="4c55fd24704ccac9a200bb25fe01e36a7bd6347b" translate="yes" xml:space="preserve">
          <source>The output from the mkth3.tcl script is a C program that contains everything needed to run the tests - everything that is except for the SQLite library itself. The generated test program contains implementations for all of the support interfaces used by the test modules and it contains the &lt;code&gt;main()&lt;/code&gt; routine that drives the tests. To convert the test program into a working executable, simply compile it against SQLite:</source>
          <target state="translated">mkth3.tcl脚本的输出是一个C程序，其中包含运行测试所需的所有内容-除SQLite库本身以外的所有内容。生成的测试程序包含测试模块使用的所有支持接口的实现，并且包含驱动测试的 &lt;code&gt;main()&lt;/code&gt; 例程。要将测试程序转换为可运行的可执行文件，只需针对SQLite对其进行编译：</target>
        </trans-unit>
        <trans-unit id="abe6a29295e5add598505fe98eb212b9e3e6e910" translate="yes" xml:space="preserve">
          <source>The output is a human-readable ASCII text report that provides information on the space utilization of the database file. The report is intended to be self-explanatory, though there is some &lt;a href=&quot;sqlanalyze#defs&quot;&gt;additional explanation&lt;/a&gt; of the various parameters reported toward the end of the report.</source>
          <target state="translated">输出是人类可读的ASCII文本报告，该报告提供有关数据库文件空间利用率的信息。尽管对报告末尾所报告的各种参数还有一些&lt;a href=&quot;sqlanalyze#defs&quot;&gt;其他&lt;/a&gt;解释，但该报告的目的不言而喻。</target>
        </trans-unit>
        <trans-unit id="89607a5138078e5c86fca97ee25682b106679c11" translate="yes" xml:space="preserve">
          <source>The output is also valid SQL. Most of the report text is contained within a header comment, with various SQL statements that create and initialize a database at the &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;end of the report&lt;/a&gt;. The constructed database contains the raw data from which the report was extracted. Hence the original report can be read into an instance of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and then the raw data can be queried to dig deeper into the space utilization of a particular database file.</source>
          <target state="translated">输出也是有效的SQL。报告的大部分文本都包含在标题注释中，&lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;在报告末尾&lt;/a&gt;带有各种SQL语句，这些语句创建和初始化数据库。构建的数据库包含从中提取报告的原始数据。因此，可以将原始报告读入&lt;a href=&quot;cli&quot;&gt;命令行Shell&lt;/a&gt;的实例，然后可以查询原始数据以更深入地了解特定数据库文件的空间利用率。</target>
        </trans-unit>
        <trans-unit id="bcfd95781cb98e2851bb0886cd3f1a588c682428" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; now shows each individual SQL statement run within a trigger.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;的输出现在显示在触发器中运行的每个单独的SQL语句。</target>
        </trans-unit>
        <trans-unit id="2d09f331aa1d428bbd3337e80bd418ed5659e816" translate="yes" xml:space="preserve">
          <source>The output of this revised query is:</source>
          <target state="translated">这个修订后的查询结果是:</target>
        </trans-unit>
        <trans-unit id="e3541aa5b140ee88f1e6bb5e89e08e8618d880af" translate="yes" xml:space="preserve">
          <source>The outputs s0 and s1 are both weighted checksums using Fibonacci weights in reverse order. (The largest Fibonacci weight occurs on the first element of the sequence being summed.) The s1 value spans all 32-bit integer terms of the sequence whereas s0 omits the final term.</source>
          <target state="translated">输出s0和s1都是使用斐波那契权重的加权校验和,顺序相反。(最大的斐波那契权重出现在被求和的序列的第一个元素上。)s1的值涵盖了序列的所有32位整数项,而s0则省略了最后一项。s1的值涵盖了序列的所有32位整数项,而s0则省略了最后一项。</target>
        </trans-unit>
        <trans-unit id="2d1abc65d901f9a5d25ea3d57ab5dd49e8f85287" translate="yes" xml:space="preserve">
          <source>The overflow thresholds are designed to give a minimum fanout of 4 for index b-trees and to make sure enough of the payload is on the b-tree page that the record header can usually be accessed without consulting an overflow page. In hindsight, the designer of the SQLite b-tree logic realized that these thresholds could have been made much simpler. However, the computations cannot be changed without resulting in an incompatible file format. And the current computations work well, even if they are a little complex.</source>
          <target state="translated">溢出阈值的设计是为了给索引b树提供最小的扇出量为4,并确保b树页面上有足够多的有效载荷,通常不需要咨询溢出页面就可以访问记录头。事后,SQLite b-tree逻辑的设计者意识到,这些阈值可以做得更简单。但是,如果不改变计算方式,就不能导致文件格式不兼容。而目前的计算结果很好用,即使它们有点复杂。</target>
        </trans-unit>
        <trans-unit id="ac70d959175f460608260178c8989bd26b78e65e" translate="yes" xml:space="preserve">
          <source>The pAppData pointer is unused by the SQLite core. The pointer is available to store auxiliary information that a VFS information might want to carry around.</source>
          <target state="translated">pAppData指针不被SQLite核心使用。该指针可用于存储VFS信息可能想要携带的辅助信息。</target>
        </trans-unit>
        <trans-unit id="18730b00ae23b4c106f1118f96d5a509058fa368" translate="yes" xml:space="preserve">
          <source>The pBuf parameter is a pointer to a contiguous range of bytes that SQLite will use for page-cache memory allocations. The buffer must be at least sz*N bytes in size. The &quot;sz&quot; parameter is the size of each page-cache allocation. N is the maximum number of available allocations.</source>
          <target state="translated">pBuf参数是指向SQLite将用于页缓存内存分配的连续字节范围的指针。缓冲区的大小必须至少是sz*N字节。&quot;sz &quot;参数是每个页缓存分配的大小。N是可用分配的最大数量。</target>
        </trans-unit>
        <trans-unit id="ac154834d9f47915a3416a80860f0b58cefd5585" translate="yes" xml:space="preserve">
          <source>The pContext member of the sqlite3_rtree_geometry structure is always set to a copy of the pContext argument passed to sqlite3_rtree_geometry_callback() when the callback is registered. The aParam[] array (size nParam) contains the parameter values passed to the SQL function on the right-hand side of the MATCH operator. In the example &quot;circle&quot; query above, nParam would be set to 3 and the aParam[] array would contain the three values 45.3, 22.9 and 5.0.</source>
          <target state="translated">sqlite3_rtree_geometry结构的pContext成员总是被设置为回调注册时传递给sqlite3_rtree_geometry_callback()的pContext参数的副本。aParam[]数组(大小为nParam)包含了传递给MATCH操作符右侧SQL函数的参数值。在上面的 &quot;圆 &quot;查询示例中,nParam将被设置为3,而aParam[]数组将包含三个值45.3、22.9和5.0。</target>
        </trans-unit>
        <trans-unit id="e127dc3dcbbc20bee3b0cdc450a4bea7c1e6776f" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。如果不是这种情况，则此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="135aebf5a9dd2b851dadacfebf43a14b9409aa81" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="47ae6763d58288a12e6ca470cf923677f0731f46" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="5f4815a3e637ae9700d2b5b8cf01f7df97a164dc" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。如果不是这种情况，则此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cb49779aa9657ac4af96a2c62fd60bce7011cad" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="836812d109e0eaaadd1e45a40c1311bde5cb7d98" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;或&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="87ffccb080e4ff9265c31827b97ddd2621e463bc" translate="yes" xml:space="preserve">
          <source>The pNext field is the only field in the sqlite3_vfs structure that SQLite will ever modify. SQLite will only access or modify this field while holding a particular static mutex. The application should never modify anything within the sqlite3_vfs object once the object has been registered.</source>
          <target state="translated">pNext字段是sqlite3_vfs结构中唯一会被SQLite修改的字段。SQLite只有在持有一个特定的静态互斥时才会访问或修改这个字段。一旦sqlite3_vfs对象被注册,应用程序就不应该修改该对象中的任何内容。</target>
        </trans-unit>
        <trans-unit id="754388a17b97b997745df633f79a8efeaffaaacb" translate="yes" xml:space="preserve">
          <source>The pNext field is used internally by SQLite. Specifically, SQLite uses this field to form a linked list of registered VFSes.</source>
          <target state="translated">pNext字段由SQLite内部使用。具体来说,SQLite使用这个字段来形成一个注册VFSes的链接列表。</target>
        </trans-unit>
        <trans-unit id="ed269faa072ea0bc301321c2683b96864943c28b" translate="yes" xml:space="preserve">
          <source>The pUser and xDelUser members of the sqlite3_rtree_geometry structure are initially set to NULL. The pUser variable may be set by the callback implementation to any arbitrary value that may be useful to subsequent invocations of the callback within the same query (for example, a pointer to a complicated data structure used to test for region intersection). If the xDelUser variable is set to a non-NULL value, then after the query has finished running SQLite automatically invokes it with the value of the pUser variable as the only argument. In other words, xDelUser may be set to a destructor function for the pUser value.</source>
          <target state="translated">sqlite3_rtree_geometry结构的pUser和xDelUser成员最初被设置为NULL。pUser变量可以被回调实现设置为任何对同一查询中后续调用回调有用的任意值(例如,指向用于测试区域交叉的复杂数据结构的指针)。如果xDelUser变量被设置为非NULL值,那么在查询运行完毕后,SQLite会自动调用它,将pUser变量的值作为唯一的参数。换句话说,xDelUser可以被设置为pUser值的析构函数。</target>
        </trans-unit>
        <trans-unit id="17b3e72d28371d5d2ffa9ec67e0ffe035454e59f" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">页面缓存从&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;，...）提供的内存池中分配，而不是从堆中分配。</target>
        </trans-unit>
        <trans-unit id="c49923490f20015de5b3c1344ee709093d18e9ac" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">页面缓存从&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;，...）提供的内存池中分配，而不是从堆中分配。</target>
        </trans-unit>
        <trans-unit id="a302370f325aa6580998e916c1cd813d2e0b53c6" translate="yes" xml:space="preserve">
          <source>The page number in the database file</source>
          <target state="translated">数据库文件中的页码</target>
        </trans-unit>
        <trans-unit id="cb3defd1f8ac1da0588e9ad79d27848df6931c39" translate="yes" xml:space="preserve">
          <source>The page number of the database page associated with this</source>
          <target state="translated">与此相关的数据库页面的页码。</target>
        </trans-unit>
        <trans-unit id="0780190de9ffbf4345610e2662e0abd5cdf52be0" translate="yes" xml:space="preserve">
          <source>The page number of the database page for the current row</source>
          <target state="translated">当前行的数据库页面的页码。</target>
        </trans-unit>
        <trans-unit id="5d2ed89da4b6a6d4a6521b481ff6c43d5bdf9213" translate="yes" xml:space="preserve">
          <source>The page number of the largest root b-tree page when in auto-vacuum or incremental-vacuum modes, or zero otherwise.</source>
          <target state="translated">当处于自动真空或增量真空模式时,最大的b树根页的页数,否则为零。</target>
        </trans-unit>
        <trans-unit id="9a28509eee63401403c2ae3763725cac2ca99893" translate="yes" xml:space="preserve">
          <source>The page number of the page on which this row was found.</source>
          <target state="translated">该行所在页面的页码。</target>
        </trans-unit>
        <trans-unit id="41b015c66ddae0dbc3440c640484bd01738dbaf6" translate="yes" xml:space="preserve">
          <source>The page size and cache size can also be set or changed at run-time using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;, respectively.</source>
          <target state="translated">页面大小和缓存大小也可以在运行时分别使用&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;进行设置或更改。</target>
        </trans-unit>
        <trans-unit id="0105846f7fbf6f81d53292a1128d1e82d5804983" translate="yes" xml:space="preserve">
          <source>The page to be fetched is determined by the key. The minimum key value is 1. After it has been retrieved using xFetch, the page is considered to be &quot;pinned&quot;.</source>
          <target state="translated">要检索的页面由键决定。最小键值为1,使用xFetch检索后,页面被视为 &quot;钉住&quot;。</target>
        </trans-unit>
        <trans-unit id="ae6ce89a0e7b046f1218400c05d873074d2788d0" translate="yes" xml:space="preserve">
          <source>The page-cache memory allocator is disabled by default. An application can enable it at start-time as follows:</source>
          <target state="translated">页缓存内存分配器默认是禁用的,应用程序可以在启动时启用它。应用程序可以在启动时启用它,具体如下。</target>
        </trans-unit>
        <trans-unit id="79944cfbe90583fe884c628acc92c56b549b69ab" translate="yes" xml:space="preserve">
          <source>The pager and btree subsystems added back. They are now the only available backend.</source>
          <target state="translated">寻呼机和btree子系统添加回来。它们现在是唯一可用的后台。</target>
        </trans-unit>
        <trans-unit id="177ac3877a5c726efa0192a81b9a621bfc8aa28e" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="translated">寻呼机不关心B树，文本编码，索引等细节。从寻呼机的角度来看，数据库由一个统一大小的块文件组成。每个块称为&amp;ldquo;页面&amp;rdquo;，通常大小为1024字节。页面从1开始编号。因此数据库的前1024个字节称为&amp;ldquo;第1页&amp;rdquo;，后1024个字节称为&amp;ldquo;第2页&amp;rdquo;，依此类推。所有其他编码细节由库的更高层处理。寻呼机使用几个模块之一与操作系统进行通信（示例：&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;，&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt;os_win.c&lt;/a&gt;），这些模块为操作系统服务提供统一的抽象。</target>
        </trans-unit>
        <trans-unit id="82bc2a399f48d653b62ff2df3d5391e1390404ef" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="translated">寻呼机与B树，文本编码，索引等细节无关。从寻呼机的角度来看，数据库由一个大小一致的块的单个文件组成。每个块称为&amp;ldquo;页面&amp;rdquo;，通常大小为1024字节。页面从1开始编号。因此，数据库的前1024个字节称为&amp;ldquo;第1页&amp;rdquo;，后1024个字节称为&amp;ldquo;第2页&amp;rdquo;，依此类推。所有其他编码细节由库的更高层处理。传呼器使用几个模块之一与操作系统进行通信（示例：&lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;，&lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt;os_win.c&lt;/a&gt;），这些模块为操作系统服务提供统一的抽象。</target>
        </trans-unit>
        <trans-unit id="5acaa405b470e4fb9ef36344daf0f015a3d5bf69" translate="yes" xml:space="preserve">
          <source>The pager module effectively controls access for separate threads, or separate processes, or both. Throughout this document whenever the word &quot;process&quot; is written you may substitute the word &quot;thread&quot; without changing the truth of the statement.</source>
          <target state="translated">寻呼机模块有效地控制了单独的线程,或单独的进程,或两者的访问。在本文档中,每当写到 &quot;进程 &quot;一词时,你可以用 &quot;线程 &quot;来代替,而不改变声明的真实性。</target>
        </trans-unit>
        <trans-unit id="3fbaa9934c130eb17f7eada7403c9132c86bbc58" translate="yes" xml:space="preserve">
          <source>The pager module is very robust but it can be subverted. This section attempts to identify and explain the risks. (See also the &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;Things That Can Go Wrong&lt;/a&gt; section of the article on &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;.</source>
          <target state="translated">寻呼机模块非常强大，但是可以被颠覆。本节试图识别和解释风险。（另请参阅&amp;ldquo; &lt;a href=&quot;atomiccommit&quot;&gt;原子提交&lt;/a&gt; &amp;rdquo;一文中的&lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;&amp;ldquo;可能出错的&lt;/a&gt;部分&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0f15cdebe573fd03148e855390c11255190632e7" translate="yes" xml:space="preserve">
          <source>The paragraph above notes that a MATCH operator with a simple term as the right-hand operand evaluates to true for all documents that contain the specified term. In this context, the &quot;document&quot; may refer to either the data stored in a single column of a row of an FTS table, or to the contents of all columns in a single row, depending on the identifier used as the left-hand operand to the MATCH operator. If the identifier specified as the left-hand operand of the MATCH operator is an FTS table column name, then the document that the search term must be contained in is the value stored in the specified column. However, if the identifier is the name of the FTS</source>
          <target state="translated">上段指出,以一个简单术语作为右手操作数的MATCH操作符,对于所有包含指定术语的文档来说,评价为真。在此上下文中,&quot;文档 &quot;可以指存储在FTS表中一行的单列中的数据,也可以指单行中所有列的内容,这取决于用作MATCH操作符左手操作数的标识符。如果作为 MATCH 操作符的左手操作符指定的标识符是 FTS 表的列名,那么搜索词必须包含的文档就是存储在指定列中的值。但是,如果标识符是FTS表的名称,那么搜索词必须包含在指定的列中。</target>
        </trans-unit>
        <trans-unit id="15582287ef68bc76059b207ebd8e45ad35a9f199" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;../opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">参数P作为唯一参数传递给回调函数X。参数N是在回调X的连续调用之间评估的&lt;a href=&quot;../opcode&quot;&gt;虚拟机指令&lt;/a&gt;的近似数量。如果N小于1，则禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="de8aa7c163a7cfc0e81022005dde253ed27f9cea" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">参数P作为唯一参数传递给回调函数X。参数N是在回调X的连续调用之间评估的&lt;a href=&quot;opcode&quot;&gt;虚拟机指令&lt;/a&gt;的近似数量。如果N小于1，则禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="b6a1b97180e82088f349d801a8feb225d5ea8536" translate="yes" xml:space="preserve">
          <source>The parameters to the callback are the pArg value, the amount of memory currently in use, and the size of the allocation that provoked the callback. The callback will presumably invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; to free up memory space. The callback may invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; but if it does, no additional callbacks will be invoked by the recursive calls.</source>
          <target state="translated">回调的参数是pArg值，当前使用的内存量以及引起回调的分配大小。回调可能会调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放内存空间。回调可以调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（），&lt;/a&gt;但如果这样做，则递归调用将不会再调用其他回调。</target>
        </trans-unit>
        <trans-unit id="a0635b4b828516772af2e4a5c5f8f7c2b0b83854" translate="yes" xml:space="preserve">
          <source>The parent and sub-query may contain WHERE clauses. Subject to rules (11), (12) and (13), they may also contain ORDER BY, LIMIT and OFFSET clauses.</source>
          <target state="translated">母查询和子查询可以包含WHERE子句。在遵守规则(11)、(12)和(13)的前提下,它们还可以包含ORDER BY、LIMIT和OFFSET子句。</target>
        </trans-unit>
        <trans-unit id="6d5030cd0c93ffa44cd5f784ea6b109c2ce36ffc" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint are not the primary key of the parent table and are not subject to a unique constraint using collating sequence specified in the CREATE TABLE, or</source>
          <target state="translated">外键约束中命名的父键列不是父表的主键,并且不受唯一约束,使用CREATE TABLE中指定的整理序列,或</target>
        </trans-unit>
        <trans-unit id="0feae637448fae26652f631fd44b61bcd440968a" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint do not exist, or</source>
          <target state="translated">外键约束中命名的父键列不存在,或</target>
        </trans-unit>
        <trans-unit id="ba132dacfac52109e850c048192c0d768817957a" translate="yes" xml:space="preserve">
          <source>The parent table does not exist, or</source>
          <target state="translated">父表不存在,或</target>
        </trans-unit>
        <trans-unit id="cfb0e652f64b7c831f470e25c9ae00145b03ba52" translate="yes" xml:space="preserve">
          <source>The parser assigns meaning to tokens based on their context. The parser for SQLite is generated using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;. Lemon does the same job as YACC/BISON, but it uses a different input syntax which is less error-prone. Lemon also generates a parser which is reentrant and thread-safe. And Lemon defines the concept of a non-terminal destructor so that it does not leak memory when syntax errors are encountered. The grammar file that drives Lemon and that defines the SQL language that SQLite understands is found in &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;.</source>
          <target state="translated">解析器根据令牌的上下文为令牌分配含义。 SQLite的解析器是使用&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器生成的&lt;/a&gt;。 Lemon做的工作与YACC / BISON相同，但是它使用不同的输入语法，因此不容易出错。 Lemon还生成可重入且线程安全的解析器。 Lemon定义了非终端析构函数的概念，以便在遇到语法错误时不会泄漏内存。在&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y中&lt;/a&gt;可以找到驱动Lemon的语法文件，该语法文件定义了SQLite可以理解的SQL语言。</target>
        </trans-unit>
        <trans-unit id="9872a2b10d55c6bd43d5d98d5414737378783a62" translate="yes" xml:space="preserve">
          <source>The parser forwards the AST on to the code generator. The code generator is the heart of SQLite, and is where most of the magic happens. The code generator resolves symbolic names in the AST - matching the names of columns and tables in the input SQL into actual columns and tables of the database. The code generator also does various transformations on the AST to &quot;optimize&quot; it. Finally the code generator chooses appropriate algorithms to implement the operations requested by the AST and constructs bytecode to carry out those operations.</source>
          <target state="translated">解析器将AST转发到代码生成器。代码生成器是SQLite的核心,也是大部分神奇的地方。代码生成器解析AST中的符号名称--将输入SQL中的列和表的名称匹配到数据库的实际列和表中。代码生成器还会对AST进行各种转换,以 &quot;优化 &quot;它。最后,代码生成器选择适当的算法来实现AST所要求的操作,并构造字节码来执行这些操作。</target>
        </trans-unit>
        <trans-unit id="bba39e24b4502de9e348487cd65024dc8a8b4825" translate="yes" xml:space="preserve">
          <source>The parser now insists on seeing a semicolon or the end of input before executing a statement. This avoids an accidental disaster if the WHERE keyword is misspelled in an UPDATE or DELETE statement.</source>
          <target state="translated">解析器现在坚持在执行语句之前看到分号或输入的结尾。这就避免了在UPDATE或DELETE语句中,WHERE关键字拼写错误的情况下发生意外灾难。</target>
        </trans-unit>
        <trans-unit id="276468011b3fce8fd043bc0ac6f52f8e374eb1fe" translate="yes" xml:space="preserve">
          <source>The parser used by SQLite is forgiving. It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity. For example, the statement &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot; is accepted by SQLite, and creates a new table named &quot;BEGIN&quot; with three columns named &quot;REPLACE&quot;, &quot;PRAGMA&quot;, and &quot;END&quot;. Nevertheless, best practice is to avoid using keywords as identifiers. Common techniques used to avoid keyword name collisions include:</source>
          <target state="translated">SQLite使用的解析器是宽容的。只要不造成解析上的歧义,通常可以使用关键字作为标识符。例如,语句 &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot;被SQLite接受,并创建了一个名为 &quot;BEGIN &quot;的新表,其中有三列名为 &quot;REPLACE&quot;、&quot;PRAGMA &quot;和 &quot;END&quot;。尽管如此,最好的做法是避免使用关键字作为标识符。避免关键词名称碰撞的常用技术包括:。</target>
        </trans-unit>
        <trans-unit id="cf399069b7a65af0b661c7a78ceab3a98b1156db" translate="yes" xml:space="preserve">
          <source>The parser's stack was overflowing on a very long UPDATE statement. This is now fixed.</source>
          <target state="translated">在很长的UPDATE语句上,解析器的堆栈溢出。现在已经修复。</target>
        </trans-unit>
        <trans-unit id="3f01287feae0670aa81041fc77641d185841977a" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficult to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="translated">在任何SQL数据库引擎中,SQL语句的解析都是CPU周期的重要消耗。为了优化SQLite,开发人员花费了大量的时间来调整Lemon,以生成更快的解析器。这些努力使Lemon解析器生成器的所有用户受益,而不仅仅是SQLite。但是,如果Lemon是一个单独维护的工具,那么对SQLite和Lemon进行协调修改就会更加困难,结果就不会有那么多的优化。因此,事实证明,解析器生成器工具被包含在SQLite的源码树中,对工具本身和SQLite都是净收益。</target>
        </trans-unit>
        <trans-unit id="a5c83958bfdec6a8c2fd0d74498090055bde1a94" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficulty to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="translated">在任何SQL数据库引擎中,SQL语句的解析都是CPU周期的重要消耗。为了优化SQLite,开发人员花费了大量的时间来调整Lemon,以生成更快的解析器。这些努力使Lemon解析器生成器的所有用户受益,而不仅仅是SQLite。但是,如果Lemon是一个单独维护的工具,那么对SQLite和Lemon进行协调修改的难度就会更大,结果就不会有那么多的优化。因此,事实证明,解析器生成器工具被包含在SQLite的源码树中,对工具本身和SQLite都是净收益。</target>
        </trans-unit>
        <trans-unit id="7d2ca17144abc28a05044c4d5d55dce18e17a921" translate="yes" xml:space="preserve">
          <source>The part of the name prior to the last &quot;_&quot; exactly matches the name of a virtual table that was created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;. (Shadow tables are not recognized for &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.)</source>
          <target state="translated">名称中最后一个&amp;ldquo; _&amp;rdquo;之前的部分与使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;创建的虚拟表的名称完全匹配。 （&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;和&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;无法识别影子表。）</target>
        </trans-unit>
        <trans-unit id="042a9e73444095c51cd83e16473e75bf7e45a5e4" translate="yes" xml:space="preserve">
          <source>The patch level Z was historically only used for bug-fix releases that changed only a small number of code lines.</source>
          <target state="translated">补丁级别Z在历史上只用于只修改少量代码行的错误修复版本。</target>
        </trans-unit>
        <trans-unit id="274dfc20017243c18164f876bdd5c3980ade92fe" translate="yes" xml:space="preserve">
          <source>The path component of the URI specifies the disk file that is the SQLite database to be opened. If the path component is omitted, then the database is stored in a temporary file that will be automatically deleted when the database connection closes. If the authority section is present, then the path is always an absolute pathname. If the authority section is omitted, then the path is an absolute pathname if it begins with the &quot;/&quot; character (ASCII code 0x2f) and is a relative pathname otherwise. On windows, if the absolute path begins with &quot;&lt;b&gt;/&lt;i&gt;X&lt;/i&gt;:/&lt;/b&gt;&quot; where &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; is any single ASCII alphabetic character (&quot;a&quot; through &quot;z&quot; or &quot;A&quot; through &quot;Z&quot;) then the &quot;&lt;b&gt;&lt;i&gt;X:&lt;/i&gt;&lt;/b&gt;&quot; is understood to be the drive letter of the volume containing the file, not the toplevel directory.</source>
          <target state="translated">URI的路径组件指定磁盘文件，该磁盘文件是要打开的SQLite数据库。如果省略路径组件，则数据库存储在一个临时文件中，当数据库连接关闭时，该文件将自动删除。如果存在授权部分，则该路径始终是绝对路径名。如果省略了权限部分，则该路径以&amp;ldquo; /&amp;rdquo;字符（ASCII代码0x2f）开头为绝对路径名，否则为相对路径名。在Windows上，如果绝对路径以&amp;ldquo; &lt;b&gt;/ &lt;i&gt;X&lt;/i&gt;：/&lt;/b&gt; &amp;rdquo; 开头，其中&lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt;是任何单个ASCII字母字符（&amp;ldquo; a&amp;rdquo;至&amp;ldquo; z&amp;rdquo;或&amp;ldquo; A&amp;rdquo;至&amp;ldquo; Z&amp;rdquo;），则&amp;ldquo; &lt;b&gt;&lt;i&gt;X：&lt;/i&gt;&lt;/b&gt;&amp;ldquo;&amp;rdquo;被理解为是包含文件而不是顶层目录的卷的驱动器号。</target>
        </trans-unit>
        <trans-unit id="f3532ac83d22ad95431b31438dce70e426b9f355" translate="yes" xml:space="preserve">
          <source>The path is optional if the authority is present. If the authority is omitted then the path is required.</source>
          <target state="translated">如果有权限,路径是可选的。如果省略了权限,则路径为必填项。</target>
        </trans-unit>
        <trans-unit id="5dd0cabb7668cbee80844078c73a695152a285b7" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;amp;sup2) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">默认&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;和&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB中&lt;/a&gt;使用的模式匹配算法对于某些病理情况，SQLite的实现可以表现出O（N＆sup2）性能（其中N是模式中的字符数）。为了避免能够指定自己的LIKE或GLOB模式的恶意者进行的拒绝服务攻击，LIKE或GLOB模式的长度限制为SQLITE_MAX_LIKE_PATTERN_LENGTH字节。此限制的默认值为50000。现代工作站甚至可以相对快速地评估甚至是50000字节的病理LIKE或GLOB模式。仅当模式长度达到数百万个字节时，拒绝服务问题才起作用。不过，由于最有用的LIKE或GLOB模式的长度最多为几十个字节，如果他们知道外部用户能够生成任意模式，则偏执的应用程序开发人员可能希望将此参数减小到几百个范围。</target>
        </trans-unit>
        <trans-unit id="d6c16218a9785941384e3fbed5d84494c8c3a3ec" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;sup2;) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">默认&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;和&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB中&lt;/a&gt;使用的模式匹配算法对于某些病理情况，SQLite的实现可以表现出O（N&amp;sup2;）性能（其中N是模式中的字符数）。为了避免能够指定自己的LIKE或GLOB模式的恶意者进行的拒绝服务攻击，LIKE或GLOB模式的长度限制为SQLITE_MAX_LIKE_PATTERN_LENGTH字节。该限制的默认值为50000。现代工作站甚至可以相对快速地评估甚至是50000字节的病理LIKE或GLOB模式。拒绝服务问题仅在模式长度达到数百万个字节时才起作用。不过，由于最有用的LIKE或GLOB模式的长度最多为几十个字节，如果他们知道外部用户能够生成任意模式，则偏执的应用程序开发人员可能希望将此参数减小到几百个范围。</target>
        </trans-unit>
        <trans-unit id="202855d0443faeb5dfa8c360619529b04d6a4b20" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. And we record the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="translated">人员表为一个大型组织中的每个人设置了一个条目。每个人要么是 &quot;学生&quot;,要么是 &quot;老师&quot;,由 &quot;角色 &quot;字段决定。而我们记录的是每个人的身高,单位是厘米。角色和身高是有索引的。请注意,索引的最左边一列不是很有选择性--它只包含两个可能的值。</target>
        </trans-unit>
        <trans-unit id="6e5ee4166c936fcf879a132b411a3178c46f082a" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. The table also records the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="translated">人员表为一个大型组织中的每个人设置了一个条目。每个人要么是 &quot;学生&quot;,要么是 &quot;教师&quot;,由 &quot;角色 &quot;字段决定。该表还记录了每个人的身高(厘米)。角色和身高是有索引的。请注意,索引的最左边一列不是很有选择性--它只包含两个可能的值。</target>
        </trans-unit>
        <trans-unit id="92b29d0fa9a5e447b11571a63811cd4169611d21" translate="yes" xml:space="preserve">
          <source>The per-connection statistics do not use global variables and hence do not require mutexes to update or access. Consequently the per-connection statistics continue to function even if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is turned off.</source>
          <target state="translated">每个连接的统计信息不使用全局变量，因此不需要互斥来更新或访问。因此，即使关闭了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，每个连接的统计信息仍继续起作用。</target>
        </trans-unit>
        <trans-unit id="50dbff919de02c3f0e66d4c1de101521648ed2d5" translate="yes" xml:space="preserve">
          <source>The performance can be improved slightly by bypassing the SQL layer and reading the blob content directly using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface, as shown in the next chart:</source>
          <target state="translated">通过绕过SQL层并使用&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口直接读取blob内容，可以稍微提高性能，如下图所示：</target>
        </trans-unit>
        <trans-unit id="095c3d78e34e00649d5524d5d46327c65695f40f" translate="yes" xml:space="preserve">
          <source>The performance difference arises (we believe) because when working from an SQLite database, the open() and close() system calls are invoked only once, whereas open() and close() are invoked once for each blob when using blobs stored in individual files. It appears that the overhead of calling open() and close() is greater than the overhead of using the database. The size reduction arises from the fact that individual files are padded out to the next multiple of the filesystem block size, whereas the blobs are packed more tightly into an SQLite database.</source>
          <target state="translated">性能差异的产生(我们认为)是因为当从SQLite数据库工作时,open()和close()系统调用只被调用一次,而当使用存储在单个文件中的blob时,每个blob都要调用一次open()和close()。看来,调用open()和close()的开销大于使用数据库的开销。文件大小的减小是因为单个文件被填充到文件系统块大小的下一个倍数,而blob则被更紧密地打包到SQLite数据库中。</target>
        </trans-unit>
        <trans-unit id="2a5a29c317c697ba64096b7f2c68033b4565ac42" translate="yes" xml:space="preserve">
          <source>The permutation is only valid until the next &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; that has the OPFLAG_PERMUTE bit set in P5. Typically the &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; should occur immediately prior to the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">该排列仅在下一个在P5中将OPFLAG_PERMUTE位置1的&lt;a href=&quot;opcode#Compare&quot;&gt;比较&lt;/a&gt;之前有效。通常，&lt;a href=&quot;opcode#Permutation&quot;&gt;排列&lt;/a&gt;应该在&lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;之前立即进行。</target>
        </trans-unit>
        <trans-unit id="645402751e5b5ab0dd0504759786ac3f99e9f97b" translate="yes" xml:space="preserve">
          <source>The persistence of WAL mode means that applications can be converted to using SQLite in WAL mode without making any changes to the application itself. One has merely to run &quot;&lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt;&quot; on the database file(s) using the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; or other utility, then restart the application.</source>
          <target state="translated">WAL模式的持久性意味着可以在WAL模式下使用SQLite将应用程序转换为应用程序，而无需对应用程序本身进行任何更改。只需使用&lt;a href=&quot;cli&quot;&gt;命令行Shell&lt;/a&gt;或其他实用程序在数据库文件上运行&amp;ldquo; &lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt; &amp;rdquo; ，然后重新启动应用程序。</target>
        </trans-unit>
        <trans-unit id="37f0ea5f181b03035443f3a918ec838d5bf0f5c4" translate="yes" xml:space="preserve">
          <source>The phrase &quot;VALUES(</source>
          <target state="translated">这句话 &quot;VALUES(</target>
        </trans-unit>
        <trans-unit id="afda55d9895c016a5496f6b600205dbf8fbc7d06" translate="yes" xml:space="preserve">
          <source>The planner avoids query plans that use indexes with unknown collating functions.</source>
          <target state="translated">规划器避免使用具有未知整理函数的索引的查询计划。</target>
        </trans-unit>
        <trans-unit id="926646f3fb08c1ad8acc73155c7f0bcd303e689e" translate="yes" xml:space="preserve">
          <source>The planner omits unused LEFT JOINs even if they are not the right-most joins of a query.</source>
          <target state="translated">规划器会省略未使用的LEFT JOIN,即使它们不是查询的最右边的连接。</target>
        </trans-unit>
        <trans-unit id="5852e8af03eff264841e6547e952b8e08ad085dc" translate="yes" xml:space="preserve">
          <source>The platform used for these tests is a 1.6GHz Athlon with 1GB or memory and an IDE disk drive. The operating system is RedHat Linux 7.2 with a stock kernel.</source>
          <target state="translated">这些测试使用的平台是1.6GHz的Athlon,1GB或内存和IDE磁盘驱动器。操作系统为RedHat Linux 7.2,内核为普通内核。</target>
        </trans-unit>
        <trans-unit id="e614d538ab4445c07af270ecdc6677ad39ccfb17" translate="yes" xml:space="preserve">
          <source>The point is this: an SQL database schema almost always does a far better job of defining and organizing the tables and data structures and their relationships. And having clear, concise, and well-defined representation almost always results in an application that performs better, has fewer problems, and is easier to develop and maintain.</source>
          <target state="translated">重点是:SQL数据库模式几乎总是在定义和组织表和数据结构及其关系方面做得更好。而拥有清晰、简明和定义良好的表示方式,几乎总是能使应用程序的性能更好,问题更少,更容易开发和维护。</target>
        </trans-unit>
        <trans-unit id="1249a327a44d56131079defe491a7680b8885a62" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;的指针参数必须为NULL，否则必须是从先前调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;之前尚未释放的指针中获得的指针。</target>
        </trans-unit>
        <trans-unit id="70d5983c94ca6fdbfd5d05e2d8f25d536fa0e2f9" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;和&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;的指针参数必须为NULL，否则必须是从先前调用&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;之前尚未释放的指针中获得的指针。</target>
        </trans-unit>
        <trans-unit id="19e21383ec674e61332285628bf7a07277fe3452" translate="yes" xml:space="preserve">
          <source>The pointer type is not intended to be flexible and dynamic. The pointer type is intended to be a design-time constant. Applications should not synthesize pointer type strings at run-time. Providing support for dynamic pointer type strings would lead developers to misuse the pointer-passing interfaces by creating run-time synthesized pointer type strings. Requiring the pointer type strings to be static encourages developers to do the right thing by choosing fixed pointer type names at design-time and encoding those names as constant strings.</source>
          <target state="translated">指针类型不是为了灵活和动态。指针类型旨在成为设计时的常量,应用程序不应该在运行时合成指针类型字符串。应用程序不应在运行时合成指针类型字符串。提供对动态指针类型字符串的支持会导致开发人员通过创建运行时合成的指针类型字符串来滥用指针传递接口。要求指针类型字符串是静态的,会鼓励开发人员在设计时选择固定的指针类型名称,并将这些名称编码为常量字符串,从而做正确的事情。</target>
        </trans-unit>
        <trans-unit id="0a50e253ab7c267f33ad3d5a3deec486738946df" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返回的指针有效，直到如上所述发生类型转换，或者直到调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;为止。用于保存字符串和BLOB的内存空间会自动释放。不要将从&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;等返回的指针传递到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3551cf33afa7b1894cdea20e6326c2bf8dcf19de" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返回的指针有效，直到如上所述发生类型转换，或者直到调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;为止。用于保存字符串和BLOB的内存空间会自动释放。不要将从&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob（）&lt;/a&gt;，&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;等返回的指针传递到&lt;a href=&quot;free&quot;&gt;sqlite3_free（）中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9edff31b2dc071eb66ab4aa44d22adfef6b1aa3c" translate="yes" xml:space="preserve">
          <source>The pointers that piggy-back on SQL NULL values using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface are transient and ephemeral. The pointers are never written into the database. The pointers will not survive sorting. The latter fact is why there is no sqlite3_column_pointer() interface, since it is impossible to predict whether or not the query planner will insert a sort operation prior to returning a value from a query, so it would be impossible to know if a pointer value inserted into a query by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; would survive through to the result set.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;，&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;接口搭载SQL NULL值的指针是临时的和短暂的。指针永远不会写入数据库。指针将无法生存排序。后一个事实是为什么没有sqlite3_column_pointer（）接口的原因，因为无法预测查询计划程序是否会在从查询返回值之前插入排序操作，因此将无法知道指针值由&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;或&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;插入查询中将保留到结果集。</target>
        </trans-unit>
        <trans-unit id="41025b56b1d99416ab106417d2e02a42b25af90e" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="translated">搬运程序标记器是包装标记器。这需要一些其他标记生成器的输出，并应用&lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;波特词干算法&lt;/a&gt;给每个令牌它返回到FTS5之前。这允许像&amp;ldquo;更正&amp;rdquo;之类的搜索字词匹配类似&amp;ldquo;更正&amp;rdquo;或&amp;ldquo;更正&amp;rdquo;之类的词。搬运工词干分析器算法仅设计用于英语术语-与其他语言一起使用可能会或可能不会提高搜索实用性。</target>
        </trans-unit>
        <trans-unit id="019bce8583fdda23526c796c86c34c98cfb4abf1" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;https://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="translated">搬运程序标记器是包装标记器。这需要一些其他标记生成器的输出，并应用&lt;a href=&quot;https://tartarus.org/martin/PorterStemmer/&quot;&gt;波特词干算法&lt;/a&gt;给每个令牌它返回到FTS5之前。这允许诸如&amp;ldquo;更正&amp;rdquo;之类的搜索词匹配诸如&amp;ldquo;更正&amp;rdquo;或&amp;ldquo;更正&amp;rdquo;之类的相似单词。搬运工词干分析器算法仅设计用于英语术语-与其他语言一起使用可能会或可能不会提高搜索实用性。</target>
        </trans-unit>
        <trans-unit id="8db274801095c26d088720201acb1bad2d40d917" translate="yes" xml:space="preserve">
          <source>The power of an SQLite database could, in theory, be achieved using a custom file format. But any custom file format that is as expressive as a relational database would likely require an enormous design specification and many tens or hundreds of thousands of lines of code to implement. And the end result would be an &quot;opaque blob&quot; that is inaccessible without specialized tools.</source>
          <target state="translated">理论上,SQLite数据库的强大功能可以通过使用自定义文件格式来实现。但是,任何像关系型数据库一样具有表现力的自定义文件格式都很可能需要一个庞大的设计规范和几万行或几十万行的代码来实现。而最终的结果将是一个 &quot;不透明的小球&quot;,没有专门的工具是无法进入的。</target>
        </trans-unit>
        <trans-unit id="4938c1fbe50ea261772ee32f2ec000b4cb6af37b" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property for individual databases can be specified as the database is opened using the &quot;psow&quot; query parameter with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For example, to always assume powersafe overwrite for a file (perhaps to ensure maximum write performance), open it as</source>
          <target state="translated">当使用带有&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;的&amp;ldquo; psow&amp;rdquo;查询参数打开数据库时，可以指定各个数据库的powersafe overwrite属性。例如，要始终假定文件的电源安全覆盖（可能是为了确保最大的写入性能），请以</target>
        </trans-unit>
        <trans-unit id="67790abdb6b576eda27fab78ba503267f5a114fa" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property says nothing about the state of the bytes that were written. Those bytes might contain their old values, their new values, random values, or some combination of these. The powersafe overwrite property merely states that writes cannot change bytes outside of the range of bytes written.</source>
          <target state="translated">powersafe overwrite 属性对被写入的字节的状态没有任何说明。这些字节可能包含了它们的旧值、新值、随机值,或者它们的某种组合。powersafe overwrite属性只是说明写入不能改变写入的字节范围之外的字节。</target>
        </trans-unit>
        <trans-unit id="1389e8d5f9998cc48b0c99ae215e31d8f358ccd0" translate="yes" xml:space="preserve">
          <source>The pragma command is specific to SQLite and is not compatible with any other SQL database engine.</source>
          <target state="translated">pragma命令是针对SQLite的,与其他任何SQL数据库引擎都不兼容。</target>
        </trans-unit>
        <trans-unit id="f45ce9f6459acccc6664213a9c9d236d0392b096" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run faster. PRAGMA quick_check runs in O(N) time whereas &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; requires O(NlogN) time where N is the total number of rows in the database. Otherwise the two pragmas are the same.</source>
          <target state="translated">该编译指示类似于&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;完整性检查，&lt;/a&gt;不同之处在于它不验证UNIQUE约束并且不验证索引内容是否与表内容匹配。通过跳过UNIQUE和索引一致性检查，quick_check可以运行得更快。PRAGMA quick_check以O（N）时间运行，而&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性&lt;/a&gt;_check需要O（NlogN）时间，其中N是数据库中的总行数。否则，这两个编译指示是相同的。</target>
        </trans-unit>
        <trans-unit id="5b9cdfdccce2f8d840c93537988a1d96c50df274" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run much faster than integrity_check. Otherwise the two pragmas are the same.</source>
          <target state="translated">该编译指示类似于&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;完整性检查，&lt;/a&gt;不同之处在于它不验证UNIQUE约束并且不验证索引内容是否与表内容匹配。通过跳过UNIQUE和索引一致性检查，quick_check的运行速度比完整性完整性检查要快得多。否则，两个语用相同。</target>
        </trans-unit>
        <trans-unit id="da60401a603e537afbb64f9be897b6e57271b0ee" translate="yes" xml:space="preserve">
          <source>The pre-update hook</source>
          <target state="translated">预更新钩子</target>
        </trans-unit>
        <trans-unit id="77a94c0ef3120048af1c78a5031b2bc8f51341cf" translate="yes" xml:space="preserve">
          <source>The pre-update hook.</source>
          <target state="translated">预更新的勾当。</target>
        </trans-unit>
        <trans-unit id="464d49040a7350ab38dd3a440629e97d8425be1c" translate="yes" xml:space="preserve">
          <source>The precautions above are not required in order to use SQLite safely with potentially hostile inputs. However, they do provide an extra layer of defense against zero-day exploits and are encouraged for applications that pass data from untrusted sources into SQLite.</source>
          <target state="translated">为了安全地使用SQLite与潜在的敌对输入,上述预防措施不是必需的。然而,它们确实提供了一个额外的防御层,以防止零日漏洞,并鼓励将来自不受信任来源的数据传递到SQLite的应用程序。</target>
        </trans-unit>
        <trans-unit id="05bf811875969018cb62c264a6781abc17b442f0" translate="yes" xml:space="preserve">
          <source>The precedence order for ON CONFLICT clauses was changed so that ON CONFLICT clauses on BEGIN statements have a higher precedence than ON CONFLICT clauses on constraints.</source>
          <target state="translated">改变了ON CONFLICT子句的优先顺序,使BEGIN语句上的ON CONFLICT子句比约束条件上的ON CONFLICT子句具有更高的优先权。</target>
        </trans-unit>
        <trans-unit id="122c8023ebc9769b59f3a1882e33d76b3169c9fd" translate="yes" xml:space="preserve">
          <source>The preceding paragraphs contain a lot of information. To ease the task of constructing a new VFS for SQLite we offer the following implementation checklist:</source>
          <target state="translated">前面的段落包含了很多信息。为了简化为SQLite构建一个新的VFS的任务,我们提供了以下的实施检查表。</target>
        </trans-unit>
        <trans-unit id="661723ea54e783ccd80036c290bfdccff5b43478" translate="yes" xml:space="preserve">
          <source>The precision field, if it is present, must follow the width separated by a single &quot;.&quot; character. If there is no width, then the &quot;.&quot; that introduces the precision immediately follows either the flags (if there are any) or the initial &quot;%&quot;.</source>
          <target state="translated">如果有精度字段,必须在宽度后面用一个&quot;.&quot;字符隔开。如果没有宽度,那么引入精度的&quot;.&quot;字段紧跟在标志(如果有的话)或初始&quot;%&quot;之后。</target>
        </trans-unit>
        <trans-unit id="1f4e06f8dccb411ae11d13e1945ae927355460b6" translate="yes" xml:space="preserve">
          <source>The precision provided by IEEE 754 Binary64 is sufficient for most computations. For example, if &quot;47.49&quot; represents a price and inflation is running at 2% per year, then the price is going up by about 0.0000000301 dollars per second. The error in the recorded value of 47.49 represents about 66 nanoseconds worth of inflation. So if the 47.49 price is exact when you enter it, then the effects of inflation will cause the true value to exactly equal the value actually stored (47.4900000000000019895196601282805204391479492187) in less than one ten-millionth of a second. Surely that level of precision is sufficient for most purposes?</source>
          <target state="translated">IEEE 754 Binary64提供的精度足以满足大多数计算的需要。例如,如果 &quot;47.49 &quot;代表一个价格,而通货膨胀率为每年2%,那么价格每秒上涨约0.0000000301美元。47.49的记录值的误差代表了大约66纳秒的通货膨胀。所以,如果输入47.49的价格是精确的,那么通货膨胀的影响将导致真实值与实际存储的值(47.490000000019895196601282805204391479492187)在不到千万分之一秒的时间内完全相等。当然,这样的精度水平对于大多数目的来说已经足够了?</target>
        </trans-unit>
        <trans-unit id="274c336721e63c209854a5c06e41f1f163132ddd" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">首选使用的例程是&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。该&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口是传统的，应当避免。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;有一个额外的&amp;ldquo; prepFlags&amp;rdquo;选项，用于特殊目的。</target>
        </trans-unit>
        <trans-unit id="2a1d33401c2095551ef53ebdb2c936c2ab4e7f75" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">首选使用的例程是&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。该&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口是传统的，应当避免。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;有一个额外的&amp;ldquo; prepFlags&amp;rdquo;选项，用于特殊目的。</target>
        </trans-unit>
        <trans-unit id="e5802699120466acd022e1fa07d198c436289856" translate="yes" xml:space="preserve">
          <source>The prefix on temporary filenames on Windows is changed from &quot;sqlite&quot; to &quot;etilqs&quot;.</source>
          <target state="translated">Windows上临时文件名的前缀由 &quot;sqlite &quot;改为 &quot;etilqs&quot;。</target>
        </trans-unit>
        <trans-unit id="f3230410aa1ec23cdd51b1c85ef3e6e8a5bf6364" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">繁忙处理程序的存在并不能保证在存在锁争用时将调用该处理程序。如果SQLite确定调用繁忙处理程序可能导致死锁，它将继续执行并将&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给应用程序，而不是调用繁忙处理程序。考虑一个场景，其中一个进程持有试图将其提升为保留锁的读取锁，而第二个进程持有试图将其提升为排他锁的保留锁。第一个进程无法进行，因为它被第二个进程阻止，第二个进程无法进行，因为它被第一个进程阻止。如果两个进程都调用繁忙的处理程序，则两者都不会取得任何进展。因此，SQLite返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;对于第一个进程，希望这将导致第一个进程释放其读取锁并允许第二个进程继续进行。</target>
        </trans-unit>
        <trans-unit id="f52f9d0c779543db7a531d457708b0c4e1e3b230" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">繁忙处理程序的存在并不能保证在存在锁争用时将调用该处理程序。如果SQLite确定调用繁忙处理程序可能导致死锁，它将继续执行并将&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给应用程序，而不是调用繁忙处理程序。考虑一个场景，其中一个进程持有试图将其提升为保留锁的读取锁，而第二个进程持有试图将其提升为排他锁的保留锁。第一个进程无法进行，因为它被第二个进程阻止，第二个进程无法进行，因为它被第一个进程阻止。如果两个进程都调用繁忙的处理程序，则两者都不会取得任何进展。因此，SQLite返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;对于第一个进程，希望这将导致第一个进程释放其读取锁并允许第二个进程继续进行。</target>
        </trans-unit>
        <trans-unit id="b2efda84ef1340b69a62f5b61118269d4141c529" translate="yes" xml:space="preserve">
          <source>The presence of a hot journal is our indication that a previous process was trying to commit a transaction but it aborted for some reason prior to the completion of the commit. A hot journal means that the database file is in an inconsistent state and needs to be repaired (by rollback) prior to being used.</source>
          <target state="translated">热日志的存在是我们的指示,表明前一个进程正试图提交一个事务,但在完成提交之前因某种原因而中止。热日志意味着数据库文件处于不一致的状态,需要在使用前进行修复(通过回滚)。</target>
        </trans-unit>
        <trans-unit id="53e2bd6dac9cbbc9b06c74e123d964800e4d3352" translate="yes" xml:space="preserve">
          <source>The presence of the &quot;noskipscan&quot; token on the sqlite_stat1.stat field of an index prevents that index from being used with the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">索引的sqlite_stat1.stat字段上存在&amp;ldquo; noskipscan&amp;rdquo;令牌，这会阻止该索引与&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化配合使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a01f573624c54e96d01f0d23d0ba8b3593807a0a" translate="yes" xml:space="preserve">
          <source>The presentation of the query planner problem above is a simplification. The costs are estimates. We cannot know what the true cost of running a loop is until we actually run the loop. SQLite makes guesses for the cost of running a loop based on the availability of indexes and constraints found in the WHERE clause. These guesses are usually pretty good, but they can sometimes be off. Using the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect additional statistical information about the database can sometimes enable SQLite to make better guesses about the cost.</source>
          <target state="translated">上面查询规划器问题的表示是一种简化。费用是估计数。在实际运行循环之前，我们不知道运行循环的真正成本是多少。SQLite根据在WHERE子句中找到的索引和约束的可用性来猜测运行循环的成本。这些猜测通常是很好的，但有时可能会落空。使用&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令收集有关数据库的其他统计信息有时可以使SQLite对成本进行更好的猜测。</target>
        </trans-unit>
        <trans-unit id="1c32ea8c1623df88595d5e28c3a4322ef70e185f" translate="yes" xml:space="preserve">
          <source>The preupdate hook interfaces were originally added to support the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension.</source>
          <target state="translated">最初添加了preupdate挂钩接口以支持&lt;a href=&quot;sessionintro&quot;&gt;会话&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="54aaab8c82da084a0f8a9658f2bc76535e494e38" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdate挂钩仅在更改实际数据库表时触发。对于&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;或系统表（如sqlite_master或sqlite_stat1）的更改，不会调用preupdate挂钩。</target>
        </trans-unit>
        <trans-unit id="56711536eb144f6abbe43b67b69a4f340bd68f45" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="translated">preupdate挂钩仅在更改实际数据库表时触发。不会调用preupdate挂钩来更改&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;或系统表（例如sqlite_sequence或sqlite_stat1）。</target>
        </trans-unit>
        <trans-unit id="f619ca19c48dc2cd5df5d0de6abefa9c15ce6509" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdate挂钩仅在更改实际数据库表时触发。对于&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;或系统表（如sqlite_master或sqlite_stat1）的更改，不会调用preupdate挂钩。</target>
        </trans-unit>
        <trans-unit id="f6985f034f86292cf6702a3b24e4e0140c1d7b08" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="translated">preupdate挂钩仅在更改实际数据库表时触发。不会调用preupdate挂钩来更改&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;或系统表（例如sqlite_sequence或sqlite_stat1）。</target>
        </trans-unit>
        <trans-unit id="548d335209dbce4d25a40d42ac27b0b5a00affc4" translate="yes" xml:space="preserve">
          <source>The previous discussion has treated searching and sorting as separate topics. But in practice, it is often the case that one wants to search and sort at the same time. Fortunately, it is possible to do this using a single index.</source>
          <target state="translated">前面的讨论已经把搜索和排序作为单独的主题。但在实际操作中,经常会出现想同时进行搜索和排序的情况。幸运的是,使用一个单一的索引就可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="5a894252915223aa28176cd8caebb845eabbbe5b" translate="yes" xml:space="preserve">
          <source>The previous example is a specific case of a more general problem: The state of an SQLite database is controlled by both the database file and the journal file. In a quiescent state, the journal file does not exist and only the database file matters. But if the journal file does exist, it must be kept together with the database to avoid corruption. The following actions are all likely to lead to corruption:</source>
          <target state="translated">前面的例子是一个比较普遍的问题的具体案例:一个SQLite数据库的状态是由数据库文件和日志文件控制的。在静止状态下,日志文件不存在,只有数据库文件重要。但如果日志文件确实存在,则必须与数据库一起保存,以避免损坏。以下操作都有可能导致损坏。</target>
        </trans-unit>
        <trans-unit id="96495b049cd011fd87b80d69ae6b3a8f79a60e9a" translate="yes" xml:space="preserve">
          <source>The previous example will return every row for which the _shape overlaps the polygon in the $query_polygon parameter. The geopoly_within() function works similarly, but only returns rows for which the _shape is completely contained within $query_polygon.</source>
          <target state="translated">前面的例子将返回$query_polygon参数中_shape与多边形重合的每一条记录。geopoly_within()函数的工作原理类似,但是只返回那些_形状完全包含在$query_polygon参数中的行。</target>
        </trans-unit>
        <trans-unit id="493e14ba39e9f9ab43ab64d3b6be4b87292ba69a" translate="yes" xml:space="preserve">
          <source>The previous example, SQLite uses index &quot;i1&quot; to optimize a WHERE clause term of the form (a=?) - in this case &quot;a=1&quot;. The previous example could not use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt;, but the following example can, and that fact is reflected in the output:</source>
          <target state="translated">在前面的示例中，SQLite使用索引&amp;ldquo; i1&amp;rdquo;来优化形式（a =？）的WHERE子句项-在这种情况下为&amp;ldquo; a = 1&amp;rdquo;。前面的示例不能使用&lt;a href=&quot;queryplanner#covidx&quot;&gt;coverage索引&lt;/a&gt;，但是下面的示例可以使用，并且事实反映在输出中：</target>
        </trans-unit>
        <trans-unit id="69c7b95e4071269d47577736bbe07ea0a083b117" translate="yes" xml:space="preserve">
          <source>The previous fix was not quite right. This one seems to work better.</source>
          <target state="translated">之前的修复方法不太正确。这个似乎比较好用。</target>
        </trans-unit>
        <trans-unit id="fdab229cc2f18edd4b33bcf4f2dc07383013038b" translate="yes" xml:space="preserve">
          <source>The previous paragraph describes what happens when the synchronous pragma setting is &quot;full&quot;.</source>
          <target state="translated">上一段介绍了当同步pragma设置为 &quot;满 &quot;时的情况。</target>
        </trans-unit>
        <trans-unit id="af577bd70a120b3a01a3ee4e9c639a65b514f294" translate="yes" xml:space="preserve">
          <source>The previous paragraph is also true (separate database connections are isolated from one another) in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; as long as the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; remains turned off. The &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is off by default and so if the application does nothing to turn it on, it will remain off. Hence, unless the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is used to change the default behavior, changes made by one database connection are invisible to readers on a different database connection sharing the same cache until the writer commits its transaction.</source>
          <target state="translated">只要保持&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;处于关闭状态，上一段在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;也是正确的（独立的数据库连接彼此隔离）。该&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTED编译&lt;/a&gt;默认是关闭的，因此，如果应用程序没有采取任何措施打开它，它会保持关闭状态。因此，除非使用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;来更改默认行为，否则共享共享缓存的另一个数据库连接上的读取器将看不到一个数据库连接所做的更改，直到写入器提交其事务为止。</target>
        </trans-unit>
        <trans-unit id="4443bdbe2499eab3d6d488e897e8d552fc707661" translate="yes" xml:space="preserve">
          <source>The previous paragraph states that SQLite does not assume that sector writes are atomic. This is true by default. But as of SQLite version 3.5.0, there is a new interface called the Virtual File System (&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;) interface. The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is the only means by which SQLite communicates to the underlying filesystem. The code comes with default VFS implementations for Unix and Windows and there is a mechanism for creating new custom VFS implementations at runtime. In this new VFS interface there is a method called xDeviceCharacteristics. This method interrogates the underlying filesystem to discover various properties and behaviors that the filesystem may or may not exhibit. The xDeviceCharacteristics method might indicate that sector writes are atomic, and if it does so indicate, SQLite will try to take advantage of that fact. But the default xDeviceCharacteristics method for both Unix and Windows does not indicate atomic sector writes and so these optimizations are normally omitted.</source>
          <target state="translated">上一段指出，SQLite不假定扇区写入是原子的。默认情况下是这样。但是从SQLite版本3.5.0开始，有一个称为虚拟文件系统（&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;）接口的新接口。该&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;是SQLite与基础文件系统通信的唯一方法。该代码随附用于Unix和Windows的默认VFS实现，并且提供了一种在运行时创建新的自定义VFS实现的机制。在这个新的VFS接口中，有一个称为xDeviceCharacteristics的方法。此方法询问基础文件系统，以发现文件系统可能会或可能不会出现的各种属性和行为。 xDeviceCharacteristics方法可能表明扇区写是原子的，如果这样做表明SQLite将尝试利用这一事实。但是，对于Unix和Windows，默认的xDeviceCharacteristics方法并不指示原子扇区写入，因此通常会省略这些优化。</target>
        </trans-unit>
        <trans-unit id="342bf4dfcd7ddbf3e5538a244e6458410341ab97" translate="yes" xml:space="preserve">
          <source>The previous paragraphs describe the behavior of temporary databases under the default SQLite configuration. An application can use the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter to force temporary databases to behave as pure in-memory databases, if desired.</source>
          <target state="translated">前面的段落描述了默认SQLite配置下临时数据库的行为。如果需要，应用程序可以使用&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;和&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数来强制临时数据库表现为纯内存数据库。</target>
        </trans-unit>
        <trans-unit id="6e1f293bab97b2b5f7895a766acf571a1f59dca9" translate="yes" xml:space="preserve">
          <source>The previous query is equivalent to the following:</source>
          <target state="translated">前面的查询相当于下面的查询:</target>
        </trans-unit>
        <trans-unit id="2a8f5ff04cf0666d4b31c9cd45d0419954ccab05" translate="yes" xml:space="preserve">
          <source>The previous step created circle (1) in the diagram above. This step will create circle (2). Run the following command:</source>
          <target state="translated">上一步在上图中创建了圆(1)。这一步将创建圆圈(2)。运行以下命令。</target>
        </trans-unit>
        <trans-unit id="73d4cf9a53d1a814d3d61247ac59a2dcf02d4a89" translate="yes" xml:space="preserve">
          <source>The primary page cache implementation is in the &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; file. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; logic is in the separate &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c&lt;/a&gt;. In-memory caching is implemented by the &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; files. The interface between page cache subsystem and the rest of SQLite is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;.</source>
          <target state="translated">主页面缓存实现位于&lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt;文件中。&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;逻辑在单独的&lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c中&lt;/a&gt;。内存中缓存由&lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt;和&lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt;文件实现。页面缓存子系统和其余SQLite之间的接口&lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;由头&lt;/a&gt;文件pager.h定义。</target>
        </trans-unit>
        <trans-unit id="01bd1fccd0eb574f8649d147f7495318ef2ed3aa" translate="yes" xml:space="preserve">
          <source>The primary use of Lemon is to create the SQL language parser. A grammar file (&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;) is compiled by Lemon into parse.c and parse.h. The parse.c file is incorporated into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; without further modification.</source>
          <target state="translated">Lemon的主要用途是创建SQL语言解析器。Lemon将一个语法文件（&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;）编译为parse.c和parse.h。parse.c文件无需进一步修改即可合并到&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c694d6e20cc8030ef2cf2b05c8cbbbe628062074" translate="yes" xml:space="preserve">
          <source>The principal task of an SQL database engine is to evaluate SQL statements of SQL. To accomplish this, the developer needs two objects:</source>
          <target state="translated">SQL数据库引擎的主要任务是评估SQL的SQL语句。为了完成这个任务,开发者需要两个对象。</target>
        </trans-unit>
        <trans-unit id="cfcb012162b1a505da1f19d8786ad1f42bcacc75" translate="yes" xml:space="preserve">
          <source>The principle difference between FTS3/4 and FTS5 is that in FTS3/4, each instance-list is stored as a single large database record, whereas in FTS5 large instance-lists are divided between multiple database records. This has the following implications for dealing with large databases that contain large lists:</source>
          <target state="translated">FTS3/4和FTS5之间的主要区别是,在FTS3/4中,每个实例列表都作为一个大的数据库记录存储,而在FTS5中,大的实例列表在多个数据库记录之间划分。这对处理包含大型列表的大型数据库有以下影响。</target>
        </trans-unit>
        <trans-unit id="d7231b054e5abc6f0cfc5cc85f7e3279373f74d4" translate="yes" xml:space="preserve">
          <source>The printf() in SQLite supports new non-standard substitution types (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;) that are useful both internally to SQLite and to applications using SQLite. Standard library printf()s cannot normally be extended in this way.</source>
          <target state="translated">SQLite中的printf（）支持新的非标准替换类型（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;，&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;，&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;和&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;），这些替换类型在内部对SQLite以及使用SQLite的应用程序均有用。通常无法以这种方式扩展标准库的printf（）s。</target>
        </trans-unit>
        <trans-unit id="0592c94ffabf868a1145cae373098959875b4ffd" translate="yes" xml:space="preserve">
          <source>The printf(FORMAT,...) SQL function works like the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">SQL函数printf（FORMAT，...）类似于&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt; C语言函数和标准C库中的printf（）函数。第一个参数是格式字符串，该格式字符串指定如何使用从后续参数获取的值构造输出字符串。如果FORMAT参数丢失或为NULL，则结果为NULL。 ％n格式将被静默忽略，并且不使用任何参数。 ％p格式是％X的别名。 ％z格式可以与％s互换。如果参数列表中的参数太少，则假定缺少的参数具有NULL值，对于数字格式，它将转换为0或0.0；对于％s，它将转换为空字符串。有关其他信息，请参见&lt;a href=&quot;printf&quot;&gt;内置的printf（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f7aa000e854fa1e51d2a8e3276f08d834816bb0a" translate="yes" xml:space="preserve">
          <source>The private memory cell is initialized to NULL by the first two instructions. Instructions 2 through 13 implement the inner SELECT statement against the examp2 table. Notice that instead of sending the result to a callback or storing the result on a sorter, the result of the query is pushed into the memory cell by instruction 10 and the loop is abandoned by the jump at instruction 11. The jump at instruction at 11 is vestigial and never executes.</source>
          <target state="translated">前两条指令将私有内存单元初始化为NULL。指令2到13实现了对examp2表的内部SELECT语句。请注意,查询的结果不是发送到回调或存储在分拣机上,而是由指令10将查询结果推送到内存单元中,并由指令11处的跳转放弃循环。11号指令处的跳转是残缺的,从来没有执行过。</target>
        </trans-unit>
        <trans-unit id="576c1ad7241fb816002c325b35c536b5acba643f" translate="yes" xml:space="preserve">
          <source>The problem is that the indexes are not of equal quality. A check-in is likely to only have one child. So the first field of PLINK_I1 will usually narrow down the search to just a single row. But there are thousands and thousands check-ins tagged with &quot;trunk&quot;, so the first field of TAGXREF_I1 will be of little help in narrowing down the search.</source>
          <target state="translated">问题是,指数的质量不一样。一个签到很可能只有一个孩子。所以PLINK_I1的第一个字段通常会将搜索范围缩小到只有一行。但是有成千上万的带有 &quot;主干 &quot;标签的签入,所以TAGXREF_I1的第一个字段对缩小搜索范围帮助不大。</target>
        </trans-unit>
        <trans-unit id="4910b74e848d7f84054aa8b42c2da7951eb8cf1a" translate="yes" xml:space="preserve">
          <source>The problem of dynamic memory allocation, and specifically the problem of a memory allocator breakdown, has been studied by J. M. Robson and the results published as:</source>
          <target state="translated">J.M.Robson对动态内存分配问题,特别是内存分配器故障问题进行了研究,结果发表为:。</target>
        </trans-unit>
        <trans-unit id="c0e48a1c7e6fc766c0233c83a22616959f0ed84b" translate="yes" xml:space="preserve">
          <source>The problem of finding the best query plan is equivalent to finding a minimum-cost path through the graph that visits each node exactly once.</source>
          <target state="translated">寻找最佳查询计划的问题相当于在图中寻找一条最小成本的路径,它能准确地访问每个节点一次。</target>
        </trans-unit>
        <trans-unit id="0f52798620170b176ff3d3af06fd50b65930b59c" translate="yes" xml:space="preserve">
          <source>The problem was fixed on 2011-02-20. The fix first appears in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12).</source>
          <target state="translated">该问题已于2011-02-20修复。该修复程序首先出现在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;版本3.7.6&lt;/a&gt;（2011-04-12）中。</target>
        </trans-unit>
        <trans-unit id="0a9231ded77785fbf75b111ccef695ba60c384a1" translate="yes" xml:space="preserve">
          <source>The problem with looking up information by rowid is that you probably do not care what the price of &quot;item 4&quot; is - you want to know the price of peaches. And so a rowid lookup is not helpful.</source>
          <target state="translated">通过rowid查找信息的问题是,你可能并不关心 &quot;物品4 &quot;的价格是多少--你想知道桃子的价格。所以用rowid查找是没有帮助的。</target>
        </trans-unit>
        <trans-unit id="5ca928318271d59121bcae8c1e00c91157b277dc" translate="yes" xml:space="preserve">
          <source>The problem with this latter query is that it must apply the contained_in() function to millions of entries in the demo_data table. The use of the R*Tree in the penultimate query reduces the number of calls to contained_in() function to a small subset of the entire table. The R*Tree index did not find the exact answer itself, it merely limited the search space.</source>
          <target state="translated">后一个查询的问题是,它必须对demo_data表中的数百万个条目应用contains_in()函数。在倒数第二个查询中使用了R*Tree,将对contains_in()函数的调用次数减少到整个表的一个小子集。R*Tree索引本身并没有找到准确的答案,它只是限制了搜索空间。</target>
        </trans-unit>
        <trans-unit id="4d80ba47d569d0e4a2a3e8f3108543e7f76afec3" translate="yes" xml:space="preserve">
          <source>The procedure used to detect a</source>
          <target state="translated">用于检测的程序</target>
        </trans-unit>
        <trans-unit id="7c5ac2fd9c78337a35d0c9980fe79b8e26f93a08" translate="yes" xml:space="preserve">
          <source>The process is explained at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;.</source>
          <target state="translated">该过程在&lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;上进行了说明。</target>
        </trans-unit>
        <trans-unit id="6eeaa105f7c556f91bf9c6156b767ca4d840a8c0" translate="yes" xml:space="preserve">
          <source>The progress callback can be used to display the status of a lengthy query or to process GUI events during a lengthy query.</source>
          <target state="translated">进度回调可用于显示冗长查询的状态或在冗长查询期间处理GUI事件。</target>
        </trans-unit>
        <trans-unit id="c69ceeecbdd66434afc39e336822e8ab81198858" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">进度处理程序回调不得做任何会修改调用进度处理程序的数据库连接的操作。请注意，在本段中，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="cfdeee9bdc15af91672d8ad9f38656051ea8a13d" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">进度处理程序回调不得做任何会修改调用进度处理程序的数据库连接的操作。请注意，在本段中，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="d0b8dc8c8f3e20ba03797e52e7e128023b09d0a3" translate="yes" xml:space="preserve">
          <source>The properties of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; and &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; commands described above only apply if foreign keys are enabled. If the user considers them undesirable, then the workaround is to use &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; to disable foreign key constraints before executing the DROP or ALTER TABLE command. Of course, while foreign key constraints are disabled, there is nothing to stop the user from violating foreign key constraints and thus creating an internally inconsistent database.</source>
          <target state="translated">上面描述的&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;和&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令的属性仅在启用外键的情况下适用。如果用户认为它们不受欢迎，则解决方法是在执行DROP或ALTER TABLE命令之前，使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;禁用外键约束。当然，在禁用外键约束的同时，也没有什么可以阻止用户违反外键约束，从而创建一个内部不一致的数据库。</target>
        </trans-unit>
        <trans-unit id="12341c72ae5851f82e7e9d06ed859f6acb79d027" translate="yes" xml:space="preserve">
          <source>The prover that determines whether any column of the right-hand table of a LEFT JOIN must be non-NULL in the WHERE clause is imperfect. It sometimes returns a false negative. In other words, it sometimes fails to reduce the strength of a LEFT JOIN when doing so was in fact possible. For example, the prover does not know the &lt;a href=&quot;lang_datefunc&quot;&gt;datetime() SQL function&lt;/a&gt; will always return NULL if its first argument is NULL, and so it will not recognize that the LEFT JOIN in the following query could be strength-reduced:</source>
          <target state="translated">确定WHERE子句中LEFT JOIN右侧表的任何列是否必须为非NULL的证明者是不完善的。有时会返回假阴性。换句话说，有时可能无法降低左联接的强度。例如，证明者不知道如果&lt;a href=&quot;lang_datefunc&quot;&gt;datetime（）SQL函数&lt;/a&gt;的第一个参数为NULL，则它将始终返回NULL，因此它无法识别以下查询中的LEFT JOIN可以降低强度：</target>
        </trans-unit>
        <trans-unit id="48a058bacf71fa48c37c493961b3f8857c5bcde0" translate="yes" xml:space="preserve">
          <source>The psow query parameter overrides the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property of the database file being opened. The psow query parameter works with the default windows and unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; but might be a no-op for other proprietary or non-standard VFSes.</source>
          <target state="translated">psow查询参数将&lt;a href=&quot;psow&quot;&gt;覆盖&lt;/a&gt;正在打开的数据库文件的powersafe overwrite属性。psow查询参数可与默认的Windows和UNIX &lt;a href=&quot;vfs&quot;&gt;VFS一起使用，&lt;/a&gt;但对于其他专有或非标准VFS可能是无效的。</target>
        </trans-unit>
        <trans-unit id="ffe108cd06e0c16c268bec90ba5007639fcc32ef" translate="yes" xml:space="preserve">
          <source>The pthreads interface provides the pthread_cond_wait() function. This function allows the caller to simultaneously release a mutex and start waiting for an asynchronous signal. Using this function, a &quot;fired&quot; flag and a mutex, the race-condition described above may be eliminated as follows:</source>
          <target state="translated">pthreads接口提供了pthread_cond_wait()函数。这个函数允许调用者同时释放一个mutex并开始等待一个异步信号。使用该函数、&quot;fireed &quot;标志和mutex,可以消除上述的竞赛条件,具体如下。</target>
        </trans-unit>
        <trans-unit id="5730c4be2fce644af4a3a0b4f7bf8a21afa9d144" translate="yes" xml:space="preserve">
          <source>The pthreads library is needed to make SQLite threadsafe. But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:</source>
          <target state="translated">pthreads库是使SQLite线程安全的需要。但由于CLI是单线程的,我们可以指示SQLite在非线程安全模式下构建,从而省略pthreads库。</target>
        </trans-unit>
        <trans-unit id="ead084e5ac51c3a25e7e77f7295b3ad410aff0a2" translate="yes" xml:space="preserve">
          <source>The purpose of the master journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the master journal is omitted, as an optimization.</source>
          <target state="translated">主日志的目的是确保跨功耗的多文件事务是原子的。但是，如果数据库文件具有其他设置，这些设置会在掉电事件中危及完整性（例如&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMAynchronized = OFF&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY&lt;/a&gt;），那么作为优化，将省略主日志的创建。</target>
        </trans-unit>
        <trans-unit id="80a4c796df15be02f28a9491edc718e0a6ad327d" translate="yes" xml:space="preserve">
          <source>The purpose of the other files and folders is presently unknown to the author but is probably not difficult to figure out.</source>
          <target state="translated">其他文件和文件夹的用途目前笔者不得而知,但大概不难弄清楚。</target>
        </trans-unit>
        <trans-unit id="f221997932c715d1cdc1bd2a990d3e44e81c153a" translate="yes" xml:space="preserve">
          <source>The purpose of the super-journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the super-journal is omitted, as an optimization.</source>
          <target state="translated">超级新闻的目的是确保跨电源损耗的多文件事务是原子的。但是，如果数据库文件具有其他设置，这些设置会在掉电事件中损害完整性（例如&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA sync = &lt;/a&gt;&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;OFF&lt;/a&gt;或PRAGMA journal_mode = MEMORY），那么将忽略超级日志的创建，以进行优化。</target>
        </trans-unit>
        <trans-unit id="6ad934bb2af516663297a114c16808bb7efaf019" translate="yes" xml:space="preserve">
          <source>The purpose of the wal-index is to answer this question quickly:</source>
          <target state="translated">华尔指数的目的就是为了快速回答这个问题。</target>
        </trans-unit>
        <trans-unit id="138e57468a79af5c77be9bf617137e42c028e084" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to argue in favor of a fourth new category of application file format: An SQLite database file.</source>
          <target state="translated">本文件的目的是为了论证支持第四类新的应用文件格式。SQLite数据库文件。</target>
        </trans-unit>
        <trans-unit id="a73682c963786c3512a8e2606835fb2fa3f30921" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to brief the reader on how SQLite development team functions on a daily basis, as they continuously enhance the SQLite software and work to improve its already high reliability. The document achieves its purpose if a competent developer can be assimilated into the development team quickly after perusing this document.</source>
          <target state="translated">本文档的目的是向读者简要介绍SQLite开发团队在日常工作中是如何运作的,因为他们在不断增强SQLite软件的功能,并努力提高其本来就很高的可靠性。如果一个有能力的开发人员在通读本文档后能迅速融入开发团队,那么本文档就达到了目的。</target>
        </trans-unit>
        <trans-unit id="634e9e567d1f1f2dd99eda8c5536d500fa1e6e07" translate="yes" xml:space="preserve">
          <source>The push-down optimization cannot always be used. For example, if the subquery contains a LIMIT, then pushing down any part of the WHERE clause from the outer query could change the result of the inner query. There are other restrictions, explained in a comment in the source code on the pushDownWhereTerms() routine that implements this optimization.</source>
          <target state="translated">不能总是使用下推优化。例如,如果子查询包含一个LIMIT,那么从外部查询中推倒WHERE子句的任何部分都可能改变内部查询的结果。还有其他的限制,在源代码中关于实现这个优化的pushDownWhereTerms()例程的注释中会有解释。</target>
        </trans-unit>
        <trans-unit id="95403298754cba937ffb2896cd7e77d09dc82fdd" translate="yes" xml:space="preserve">
          <source>The quality management plan was originally composed by going through the description of outputs in section 11 of DO-178B (pages 48 through 56) and writing down those elements that seemed relevant to SQLite. The text will be subsequent revised to track enhancements to the SQLite quality process.</source>
          <target state="translated">质量管理计划最初是通过浏览DO-178B第11节(第48至56页)中的产出描述,并写下那些似乎与SQLite相关的内容。随后将对该案文进行修订,以跟踪SQLite质量程序的改进情况。</target>
        </trans-unit>
        <trans-unit id="06064891cfb2016593d8db9b131661701e81d4c1" translate="yes" xml:space="preserve">
          <source>The query above could be made to run faster by using the FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; function to determine the number of query term instances that appear in each result. The matchinfo function is much more efficient than the offsets function. Furthermore, the matchinfo function provides extra information regarding the overall number of occurrences of each query term in the entire document set (not just the current row) and the number of documents in which each query term appears. This may be used (for example) to attach a higher weight to less common terms which may increase the overall computed relevancy of those results the user considers more interesting.</source>
          <target state="translated">通过使用FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt;函数确定出现在每个结果中的查询词实例的数量，可以使上面的查询运行得更快。 matchinfo函数比offsets函数有效得多。此外，matchinfo函数提供有关整个文档集中（不仅是当前行）每个查询词的出现总数以及每个查询词出现在其中的文档数的额外信息。这可以用于（例如）将较高的权重附加到不太常见的术语上，这可以增加用户认为更有趣的那些结果的总体计算相关性。</target>
        </trans-unit>
        <trans-unit id="418f38a31900c8102303fe91cea3cb03a0bfc91a" translate="yes" xml:space="preserve">
          <source>The query above could be rewritten as a join and without the use of row values:</source>
          <target state="translated">上面的查询可以改写为连接,而不使用行值。</target>
        </trans-unit>
        <trans-unit id="8505932c272eacf13a6ac016c3034294904230a0" translate="yes" xml:space="preserve">
          <source>The query above will return suggestions for the whole input word that begins with $prefix. The $wholeline parameter is all text from the beginning of the line up to the insertion point. The $wholeline parameter is used for context.</source>
          <target state="translated">上面的查询将返回以$prefix开头的整个输入词的建议。$wholeline参数是指从行首到插入点的所有文本。$wholeline参数用于上下文。</target>
        </trans-unit>
        <trans-unit id="f9921b4f3858e29c8d8f50be7ccdabc32d452e7c" translate="yes" xml:space="preserve">
          <source>The query above will use the po_parent index to help find the answer, since the po_parent index contains entries for all rows of interest. Note that since po_parent is smaller than a full index, the query will likely run faster too.</source>
          <target state="translated">上面的查询将使用po_parent索引来帮助找到答案,因为po_parent索引包含了所有相关记录的条目。需要注意的是,由于po_parent索引比完整索引小,所以查询的运行速度也会更快。</target>
        </trans-unit>
        <trans-unit id="0190a12968e1ccf51186372beeb26ae3012cb0b9" translate="yes" xml:space="preserve">
          <source>The query above would very quickly locate the id of 1 even if the R*Tree contained millions of entries. The previous is an example of a &quot;contained-within&quot; query. The R*Tree also supports &quot;overlapping&quot; queries. For example, to find all bounding boxes that overlap the Charlotte area:</source>
          <target state="translated">即使R*Tree中包含了数百万个条目,上面的查询也会非常快速地找到1的id。前面是一个 &quot;包含-内 &quot;查询的例子。R*Tree还支持 &quot;重叠 &quot;查询。例如,要找到所有与Charlotte区域重叠的边界框。</target>
        </trans-unit>
        <trans-unit id="94364d8100096142da610b0a18f63efa10ad070a" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URI的查询组件可能包含由SQLite本身或由&lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;自定义VFS实现&lt;/a&gt;解释的参数。SQLite及其内置的&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;解释以下查询参数：</target>
        </trans-unit>
        <trans-unit id="86e91a7c9e388f3708828edd53ce0492e58dcf0d" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URI的查询组件可能包含由SQLite本身或由&lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;自定义VFS实现&lt;/a&gt;解释的参数。SQLite及其内置的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;解释以下查询参数：</target>
        </trans-unit>
        <trans-unit id="f6f2f3df836d46d9540098c193cbe7de6978b27d" translate="yes" xml:space="preserve">
          <source>The query contains both a search restriction in the WHERE clause and a sort order in the ORDER BY clause. Both the search and the sort can be accomplished at the same time using the two-column index Idx3.</source>
          <target state="translated">这个查询包含了WHERE子句中的搜索限制和ORDER BY子句中的排序顺序,搜索和排序都可以通过使用两列索引Idx3同时完成。搜索和排序都可以使用双列索引Idx3同时完成。</target>
        </trans-unit>
        <trans-unit id="bb441cf385ae38b5e50765b319372e3b2d5a50b2" translate="yes" xml:space="preserve">
          <source>The query does a binary search on the index to find the subset of rows that have fruit='Orange'. (Because the fruit column is the left-most column of the index and the rows of the index are in sorted order, all such rows will be adjacent.) Then it scans the matching index rows from top to bottom to get the rowids for the original table, and for each rowid does a binary search on the original table to find the price.</source>
          <target state="translated">该查询在索引上进行二进制搜索,以查找fruit='Orange'的行的子集。(因为fruit列是索引的最左边的一列,而索引的行是按顺序排列的,所以所有这样的行都会相邻)。然后它从上到下扫描匹配的索引行,得到原表的rowid,并对每个rowid在原表上进行二元搜索,找到价格。</target>
        </trans-unit>
        <trans-unit id="0da70d4a5a91c3bdacf749b9198a4a57a477e008" translate="yes" xml:space="preserve">
          <source>The query is not an aggregate</source>
          <target state="translated">查询不是一个集合</target>
        </trans-unit>
        <trans-unit id="d5463ef5a6e2ace12b54dcf259b0837fe48d0c3a" translate="yes" xml:space="preserve">
          <source>The query loop is built from instructions 5 through 13. Instructions 6 through 8 build a record that contains the azData[] values for a single invocation of the callback. A sort key is generated by instructions 9 through 11. Instruction 12 combines the invocation record and the sort key into a single entry and puts that entry on the sort list.</source>
          <target state="translated">查询循环是由指令5到13建立的。指令6到指令8建立一条记录,其中包含回调的一次调用的azData[]值。排序键由指令9到11生成。指令12将调用记录和排序键合并为一个条目,并将该条目放在排序列表中。</target>
        </trans-unit>
        <trans-unit id="b89b1eb2c0211443a7be50a77507c951f5a3834f" translate="yes" xml:space="preserve">
          <source>The query loop is implemented by instructions 8 through 22. The aggregate key specified by the GROUP BY clause is computed by instructions 9 and 10. Instruction 11 causes the appropriate bucket to come into focus. If a bucket with the given key does not already exists, a new bucket is created and control falls through to instructions 12 and 13 which initialize the bucket. If the bucket does already exist, then a jump is made to instruction 14. The values of aggregate functions are updated by the instructions between 11 and 21. Instructions 14 through 18 update memory slot 1 to hold the next value &quot;min(three+four)&quot;. Then the sum of the &quot;four&quot; column is updated by instructions 19 through 21.</source>
          <target state="translated">查询循环由指令8到22实现。由GROUP BY子句指定的集合键由指令9和10计算。指令11使适当的桶成为焦点。如果具有给定键的bucket还不存在,则创建一个新的bucket,控制权落到指令12和13,这两条指令初始化bucket。如果 bucket 已经存在,则跳转到指令 14。汇总函数的值由11到21之间的指令更新。指令14到18更新内存槽1,以保持下一个值 &quot;min(three+four)&quot;。然后由指令19到21更新 &quot;四 &quot;列的和。</target>
        </trans-unit>
        <trans-unit id="a6ac9b746a0ebf6db3c5dac60c7fc4d3c527912f" translate="yes" xml:space="preserve">
          <source>The query optimizer might translate this into three separate constraints:</source>
          <target state="translated">查询优化器可以将其转化为三个独立的约束条件。</target>
        </trans-unit>
        <trans-unit id="ca7f72fc82a7c6f8223569dbd345a23847f45a71" translate="yes" xml:space="preserve">
          <source>The query optimizer now attempts to implement the ORDER BY clause using an index. Sorting is still used if not suitable index is available.</source>
          <target state="translated">查询优化器现在尝试使用索引来实现ORDER BY子句。如果没有合适的索引,仍然会使用排序。</target>
        </trans-unit>
        <trans-unit id="074dd395e411c2a7564e05c9a803ff7d91501e5c" translate="yes" xml:space="preserve">
          <source>The query planner considers the LIMIT clause when estimating the cost of ORDER BY.</source>
          <target state="translated">查询规划师在估算ORDER BY的成本时,会考虑LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="efb22d31da7b95dc237d9b06fed089e63b961bd2" translate="yes" xml:space="preserve">
          <source>The query planner examines the values of bound parameters to help determine if a partial index is usable.</source>
          <target state="translated">查询规划器检查约束参数的值,以帮助确定部分索引是否可用。</target>
        </trans-unit>
        <trans-unit id="e51e3ffe015829441eac83092590224609d07ba7" translate="yes" xml:space="preserve">
          <source>The query planner in SQLite normally does a terrific job of selecting fast algorithms for running your SQL statements. This is true of the legacy query planner and even more true of the new NGQP. There may be an occasional situation where, due to incomplete information, the query planner selects a suboptimal plan. This will happen less often with the NGQP than with the legacy query planner, but it might still happen. Only in those rare cases do application developers need to get involved and help the query planner to do the right thing. In the common case, the NGQP is just a new enhancement to SQLite that makes the application run a little faster and which requires no new developer thought or action.</source>
          <target state="translated">SQLite中的查询规划器通常在选择运行SQL语句的快速算法方面做得非常出色。传统的查询规划器如此,新的NGQP更是如此。偶尔会出现这样的情况:由于信息不完整,查询规划器选择了一个次优的计划。这种情况在NGQP中发生的频率会比在传统查询规划器中发生的频率要低,但仍有可能发生。只有在这些极少数情况下,应用开发人员才需要参与进来,帮助查询规划器做正确的事情。在常见的情况下,NGQP只是对SQLite的一个新的增强,它使应用程序的运行速度更快一些,它不需要开发人员有新的想法或行动。</target>
        </trans-unit>
        <trans-unit id="7056feb20ef72b761795635d81c08e5ed2af62a2" translate="yes" xml:space="preserve">
          <source>The query planner in future versions of SQLite might grow smart enough to make transformations such as the above automatically, in both directions. That is to say, future versions of SQLite might transform queries of the first form into the second, or queries written the second way into the first. As of SQLite version 3.22.0 (2018-01-22), the query planner will flatten the subquery if the outer query does not make use of any user-defined functions or subqueries in its result set. For the examples shown above, however, SQLite implements each of the queries as written.</source>
          <target state="translated">未来版本的SQLite中的查询规划器可能会长得足够聪明,可以自动地进行如上的转换,双向转换。也就是说,未来版本的SQLite可能会将第一种形式的查询转化为第二种形式,或者将第二种方式写的查询转化为第一种方式。从SQLite 3.22.0版本(2018-01-22)开始,如果外层查询的结果集中没有使用任何用户定义的函数或子查询,查询规划器将扁平化子查询。然而,对于上面显示的例子,SQLite按照编写的方式实现了每个查询。</target>
        </trans-unit>
        <trans-unit id="f9ae7f14e38f472239e8cbf47519f9f962bf6c41" translate="yes" xml:space="preserve">
          <source>The query planner is able to optimize IN operators on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method does not set the sqlite3_index_constraint_usage.omit flag of the virtual table column to the left of the IN operator.</source>
          <target state="translated">即使&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法未将虚拟表列的sqlite3_index_constraint_usage.omit标志设置在IN运算符的左侧，查询计划程序仍可以优化&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;上的IN运算符。</target>
        </trans-unit>
        <trans-unit id="4b67d5103aec179badd00d13df4b687ed31a2fd8" translate="yes" xml:space="preserve">
          <source>The query planner is more aggressive about using &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; for views and subqueries for which it is not possible to create a persistent index.</source>
          <target state="translated">查询计划者对于无法为其创建持久索引的视图和子查询使用&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;更具攻击性。</target>
        </trans-unit>
        <trans-unit id="0ff80f93923c8ea0ed391da80428d773af3f58c7" translate="yes" xml:space="preserve">
          <source>The query planner is now able to use &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; that contain AND-connected terms in the WHERE clause.</source>
          <target state="translated">现在，查询计划器可以使用在WHERE子句中包含AND连接项的&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1bf26dc5394aa893fb29edbb88f7b0f3c1a3bf4" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;.</source>
          <target state="translated">读取架构时，查询计划器会将统计信息表的内容加载到内存中。因此，当应用程序直接更改统计表时，SQLite将不会立即注意到这些更改。应用程序可以通过运行&lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;来强制查询计划程序重新读取统计信息表。</target>
        </trans-unit>
        <trans-unit id="b54043d2a3881a0e42bb93d2a4b188d8e3b927bd" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_schema&lt;/b&gt;.</source>
          <target state="translated">读取架构时，查询计划器会将统计信息表的内容加载到内存中。因此，当应用程序直接更改统计信息表时，SQLite将不会立即注意到这些更改。应用程序可以通过运行&lt;b&gt;ANALYZE sqlite_schema&lt;/b&gt;强制查询计划程序重新读取统计信息表。</target>
        </trans-unit>
        <trans-unit id="764ebb928a21a2403e7ad4384e4177e72689b2ef" translate="yes" xml:space="preserve">
          <source>The query planner must decide between many possible implementations of this query, but two plans in particular are of note:</source>
          <target state="translated">查询规划者必须在这个查询的许多可能的实现中做出决定,但有两个计划特别值得注意。</target>
        </trans-unit>
        <trans-unit id="35937457496b4c465e761e374d83f1c328cfb649" translate="yes" xml:space="preserve">
          <source>The query planner now does a better job of optimizing &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; accesses in a 3-way or higher join where constraints on the virtual table are split across two or more other tables of the join.</source>
          <target state="translated">现在，查询计划器可以更好地优化3向或更高连接中的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;访问，其中虚拟表上的约束分布在两个或多个其他连接表中。</target>
        </trans-unit>
        <trans-unit id="ecefb9cd6e1de2d9ed81b2814e874ca9b432f553" translate="yes" xml:space="preserve">
          <source>The query planner now prefers to implement FROM-clause subqueries using &lt;a href=&quot;optoverview#coroutines&quot;&gt;co-routines&lt;/a&gt; rather using the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; optimization. Support for the use of co-routines for subqueries may no longer be disabled.</source>
          <target state="translated">现在，查询计划者更喜欢使用&lt;a href=&quot;optoverview#coroutines&quot;&gt;协例程&lt;/a&gt;而不是&lt;a href=&quot;optoverview#flattening&quot;&gt;查询展平器&lt;/a&gt;优化来实现FROM子句子查询。可能不再禁用对子查询使用协同例程的支持。</target>
        </trans-unit>
        <trans-unit id="39ca8ebd42e9f170c8e29a8cb05c453c4287996d" translate="yes" xml:space="preserve">
          <source>The query planner now recognizes that any column in the right-hand table of a LEFT JOIN can be NULL, even if that column has a NOT NULL constraint. Avoid trying to optimize out NULL tests in those cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">现在，查询计划器可以识别LEFT JOIN右侧表中的任何列都可以为NULL，即使该列具有NOT NULL约束。在这种情况下，请避免尝试优化NULL测试。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec8769590db8f2b5c877d645663be729be900155" translate="yes" xml:space="preserve">
          <source>The query planner now uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information (created by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;) to help determine if the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; is appropriate.</source>
          <target state="translated">现在，查询计划器使用&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;信息（由&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;创建）来帮助确定&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化&lt;/a&gt;是否合适。</target>
        </trans-unit>
        <trans-unit id="c31a7ce3fe100e3f0ec40a06c5c355aa9ab9699f" translate="yes" xml:space="preserve">
          <source>The query planner used &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;-style statistics for one or more indexes of the table at some point during the lifetime of the current connection.</source>
          <target state="translated">查询计划程序在当前连接的生存期内的某个时候对表的一个或多个索引使用了&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;样式的统计信息。</target>
        </trans-unit>
        <trans-unit id="a97e7a7c05ace47af23f942a5bb054692500ea21" translate="yes" xml:space="preserve">
          <source>The query planner uses a full scan of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; instead of a full scan of the main table, in cases where that makes sense.</source>
          <target state="translated">在这种情况下，查询计划程序将使用&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的完整扫描而不是主表的完整扫描。</target>
        </trans-unit>
        <trans-unit id="5c0c2991e6f563d6716af52b8b617039da1f2fdd" translate="yes" xml:space="preserve">
          <source>The query starts by doing a binary search on the Idx1 index for entries that have fruit='Peach'. SQLite can do this binary search on the Idx1 index but not on the original FruitsForSale table because the rows in Idx1 are sorted by the &quot;fruit&quot; column. Having found a row in the Idx1 index that has fruit='Peach', the database engine can extract the rowid for that row. Then the database engines does a second binary search on the original FruitsForSale table to find the original row that contains fruit='Peach'. From the row in the FruitsForSale table, SQLite can then extract the value of the price column. This procedure is illustrated by &lt;a href=&quot;#fig5&quot;&gt;figure 5&lt;/a&gt;.</source>
          <target state="translated">该查询从对Idx1索引进行二进制搜索开始，以查找具有fruit ='Peach'的条目。 SQLite可以在Idx1索引上执行此二进制搜索，但不能在原始FruitsForSale表上执行此二进制搜索，因为Idx1中的行按&amp;ldquo;水果&amp;rdquo;列排序。在Idx1索引中找到具有fruit ='Peach'的行之后，数据库引擎可以提取该行的rowid。然后，数据库引擎对原始FruitsForSale表进行第二次二进制搜索，以找到包含fruit ='Peach'的原始行。然后，从FruitsForSale表的行中，SQLite可以提取price列的值。该过程由&lt;a href=&quot;#fig5&quot;&gt;图5&lt;/a&gt;示出。</target>
        </trans-unit>
        <trans-unit id="7d2f0fdfeb4c2c835aff8667a9df0a76c56f4c48" translate="yes" xml:space="preserve">
          <source>The query string is optional. If the query string is present, then all query parameters are passed through into the xOpen method of the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">查询字符串是可选的。如果存在查询字符串，那么所有查询参数都将传递到基础&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xOpen方法中。</target>
        </trans-unit>
        <trans-unit id="85170b302d04cae08fe65e554bbdfb1393e9fe62" translate="yes" xml:space="preserve">
          <source>The query syntax has been revised where necessary to remove ambiguities and to make it possible to escape special characters in query terms.</source>
          <target state="translated">必要时对查询语法进行了修改,以消除歧义,并使查询术语中的特殊字符可以转义。</target>
        </trans-unit>
        <trans-unit id="6a08992b107064a2b4d32992f6db718c41160975" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents all changes to database files when enabled.</source>
          <target state="translated">query_only pragma 启用后,可以防止对数据库文件的所有更改。</target>
        </trans-unit>
        <trans-unit id="c11b766a9a9b16341cc1ae469b721f6d16c2804c" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents data changes on database files when enabled. When this pragma is enabled, any attempt to CREATE, DELETE, DROP, INSERT, or UPDATE will result in an &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; error. However, the database is not truly read-only. You can still run a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; or a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; and the return value of the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; routine is not affected.</source>
          <target state="translated">如果启用了query_only编译指示，则可以防止更改数据库文件上的数据。启用此编译指示后，任何尝试进行CREATE，DELETE，DROP，INSERT或UPDATE的操作都会导致&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;错误。但是，数据库不是真正的只读。您仍然可以运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;或&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;，而&lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly（）&lt;/a&gt;例程的返回值不受影响。</target>
        </trans-unit>
        <trans-unit id="c227c47e0d2b0279a9dff3f8b02f840ecf77eb68" translate="yes" xml:space="preserve">
          <source>The quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL.</source>
          <target state="translated">quote(X)函数返回一个SQL文字的文本,这个文本是其参数的值,适合包含在SQL语句中。字符串由单引号包围,并根据需要在内部引号上进行转义。BLOBs被编码为十六进制文字。嵌入NUL字符的字符串在SQL中不能表示为字符串字元,因此返回的字符串字元在第一个NUL之前被截断。</target>
        </trans-unit>
        <trans-unit id="9f63b25a5004d971fa73a7b89854797c36e88a71" translate="yes" xml:space="preserve">
          <source>The random() function provides 64 bits of randomness instead of only 32 bits.</source>
          <target state="translated">random()函数提供了64位的随机性,而不是只有32位。</target>
        </trans-unit>
        <trans-unit id="db5db9919e511217ef7da4b79216c59c757f004b" translate="yes" xml:space="preserve">
          <source>The random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807.</source>
          <target state="translated">random()函数返回一个介于-9223372036854775808和+9223372036854775807之间的伪随机整数。</target>
        </trans-unit>
        <trans-unit id="dc66046ce33b1a2430fa7d3f10cb359cc80fae20" translate="yes" xml:space="preserve">
          <source>The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.</source>
          <target state="translated">randomblob(N)函数返回一个包含伪随机字节的N字节blob。如果N小于1,则返回一个1字节的随机blob。</target>
        </trans-unit>
        <trans-unit id="c291d5ba33f13d62c916974b77fcaf954ce3ff7e" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most. Key columns come before auxiliary columns.)</source>
          <target state="translated">列在索引中的等级,(0表示最左,关键列在辅助列之前。)(0表示最左,关键列在辅助列之前。)</target>
        </trans-unit>
        <trans-unit id="0b2bd6ab8a45c757d36fc0179def745c6a1bbb66" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most.)</source>
          <target state="translated">列在索引中的等级。(0表示最左边。)</target>
        </trans-unit>
        <trans-unit id="463c4210effd7ad2a8dada3187acf9269beea08a" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed, or -1 if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed and -2 if the &lt;a href=&quot;expridx&quot;&gt;index is on an expression&lt;/a&gt;.</source>
          <target state="translated">被索引表中的列的排名；如果index-column是被索引表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则为-1，如果&lt;a href=&quot;expridx&quot;&gt;索引位于expression上，则为&lt;/a&gt; -2 。</target>
        </trans-unit>
        <trans-unit id="84413b7d19914c0bede4000ce3b0ffb8491410c6" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed. A value of -1 means &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; and a value of -2 means that an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt; is being used.</source>
          <target state="translated">被索引表中列的等级。值-1表示&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，值-2表示正在使用&lt;a href=&quot;expridx&quot;&gt;表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8754b3bec73ba7fde29d928b708ca495c5b77ae4" translate="yes" xml:space="preserve">
          <source>The rank of word.</source>
          <target state="translated">字的等级。</target>
        </trans-unit>
        <trans-unit id="2dd609ed9718452c7fad1b16788c833004253127" translate="yes" xml:space="preserve">
          <source>The rank option is used to change the default auxiliary function mapping for the rank column. The option should be set to a text value in the same format as described for &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;rank MATCH ?&quot;&lt;/a&gt; terms above. For example:</source>
          <target state="translated">rank选项用于更改rank列的默认辅助功能映射。该选项应设置为与&lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&amp;ldquo; rank MATCH？&amp;rdquo;&lt;/a&gt;所述格式相同的文本值。以上条款。例如：</target>
        </trans-unit>
        <trans-unit id="3e012920d09c510ffee894f9967688d5537ade9a" translate="yes" xml:space="preserve">
          <source>The rate of enhancement for SQLite over the previous five years (2010-2015) is approximately 6 increments of Y per year. The numbering format used by for &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; and &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; allows versions up to 3.999.999, which is more than enough for the planned end-of-support date for SQLite in 2050. However, the current tarball naming conventions only reserve two digits for the Y and so the naming format for downloads will need to be revised in about 2030.</source>
          <target state="translated">在过去的五年（2010-2015年）中，SQLite的增强速度约为每年Y的6个增量。&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;和&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;使用的编号格式允许版本高达3.999.999，这对于2050年SQLite计划的支持终止日期已绰绰有余。但是，当前的tarball命名约定仅保留两位数字用于Y，因此需要在2030年左右修改下载的命名格式。</target>
        </trans-unit>
        <trans-unit id="e8a5095befc118ca6a6fec21354c920d6bd315d2" translate="yes" xml:space="preserve">
          <source>The reader algorithm in the previous paragraphs works correctly, but because frames for page P can appear anywhere within the WAL, the reader has to scan the entire WAL looking for page P frames. If the WAL is large (multiple megabytes is typical) that scan can be slow, and read performance suffers. To overcome this problem, a separate data structure called the wal-index is maintained to expedite the search for frames of a particular page.</source>
          <target state="translated">前面几段中的阅读器算法是正确的,但是由于P页的帧可以出现在WAL中的任何地方,所以阅读器必须扫描整个WAL来寻找P页的帧。如果WAL很大(典型的是多兆字节),这种扫描会很慢,读取性能也会受到影响。为了克服这个问题,我们维护了一个单独的数据结构,称为wal-index,以加快搜索某一页的帧。</target>
        </trans-unit>
        <trans-unit id="3e2fc6a74baa30b6fadb3fd43bce3110d90f198d" translate="yes" xml:space="preserve">
          <source>The readfile(X) SQL function reads the entire content of the file named X and returns that content as a BLOB. This can be used to load content into a table. For example:</source>
          <target state="translated">readfile(X)SQL函数读取名为X的文件的全部内容,并将这些内容以BLOB的形式返回。这可以用来将内容加载到一个表中。例如</target>
        </trans-unit>
        <trans-unit id="f5d4c0c9266d8eca05dca08f98a5cbf6d922d36a" translate="yes" xml:space="preserve">
          <source>The realization that an aggregate query is really two consecutive loops makes it much easier to understand the difference between a WHERE clause and a HAVING clause in SQL query statement. The WHERE clause is a restriction on the first loop and the HAVING clause is a restriction on the second loop. You can see this by adding both a WHERE and a HAVING clause to our example query:</source>
          <target state="translated">认识到聚合查询实际上是两个连续的循环,就更容易理解SQL查询语句中WHERE子句和HAVING子句的区别了。WHERE子句是对第一个循环的限制,HAVING子句是对第二个循环的限制。你可以通过在我们的示例查询中同时添加一个WHERE子句和一个HAVING子句来了解这一点。</target>
        </trans-unit>
        <trans-unit id="4a5758542d7b569e5728a8a94a0c5f527ec1ddfe" translate="yes" xml:space="preserve">
          <source>The reallocarray() interface is a recent innovation (circa 2014) from the OpenBSD community that grow out of efforts to prevent the next &lt;a href=&quot;http://heartbleed.com&quot;&gt;&quot;heartbleed&quot; bug&lt;/a&gt; by avoiding 32-bit integer arithmetic overflow on memory allocation size computations. The reallocarray() function has both unit-size and count parameters. To allocate memory sufficient to hold an array of N elements each X-bytes in size, one calls &quot;reallocarray(0,X,N)&quot;. This is preferred over the traditional technique of invoking &quot;malloc(X*N)&quot; as reallocarray() eliminates the risk that the X*N multiplication will overflow and cause malloc() to return a buffer that is a different size from what the application expected.</source>
          <target state="translated">reallocarray（）接口是OpenBSD社区的一项最新创新（大约于2014年），它通过避免内存分配大小计算中的32位整数算术溢出来防止下一个&lt;a href=&quot;http://heartbleed.com&quot;&gt;&amp;ldquo;令人讨厌的&amp;rdquo;错误&lt;/a&gt;。 reallocarray（）函数同时具有单位大小和计数参数。为了分配足够的内存来容纳每个X字节大小的N个元素的数组，一个调用&amp;ldquo; reallocarray（0，X，N）&amp;rdquo;。这优于调用&amp;ldquo; malloc（X * N）&amp;rdquo;的传统技术，因为reallocarray（）消除了X * N乘法将溢出并导致malloc（）返回与应用程序大小不同的缓冲区的风险。预期。</target>
        </trans-unit>
        <trans-unit id="a25a89f7da0624003a3e075ec1d5437a5611f942" translate="yes" xml:space="preserve">
          <source>The reason for attempting to read the</source>
          <target state="translated">试图阅读的原因。</target>
        </trans-unit>
        <trans-unit id="61ed3e5eacc7786aa96400e0606560d6b0c2919c" translate="yes" xml:space="preserve">
          <source>The reason for this is easy to understand: When a document is inserted into the FTS5 table, an entry is added to the full-text index to record the position of each token within the new document. When a document is removed, the original data is required in order to determine the set of entries that need to be removed from the full-text index. So if the data supplied to FTS5 when a row is deleted using this command is different from that used to determine the set of token instances when it was inserted, some full-text index entries may not be correctly deleted, or FTS5 may try to remove index entries that do not exist. This can leave the full-text index in an unpredictable state, making future query results unreliable.</source>
          <target state="translated">这样做的原因很容易理解。当一份文件被插入FTS5表时,全文索引中会增加一个条目,以记录新文件中每个标记的位置。当文档被删除时,需要原始数据来确定需要从全文索引中删除的条目集。因此,如果使用此命令删除某行时提供给 FTS5 的数据与插入时用于确定标记实例集的数据不同,则一些全文索引条目可能不会被正确删除,或者 FTS5 可能会尝试删除不存在的索引条目。这可能会使全文索引处于不可预测的状态,使未来的查询结果不可靠。</target>
        </trans-unit>
        <trans-unit id="aaf49440241f0d03e40af262860c9b5798f65bc8" translate="yes" xml:space="preserve">
          <source>The reason that the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; has its buffer pointer and buffer size arguments reversed from what is found in the standard library snprintf() routine is because there was no snprintf() routine in the standard C library when Hipp was first implementing his version, and he chose a different order than the designers of the standard C library.</source>
          <target state="translated">之所以说&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;有它的缓冲区指针和缓冲从什么是在标准库的snprintf发现逆转尺寸参数（）函数是因为在标准C库中没有的snprintf（）函数时希普首次实现他的版本，他选择的顺序与标准C库的设计人员不同。</target>
        </trans-unit>
        <trans-unit id="791eaa4dd6fb2ae12ed4b869340107d40b780f17" translate="yes" xml:space="preserve">
          <source>The reasons why C is the best language to implement SQLite include:</source>
          <target state="translated">C语言是实现SQLite的最佳语言的原因包括:。</target>
        </trans-unit>
        <trans-unit id="570c3cd1b218e89b5e9796c1a0c8bf3041d5fcd8" translate="yes" xml:space="preserve">
          <source>The recommended fix for this problem is to select a different filesystem. These days, there is a huge selection of high-performance, reliable, patent-free filesystems that support long filenames. Where possible, it is recommended that embedded devices use one of these other filesystems. This will avoid compatibility issues and the danger of &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">对于此问题，建议的解决方法是选择其他文件系统。如今，支持长文件名的高性能，可靠，免专利的文件系统种类繁多。在可能的情况下，建议嵌入式设备使用这些其他文件系统之一。这将避免兼容性问题，以及&lt;a href=&quot;shortnames#db83corrupt&quot;&gt;由于不一致使用8 + 3文件名而导致数据库损坏&lt;/a&gt;的危险。</target>
        </trans-unit>
        <trans-unit id="25181bcaf1df8e046a1c955d3b9df90abb750621" translate="yes" xml:space="preserve">
          <source>The recommended setting is 0, meaning that double-quoted strings are disallowed in all contexts. However, the default setting is 3 for maximum compatibility with legacy applications.</source>
          <target state="translated">建议设置为0,这意味着在所有情况下都不允许使用双引号字符串。但是,为了最大限度地与传统应用程序兼容,默认设置为3。</target>
        </trans-unit>
        <trans-unit id="932d02d128af056f356f5d45448ef957094cec8a" translate="yes" xml:space="preserve">
          <source>The recommended usage pattern for the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit&lt;/a&gt; pragma is like this:</source>
          <target state="translated">建议的&lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit&lt;/a&gt;用法的用法模式如下所示：</target>
        </trans-unit>
        <trans-unit id="f9e4e6885559253d0ddfdbd8cf19b8d22821af1f" translate="yes" xml:space="preserve">
          <source>The recommended way of creating, updating, listing, and extracting an SQLite Archive is to use the &lt;a href=&quot;cli&quot;&gt;sqlite3.exe command-line shell&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02) or later. This CLI supports the -A command-line option that allows easy management of SQLite Archives. The CLI for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22) has the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; for managing SQLite Archives, but that requires interacting with the shell.</source>
          <target state="translated">创建，更新，列出和提取SQLite存档的推荐方法是将&lt;a href=&quot;cli&quot;&gt;sqlite3.exe命令行外壳&lt;/a&gt;用于SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;3.23.0&lt;/a&gt;（2018-04-02）或更高版本。此CLI支持-A命令行选项，该选项可轻松管理SQLite存档。用于SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;3.22.0版&lt;/a&gt;（2018-01-22）的CLI 具有用于管理SQLite存档的&lt;a href=&quot;cli#sqlar&quot;&gt;.archive命令&lt;/a&gt;，但是需要与Shell进行交互。</target>
        </trans-unit>
        <trans-unit id="4601afd19c62f4d6f4dd6a59905680482f9f3f16" translate="yes" xml:space="preserve">
          <source>The record format makes extensive use of the &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt; or &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; representation of 64-bit signed integers defined above.</source>
          <target state="translated">记录格式大量使用了上面定义的64位带符号整数的&lt;a href=&quot;fileformat2#varint&quot;&gt;变长整数&lt;/a&gt;或&lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt;表示形式。</target>
        </trans-unit>
        <trans-unit id="b82eef28a6cb7dd57ec4d49f060118580d2825f6" translate="yes" xml:space="preserve">
          <source>The recursive SELECT statements must be separated from the non-recursive SELECT statemens and from each other using by the UNION or UNION ALL operators. If there are two or more recursive SELECT statements, they all must be separated from each other using the same operator that separates the first recursive SELECT from the last non-recursive SELECT statement.</source>
          <target state="translated">递归SELECT语句必须使用UNION或UNION ALL运算符与非递归SELECT语句分开,并相互分开。如果有两个或更多递归SELECT语句,它们必须使用相同的运算符将第一个递归SELECT和最后一个非递归SELECT语句分开。</target>
        </trans-unit>
        <trans-unit id="6f45dfeab7c8fdea2c19dfb3263b7e954261008d" translate="yes" xml:space="preserve">
          <source>The register P3 contains one less than the maximum number of allowed errors. At most reg(P3) errors will be reported. In other words, the analysis stops as soon as reg(P1) errors are seen. Reg(P1) is updated with the number of errors remaining.</source>
          <target state="translated">寄存器P3中包含的错误比最大允许的错误数少一个。最多只能报告reg(P3)错误。换句话说,一旦看到reg(P1)错误,分析就会停止。reg(P1)会根据剩余的错误数更新。</target>
        </trans-unit>
        <trans-unit id="b0a0f881a2de041dc76deecadc2825d6252c40fe" translate="yes" xml:space="preserve">
          <source>The registers P1 through P1+P2-1 contain a single row of results. This opcode causes the sqlite3_step() call to terminate with an SQLITE_ROW return code and it sets up the sqlite3_stmt structure to provide access to the r(P1)..r(P1+P2-1) values as the result row.</source>
          <target state="translated">寄存器P1到P1+P2-1包含了单行的结果。这个操作码导致sqlite3_step()调用以SQLITE_ROW返回代码终止,并且它设置了sqlite3_stmt结构以提供对r(P1)...r(P1+P2-1)值的访问作为结果行。</target>
        </trans-unit>
        <trans-unit id="3af4c8adff2c9c78e4e3d405284a88188dcbb490" translate="yes" xml:space="preserve">
          <source>The registers released will be the P2 registers starting at P1, except if bit ii of P3 set, then do not release register P1+ii. In other words, P3 is a mask of registers to preserve.</source>
          <target state="translated">释放的寄存器将是从P1开始的P2寄存器,只是如果P3的第ii位被设置,则不释放寄存器P1+ii。换句话说,P3是一个要保留的寄存器的掩码。</target>
        </trans-unit>
        <trans-unit id="3ad008f7525662f6767cf59c0a5ffbf397455036" translate="yes" xml:space="preserve">
          <source>The relative precedence of the set operations is different. In particular, using the standard query syntax the &quot;OR&quot; operator has a higher precedence than &quot;AND&quot;. The precedence of operators when using the standard query syntax is:</source>
          <target state="translated">集合操作的相对优先性是不同的。特别是,使用标准查询语法时,&quot;OR &quot;操作符的优先级高于 &quot;AND&quot;。使用标准查询语法时,运算符的优先级是:</target>
        </trans-unit>
        <trans-unit id="4055a7e54aa1eb8dd8ef4889c3d207a5659a2b35" translate="yes" xml:space="preserve">
          <source>The release build is used to validate the generated machine code.</source>
          <target state="translated">发布构建是用来验证生成的机器代码。</target>
        </trans-unit>
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">发布检查表是不断发展的。随着新问题或潜在问题的发现,新的检查表项目被添加进来,以确保这些问题不会出现在随后的版本中。事实证明,发布检查清单是一个宝贵的工具,有助于确保在发布过程中不遗漏任何问题。</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">发布检查表不是自动的:开发人员手动运行检查表上的每个项目。我们发现,让人参与其中很重要。有时,即使测试本身通过了,但在运行检查表项目时还是会发现问题。让一个人在最高级别审查测试输出,并不断询问 &quot;这真的是对的吗?&quot;是很重要的。</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">一个文档的相关性可能不仅仅取决于matchinfo的返回值中的数据。例如,数据库中的每个文档可以根据与其内容无关的因素(来源、作者、年龄、参考文献的数量等)分配一个静态权重。这些值可以由应用程序存储在一个单独的表中,可以与子查询中的文档表连接,以便排名函数可以访问它们。</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">SQLite的可靠性和健壮性在一定程度上是通过彻底和仔细的测试实现的。</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">本文件的其余部分将指导读者完成维护私人分支机构所需的步骤。总的思路与上文所述相同。本节只是提供更多细节。</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的其余字段都存储指向实现原始操作的函数的指针。我们称这些为&amp;ldquo;方法&amp;rdquo;。第一种方法xOpen用于打开基础存储介质上的文件。结果是一个&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象。由&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象本身定义的其他方法可用于读取和写入以及关闭文件。其他方法将在下面详细说明。文件名采用UTF-8。 SQLite将确保传递给xOpen（）的zFilename字符串是由xFullPathname（）生成的完整路径名，并且该字符串在调用xClose（）之前将一直有效且不变。所以&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;如果由于某种原因需要记住文件名，可以存储指向文件名的指针。 xOpen（）的flags参数是sqlite3_open_v2（）的flags参数的副本。如果使用sqlite3_open（）或sqlite3_open16（），则标志为&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。如果xOpen（）以只读方式打开文件，则它将* pOutFlags设置为包括&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;。 * pOutFlags中的其他位可以设置。 SQLite还将根据打开的对象向xOpen（）调用添加以下标志之一：</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">该结构定义的其余七个方法(xMutexAlloc、xMutexFree、xMutexEnter、xMutexTry、xMutexLeave、xMutexHeld和xMutexNotheld)分别实现了以下接口。</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">不支持 remove_diacritics 选项。</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">remove_diacritics选项可以设置为 &quot;0&quot;、&quot;1 &quot;或 &quot;2&quot;。默认值是 &quot;1&quot;。如果它被设置为 &quot;1 &quot;或 &quot;2&quot;,那么拉丁字母字符中的暗号就会如上所述被移除,但如果它被设置为 &quot;1&quot;,那么暗号就不会被移除。然而,如果它被设置为 &quot;1&quot;,那么在相当少见的情况下,当一个单一的unicode码点被用来表示一个有多个重音符号的字符时,重音符号就不会被移除。例如,0x1ED9码点(&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;)的暗号没有被删除。这在技术上是一个错误,但如果不造成向后的兼容性问题,就无法修复。如果这个选项被设置为 &quot;2&quot;,那么所有拉丁字符中的双音符就会被正确地删除。</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">replace（X，Y，Z）函数返回一个字符串，该字符串是用字符串Z替换字符串X中每次出现的字符串Y所形成的字符串&lt;a href=&quot;datatype3#collation&quot;&gt;。BINARY&lt;/a&gt;整理序列用于比较。如果Y为空字符串，则返回X不变。如果Z最初不是字符串，则在处理之前将其强制转换为UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">上一步创建的版本库最初是空的。下一步是加载基线SQLite版本--上图中的圆圈(1)。</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">保留区域是每页(除锁定页外)末尾未使用的空间,扩展程序可以用它来保存每页信息。保留区域的大小由数据库文件头中偏移量为20的一字节无符号整数决定。保留区域的大小通常为零。</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">保留区域;</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">使用专门的内存分配器覆盖层来测试SQLite对内存外(OOM)错误的响应,该覆盖层可以模拟内存故障。覆盖层是一个插入在内存分配器和SQLite其他部分之间的层。覆盖层将大部分内存分配请求直接传递给底层分配器,并将结果传回给请求者。但是覆盖层可以被设置为导致第N次内存分配失败。要运行OOM测试,首先设置覆盖层在第一次分配尝试时失败。然后运行一些测试脚本,验证分配是否被正确捕获和处理。然后在第二次分配时将覆盖设置为失败,然后重复测试。失败点每次继续推进一个分配,直到整个测试程序运行完成,没有碰到内存分配错误。这整个测试序列运行两次。在第一次通过时,覆盖点被设置为只在第N次分配时失败。在第二次测试中,覆盖点被设置为第N次分配和所有后续分配失败。</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">该模块结构的其余部分由用于实现虚拟表的各种功能的方法组成。关于这些方法的详细内容将在后文中提供。</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">对复合子查询生成的结果列名进行了简化,只显示原表的列名,省略表名。这使得SQLite的操作更像其他SQL数据库引擎。</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">&amp;ldquo;（1,2,3）=（1，NULL，3）&amp;rdquo;的结果为NULL，因为如果替换为NULL&amp;rarr;2，则结果可能为true；如果替换为NULL&amp;rarr;9，则结果为false。结果&amp;ldquo;（1,2,3）=（1，NULL，4）&amp;rdquo;不是NULL，因为没有组成NULL的替换将使表达式为true，因为在第三列中3永远不会等于4。</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">IN或NOT IN运算符的结果由以下矩阵决定:</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">任何二进制运算符的结果要么是一个数值,要么是NULL,但除了</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">应用程序通过调用sqlite3changegroup_output()获得将所有输入的变化集组合在一起的结果。</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">打开文件的结果是&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象的实例。所述&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象是一个抽象基类定义如下：</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">复合选择的结果由指令22到25的循环发送到回调例程。这个循环没有什么新的或值得注意的地方,除了23处的Column指令将从记录键中提取一列而不是记录数据。</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">最后一个例子的结果应该是examp表中 &quot;2 &quot;列中的每一个唯一值,除了examp2的 &quot;4 &quot;列中的任何值都会被删除。实现这个查询的代码如下。</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">total()的结果总是一个浮点值。如果所有非NULL输入都是整数,那么sum()的结果就是一个整数值。如果sum()的任何输入既不是整数也不是NULL,那么sum()返回的是一个浮点值,它可能是真实总和的近似值。</target>
        </trans-unit>
        <trans-unit id="3501cb60eee256e312e1519991e5a4a97f468bc9" translate="yes" xml:space="preserve">
          <source>The result shown above (0.0000011126) is the correct answer. But if you do this computation using binary64 floating-point, the answer you get is 0.00000095367431640625 - an error of about 14%. If you do many similar computations as part of your program, the errors add up so that your final result might be completely meaningless.</source>
          <target state="translated">上面显示的结果(0.0000011126)是正确的答案。但是如果你使用二进制64浮点计算,你得到的答案是0.00000095367431640625--错误率约为14%。如果你在程序中做了很多类似的计算,错误会不断增加,所以你的最终结果可能完全没有意义。</target>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">由此产生的 &quot;sqlite3.c &quot;合并代码文件(及其相关的头文件 &quot;sqlite3.h&quot;)可以移到非unix平台上使用本地编译器进行最终编译。</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">根据以下规则,比较的结果取决于操作数的存储类别。</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">这里介绍的结果有以下几点注意事项。</target>
        </trans-unit>
        <trans-unit id="0aa6d6ab54b80d454b7163f11aaed1a126d7a246" translate="yes" xml:space="preserve">
          <source>The return value from both sqlite3_soft_heap_limit64() and sqlite3_hard_heap_limit64() is the size of the heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the heap limit. Hence, the current size of heap limits can be determined by invoking sqlite3_soft_heap_limit64(-1) or sqlite3_hard_heap_limit(-1).</source>
          <target state="translated">sqlite3_soft_heap_limit64()和 sqlite3_hard_heap_limit64()的返回值都是调用前的堆限制大小,如果出错,则为负值。如果参数N为负值,那么就不会对堆限制进行改变。因此,可以通过调用sqlite3_soft_heap_limit64(-1)或sqlite3_hard_heap_limit(-1)来确定当前堆限制的大小。</target>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">sqlite3_soft_heap_limit64()的返回值是调用前软堆限制的大小,如果出现错误,返回值为负值。如果参数N为负值,则不会对软堆限制进行任何改变。因此,可以通过调用参数为负的sqlite3_soft_heap_limit64()来确定当前软堆限制的大小。</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">返回值表示间接标志的最终状态:如果是清除,则为0;如果是设置,则为1。</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">返回值表示会话对象的最终状态:如果会话被禁用,则为0;如果会话被启用,则为1。</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;接口的返回值由编译时线程模式选择确定。如果在编译时选择了单线程模式，则&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回false。如果选择了多线程或序列化模式，则&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回true。该&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;接口早在多线程模式和启动时间和运行时间模式选择，因此是无法多线程和序列化的模式，也没有区分是它能够报告开始时间或运行时模式的变化。</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">&lt;b&gt;sqlite_open&lt;/b&gt;函数的返回值是一个不透明的&lt;b&gt;sqlite&lt;/b&gt;结构的指针。该指针将成为处理同一数据库的所有后续SQLite函数调用的第一个参数。如果打开由于任何原因失败，则返回NULL。</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返回的字符串指针是有效的，直到用&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;或直到针对特定运行的第一次调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;来自动重新准备该语句为止，或者直到下次调用sqlite3_column_name（）或sqlite3_column_name16（）为止。同一列。</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返回的字符串指针是有效的，直到用&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;或直到针对特定运行的第一次调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;来自动重新准备该语句为止，或者直到下次调用sqlite3_column_name（）或sqlite3_column_name16（）为止。同一列。</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">上面重写的表达是概念性的；包含OR的WHERE子句实际上不是用这种方式重写的。OR子句的实际实现使用一种效率更高的机制，甚至对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表或无法访问&amp;ldquo; rowid&amp;rdquo;的表也可以使用。但是，实现的实质已由上面的语句捕获：使用单独的索引从每个OR子句项中查找候选结果行，而最终结果是这些行的并集。</target>
        </trans-unit>
        <trans-unit id="cbb9e35f3e4288e3a391570d497ad6531d2b29a9" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. Nevertheless, the essence of the implementation is captured by the statement above: Separate indexes are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">上面重写的表达是概念性的；包含OR的WHERE子句不会真正用这种方式重写。OR子句的实际实现使用一种效率更高的机制，甚至对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表或无法访问&amp;ldquo; rowid&amp;rdquo;的表也可以使用。尽管如此，实现的实质还是由上面的语句捕获到的：使用单独的索引从每个OR子句项中查找候选结果行，而最终结果是这些行的并集。</target>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">然后,重写的项可能会继续使用*IN*运算符的正常规则来约束一个索引。注意</target>
        </trans-unit>
        <trans-unit id="ef14765b49eac9a83db5b6d2871d0bce22ce3fcc" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for &lt;b&gt;IN&lt;/b&gt; operators. Note that</source>
          <target state="translated">然后，重写的术语可能会继续使用&lt;b&gt;IN&lt;/b&gt;运算符的常规规则来约束索引。注意</target>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">如果操作数是列表,IN或NOT IN操作数的右侧操作数没有亲和力,如果操作数是SELECT,则与结果集表达式的亲和力相同。</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">现在,IN操作符的右侧可以是表达式的列表,而不仅仅是常量的列表。</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">LIKE或GLOB的右侧必须是字符串文字或绑定到不以通配符开头的字符串文字的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">LEFT JOIN的右侧表在查询中除了它自己的USING或ON子句外的任何地方都不能使用。</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">MATCH 或=操作符的右侧必须是一个常量表达式,它的值是一个由要调用的辅助函数组成的字符串,后面的括号内是零个或多个逗号分隔的参数。参数必须是 SQL 字符。例如</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">复合选择的最右边的SELECT不得使用&lt;a href=&quot;lang_aggfunc&quot;&gt;聚集&lt;/a&gt;或&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">回滚日志包含一个小头(图中绿色所示),记录了数据库文件的原始大小。因此,如果一个变化导致数据库文件增长,我们仍然会知道数据库的原始大小。页码与每个写入回滚日志的数据库页一起存储。</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">回滚日志不包含主日志文件的名称（请参阅下面的&lt;a href=&quot;#section_5_5&quot;&gt;5.5节&lt;/a&gt;），或者如果包含主日志的名称，则该主日志文件存在。</target>
        </trans-unit>
        <trans-unit id="070c8fccacf99462797ddd5845e4bd8960ffcf17" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a super-journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a super-journal, then that super-journal file exists.</source>
          <target state="translated">回滚日志不包含超级日志文件的名称（请参阅下面的&lt;a href=&quot;#section_5_5&quot;&gt;5.5节&lt;/a&gt;），或者如果包含超级日志文件的名称，则该超级日志文件存在。</target>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">回滚日志存在。</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">可以删除回滚日志文件。</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">回滚日志文件可以被截断为零长度,或者是</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">回滚日志是</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">回滚日志是与每个SQLite数据库文件关联的文件，其中包含用于在事务过程中将数据库文件还原到其初始状态的信息。回滚日志文件始终与数据库文件位于同一目录中，并且与数据库文件具有相同的名称，但是附加了字符串&amp;ldquo; &lt;code&gt;-journal&lt;/code&gt; &amp;rdquo;。与给定数据库只能有一个回滚日志，因此一次只能对一个数据库打开一个写事务。</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">恢复电源后，回滚日志已完成并且在磁盘上完好无损。这是关键。&lt;a href=&quot;#section_3_7&quot;&gt;步骤3.7&lt;/a&gt;中进行刷新操作的原因是，在对数据库文件本身进行任何更改之前，绝对要确保所有回滚日志都安全地存储在非易失性存储中。</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">回滚日志不是一个空文件。</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">数据库中所有表的根号都是整数,存储在P4_INTARRAY参数中。</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">round(X,Y)函数返回一个浮点值X,将其四舍五入到小数点右边的Y位。如果省略Y参数,则假定为0。</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">例程&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;，&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;接受SQL语句列表（sql-stmt-list），该列表以分号分隔。</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">行值表示法对于从单个查询的结果更新表的两个或更多列很有用。例如，&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil版本控制系统&lt;/a&gt;的全文本搜索功能。</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">每组中第一个对等体的row_number()--当前有空隙的行的等级。如果没有ORDER BY子句,那么所有的行都被认为是对等体,这个函数总是返回1。</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">row_number()窗口函数按照window-defn中的 &quot;ORDER BY &quot;子句(在本例中为 &quot;ORDER BY y&quot;)的顺序为每条记录分配连续的整数。请注意,这不会影响整个查询结果的返回顺序。最终输出结果的顺序仍然受SELECT语句中附加的ORDER BY子句的约束(在本例中为 &quot;ORDER BY x&quot;)。</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中省略了rowid（以及&amp;ldquo; oid&amp;rdquo;和&amp;ldquo; _rowid_&amp;rdquo;）。WITHOUT ROWID表仅在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;3.8.2&lt;/a&gt;（2013-12-06）及更高版本中可用。缺少WITHOUT ROWID子句的表称为&amp;ldquo; rowid表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">rowid列在without rowid虚拟表上是无法访问的(当然)。</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">包含术语实例的文档的rowid。</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">表中被更改的行的行名。</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">rtreecheck()函数执行以下检查。</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">rtrim(X,Y)函数返回一个从X的右侧删除Y中出现的所有字符所形成的字符串,如果省略Y参数,rtrim(X)将从X的右侧删除空格。</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">上面的规则说，用户输入中的字母&amp;ldquo; a&amp;rdquo;可以与字典中的字母&amp;ldquo;&amp;auml;&amp;rdquo;匹配，罚分5。</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">确定用于二进制比较运算符（=，&amp;lt;，&amp;gt;，&amp;lt;=，&amp;gt; =，！=，IS和IS NOT）的排序规则的规则如下：</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">在未来的版本中,何时对表格进行分析的规则可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">最安全、最容易记住的政策是:假设任何结果从</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">最安全的政策是以下列方式之一调用这些例程。</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">框架头中的盐-1和盐-2的值与墙头中的盐值相匹配。</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">由于使用关键字 &quot;union&quot;、&quot;true &quot;和 &quot;with &quot;作为标识符,同样的SQL语句在我们知道的所有其他SQL实现上都会失败。</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">使用相同的基本B-Tree格式,但为了提供更好的查询优化机会,改变了索引键的细节。为了将一行的最大大小从64KB增加到24MB,还改变了一些头文件。</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">同样的基本算法,只是这次索引的匹配行是从下往上扫描,而不是从上往下扫描,这样状态将按降序出现。</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">同样的核心字符串格式化器也被SQLite内部使用。</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">同一数据库连接现在可以由不同的线程同时使用。</target>
        </trans-unit>
        <trans-unit id="5f8ba3c2f9144ee232f4993ee2d9beb3988a44ac" translate="yes" xml:space="preserve">
          <source>The same indexes are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">在这两个实现方案中,使用相同的索引来加快每个循环的速度。这两个查询计划的唯一区别是循环的嵌套顺序。</target>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">在这两个实现方案中,使用相同的索引来加快每个循环的速度。这两个查询计划的唯一区别是循环的嵌套顺序。</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">同样的技术确保了SQLite数据库文件不会因为在不恰当的时刻发生的系统故障而损坏。如果系统故障确实发生在SQLite还没有来得及执行足够的程序之前。</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">当然,同样的事情也可以用企业客户/服务器数据库来完成。SQLite的优点是安装和使用比较方便,而且生成的数据库是一个单一的文件,可以写入U盘或者通过电子邮件发给同事。</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">标量SQL函数rtreecheck（R）或rtreecheck（S，R）对数据库S中包含的名为R的rtree表运行完整性检查。该函数返回发现的任何问题的人工语言描述，或者返回字符串'ok'（如果存在）一切都好。在R * Tree虚拟表上运行rtreecheck（）类似于在数据库上运行&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">上述情况听起来很牵强。但SQLite开发者知道至少有一款商业产品发布时恰恰存在这种错误。供应商向SQLite开发人员寻求帮助,以追踪他们在Linux和Mac上看到的一些不频繁的数据库损坏问题。这个问题最终被追溯到一个事实,即应用程序是针对SQLite的两个独立副本进行链接的。解决方法是改变应用程序的构建过程,使其只与一个SQLite副本而不是两个副本进行链接。</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">上面的模式定义了一个有向图,能够在每个节点上存储一个名字。现在考虑对这个模式进行查询。</target>
        </trans-unit>
        <trans-unit id="d37b6e6570fc572ab09d9f50bc38138c9b41b0ec" translate="yes" xml:space="preserve">
          <source>The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented whenever the database schema changes. A prepared statement is compiled against a specific version of the database schema. When the database schema changes, the statement must be reprepared. When a prepared statement runs, it first checks the schema cookie to ensure the value is the same as when the statement was prepared and if the schema cookie has changed, the statement either automatically reprepares and reruns or it aborts with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">模式cookie是偏移量40处的4字节大尾数整数，每当数据库模式更改时，该cookie就会递增。准备好的语句是针对特定版本的数据库模式进行编译的。当数据库模式更改时，必须重新准备该语句。当准备好的语句运行时，它首先检查架构cookie，以确保该值与准备该语句时的值相同；如果架构cookie已更改，则该语句将自动重新准备并重新运行，或者由于&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;错误而中止。</target>
        </trans-unit>
        <trans-unit id="1ab0e540f94c93f90585f3869aa649d5881cec37" translate="yes" xml:space="preserve">
          <source>The schema cookie.</source>
          <target state="translated">模式cookie。</target>
        </trans-unit>
        <trans-unit id="4488aa59b7580b3c4da5952eb56f99b2cde228a2" translate="yes" xml:space="preserve">
          <source>The schema depicted above is not designed to store the full-text index directly. Instead, it is used to store one or more b-tree structures. There is one b-tree for each row in the %_segdir table. The %_segdir table row contains the root node and various meta-data associated with the b-tree structure, and the %_segments table contains all other (non-root) b-tree nodes. Each b-tree is referred to as a &quot;segment&quot;. Once it has been created, a segment b-tree is never updated (although it may be deleted altogether).</source>
          <target state="translated">上面所描述的模式并不是为了直接存储全文索引而设计的,而是用来存储一个或多个b-tree结构。相反,它被用来存储一个或多个b-tree结构。在%_segdir表中,每一行都有一个b树。%_segdir表行包含根节点和与b树结构相关的各种元数据,%_segments表包含所有其他(非根)b树节点。每个b树被称为 &quot;segments&quot;。一旦被创建,一个分段b树就不会被更新(尽管它可能被完全删除)。</target>
        </trans-unit>
        <trans-unit id="2b92ee620ed7f83eb29e5266f914917afed4620a" translate="yes" xml:space="preserve">
          <source>The schema for the DBSTAT virtual table looks like this:</source>
          <target state="translated">DBSTAT虚拟表的模式是这样的。</target>
        </trans-unit>
        <trans-unit id="0fd02dc53052cb07a4282595789654910705302c" translate="yes" xml:space="preserve">
          <source>The schema for the dbstat virtual table is this:</source>
          <target state="translated">dbstat虚拟表的模式是这样的。</target>
        </trans-unit>
        <trans-unit id="2252a25e95423355b1edc92e550e314acf60ad89" translate="yes" xml:space="preserve">
          <source>The schema for the table returned by json_each() and json_tree() is as follows:</source>
          <target state="translated">json_each()和json_tree()返回的表的模式如下。</target>
        </trans-unit>
        <trans-unit id="c3619e8cc0e29548b78032aaa5130408e5391fbe" translate="yes" xml:space="preserve">
          <source>The schema for the tables_used table is:</source>
          <target state="translated">tables_used表的模式是。</target>
        </trans-unit>
        <trans-unit id="7f20e4cd592c03cab97adad3d2182916294f862d" translate="yes" xml:space="preserve">
          <source>The schema format number for a new database can be set at runtime using the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; command.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt;命令设置新数据库的模式格式编号。</target>
        </trans-unit>
        <trans-unit id="933a80ece41d7c4fe3169e373964e2826ef1d8f7" translate="yes" xml:space="preserve">
          <source>The schema format number is a 4-byte big-endian integer at offset 44. The schema format number is similar to the file format read and write version numbers at offsets 18 and 19 except that the schema format number refers to the high-level SQL formatting rather than the low-level b-tree formatting. Four schema format numbers are currently defined:</source>
          <target state="translated">模式格式号是一个4字节的大恩迪安整数,位于偏移量44。模式格式号与偏移量18和19处的文件格式读写版本号类似,只是模式格式号指的是高级SQL格式化,而不是低级b-tree格式化。目前定义了四种模式格式号。</target>
        </trans-unit>
        <trans-unit id="62a7a887a20a821d1b69e9b449caf90b4200d958" translate="yes" xml:space="preserve">
          <source>The schema format number. Supported schema formats are 1, 2, 3, and 4.</source>
          <target state="translated">方案格式号。支持的模式格式有1、2、3和4。</target>
        </trans-unit>
        <trans-unit id="c07d56a869023707575ade10738a217ecfcee4af" translate="yes" xml:space="preserve">
          <source>The schema of an SQL database is able to represent information more directly and succinctly than a key/value database such as a ZIP archive. This makes the document content more accessible to third-party applications and scripts and facilitates advanced features such as built-in document versioning, and incremental saving of work in progress for recovery after a crash.</source>
          <target state="translated">与ZIP档案等键/值数据库相比,SQL数据库的模式能够更直接、更简洁地表示信息。这使得文档内容更容易被第三方应用程序和脚本所访问,并促进了高级功能,如内置的文档版本,以及正在进行的工作的增量保存,以便在崩溃后恢复。</target>
        </trans-unit>
        <trans-unit id="4828e232778c36009f5d78cd72861a810e476bb6" translate="yes" xml:space="preserve">
          <source>The schema of the bytecode table is:</source>
          <target state="translated">字节码表的模式是:</target>
        </trans-unit>
        <trans-unit id="a339d84c3beee1eeb93694c936d75161789ed451" translate="yes" xml:space="preserve">
          <source>The schema table can always be referenced using the name &quot;sqlite_schema&quot;, especially if qualifed by the schema name like &quot;main.sqlite_schema&quot; or &quot;temp.sqlite_schema&quot;. But for historical compatibility, some alternative names are also recognized, including:</source>
          <target state="translated">模式表总是可以使用 &quot;sqlite_schema &quot;这个名字来引用,特别是如果用 &quot;main.sqlite_schema &quot;或 &quot;temp.sqlite_schema &quot;这样的模式名来限定的话。但为了历史的兼容性,一些替代名称也被认可,包括。</target>
        </trans-unit>
        <trans-unit id="70d31e0ed54ade1f01f5803b76d2ee1ab0a7fa16" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_version编译指示将在&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库标头&lt;/a&gt;中的偏移40处获取或设置schema-version整数的值。</target>
        </trans-unit>
        <trans-unit id="87cc88d5b4a5e95bb023c0790cc28378b9e2bd05" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will to get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_version编译指示将获取或设置&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库标头&lt;/a&gt;中偏移40处的schema-version整数的值。</target>
        </trans-unit>
        <trans-unit id="077341a10c528ac1588a1408b9034c9f8021b705" translate="yes" xml:space="preserve">
          <source>The scheme of the URI must be &quot;&lt;code&gt;file:&lt;/code&gt;&quot;. Any other scheme results in the input being treated as an ordinary filename.</source>
          <target state="translated">URI的方案必须为&amp;ldquo; &lt;code&gt;file:&lt;/code&gt; &amp;rdquo;。任何其他方案都会导致输入被视为普通文件名。</target>
        </trans-unit>
        <trans-unit id="08d91918dffee8fc87a94df6946790f6caab8817" translate="yes" xml:space="preserve">
          <source>The score is a combination of rank and distance. The idea is that a lower score is better. The virtual table attempts to find words with the lowest score and by default (unless overridden by ORDER BY) returns results in order of increasing score.</source>
          <target state="translated">分数是等级和距离的组合。这个想法是分数越低越好。虚拟表试图找到得分最低的词,默认情况下(除非被ORDER BY覆盖)按得分增加的顺序返回结果。</target>
        </trans-unit>
        <trans-unit id="61fd3b441b127465c680d5c3514e6d464720698f" translate="yes" xml:space="preserve">
          <source>The script compiles the TH3 test harness into machine code (&quot;th3.o&quot;) if necessary.</source>
          <target state="translated">如果需要的话,这个脚本会把TH3测试线束编译成机器代码(&quot;th3.o&quot;)。</target>
        </trans-unit>
        <trans-unit id="9f405708716b43bff0ad67cd4c7d9fb92e6afc28" translate="yes" xml:space="preserve">
          <source>The script compiles the sqlite3.c source file into assembly language (&quot;sqlite3.s&quot;) if necessary.</source>
          <target state="translated">如果需要的话,脚本会将sqlite3.c源文件编译成汇编语言(&quot;sqlite3.s&quot;)。</target>
        </trans-unit>
        <trans-unit id="9bf1fc92f793f60b433b7ebac87847be7a48eb60" translate="yes" xml:space="preserve">
          <source>The script loops through instructions in the assembly language file to locate branch operations.</source>
          <target state="translated">脚本循环浏览汇编语言文件中的指令,以定位分支操作。</target>
        </trans-unit>
        <trans-unit id="576c62795ba33247bec0c331da3dd87f14e7a748" translate="yes" xml:space="preserve">
          <source>The script makes a copy of the original sqlite3.s file.</source>
          <target state="translated">脚本对原来的sqlite3.s文件进行复制。</target>
        </trans-unit>
        <trans-unit id="fbefc60f4848710280b3f195980be93ae6fb0731" translate="yes" xml:space="preserve">
          <source>The script shows progress for each cycle of the previous step then displays a summary of &quot;survivors&quot; at the end. A &quot;survivor&quot; is a mutation that was not detected by TH3.</source>
          <target state="translated">脚本显示了上一步的每个周期的进展,然后在最后显示 &quot;幸存者 &quot;的摘要。一个 &quot;幸存者 &quot;是指一个没有被TH3检测到的突变。</target>
        </trans-unit>
        <trans-unit id="4a731425cd1bb86844c78ad068a724419eca7459" translate="yes" xml:space="preserve">
          <source>The search for these strings in the type declaration is case insensitive, of course. If any of the above strings occur anywhere in the type declaration, then the datatype of the column is text. Notice that the type &quot;VARCHAR&quot; contains &quot;CHAR&quot; as a substring so it is considered text.</source>
          <target state="translated">当然,在类型声明中搜索这些字符串是不区分大小写的。如果在类型声明中的任何地方出现上述字符串,那么列的数据类型就是文本。注意,类型 &quot;VARCHAR &quot;中包含 &quot;CHAR &quot;作为子串,所以它被认为是文本。</target>
        </trans-unit>
        <trans-unit id="201735a6137bd8c721345300624cc86e3645ba64" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; instruction begins a transaction and starts a rollback journal for database 1, the database used for temporary tables.</source>
          <target state="translated">第二个&lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt;指令开始一个事务并启动数据库1（用于临时表的数据库）的回滚日志。</target>
        </trans-unit>
        <trans-unit id="541464126fdf47682a89498dd2c1f59037e5c50b" translate="yes" xml:space="preserve">
          <source>The second SELECT is implemented by instructions 14 through 19. Instruction 14 initializes the loop by rewinding its cursor. A new result row is created from the &quot;four&quot; column of table &quot;examp2&quot; by instructions 15 and 16. But instead of using PutStrKey to write this new row into the temporary table, we instead call Delete to remove it from the temporary table if it exists.</source>
          <target state="translated">第二条SELECT由指令14至19实现。指令14通过将光标回卷来初始化循环。通过指令15和16从表 &quot;examp2 &quot;的 &quot;四 &quot;列中创建一条新的结果行。但是我们没有使用PutStrKey将这条新行写入临时表,而是调用Delete将其从临时表中删除(如果存在的话)。</target>
        </trans-unit>
        <trans-unit id="b382925f3a88c50c566963d5ae8b2f2a69bce488" translate="yes" xml:space="preserve">
          <source>The second advantage the SQLite printf routines have over &lt;b&gt;sprintf&lt;/b&gt; are two new formatting options specifically designed to support string literals in SQL. Within the format string, the %q formatting option works very much like %s in that it reads a null-terminated string from the argument list and inserts it into the result. But %q translates the inserted string by making two copies of every single-quote (') character in the substituted string. This has the effect of escaping the end-of-string meaning of single-quote within a string literal. The %Q formatting option works similar; it translates the single-quotes like %q and additionally encloses the resulting string in single-quotes. If the argument for the %Q formatting options is a NULL pointer, the resulting string is NULL without single quotes.</source>
          <target state="translated">与&lt;b&gt;sprintf&lt;/b&gt;相比，SQLite printf例程具有的第二个优势是两个新的格式设置选项，这些选项专门设计用于支持SQL中的字符串文字。在格式字符串中，％q格式设置选项的作用与％s非常相似，因为它从参数列表中读取以空值结尾的字符串并将其插入到结果中。但是％q通过为替换字符串中的每个单引号（'）字符制作两个副本来翻译插入的字符串。这具有在字符串文字中转义单引号的字符串结尾含义的效果。 ％Q格式化选项的工作原理类似；它翻译％q之类的单引号，并另外将结果字符串括在单引号中。如果％Q格式设置选项的参数为NULL指针，则结果字符串为NULL，不带单引号。</target>
        </trans-unit>
        <trans-unit id="24bd2add8c4054117cbe09f659537f282404edb5" translate="yes" xml:space="preserve">
          <source>The second and all subsequent 32768-byte units of the shm file are like this:</source>
          <target state="translated">shm文件的第二个及以后所有32768字节的单位是这样的。</target>
        </trans-unit>
        <trans-unit id="2f88dda8423c5371c7ad74eb85809481a6d1addf" translate="yes" xml:space="preserve">
          <source>The second and third forms return the computed edit distance between strings 'string1' and &quot;string2'. In the second form, a language id of 0 is used. The language id is specified in the third form.</source>
          <target state="translated">第二和第三种形式返回字符串 &quot;string1 &quot;和 &quot;string2 &quot;之间的计算编辑距离。在第二种形式中,使用的语言ID为0。在第三种形式中,语言ID被指定。</target>
        </trans-unit>
        <trans-unit id="bab5b375ff048a5d63f1a3b4cc3d343effcaa9c1" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes are not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">第二个参数(xFilter)是 &quot;过滤器回调&quot;。对于没有连接到Session对象的表的行的更改,过滤器被调用来决定是否应该跟踪表的行的更改。如果xFilter返回0,则不跟踪更改。请注意,一旦表被附加,xFilter将不会被再次调用。</target>
        </trans-unit>
        <trans-unit id="a3a47f0193da66fdda72484a51d350d2076b5681" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes is not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">第二个参数(xFilter)是 &quot;过滤器回调&quot;。对于没有连接到Session对象的表的行的更改,过滤器被调用来决定是否应该跟踪表的行的更改。如果xFilter返回0,则不跟踪更改。请注意,一旦表被附加,xFilter将不会被再次调用。</target>
        </trans-unit>
        <trans-unit id="718f90fed591046439ad14f60ea06810377e7e83" translate="yes" xml:space="preserve">
          <source>The second argument indicates the reason that FTS5 is requesting tokenization of the supplied text. This is always one of the following four values:</source>
          <target state="translated">第二个参数表示FTS5请求对提供的文本进行标记化的原因。该参数始终是以下四个值之一。</target>
        </trans-unit>
        <trans-unit id="1b37e9b1846948d626696aade4d54493fddd03d8" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">第二个参数是指向在rowid表中更新，插入或删除行时要调用的函数的指针。回调的第一个参数是sqlite3_update_hook（）的第三个参数的副本。第二个回调参数是&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于导致调用回调的操作。回调的第三个和第四个参数包含指向数据库的指针和包含受影响的行的表名称。最后的回调参数是该行的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。在更新的情况下，这是更新发生后的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6eef977cb1db09c38e32ceda39f74ec952be8d2" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">第二个参数是指向在rowid表中更新，插入或删除行时要调用的函数的指针。回调的第一个参数是sqlite3_update_hook（）的第三个参数的副本。第二个回调参数是&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于导致调用回调的操作。回调的第三个和第四个参数包含指向数据库的指针和包含受影响的行的表名称。最后的回调参数是该行的&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。在更新的情况下，这是更新发生后的&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="724bd11ad92d936922e1ead7d8425d39851a3038" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="translated">第二个参数是要设置的SQL参数的索引。最左边的SQL参数的索引为1。当多次使用同一命名的SQL参数时，第二个及后续出现的索引与第一次出现的索引相同。如果需要，可以使用&lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API查找命名参数的索引。 &amp;ldquo;？NNN&amp;rdquo;参数的索引是NNN的值。 NNN值必须介于1和&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;参数&lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER之间&lt;/a&gt;（默认值：32766）。</target>
        </trans-unit>
        <trans-unit id="d4e308f3aa98b17590b5e994747b662ab58b2433" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">第二个参数是要设置的SQL参数的索引。最左边的SQL参数的索引为1。当多次使用同一命名的SQL参数时，第二个及后续出现的索引与第一次出现的索引相同。如果需要，可以使用&lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API 查找命名参数的索引。 &amp;ldquo;？NNN&amp;rdquo;参数的索引是NNN的值。 NNN值必须介于1到&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;参数&lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER之间&lt;/a&gt;（默认值：999）。</target>
        </trans-unit>
        <trans-unit id="ff965dc4a3884d50d8419508e30018f226ac3b0d" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="translated">第二个参数是要设置的SQL参数的索引。最左边的SQL参数的索引为1。当多次使用同一命名的SQL参数时，第二个及后续出现的索引与第一次出现的索引相同。如果需要，可以使用&lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API查找命名参数的索引。 &amp;ldquo;？NNN&amp;rdquo;参数的索引是NNN的值。 NNN值必须介于1和&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;参数&lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER之间&lt;/a&gt;（默认值：32766）。</target>
        </trans-unit>
        <trans-unit id="a3f014790ea15d84ae5efd1a40e8d6440e64de4e" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">第二个参数是要设置的SQL参数的索引。最左边的SQL参数的索引为1。当多次使用同一命名的SQL参数时，第二个及后续出现的索引与第一次出现的索引相同。如果需要，可以使用&lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API 查找命名参数的索引。 &amp;ldquo;？NNN&amp;rdquo;参数的索引是NNN的值。 NNN值必须介于1到&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;参数&lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER之间&lt;/a&gt;（默认值：999）。</target>
        </trans-unit>
        <trans-unit id="2fb1bff691f79072fe4cf1aa2d31d1bd3832725a" translate="yes" xml:space="preserve">
          <source>The second argument passed to the xToken() callback (&quot;tflags&quot;) should normally be set to 0. The exception is if the tokenizer supports synonyms. In this case see the discussion below for details.</source>
          <target state="translated">传递给xToken()回调的第二个参数(&quot;tflags&quot;)通常应该设置为0。 如果tokenizer支持同义词,则例外。在这种情况下,详情请参考下面的讨论。</target>
        </trans-unit>
        <trans-unit id="ca943db57529952ad5f76d4c9a47b52221a6d6e3" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D，V，...）的第二个参数是&lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;配置动词&lt;/a&gt; -一个整数代码，指示正在配置&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接的&lt;/a&gt;哪个方面。后续参数根据配置动词而有所不同。</target>
        </trans-unit>
        <trans-unit id="a7845e3bb7f88361055af36d05adde4b952592f9" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D，V，...）的第二个参数是&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;配置动词&lt;/a&gt; -一个整数代码，指示正在配置&lt;a href=&quot;sqlite3&quot;&gt;数据库连接的&lt;/a&gt;哪个方面。后续参数根据配置动词而有所不同。</target>
        </trans-unit>
        <trans-unit id="7ca88f23336b34513d2d790b7c87ef9c5d8d0e67" translate="yes" xml:space="preserve">
          <source>The second argument to the error logger callback is an integer &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;. The third argument to the error logger is the text of the error message. The error message text is stored in a fixed-length stack buffer in the calling function and so will only be valid for the duration of the error logger callback function. The error logger should make a copy of this message into persistent storage if retention of the message is needed.</source>
          <target state="translated">错误记录器回调的第二个参数是整数&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。错误记录器的第三个参数是错误消息的文本。错误消息文本存储在调用函数的固定长度堆栈缓冲区中，因此仅在错误记录器回调函数期间有效。如果需要保留消息，则错误记录器应将此消息复制到持久性存储中。</target>
        </trans-unit>
        <trans-unit id="a2a47b21d6064e4d10a2f6d6161c0f1dce1664a1" translate="yes" xml:space="preserve">
          <source>The second argument, &quot;zSql&quot;, is the statement to be compiled, encoded as either UTF-8 or UTF-16. The sqlite3_prepare(), sqlite3_prepare_v2(), and sqlite3_prepare_v3() interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() use UTF-16.</source>
          <target state="translated">第二个参数 &quot;zSql &quot;是要编译的语句,编码为UTF-8或UTF-16。sqlite3_prepare()、 sqlite3_prepare_v2()和 sqlite3_prepare_v3()接口使用UTF-8,sqlite3_prepare16()、 sqlite3_prepare16_v2()和 sqlite3_prepare16_v3()使用UTF-16。</target>
        </trans-unit>
        <trans-unit id="f2e250c2ef383dec7dc31067a07b23d0da95c91b" translate="yes" xml:space="preserve">
          <source>The second beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0的第二个测试版本。</target>
        </trans-unit>
        <trans-unit id="771287a1de97a728b2134cd9c420c1c39a0f52c6" translate="yes" xml:space="preserve">
          <source>The second column is the name of the table.</source>
          <target state="translated">第二列是表的名称。</target>
        </trans-unit>
        <trans-unit id="68511a08109abd7af5a81fce815eeb4f023584c9" translate="yes" xml:space="preserve">
          <source>The second form changes the journaling mode for &quot;</source>
          <target state="translated">第二种形式将日记模式改为&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="2f272c30ebac8ce92b2f903964b40a07bad463d7" translate="yes" xml:space="preserve">
          <source>The second form of the INSERT statement contains a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement instead of a VALUES clause. A new entry is inserted into the table for each row of data returned by executing the SELECT statement. If a column-list is specified, the number of columns in the result of the SELECT must be the same as the number of items in the column-list. Otherwise, if no column-list is specified, the number of columns in the result of the SELECT must be the same as the number of columns in the table. Any SELECT statement, including &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECTs&lt;/a&gt; and SELECT statements with &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and/or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses, may be used in an INSERT statement of this form.</source>
          <target state="translated">INSERT语句的第二种形式包含&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句，而不是VALUES子句。对于通过执行SELECT语句返回的每一行数据，表中都会插入一个新条目。如果指定了列列表，则SELECT结果中的列数必须与列列表中的项目数相同。否则，如果未指定column-list，则SELECT结果中的列数必须与表中的列数相同。任何SELECT语句，包括&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECTs&lt;/a&gt;和带有&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;和/或&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;子句的SELECT语句，都可以在这种形式的INSERT语句中使用。</target>
        </trans-unit>
        <trans-unit id="ec9aa9593798c759bbdf9a6cf2b73541eab87efe" translate="yes" xml:space="preserve">
          <source>The second form of the command is this:</source>
          <target state="translated">命令的第二种形式是这样的。</target>
        </trans-unit>
        <trans-unit id="fa9b557c755fe5c619c7e5fc0af0adff81ce48ad" translate="yes" xml:space="preserve">
          <source>The second form of the pragma listed above is used to set a new limit in bytes for the specified database. A negative number implies no limit. To always truncate rollback journals and WAL files to their minimum size, set the journal_size_limit to zero. Both the first and second forms of the pragma listed above return a single result row containing a single integer column - the value of the journal size limit in bytes. The default journal size limit is -1 (no limit). The &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; preprocessor macro can be used to change the default journal size limit at compile-time.</source>
          <target state="translated">上面列出的编译指示的第二种形式用于为指定的数据库设置新的字节限制。负数表示没有限制。要始终将回滚日志和WAL文件截断为最小大小，请将journal_size_limit设置为零。上面列出的编译指示的第一种和第二种形式均返回包含单个整数列的单个结果行-日志大小限制的值（以字节为单位）。默认的日记帐大小限制为-1（无限制）。该&lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;预处理宏可以用来在编译时更改默认的日志大小限制。</target>
        </trans-unit>
        <trans-unit id="4008980ca9a9274111928748bc06de4b907efa68" translate="yes" xml:space="preserve">
          <source>The second integer, if it is present, is the aggregate size of all data stored on leaf pages in bytes. If the value is negative, then the segment is the output of an unfinished incremental-merge operation, and the absolute value is current size in bytes.</source>
          <target state="translated">第二个整数,如果存在,则是存储在叶页上的所有数据的总大小,单位是字节。如果该值为负,则该段是未完成的增量合并操作的输出,绝对值是当前大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="211c21970b7cdeb91101e574bc29708c2cdfae64" translate="yes" xml:space="preserve">
          <source>The second line above creates a virtual table named &quot;t1&quot; that reads the content of the file named in the argument. The number and names of the columns is determined automatically by reading the first line of content. Other options to the CSV virtual table provide the ability to take the CSV content from a string rather than a separate file, and give the programmer more control over the number and names of the columns. The options are detailed below. The CSV virtual table is usually created as a TEMP table so that it exists only for the current database connection and does not become a permanent part of the database schema. Note that there is no &quot;CREATE TEMP VIRTUAL TABLE&quot; command in SQLite. Instead, prepend the &quot;temp.&quot; schema prefix to the name of the virtual table.</source>
          <target state="translated">上面第二行创建了一个名为 &quot;t1 &quot;的虚拟表,读取参数中命名的文件内容。列的数量和名称是通过读取第一行内容自动确定的。CSV虚拟表的其他选项提供了从字符串而不是单独的文件中获取CSV内容的能力,并让程序员对列的数量和名称有更多的控制。这些选项详述如下。CSV虚拟表通常是作为TEMP表创建的,这样它只为当前的数据库连接而存在,不会成为数据库模式的永久部分。注意,在SQLite中没有 &quot;CREATE TEMP VIRTUAL TABLE &quot;命令。而是在虚拟表的名称前加上 &quot;temp.&quot;模式前缀。</target>
        </trans-unit>
        <trans-unit id="c3933495d9788c26f88ba69fbabb317f1e83064e" translate="yes" xml:space="preserve">
          <source>The second line of the file contains 211792 characters of impenetrable XML. Yes, 211792 characters all on one line. This file is a good stress-test for a text editor. Thankfully, the file is not some obscure binary format, but in terms of accessibility, it might as well be written in Klingon.</source>
          <target state="translated">文件的第二行包含211792个字符,是无法穿透的XML。是的,211792个字符都在一行。这个文件对文本编辑器来说是一个很好的压力测试。值得庆幸的是,这个文件并不是什么晦涩难懂的二进制格式,但就无障碍性而言,它也可能是用克林贡语写的。</target>
        </trans-unit>
        <trans-unit id="5c1d27adf7a874de9fb599be39fb1d27d63c3092" translate="yes" xml:space="preserve">
          <source>The second number Y is incremented for any change that breaks forward compatibility by adding new features. Most future SQLite releases are expected to increment the second number Y. The Z is reset to zero whenever Y is increased.</source>
          <target state="translated">第二位数字Y是通过增加新功能而破坏前向兼容性的任何变化而递增的,未来的大多数SQLite版本预计会递增第二位数字Y,每当Y增加时,Z会被重置为零。大多数未来的SQLite版本都会对第二个数字Y进行递增,每当Y增加时,Z会被重置为零。</target>
        </trans-unit>
        <trans-unit id="50b9dd44fd65466aa651f4fce7056da00ed7e13a" translate="yes" xml:space="preserve">
          <source>The second parameter (argc) and the fourth parameter (columnNames) are still valid and can be used to determine the number and names of the result columns if there had been a result. The default behavior is not to invoke the callback at all if the result set is empty.</source>
          <target state="translated">第二个参数(argc)和第四个参数(columnNames)仍然有效,如果有结果,可以用来确定结果列的数量和名称。如果结果集为空,默认行为是完全不调用回调。</target>
        </trans-unit>
        <trans-unit id="682054ab4ce2cb4dfe2528dcad7556d5d406ca5f" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">第二个参数是要创建或重新定义的SQL函数的名称。名称的长度以UTF-8表示形式限制为255个字节，不包括零终止符。请注意，名称长度限制以UTF-8字节为单位，而不是字符或UTF-16字节。任何尝试使用更长名称创建函数的尝试都会导致返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="266b83f6439ab5e88dcd3928741ef542cdbb6626" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">第二个参数是要创建或重新定义的SQL函数的名称。名称的长度以UTF-8表示形式限制为255个字节，不包括零终止符。请注意，名称长度限制以UTF-8字节为单位，而不是字符或UTF-16字节。任何尝试使用更长名称创建函数的尝试都会导致返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="560b989b803d6b51bde79f3db2c1500c44cc5751" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdate回调的第二个参数是指向注册preupdate挂钩的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。 preupdate回调的第三个参数是常量&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE之一，&lt;/a&gt;用于标识即将发生的更新操作的类型。 preupdate回调的第四个参数是数据库连接中正在修改的数据库的名称。对于主数据库，这将是&amp;ldquo; main&amp;rdquo;；对于TEMP表，这将是&amp;ldquo; temp&amp;rdquo;；对于已连接的数据库，这将在&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后给出。 preupdate回调的第五个参数是要修改的表的名称。</target>
        </trans-unit>
        <trans-unit id="097d5db1a651bbf810ec3be53362ed0414cfc3f9" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdate回调的第二个参数是指向注册preupdate挂钩的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。 preupdate回调的第三个参数是常量&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE之一，&lt;/a&gt;用于标识即将发生的更新操作的类型。 preupdate回调的第四个参数是数据库连接中正在修改的数据库的名称。对于主数据库，这将是&amp;ldquo; main&amp;rdquo;；对于TEMP表，这将是&amp;ldquo; temp&amp;rdquo;；对于已连接的数据库，这将在&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后给出。 preupdate回调的第五个参数是要修改的表的名称。</target>
        </trans-unit>
        <trans-unit id="f5ad56c8e6b709d2294efc15c0b9ac27fea8d776" translate="yes" xml:space="preserve">
          <source>The second step finds the four shortest paths to visit two nodes beginning with one of the four paths from the previous step. In the case where two or more paths are equivalent (they have the same set of visited nodes, though possibly in a different order) only the first and lowest-cost path is retained. We have:</source>
          <target state="translated">第二步从上一步的四条路径中的一条开始,找出访问两个节点的四条最短路径。在两条或多条路径相等的情况下(它们有相同的访问节点集,虽然顺序可能不同),只保留第一条成本最低的路径。我们有:</target>
        </trans-unit>
        <trans-unit id="73fbb8fcf9b3b6fa8277785714e82cfa142507c2" translate="yes" xml:space="preserve">
          <source>The second through fifth forms of this pragma set the encoding that the main database will be created with if it is created by this session. The string 'UTF-16' is interpreted as &quot;UTF-16 encoding using native machine byte-ordering&quot;. It is not possible to change the text encoding of a database after it has been created and any attempt to do so will be silently ignored.</source>
          <target state="translated">这个pragma的第二到第五种形式设置了如果主数据库是由这个会话创建的,它将被创建的编码。字符串'UTF-16'被解释为 &quot;使用本机字节排序的UTF-16编码&quot;。在创建数据库后,不可能更改数据库的文本编码,任何试图这样做的行为都将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="5882943850506b5e4c2358f26a0aca06e4d009ac" translate="yes" xml:space="preserve">
          <source>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur. On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; for additional information.</source>
          <target state="translated">secure_delete设置导致删除的内容被零覆盖。由于必须进行额外的I / O，因此性能损失很小。另一方面，secure_delete可以防止敏感信息的片段在删除后保留在数据库文件的未使用部分中。有关其他信息，请参见&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete编译&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="8c43aaf2166362418b74a582dbeb5524f0656e30" translate="yes" xml:space="preserve">
          <source>The seekHit integer represents the maximum of terms in an index for which there is known to be at least one match. If the seekHit value is smaller than the total number of equality terms in an index lookup, then the &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt; opcode might run to see if the IN loop can be abandoned early, thus saving work. This is part of the IN-early-out optimization.</source>
          <target state="translated">seekHit整数表示已知存在至少一个匹配项的索引中的最大项。如果seekHit值小于索引查找中相&lt;a href=&quot;opcode#IfNoHope&quot;&gt;等项&lt;/a&gt;的总数，则IfNoHope操作码可能会运行以查看是否可以尽早放弃I​​N循环，从而节省了工作。这是IN-early-out优化的一部分。</target>
        </trans-unit>
        <trans-unit id="5b04afcfc3f7fd09080833015b31410c518c0339" translate="yes" xml:space="preserve">
          <source>The separate &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; description provides details on the structure of a database file and of the write-head log file used in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. But details of the locking protocol and of the format of the WAL-index are deliberately omitted since those details are left to discretion of individual &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations. This document fills in those missing details for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">单独的&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;描述提供了有关&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;使用的数据库文件和写头日志文件的结构的详细信息。但是有意省略了锁定协议的细节和WAL-index格式的细节，因为这些细节留给各个&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现酌情决定。本文档填充了UNIX和Windows &lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;那些缺失的详细信息。</target>
        </trans-unit>
        <trans-unit id="92103d1dd017d8e08e89604f71cfaaa913bec164" translate="yes" xml:space="preserve">
          <source>The session extension facilitates this by recording all changes to both Alice's and Bob's databases and writing those changes into changeset or patchset files. At the end of the day, Alice can send her changeset to Bob and Bob can &quot;apply&quot; it to his database. The result (assuming there are no conflicts) is that Bob's database then contains both his changes and Alice's changes. Likewise, Bob can send a changeset of his work over to Alice and she can apply his changes to her database.</source>
          <target state="translated">会话扩展通过记录Alice和Bob数据库的所有变化,并将这些变化写进变化集或补丁集文件中来实现这一目的。在一天结束的时候,Alice可以把她的变化集发送给Bob,Bob可以把它应用到他的数据库中。结果(假设没有冲突)是Bob的数据库中包含了他的变化和Alice的变化。同样的,Bob可以把他的工作变化集发送给Alice,而Alice可以把他的变化应用到她的数据库中。</target>
        </trans-unit>
        <trans-unit id="1c8659fbbef014d7697d1ea170e739bed552acd5" translate="yes" xml:space="preserve">
          <source>The session extension only works with tables that have a declared PRIMARY KEY. The PRIMARY KEY of a table may be an INTEGER PRIMARY KEY (rowid alias) or an external PRIMARY KEY.</source>
          <target state="translated">会话扩展只适用于有声明PRIMARY KEY的表。表的PRIMARY KEY可以是一个INTEGER PRIMARY KEY(rowid别名)或一个外部PRIMARY KEY。</target>
        </trans-unit>
        <trans-unit id="8619b8eb0bb510e39b3c8622337b2bb7b6549aba" translate="yes" xml:space="preserve">
          <source>The session extension provide a mechanism for recording changes to some or all of the &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; in an SQLite database, and packaging those changes into a &quot;changeset&quot; or &quot;patchset&quot; file that can later be used to apply the same set of changes to another database with the same schema and compatible starting data. A &quot;changeset&quot; may also be inverted and used to &quot;undo&quot; a session.</source>
          <target state="translated">会话扩展提供了一种机制，用于记录对SQLite数据库中某些或所有&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;的更改，并将这些更改打包到&amp;ldquo; changeset&amp;rdquo;或&amp;ldquo; patchset&amp;rdquo;文件中，这些文件以后可用于将同一组更改应用于另一个具有相同架构和兼容起始数据的数据库。&amp;ldquo;变更集&amp;rdquo;也可以反转并用于&amp;ldquo;撤消&amp;rdquo;会话。</target>
        </trans-unit>
        <trans-unit id="0b97f5ba300285bc33992abb7779519b897b7aa7" translate="yes" xml:space="preserve">
          <source>The session object &quot;indirect&quot; flag is set when the change is made, or</source>
          <target state="translated">变更时设置会话对象 &quot;间接 &quot;标志,或者是</target>
        </trans-unit>
        <trans-unit id="ffcb76dee8dc3b4cb20fe29908bbbe2ff2230909" translate="yes" xml:space="preserve">
          <source>The session object is configured with a set of tables to monitor changes on.</source>
          <target state="translated">会话对象配置了一组表来监控变化。</target>
        </trans-unit>
        <trans-unit id="0c67ff7ccfd533851dea34da8187939bbeae8841" translate="yes" xml:space="preserve">
          <source>The session object is deleted using a call to the &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; API function.</source>
          <target state="translated">可以使用对&lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete（）&lt;/a&gt; API函数的调用来删除会话对象。</target>
        </trans-unit>
        <trans-unit id="b41c2d1dd25f0b9daf0304c7870c3eb7ae78b919" translate="yes" xml:space="preserve">
          <source>The session object therefore accumulates two types of records - those that consist of primary key values only (created when the user inserts a new record) and those that consist of the primary key values and the original values of other table columns (created when the users deletes or updates a record).</source>
          <target state="translated">因此,会话对象积累了两种类型的记录--仅由主键值组成的记录(当用户插入一条新记录时创建)和由主键值和其他表列的原始值组成的记录(当用户删除或更新一条记录时创建)。</target>
        </trans-unit>
        <trans-unit id="67b4d05a6aa852ba851b95d39158470c33cead0c" translate="yes" xml:space="preserve">
          <source>The session object will be used to create changesets for tables in database zDb, where zDb is either &quot;main&quot;, or &quot;temp&quot;, or the name of an attached database. It is not an error if database zDb is not attached to the database when the session object is created.</source>
          <target state="translated">会话对象将用于为数据库zDb中的表创建更改集,其中zDb是 &quot;main &quot;或 &quot;temp&quot;,或者是附加数据库的名称。如果在创建会话对象时,数据库zDb没有被连接到数据库,这并不是一个错误。</target>
        </trans-unit>
        <trans-unit id="45a8679117c7936fefc29c4e8b252b099d09917b" translate="yes" xml:space="preserve">
          <source>The sessions module never invokes an xOutput callback with the third parameter set to a value less than or equal to zero. Other than this, no guarantees are made as to the size of the chunks of data returned.</source>
          <target state="translated">会话模块从不调用第三个参数设置为小于或等于0的xOutput回调。除此之外,我们不保证返回的数据块的大小。</target>
        </trans-unit>
        <trans-unit id="a218d47a709906affb4f3ae717da9de3077b519d" translate="yes" xml:space="preserve">
          <source>The sessions module revolves around creating and manipulating changesets. A changeset is a blob of data that encodes a series of changes to a database. Each change in a changeset is one of the following:</source>
          <target state="translated">会话模块围绕着创建和操作变更集展开。一个变化集是一个数据块,它编码了一系列对数据库的变化。变更集中的每一个变化都是以下几种情况之一。</target>
        </trans-unit>
        <trans-unit id="d639d6bbcd88a2f2cd5339240f5d5c5de8f80432" translate="yes" xml:space="preserve">
          <source>The set X contains the index in aPgno of every entry in the current 32768-byte unit of the shm file that might possible be a solution to the FindFrame(P,M) function. Each of these entries must be checked separately to ensure that the aPgno value is P and that the frame number does not exceed M. The largest frame number that passes those two tests is the answer.</source>
          <target state="translated">集X包含了shm文件当前32768字节单位中每一个可能是FindFrame(P,M)函数解的条目在aPgno中的索引。每一个条目都必须单独检查,以确保aPgno的值是P,并且帧数不超过M,通过这两个测试的最大帧数就是答案。</target>
        </trans-unit>
        <trans-unit id="daeab809359987c0f17f57c78f38704f62041f7b" translate="yes" xml:space="preserve">
          <source>The set of</source>
          <target state="translated">这套</target>
        </trans-unit>
        <trans-unit id="df619f50e7143055665ccf4d69e938c1340f4737" translate="yes" xml:space="preserve">
          <source>The set of built-in auxiliary functions provided by FTS5 may be improved upon in the future.</source>
          <target state="translated">未来可能会对FTS5提供的一组内置辅助功能进行改进。</target>
        </trans-unit>
        <trans-unit id="a49341beec33b485301f8bafe6ae6c61c6f39915" translate="yes" xml:space="preserve">
          <source>The set of checklist items for release checklist is potentially updated for each release. The content and complete history of each release checklist are retained for the historical record.</source>
          <target state="translated">每次发布时,发布检查表的检查项目集都有可能更新。每份发布检查表的内容和完整的历史记录都会被保留下来,作为历史记录。</target>
        </trans-unit>
        <trans-unit id="0f5a66644e1d1f4b0f41c960d4f2f7a794b20868" translate="yes" xml:space="preserve">
          <source>The set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.</source>
          <target state="translated">静态mutexes集可能会从一个SQLite版本改变到下一个版本。覆盖内置的mutex逻辑的应用程序必须准备好适应额外的静态mutexes。</target>
        </trans-unit>
        <trans-unit id="9b60f1982b5c4164ca917a617479f0aacfe46294" translate="yes" xml:space="preserve">
          <source>The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularly useful. And you can &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or even &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; the shadow tables, though doing so will corrupt your R*Tree index. So it is best to simply ignore the shadow tables. Recognize that they hold your R*Tree index information and let it go as that.</source>
          <target state="translated">影子表是普通的SQLite数据表。您可以根据需要直接查询它们，尽管这不可能揭示任何特别有用的东西。而且您可以&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;甚至是&lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt;影子表，尽管这样做会破坏您的R * Tree索引。因此，最好只是忽略影子表。认识到他们拥有您的R * Tree索引信息，并就这样继续进行。</target>
        </trans-unit>
        <trans-unit id="7b89e4e1261efca1d668789aecafeceb06cf0045" translate="yes" xml:space="preserve">
          <source>The shared library filename passed to &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; may omit the filename suffix, and an appropriate architecture-dependent suffix (&quot;.so&quot;, &quot;.dylib&quot;, or &quot;.dll&quot;) will be added automatically.</source>
          <target state="translated">传递给&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;的共享库文件名可以省略文件名后缀，并且将自动添加适当的与体系结构相关的后缀（&amp;ldquo; .so&amp;rdquo;，&amp;ldquo;。dylib&amp;rdquo;或&amp;ldquo; .dll&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="683712ddb2de169a205df89a5ffe29d5c006c2b5" translate="yes" xml:space="preserve">
          <source>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</source>
          <target state="translated">共享内存文件不包含任何持久性内容。共享内存文件的唯一目的是提供一块共享内存，供所有以WAL模式访问同一数据库的多个进程使用。如果&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;能够提供一种访问共享内存的替代方法，则可以使用该替代方法而不是共享内存文件。例如，如果&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMAlocking_mode&lt;/a&gt;设置为EXCLUSIVE（意味着只有一个进程能够访问数据库文件），则共享内存将从堆中分配，而不是从共享内存文件中分配，并且共享内存文件将永远不会被创造。</target>
        </trans-unit>
        <trans-unit id="d84d71db4e9c7a1a18a467e4bbe2be0320c053f2" translate="yes" xml:space="preserve">
          <source>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</source>
          <target state="translated">共享内存文件与其关联的WAL文件具有相同的寿命。当创建WAL文件时,共享内存文件被创建,当删除WAL文件时,共享内存文件被删除。在WAL文件恢复过程中,共享内存文件会根据被恢复的WAL文件的内容从头开始重新创建。</target>
        </trans-unit>
        <trans-unit id="c6175d074e784d9fffd662056186d3e1dc1f4cc9" translate="yes" xml:space="preserve">
          <source>The shm does not contain any database content and is not required to recover the database following a crash. For that reason, the first client to connect to a quiescent database will normally truncate the shm file if it exists. Since the content of the shm file does not need to be preserved across a crash, the shm file is never fsync()-ed to disk. In fact, if there were a mechanism by which SQLite could tell the operating system to never persist the shm file to disk but always hold it in cache memory, SQLite would use that mechanism to avoid any unnecessary disk I/O associated with the shm file. However, no such mechanism exists in standard posix.</source>
          <target state="translated">shm不包含任何数据库内容,也不需要在崩溃后恢复数据库。因此,第一个连接到静止数据库的客户端通常会截断shm文件(如果它存在的话)。由于shm文件的内容不需要在崩溃时保存,所以shm文件永远不会被fsync()-ed到磁盘上。事实上,如果有一种机制可以让SQLite告诉操作系统永远不要将shm文件持久化到磁盘上,而总是将其保存在缓存中,那么SQLite就会使用这种机制来避免与shm文件相关的任何不必要的磁盘I/O。然而,在标准posix中不存在这样的机制。</target>
        </trans-unit>
        <trans-unit id="2ce5842569cd9ae6cb873fe122d925e98dfd9e57" translate="yes" xml:space="preserve">
          <source>The shm file consists of one or more hash tables, where each hash table is 32768 bytes in size. Except, a 136-byte header is carved out of the front of the very first hash table, so the first hash table is only 32632 bytes in size. The total size of the shm file is always a multiple of 32768. In most cases, the total size of the shm file is exactly 32768 bytes. The shm file only needs to grow beyond a single hash table if when the wal file grows very large (more than 4079 frames). Since the default &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;automatic checkpoint threshold&lt;/a&gt; is 1000, WAL files rare reach the 4079 threshold needed to make the shm file grow.</source>
          <target state="translated">shm文件由一个或多个哈希表组成，其中每个哈希表的大小为32768字节。除了在第一个哈希表的开头雕刻了一个136字节的标头之外，因此第一个哈希表的大小仅为32632字节。 shm文件的总大小始终是32768的倍数。在大多数情况下，shm文件的总大小恰好是32768字节。如果wal文件变得非常大（超过4079帧），则shm文件仅需要增长到单个哈希表之外。由于默认的&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;自动检查点阈&lt;/a&gt;值为1000，因此WAL文件很少达到使shm文件增长所需的4079阈值。</target>
        </trans-unit>
        <trans-unit id="0d8774149ef596e36906cd1fe56afff10a697841" translate="yes" xml:space="preserve">
          <source>The signature of the xAccess method has been modified to return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and to store its output into an integer pointed to by a parameter, rather than returning the output directly. This change allows the xAccess() method to report failures. In association with this signature change, a new extended error code &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; has been added.</source>
          <target state="translated">已修改xAccess方法的签名，以返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;并将其输出存储到参数指向的整数中，而不是直接返回输出。此更改使xAccess（）方法可以报告失败。与此签名更改相关联，添加了新的扩展错误代码&lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73da15d1378e7e4cecf6c05a9921a5f1b3117f3b" translate="yes" xml:space="preserve">
          <source>The signature of the xCheckReservedLock method on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; has been modified so that it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and stores its boolean result into an integer pointed to by a parameter. In association with this change, a new extended error code &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; has been added.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;上xCheckReservedLock方法的签名已被修改，以便它返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;并将其布尔结果存储到参数所指向的整数中。与此更改关联，添加了新的扩展错误代码&lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23da313c5318bbaf1e11638c6787139e74ceff62" translate="yes" xml:space="preserve">
          <source>The simple, modular design of SQLite makes it a good platform for prototyping new, experimental database language features or ideas.</source>
          <target state="translated">SQLite简单、模块化的设计使其成为一个很好的平台,可以对新的、实验性的数据库语言功能或想法进行原型设计。</target>
        </trans-unit>
        <trans-unit id="2d0de7ad7a0838db1beb185b37e3f4659d20a947" translate="yes" xml:space="preserve">
          <source>The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.</source>
          <target state="translated">通过评估结果集中的聚合和非聚合表达式创建的单行结果集数据,形成了没有GROUP BY子句的聚合查询的结果。没有GROUP BY子句的聚合查询总是只返回一行数据,即使输入数据的行数为零。</target>
        </trans-unit>
        <trans-unit id="9e5842a2d17c6ea95217db027ef9476039d3c1f4" translate="yes" xml:space="preserve">
          <source>The single-argument form of carray() requires a special C-language interface named &quot;sqlite3_carray_bind()&quot; in order to attach values:</source>
          <target state="translated">carray()的单参数形式需要一个名为 &quot;sqlite3_carray_bind()&quot;的特殊C语言接口来附加值。</target>
        </trans-unit>
        <trans-unit id="fee8fe6df1809775fcd62fdf9f110bcf759d94a6" translate="yes" xml:space="preserve">
          <source>The six streaming API xxx_strm() functions serve similar purposes to the corresponding non-streaming API functions:</source>
          <target state="translated">六个流式API xxx_strm()函数的作用与相应的非流式API函数类似。</target>
        </trans-unit>
        <trans-unit id="af903c0dcc364c9d11abbe191c3960a1c5d014f5" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）的第六个参数必须是&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;之一，以在第三个参数中指定文本的编码。如果sqlite3_bind_text64（）的第六个参数不是上面显示的允许值之一，或者文本编码与第六个参数指定的编码不同，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="3a920902ff183846916ffe84129516653c512659" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）的第六个参数必须是&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;之一，以在第三个参数中指定文本的编码。如果sqlite3_bind_text64（）的第六个参数不是上面显示的允许值之一，或者文本编码与第六个参数指定的编码不同，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="e8b06ccbdc8c379a9a470f7c185a0247a80f8e2b" translate="yes" xml:space="preserve">
          <source>The sixth, seventh and eighth parameters passed to the three &quot;sqlite3_create_function*&quot; functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate. A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters. An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc. To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.</source>
          <target state="translated">传递给三个 &quot;sqlite3_create_function*&quot;函数xFunc、xStep和xFinal的第六、第七和第八个参数是实现SQL函数或集合的C语言函数的指针。一个标量SQL函数只需要实现xFunc回调,NULL指针必须作为xStep和xFinal参数传递。聚合SQL函数需要xStep和xFinal的实现,必须为xFunc传递NULL指针。要删除一个现有的SQL函数或聚合函数,必须为这三个函数的回调传递NULL指针。</target>
        </trans-unit>
        <trans-unit id="5a1e0ca7d22b49ccdf57dfbe9e13e610f7e7488a" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">传递给sqlite3_create_window_function的第六，第七，第八和第九个参数（xStep，xFinal，xValue和xInverse）是指向实现新功能的C语言回调的指针。 xStep和xFinal必须都为非NULL。 xValue和xInverse都可以为NULL（在这种情况下会创建常规的聚合函数），或者必须都为非NULL（在这种情况下，新函数可以用作聚合或聚​​合窗口函数）。有关聚合窗口功能实现的更多详细信息，&lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;请参见此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f70d86715eabcca8a7d61d2f6e68b2fc4d6a57e" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">传递给sqlite3_create_window_function的第六，第七，第八和第九个参数（xStep，xFinal，xValue和xInverse）是指向实现新功能的C语言回调的指针。 xStep和xFinal必须都为非NULL。 xValue和xInverse都可以为NULL（在这种情况下会创建常规的聚合函数），或者必须都为非NULL（在这种情况下，新函数可以用作聚合或聚​​合窗口函数）。有关聚合窗口功能实现的更多详细信息，&lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;请参见此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650196bb22cf5bf05d1563df9b31bf781c3e9a6d" translate="yes" xml:space="preserve">
          <source>The size of the blobs in the test data affects performance. The filesystem will generally be faster for larger blobs, since the overhead of open() and close() is amortized over more bytes of I/O, whereas the database will be more efficient in both speed and space as the average blob size decreases.</source>
          <target state="translated">测试数据中的 blobs 大小会影响性能。一般来说,文件系统对于较大的blob会更快,因为open()和close()的开销是通过更多的I/O字节来分摊的,而数据库随着blob平均大小的减小,在速度和空间上都会更有效率。</target>
        </trans-unit>
        <trans-unit id="71ba6b5b378d657456a5945d2ff20a780b1b14d4" translate="yes" xml:space="preserve">
          <source>The size of the lookaside memory pool has a global default value but can also be configured on a connection-by-connection basis. To change the default size of the lookaside memory pool at compile-time, use the &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/a&gt; option. To change the default size of the lookaside memory pool at start-time, use the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface:</source>
          <target state="translated">后备内存池的大小具有全局默认值，但也可以基于逐个连接进行配置。要在编译时更改后备内存池的默认大小，请使用&lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE = &lt;i&gt;SZ，N&lt;/i&gt;&lt;/a&gt;选项。要在启动时更改后备内存池的默认大小，请使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口：</target>
        </trans-unit>
        <trans-unit id="7032e0044fe8cbf0ccd0392512f38ee2b17ffc25" translate="yes" xml:space="preserve">
          <source>The size of the matching term in bytes.</source>
          <target state="translated">匹配项的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="481f99d28cac0daa50062e9ad3a05601840366c0" translate="yes" xml:space="preserve">
          <source>The size of the memory-mapped I/O region cannot be changed while the memory-mapped I/O region is in active use, to avoid unmapping memory out from under running SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior mmap_size is non-zero and there are other SQL statements running concurrently on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">内存映射的I / O区域处于活动状态时，不能更改内存映射的I / O区域的大小，以避免在正在运行的SQL语句中取消内存的映射。因此，如果先前的mmap_size不为零，并且在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上同时运行其他SQL语句，则mmap_size编译指示可能为空。</target>
        </trans-unit>
        <trans-unit id="19c67c781984d7843a725bf421c45281605af01e" translate="yes" xml:space="preserve">
          <source>The snippet function first attempts to find a fragment of text consisting of</source>
          <target state="translated">代码段函数首先尝试查找由以下内容组成的文本片段</target>
        </trans-unit>
        <trans-unit id="54b3f9fdd628ef57cd97424e1a01116d0ba15ccd" translate="yes" xml:space="preserve">
          <source>The snippet function is used to create formatted fragments of document text for display as part of a full-text query results report. The snippet function may be passed between one and six arguments, as follows:</source>
          <target state="translated">snippet函数用于创建格式化的文档文本片段,以便作为全文查询结果报告的一部分显示。可以通过一个到六个参数来传递snippet函数,如下所示:</target>
        </trans-unit>
        <trans-unit id="25ab90403f978d997e2573cced370b12d71d602c" translate="yes" xml:space="preserve">
          <source>The snippet() function is similar to highlight(), except that instead of returning entire column values, it automatically selects and extracts a short fragment of document text to process and return. The snippet() function must be passed five parameters following the table name argument:</source>
          <target state="translated">snippet()函数类似于highlight(),不同的是,它不是返回整个列的值,而是自动选择和提取文档文本的一个短片段来处理和返回。snippet()函数必须在表名参数后传递五个参数。</target>
        </trans-unit>
        <trans-unit id="650db23255aac8aa4103c6f6d9992ba8c2854051" translate="yes" xml:space="preserve">
          <source>The soft heap limit is &quot;soft&quot; in this sense: If SQLite is not able to free up enough auxiliary memory to stay below the limit, it goes ahead and allocates the extra memory and exceeds its limit. This occurs under the theory that it is better to use additional memory than to fail outright.</source>
          <target state="translated">软堆限制在这个意义上是 &quot;软 &quot;的:如果SQLite无法释放出足够的辅助内存,无法保持在限额以下,它就会去分配额外的内存,并超过其限额。这种情况发生的理论是,使用额外的内存比直接失败要好。</target>
        </trans-unit>
        <trans-unit id="f259c7b18142819d8b2454c94e82cad365d3cfbd" translate="yes" xml:space="preserve">
          <source>The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">如果以下一个或多个条件为真,软堆限制在当前的实施中不会被执行。</target>
        </trans-unit>
        <trans-unit id="62f643dbe59889b37bb6ee27203ce861b75e4df1" translate="yes" xml:space="preserve">
          <source>The soft heap limit is set to zero.</source>
          <target state="translated">软堆限制设置为零。</target>
        </trans-unit>
        <trans-unit id="1e9f9417ca080fbcc56641af6510e79f88f545c2" translate="yes" xml:space="preserve">
          <source>The soft heap limit may not be greater than the hard heap limit. If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N) is invoked with a value of N that is greater than the hard heap limit, the the soft heap limit is set to the value of the hard heap limit. The soft heap limit is automatically enabled whenever the hard heap limit is enabled. When sqlite3_hard_heap_limit64(N) is invoked and the soft heap limit is outside the range of 1..N, then the soft heap limit is set to N. Invoking sqlite3_soft_heap_limit64(0) when the hard heap limit is enabled makes the soft heap limit equal to the hard heap limit.</source>
          <target state="translated">软堆限制不能大于硬堆限制。如果启用了硬堆限制,并且调用sqlite3_soft_heap_limit(N)时,N的值大于硬堆限制,则软堆限制被设置为硬堆限制的值。每当启用硬堆限制时,软堆限制就会自动启用。当调用sqlite3_hard_heap_limit64(N),并且软堆限制在1...N范围之外时,软堆限制被设置为N,当硬堆限制被启用时,调用sqlite3_soft_heap_limit64(0)使得软堆限制等于硬堆限制。</target>
        </trans-unit>
        <trans-unit id="84963983acb45095ae249428915953ba1875b5f1" translate="yes" xml:space="preserve">
          <source>The solution was computed in less than 300 milliseconds on a modern workstation.</source>
          <target state="translated">在现代工作站上,该解决方案的计算时间不到300毫秒。</target>
        </trans-unit>
        <trans-unit id="d8fc439428a4b57b8a635dfdc3bc6c9e9458a598" translate="yes" xml:space="preserve">
          <source>The solver works by adding new entries to the &quot;x&quot; recursive table. Given prior entries, the recursive-select tries to fill in a single new position with all values between 1 and 9 that actually work in that position. The complicated &quot;NOT EXISTS&quot; subquery is the magic that figures out whether or not each candidate &quot;s&quot; string is a valid sudoku puzzle or not.</source>
          <target state="translated">求解器通过向 &quot;x &quot;递归表添加新条目来工作。给定先前的条目,递归选择试图用1到9之间的所有值来填补一个新的位置,而这些值实际上是在这个位置上工作的。复杂的 &quot;NOT EXISTS &quot;子查询是计算出每个候选 &quot;s &quot;字符串是否为有效数独谜题的法宝。</target>
        </trans-unit>
        <trans-unit id="a81e5007b5735cbaaaf41fe92b085a6bb28859ca" translate="yes" xml:space="preserve">
          <source>The sorter can use auxiliary helper threads to increase real-time response. This feature is off by default and may be enabled using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command or the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option.</source>
          <target state="translated">排序器可以使用辅助帮助器线程来增加实时响应。此功能默认情况下处于关闭状态，可以使用&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA线程&lt;/a&gt;命令或&lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt;编译时选项启用。</target>
        </trans-unit>
        <trans-unit id="f3082f533e58c712999cbf940673f567d8a29017" translate="yes" xml:space="preserve">
          <source>The soundex(X) function returns a string that is the soundex encoding of the string X. The string &quot;?000&quot; is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; compile-time option is used when SQLite is built.</source>
          <target state="translated">soundex（X）函数返回的字符串是字符串X的soundex编码。如果参数为NULL或不包含ASCII字母字符，则返回字符串&amp;ldquo;？000&amp;rdquo;。默认情况下，SQLite会省略此功能。仅当构建SQLite时使用&lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt;编译时选项时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="9611e60fec986c004f40bb3986af444fd02497aa" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">在备份操作正在进行或初始化时，应用程序可以将源&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;用于其他目的。如果将SQLite编译并配置为支持线程安全数据库连接，则可以从其他线程中同时使用源数据库连接。</target>
        </trans-unit>
        <trans-unit id="d46770cf519d64fb4869e93bb4ebad2a0d214ebb" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">在备份操作正在进行或初始化时，应用程序可以将源&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;用于其他目的。如果将SQLite编译并配置为支持线程安全数据库连接，则可以从其他线程中同时使用源数据库连接。</target>
        </trans-unit>
        <trans-unit id="cb98bce78cf336a453aacfd68f1f2a70ccf1bb9e" translate="yes" xml:space="preserve">
          <source>The source code files for other SQL database engines typically begin with a comment describing your legal rights to view and copy that file. The SQLite source code contains no license since it is not governed by copyright. Instead of a license, the SQLite source code offers a blessing:</source>
          <target state="translated">其他SQL数据库引擎的源代码文件通常以注释开头,说明你查看和复制该文件的合法权利。SQLite源代码不包含许可证,因为它不受版权的约束。SQLite源代码提供的不是许可证,而是祝福。</target>
        </trans-unit>
        <trans-unit id="b230daf41ab11e7921fa2a959263c09c6fe7e609" translate="yes" xml:space="preserve">
          <source>The source code for Geopoly is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is not included in the library unless the &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Geopoly的源代码包含在&lt;a href=&quot;amalgamation&quot;&gt;合并中，&lt;/a&gt;但没有包含在库中，除非使用&lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="9ce563d47e369284dcc9eb90d209f5fe50c9d87d" translate="yes" xml:space="preserve">
          <source>The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source code. (The documentation and test code is a different matter - some sections of documentation and test logic are governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with the SQLite source code.</source>
          <target state="translated">SQLite的源代码是在公共领域。没有对核心源代码的任何部分提出版权要求。文档和测试代码是另一回事--文档和测试逻辑的某些部分受开源许可证的约束)。SQLite核心软件的所有贡献者都签署了宣誓书,明确表示不承认代码中的任何版权利益。这意味着任何人都可以合法地对SQLite源代码做任何他们想做的事情。</target>
        </trans-unit>
        <trans-unit id="1cfec4458134c689073b56a3f124a05cfee319a4" translate="yes" xml:space="preserve">
          <source>The source code in public SQLite releases uses unix line endings (ASCII code 10: &quot;newline&quot; only, NL) and spaces instead of tabs. If you will be changing the line ending to windows-style line endings (ASCII codes 13, 10: &quot;carriage-return&quot; and &quot;newline&quot;; CR-NL) or if you will be changing space indents into tab indents, &lt;b&gt;make that change now&lt;/b&gt; before you check in the baseline. The merging process will only work well if the differences between the public and the private branches are minimal. If every single line of the source file is changed in the private branch because you changed from NL to CR-NL line endings, then the merge steps will not work correctly.</source>
          <target state="translated">公共SQLite版本中的源代码使用unix行尾（ASCII代码10：仅&amp;ldquo; newline&amp;rdquo;，NL）和空格而不是制表符。如果要将行尾更改为Windows样式的行尾（ASCII代码13、10：&amp;ldquo; carriage-return&amp;rdquo;和&amp;ldquo; newline&amp;rdquo;； CR-NL），或者要将空格缩进更改为制表符缩进，请&lt;b&gt;进行更改现在，&lt;/b&gt;在检查基线之前。只有在公共部门和私人部门之间的差异很小的情况下，合并过程才能很好地工作。如果源文件的每一行都在私人分支中更改（因为您从NL更改为CR-NL行尾），则合并步骤将无法正常进行。</target>
        </trans-unit>
        <trans-unit id="c71fe30151d8d1ffe822e83fe610e421f8822069" translate="yes" xml:space="preserve">
          <source>The source code module that implements the spellfix1 virtual table also implements several SQL functions that might be useful to applications that employ spellfix1 or for testing or diagnostic work while developing applications that use spellfix1. The following auxiliary functions are available:</source>
          <target state="translated">实现spellfix1虚拟表的源码模块还实现了几个SQL函数,这些函数可能对采用spellfix1的应用程序或开发使用spellfix1的应用程序时的测试或诊断工作有用。以下是可用的辅助函数。</target>
        </trans-unit>
        <trans-unit id="06e0d7a5506cbf178b35ec85914ad01a3f38017c" translate="yes" xml:space="preserve">
          <source>The source code to SQLite is designed to be readable and accessible to the average programmer. All procedures and data structures and many automatic variables are carefully commented with useful information about what they do. Boilerplate commenting is omitted.</source>
          <target state="translated">SQLite的源代码被设计成对普通程序员来说是可读和可访问的。所有的程序和数据结构以及许多自动变量都有仔细的注释,并提供了它们的有用信息。锅炉板的注释被省略了。</target>
        </trans-unit>
        <trans-unit id="042c70a1cba19758906aae3ec84cad7dc8c53383" translate="yes" xml:space="preserve">
          <source>The source code to the SQLite R*Tree module is included as part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is disabled by default. To enable the R*Tree module, simply compile with the &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C-preprocessor macro defined. With many compilers, this is accomplished by adding the option &quot;-DSQLITE_ENABLE_RTREE=1&quot; to the compiler command-line.</source>
          <target state="translated">SQLite R * Tree模块的源代码包含在&lt;a href=&quot;amalgamation&quot;&gt;合并中，&lt;/a&gt;但默认情况下处于禁用状态。要启用R * Tree模块，只需使用定义的&lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C预处理器宏进行编译。对于许多编译器，这是通过在编译器命令行中添加选项&amp;ldquo; -DSQLITE_ENABLE_RTREE = 1&amp;rdquo;来实现的。</target>
        </trans-unit>
        <trans-unit id="a40cbeb8ac52569bca99e948856ab4db846ed02b" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">字节码引擎的源代码位于&lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;源文件中。本文档中的&lt;a href=&quot;opcode#codes&quot;&gt;操作码定义&lt;/a&gt;源自该源文件中的注释。源代码注释是有关字节码引擎的规范信息源。如有疑问，请参考源代码。</target>
        </trans-unit>
        <trans-unit id="ec46398b190fd4712f7c9072a7d45135878f4398" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;https://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">字节码引擎的源代码位于&lt;a href=&quot;https://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;源文件中。本文档中的&lt;a href=&quot;opcode#codes&quot;&gt;操作码定义&lt;/a&gt;源自该源文件中的注释。源代码注释是有关字节码引擎的规范信息源。如有疑问，请参考源代码。</target>
        </trans-unit>
        <trans-unit id="013177e363c21284dd8426d7c41bb413bf325a0a" translate="yes" xml:space="preserve">
          <source>The source code to the software that runs the checklists is stored in its own Fossil repository at &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt;.</source>
          <target state="translated">运行清单的软件的源代码存储在其自己的Fossil信息库中，&lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;网址&lt;/a&gt;为https://www.sqlite.org/checklistapp。</target>
        </trans-unit>
        <trans-unit id="79b8e8d26e2fd4c36bb8b15bd366cedd02031771" translate="yes" xml:space="preserve">
          <source>The source code to the sqlite3 command line interface is in a single file named &quot;shell.c&quot;. The shell.c source file is generated from other sources, but most of the code for shell.c can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c.in&lt;/a&gt;. (Regenerate shell.c by typing &quot;make shell.c&quot; from the canonical source tree.) &lt;a href=&quot;howtocompile&quot;&gt;Compile&lt;/a&gt; the shell.c file (together with the &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 library source code&lt;/a&gt;) to generate the executable. For example:</source>
          <target state="translated">sqlite3命令行界面的源代码位于一个名为&amp;ldquo; shell.c&amp;rdquo;的文件中。shell.c源文件是从其他来源生成的，但是大多数shell.c代码可以在&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c.in中&lt;/a&gt;找到。（通过从规范的源代码树中键入&amp;ldquo; make shell.c&amp;rdquo;来重新生成shell.c。）&lt;a href=&quot;howtocompile&quot;&gt;编译&lt;/a&gt; shell.c文件（与&lt;a href=&quot;amalgamation&quot;&gt;sqlite3库源代码一起&lt;/a&gt;）以生成可执行文件。例如：</target>
        </trans-unit>
        <trans-unit id="3baebed042eebfba10dcbc501e7f4785bd1f6d07" translate="yes" xml:space="preserve">
          <source>The source file and entry point are named for &quot;unionvtab&quot; instead of &quot;swarmvtab&quot;. Unionvtab is a &lt;a href=&quot;unionvtab&quot;&gt;separately documented&lt;/a&gt; virtual table that is bundled with swarmvtab.</source>
          <target state="translated">源文件和入口点以&amp;ldquo; unionvtab&amp;rdquo;而不是&amp;ldquo; swarmvtab&amp;rdquo;命名。Unionvtab是&lt;a href=&quot;unionvtab&quot;&gt;单独记录的&lt;/a&gt;虚拟表，与swarmvtab捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="f3fba365763538ecbddb6c57bd7009fd058f9084" translate="yes" xml:space="preserve">
          <source>The special &quot;:memory:&quot; filename also works when using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;. For example:</source>
          <target state="translated">当使用&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;时，特殊的&amp;ldquo;：memory：&amp;rdquo;文件名也可以使用。例如：</target>
        </trans-unit>
        <trans-unit id="e94ff833d41c9d30c15767ac9e7aeb85daf442aa" translate="yes" xml:space="preserve">
          <source>The special UPSERT processing happens only for uniqueness constraint on the table that is receiving the INSERT. A &quot;uniqueness constraint&quot; is an explicit UNIQUE or PRIMARY KEY constraint within the CREATE TABLE statement, or a &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt;. UPSERT does not intervene for failed NOT NULL or foreign key constraints or for constraints that are implemented using triggers.</source>
          <target state="translated">特殊的UPSERT处理仅针对接收INSERT的表上的唯一性约束而发生。&amp;ldquo;唯一性约束&amp;rdquo;是CREATE TABLE语句中的显式UNIQUE或PRIMARY KEY约束，或者是&lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;唯一索引&lt;/a&gt;。UPSERT不会针对失败的NOT NULL或外键约束或使用触发器实现的约束进行干预。</target>
        </trans-unit>
        <trans-unit id="2e94e3f68bdf7fc07fc0dcd878c089797a3fe9a2" translate="yes" xml:space="preserve">
          <source>The special filename &quot;:memory:&quot; can be used anywhere that a database filename is permitted. For example, it can be used as the</source>
          <target state="translated">特殊的文件名&quot;:memory:&quot;可以用在任何允许数据库文件名的地方。例如,它可以被用作</target>
        </trans-unit>
        <trans-unit id="dff68709141a31a267598fa549dc38cfbd61c946" translate="yes" xml:space="preserve">
          <source>The special processing for opening ZIP archives is a trick of the command-line shell, not the core SQLite library. So if you want to open a ZIP archive as a database in your application, you will need to activate the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; module then run an appropriate &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">打开ZIP存档的特殊处理是命令行外壳的技巧，而不是核心SQLite库。因此，如果要在应用程序中将ZIP存档作为数据库打开，则需要激活&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表&lt;/a&gt;模块，然后运行适当的&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="29bca994e11cb6f841a93aac5cdb8471376e38df" translate="yes" xml:space="preserve">
          <source>The specified column of row iRow contains a value that is not a TEXT or BLOB value,</source>
          <target state="translated">行iRow的指定列包含一个不是TEXT或BLOB的值。</target>
        </trans-unit>
        <trans-unit id="06e48e6df6f51c35512fa45acc8a0e8a634c95f8" translate="yes" xml:space="preserve">
          <source>The speedtest1.c program is updated from time to time as the SQLite developers' understanding of what constitutes &quot;typical&quot; usage evolves.</source>
          <target state="translated">speedtest1.c程序会随着SQLite开发人员对 &quot;典型 &quot;用法的理解而不时更新。</target>
        </trans-unit>
        <trans-unit id="5446f248e6916745d646dc3f5e88e893b3ad00cc" translate="yes" xml:space="preserve">
          <source>The speedtest1.c workload that is being measured tries to be representative of a wide range of typical uses of SQLite. But every application is different. The speedtest1.c workload might not be a good proxy for the kinds of activities performed by some applications. The SQLite developers are constantly working to improve the speedtest1.c program, to make it a better proxy for actual SQLite usage. Community feedback is welcomed.</source>
          <target state="translated">正在测量的 speedtest1.c 工作负载试图代表 SQLite 的各种典型用途。但每个应用程序都是不同的。speedtest1.c 工作负载可能无法很好地代表某些应用程序所执行的活动类型。SQLite 开发人员正在不断努力改进 speedtest1.c 程序,使其更好地代表实际 SQLite 使用情况。欢迎社区的反馈意见。</target>
        </trans-unit>
        <trans-unit id="92167de554e681259504f6e2f3edf942b7026bd6" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table creates a single shadow table named &quot;%_vocab&quot; (where the % is replaced by the name of the virtual table; Ex: &quot;demo_vocab&quot; for the &quot;demo&quot; virtual table). the shadow table contains the following columns:</source>
          <target state="translated">spellfix1虚拟表创建了一个名为&quot;%_vocab &quot;的影子表(其中%被虚拟表的名称所代替;Ex:&quot;demo_vocab &quot;代表 &quot;demo &quot;虚拟表),影子表包含以下列。</target>
        </trans-unit>
        <trans-unit id="f9097157fe13f14b48b89617ee87aed62da83c73" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table uses editdist3 if the &quot;edit_cost_table=TABLE&quot; option is specified as an argument when the spellfix1 virtual table is created. But editdist3 can also be tested directly using the built-in &quot;editdist3()&quot; SQL function. The editdist3() SQL function has 3 forms:</source>
          <target state="translated">如果在创建spellfix1虚拟表时指定 &quot;edit_cost_table=TABLE &quot;选项作为参数,那么spellfix1虚拟表就会使用editdist3。但是editdist3也可以直接使用内置的 &quot;editdist3()&quot;SQL函数进行测试。editdist3()SQL函数有3种形式。</target>
        </trans-unit>
        <trans-unit id="e416e23f51996e4d87d84d45407db4bd482280e4" translate="yes" xml:space="preserve">
          <source>The sqlar_compress(X) function attempts to compress a copy of the string or blob X using the &lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt; algorithm and returns the result as a blob. If the input X is incompressible, then a copy of X is returned. This routine is used when inserting content into an SQLite Archive.</source>
          <target state="translated">sqlar_compress（X）函数尝试使用&lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt;算法压缩字符串或Blob X的副本，并将结果作为Blob返回。如果输入X是不可压缩的，则返回X的副本。在将内容插入SQLite存档时使用此例程。</target>
        </trans-unit>
        <trans-unit id="0c132e268d7082089985d58b1716bee78c9b6c72" translate="yes" xml:space="preserve">
          <source>The sqlar_uncompress(Y,SZ) function will undo the compression accomplished by sqlar_compress(X). The Y parameter is the compressed content (the output from a prior call to sqlar_compress()) and SZ is the original uncompressed size of the input X that generated Y. If SZ is less than or equal to the size of Y, that indicates that no compression occurred, and so sqlar_uncompress(Y,SZ) returns a copy of Y. Otherwise, sqlar_uncompress(Y,SZ) runs the Inflate algorithm on Y to uncompress it and restore it to its original form and returns the uncompressed content. This routine is used when extracting content from an SQLite Archive.</source>
          <target state="translated">sqlar_uncompress(Y,SZ)函数将撤销由sqlar_compress(X)完成的压缩。如果SZ小于或等于Y的大小,则表明没有发生压缩,所以sqlar_uncompress(Y,SZ)返回Y的副本。否则,sqlar_uncompress(Y,SZ)会在Y上运行Inflate算法来解压缩,并将其恢复到原始形式,然后返回未压缩的内容。这个例程在从SQLite Archive中提取内容时使用。</target>
        </trans-unit>
        <trans-unit id="9894bd2027e1ec7fe1defc073eb794af8cfcddba" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility does not (currently) display differences in &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGERs&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt;.</source>
          <target state="translated">所述sqldiff.exe实用程序执行中不（目前）显示差异&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;或&lt;a href=&quot;lang_createview&quot;&gt;意见&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1eec35831f2ddb18882fbe495fb78b6e88f27f70" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility is unable to compute differences for rowid tables for which the rowid is inaccessible. An example of a table with an inaccessible rowid is:</source>
          <target state="translated">sqldiff.exe 工具无法计算无法访问 rowid 的表的差异。下面是一个无法访问的表的例子。</target>
        </trans-unit>
        <trans-unit id="199f0fae6d132ab01eeef495a83df7f5456338b1" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility works by finding rows in the source and destination that are logical &quot;pairs&quot;. The default behavior is to treat two rows as pairs if they are in tables with the same name and they have the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, or in the case of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table if they have the same &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. Any differences in the content of paired rows are output as UPDATEs. Rows in the source database that could not be paired are output as DELETEs. Rows in the destination database that could not be paired are output as INSERTs.</source>
          <target state="translated">sqldiff.exe实用程序通过在源和目标中查找逻辑&amp;ldquo;对&amp;rdquo;的行来工作。默认行为是，如果两行位于相同名称的表中且具有相同的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则将它们视为对；如果为&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，则将它们具有相同的&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;视为一对。成对行内容的任何差异都将作为UPDATE输出。源数据库中无法配对的行将作为DELETE输出。目标数据库中无法配对的行将作为INSERT输出。</target>
        </trans-unit>
        <trans-unit id="5a94a70315a765a01576195e900e88922987242a" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in 14 different formats:</source>
          <target state="translated">sqlite3程序能够以14种不同的格式显示查询结果。</target>
        </trans-unit>
        <trans-unit id="8a33930cce71afaf2bac4391a7d92f2102fe6799" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in eight different formats: &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;, and &quot;tcl&quot;. You can use the &quot;.mode&quot; dot command to switch between these output formats.</source>
          <target state="translated">sqlite3程序能够以八种不同的格式显示查询结果。&quot;csv&quot;、&quot;column&quot;、&quot;html&quot;、&quot;insert&quot;、&quot;line&quot;、&quot;list&quot;、&quot;quote&quot;、&quot;tabs &quot;和 &quot;tcl&quot;。你可以使用&quot;.mode &quot;点命令来切换这些输出格式。</target>
        </trans-unit>
        <trans-unit id="c934dde95758c5fad9d43c84ef7f4c41bf3fe114" translate="yes" xml:space="preserve">
          <source>The sqlite3 program provides several convenience commands that are useful for looking at the schema of the database. There is nothing that these commands do that cannot be done by some other means. These commands are provided purely as a shortcut.</source>
          <target state="translated">sqlite3程序提供了几个方便的命令,这些命令对查看数据库的模式很有用。这些命令所做的事情没有什么是不能通过其他方式完成的。这些命令纯粹是作为一种快捷方式提供的。</target>
        </trans-unit>
        <trans-unit id="d730ebfc68ed44661fe9aaa4784f842bff23a6ec" translate="yes" xml:space="preserve">
          <source>The sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocate error occurs.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)例程在第一次调用时,如果N小于或等于0,或者发生内存分配错误,则返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="a781b80076608933fb39f35323ee417edf53e9fb" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer utility program is updated to provide better descriptions and to compute a more accurate estimate for &quot;Non-sequential pages&quot;</source>
          <target state="translated">sqlite3_analyzer实用程序已经更新,以提供更好的描述,并计算出更准确的 &quot;非连续页面 &quot;估计值。</target>
        </trans-unit>
        <trans-unit id="cea6cec9b3cecf3cdb8b21b8c439ffacaf7e4757" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe Utility Program</source>
          <target state="translated">sqlite3_analyzer.exe实用程序。</target>
        </trans-unit>
        <trans-unit id="08064e181ad262ed7b2155684ee88c71ec311b40" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe utility is updated to report the depth of each btree and to show the average fanout for indexes and WITHOUT ROWID tables.</source>
          <target state="translated">sqlite3_analyzer.exe实用程序已经更新,以报告每个btree的深度,并显示索引和WITHOUT ROWID表的平均扇出。</target>
        </trans-unit>
        <trans-unit id="69ea749b99043a4585c42b36d581974b4510bba7" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup对象记录有关正在进行的联机备份操作的状态信息。所述sqlite3_backup目的通过一个调用创建到&lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init（） &lt;/a&gt;，并通过呼叫销毁&lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff5c92c4105199925092609d2d9f802d1fa55672" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup对象记录有关正在进行的联机备份操作的状态信息。所述sqlite3_backup目的通过一个调用创建到&lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（） &lt;/a&gt;，并通过呼叫销毁&lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db586a6cde9f4397b1aba32074e60460ba79310a" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs report values stored by the previous call to sqlite3_backup_step(), they do not actually inspect the source database file. This means that if the source database is written to by another thread or process after the call to sqlite3_backup_step() returns but before the values returned by sqlite3_backup_remaining() and sqlite3_backup_pagecount() are used, the values may be technically incorrect. This is not usually a problem.</source>
          <target state="translated">sqlite3_backup_remaining()和 sqlite3_backup_pagecount()API报告之前调用 sqlite3_backup_step()所存储的值,它们实际上并不检查源数据库文件。这意味着,如果在调用 sqlite3_backup_step()返回之后,但在使用 sqlite3_backup_remaining()和 sqlite3_backup_pagecount()返回的值之前,源数据库被另一个线程或进程写入,那么这些值在技术上可能是不正确的。这通常不是一个问题。</target>
        </trans-unit>
        <trans-unit id="ab13e83a5eec05a800456f808bd2ed14f96ad7d8" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() routine returns the number of pages still to be backed up at the conclusion of the most recent sqlite3_backup_step(). The sqlite3_backup_pagecount() routine returns the total number of pages in the source database at the conclusion of the most recent sqlite3_backup_step(). The values returned by these functions are only updated by sqlite3_backup_step(). If the source database is modified in a way that changes the size of the source database or the number of pages remaining, those changes are not reflected in the output of sqlite3_backup_pagecount() and sqlite3_backup_remaining() until after the next sqlite3_backup_step().</source>
          <target state="translated">sqlite3_backup_remaining()例程返回最近一次 sqlite3_backup_step()结束时仍然需要备份的页面数。sqlite3_backup_pagecount()例程返回最近一次 sqlite3_backup_step()结束时源数据库的总页数。这些函数返回的值只由 sqlite3_backup_step()更新。如果源数据库被修改,改变了源数据库的大小或剩余页数,这些改变不会反映在sqlite3_backup_pagecount()和sqlite3_backup_remaining()的输出中,直到下一个sqlite3_backup_step()之后。</target>
        </trans-unit>
        <trans-unit id="027c7809f8a158ea3a080d548eaba037441f7cc5" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">该sqlite3_backup_step（）可能返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;如果</target>
        </trans-unit>
        <trans-unit id="44bfd22dba6c2a0335c1b72cfe8865a0ed15325c" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">该sqlite3_backup_step（）可能返回&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;如果</target>
        </trans-unit>
        <trans-unit id="a2f8db9336dd78e8265a2d46cc59a9e446011dc7" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *例程成功返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;，如果出现任何&lt;a href=&quot;rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果字符串或BLOB的大小超过规定的限制，可能会返回&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）或&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;。如果参数索引超出范围，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt;。如果malloc（）失败，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb0da7fe06be85118ba3dab99ff46185b6777bbe" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *例程成功返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;，如果出现任何&lt;a href=&quot;../rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果字符串或BLOB的大小超过规定的限制，可能会返回&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）或&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;。如果参数索引超出范围，则返回&lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;。如果malloc（）失败，则返回&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f71713542739e9593b1adb467245384ef671786" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P，N）接口在&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; P中返回第N个&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL参数&lt;/a&gt;的名称。形式为&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;的SQL参数有一个名称，分别是字符串&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;。换句话说，首字母&amp;ldquo;：&amp;rdquo;或&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;或&amp;ldquo;？&amp;rdquo;包含在名称中。形式为&amp;ldquo;？&amp;rdquo;的参数没有后面的整数的名字没有名字，被称为&amp;ldquo;无名&amp;rdquo;或&amp;ldquo;匿名参数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8f7478b82c93544aa582bd52cdb8be854dddfaed" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P，N）接口在&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; P中返回第N个&lt;a href=&quot;bind_blob&quot;&gt;SQL参数&lt;/a&gt;的名称。形式为&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;的SQL参数有一个名称，分别是字符串&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;。换句话说，首字母&amp;ldquo;：&amp;rdquo;或&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;或&amp;ldquo;？&amp;rdquo;包含在名称中。形式为&amp;ldquo;？&amp;rdquo;的参数没有后面的整数的名字没有名字，被称为&amp;ldquo;无名&amp;rdquo;或&amp;ldquo;匿名参数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2f7ba9ace88be98840180479bfcb11ff0ebe16ce" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S，I，P，T，D）例程使已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S中的第I个参数的SQL值为NULL，但也与类型T的指针P关联。D为NULL指针或指向P的析构函数的指针。使用P完成时，SQLite将使用P的单个参数调用析构函数D。T参数应为静态字符串，最好是字符串文字。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="658c91c6c69fa0e297b2600c0a7ae1e8d41b306a" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S，I，P，T，D）例程使已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S中的第I个参数的SQL值为NULL，但也与类型T的指针P关联。D为NULL指针或指向P的析构函数的指针。使用P完成时，SQLite将使用P的单个参数调用析构函数D。T参数应为静态字符串，最好是字符串文字。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="6397a7b2569f0831356316d22abee5d260da2f56" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）例程绑定长度为N的BLOB，并用零填充。在处理过程中，zeroblob使用固定数量的内存（仅保留一个整数即可容纳其大小）。Zeroblob旨在用作BLOB的占位符，其内容随后使用&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;例程编写。零blob的负值将导致零长度BLOB。</target>
        </trans-unit>
        <trans-unit id="c43ef2df76e0304e4b4beb3c8e7c5dbefc82b96b" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）例程绑定长度为N的BLOB，并用零填充。在处理过程中，zeroblob使用固定数量的内存（仅保留一个整数即可容纳其大小）。Zeroblob旨在用作BLOB的占位符，其内容随后使用&lt;a href=&quot;blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;例程编写。零blob的负值将导致零长度BLOB。</target>
        </trans-unit>
        <trans-unit id="3d2cce49ac08682bc109d88559efafcb5bc906c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D，X，P）例程设置一个回调函数X，只要在另一个线程或进程将表锁定时尝试访问与&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 相关联的数据库表，都可以使用参数P调用该回调函数。sqlite3_busy_handler（）接口用于实现&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3363e5f93709d191e40f4d06f477acdab0e375e" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D，X，P）例程设置一个回调函数X，只要在另一个线程或进程将表锁定时尝试访问与&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 相关联的数据库表，都可以使用参数P调用该回调函数。sqlite3_busy_handler（）接口用于实现&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;和&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8d93853c1f8ff5d06942fd5a08d82650ba96772" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）和sqlite3_close_v2（）例程是&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的析构函数。如果&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象成功销毁并且所有关联资源都已释放，则对sqlite3_close（）和sqlite3_close_v2（）的调用返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3b661e4a47ed928f3b7e88dd929f7831fe5385b" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）和sqlite3_close_v2（）例程是&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的析构函数。如果&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象成功销毁并且所有关联资源都已释放，则对sqlite3_close（）和sqlite3_close_v2（）的调用返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e35c3e04c8fe7269b95a0494cefdd5cde7acf02" translate="yes" xml:space="preserve">
          <source>The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence. The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed. The fourth parameter to the callback is the name of the collating sequence in UTF-8. For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.</source>
          <target state="translated">sqlite3_collation_needed()例程注册了一个回调,如果遇到未知的整理序列,数据库引擎会调用这个回调。该回调可以查找一个合适的比较函数,并根据需要调用sqlite_3_create_collation()。回调的第四个参数是整理序列的名称,用UTF-8表示。对于sqlite3_collation_need16(),回调会以UTF-16主机字节顺序发送整理序列名。</target>
        </trans-unit>
        <trans-unit id="289668a545984e8fa7c4b426fa20f850363028a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_decltype() routine returns text which is the declared type of the column in the CREATE TABLE statement. For an expression, the return type is an empty string. sqlite3_column_name() returns the name of the Nth column. sqlite3_column_bytes() returns the number of bytes in a column that has type BLOB or the number of bytes in a TEXT string with UTF-8 encoding. sqlite3_column_bytes16() returns the same value for BLOBs but for TEXT strings returns the number of bytes in a UTF-16 encoding. sqlite3_column_blob() return BLOB data. sqlite3_column_text() return TEXT data as UTF-8. sqlite3_column_text16() return TEXT data as UTF-16. sqlite3_column_int() return INTEGER data in the host machines native integer format. sqlite3_column_int64() returns 64-bit INTEGER data. Finally, sqlite3_column_double() return floating point data.</source>
          <target state="translated">sqlite3_column_decltype()例程返回的文本是在CREATE TABLE语句中声明的列的类型。sqlite3_column_name()返回第N个列的名称。 sqlite3_column_bytes()返回BLOB类型的列的字节数或者UTF-8编码的TEXT字符串的字节数。 sqlite3_column_bytes16()对BLOB返回相同的值,但是对TEXT字符串返回UTF-16编码的字节数。sqlite3_column_blob()返回BLOB数据。 sqlite3_column_text()返回UTF-8格式的TEXT数据。 sqlite3_column_text16()返回UTF-16格式的TEXT数据。 sqlite3_column_int()返回主机本地整数格式的INTEGER数据。最后,sqlite3_column_double()返回浮点数据。</target>
        </trans-unit>
        <trans-unit id="a9b38d21f857b4d104b01ccf828564edcab9302b" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）例程返回结果列的初始数据类型的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型代码&lt;/a&gt;。返回的值是&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。 sqlite3_column_type（）的返回值可用于确定应使用前六个接口中的哪个来提取列值。 sqlite3_column_type（）返回的值仅在没有针对该值进行自动类型转换的情况下才有意义。类型转换后，调用sqlite3_column_type（）的结果是不确定的，尽管无害。类型转换后，SQLite的未来版本可能会更改sqlite3_column_type（）的行为。</target>
        </trans-unit>
        <trans-unit id="d87c623fe2ec1f08f5218d69ec07d1b6f1fe406e" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）例程返回结果列的初始数据类型的&lt;a href=&quot;c_blob&quot;&gt;数据类型代码&lt;/a&gt;。返回的值是&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。 sqlite3_column_type（）的返回值可用于确定应使用前六个接口中的哪个来提取列值。 sqlite3_column_type（）返回的值仅在没有针对该值进行自动类型转换的情况下才有意义。类型转换后，调用sqlite3_column_type（）的结果是不确定的，尽管无害。类型转换后，SQLite的未来版本可能会更改sqlite3_column_type（）的行为。</target>
        </trans-unit>
        <trans-unit id="80c9429e83e0f6600057106ffc072b05d6e8df14" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）接口注册一个回调函数，只要&lt;a href=&quot;../lang_transaction&quot;&gt;提交&lt;/a&gt;事务即可调用该回调函数。先前调用sqlite3_commit_hook（）为同一数据库连接设置的任何回调都将被覆盖。 sqlite3_rollback_hook（）接口注册一个回调函数，每当事务&lt;a href=&quot;../lang_transaction&quot;&gt;回滚&lt;/a&gt;时，该回调函数就会被调用。先前调用sqlite3_rollback_hook（）为同一数据库连接设置的任何回调都将被覆盖。 pArg参数传递给回调。如果提交挂钩函数上的回调返回非零，则提交将转换为回滚。</target>
        </trans-unit>
        <trans-unit id="c831f98581f1e28276e947cc54e55e8093cff2bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）接口注册一个回调函数，只要&lt;a href=&quot;lang_transaction&quot;&gt;提交&lt;/a&gt;事务即可调用该回调函数。先前调用sqlite3_commit_hook（）为同一数据库连接设置的任何回调都将被覆盖。 sqlite3_rollback_hook（）接口注册一个回调函数，每当事务&lt;a href=&quot;lang_transaction&quot;&gt;回滚&lt;/a&gt;时，该回调函数就会被调用。先前调用sqlite3_rollback_hook（）为同一数据库连接设置的任何回调都将被覆盖。 pArg参数传递给回调。如果提交挂钩函数上的回调返回非零，则提交将转换为回滚。</target>
        </trans-unit>
        <trans-unit id="8ed0ff1b29d3e198ebfc7c54c6d04128fb45e5b9" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D，C，P）和sqlite3_rollback_hook（D，C，P）函数从相同&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上同一函数的上一次调用返回P参数，对于D上每个函数的首次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="5c814d040fa0b2376c6a44e987d8d06f8d405641" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D，C，P）和sqlite3_rollback_hook（D，C，P）函数从相同&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上同一函数的上一次调用返回P参数，对于D上每个函数的首次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="a783ef29506da5187d0b6a8b529c5db8a199c982" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_get() function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string. If N is out of range, sqlite3_compileoption_get() returns a NULL pointer. The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get().</source>
          <target state="translated">sqlite3_compileoption_get()函数允许通过返回第N个编译时的选项字符串来迭代编译时定义的选项列表。如果N超出了范围,sqlite3_compileoption_get()返回一个NULL指针。sqlite3_compileoption_get()返回的任何字符串都将省略SQLITE_前缀。</target>
        </trans-unit>
        <trans-unit id="39c27e864f7c32b9ceed46ceee3feba79ed9e6fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_used() function returns 0 or 1 indicating whether the specified option was defined at compile time. The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used().</source>
          <target state="translated">sqlite3_compileoption_used()函数返回0或1,表示指定的选项是否在编译时被定义。传递给sqlite3_compileoption_used()的选项名中可以省略SQLITE_前缀。</target>
        </trans-unit>
        <trans-unit id="c2f7b71d769d28cabe75800e2f0fc786a0e3ca05" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.</source>
          <target state="translated">sqlite3_config()接口用于对SQLite进行全局配置更改,以便根据应用程序的特定需求调整SQLite。对于大多数应用程序来说,默认配置是被推荐的,因此这个例程通常是不必要的。提供它是为了支持有特殊需求的罕见应用。</target>
        </trans-unit>
        <trans-unit id="2a43551c13014713b84ff3176d603e20a0bb2d0e" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）接口只能在使用&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;初始化库之前或在通过&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;关闭后调用。如果sqlite3_config（）被称为后&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;和前&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;，然后将返回SQLITE_MISUSE。但是请注意，可以将sqlite3_config（）作为应用程序定义的&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;的实现的一部分来调用。</target>
        </trans-unit>
        <trans-unit id="950f596cd61399b38213d68d8e3371f1294cd97c" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）接口只能在使用&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;初始化库之前或在通过&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;关闭后调用。如果sqlite3_config（）被称为后&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;和前&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;，然后将返回SQLITE_MISUSE。但是请注意，可以将sqlite3_config（）作为应用程序定义的&lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;的实现的一部分来调用。</target>
        </trans-unit>
        <trans-unit id="f36e7397009cd60c7259be5a8cbdeb80264ff811" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）接口返回指向最初注册了应用程序定义函数的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;（第一个参数）的指针的副本。</target>
        </trans-unit>
        <trans-unit id="04b3afa93b5033ef2c02acd3a1ef18374b3a066e" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）接口返回指向最初注册了应用程序定义函数的&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;（第一个参数）的指针的副本。</target>
        </trans-unit>
        <trans-unit id="0b0f49ec423453d8567eeff6ab2f843591a04245" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function honors the SQLITE_UTF16_ALIGNED flag.</source>
          <target state="translated">sqlite3_create_collation()函数尊重SQLITE_UTF16_ALIGNED标志。</target>
        </trans-unit>
        <trans-unit id="0e46987511170cbb4e8e90d14cfd9fe052087146" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence. The comparison function is only used for comparing text values. The eTextRep parameter is one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, or SQLITE_ANY to specify which text representation the comparison function works with. Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations. The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.</source>
          <target state="translated">sqlite3_create_collation()函数指定了一个整理序列名和一个比较函数来实现该整理序列。比较函数只用于比较文本值。eTextRep参数是SQLITE_UTF8、SQLITE_UTF16LE、SQLITE_UTF16BE或SQLITE_ANY中的一个,用于指定比较函数工作的文本表示方式。对于UTF-8、UTF-16LE和UTF-16BE三种文本表示,同一整理序列可以存在单独的比较函数。sqlite3_create_collation16()的工作原理和 sqlite3_create_collation()一样,只是整理名称是以 UTF-16 主机字节顺序而不是 UTF-8 来指定的。</target>
        </trans-unit>
        <trans-unit id="3bb1bc030c0ecaf171e6e7837d4fc5ad509b9304" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）的工作方式与sqlite3_create_collat​​ion（）相似，此外，删除整理功能后，在pArg上调用了xDestroy回调。当整理函数被以后对整理创建函数的调用所覆盖，或者使用&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;时，整理函数将被删除。</target>
        </trans-unit>
        <trans-unit id="cce8a06023084f98541458166466b478b68c97fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）的工作方式与sqlite3_create_collat​​ion（）相似，此外，删除整理功能后，在pArg上调用了xDestroy回调。当整理函数被以后对整理创建函数的调用所覆盖，或者使用&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;时，整理函数将被删除。</target>
        </trans-unit>
        <trans-unit id="35eaa1fdb7403d0bf2c872e0985b90cb08324f23" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of database filename D with corresponding journal file J and WAL file W and with N URI parameters key/values pairs in the array P. The result from sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that is safe to pass to routines like:</source>
          <target state="translated">sqlite3_create_filename(D,J,W,N,P)分配内存来保存数据库文件名D的一个版本,它有相应的日志文件J和WAL文件W,并且在数组P中有N个URI参数key/values对。 sqlite3_create_filename(D,J,W,N,P)的结果是一个指向数据库文件名的指针,这个文件名可以安全地传递给像这样的例程。</target>
        </trans-unit>
        <trans-unit id="2321a78d45e7f791f5be9bd5eeeecdd73b61cbff" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_module_v2() interface has a fifth parameter which is a pointer to a destructor for the pClientData. SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the pClientData pointer. The destructor will also be invoked if the call to sqlite3_create_module_v2() fails. The sqlite3_create_module() interface is equivalent to sqlite3_create_module_v2() with a NULL destructor.</source>
          <target state="translated">sqlite3_create_module_v2()接口有第五个参数,它是指向pClientData的析构器的指针,当SQLite不再需要pClientData指针时,SQLite会调用析构器函数(如果不是NULL)。当SQLite不再需要pClientData指针时,SQLite将调用destructor函数(如果它不是NULL)。如果调用 sqlite3_create_module_v2()失败,destructor 也会被调用。sqlite3_create_module()接口相当于sqlite3_create_module_v2()的NULL析构器。</target>
        </trans-unit>
        <trans-unit id="ce43917c89192dc7d4a31aeaa86afac14bcedebc" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）接口返回已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;P结果集中当前行中的列数。如果已准备好的语句P没有准备好返回结果（通过调用&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;系列接口），则sqlite3_data_count（ P）返回0。如果P是NULL指针，则sqlite3_data_count（P）例程也返回0。如果先前对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，则sqlite3_data_count（P）例程返回0 。如果先前对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回了&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;，则sqlite3_data_count（P）将返回非零值，但&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA增量&lt;/a&gt;_vacuum的情况除外因为该多步骤编译指示的每一步都会返回0列数据，所以该位置始终返回零。</target>
        </trans-unit>
        <trans-unit id="b23578428cca6b0b7cc9f351266849d54d3f4ac7" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）接口返回已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; P 结果集中当前行中的列数。如果已准备好的语句P没有准备好返回结果（通过调用接口的&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column _ *（）&lt;/a&gt;），则sqlite3_data_count（ P）返回0。如果P是NULL指针，则sqlite3_data_count（P）例程也返回0。如果先前对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，则sqlite3_data_count（P）例程返回0 。如果先前对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回了&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;，则sqlite3_data_count（P）将返回非零值，但&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA增量式&lt;/a&gt;真空的情况除外由于该多步骤编译指示的每一步都会返回0列数据，因此该位置始终返回零。</target>
        </trans-unit>
        <trans-unit id="f5791b68b76b19a4a15dafbc0a31b6f189b8fc89" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）接口返回已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;P结果集中当前行中的列数。如果已准备好的语句P没有准备好返回结果（通过调用&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;系列接口），则sqlite3_data_count（ P）返回0。如果P是NULL指针，则sqlite3_data_count（P）例程也返回0。如果先前对&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，则sqlite3_data_count（P）例程返回0 。如果先前对&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回了&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;，则sqlite3_data_count（P）将返回非零值，但&lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA增量&lt;/a&gt;_vacuum的情况除外因为该多步骤编译指示的每一步都会返回0列数据，所以该位置始终返回零。</target>
        </trans-unit>
        <trans-unit id="0331c5159620074031eabe2d2fffeb3879925815" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）接口返回已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; P 结果集中当前行中的列数。如果已准备好的语句P没有准备好返回结果（通过调用接口的&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column _ *（）&lt;/a&gt;），则sqlite3_data_count（ P）返回0。如果P是NULL指针，则sqlite3_data_count（P）例程也返回0。如果先前对&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，则sqlite3_data_count（P）例程返回0 。如果先前对&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回了&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;，则sqlite3_data_count（P）将返回非零值，但&lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA增量式&lt;/a&gt;真空的情况除外由于该多步骤编译指示的每一步都会返回0列数据，因此该位置始终返回零。</target>
        </trans-unit>
        <trans-unit id="043836a9d52018cfd95036ef1de8601c0dd65b27" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）接口用于对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;进行配置更改。该接口与&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;相似，不同之处在于更改适用于单个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;（在第一个参数中指定）。</target>
        </trans-unit>
        <trans-unit id="cb382b8043f6bd41fb4e955562ae2dd8de8821a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）接口用于对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;进行配置更改。该接口与&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;相似，不同之处在于更改适用于单个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;（在第一个参数中指定）。</target>
        </trans-unit>
        <trans-unit id="d9890e9099b39efa9f23ed1209f98fc2abd695d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to a filename associated with database N of connection D. The main database file has the name &quot;main&quot;. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename(D,N)接口返回一个指向连接D的数据库N相关联的文件名的指针,主数据库文件的名称为 &quot;main&quot;。如果数据库连接D上没有关联的数据库N,或者数据库N是一个临时的或者内存中的数据库,那么这个函数将返回一个NULL指针或者一个空字符串。</target>
        </trans-unit>
        <trans-unit id="6ce559d2134cd8f80b32424d9cafa088f3f1de6d" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to the filename associated with database N of connection D. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename(D,N)接口返回一个指向连接D的数据库N相关联的文件名的指针,如果数据库连接D上没有连接数据库N,或者数据库N是一个临时的或者内存中的数据库,那么这个函数将返回一个NULL指针或者一个空字符串。</target>
        </trans-unit>
        <trans-unit id="7a0142f7765d452e556a6d1ade538189bbf023a1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handle接口返回已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;所属的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。该&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;通过sqlite3_db_handle返回相同&lt;a href=&quot;#sqlite3&quot;&gt;的数据库连接&lt;/a&gt;，这是第一个参数到&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;是用于创建摆在首位的语句调用（或其变体）。</target>
        </trans-unit>
        <trans-unit id="0ed4944069eec7d7c0e7904b6909ffc71d6a37af" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handle接口返回已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;所属的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。该&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;通过sqlite3_db_handle返回相同&lt;a href=&quot;sqlite3&quot;&gt;的数据库连接&lt;/a&gt;，这是第一个参数到&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;是用于创建摆在首位的语句调用（或其变体）。</target>
        </trans-unit>
        <trans-unit id="f13e3d008759351c9d014a67b0c7d66c909c38ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.</source>
          <target state="translated">sqlite3_db_readonly(D,N)接口如果连接D的数据库N是只读,则返回1,如果是读/写,则返回0,如果N不是连接D上的数据库名称,则返回-1。</target>
        </trans-unit>
        <trans-unit id="7c54e0312a49676acc8e0fa5a98fa6c3ca389049" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）接口尝试从数据库连接D释放尽可能多的堆内存。与&lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口不同，即使忽略了&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项，此接口也有效。</target>
        </trans-unit>
        <trans-unit id="a4505b330dae36966abd878a7a5251bb10a809a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）接口尝试从数据库连接D释放尽可能多的堆内存。与&lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口不同，即使忽略了&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项，此接口也有效。</target>
        </trans-unit>
        <trans-unit id="83634ce6a2d174966fca0f07d2eb6e5e52439e9f" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7babdc84886f95b16b07a064461180aa8e231247" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18d47ae58f8b29dbac7701bb014dc19e22eadf62" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.</source>
          <target state="translated">如果数据库当前处于读取事务中或者参与了备份操作,那么sqlite3_deserialize()接口将以SQLITE_BUSY失败。</target>
        </trans-unit>
        <trans-unit id="12340c8333dc6a82eca44a1f4c8bbf0434fac375" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D，S，P，N，M，F）接口使&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D与数据库S断开连接，然后根据P中包含的序列化将S作为内存数据库重新打开。序列化的数据库P为N字节大小。M是缓冲区P的大小，它可能大于N。如果M大于N，并且F中未设置SQLITE_DESERIALIZE_READONLY位，则只要允许SQLite向内存数据库添加内容，就可以总大小不超过M个字节。</target>
        </trans-unit>
        <trans-unit id="afac5ec67e0561a540471ae51b94788f3734ed79" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D，S，P，N，M，F）接口使&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D与数据库S断开连接，然后根据P中包含的序列化将S作为内存数据库重新打开。序列化的数据库P为N字节大小。M是缓冲区P的大小，它可能大于N。如果M大于N，并且F中未设置SQLITE_DESERIALIZE_READONLY位，则只要允许SQLite向内存数据库添加内容，就可以总大小不超过M个字节。</target>
        </trans-unit>
        <trans-unit id="6ae05681a8b59259daa468a1d8590729337a135a" translate="yes" xml:space="preserve">
          <source>The sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.</source>
          <target state="translated">sqlite3_drop_modules(D,L)接口从数据库连接D中删除所有虚拟表模块,列表L中命名的模块除外。L参数必须是NULL或指向字符串指针数组的指针,其中数组以单个NULL指针结束。如果L参数为NULL,则删除所有虚拟表模块。</target>
        </trans-unit>
        <trans-unit id="cb17fe8b042f1bd6f76a39ed23dd1524edfc2345" translate="yes" xml:space="preserve">
          <source>The sqlite3_errcode() routine returns a result code for the most recent major API call. sqlite3_errmsg() returns an English-language text error message for the most recent error. The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function. sqlite3_errmsg16() works like sqlite3_errmsg() except that it returns the error message represented as UTF-16 in host native byte order.</source>
          <target state="translated">sqlite3_errcode()例程返回最近一次主要API调用的结果代码。 sqlite3_errmsg()返回最近一次错误的英文文本错误信息。sqlite3_errmsg16()的工作原理和sqlite3_errmsg()一样,只是它以主机本地字节顺序返回UTF-16表示的错误信息。</target>
        </trans-unit>
        <trans-unit id="5e0d9cf7c1277961ee0db98705525eacc5bb425f" translate="yes" xml:space="preserve">
          <source>The sqlite3_errmsg() and sqlite3_errmsg16() return English-language text that describes the error, as either UTF-8 or UTF-16 respectively. Memory to hold the error message string is managed internally. The application does not need to worry about freeing the result. However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.</source>
          <target state="translated">sqlite3_errmsg()和sqlite3_errmsg16()分别以UTF-8或UTF-16的形式返回描述错误的英文文本。用于保存错误信息字符串的内存由内部管理。应用程序不需要担心释放结果。但是,错误字符串可能会被后续对其他SQLite接口函数的调用覆盖或重新分配。</target>
        </trans-unit>
        <trans-unit id="a3b2d05546afbeecb20b8fe87e3f3189bfedb642" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）接口以UTF-8 返回描述&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;的英语文本。包含错误消息字符串的内存是在内部进行管理的，应用程序不得释放该内存。</target>
        </trans-unit>
        <trans-unit id="3185f0fefecbff2d0db8b69bac9298083b70809e" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）接口以UTF-8 返回描述&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;的英语文本。包含错误消息字符串的内存是在内部进行管理的，应用程序不得释放该内存。</target>
        </trans-unit>
        <trans-unit id="eec19de3d00e4cd6319cb02ddf72d5b612e30300" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）接口是&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;的便捷包装，它允许应用程序运行多个SQL语句而无需使用大量C代码。</target>
        </trans-unit>
        <trans-unit id="9a4e88bd32574fff7b2361feb6cf37710d7194a2" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）接口是&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;的便捷包装，它允许应用程序运行多个SQL语句而无需使用大量C代码。</target>
        </trans-unit>
        <trans-unit id="5f6ecb5327784e2b3ab3076a060e42400e8e6e49" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）接口在作为第一个参数传入的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;的上下文中，运行零个或多个以UTF-8编码，以分号分隔的SQL语句，并将其传递给第二个参数。如果sqlite3_exec（）的第3个参数的回调函数不为NULL，则将对从评估的SQL语句中出来的每个结果行调用该函数。sqlite3_exec（）的第4个参数将中继到每个回调调用的第一个参数。如果指向sqlite3_exec（）的回调指针为NULL，则不会调用任何回调，并且将忽略结果行。</target>
        </trans-unit>
        <trans-unit id="7f2bf987e70ab4f6565417a4f7295b79e8706b9e" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）接口在作为第一个参数传入的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;的上下文中，运行零个或多个以UTF-8编码，以分号分隔的SQL语句，并将其传递给第二个参数。如果sqlite3_exec（）的第3个参数的回调函数不为NULL，则将对从评估的SQL语句中出来的每个结果行调用该函数。sqlite3_exec（）的第4个参数将中继到每个回调调用的第一个参数。如果指向sqlite3_exec（）的回调指针为NULL，则不会调用任何回调，并且将忽略结果行。</target>
        </trans-unit>
        <trans-unit id="fdc80de144729ab29ec768dc45f521935b24167a" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">如果没有足够的内存来保存结果，或者如果结果将超过&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;确定的最大字符串长度，则sqlite3_expanded_sql（）接口返回NULL 。</target>
        </trans-unit>
        <trans-unit id="253eafa1da6e36def799917e15566e8c664899fe" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">如果没有足够的内存来保存结果，或者如果结果将超过&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;确定的最大字符串长度，则sqlite3_expanded_sql（）接口返回NULL 。</target>
        </trans-unit>
        <trans-unit id="1d1fd4c0ad3995d89a0ef41f1f46affc2269eba4" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）例程启用或禁用SQLite 的&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;功能。默认情况下，扩展结果代码是禁用的，以实现历史兼容性。</target>
        </trans-unit>
        <trans-unit id="904ab00e0ae19fa09117889888e1162471d32017" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）例程启用或禁用SQLite 的&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;功能。默认情况下，扩展结果代码是禁用的，以实现历史兼容性。</target>
        </trans-unit>
        <trans-unit id="5daeea1eac71cd621bf8b80af259a724f2e831b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">调用sqlite3_finalize（）函数以删除&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果对语句的最新评估没有遇到错误，或者从未对语句进行评估，则sqlite3_finalize（）返回SQLITE_OK。如果对语句S的最新评估失败，则sqlite3_finalize（S）返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74837217c620c1e41ee1e321a9ad17968e0d6486" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">调用sqlite3_finalize（）函数以删除&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果对语句的最新评估没有遇到错误，或者从未对语句进行评估，则sqlite3_finalize（）返回SQLITE_OK。如果对语句S的最新评估失败，则sqlite3_finalize（S）返回适当的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfdc64000a1f68dd938d60f9bb70e02c947748fd" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）例程可以在已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S 的生命周期中的任何时间调用：在评估语句 S之前，一次或多次调用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;之后或在调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）之后，&lt;/a&gt;无论是否或语句尚未完成执行。</target>
        </trans-unit>
        <trans-unit id="1dec5478469a2333006cfdfd3bbed8c6613161e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）例程可以在已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S 的生命周期中的任何时间调用：在评估语句 S之前，一次或多次调用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;之后或在调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）之后，&lt;/a&gt;无论是否或语句尚未完成执行。</target>
        </trans-unit>
        <trans-unit id="408796a34b26a6721118a4ab1b7c1f9baef90909" translate="yes" xml:space="preserve">
          <source>The sqlite3_free_filename(Y) routine releases a memory allocation previously obtained from sqlite3_create_filename(). Invoking sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.</source>
          <target state="translated">sqlite3_free_filename(Y)例程释放了之前从 sqlite3_create_filename()获得的内存分配。调用sqlite3_free_filename(Y)例程,其中Y是一个NULL指针,是一个无害的no-op。</target>
        </trans-unit>
        <trans-unit id="0a8a4dfedb4d5de550dae28093210eb5e1165c50" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">如果给定的数据库连接分别处于或不处于自动提交模式，则sqlite3_get_autocommit（）接口分别返回非零或零。默认情况下，自动提交模式是打开的。自动提交模式被&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;语句禁用。自动提交模式由&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;或&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;重新启用。</target>
        </trans-unit>
        <trans-unit id="c6407bbe024eecae19905f3987328770ebef955e" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">如果给定的数据库连接分别处于或不处于自动提交模式，则sqlite3_get_autocommit（）接口分别返回非零或零。默认情况下，自动提交模式是打开的。自动提交模式被&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;语句禁用。自动提交模式由&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;或&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;重新启用。</target>
        </trans-unit>
        <trans-unit id="c54753db8fb054877250927a699aaaed04734d2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument value to the application-defined function. N is zero for the left-most function argument. If there is no metadata associated with the function argument, the sqlite3_get_auxdata(C,N) interface returns a NULL pointer.</source>
          <target state="translated">sqlite3_get_auxdata(C,N)接口返回一个指针,指向sqlite3_set_auxdata(C,N,P,X)函数与应用定义函数的第N个参数值关联的元数据。对于最左边的函数参数,N为零。如果没有与函数参数相关联的元数据,sqlite3_get_auxdata(C,N)接口返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="35597daf57a6a6a4650eb220c2a29fa2c91a59d0" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2nd parameter and returns a result table to the pointer given in its 3rd parameter.</source>
          <target state="translated">sqlite3_get_table()函数对其第2个参数中的一个或多个以分号分隔的UTF-8字符串的SQL语句进行评估,并向其第3个参数中给出的指针返回一个结果表。</target>
        </trans-unit>
        <trans-unit id="acdf7ebaf34cc7cf8bdf020e8dc45c52df0d628c" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）接口被实现为&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的包装。 sqlite3_get_table（）例程无法访问SQLite的任何内部数据结构。它仅使用此处定义的公共接口。结果，内部&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;调用外部的包装层中发生的错误不会反映在后续对&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）的&lt;/a&gt;调用中。</target>
        </trans-unit>
        <trans-unit id="566ec671a5bf78f09b92642b451438dd26c86350" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）接口被实现为&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的包装。 sqlite3_get_table（）例程无法访问SQLite的任何内部数据结构。它仅使用此处定义的公共接口。结果，内部&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;调用外部的包装层中发生的错误不会反映在后续对&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）的&lt;/a&gt;调用中。</target>
        </trans-unit>
        <trans-unit id="b9b992cc0be7235d15c4a18cbb125e283656622e" translate="yes" xml:space="preserve">
          <source>The sqlite3_hard_heap_limit64(N) interface sets a hard upper bound of N bytes on the amount of memory that will be allocated. The sqlite3_hard_heap_limit64(N) interface is similar to sqlite3_soft_heap_limit64(N) except that memory allocations will fail when the hard heap limit is reached.</source>
          <target state="translated">sqlite3_hard_heap_limit64(N)接口对将要分配的内存量设置了一个N字节的硬上界。sqlite3_hard_heap_limit64(N)接口与 sqlite3_soft_heap_limit64(N)接口类似,只是当达到硬堆限制时,内存分配将失败。</target>
        </trans-unit>
        <trans-unit id="5a1053b2bb267ced2e3415b8b71b02dc7bb0d976" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info结构及其子结构用作&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;接口的一部分，以将信息传递到&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法并从中接收答复。**输入**下的字段是xBestIndex的输入，并且是只读的。xBestIndex将其结果插入到&amp;ldquo;输出&amp;rdquo;字段中。</target>
        </trans-unit>
        <trans-unit id="779db7516101e2733ab83d988869d6422e837e26" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info结构及其子结构用作&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;接口的一部分，以将信息传递到&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法并从中接收答复。**输入**下的字段是xBestIndex的输入，并且是只读的。xBestIndex将其结果插入到&amp;ldquo;输出&amp;rdquo;字段中。</target>
        </trans-unit>
        <trans-unit id="f7b3a693ac538b125172c62d75cc7d377f31b955" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）接口是线程安全的，但sqlite3_shutdown（）不是。sqlite3_shutdown（）接口只能从单个线程中调用。在调用sqlite3_shutdown（）之前，必须关闭所有打开的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接，&lt;/a&gt;并且必须释放所有其他SQLite资源。</target>
        </trans-unit>
        <trans-unit id="88e442978d61726b76c4c6bd7b1f8a87808c119b" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）接口是线程安全的，但sqlite3_shutdown（）不是。sqlite3_shutdown（）接口只能从单个线程中调用。在调用sqlite3_shutdown（）之前，必须关闭所有打开的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接，&lt;/a&gt;并且必须释放所有其他SQLite资源。</target>
        </trans-unit>
        <trans-unit id="0e2957684efb0782443d87103a368a9305c21dfe" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine initializes the SQLite library. The sqlite3_shutdown() routine deallocates any resources that were allocated by sqlite3_initialize(). These routines are designed to aid in process initialization and shutdown on embedded systems. Workstation applications using SQLite normally do not need to invoke either of these routines.</source>
          <target state="translated">sqlite3_initialize()例程初始化SQLite库。sqlite3_shutdown()例程会重新分配由 sqlite3_initialize()分配的资源。这些例程被设计用来帮助嵌入式系统的进程初始化和关闭。使用SQLite的工作站应用程序通常不需要调用这两个例程。</target>
        </trans-unit>
        <trans-unit id="6344d658101e62a854952f62047632e568cb77e6" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）例程由许多其他SQLite接口在内部调用，因此应用程序通常不需要直接调用sqlite3_initialize（）。例如，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;调用sqlite3_initialize（），所以SQLite库时将被自动初始化&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;被调用，如果它没有被已经初始化。但是，如果使用&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite使用compile-time选项，则将省略对sqlite3_initialize（）的自动调用，并且应用程序必须在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。为了获得最大的可移植性，建议应用程序始终始终在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。 SQLite的未来版本可能会要求这样做。换句话说，在将来的SQLite发行版中，使用&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite时显示的行为可能成为默认行为。</target>
        </trans-unit>
        <trans-unit id="fcebb10283d6873f839e3d670ae393ff5c1368df" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）例程由许多其他SQLite接口在内部调用，因此应用程序通常不需要直接调用sqlite3_initialize（）。例如，&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;调用sqlite3_initialize（），所以SQLite库时将被自动初始化&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;被调用，如果它没有被已经初始化。但是，如果使用&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite使用compile-time选项，则将省略对sqlite3_initialize（）的自动调用，并且应用程序必须在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。为了获得最大的可移植性，建议应用程序始终始终在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。 SQLite的未来版本可能会要求这样做。换句话说，在将来的SQLite发行版中，使用&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite时显示的行为可能成为默认行为。</target>
        </trans-unit>
        <trans-unit id="ce2e2f5e58c3c92f466c0d1a9cbb3782ccb3ca7e" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）例程成功返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果由于某种原因sqlite3_initialize（）无法初始化库（也许无法分配所需的资源，例如互斥锁），则它将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;以外的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cfd6fb2b2f9b6bef5dc2729044b616aa2e46340" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）例程成功返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果由于某种原因sqlite3_initialize（）无法初始化库（也许无法分配所需的资源，例如互斥锁），则它将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;以外的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="004164880e4716eb9f6522ffa56490d8e1026730" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions. The sqlite_int64 and sqlite_uint64 types are supported for backwards compatibility only.</source>
          <target state="translated">sqlite3_int64和 sqlite3_uint64是首选类型定义。sqlite_int64和 sqlite_uint64类型只支持向后兼容。</target>
        </trans-unit>
        <trans-unit id="7d87f3d7209e128d2babe00e667401d22d9cc8a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite_int64 types can store integer values between -9223372036854775808 and +9223372036854775807 inclusive. The sqlite3_uint64 and sqlite_uint64 types can store integer values between 0 and +18446744073709551615 inclusive.</source>
          <target state="translated">sqlite3_int64和sqlite_int64类型可以存储-9223372036854775808和+9223372036854775807(含)之间的整数值。sqlite3_uint64和sqlite_uint64类型可以存储0和+18446744073709551615(含)之间的整数值。</target>
        </trans-unit>
        <trans-unit id="d1945cfc4228bc66b1032ca0f61bc88893782d0c" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）调用一直有效，直到&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;D上所有当前正在运行的SQL语句完成为止。在sqlite3_interrupt（）调用之后和运行语句计数达到零之前启动的任何新SQL语句都被中断，就好像它们在sqlite3_interrupt（）调用之前已在运行一样。在运行语句计数达到零后启动的新SQL语句不受sqlite3_interrupt（）的影响。在没有运行中的SQL语句时发生的对sqlite3_interrupt（D）的调用是无操作的，并且对在sqlite3_interrupt（）调用返回后启动的SQL语句没有影响。</target>
        </trans-unit>
        <trans-unit id="7eba8c8e6f99b81a907173174c705f9ed98298ab" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）调用将一直有效，直到&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上所有当前正在运行的SQL语句完成为止。在sqlite3_interrupt（）调用之后且正在运行的语句达到零之前启动的任何新SQL语句都被中断，就好像它们在sqlite3_interrupt（）调用之前已在运行一样。在运行语句计数达到零之后启动的新SQL语句不受sqlite3_interrupt（）的影响。在没有运行中的SQL语句时发生的对sqlite3_interrupt（D）的调用是无操作的，并且对在sqlite3_interrupt（）调用返回后启动的SQL语句没有影响。</target>
        </trans-unit>
        <trans-unit id="397354330de52f0df08035b92ede80f0eda59fd9" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）调用一直有效，直到&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;D上所有当前正在运行的SQL语句完成为止。在sqlite3_interrupt（）调用之后和运行语句计数达到零之前启动的任何新SQL语句都被中断，就好像它们在sqlite3_interrupt（）调用之前已在运行一样。在运行语句计数达到零后启动的新SQL语句不受sqlite3_interrupt（）的影响。在没有运行中的SQL语句时发生的对sqlite3_interrupt（D）的调用是无操作的，并且对在sqlite3_interrupt（）调用返回后启动的SQL语句没有影响。</target>
        </trans-unit>
        <trans-unit id="a6b86af3fa8ce3c883af892e74e82bdad0554e41" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）调用将一直有效，直到&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上所有当前正在运行的SQL语句完成为止。在sqlite3_interrupt（）调用之后且正在运行的语句达到零之前启动的任何新SQL语句都被中断，就好像它们在sqlite3_interrupt（）调用之前已在运行一样。在运行语句计数达到零之后启动的新SQL语句不受sqlite3_interrupt（）的影响。在没有运行中的SQL语句时发生的对sqlite3_interrupt（D）的调用是无操作的，并且对在sqlite3_interrupt（）调用返回后启动的SQL语句没有影响。</target>
        </trans-unit>
        <trans-unit id="3bfe2e62ea9486a964b648fd6403e7edfa3b65f8" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_check(Z,L) interface checks to see whether or not the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero if it is and zero if not.</source>
          <target state="translated">sqlite3_keyword_check(Z,L)接口检查Z指向的L字节UTF8标识符是否是关键字,如果是,返回非零,如果不是,返回零。</target>
        </trans-unit>
        <trans-unit id="d4d8092bdf6d249db5e6e39b2ccbee0c913272c1" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_count() interface returns the number of distinct keywords understood by SQLite.</source>
          <target state="translated">sqlite3_keyword_count()接口返回SQLite所理解的不同关键字的数量。</target>
        </trans-unit>
        <trans-unit id="dc0acf41ffb529d44b2ebca13529ac325b17bad2" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L. The string that *Z points to is not zero-terminated. The sqlite3_keyword_name(N,Z,L) routine returns SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z or L are NULL or invalid pointers then calls to sqlite3_keyword_name(N,Z,L) result in undefined behavior.</source>
          <target state="translated">sqlite3_keyword_name(N,Z,L)接口找到第N个关键字,并使*Z指向该关键字,用UTF8表示,并将关键字的字节数写入*L中。*Z指向的字符串不以零结尾。sqlite3_keyword_name(N,Z,L)例程如果N在范围内则返回SQLITE_OK,如果不在范围内则返回SQLITE_ERROR。如果Z或L是NULL或无效指针,那么对sqlite3_keyword_name(N,Z,L)的调用将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="0a1d77fc76c131dee5ee5dd030d6d5133cee00d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">所述sqlite3_last_insert_rowid（d）接口通常返回&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最近成功的&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;成一个rowid表或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;上的数据库连接D.插入到&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表不被记录。如果在数据库连接D上没有成功向rowid表&lt;a href=&quot;../lang_insert&quot;&gt;插入INSERT&lt;/a&gt;，则sqlite3_last_insert_rowid（D）返回零。</target>
        </trans-unit>
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">所述sqlite3_last_insert_rowid（d）接口通常返回&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最近成功的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;成一个rowid表或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;上的数据库连接D.插入到&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表不被记录。如果在数据库连接D上没有成功向rowid表&lt;a href=&quot;lang_insert&quot;&gt;插入INSERT&lt;/a&gt;，则sqlite3_last_insert_rowid（D）返回零。</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）接口尝试加载文件zFile中包含的&lt;a href=&quot;../loadext&quot;&gt;SQLite扩展&lt;/a&gt;库。如果无法直接加载文件，则尝试使用添加的各种特定于操作系统的扩展名进行加载。因此，例如，如果无法加载&amp;ldquo; samplelib&amp;rdquo;，则也可以尝试使用&amp;ldquo; samplelib.so&amp;rdquo;或&amp;ldquo; samplelib.dylib&amp;rdquo;或&amp;ldquo; samplelib.dll&amp;rdquo;之类的名称。</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）接口尝试加载文件zFile中包含的&lt;a href=&quot;loadext&quot;&gt;SQLite扩展&lt;/a&gt;库。如果无法直接加载文件，则尝试使用添加的各种特定于操作系统的扩展名进行加载。因此，例如，如果无法加载&amp;ldquo; samplelib&amp;rdquo;，则也可以尝试使用&amp;ldquo; samplelib.so&amp;rdquo;或&amp;ldquo; samplelib.dylib&amp;rdquo;或&amp;ldquo; samplelib.dll&amp;rdquo;之类的名称。</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">sqlite3_log()接口是为虚拟表、整理函数和SQL函数等扩展而设计的。虽然没有什么可以阻止应用程序调用sqlite3_log(),但这样做被认为是不好的形式。</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">sqlite3_malloc()例程返回一个指向至少N个字节长度的内存块的指针,其中N是参数。如果sqlite3_malloc()无法获得足够的空闲内存,它将返回一个NULL指针。如果sqlite3_malloc()的参数N为0或负值,那么sqlite3_malloc()返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">sqlite3_malloc64(N)例程的工作原理和sqlite3_malloc(N)一样,只是N是一个无符号的64位整数而不是有符号的32位整数。</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）和sqlite3_vmprintf（）例程将其结果写入从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中。这两个例程返回的字符串应由&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放。如果&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;无法分配足够的内存来容纳结果字符串，则这两个例程都将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）和sqlite3_vmprintf（）例程将其结果写入从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中。这两个例程返回的字符串应由&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放。如果&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;无法分配足够的内存来容纳结果字符串，则这两个例程都将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">sqlite3_mutex_alloc()例程分配一个新的mutex并返回一个指向它的指针。如果不能分配所需的mutex,sqlite3_mutex_alloc()例程返回NULL。sqlite3_mutex_alloc()的参数必须是这些整数常数之一。</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）和sqlite3_mutex_try（）例程尝试输入互斥量。如果互斥锁中已有另一个线程，则sqlite3_mutex_enter（）将阻塞，而sqlite3_mutex_try（）将返回SQLITE_BUSY。成功输入后，sqlite3_mutex_try（）接口将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。使用SQLITE_MUTEX_RECURSIVE创建的互斥锁可以由同一线程多次输入。在这种情况下，互斥锁必须退出相同的次数才能进入另一个线程。如果同一线程多次尝试输入除SQLITE_MUTEX_RECURSIVE以外的任何互斥锁，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）和sqlite3_mutex_try（）例程尝试输入互斥量。如果互斥锁中已有另一个线程，则sqlite3_mutex_enter（）将阻塞，而sqlite3_mutex_try（）将返回SQLITE_BUSY。成功输入后，sqlite3_mutex_try（）接口将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。使用SQLITE_MUTEX_RECURSIVE创建的互斥锁可以由同一线程多次输入。在这种情况下，互斥锁必须退出相同的次数才能进入另一个线程。如果同一线程多次尝试输入除SQLITE_MUTEX_RECURSIVE以外的任何互斥锁，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">sqlite3_mutex_free()例程会重新定位之前分配的动态互斥。试图重新定位一个静态的mutex会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">sqlite3_mutex_held()和 sqlite3_mutex_notheld()例程是为了在 assert()语句中使用。SQLite核心除了在assert()语句中使用这些例程外,从未使用过这些例程,建议应用程序遵循核心的引导。SQLite核心只有在编译时使用SQLITE_DEBUG标志时才会提供这些例程的实现。只有在定义了SQLITE_DEBUG和没有定义NDEBUG的情况下,外部mutex实现才需要提供这些例程。</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">sqlite3_mutex_leave()例程会退出一个之前由同一线程进入的mutex。如果mutex当前没有被调用线程进入,或者当前没有被分配,那么这个行为就没有定义。</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">sqlite3_open()例程返回一个整数错误代码,而不是像版本2接口那样返回一个指向sqlite3结构的指针。sqlite3_open()和sqlite3_open16()的区别在于,sqlite3_open16()采用UTF-16(按主机本地字节顺序)作为数据库文件的名称。如果需要创建一个新的数据库文件,那么sqlite3_open16()将内部的文本表示方式设置为UTF-16,而sqlite3_open()将文本表示方式设置为UTF-8。</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）接口的工作方式类似于sqlite3_open（），不同之处在于它接受两个附加参数来对新数据库连接进行附加控制。 sqlite3_open_v2（）的flags参数可以采用以下三个值之一，可以选择与&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;和/或&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志组合：</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）接口的工作方式类似于sqlite3_open（），不同之处在于它接受两个附加参数来对新数据库连接进行附加控制。 sqlite3_open_v2（）的flags参数可以采用以下三个值之一，可以选择与&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;和/或&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志组合：</target>
        </trans-unit>
        <trans-unit id="5a0142d09a66478c971c322bbffc0dda8bf83c4b" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() must include, at a minimum, one of the following three flag combinations:</source>
          <target state="translated">sqlite3_open_v2()接口的工作原理和sqlite3_open()一样,只是它接受两个额外的参数来控制新的数据库连接。sqlite3_open_v2()的flags参数必须至少包括以下三个标志组合之一。</target>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）例程对SQLite库进行操作系统特定的初始化。sqlite3_os_end（）例程撤消sqlite3_os_init（）的影响。这些例程执行的典型任务包括静态资源的分配或释放，全局变量的初始化，设置默认的&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;模块或使用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;设置默认配置。</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）例程对SQLite库进行操作系统特定的初始化。sqlite3_os_end（）例程撤消sqlite3_os_init（）的影响。这些例程执行的典型任务包括静态资源的分配或释放，全局变量的初始化，设置默认的&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;模块或使用&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;设置默认配置。</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">sqlite3_pcache类型是不透明的。它是由可插拔模块实现的。SQLite核心对它的大小和内部结构一无所知,除了持有和传递指向对象的指针外,从不处理sqlite3_pcache对象。</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">不建议使用sqlite3_pcache_methods结构以及&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt;配置参数。它们由新的&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;结构以及&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt;配置参数代替。</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">sqlite3_pcache_page对象代表页面缓存中的一个页面。页面缓存将分配这个对象的实例。页面缓存的各种方法使用指向这个对象实例的指针作为参数或作为它们的返回值。</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">sqlite3_prepare接口将一条SQL语句编译成字节码供以后执行。这个接口现在是访问数据库的首选方式。</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">对于所有新程序，建议使用sqlite3_prepare_v2（），sqlite3_prepare_v3（），sqlite3_prepare16_v2（）和sqlite3_prepare16_v3（）接口。保留了较旧的接口（sqlite3_prepare（）和sqlite3_prepare16（））是为了向后兼容，但不鼓励使用它们。在&amp;ldquo; vX&amp;rdquo;接口中，返回的准备好的语句（&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象）包含原始SQL文本的副本。这导致&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口以三种方式表现不同：</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">对于所有新程序，建议使用sqlite3_prepare_v2（），sqlite3_prepare_v3（），sqlite3_prepare16_v2（）和sqlite3_prepare16_v3（）接口。保留了较旧的接口（sqlite3_prepare（）和sqlite3_prepare16（））是为了向后兼容，但不鼓励使用它们。在&amp;ldquo; vX&amp;rdquo;接口中，返回的准备好的语句（&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象）包含原始SQL文本的副本。这导致&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口以三种方式表现不同：</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D，N，X，P）接口使长时间运行对数据库连接D的&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table（）的&lt;/a&gt;调用会定期调用回调函数X。此接口的示例用法是在大型查询期间保持GUI更新。</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D，N，X，P）接口使长时间运行对数据库连接D的&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;，&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table（）的&lt;/a&gt;调用会定期调用回调函数X。此接口的示例用法是在大型查询期间保持GUI更新。</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">sqlite3_realloc(X,N)接口试图调整先前的内存分配X的大小,使其至少为N个字节。如果sqlite3_realloc(X,N)的X参数是一个NULL指针,那么它的行为和调用sqlite3_malloc(N)是一样的。如果sqlite3_realloc(X,N)的N参数是0或负数,那么它的行为与调用sqlite3_free(X)完全相同。sqlite3_realloc(X,N)返回一个指针,指向一个至少有N个字节大小的内存分配,如果可用内存不足,则返回NULL。如果M是前一个分配的大小,那么前一个分配的min(N,M)字节会被复制到sqlite3_realloc(X,N)返回的缓冲区的开头,并且释放前一个分配。如果sqlite3_realloc(X,N)返回NULL,且N为正值,那么之前的分配就不会被释放。</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">sqlite3_realloc64(X,N)接口的工作原理与 sqlite3_realloc(X,N)相同,只是 N 是一个 64 位的无符号整数,而不是一个 32 位的有符号整数。</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">通过调用sqlite3rebaser_delete()删除sqlite3_rebaser对象。</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）接口尝试通过释放数据库库所持有的不必要的内存分配来释放N字节的堆内存。用于缓存数据库页面以提高性能的内存是非必需内存的一个示例。 sqlite3_release_memory（）返回实际释放的字节数，它可能大于或小于请求的数量。如果未使用&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译SQLite，则sqlite3_release_memory（）例程是无操作的，返回零。</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）接口尝试通过释放数据库库所持有的不必要的内存分配来释放N字节的堆内存。用于缓存数据库页面以提高性能的内存是非必需内存的一个示例。 sqlite3_release_memory（）返回实际释放的字节数，它可能大于或小于请求的数量。如果未使用&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译SQLite，则sqlite3_release_memory（）例程是无操作的，返回零。</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">调用sqlite3_reset（）函数可将&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象重置回其初始状态，以备重新执行。使用&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;绑定了值的任何SQL语句变量都将保留其值。使用&lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;重置绑定。</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">调用sqlite3_reset（）函数可将&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象重置回其初始状态，以备重新执行。使用&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;绑定了值的任何SQL语句变量都将保留其值。使用&lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;重置绑定。</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">sqlite3_result_blob()接口将一个应用程序定义的函数的结果设置为BLOB,其内容由第二个参数指向,并且是N个字节长,其中N是第三个参数。</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">sqlite3_result_double()接口将应用程序定义函数的结果设置为由其第2个参数指定的浮点值。</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error()和sqlite3_result_error16()函数会使实现的SQL函数抛出异常。SQLite使用sqlite3_result_error()或sqlite3_result_error16()的第2个参数指向的字符串作为错误信息的文本。SQLite将来自sqlite3_result_error()的错误信息字符串解释为UTF-8。SQLite将来自sqlite3_result_error16()的字符串按照本机字节顺序解释为UTF-16。如果 sqlite3_result_error()或 sqlite3_result_error16()的第三个参数为负值,那么 SQLite 将从第一个零字符开始的所有文本作为错误信息。如果sqlite3_result_error()或sqlite3_result_error16()的第三个参数是非负值,那么SQLite将从第2个参数中取出的那么多字节(不是字符)作为错误信息。sqlite3_result_error()和 sqlite3_result_error16()例程在返回之前,会对错误信息的文本做一个私有的拷贝。因此,调用函数可以在返回后对文本进行重新分配或修改,而不会造成伤害。sqlite3_result_error_code()函数改变了SQLite因函数出错而返回的错误代码。默认情况下,错误代码是SQLITE_ERROR。随后调用sqlite3_result_error()或sqlite3_result_error16()会将错误代码重置为SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="29f28f42596987edc9ab24a265ebb7acbdeb19a7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error（）和sqlite3_result_error16（）函数导致已实现的SQL函数引发异常。 SQLite使用sqlite3_result_error（）或sqlite3_result_error16（）的第二个参数指向的字符串作为错误消息的文本。 SQLite将来自sqlite3_result_error（）的错误消息字符串解释为UTF-8。 SQLite使用与sqlite3_bind_text16（）相同的&lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;字节顺序确定规则&lt;/a&gt;，将&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_result_error16（）中&lt;/a&gt;的字符串解释为UTF-16。。如果sqlite3_result_error（）或sqlite3_result_error16（）的第三个参数为负，则SQLite将通过第一个零字符开始的所有文本作为错误消息。如果sqlite3_result_error（）或sqlite3_result_error16（）的第三个参数为非负数，则SQLite从第二个参数中获取那么多字节（不是字符）作为错误消息。 sqlite3_result_error（）和sqlite3_result_error16（）例程在返回错误消息之前对其进行私有复制。因此，调用函数可以在返回文本后取消分配或修改文本，而不会造成损害。 sqlite3_result_error_code（）函数更改SQLite由于函数错误而返回的错误代码。默认情况下，错误代码为SQLITE_ERROR。随后调用sqlite3_result_error（）或sqlite3_result_error16（）会将错误代码重置为SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="c5a0bd3f253d68fda2502decfe5e0f0d13527f91" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error（）和sqlite3_result_error16（）函数导致已实现的SQL函数引发异常。 SQLite使用sqlite3_result_error（）或sqlite3_result_error16（）的第二个参数指向的字符串作为错误消息的文本。 SQLite将来自sqlite3_result_error（）的错误消息字符串解释为UTF-8。 SQLite使用与sqlite3_bind_text16（）相同的&lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;字节顺序确定规则&lt;/a&gt;，将&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_result_error16（）中&lt;/a&gt;的字符串解释为UTF-16。。如果sqlite3_result_error（）或sqlite3_result_error16（）的第三个参数为负，则SQLite将通过第一个零字符开始的所有文本作为错误消息。如果sqlite3_result_error（）或sqlite3_result_error16（）的第三个参数为非负数，则SQLite从第二个参数中获取那么多字节（不是字符）作为错误消息。 sqlite3_result_error（）和sqlite3_result_error16（）例程在返回错误消息之前对其进行私有复制。因此，调用函数可以在返回文本后取消分配或修改文本，而不会造成损害。 sqlite3_result_error_code（）函数更改SQLite由于函数错误而返回的错误代码。默认情况下，错误代码为SQLITE_ERROR。随后调用sqlite3_result_error（）或sqlite3_result_error16（）会将错误代码重置为SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">sqlite3_result_error_nomem()接口使SQLite抛出一个错误,表明内存分配失败。</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">sqlite3_result_error_toobig()接口使SQLite抛出一个错误,表示一个字符串或BLOB太长,无法表示。</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">sqlite3_result_int()接口将应用程序定义的函数的返回值设置为第2个参数中给出的32位有符号的整数值。sqlite3_result_int64()接口将应用程序定义的函数的返回值设置为第2个参数中给出的64位有符号的整数值。</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">sqlite3_result_null()接口将应用定义函数的返回值设置为NULL。</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C，P，T，D）接口将结果设置为SQL NULL值，就像&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null（C）一样&lt;/a&gt;，不同之处在于它还将主机语言指针P或类型T与该NULL值相关联，从而使指针可以使用&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数中&lt;/a&gt;检索。如果D参数不为NULL，则它是指向P参数的析构函数的指针。当SQLite用P结尾时，SQLite调用D作为唯一的参数。D参数应该是静态字符串，最好是字符串文字。 sqlite3_result_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="2141ed898fc1d1e35a1c686aae779faa61d104a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C，P，T，D）接口将结果设置为SQL NULL值，就像&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null（C）一样&lt;/a&gt;，不同之处在于它还将主机语言指针P或类型T与该NULL值相关联，从而使指针可以使用&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数中&lt;/a&gt;检索。如果D参数不为NULL，则它是指向P参数的析构函数的指针。当SQLite用P结尾时，SQLite调用D作为唯一参数。D参数应该是静态字符串，最好是字符串文字。 sqlite3_result_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="abeb9a4e536ac73c7793be889cbe18ade4a8329e" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C，P，T，D）接口将结果设置为SQL NULL值，就像&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null（C）一样&lt;/a&gt;，不同之处在于它还将主机语言指针P或类型T与该NULL值相关联，从而使指针可以使用&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在&lt;a href=&quot;../appfunc&quot;&gt;应用程序定义的SQL函数中&lt;/a&gt;检索。如果D参数不为NULL，则它是指向P参数的析构函数的指针。当SQLite用P结尾时，SQLite调用D作为唯一参数。D参数应该是静态字符串，最好是字符串文字。 sqlite3_result_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C，P，T，D）接口将结果设置为SQL NULL值，就像&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null（C）一样&lt;/a&gt;，不同之处在于它还将主机语言指针P或类型T与该NULL值相关联，从而使指针可以使用&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数中&lt;/a&gt;检索。如果D参数不为NULL，则它是指向P参数的析构函数的指针。当SQLite用P结尾时，SQLite调用D作为唯一的参数。D参数应该是静态字符串，最好是字符串文字。 sqlite3_result_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C，T）函数使带有&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C 的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的结果子类型成为值T。在当前版本的SQLite中，仅保留了子类型T的低8位。高阶位被丢弃。在将来的SQLite版本中，SQLite保留的子类型字节数可能会增加。</target>
        </trans-unit>
        <trans-unit id="14b620485a8968d2bc78129bd173a352a06dd552" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C，T）函数使带有&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C的&lt;a href=&quot;../appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的结果子类型成为值T。在当前版本的SQLite中，仅保留了子类型T的低8位。高阶位被丢弃。在将来的SQLite版本中，SQLite保留的子类型字节数可能会增加。</target>
        </trans-unit>
        <trans-unit id="b466179681aeddfbf231a03d679d2648006d92dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C，T）函数使带有&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C的&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的结果子类型成为值T。在当前版本的SQLite中，仅保留了子类型T的低8位。高阶位被丢弃。在将来的SQLite版本中，SQLite保留的子类型字节数可能会增加。</target>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C，T）函数使带有&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C 的&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的结果子类型成为值T。在当前版本的SQLite中，仅保留了子类型T的低8位。高阶位被丢弃。在将来的SQLite版本中，SQLite保留的子类型字节数可能会增加。</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（），sqlite3_result_text16（），sqlite3_result_text16le（）和sqlite3_result_text16be（）接口将应用程序定义函数的返回值设置为文本字符串，该文本字符串表示为UTF-8，UTF-16本机字节顺序，UTF-分别为16个小字节序或UTF-16大字节序。 sqlite3_result_text64（）接口将应用程序定义的函数的返回值设置为由第五个（也是最后一个）参数指定的编码的文本字符串，该参数必须是&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE之一&lt;/a&gt;。 SQLite从sqlite3_result_text *接口的第二个参数获取应用程序的文本结果。如果sqlite3_result_text *接口的第3个参数为负，则SQLite从第2个参数到第一个零字符获取结果文本。如果sqlite3_result_text *接口的第3个参数为非负数，则将第2个参数所指向的文本字节（不是字符）作为应用程序定义的函数结果。如果第三个参数为非负数，则它必须是字符串中NUL终止处出现的字符串中字节偏移量。如果字符串中出现的任何NUL字符的字节偏移小于第3个参数的值，那么结果字符串将包含嵌入式NUL，并且对带有嵌入式NUL的字符串进行运算的表达式的结果是不确定的。如果sqlite3_result_text *接口或sqlite3_result_blob的第4个参数是非NULL指针，则SQLite在使用完该结果后将调用该函数作为文本或BLOB结果的析构函数。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_STATIC，则SQLite假定文本或BLOB结果位于恒定空间中，并且不复制参数的内容，也不会在其内容上调用析构函数完成使用该结果。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_TRANSIENT，则SQLite会将结果的副本复制到从中获取的空间中&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;返回之前。</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（），sqlite3_result_text16（），sqlite3_result_text16le（）和sqlite3_result_text16be（）接口将应用程序定义函数的返回值设置为文本字符串，该文本字符串表示为UTF-8，UTF-16本机字节顺序，UTF-分别为16个小字节序或UTF-16大字节序。 sqlite3_result_text64（）接口将应用程序定义的函数的返回值设置为由第五个（也是最后一个）参数指定的编码的文本字符串，该参数必须是&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE之一&lt;/a&gt;。 SQLite从sqlite3_result_text *接口的第二个参数获取应用程序的文本结果。如果sqlite3_result_text *接口的第3个参数为负，则SQLite从第2个参数到第一个零字符获取结果文本。如果sqlite3_result_text *接口的第3个参数为非负数，则将第2个参数所指向的文本字节（不是字符）作为应用程序定义的函数结果。如果第三个参数为非负数，则它必须是字符串中NUL终止处出现的字符串中字节偏移量。如果字符串中出现的任何NUL字符的字节偏移小于第3个参数的值，那么结果字符串将包含嵌入式NUL，并且对带有嵌入式NUL的字符串进行运算的表达式的结果是不确定的。如果sqlite3_result_text *接口或sqlite3_result_blob的第4个参数是非NULL指针，则SQLite在使用完该结果后将调用该函数作为文本或BLOB结果的析构函数。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_STATIC，则SQLite假定文本或BLOB结果位于恒定空间中，并且不复制参数的内容，也不会在其内容上调用析构函数完成使用该结果。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_TRANSIENT，则SQLite会将结果的副本复制到从中获取的空间中&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;返回之前。</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）接口将应用程序定义的函数的结果设置为第二个参数指定的&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象的副本。所述sqlite3_result_value（）接口使得副本&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;使得&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;使用参数中指定可以改变或sqlite3_result_value（）无伤害返回之后被释放。甲&lt;a href=&quot;#sqlite3_value&quot;&gt;保护sqlite3_value&lt;/a&gt;对象总是可以用在一个&lt;a href=&quot;#sqlite3_value&quot;&gt;无保护sqlite3_value&lt;/a&gt;需要对象，因此任一种&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象可以与该接口时使用。</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）接口将应用程序定义的函数的结果设置为第二个参数指定的&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象的副本。所述sqlite3_result_value（）接口使得副本&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;使得&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;使用参数中指定可以改变或sqlite3_result_value（）无伤害返回之后被释放。甲&lt;a href=&quot;value&quot;&gt;保护sqlite3_value&lt;/a&gt;对象总是可以用在一个&lt;a href=&quot;value&quot;&gt;无保护sqlite3_value&lt;/a&gt;需要对象，因此任一种&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象可以与该接口时使用。</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">sqlite3_result_zeroblob(C,N)和 sqlite3_result_zeroblob64(C,N)接口将应用定义函数的结果设置为一个包含所有零字节和N个字节大小的BLOB。</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">xGeom回调的第一个参数所指向的sqlite3_rtree_geometry结构的结构如下所示。在同一个查询中,同一个MATCH操作符的每个回调都会使用完全相同的sqlite3_rtree_geometry结构。sqlite3_rtree_geometry结构的内容是由SQLite初始化的,但随后不会被修改。如果需要,回调可以自由地对结构中的pUser和xDelUser元素进行修改。</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">sqlite3_rtree_query_callback（）在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;3.8.5&lt;/a&gt;（2014-06-04）版本中可用，并且是首选接口。sqlite3_rtree_geometry_callback（）是一个较旧且较不灵活的接口，支持向后兼容。</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D，S，P，F）接口返回指向内存的指针，该内存是&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上S数据库的序列化。如果P不是NULL指针，则将以字节为单位的数据库大小写入* P.</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D，S，P，F）接口返回指向内存的指针，该内存是&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上S数据库的序列化。如果P不是NULL指针，则将以字节为单位的数据库大小写入* P.</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">sqlite3_set_auxdata(C,N,P,X)接口将P保存为应用定义函数的第N个参数的元数据。如果元数据仍然有效,后续对 sqlite3_get_auxdata(C,N)的调用将返回最近一次调用 sqlite3_set_auxdata(C,N,P,X)中的 P,如果元数据被丢弃,则返回 NULL。在每次调用sqlite3_set_auxdata(C,N,P,X)后,其中X不是NULL,SQLite将在元数据被丢弃时,准确地调用参数为P的析构函数X一次。SQLite可以在任何时候自由丢弃元数据,包括。</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">sqlite3_set_last_insert_rowid(D,R)方法允许应用程序将调用sqlite3_last_insert_rowid(D)返回的值设置为R,而无需在数据库中插入一条记录。</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">sqlite3_sleep()函数会使当前线程暂停执行至少一个在其参数中指定的毫秒数。</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">sqlite3_snapshot对象记录了数据库文件历史版本的状态信息,这样以后打开一个新的读事务,就可以看到该数据库的历史版本,而不是最新的版本。</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">sqlite3_snapshot_cmp(P1,P2)接口用于比较两个有效快照句柄的年龄。</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">sqlite3_snprintf()例程类似于标准C库中的 &quot;snprintf()&quot;。结果被写入第二个参数提供的缓冲区中,缓冲区的大小由第一个参数给出。请注意,前两个参数的顺序与snprintf()相反。这是一个历史性的意外,在不破坏向后兼容性的情况下无法修复。还要注意的是,sqlite3_snprintf()返回的是一个指向缓冲区的指针,而不是实际写入缓冲区的字符数。我们承认写入的字符数是一个更有用的返回值,但是我们现在无法在不破坏兼容性的情况下改变 sqlite3_snprintf()的实现。</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）接口设置和/或查询SQLite可能分配的堆内存量的软限制。 SQLite努力通过在堆内存使用率接近极限时减少页面缓存中保存的页面数，将堆内存使用率保持在软堆限制以下。软堆限制是&amp;ldquo;软&amp;rdquo;的，因为即使SQLite努力保持低于该限制，它也会超过该限制而不是生成&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;错误。换句话说，软堆限制仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）接口设置和/或查询SQLite可能分配的堆内存量的软限制。 SQLite努力通过在堆内存使用率接近极限时减少页面缓存中保存的页面数，将堆内存使用率保持在软堆限制以下。软堆限制是&amp;ldquo;软&amp;rdquo;的，因为即使SQLite努力保持低于该限制，它也会超过该限制而不是生成&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;错误。换句话说，软堆限制仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">如果P是由&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;创建的，则sqlite3_sql（P）接口返回指向用于创建预&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt; P 的UTF-8 SQL文本副本的指针。 sqlite3_expanded_sql（P）接口返回指向UTF-8字符串的指针，该字符串包含已准备好的语句P的SQL文本，且&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数已&lt;/a&gt;扩展。 sqlite3_normalized_sql（P）接口返回一个指向包含已准备好的语句P的规范化SQL文本的UTF-8字符串的指针。用于规范化SQL语句的语义是未指定的，并且可能会发生更改。至少，文字值将替换为合适的占位符。</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">如果P是由&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;创建的，则sqlite3_sql（P）接口返回指向用于创建预&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt; P 的UTF-8 SQL文本副本的指针。 sqlite3_expanded_sql（P）接口返回指向UTF-8字符串的指针，该字符串包含已准备好的语句P的SQL文本，且&lt;a href=&quot;../lang_expr#varparam&quot;&gt;绑定参数已&lt;/a&gt;扩展。 sqlite3_normalized_sql（P）接口返回一个指向包含已准备好的语句P的规范化SQL文本的UTF-8字符串的指针。用于规范化SQL语句的语义是未指定的，并且可能会发生更改。至少，文字值将替换为合适的占位符。</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）和sqlite3_status64（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）和sqlite3_status64（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">如果因为锁而无法提交更改,sqlite3_step()接口返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">sqlite3_step()例程如果返回的是结果集的单行,则返回SQLITE_ROW,如果执行完毕,无论是正常执行还是错误执行,则返回SQLITE_DONE。如果无法打开数据库文件,它也可能返回SQLITE_BUSY。如果返回值是SQLITE_ROW,那么可以使用下面的例程来提取结果集中该行的信息。</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S已使用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;至少执行了一次，但既未执行完毕（从&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;），又未使用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（&lt;/a&gt;）重置，则sqlite3_stmt_busy（S）接口返回true（非零）。S）。如果S是NULL指针，则sqlite3_stmt_busy（S）接口返回false。如果S不是NULL指针，也不是指向有效的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的指针，则该行为是不确定的，并且可能是不希望的。</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">如果&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S已使用&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;至少执行了一次，但既未执行完毕（从&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;），又未使用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（&lt;/a&gt;）重置，则sqlite3_stmt_busy（S）接口返回true（非零）。S）。如果S是NULL指针，则sqlite3_stmt_busy（S）接口返回false。如果S不是NULL指针，也不是指向有效的&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的指针，则该行为是不确定的，并且可能是不希望的。</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">如果准备好的语句S是EXPLAIN语句,则sqlite3_stmt_isexplain(S)接口返回1;如果语句S是EXPLAIN查询计划,则返回2。如果S是普通语句或NULL指针,sqlite3_stmt_isexplain(S)接口返回0。</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">当且仅当&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; X没有直接更改数据库文件的内容时，sqlite3_stmt_readonly（X）接口才返回true（非零）。</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">当且仅当&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; X没有直接更改数据库文件的内容时，sqlite3_stmt_readonly（X）接口才返回true（非零）。</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str对象是使用&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;创建的。</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str对象是使用&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;创建的。</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str对象被销毁，并使用&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;接口返回它创建的字符串。</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str对象被销毁，并使用&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;接口返回它创建的字符串。</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X，D，T，C，....）例程返回有关&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; X 上数据库 D中表T列C的信息。sqlite3_table_column_metadata（）接口返回SQLITE_OK并在如果指定的列存在，则使用适当的值最后五个自变量。 sqlite3_table_column_metadata（）接口返回SQLITE_ERROR，如果指定的列不存在。如果sqlite3_table_column_metadata（）的column-name参数是NULL指针，则此例程仅检查表是否存在，如果表存在则返回SQLITE_OK，否则返回SQLITE_ERROR。如果对sqlite3_table_column_metadata（X，D，T，C，...）的调用中的表名参数T为NULL，则结果为未定义行为。</target>
        </trans-unit>
        <trans-unit id="1a9220a600a9fb3a4c23d26f17dc0f839445989b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X，D，T，C，....）例程返回有关&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;X上数据库D中表T列C的信息。sqlite3_table_column_metadata（）接口返回SQLITE_OK并在如果指定的列存在，则使用适当的值来最后5个参数。如果指定的列不存在，则sqlite3_table_column_metadata（）接口返回SQLITE_ERROR。如果sqlite3_table_column_metadata（）的column-name参数是NULL指针，则此例程仅检查表是否存在，如果表存在则返回SQLITE_OK，否则返回SQLITE_ERROR。如果对sqlite3_table_column_metadata（X，D，T，C，...）的调用中的表名参数T为NULL，则结果为未定义行为。</target>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X，D，T，C，....）例程返回有关&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; X 上数据库 D中表T列C的信息。sqlite3_table_column_metadata（）接口返回SQLITE_OK并在如果指定的列存在，则使用适当的值最后五个自变量。 sqlite3_table_column_metadata（）接口返回SQLITE_ERROR，如果指定的列不存在。如果sqlite3_table_column_metadata（）的column-name参数是NULL指针，则此例程仅检查表是否存在，如果表存在则返回SQLITE_OK，否则返回SQLITE_ERROR。如果对sqlite3_table_column_metadata（X，D，T，C，...）的调用中的表名参数T为NULL，则结果为未定义行为。</target>
        </trans-unit>
        <trans-unit id="1c11863e106d03a5d69e9f5e41b5782d50d0ba8d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X，D，T，C，....）例程返回有关&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;X上数据库D中表T列C的信息。sqlite3_table_column_metadata（）接口返回SQLITE_OK并在如果指定的列存在，则使用适当的值来最后5个参数。如果指定的列不存在，则sqlite3_table_column_metadata（）接口返回SQLITE_ERROR。如果sqlite3_table_column_metadata（）的column-name参数是NULL指针，则此例程仅检查表是否存在，如果表存在则返回SQLITE_OK，否则返回SQLITE_ERROR。如果对sqlite3_table_column_metadata（X，D，T，C，...）的调用中的表名参数T为NULL，则结果为未定义行为。</target>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">sqlite3_test_control()接口用于读出SQLite的内部状态,并向SQLite注入故障,以达到测试的目的。第一个参数是一个操作代码,决定了后续所有参数的数量、意义和操作。</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">当且仅当由于将&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE的&lt;/a&gt;编译时选项设置为0 而省略了静音代码的情况下编译SQLite时，sqlite3_threadsafe（）函数才返回零。</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">当且仅当由于将&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE的&lt;/a&gt;编译时选项设置为0 而省略了静音代码的情况下编译SQLite时，sqlite3_threadsafe（）函数才返回零。</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">sqlite3_trace()回调发生在每条语句执行之前,而不是在语句编译时。</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）接口用于替换不推荐使用的旧接口&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）接口用于替换不推荐使用的旧接口&lt;a href=&quot;profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;和&lt;a href=&quot;profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D，M，X，P）接口使用属性掩码M和上下文指针P 针对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 注册跟踪回调函数X。如果X回调为NULL或M掩码为零，则禁用跟踪。M参数应为零或多个&lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt;常数的按位&amp;ldquo;或&amp;rdquo;组合。</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D，M，X，P）接口使用属性掩码M和上下文指针P 针对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 注册跟踪回调函数X。如果X回调为NULL或M掩码为零，则禁用跟踪。M参数应为零或多个&lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt;常数的按位&amp;ldquo;或&amp;rdquo;组合。</target>
        </trans-unit>
        <trans-unit id="6feba83e9a10c6c07d482619d7953b682da3b975" translate="yes" xml:space="preserve">
          <source>The sqlite3_txn_state(D,S) interface returns the current &lt;a href=&quot;#SQLITE_TXN_NONE&quot;&gt;transaction state&lt;/a&gt; of schema S in database connection D. If S is NULL, then the highest transaction state of any schema on database connection D is returned. Transaction states are (in order of lowest to highest):</source>
          <target state="translated">sqlite3_txn_state（D，S）接口返回数据库连接D中模式S的当前&lt;a href=&quot;#SQLITE_TXN_NONE&quot;&gt;事务状态&lt;/a&gt;。如果S为NULL，则返回数据库连接D上任何模式的最高事务状态。事务状态为（从低到高的顺序）：</target>
        </trans-unit>
        <trans-unit id="7f2eef336e211ebe9225c5190790ccb47f8b29b5" translate="yes" xml:space="preserve">
          <source>The sqlite3_txn_state(D,S) interface returns the current &lt;a href=&quot;c_txn_none&quot;&gt;transaction state&lt;/a&gt; of schema S in database connection D. If S is NULL, then the highest transaction state of any schema on database connection D is returned. Transaction states are (in order of lowest to highest):</source>
          <target state="translated">sqlite3_txn_state（D，S）接口返回数据库连接D中模式S的当前&lt;a href=&quot;c_txn_none&quot;&gt;事务状态&lt;/a&gt;。如果S为NULL，则返回数据库连接D上任何模式的最高事务状态。事务状态为（从低到高的顺序）：</target>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）接口使用第一个参数标识的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册一个回调函数，只要在&lt;a href=&quot;rowidtable&quot;&gt;rowid表中&lt;/a&gt;更新，插入或删除行时就将调用该函数。先前调用此函数为同一数据库连接设置的任何回调都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）接口使用第一个参数标识的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册一个回调函数，只要在&lt;a href=&quot;../rowidtable&quot;&gt;rowid表中&lt;/a&gt;更新，插入或删除行时就将调用该函数。先前调用此函数为同一数据库连接设置的任何回调都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D，C，P）函数从同一&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的上一次调用返回P参数，对于D上的第一次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D，C，P）函数从同一&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的上一次调用返回P参数，对于D上的第一次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="9e5c2049439d88f4f1e900d8863f9c93f3ca0ab3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean(F,P,B)例程假设P是一个布尔参数,并根据P的值返回true(1)或false(0)。 sqlite3_uri_boolean(F,P,B)例程在任何情况下,如果查询参数P的值是 &quot;yes&quot;、&quot;true &quot;或 &quot;on &quot;之一,或者如果该值以非零数开头,则返回true(1)。sqlite3_uri_boolean(F,P,B)例程在任何情况下,如果查询参数P的值是 &quot;no&quot;、&quot;false &quot;或 &quot;off &quot;中的一个,或者如果值以数字0开头,则返回false(0)。如果P不是F上的查询参数,或者P的值不符合上述任何一种情况,那么sqlite3_uri_boolean(F,P,B)返回(B!=0)。</target>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean(F,P,B)例程假设P是一个布尔参数,并根据P的值返回true(1)或false(0)。 sqlite3_uri_boolean(F,P,B)例程在任何情况下,如果查询参数P的值是 &quot;yes&quot;、&quot;true &quot;或 &quot;on &quot;之一,或者如果该值以非零数开头,则返回true(1)。sqlite3_uri_boolean(F,P,B)例程在任何情况下,如果查询参数P的值是 &quot;no&quot;、&quot;false &quot;或 &quot;off &quot;中的一个,或者如果值以数字0开头,则返回false(0)。如果P不是F上的查询参数,或者P的值不符合上述任何一种情况,那么sqlite3_uri_boolean(F,P,B)返回(B!=0)。</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">sqlite3_uri_int64(F,P,D)例程将P的值转换为一个64位有符号的整数,并返回该整数,如果P不存在,则返回D。如果P的值不是整数,则返回0。</target>
        </trans-unit>
        <trans-unit id="00f6b921b58342af7827ee6740ce3bd7da1204bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_key(F,N) returns a pointer to the name (not the value) of the N-th query parameter for filename F, or a NULL pointer if N is less than zero or greater than the number of query parameters minus 1. The N value is zero-based so N should be 0 to obtain the name of the first query parameter, 1 for the second parameter, and so forth.</source>
          <target state="translated">sqlite3_uri_key(F,N)返回一个指向文件名F的第N个查询参数的名称(而不是值)的指针,如果N小于0或大于查询参数的数量减1,则返回一个NULL指针。N值是基于零的,所以N应该是0,以获得第一个查询参数的名称,1是第二个参数的名称,以此类推。</target>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）接口返回指针的副本，该指针是最初注册应用程序定义函数的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的pUserData参数（第5个参数）。</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）接口返回指针的副本，该指针是最初注册应用程序定义函数的&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的pUserData参数（第5个参数）。</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">作为参数传递到&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的实现中的sqlite3_value对象受到保护。由&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的sqlite3_value对象不受保护。未受保护的sqlite3_value对象只能用作&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）的参数&lt;/a&gt;。该&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;系列的接口需要保护sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="878c26369032034cf1577de94a30701d2b72bfbf" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">作为参数传递到&lt;a href=&quot;../appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的实现中的sqlite3_value对象受到保护。由&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的sqlite3_value对象不受保护。未受保护的sqlite3_value对象只能用作&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;，&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）的参数&lt;/a&gt;。该&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;系列的接口需要保护sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="5d8545cde1bbfc4f37da956f6919362a532aef6b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">作为参数传递到&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的实现中的sqlite3_value对象受到保护。由&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的sqlite3_value对象不受保护。未受保护的sqlite3_value对象只能用作&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）的参数&lt;/a&gt;。该&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;系列的接口需要保护sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">作为参数传递到&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的实现中的sqlite3_value对象受到保护。由&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的sqlite3_value对象不受保护。未受保护的sqlite3_value对象只能用作&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;，&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）的参数&lt;/a&gt;。该&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;系列的接口需要保护sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）接口创建&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象D 的副本，并返回指向该副本的指针。即使输入不是，返回的&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;是&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。如果V为NULL或内存分配失败，则sqlite3_value_dup（V）接口返回NULL。</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）接口创建&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象D 的副本，并返回指向该副本的指针。即使输入不是，返回的&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;是&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。如果V为NULL或内存分配失败，则sqlite3_value_dup（V）接口返回NULL。</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）接口释放先前从&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;获得的&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象。如果V是NULL指针，则sqlite3_value_free（V）是无害的无操作。</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）接口释放先前从&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;获得的&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象。如果V是NULL指针，则sqlite3_value_free（V）是无害的无操作。</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">如果值X源自&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;接口之一，则sqlite3_value_frombind（X）接口返回非零值。如果X来自SQL文字值，表列和表达式，则sqlite3_value_frombind（X）返回零。</target>
        </trans-unit>
        <trans-unit id="80d4668ad9e2d92c3db76ff20be74213c969d9ff" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">如果值X源自&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;接口之一，则sqlite3_value_frombind（X）接口返回非零值。如果X来自SQL文字值，表列或表达式，则sqlite3_value_frombind（X）返回零。</target>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">如果值X源自&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;接口之一，则sqlite3_value_frombind（X）接口返回非零值。如果X来自SQL文字值，表列和表达式，则sqlite3_value_frombind（X）返回零。</target>
        </trans-unit>
        <trans-unit id="d098066d168e6b39abb688284c2a26c07f3bcf76" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">如果值X源自&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;接口之一，则sqlite3_value_frombind（X）接口返回非零值。如果X来自SQL文字值，表列或表达式，则sqlite3_value_frombind（X）返回零。</target>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）接口尝试将数字亲和力应用于该值。这意味着试图将值转换为整数或浮点数。如果可以进行这种转换而不会丢失信息（换句话说，如果该值是看起来像数字的字符串），那么将执行转换。否则，将不会发生转换。返回转换后的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）接口尝试将数字亲和力应用于该值。这意味着试图将值转换为整数或浮点数。如果可以进行这种转换而不会丢失信息（换句话说，如果该值是看起来像数字的字符串），那么将执行转换。否则，将不会发生转换。返回转换后的&lt;a href=&quot;c_blob&quot;&gt;数据类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）函数返回&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数自&lt;/a&gt;变量V的子类型。子类型信息可用于将有限量的上下文从一个SQL函数传递给另一个SQL函数。使用&lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;例程为SQL函数的返回值设置子类型。</target>
        </trans-unit>
        <trans-unit id="ac784313e8a1c8814ecb1722aed4c17998bb6a84" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）函数返回&lt;a href=&quot;../appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;参数V的子类型。子类型信息可用于将有限量的上下文从一个SQL函数传递给另一个SQL函数。使用&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;例程为SQL函数的返回值设置子类型。</target>
        </trans-unit>
        <trans-unit id="b9482d5c89729cab0c852ef903cf3adcd7fd134d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）函数返回&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;参数V的子类型。子类型信息可用于将有限量的上下文从一个SQL函数传递给另一个SQL函数。使用&lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;例程为SQL函数的返回值设置子类型。</target>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）函数返回&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数自&lt;/a&gt;变量V的子类型。子类型信息可用于将有限量的上下文从一个SQL函数传递给另一个SQL函数。使用&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;例程为SQL函数的返回值设置子类型。</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">sqlite3_value_text16()接口以主机的本机字节顺序提取UTF-16字符串。sqlite3_value_text16be()和 sqlite3_value_text16le()接口分别将UTF-16字符串提取为big-endian和little-endian。</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）接口返回&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象V 的初始数据类型的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型代码&lt;/a&gt;。返回值是&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。其他接口可能会更改sqlite3_value对象的数据类型。例如，如果数据类型最初是SQLITE_INTEGER，并且调用sqlite3_value_text（V）提取该整数的文本值，则随后对sqlite3_value_type（V）的调用可能返回SQLITE_TEXT。不确定是否发生持久内部数据类型转换，并且可能会从一个SQLite版本更改为另一个版本。</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）接口返回&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象V 的初始数据类型的&lt;a href=&quot;c_blob&quot;&gt;数据类型代码&lt;/a&gt;。返回值是&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。其他接口可能会更改sqlite3_value对象的数据类型。例如，如果数据类型最初是SQLITE_INTEGER，并且调用sqlite3_value_text（V）提取该整数的文本值，则随后对sqlite3_value_type（V）的调用可能返回SQLITE_TEXT。不确定是否发生持久内部数据类型转换，并且可能会从一个SQLite版本更改为另一个版本。</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []字符串常量包含&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;宏的文本。 sqlite3_libversion（）函数返回一个指向sqlite3_version []字符串常量的指针。提供sqlite3_libversion（）函数供DLL使用，因为DLL用户通常无法直接访问DLL中的字符串常量。 sqlite3_libversion_number（）函数返回一个等于&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;的整数。 sqlite3_sourceid（）函数返回一个指向字符串常量的指针，该字符串常量的值与&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同。除非SQLite是使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;的编辑副本构建的，否则哈希的最后四个字符可能与&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []字符串常量包含&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;宏的文本。 sqlite3_libversion（）函数返回一个指向sqlite3_version []字符串常量的指针。提供sqlite3_libversion（）函数供DLL使用，因为DLL用户通常无法直接访问DLL中的字符串常量。 sqlite3_libversion_number（）函数返回一个等于&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;的整数。 sqlite3_sourceid（）函数返回一个指向字符串常量的指针，该字符串常量的值与&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同。除非SQLite是使用&lt;a href=&quot;../amalgamation&quot;&gt;合并&lt;/a&gt;的编辑副本构建的，否则哈希的最后四个字符可能与&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">sqlite3_vfs_find()接口返回一个给定名称的VFS指针。名称是区分大小写的,名称是零结尾的UTF-8字符串。名称是以零结尾的UTF-8字符串,如果没有匹配,返回一个NULL指针。如果没有匹配,将返回一个NULL指针。如果zVfsName为NULL,则返回默认的VFS。</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">sqlite3_vsnprintf()例程是 sqlite3_snprintf()的一个varargs版本。</target>
        </trans-unit>
        <trans-unit id="356433cad1c4d15f2f32ad4a2430dfb62b71a5c8" translate="yes" xml:space="preserve">
          <source>The sqlite3_vtab_nochange() routine is an optimization. Virtual table implementations should continue to give a correct answer even if the sqlite3_vtab_nochange() interface were to always return false. In the current implementation, the sqlite3_vtab_nochange() interface does always returns false for the enhanced &lt;a href=&quot;../lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt; statement.</source>
          <target state="translated">sqlite3_vtab_nochange（）例程是一种优化。即使sqlite3_vtab_nochange（）接口始终返回false，虚拟表实现也应继续给出正确的答案。在当前实现中，sqlite3_vtab_nochange（）接口的确会为增强的&lt;a href=&quot;../lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt;语句返回false 。</target>
        </trans-unit>
        <trans-unit id="409bceec3a12ab1303b2c91da2663bb3cd84af64" translate="yes" xml:space="preserve">
          <source>The sqlite3_vtab_nochange() routine is an optimization. Virtual table implementations should continue to give a correct answer even if the sqlite3_vtab_nochange() interface were to always return false. In the current implementation, the sqlite3_vtab_nochange() interface does always returns false for the enhanced &lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt; statement.</source>
          <target state="translated">sqlite3_vtab_nochange（）例程是一种优化。即使sqlite3_vtab_nochange（）接口始终返回false，虚拟表实现也应继续给出正确的答案。在当前实现中，sqlite3_vtab_nochange（）接口的确会为增强的&lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt;语句返回false 。</target>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D，X）等同于&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D，X，&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;，0,0）。</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D，X）等同于&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D，X，&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;，0,0）。</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D，X，M，L，C）接口在模式M下对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D的数据库X运行检查点操作。状态信息被写回到L和C所指向的整数。M参数必须为有效&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;检查点模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D，X，M，L，C）接口在模式M下对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D的数据库X运行检查点操作。状态信息被写回到L和C所指向的整数。M参数必须为有效&lt;a href=&quot;c_checkpoint_full&quot;&gt;检查点模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">当更新sqlite_stat1表时,sqlite3changeset_apply()函数会自动将零长度的blob转换回NULL值。但是,如果应用程序直接在一个变化集迭代器上调用sqlite3changeset_new()、sqlite3changeset_old()或sqlite3changeset_conflict(包括传递给冲突处理回调的变化集迭代器),那么就会返回X''值。如果需要的话,应用程序必须自己将X''翻译成NULL。</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">sqlite3rbu_open(T,A,S)函数返回一个指向 &quot;sqlite3rbu &quot;对象的指针,然后传入后续的接口。</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">sqlite3session_config()接口不是线程安全的。如果在任何其他线程处于任何其他session方法中时调用它,那么结果是未定义的。此外,如果在任何会话相关对象被创建后调用它,结果也是未定义的。</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">sqlite3session_config()接口用于对session模块进行全局配置修改,以便根据应用的具体需求进行调整。</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">sqlite_compileoption_get（）SQL函数是对&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++函数的包装。此例程返回用于构建SQLite的第N个编译时选项；如果N超出范围，则返回NULL。另请参见&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">sqlite_compileoption_used（）SQL函数是对&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt; C / C ++函数的包装。当sqlite_compileoption_used（X）的参数X是作为编译时选项名称的字符串时，此例程将返回true（1）或false（0），具体取决于在构建过程中是否使用了该选项。</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_master表针对数据库架构中的每个表，索引，视图和触发器（统称为&amp;ldquo;对象&amp;rdquo;）包含一行，但sqlite_master表本身没有条目。sqlite_master表除了应用程序和程序员定义的对象外，还包含&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部模式对象的&lt;/a&gt;条目。</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_master.name列将保存对象的名称。&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;表上的UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束导致SQLite创建&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部索引&lt;/a&gt;，其名称格式为&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;，其中TABLE替换为包含约束的表的名称，N为以1开头并随每个约束加1的整数。在表定义中可见。在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中，PRIMARY KEY没有sqlite_master条目，但是PRIMARY KEY却保留了&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称，就好像sqlite_master条目确实存在一样。这将影响随后的UNIQUE约束的编号。 &amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称永远不会分配给&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，在rowid表或WITHOUT ROWID表中。</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_master.rootpage列存储了表和索引的根b树页的页码。对于定义视图、触发器和虚拟表的行,rootpage列是0或NULL。</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_master.sql列存储描述对象的SQL文本。该SQL文本是&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;，&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;，&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;，&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;或&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句，如果针对数据库文件进行评估（如果它是&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的主数据库），则会重新创建该对象。文本通常是用于创建对象的原始语句的副本，但是应用了规范化，因此文本符合以下规则：</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_master.tbl_name列保存了对象所关联的表或视图的名称,对于一个表或视图,tbl_name列是名称列的副本。对于表或视图来说,tbl_name列是name列的副本。对于一个索引,tbl_name是被索引的表的名称。对于触发器,tbl_name列存储的是导致触发器被触发的表或视图的名称。</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_master.type列将是以下文本字符串之一：&amp;ldquo; table&amp;rdquo;，&amp;ldquo; index&amp;rdquo;，&amp;ldquo; view&amp;rdquo;或&amp;ldquo; trigger&amp;rdquo;（根据定义的对象类型）。'table'字符串用于普通&lt;a href=&quot;vtab&quot;&gt;表&lt;/a&gt;和虚拟表。</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">只有使用&lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;编译时选项构建SQLite时，sqlite_offset（X）SQL函数才可用。</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">sqlite_offset(X)函数返回数据库文件中读取值的记录开头的字节偏移量。如果X不是普通表中的列,那么sqlite_offset(X)返回NULL。sqlite_offset(X)返回的值可能引用原始表或索引,这取决于查询。如果值X通常会从索引中提取,那么sqlite_offset(X)返回对应索引记录的偏移量。如果值X将从原始表中提取,那么sqlite_offset(X)返回到表记录的偏移量。</target>
        </trans-unit>
        <trans-unit id="7edde881cc83be6805465c505116db44a7c10317" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_schema table itself. The sqlite_schema table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_schema表针对数据库架构中的每个表，索引，视图和触发器（统称为&amp;ldquo;对象&amp;rdquo;）包含一行，但sqlite_schema表本身没有条目。sqlite_schema表除了应用程序和程序员定义的对象外，还包含&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部模式对象的&lt;/a&gt;条目。</target>
        </trans-unit>
        <trans-unit id="d8cd91bb0f299cfe62ef641ec65f9fe2bb5de142" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the schema, except there is no entry for the sqlite_schema table itself. See the &lt;a href=&quot;fileformat2#ffschema&quot;&gt;schema storage&lt;/a&gt; subsection of the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for additional information on how SQLite uses the sqlite_schema table internally.</source>
          <target state="translated">sqlite_schema表针对架构中的每个表，索引，视图和触发器（统称为&amp;ldquo;对象&amp;rdquo;）包含一行，但sqlite_schema表本身没有条目。有关SQLite如何在内部使用sqlite_schema表的其他信息，请参见&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档的&lt;a href=&quot;fileformat2#ffschema&quot;&gt;模式存储&lt;/a&gt;小节。</target>
        </trans-unit>
        <trans-unit id="01b38e5a9d3444c64ea7992a244995da2b49b851" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. (&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_schema.name列将保存对象的名称。 （对表的&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束使SQLite创建名称形式为&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;的&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部索引&lt;/a&gt;，其中TABLE替换为包含约束的表的名称，并且N是一个以1开头并以1递增的整数。在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中没有PRIMARY KEY的sqlite_schema条目，但是为PRIMARY KEY保留了&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称，就好像sqlite_schema条目确实存在。随后的UNIQUE约束。&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称永远不会分配给&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，无论是在rowid表中还是在WITHOUT ROWID表中。</target>
        </trans-unit>
        <trans-unit id="e02071e2d759314e2fb363a98ec697450c31c3a5" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_schema.name列将保存对象的名称。&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;表上的UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束导致SQLite创建名称形式为&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;的&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部索引&lt;/a&gt;，其中TABLE替换为包含约束的表的名称，N是一个以1开头并随每个约束加1的整数。在表定义中可见。在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中，没有用于PRIMARY KEY的sqlite_schema条目，但是为PRIMARY KEY保留了&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称，就好像sqlite_schema条目确实存在一样。这将影响随后的UNIQUE约束的编号。 &amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称永远不会分配给&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，无论是在rowid表中还是在WITHOUT ROWID表中。</target>
        </trans-unit>
        <trans-unit id="b54e4469dd50abde5034fd8f801a4d0306037ed0" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_schema.rootpage列存储了表和索引的根b树页的页码。对于定义视图、触发器和虚拟表的行,rootpage列是0或NULL。</target>
        </trans-unit>
        <trans-unit id="ee6bcf89a71c75b0fa182495e5015131f7df248c" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_schema.sql列存储描述对象的SQL文本。此SQL文本是&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;，&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;，&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;，&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;或&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句，如果针对数据库文件进行评估（如果它是&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的主数据库），则会重新创建该对象。文本通常是用于创建对象的原始语句的副本，但是应用了规范化，因此文本符合以下规则：</target>
        </trans-unit>
        <trans-unit id="d911ebef016f1f15b28a4875cf26c113309d9fa3" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_schema.tbl_name列持有对象所关联的表或视图的名称。对于表或视图,tbl_name列是name列的副本。对于一个索引,tbl_name是被索引的表的名称。对于触发器,tbl_name列存储的是导致触发器被触发的表或视图的名称。</target>
        </trans-unit>
        <trans-unit id="02a28099cf1bad8380c62abb7ce56059bbeb63ba" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_schema.type列将是以下文本字符串之一：&amp;ldquo; table&amp;rdquo;，&amp;ldquo; index&amp;rdquo;，&amp;ldquo; view&amp;rdquo;或&amp;ldquo; trigger&amp;rdquo;（根据定义的对象类型）。'table'字符串用于普通&lt;a href=&quot;vtab&quot;&gt;表&lt;/a&gt;和虚拟表。</target>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequence表是用于帮助实现&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;的内部表。每当创建具有AUTOINCREMENT整数主键的任何普通表时，都会自动创建sqlite_sequence表。创建后，sqlite_sequence表将永远存在于sqlite_master表中。它不能被丢弃。sqlite_sequence表的架构为：</target>
        </trans-unit>
        <trans-unit id="45d57d826d6c576b74670b2e5b7c281dbdfadbab" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_schema table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequence表是用于帮助实现&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;的内部表。每当创建具有AUTOINCREMENT整数主键的任何普通表时，都会自动创建sqlite_sequence表。创建后，sqlite_sequence表将永远存在于sqlite_schema表中。它不能被丢弃。sqlite_sequence表的架构为：</target>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">sqlite_source_id（）函数返回一个字符串，该字符串标识用于构建SQLite库的源代码的特定版本。sqlite_source_id（）返回的字符串是签入源代码的日期和时间，后跟该签入的SHA1哈希。该函数是&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt; C接口的SQL包装器。</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">sqlite_stat1是由&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令创建的内部表，用于保存有关表和索引的补充信息，查询计划程序可以使用这些信息来帮助其查找执行查询的更好方法。应用程序可以更新，删除，插入或删除sqlite_stat1表，但不能创建或更改sqlite_stat1表。sqlite_stat1表的架构如下：</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">一个索引的sqlite_stat2.sampleno在0到9(含)之间的sqlite_stat2条目是在索引中最左边的键值沿索引均匀间隔的点上取的样本。让C为索引中的行数。那么,采样的行数由以下公式给出</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2只在SQLite被编译为SQLITE_ENABLE_STAT2,并且SQLite版本号在3.6.18(2009-09-11)和3.7.8(2011-09-19)之间的情况下才会被创建和使用。sqlite_stat2表既不能被3.6.18之前的SQLite版本读取,也不能被3.7.8之后的SQLite版本写入。sqlite_stat2表包含了关于索引内键分布的附加信息。sqlite_stat2表的模式如下。</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">sqlite_stat2表中每行的sqlite_stat2.idx列和sqlite_stat2.tbl列标识了该行所描述的索引。在sqlite_stat2表中,每个索引通常有10行。</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">只有在使用&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;或&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译SQLite 且SQLite版本号为3.7.9（2011-11-01）或更高版本时，才使用sqlite_stat3。在3.7.9之前的任何版本的SQLite都无法读写sqlite_stat3表。如果使用了&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，并且SQLite版本号是3.8.1（2013-10-17）或更高版本，则sqlite_stat3可能被读取但未被写入。 sqlite_stat3表包含有关索引内键的分布的其他信息，查询计划人员可以使用该信息来设计更好，更快的查询算法。 sqlite_stat3表的架构如下：</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">sqlite_stat4是sqlite_stat3表的泛化,sqlite_stat3表提供了索引最左边的列的信息,而sqlite_stat4表提供了索引所有列的信息。sqlite_stat3表提供了一个索引最左边的列的信息,而sqlite_stat4表提供了索引所有列的信息。</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">sqlite_stat4仅在使用&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译SQLite 且SQLite版本号为3.8.1（2013-10-17）或更高版本时创建并使用。在3.8.1之前的任何版本的SQLite都无法读写sqlite_stat4表。 sqlite_stat4表包含有关索引中的键分布或&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的主键中的键分布的其他信息。查询计划者有时可以使用sqlite_stat4表中的其他信息来设计更好，更快的查询算法。 sqlite_stat4表的架构如下：</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">sqlite_stat4.idx列保存该行描述的索引的名称，或者对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，如果为sqlite_stat4条目，则保留该表本身的名称。</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">sqlite_stat4.nDLt列中存放了N个整数列表,其中K-th整数是指索引中前K列不同的条目数,且最左K列的总和小于样本的最左K列。</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nEq列持有N个整数列表,其中K-th整数是索引中最左K列与样本最左K列完全匹配的条目数的近似值。</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nLt列中存放了N个整数列表,其中K-th整数是指索引中K最左列总和小于样本最左列的条目数。</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">sqlite_stat4.sample列包含&lt;a href=&quot;fileformat2#record_format&quot;&gt;记录格式&lt;/a&gt;的BLOB，该BLOB 对索引列进行编码，然后对rowid表的rowid或对WITHOUT ROWID表的主键的列进行编码。 WITHOUT ROWID表本身的sqlite_stat4.sample BLOB仅包含主键的列。假设由sqlite_stat4.sample Blob编码的列数为N。对于普通rowid表上的索引，N将比索引的列数多一。对于WITHOUT ROWID表上的索引，N将是被索引的列数加上主键中的列数。对于WITHOUT ROWID表，N将为主键中的列数。</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">sqlite_stat4.tbl列拥有该行所描述的索引的表名。</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">sqlite_version（）函数返回正在运行的SQLite库的版本字符串。此函数是&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion（）&lt;/a&gt; C接口的SQL包装器。</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">SQLite数据库文件格式的稳定性以及该文件格式是跨平台的事实共同使SQLite数据库文件成为&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;的绝佳选择。美国国会图书馆通过将SQLite列为长期保存数字内容的&lt;a href=&quot;locrsf&quot;&gt;推荐存储格式&lt;/a&gt;来认可这一点。</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">标准的SQLite源代码树包含用于UNIX和Windows的内置VFS。可以使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;接口在启动时或运行时添加备用VFS 。</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">第一次打开数据库连接时,计算机的状态由右图概念性地显示出来。图中最右边的区域(标为 &quot;Disk&quot;)表示存储在大容量存储设备上的信息。每个矩形是一个扇区。蓝色代表这些扇区包含原始数据。中间的区域是操作系统的磁盘缓存。在我们的例子中,缓存是冷的,这通过将磁盘缓存的矩形留空来表示。图中左侧区域显示的是使用SQLite的进程的内存内容。数据库连接刚刚打开,还没有读取任何信息,所以用户空间是空的。</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">上面的语句创建了一个名为 &quot;newtab &quot;的新地缘表。每个地缘表都包含一个内置的整数 &quot;rowid &quot;列和一个&quot;_shape &quot;列,其中包含了与表中该行相关联的多边形。上面的例子还定义了三个名为 &quot;a&quot;、&quot;b &quot;和 &quot;c &quot;的辅助数据列,可以存储应用程序需要与每个多边形相关联的任何附加信息。如果不需要存储辅助信息,可以省略辅助列列表。</target>
        </trans-unit>
        <trans-unit id="d3ed1fe19431b8dcc87a89320be8ef338ed550ea" translate="yes" xml:space="preserve">
          <source>The statement above has three ordinary columns, &quot;a&quot; (the PRIMARY KEY), &quot;b&quot;, and &quot;c&quot;, and two generated columns &quot;d&quot; and &quot;e&quot;.</source>
          <target state="translated">上面的语句有 &quot;a&quot;(primary key)、&quot;b&quot;、&quot;c &quot;三个普通列和 &quot;d&quot;、&quot;e &quot;两个生成列。</target>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">上面的陈述在某些语法上可能看起来不正确。有关说明，请参阅描述&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;简单fts查询&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">语句日志被赋予一个随机的名称,不一定与主数据库在同一目录下,并在事务结束时自动删除。语句日志的大小与导致创建语句日志的UPDATE或INSERT语句所实现的变化大小成正比。</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">status方法基本上是&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt; C语言接口的包装。</target>
        </trans-unit>
        <trans-unit id="c5cf163b4b04538a4fb65ca4f4e01be3e19142a2" translate="yes" xml:space="preserve">
          <source>The step function for an aggregate should always begin with a call to the &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; routine to fetch the persistent state of the aggregate function. On the first invocation of the step() function, the aggregate context is initialized to a block of memory that is N bytes in size, where N is the second parameter to sqlite3_aggregate_context() and that memory is zeroed. On all subsequent calls to the step() function, the same block of memory is returned. Except, sqlite3_aggregate_context() might return NULL in the case of an out-of-memory error, so aggregate functions should be prepared to deal with that case.</source>
          <target state="translated">聚合的step函数应始终始于对&lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;例程的调用，以获取聚合函数的持久状态。第一次调用step（）函数时，聚合上下文将初始化为大小为N个字节的内存块，其中N是sqlite3_aggregate_context（）的第二个参数，并且该内存为零。在对step（）函数的所有后续调用中，将返回相同的内存块。除非在内存不足错误的情况下sqlite3_aggregate_context（）可能返回NULL，所以应该准备聚合函数来处理这种情况。</target>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">该策略是使用&lt;b&gt;sqlite_compile&lt;/b&gt;编译单个SQL语句，然后多次调用&lt;b&gt;sqlite_step（&lt;/b&gt;对于输出的每一行一次），最后在SQL完成执行后调用&lt;b&gt;sqlite_finalize&lt;/b&gt;进行清理。</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">长度为P1(字节)的字符串值P4存储在寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="9a7f87028156aaa8a8bf754d55b553e046a12fec" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="translated">此例程返回的字符串值由数据库连接拥有和管理。直到数据库N是值将是有效的&lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt; -ed或直到数据库连接关闭。</target>
        </trans-unit>
        <trans-unit id="cb38b0feb448edc668a127b1d9c6a6f2f876060a" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="translated">此例程返回的字符串值由数据库连接拥有和管理。直到数据库N是值将是有效的&lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; -ed或直到数据库连接关闭。</target>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）和sqlite3_normalized_sql（P）返回的字符串由SQLite管理，并在准备好的语句完成后自动释放。另一方面，sqlite3_expanded_sql（P）返回的字符串是从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的，并且必须由应用程序通过将其传递给&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）和sqlite3_normalized_sql（P）返回的字符串由SQLite管理，并在准备好的语句完成后自动释放。另一方面，sqlite3_expanded_sql（P）返回的字符串是从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的，并且必须由应用程序通过将其传递给&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">子查询和外层查询都不使用LIMIT。</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">子查询和外查询不都有ORDER BY子句。</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">子查询不使用LIMIT或外查询不使用聚合。</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">子查询没有使用LIMIT,或者外查询不是连接。</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">子查询不使用OFFSET。</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">子查询中有一个FROM子句。</target>
        </trans-unit>
        <trans-unit id="36f95cae80ab7a78b4e298e8fc4b136f62be389f" translate="yes" xml:space="preserve">
          <source>The subquery in the FROM clause computes the amount by which the inventory should be reduced for each itemId. That subquery is joined against the inventory table and the quantity of each affected inventory row is reduced by the appropriate amount.</source>
          <target state="translated">FROM子句中的子查询计算出每个项目ID的库存量应减少的数量。该子查询与库存表相连接,受影响的每一行库存的数量都会减少适当的数量。</target>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">子查询不是DISTINCT。</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">子查询可能不是递归CTE。</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">替换字符(unicode码点26)。</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">上面SQL视图中的substr()函数返回rbu_control参数的文本,但去掉了第一个字符(对应于列 &quot;i &quot;的那个字符,FTS表不需要)。</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">函数substr(X,Y,Z)返回一个从Y-th字符开始的输入字符串X的子串,长度为Z字符。如果省略Z,那么substr(X,Y)将返回从Y-th开始的字符串X的所有字符。X的最左边的字符是1号。如果Y是负数,那么子串的第一个字符是从右边而不是左边开始数的。如果Z是负数,那么返回Y-th字符前面的abs(Z)字符。如果X是一个字符串,那么字符索引指的是实际的UTF-8字符。如果X是一个BLOB,那么索引指的是字节。</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">所有 &quot;四个 &quot;值的总和。用于计算 &quot;avg(four)&quot;。</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">sum()和total()集合函数返回组中所有非NULL值的总和。如果没有非NULL的输入行,那么sum()返回NULL,但是total()返回0.0。对于没有行的总和来说,NULL通常不是一个有用的结果,但是SQL标准要求这样做,而且大多数其他的SQL数据库引擎都是这样实现sum()的,所以为了兼容,SQLite也是这样做的。提供非标准的total()函数是为了方便地解决SQL语言中的这个设计问题。</target>
        </trans-unit>
        <trans-unit id="c8cc59294c9d81aba99fd5de24fb6dc6b41b0132" translate="yes" xml:space="preserve">
          <source>The super-journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">仅为涉及多个数据库文件的&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作创建超级日志文件，其中至少两个数据库满足以下所有要求：</target>
        </trans-unit>
        <trans-unit id="8ee67fa1e83c36dfa202c1d70aacf19927252737" translate="yes" xml:space="preserve">
          <source>The super-journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The super-journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The super-journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the super-journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">当单个事务对使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句添加到单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;中的多个数据库进行更改时，超级日志文件将用作原子提交过程的一部分。超级新闻文件始终与主数据库文件位于同一目录中（主数据库文件是在创建&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的原始&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;调用中标识的数据库）），并带有随机后缀。超级新闻文件包含在事务期间更改的所有各种附加辅助数据库的名称。删除超级日志文件时，将提交多数据库事务。有关更多详细信息，请参见标题为&amp;ldquo; &lt;a href=&quot;atomiccommit&quot;&gt;SQLite&lt;/a&gt;中的原子提交&amp;rdquo;的文档。</target>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">仅在WITHOUT ROWID表中抑制索引条目的键后缀中的冗余列。在普通的rowid表中，即使&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列是被索引的列之一，索引条目也总是以rowid结尾。</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">swarmvtab 实现可以在任何时候打开或关闭数据库。默认情况下,它试图将同时打开的数据库文件的最大数量限制为九个。这并不是一个硬性的限制-可以构建一个会导致 swarmvtab 超过这个限制的方案。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
